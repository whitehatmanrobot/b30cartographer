varSingle, __out PROPVARIANT *ppropvarVector);
PSSTDAPI InitPropVariantFromStrRet(__inout STRRET *pstrret, __in_opt PCUITEMID_CHILD pidl, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromBooleanVector(__in_ecount_opt(cElems) const BOOL *prgf, __in ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromInt16Vector(__in_ecount_opt(cElems) const SHORT *prgn, __in ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromUInt16Vector(__in_ecount_opt(cElems) const USHORT *prgn, __in ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromInt32Vector(__in_ecount_opt(cElems) const LONG *prgn, __in ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromUInt32Vector(__in_ecount_opt(cElems) const ULONG *prgn, __in ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromInt64Vector(__in_ecount_opt(cElems) const LONGLONG *prgn, __in ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromUInt64Vector(__in_ecount_opt(cElems) const ULONGLONG *prgn, __in ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromDoubleVector(__in_ecount_opt(cElems) const DOUBLE *prgn, __in ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromFileTimeVector(__in_ecount_opt(cElems) const FILETIME *prgft, __in ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromStringVector(__in_ecount_opt(cElems) PCWSTR *prgsz, __in ULONG cElems, __out PROPVARIANT *ppropvar);
PSSTDAPI InitPropVariantFromStringAsVector(__in_opt PCWSTR psz, __out PROPVARIANT *ppropvar);
#ifdef __cplusplus
HRESULT  InitPropVariantFromBoolean(__in BOOL fVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromInt16(__in SHORT nVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromUInt16(__in USHORT uiVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromInt32(__in LONG lVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromUInt32(__in ULONG ulVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromInt64(__in LONGLONG llVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromUInt64(__in ULONGLONG ullVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromDouble(__in DOUBLE dblVal, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromString(__in PCWSTR psz, __out PROPVARIANT *ppropvar);
HRESULT  InitPropVariantFromGUIDAsBuffer(__in REFGUID guid, __out PROPVARIANT *ppropvar);
BOOL     IsPropVariantVector(__in REFPROPVARIANT propvar);
BOOL     IsPropVariantString(__in REFPROPVARIANT propvar);
#endif

// Extract data from a propvariant
PSSTDAPI_(BOOL)      PropVariantToBooleanWithDefault(__in REFPROPVARIANT propvarIn, __in BOOL fDefault);
PSSTDAPI_(SHORT)     PropVariantToInt16WithDefault(__in REFPROPVARIANT propvarIn, __in SHORT iDefault);
PSSTDAPI_(USHORT)    PropVariantToUInt16WithDefault(__in REFPROPVARIANT propvarIn, __in USHORT uiDefault);
PSSTDAPI_(LONG)      PropVariantToInt32WithDefault(__in REFPROPVARIANT propvarIn, __in LONG lDefault);
PSSTDAPI_(ULONG)     PropVariantToUInt32WithDefault(__in REFPROPVARIANT propvarIn, __in ULONG ulDefault);
PSSTDAPI_(LONGLONG)  PropVariantToInt64WithDefault(__in REFPROPVARIANT propvarIn, __in LONGLONG llDefault);
PSSTDAPI_(ULONGLONG) PropVariantToUInt64WithDefault(__in REFPROPVARIANT propvarIn, __in ULONGLONG ullDefault);
PSSTDAPI_(DOUBLE)    PropVariantToDoubleWithDefault(__in REFPROPVARIANT propvarIn, __in DOUBLE dblDefault);
PSSTDAPI_(PCWSTR)    PropVariantToStringWithDefault(__in REFPROPVARIANT propvarIn, __in_opt LPCWSTR pszDefault);

PSSTDAPI             PropVariantToBoolean(__in REFPROPVARIANT propvarIn, __out BOOL *pfRet);
PSSTDAPI             PropVariantToInt16(__in REFPROPVARIANT propvarIn, __out SHORT *piRet);
PSSTDAPI             PropVariantToUInt16(__in REFPROPVARIANT propvarIn, __out USHORT *puiRet);
PSSTDAPI             PropVariantToInt32(__in REFPROPVARIANT propvarIn, __out LONG *plRet);
PSSTDAPI             PropVariantToUInt32(__in REFPROPVARIANT propvarIn, __out ULONG *pulRet);
PSSTDAPI             PropVariantToInt64(__in REFPROPVARIANT propvarIn, __out LONGLONG *pllRet);
PSSTDAPI             PropVariantToUInt64(__in REFPROPVARIANT propvarIn, __out ULONGLONG *pullRet);
PSSTDAPI             PropVariantToDouble(__in REFPROPVARIANT propvarIn, __out DOUBLE *pdblRet);
PSSTDAPI             PropVariantToBuffer(__in REFPROPVARIANT propvar, __out_bcount(cb) void *pv, __in UINT cb);
PSSTDAPI             PropVariantToString(__in REFPROPVARIANT propvar, __out_ecount(cch) PWSTR psz, __in UINT cch);
PSSTDAPI             PropVariantToGUID(__in REFPROPVARIANT propvar, __out GUID *pguid);
__checkReturn PSSTDAPI PropVariantToStringAlloc(__in REFPROPVARIANT propvar, __deref_out PWSTR *ppszOut);
__checkReturn PSSTDAPI PropVariantToBSTR(__in REFPROPVARIANT propvar, __deref_out BSTR *pbstrOut);
__checkReturn PSSTDAPI PropVariantToStrRet(__in REFPROPVARIANT propvar, __out STRRET *pstrret);
PSSTDAPI             PropVariantToFileTime(__in REFPROPVARIANT propvar, __in PSTIME_FLAGS pstfOut, __out FILETIME* pftOut);
#ifdef __cplusplus
HRESULT              PropVariantToCLSID(__in REFPROPVARIANT propvar, __out CLSID *pclsid);
#endif

// Returns element count of a VT_VECTOR or VT_ARRAY value; or 1 otherwise
PSSTDAPI_(ULONG) PropVariantGetElementCount(__in REFPROPVARIANT propvar);

// Extract data from a propvariant into a vector
PSSTDAPI PropVariantToBooleanVector(__in REFPROPVARIANT propvar, __out_ecount_part(crgf, *pcElem) BOOL *prgf, __in ULONG crgf, __out ULONG *pcElem);
PSSTDAPI PropVariantToInt16Vector(__in REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) SHORT *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToUInt16Vector(__in REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) USHORT *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToInt32Vector(__in REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) LONG *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToUInt32Vector(__in REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) ULONG *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToInt64Vector(__in REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) LONGLONG *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToUInt64Vector(__in REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) ULONGLONG *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToDoubleVector(__in REFPROPVARIANT propvar, __out_ecount_part(crgn, *pcElem) DOUBLE *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI PropVariantToFileTimeVector(__in REFPROPVARIANT propvar, __out_ecount_part(crgft, *pcElem) FILETIME *prgft, __in ULONG crgft, __out ULONG *pcElem);
__checkReturn PSSTDAPI PropVariantToStringVector(__in REFPROPVARIANT propvar, __out_ecount_part(crgsz, *pcElem) PWSTR *prgsz, __in ULONG crgsz, __out ULONG *pcElem);


// Extract data from a propvariant and return an newly allocated vector (free with CoTaskMemFree)
__checkReturn PSSTDAPI PropVariantToBooleanVectorAlloc(__in REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) BOOL **pprgf, __out ULONG *pcElem);
__checkReturn PSSTDAPI PropVariantToInt16VectorAlloc(__in REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) SHORT **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI PropVariantToUInt16VectorAlloc(__in REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) USHORT **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI PropVariantToInt32VectorAlloc(__in REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) LONG **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI PropVariantToUInt32VectorAlloc(__in REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) ULONG **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI PropVariantToInt64VectorAlloc(__in REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) LONGLONG **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI PropVariantToUInt64VectorAlloc(__in REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) ULONGLONG **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI PropVariantToDoubleVectorAlloc(__in REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) DOUBLE **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI PropVariantToFileTimeVectorAlloc(__in REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) FILETIME **pprgft, __out ULONG *pcElem);
__checkReturn PSSTDAPI PropVariantToStringVectorAlloc(__in REFPROPVARIANT propvar, __deref_out_ecount(*pcElem) PWSTR **pprgsz, __out ULONG *pcElem);

// Extract a single element from a propvariant.  If it is a VT_VECTOR or VT_ARRAY, returns the element you request.
// Otherwise iElem must equal 0 and the function will returns the value.
PSSTDAPI PropVariantGetBooleanElem(__in REFPROPVARIANT propvar, __in ULONG iElem, __out BOOL *pfVal);
PSSTDAPI PropVariantGetInt16Elem(__in REFPROPVARIANT propvar, __in ULONG iElem, __out SHORT *pnVal);
PSSTDAPI PropVariantGetUInt16Elem(__in REFPROPVARIANT propvar, __in ULONG iElem, __out USHORT *pnVal);
PSSTDAPI PropVariantGetInt32Elem(__in REFPROPVARIANT propvar, __in ULONG iElem, __out LONG *pnVal);
PSSTDAPI PropVariantGetUInt32Elem(__in REFPROPVARIANT propvar, __in ULONG iElem, __out ULONG *pnVal);
PSSTDAPI PropVariantGetInt64Elem(__in REFPROPVARIANT propvar, __in ULONG iElem, __out LONGLONG *pnVal);
PSSTDAPI PropVariantGetUInt64Elem(__in REFPROPVARIANT propvar, __in ULONG iElem, __out ULONGLONG *pnVal);
PSSTDAPI PropVariantGetDoubleElem(__in REFPROPVARIANT propvar, __in ULONG iElem, __out DOUBLE *pnVal);
PSSTDAPI PropVariantGetFileTimeElem(__in REFPROPVARIANT propvar, __in ULONG iElem, __out FILETIME *pftVal);
__checkReturn PSSTDAPI PropVariantGetStringElem(__in REFPROPVARIANT propvar, __in ULONG iElem, __deref_out PWSTR *ppszVal);
#ifdef __cplusplus
HRESULT  PropVariantGetElem(__in REFPROPVARIANT propvarIn, __in ULONG iElem, __out PROPVARIANT *ppropvar);
#endif

// Helpers
PSSTDAPI_(void) ClearPropVariantArray(__inout_ecount(cVars) PROPVARIANT *rgPropVar, __in UINT cVars);

typedef enum 
{
    PVCU_DEFAULT = 0,
    PVCU_SECOND  = 1,
    PVCU_MINUTE  = 2,
    PVCU_HOUR    = 3,
    PVCU_DAY     = 4,
    PVCU_MONTH   = 5,
    PVCU_YEAR    = 6
} PROPVAR_COMPARE_UNIT;

enum tagPROPVAR_COMPARE_FLAGS
{
    PVCF_DEFAULT                 = 0x00000000,   // When comparing strings, use StrCmpLogical
    PVCF_TREATEMPTYASGREATERTHAN = 0x00000001,   // Empty/null values are greater-than non-empty values
    PVCF_USESTRCMP               = 0x00000002,   // When comparing strings, use StrCmp
    PVCF_USESTRCMPC              = 0x00000004,   // When comparing strings, use StrCmpC
    PVCF_USESTRCMPI              = 0x00000008,   // When comparing strings, use StrCmpI
    PVCF_USESTRCMPIC             = 0x00000010,   // When comparing strings, use StrCmpIC
};
typedef int PROPVAR_COMPARE_FLAGS;

// Comparisons
PSSTDAPI_(int) PropVariantCompareEx(__in REFPROPVARIANT propvar1, __in REFPROPVARIANT propvar2, __in PROPVAR_COMPARE_UNIT unit, __in PROPVAR_COMPARE_FLAGS flags);
#ifdef __cplusplus
int PropVariantCompare(__in REFPROPVARIANT propvar1, __in REFPROPVARIANT propvar2);
#endif

enum tagPROPVAR_CHANGE_FLAGS
{
    PVCHF_DEFAULT           = 0x00000000,
    PVCHF_NOVALUEPROP       = 0x00000001,       // Maps to VARIANT_NOVALUEPROP for VariantChangeType
    PVCHF_ALPHABOOL         = 0x00000002,       // Maps to VARIANT_ALPHABOOL for VariantChangeType
    PVCHF_NOUSEROVERRIDE    = 0x00000004,       // Maps to VARIANT_NOUSEROVERRIDE for VariantChangeType
    PVCHF_LOCALBOOL         = 0x00000008,       // Maps to VARIANT_LOCALBOOL for VariantChangeType
    PVCHF_NOHEXSTRING       = 0x00000010,       // Don't convert a string that looks like hexadecimal (0xABCD) to the numerical equivalent
};
typedef int PROPVAR_CHANGE_FLAGS;

// Coersions
PSSTDAPI PropVariantChangeType(__out PROPVARIANT *ppropvarDest, __in REFPROPVARIANT propvarSrc, __in PROPVAR_CHANGE_FLAGS flags, __in VARTYPE vt);

// Conversions
PSSTDAPI PropVariantToVariant(__in const PROPVARIANT *pPropVar, __out VARIANT *pVar);
PSSTDAPI VariantToPropVariant(__in const VARIANT* pVar, __out PROPVARIANT* pPropVar);

// Stg functions
__checkReturn PSSTDAPI StgSerializePropVariant(
            __in const PROPVARIANT* ppropvar,
            __deref_out_bcount(*pcb) SERIALIZEDPROPERTYVALUE** ppProp,
            __out ULONG* pcb);
    
PSSTDAPI StgDeserializePropVariant(
            __in const SERIALIZEDPROPERTYVALUE* pprop,
            __in ULONG cbMax,
            __out PROPVARIANT* ppropvar);



//================
//
// Variant Helpers
//
//================

#ifdef __cplusplus
BOOL IsVarTypeFloat(__in VARTYPE vt);
BOOL IsVariantArray(__in REFVARIANT var);
BOOL IsVariantString(__in REFVARIANT var);
BOOL IsVarTypeNumber(__in VARTYPE vt);
BOOL IsVarTypeInteger(__in VARTYPE vt);
#endif

// Initialize a VARIANT
PSSTDAPI InitVariantFromResource(__in HINSTANCE hinst, __in UINT id, __out VARIANT *pvar);
PSSTDAPI InitVariantFromBuffer(__in_bcount(cb) const void *pv, __in UINT cb, __out VARIANT *pvar);
PSSTDAPI InitVariantFromGUIDAsString(__in REFGUID guid, __out VARIANT *pvar);
PSSTDAPI InitVariantFromFileTime(__in const FILETIME *pft, __out VARIANT *pvar);
PSSTDAPI InitVariantFromFileTimeArray(__in_ecount_opt(cElems) const FILETIME *prgft, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromStrRet(__in STRRET *pstrret, __in PCUITEMID_CHILD pidl, __out VARIANT *pvar);
PSSTDAPI InitVariantFromVariantArrayElem(__in REFVARIANT varIn, __in ULONG iElem, __out VARIANT *pvar);
PSSTDAPI InitVariantFromBooleanArray(__in_ecount(cElems) const BOOL *prgf, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromInt16Array(__in_ecount(cElems) const SHORT *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromUInt16Array(__in_ecount(cElems) const USHORT *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromInt32Array(__in_ecount(cElems) const LONG *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromUInt32Array(__in_ecount(cElems) const ULONG *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromInt64Array(__in_ecount(cElems) const LONGLONG *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromUInt64Array(__in_ecount(cElems) const ULONGLONG *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromDoubleArray(__in_ecount(cElems) const DOUBLE *prgn, __in ULONG cElems, __out VARIANT *pvar);
PSSTDAPI InitVariantFromStringArray(__in_ecount(cElems) PCWSTR *prgsz, __in ULONG cElems, __out VARIANT *pvar);
#ifdef __cplusplus
HRESULT  InitVariantFromBoolean(__in BOOL fVal, __out VARIANT *pvar);
HRESULT  InitVariantFromInt16(__in SHORT iVal, __out VARIANT *pvar);
HRESULT  InitVariantFromUInt16(__in USHORT uiVal, __out VARIANT *pvar);
HRESULT  InitVariantFromInt32(__in LONG lVal, __out VARIANT *pvar);
HRESULT  InitVariantFromUInt32(__in ULONG ulVal, __out VARIANT *pvar);
HRESULT  InitVariantFromInt64(__in LONGLONG llVal, __out VARIANT *pvar);
HRESULT  InitVariantFromUInt64(__in ULONGLONG ullVal, __out VARIANT *pvar);
HRESULT  InitVariantFromDouble(__in DOUBLE dblVal, __out VARIANT *pvar);
HRESULT  InitVariantFromString(__in PCWSTR psz, __out VARIANT *pvar);
HRESULT  InitVariantFromDispatch(__in_opt IDispatch* pdisp, __out VARIANT *pvar);
HRESULT  InitVariantFromDosDateTime(__in WORD wDate, __in WORD wTime, __out VARIANT *pvar);
HRESULT  InitVariantFromGUIDAsBuffer(__in REFGUID guid, __out VARIANT *pvar);
#endif

// Extract data from a VARIANT
PSSTDAPI_(BOOL)       VariantToBooleanWithDefault(__in REFVARIANT varIn, __in BOOL fDefault);
PSSTDAPI_(SHORT)      VariantToInt16WithDefault(__in REFVARIANT varIn, __in SHORT iDefault);
PSSTDAPI_(USHORT)     VariantToUInt16WithDefault(__in REFVARIANT varIn, __in USHORT uiDefault);
PSSTDAPI_(LONG)       VariantToInt32WithDefault(__in REFVARIANT varIn, __in LONG lDefault);
PSSTDAPI_(ULONG)      VariantToUInt32WithDefault(__in REFVARIANT varIn, __in ULONG ulDefault);
PSSTDAPI_(LONGLONG)   VariantToInt64WithDefault(__in REFVARIANT varIn, __in LONGLONG llDefault);
PSSTDAPI_(ULONGLONG)  VariantToUInt64WithDefault(__in REFVARIANT varIn, __in ULONGLONG ullDefault);
PSSTDAPI_(DOUBLE)     VariantToDoubleWithDefault(__in REFVARIANT varIn, __in DOUBLE dblDefault);
PSSTDAPI_(PCWSTR)     VariantToStringWithDefault(__in REFVARIANT varIn, __in_opt LPCWSTR pszDefault);

PSSTDAPI              VariantToBoolean(__in REFVARIANT varIn, __out BOOL *pfRet);
PSSTDAPI              VariantToInt16(__in REFVARIANT varIn, __out SHORT *piRet);
PSSTDAPI              VariantToUInt16(__in REFVARIANT varIn, __out USHORT *puiRet);
PSSTDAPI              VariantToInt32(__in REFVARIANT varIn, __out LONG *plRet);
PSSTDAPI              VariantToUInt32(__in REFVARIANT varIn, __out ULONG *pulRet);
PSSTDAPI              VariantToInt64(__in REFVARIANT varIn, __out LONGLONG *pllRet);
PSSTDAPI              VariantToUInt64(__in REFVARIANT varIn, __out ULONGLONG *pullRet);
PSSTDAPI              VariantToDouble(__in REFVARIANT varIn, __out DOUBLE *pdblRet);
PSSTDAPI              VariantToBuffer(__in REFVARIANT varIn, __out_bcount(cb) void *pv, __in UINT cb);
PSSTDAPI              VariantToGUID(__in REFVARIANT varIn, __out GUID *pguid);
PSSTDAPI              VariantToString(__in REFVARIANT varIn, __out_ecount(cchBuf) PWSTR pszBuf, __in UINT cchBuf);
__checkReturn PSSTDAPI VariantToStringAlloc(__in REFVARIANT varIn, __deref_out PWSTR *ppszBuf);
PSSTDAPI              VariantToDosDateTime(__in REFVARIANT varIn, __out WORD *pwDate, __out WORD *pwTime);
__checkReturn PSSTDAPI VariantToStrRet(__in REFVARIANT varIn, __out STRRET *pstrret);
PSSTDAPI              VariantToFileTime(__in REFVARIANT varIn, __in PSTIME_FLAGS stfOut, __out FILETIME* pftOut);

// Get the element count.  Returns number of elements for values of type VT_ARRAY; returns 1 otherwise.
PSSTDAPI_(ULONG) VariantGetElementCount(__in REFVARIANT varIn);

// Extract data from a VARIANT into a vector
PSSTDAPI VariantToBooleanArray(__in REFVARIANT var, __out_ecount_part(crgn, *pcElem) BOOL *prgf, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToInt16Array(__in REFVARIANT var, __out_ecount_part(crgn, *pcElem) SHORT *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToUInt16Array(__in REFVARIANT var, __out_ecount_part(crgn, *pcElem) USHORT *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToInt32Array(__in REFVARIANT var, __out_ecount_part(crgn, *pcElem) LONG *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToUInt32Array(__in REFVARIANT var, __out_ecount_part(crgn, *pcElem) ULONG *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToInt64Array(__in REFVARIANT var, __out_ecount_part(crgn, *pcElem) LONGLONG *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToUInt64Array(__in REFVARIANT var, __out_ecount_part(crgn, *pcElem) ULONGLONG *prgn, __in ULONG crgn, __out ULONG *pcElem);
PSSTDAPI VariantToDoubleArray(__in REFVARIANT var, __out_ecount_part(crgn, *pcElem) DOUBLE *prgn, __in ULONG crgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI VariantToStringArray(__in REFVARIANT var, __out_ecount_part(crgsz, *pcElem) PWSTR *prgsz, __in ULONG crgsz, __out ULONG *pcElem);

// Extract data from a VARIANT into a newly allocated vector (free with CoTaskMemFree)
__checkReturn PSSTDAPI VariantToBooleanArrayAlloc(__in REFVARIANT var, __deref_out_ecount(*pcElem) BOOL **pprgf, __out ULONG *pcElem);
__checkReturn PSSTDAPI VariantToInt16ArrayAlloc(__in REFVARIANT var, __deref_out_ecount(*pcElem) SHORT **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI VariantToUInt16ArrayAlloc(__in REFVARIANT var, __deref_out_ecount(*pcElem) USHORT **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI VariantToInt32ArrayAlloc(__in REFVARIANT var, __deref_out_ecount(*pcElem) LONG **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI VariantToUInt32ArrayAlloc(__in REFVARIANT var, __deref_out_ecount(*pcElem) ULONG **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI VariantToInt64ArrayAlloc(__in REFVARIANT var, __deref_out_ecount(*pcElem) LONGLONG **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI VariantToUInt64ArrayAlloc(__in REFVARIANT var, __deref_out_ecount(*pcElem) ULONGLONG **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI VariantToDoubleArrayAlloc(__in REFVARIANT var, __deref_out_ecount(*pcElem) DOUBLE **pprgn, __out ULONG *pcElem);
__checkReturn PSSTDAPI VariantToStringArrayAlloc(__in REFVARIANT var, __deref_out_ecount(*pcElem) PWSTR **pprgsz, __out ULONG *pcElem);

// Get a single element of a VARIANT.  If it is type VT_ARRAY, returns a the requested element.  Otherwise
// iElem must equal 0 and the function returns the value.
PSSTDAPI VariantGetBooleanElem(__in REFVARIANT var, __in ULONG iElem, __out BOOL *pfVal);
PSSTDAPI VariantGetInt16Elem(__in REFVARIANT var, __in ULONG iElem, __out SHORT *pnVal);
PSSTDAPI VariantGetUInt16Elem(__in REFVARIANT var, __in ULONG iElem, __out USHORT *pnVal);
PSSTDAPI VariantGetInt32Elem(__in REFVARIANT var, __in ULONG iElem, __out LONG *pnVal);
PSSTDAPI VariantGetUInt32Elem(__in REFVARIANT var, __in ULONG iElem, __out ULONG *pnVal);
PSSTDAPI VariantGetInt64Elem(__in REFVARIANT var, __in ULONG iElem, __out LONGLONG *pnVal);
PSSTDAPI VariantGetUInt64Elem(__in REFVARIANT var, __in ULONG iElem, __out ULONGLONG *pnVal);
PSSTDAPI VariantGetDoubleElem(__in REFVARIANT var, __in ULONG iElem, __out DOUBLE *pnVal);
__checkReturn PSSTDAPI VariantGetStringElem(__in REFVARIANT var, __in ULONG iElem, __deref_out PWSTR *ppszVal);
#ifdef __cplusplus
HRESULT  VariantGetElem(__in REFVARIANT varIn, __in ULONG iElem, __out VARIANT *pvar);
#endif

// Helpers
PSSTDAPI_(void) ClearVariantArray(__inout_ecount(cvars) VARIANT *pvars, __in UINT cvars);
PSSTDAPI_(int) VariantCompare(__in REFVARIANT var1, __in REFVARIANT var2);

//===========================
//
// Property-specific notions
//
//===========================


// The progress bar property control uses a specially formatted PROPVARIANT to convey the look of the progress bar
// propvar.vt = VT_UI4
// propvar.caul.pElems[0] = current progress
// propvar.caul.pElems[1] = total progress
// propvar.caul.pElems[2] = DRAWPROGRESSFLAGS (see below);
typedef enum DRAWPROGRESSFLAGS
{
    DPF_NONE                = 0x0,  // No progress flags.
    DPF_MARQUEE             = 0x1,  // The progress bar should draw in marquee mode.
    DPF_MARQUEE_COMPLETE    = 0x2,  // The marquee format progress bar has completed.
    DPF_ERROR               = 0x4,  // The progress bar should be drawn in the error state.
    DPF_WARNING             = 0x8,  // The progress bar should be drawn in the warning state.
    DPF_STOPPED             = 0x10, // The progress bar is stopped.
} DRAWPROGRESSFLAGS;

//================
//
// Inline Helpers
//
//================

#if defined(__cplusplus) && !defined(NO_PROPVAR_INLINES)
inline HRESULT InitPropVariantFromBoolean(__in BOOL fVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_BOOL;
    ppropvar->boolVal = fVal ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

inline HRESULT InitPropVariantFromInt16(__in SHORT nVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_I2;
    ppropvar->iVal = nVal;
    return S_OK;
}

inline HRESULT InitPropVariantFromUInt16(__in USHORT uiVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_UI2;
    ppropvar->uiVal = uiVal;
    return S_OK;
}

inline HRESULT InitPropVariantFromInt32(__in LONG lVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_I4;
    ppropvar->lVal = lVal;
    return S_OK;
}

inline HRESULT InitPropVariantFromUInt32(__in ULONG ulVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_UI4;
    ppropvar->ulVal = ulVal;
    return S_OK;
}

inline HRESULT InitPropVariantFromInt64(__in LONGLONG llVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_I8;
    ppropvar->hVal.QuadPart = llVal;
    return S_OK;
}

inline HRESULT InitPropVariantFromUInt64(__in ULONGLONG ullVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_UI8;
    ppropvar->uhVal.QuadPart = ullVal;
    return S_OK;
}

inline HRESULT InitPropVariantFromDouble(__in DOUBLE dblVal, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_R8;
    ppropvar->dblVal = dblVal;
    return S_OK;
}

// Creates a VT_LPWSTR propvariant.
inline HRESULT InitPropVariantFromString(__in PCWSTR psz, __out PROPVARIANT *ppropvar)
{
    ppropvar->vt = VT_LPWSTR;
    HRESULT hr = SHStrDupW(psz, &ppropvar->pwszVal);
    if (FAILED(hr))
    {
        PropVariantInit(ppropvar);
    }
    return hr;
}

// Creates a VT_VECTOR | VT_UI1 propvariant.
inline HRESULT InitPropVariantFromGUIDAsBuffer(__in REFGUID guid, __out PROPVARIANT *ppropvar)
{
    return InitPropVariantFromBuffer(&guid, sizeof(GUID), ppropvar);
}

inline BOOL IsPropVariantVector(__in REFPROPVARIANT propvar)
{
    return (propvar.vt & (VT_ARRAY | VT_VECTOR));
}

// If TRUE, propvar contains a unicode string.  Use PropVariantToStringWithDefault(propvar, NULL) to retrieve it.
inline BOOL IsPropVariantString(__in REFPROPVARIANT propvar)
{
    return (PropVariantToStringWithDefault(propvar, NULL) != NULL);
}

// Handles int instead of LONG
inline HRESULT PropVariantToInt32(__in REFPROPVARIANT propvarIn, __out int *piRet)
{
    return PropVariantToInt32(propvarIn, (LONG*)piRet);
}

// Handles UINT instead of ULONG
inline HRESULT PropVariantToUInt32(__in REFPROPVARIANT propvarIn, __out UINT *piRet)
{
    return PropVariantToUInt32(propvarIn, (ULONG*)piRet);
}

inline HRESULT PropVariantToCLSID(__in REFPROPVARIANT propvarIn, __out CLSID *pclsid)
{ 
    return PropVariantToGUID(propvarIn, (GUID*)pclsid);
}  


inline int PropVariantCompare(__in REFPROPVARIANT propvar1, __in REFPROPVARIANT propvar2)
{
    return PropVariantCompareEx(propvar1, propvar2, PVCU_DEFAULT, PVCF_DEFAULT);
}

inline HRESULT PropVariantGetElem(__in REFPROPVARIANT propvarIn, __in ULONG iElem, __out PROPVARIANT *ppropvar)
{
    return InitPropVariantFromPropVariantVectorElem(propvarIn, iElem, ppropvar);
}

inline HRESULT InitVariantFromBoolean(__in BOOL fVal, __out VARIANT *pvar)
{
    pvar->vt = VT_BOOL;
    pvar->boolVal = fVal ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

inline HRESULT InitVariantFromInt16(__in short iVal, __out VARIANT *pvar)
{
    pvar->vt = VT_I2;
    pvar->iVal = iVal;
    return S_OK;
}

inline HRESULT InitVariantFromUInt16(__in USHORT uiVal, __out VARIANT *pvar)
{
    pvar->vt = VT_UI2;
    pvar->uiVal = uiVal;
    return S_OK;
}

inline HRESULT InitVariantFromInt32(__in LONG lVal, __out VARIANT *pvar)
{
    pvar->vt = VT_I4;
    pvar->lVal = lVal;
    return S_OK;
}

inline HRESULT InitVariantFromUInt32(__in ULONG ulVal, __out VARIANT *pvar)
{
    pvar->vt = VT_UI4;
    pvar->ulVal = ulVal;
    return S_OK;
}

inline HRESULT InitVariantFromInt64(__in LONGLONG llVal, __out VARIANT *pvar)
{
    pvar->vt = VT_I8;
    pvar->llVal = llVal;
    return S_OK;
}

inline HRESULT InitVariantFromUInt64(__in ULONGLONG ullVal, __out VARIANT *pvar)
{
    pvar->vt = VT_UI8;
    pvar->ullVal = ullVal;
    return S_OK;
}

inline HRESULT InitVariantFromDouble(__in DOUBLE dblVal, __out VARIANT *pvar)
{
    pvar->vt = VT_R8;
    pvar->dblVal = dblVal;
    return S_OK;
}

inline HRESULT InitVariantFromString(__in PCWSTR psz, __out VARIANT *pvar)
{
    pvar->vt = VT_BSTR;
    pvar->bstrVal = SysAllocString(psz);
    HRESULT hr =  pvar->bstrVal ? S_OK : (psz ? E_OUTOFMEMORY : E_INVALIDARG);
    if (FAILED(hr))
    {
        VariantInit(pvar);
    }
    return hr;
}

inline HRESULT InitVariantFromDispatch(__in_opt IDispatch* pdisp, __out VARIANT *pvar)
{
    pvar->vt = VT_DISPATCH;
    pvar->pdispVal = pdisp;
    if (pvar->pdispVal)
    {
        (pvar->pdispVal)->AddRef();
    }
    return S_OK;
}

// Creates a VT_DATE variant
inline HRESULT InitVariantFromDosDateTime(__in WORD wDate, __in WORD wTime, __out VARIANT *pvar)
{
    pvar->vt = VT_DATE;
    return DosDateTimeToVariantTime(wDate, wTime, &pvar->date) ? S_OK : S_FALSE;
}

inline BOOL IsVarTypeFloat(__in VARTYPE vt)
{
    return (vt == VT_R4 || vt == VT_R8);
}

inline BOOL IsVariantArray(__in REFVARIANT var)
{
    return (var.vt & VT_ARRAY);
}

// if TRUE, you can use VariantToStringCast to obtain the string pointer
inline BOOL IsVariantString(__in REFVARIANT var)
{
    return (VariantToStringWithDefault(var, NULL) != NULL);
}

inline BOOL IsVarTypeNumber(__in VARTYPE vt)
{
    return IsVarTypeInteger(vt) || IsVarTypeFloat(vt);
}

inline BOOL IsVarTypeSignedInteger(__in VARTYPE vt)
{
    BOOL fRet = FALSE;
    switch (vt)
    {
        case VT_I1:
        case VT_I2:
        case VT_I4:
        case VT_I8:
        fRet = TRUE;
    }
    return fRet;
}

inline BOOL IsVarTypeUnsignedInteger(__in VARTYPE vt)
{
    BOOL fRet = FALSE;
    switch (vt)
    {
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
        case VT_UI8:
        fRet = TRUE;
    }
    return fRet;
}

inline BOOL IsVarTypeInteger(__in VARTYPE vt)
{
    return IsVarTypeSignedInteger(vt) || IsVarTypeUnsignedInteger(vt);
}

// Creates a VT_ARRAY | VT_UI1 variant.
inline HRESULT InitVariantFromGUIDAsBuffer(__in REFGUID guid, __out VARIANT *pvar)
{
    return InitVariantFromBuffer(&guid, sizeof(GUID), pvar);
}

// Handles int instead of LONG
inline HRESULT VariantToInt32(__in REFVARIANT varIn, __out int *piRet)
{
    return VariantToInt32(varIn, (LONG*)piRet);
}

// Handles UINT instead of ULONG
inline HRESULT VariantToUInt32(__in REFVARIANT varIn, __out UINT *piRet)
{
    return VariantToUInt32(varIn, (ULONG*)piRet);
}

inline HRESULT VariantGetElem(__in REFVARIANT varIn, __in ULONG iElem, __out VARIANT *pvar)
{
    return InitVariantFromVariantArrayElem(varIn, iElem, pvar);
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\PrSht.h ===
/*****************************************************************************\
*                                                                             *
* prsht.h - - Interface for the Windows Property Sheet Pages                  *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/

#ifndef _PRSHT_H_
#define _PRSHT_H_


//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINCOMMCTRLAPI
#if !defined(_COMCTL32_) && defined(_WIN32)
#define WINCOMMCTRLAPI DECLSPEC_IMPORT
#else
#define WINCOMMCTRLAPI
#endif
#endif // WINCOMMCTRLAPI

//
// For compilers that don't support nameless unions
//
#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME   u
#define DUMMYUNIONNAME2  u2
#define DUMMYUNIONNAME3  u3
#define DUMMYUNIONNAME4  u4
#define DUMMYUNIONNAME5  u5
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#define DUMMYUNIONNAME5
#endif
#endif // DUMMYUNIONNAME

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(push)
#pragma warning(disable:4201) /* nonstandard extension used : nameless struct/union */
#endif


#ifdef _WIN64
#include <pshpack8.h>
#else
#include <pshpack4.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif


#ifndef SNDMSG
#ifdef __cplusplus
#ifndef _MAC
#define SNDMSG ::SendMessage
#else
#define SNDMSG ::AfxSendMessage
#endif
#else
#ifndef _MAC
#define SNDMSG SendMessage
#else
#define SNDMSG AfxSendMessage
#endif
#endif
#endif // ifndef SNDMSG

#ifndef PSTMSG
#ifdef __cplusplus
#define PSTMSG ::PostMessage
#else
#define PSTMSG PostMessage
#endif
#endif // ifndef PSTMSG

#define MAXPROPPAGES            100

struct _PSP;
typedef struct _PSP * HPROPSHEETPAGE;

#ifndef MIDL_PASS
struct _PROPSHEETPAGEA;
struct _PROPSHEETPAGEW;
#endif

typedef UINT (CALLBACK *LPFNPSPCALLBACKA)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEA *ppsp);
typedef UINT (CALLBACK *LPFNPSPCALLBACKW)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEW *ppsp);

#ifdef UNICODE
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKW
#else
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKA
#endif

#define PSP_DEFAULT                0x00000000
#define PSP_DLGINDIRECT            0x00000001
#define PSP_USEHICON               0x00000002
#define PSP_USEICONID              0x00000004
#define PSP_USETITLE               0x00000008
#define PSP_RTLREADING             0x00000010

#define PSP_HASHELP                0x00000020
#define PSP_USEREFPARENT           0x00000040
#define PSP_USECALLBACK            0x00000080
#define PSP_PREMATURE              0x00000400

#if (_WIN32_IE >= 0x0400)
//----- New flags for wizard97 --------------
#define PSP_HIDEHEADER             0x00000800
#define PSP_USEHEADERTITLE         0x00001000
#define PSP_USEHEADERSUBTITLE      0x00002000
//-------------------------------------------
#endif
#if (_WIN32_WINNT >= 0x0501) || ISOLATION_AWARE_ENABLED
#define PSP_USEFUSIONCONTEXT       0x00004000
#endif


#if (_WIN32_IE >= 0x0500)
#define PSPCB_ADDREF            0
#endif
#define PSPCB_RELEASE           1
#define PSPCB_CREATE            2

#ifdef _WIN32
typedef LPCDLGTEMPLATE PROPSHEETPAGE_RESOURCE;
#else
typedef const VOID* PROPSHEETPAGE_RESOURCE;
#endif

#define PROPSHEETPAGEA_V1_FIELDS   \
    DWORD           dwSize;        \
    DWORD           dwFlags;       \
    HINSTANCE       hInstance;     \
    union                          \
    {                              \
        LPCSTR      pszTemplate;   \
        PROPSHEETPAGE_RESOURCE pResource; \
    } DUMMYUNIONNAME;              \
    union                          \
    {                              \
        HICON        hIcon;        \
        LPCSTR       pszIcon;      \
    } DUMMYUNIONNAME2;             \
    LPCSTR           pszTitle;     \
    DLGPROC          pfnDlgProc;   \
    LPARAM           lParam;       \
    LPFNPSPCALLBACKA pfnCallback;  \
    UINT             *pcRefParent; \

#define PROPSHEETPAGEW_V1_FIELDS   \
    DWORD           dwSize;        \
    DWORD           dwFlags;       \
    HINSTANCE       hInstance;     \
    union                          \
    {                              \
        LPCWSTR     pszTemplate;   \
        PROPSHEETPAGE_RESOURCE pResource; \
    } DUMMYUNIONNAME;              \
    union                          \
    {                              \
        HICON        hIcon;        \
        LPCWSTR      pszIcon;      \
    } DUMMYUNIONNAME2;             \
    LPCWSTR          pszTitle;     \
    DLGPROC          pfnDlgProc;   \
    LPARAM           lParam;       \
    LPFNPSPCALLBACKW pfnCallback;  \
    UINT             *pcRefParent; \

#if _WIN32_WINNT >= 0x0600
#define  _PROPSHEETPAGEA_V4 _PROPSHEETPAGEA
#define  _PROPSHEETPAGEW_V4 _PROPSHEETPAGEW
#elif (_WIN32_WINNT >= 0x0501) || ISOLATION_AWARE_ENABLED
#define  _PROPSHEETPAGEA_V3 _PROPSHEETPAGEA
#define  _PROPSHEETPAGEW_V3 _PROPSHEETPAGEW
#elif (_WIN32_IE >= 0x0400)
#define  _PROPSHEETPAGEA_V2 _PROPSHEETPAGEA
#define  _PROPSHEETPAGEW_V2 _PROPSHEETPAGEW
#else
#define  _PROPSHEETPAGEA_V1 _PROPSHEETPAGEA
#define  _PROPSHEETPAGEW_V1 _PROPSHEETPAGEW
#endif

typedef struct _PROPSHEETPAGEA_V1
{
    PROPSHEETPAGEA_V1_FIELDS
} PROPSHEETPAGEA_V1, *LPPROPSHEETPAGEA_V1;
typedef const PROPSHEETPAGEA_V1 *LPCPROPSHEETPAGEA_V1;

typedef struct _PROPSHEETPAGEA_V2
{
    PROPSHEETPAGEA_V1_FIELDS

    LPCSTR           pszHeaderTitle;    // this is displayed in the header
    LPCSTR           pszHeaderSubTitle; //
} PROPSHEETPAGEA_V2, *LPPROPSHEETPAGEA_V2;
typedef const PROPSHEETPAGEA_V2 *LPCPROPSHEETPAGEA_V2;

typedef struct _PROPSHEETPAGEA_V3
{
    PROPSHEETPAGEA_V1_FIELDS

    LPCSTR           pszHeaderTitle;    // this is displayed in the header
    LPCSTR           pszHeaderSubTitle; //

    HANDLE           hActCtx;
} PROPSHEETPAGEA_V3, *LPPROPSHEETPAGEA_V3;
typedef const PROPSHEETPAGEA_V3 *LPCPROPSHEETPAGEA_V3;

#if _WIN32_WINNT >= 0x0600
typedef struct _PROPSHEETPAGEA_V4
{
    PROPSHEETPAGEA_V1_FIELDS

    LPCSTR           pszHeaderTitle;    // this is displayed in the header
    LPCSTR           pszHeaderSubTitle; //

    HANDLE           hActCtx;

    union 
    {
        HBITMAP     hbmHeader;
        LPCSTR      pszbmHeader;
    } DUMMYUNIONNAME3;

} PROPSHEETPAGEA_V4, *LPPROPSHEETPAGEA_V4;
typedef const PROPSHEETPAGEA_V4 *LPCPROPSHEETPAGEA_V4;
#endif

typedef struct _PROPSHEETPAGEW_V1
{
    PROPSHEETPAGEW_V1_FIELDS
} PROPSHEETPAGEW_V1, *LPPROPSHEETPAGEW_V1;
typedef const PROPSHEETPAGEW_V1 *LPCPROPSHEETPAGEW_V1;

typedef struct _PROPSHEETPAGEW_V2
{
    PROPSHEETPAGEW_V1_FIELDS

    LPCWSTR           pszHeaderTitle;    // this is displayed in the header
    LPCWSTR           pszHeaderSubTitle; //
} PROPSHEETPAGEW_V2, *LPPROPSHEETPAGEW_V2;
typedef const PROPSHEETPAGEW_V2 *LPCPROPSHEETPAGEW_V2;

typedef struct _PROPSHEETPAGEW_V3
{
    PROPSHEETPAGEW_V1_FIELDS

    LPCWSTR           pszHeaderTitle;    // this is displayed in the header
    LPCWSTR           pszHeaderSubTitle; //

    HANDLE           hActCtx;
} PROPSHEETPAGEW_V3, *LPPROPSHEETPAGEW_V3;
typedef const PROPSHEETPAGEW_V3 *LPCPROPSHEETPAGEW_V3;

#if _WIN32_WINNT >= 0x0600
typedef struct _PROPSHEETPAGEW_V4
{
    PROPSHEETPAGEW_V1_FIELDS

    LPCWSTR           pszHeaderTitle;    // this is displayed in the header
    LPCWSTR           pszHeaderSubTitle; //

    HANDLE            hActCtx;

    union 
    {
        HBITMAP     hbmHeader;
        LPCWSTR     pszbmHeader;
    } DUMMYUNIONNAME3;

} PROPSHEETPAGEW_V4, *LPPROPSHEETPAGEW_V4;
typedef const PROPSHEETPAGEW_V4 *LPCPROPSHEETPAGEW_V4;
#endif

#define PROPSHEETPAGEA_V1_SIZE sizeof(PROPSHEETPAGEA_V1)
#define PROPSHEETPAGEW_V1_SIZE sizeof(PROPSHEETPAGEW_V1)

#define PROPSHEETPAGEA_V2_SIZE sizeof(PROPSHEETPAGEA_V2)
#define PROPSHEETPAGEW_V2_SIZE sizeof(PROPSHEETPAGEW_V2)

#define PROPSHEETPAGEA_V3_SIZE sizeof(PROPSHEETPAGEA_V3)
#define PROPSHEETPAGEW_V3_SIZE sizeof(PROPSHEETPAGEW_V3)

#if _WIN32_WINNT >= 0x0600
#define PROPSHEETPAGEA_V4_SIZE sizeof(PROPSHEETPAGEA_V4)
#define PROPSHEETPAGEW_V4_SIZE sizeof(PROPSHEETPAGEW_V4)
#endif


#if _WIN32_WINNT >= 0x0600
typedef    PROPSHEETPAGEA_V4    PROPSHEETPAGEA_LATEST;
typedef    PROPSHEETPAGEW_V4    PROPSHEETPAGEW_LATEST;
typedef  LPPROPSHEETPAGEA_V4  LPPROPSHEETPAGEA_LATEST;
typedef  LPPROPSHEETPAGEW_V4  LPPROPSHEETPAGEW_LATEST;
typedef LPCPROPSHEETPAGEA_V4 LPCPROPSHEETPAGEA_LATEST;
typedef LPCPROPSHEETPAGEW_V4 LPCPROPSHEETPAGEW_LATEST;
#else
typedef    PROPSHEETPAGEA_V3    PROPSHEETPAGEA_LATEST;
typedef    PROPSHEETPAGEW_V3    PROPSHEETPAGEW_LATEST;
typedef  LPPROPSHEETPAGEA_V3  LPPROPSHEETPAGEA_LATEST;
typedef  LPPROPSHEETPAGEW_V3  LPPROPSHEETPAGEW_LATEST;
typedef LPCPROPSHEETPAGEA_V3 LPCPROPSHEETPAGEA_LATEST;
typedef LPCPROPSHEETPAGEW_V3 LPCPROPSHEETPAGEW_LATEST;
#endif


#if _WIN32_WINNT >= 0x0600
typedef    PROPSHEETPAGEA_V4    PROPSHEETPAGEA;
typedef    PROPSHEETPAGEW_V4    PROPSHEETPAGEW;
typedef  LPPROPSHEETPAGEA_V4  LPPROPSHEETPAGEA;
typedef  LPPROPSHEETPAGEW_V4  LPPROPSHEETPAGEW;
typedef LPCPROPSHEETPAGEA_V4 LPCPROPSHEETPAGEA;
typedef LPCPROPSHEETPAGEW_V4 LPCPROPSHEETPAGEW;
#elif (_WIN32_WINNT >= 0x0501) || ISOLATION_AWARE_ENABLED
typedef    PROPSHEETPAGEA_V3    PROPSHEETPAGEA;
typedef    PROPSHEETPAGEW_V3    PROPSHEETPAGEW;
typedef  LPPROPSHEETPAGEA_V3  LPPROPSHEETPAGEA;
typedef  LPPROPSHEETPAGEW_V3  LPPROPSHEETPAGEW;
typedef LPCPROPSHEETPAGEA_V3 LPCPROPSHEETPAGEA;
typedef LPCPROPSHEETPAGEW_V3 LPCPROPSHEETPAGEW;
#elif (_WIN32_IE >= 0x0400)
typedef    PROPSHEETPAGEA_V2    PROPSHEETPAGEA;
typedef    PROPSHEETPAGEW_V2    PROPSHEETPAGEW;
typedef  LPPROPSHEETPAGEA_V2  LPPROPSHEETPAGEA;
typedef  LPPROPSHEETPAGEW_V2  LPPROPSHEETPAGEW;
typedef LPCPROPSHEETPAGEA_V2 LPCPROPSHEETPAGEA;
typedef LPCPROPSHEETPAGEW_V2 LPCPROPSHEETPAGEW;
#else
typedef    PROPSHEETPAGEA_V1    PROPSHEETPAGEA;
typedef    PROPSHEETPAGEW_V1    PROPSHEETPAGEW;
typedef  LPPROPSHEETPAGEA_V1  LPPROPSHEETPAGEA;
typedef  LPPROPSHEETPAGEW_V1  LPPROPSHEETPAGEW;
typedef LPCPROPSHEETPAGEA_V1 LPCPROPSHEETPAGEA;
typedef LPCPROPSHEETPAGEW_V1 LPCPROPSHEETPAGEW;
#endif

#ifdef UNICODE
#define    PROPSHEETPAGE           PROPSHEETPAGEW
#define  LPPROPSHEETPAGE         LPPROPSHEETPAGEW
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEW
#define    PROPSHEETPAGE_V1_SIZE   PROPSHEETPAGEW_V1_SIZE
#define    PROPSHEETPAGE_V2_SIZE   PROPSHEETPAGEW_V2_SIZE
#define    PROPSHEETPAGE_V1        PROPSHEETPAGEW_V1
#define  LPPROPSHEETPAGE_V1      LPPROPSHEETPAGEW_V1
#define LPCPROPSHEETPAGE_V1     LPCPROPSHEETPAGEW_V1
#define    PROPSHEETPAGE_V2        PROPSHEETPAGEW_V2
#define  LPPROPSHEETPAGE_V2      LPPROPSHEETPAGEW_V2
#define LPCPROPSHEETPAGE_V2     LPCPROPSHEETPAGEW_V2
#define    PROPSHEETPAGE_V3        PROPSHEETPAGEW_V3
#define  LPPROPSHEETPAGE_V3      LPPROPSHEETPAGEW_V3
#define LPCPROPSHEETPAGE_V3     LPCPROPSHEETPAGEW_V3
#if _WIN32_WINNT >= 0x0600
#define    PROPSHEETPAGE_V4        PROPSHEETPAGEW_V4
#define  LPPROPSHEETPAGE_V4      LPPROPSHEETPAGEW_V4
#define LPCPROPSHEETPAGE_V4     LPCPROPSHEETPAGEW_V4
#endif
#define    PROPSHEETPAGE_LATEST    PROPSHEETPAGEW_LATEST
#define  LPPROPSHEETPAGE_LATEST  LPPROPSHEETPAGEW_LATEST
#define LPCPROPSHEETPAGE_LATEST LPCPROPSHEETPAGEW_LATEST
#else
#define    PROPSHEETPAGE           PROPSHEETPAGEA
#define  LPPROPSHEETPAGE         LPPROPSHEETPAGEA
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEA
#define    PROPSHEETPAGE_V1_SIZE   PROPSHEETPAGEA_V1_SIZE
#define    PROPSHEETPAGE_V2_SIZE   PROPSHEETPAGEA_V2_SIZE
#define    PROPSHEETPAGE_V1        PROPSHEETPAGEA_V1
#define  LPPROPSHEETPAGE_V1      LPPROPSHEETPAGEA_V1
#define LPCPROPSHEETPAGE_V1     LPCPROPSHEETPAGEA_V1
#define    PROPSHEETPAGE_V2        PROPSHEETPAGEA_V2
#define  LPPROPSHEETPAGE_V2      LPPROPSHEETPAGEA_V2
#define LPCPROPSHEETPAGE_V2     LPCPROPSHEETPAGEA_V2
#define    PROPSHEETPAGE_V3        PROPSHEETPAGEA_V3
#define  LPPROPSHEETPAGE_V3      LPPROPSHEETPAGEA_V3
#define LPCPROPSHEETPAGE_V3     LPCPROPSHEETPAGEA_V3
#if _WIN32_WINNT >= 0x0600
#define    PROPSHEETPAGE_V4        PROPSHEETPAGEA_V4
#define  LPPROPSHEETPAGE_V4      LPPROPSHEETPAGEA_V4
#define LPCPROPSHEETPAGE_V4     LPCPROPSHEETPAGEA_V4
#endif
#define    PROPSHEETPAGE_LATEST    PROPSHEETPAGEA_LATEST
#define  LPPROPSHEETPAGE_LATEST  LPPROPSHEETPAGEA_LATEST
#define LPCPROPSHEETPAGE_LATEST LPCPROPSHEETPAGEA_LATEST
#endif


//----- PropSheet Header related ---------

#define PSH_DEFAULT             0x00000000
#define PSH_PROPTITLE           0x00000001
#define PSH_USEHICON            0x00000002
#define PSH_USEICONID           0x00000004
#define PSH_PROPSHEETPAGE       0x00000008

#define PSH_WIZARDHASFINISH     0x00000010
#define PSH_WIZARD              0x00000020
#define PSH_USEPSTARTPAGE       0x00000040
#define PSH_NOAPPLYNOW          0x00000080

#define PSH_USECALLBACK         0x00000100
#define PSH_HASHELP             0x00000200
#define PSH_MODELESS            0x00000400
#define PSH_RTLREADING          0x00000800

#define PSH_WIZARDCONTEXTHELP   0x00001000

#if (_WIN32_IE >= 0x0400)
//----- New flags for wizard97 -----------
#if (_WIN32_IE < 0x0500)
#define PSH_WIZARD97            0x00002000
#else
#define PSH_WIZARD97            0x01000000
#endif
#define PSH_WATERMARK           0x00008000

#define PSH_USEHBMWATERMARK     0x00010000  // user pass in a hbmWatermark instead of pszbmWatermark
#define PSH_USEHPLWATERMARK     0x00020000  //
#define PSH_STRETCHWATERMARK    0x00040000  // stretchwatermark also applies for the header
#define PSH_HEADER              0x00080000

#define PSH_USEHBMHEADER        0x00100000
#define PSH_USEPAGELANG         0x00200000  // use frame dialog template matched to page
//----------------------------------------
#endif

#if (_WIN32_IE >= 0x0500)
//----- New flags for wizard-lite --------
#define PSH_WIZARD_LITE         0x00400000
#define PSH_NOCONTEXTHELP       0x02000000
//----------------------------------------
#endif


#if _WIN32_WINNT >= 0x0600
#define PSH_AEROWIZARD                          0x00004000

#define PSH_RESIZABLE                           0x04000000
#define PSH_HEADERBITMAP                        0x08000000
#define PSH_NOMARGIN                            0x10000000
#endif



typedef int (CALLBACK *PFNPROPSHEETCALLBACK)(HWND, UINT, LPARAM);

#define PROPSHEETHEADERA_V1_FIELDS      \
        DWORD           dwSize;         \
        DWORD           dwFlags;        \
        HWND            hwndParent;     \
        HINSTANCE       hInstance;      \
        union                           \
        {                               \
            HICON       hIcon;          \
            LPCSTR      pszIcon;        \
        } DUMMYUNIONNAME;               \
        LPCSTR          pszCaption;     \
        UINT            nPages;         \
        union                           \
        {                               \
            UINT        nStartPage;     \
            LPCSTR      pStartPage;     \
        } DUMMYUNIONNAME2;              \
        union                           \
        {                               \
            LPCPROPSHEETPAGEA ppsp;     \
            HPROPSHEETPAGE *phpage;     \
        } DUMMYUNIONNAME3;              \
        PFNPROPSHEETCALLBACK pfnCallback;   

typedef struct _PROPSHEETHEADERA_V1
{
    PROPSHEETHEADERA_V1_FIELDS
} PROPSHEETHEADERA_V1, *LPPROPSHEETHEADERA_V1;
typedef const PROPSHEETHEADERA_V1 *LPCPROPSHEETHEADERA_V1;

#if (_WIN32_IE >= 0x0400)
typedef struct _PROPSHEETHEADERA_V2
{
    PROPSHEETHEADERA_V1_FIELDS
    union 
    {
        HBITMAP hbmWatermark;
        LPCSTR pszbmWatermark;
    } DUMMYUNIONNAME4;
    HPALETTE hplWatermark;
    union 
    {
        HBITMAP hbmHeader;     // Header  bitmap shares the palette with watermark
        LPCSTR pszbmHeader;
    } DUMMYUNIONNAME5;
} PROPSHEETHEADERA_V2, *LPPROPSHEETHEADERA_V2;
typedef const PROPSHEETHEADERA_V2 *LPCPROPSHEETHEADERA_V2;
#endif

#define PROPSHEETHEADERW_V1_FIELDS      \
        DWORD           dwSize;         \
        DWORD           dwFlags;        \
        HWND            hwndParent;     \
        HINSTANCE       hInstance;      \
        union                           \
        {                               \
            HICON       hIcon;          \
            LPCWSTR     pszIcon;        \
        } DUMMYUNIONNAME;               \
        LPCWSTR         pszCaption;     \
        UINT            nPages;         \
        union                           \
        {                               \
            UINT        nStartPage;     \
            LPCWSTR     pStartPage;     \
        } DUMMYUNIONNAME2;              \
        union                           \
        {                               \
            LPCPROPSHEETPAGEW ppsp;     \
            HPROPSHEETPAGE *phpage;     \
        } DUMMYUNIONNAME3;              \
        PFNPROPSHEETCALLBACK pfnCallback;  

typedef struct _PROPSHEETHEADERW_V1
{
    PROPSHEETHEADERW_V1_FIELDS
} PROPSHEETHEADERW_V1, *LPPROPSHEETHEADERW_V1;
typedef const PROPSHEETHEADERW_V1 *LPCPROPSHEETHEADERW_V1;

#if (_WIN32_IE >= 0x0400)
typedef struct _PROPSHEETHEADERW_V2
{
    PROPSHEETHEADERW_V1_FIELDS
    union 
    {
        HBITMAP hbmWatermark;
        LPCWSTR pszbmWatermark;
    } DUMMYUNIONNAME4;
    HPALETTE hplWatermark;
    union 
    {
        HBITMAP hbmHeader;     // Header  bitmap shares the palette with watermark
        LPCWSTR pszbmHeader;
    } DUMMYUNIONNAME5;
} PROPSHEETHEADERW_V2, *LPPROPSHEETHEADERW_V2;
typedef const PROPSHEETHEADERW_V2 *LPCPROPSHEETHEADERW_V2;
#endif

#define PROPSHEETHEADERA_V1_SIZE sizeof(PROPSHEETHEADERA_V1)
#define PROPSHEETHEADERW_V1_SIZE sizeof(PROPSHEETHEADERW_V1)

#if (_WIN32_IE >= 0x400)
#define PROPSHEETHEADERA_V2_SIZE sizeof(PROPSHEETHEADERA_V2)
#define PROPSHEETHEADERW_V2_SIZE sizeof(PROPSHEETHEADERW_V2)
#endif

#if (_WIN32_IE >= 0x400)
#define    _PROPSHEETHEADERA        PROPSHEETHEADERA_V2;
#define    _PROPSHEETHEADERW        PROPSHEETHEADERW_V2;
typedef    PROPSHEETHEADERA_V2      PROPSHEETHEADERA;
typedef    PROPSHEETHEADERW_V2      PROPSHEETHEADERW;
typedef  LPPROPSHEETHEADERA_V2      LPPROPSHEETHEADERA;
typedef  LPPROPSHEETHEADERW_V2      LPPROPSHEETHEADERW;
typedef LPCPROPSHEETHEADERA_V2      LPCPROPSHEETHEADERA;
typedef LPCPROPSHEETHEADERW_V2      LPCPROPSHEETHEADERW;
#else
#define    _PROPSHEETHEADERA        PROPSHEETHEADERA_V1;
#define    _PROPSHEETHEADERW        PROPSHEETHEADERW_V1;
typedef    PROPSHEETHEADERA_V1      PROPSHEETHEADERA;
typedef    PROPSHEETHEADERW_V1      PROPSHEETHEADERW;
typedef  LPPROPSHEETHEADERA_V1      LPPROPSHEETHEADERA;
typedef  LPPROPSHEETHEADERW_V1      LPPROPSHEETHEADERW;
typedef LPCPROPSHEETHEADERA_V1      LPCPROPSHEETHEADERA;
typedef LPCPROPSHEETHEADERW_V1      LPCPROPSHEETHEADERW;
#endif


#ifdef UNICODE
#define PROPSHEETHEADER         PROPSHEETHEADERW
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERW
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERW
#define PROPSHEETHEADER_V1_SIZE PROPSHEETHEADERW_V1_SIZE
#if (_WIN32_IE >= 0x400)
#define PROPSHEETHEADER_V2_SIZE PROPSHEETHEADERW_V2_SIZE
#endif
#else
#define PROPSHEETHEADER         PROPSHEETHEADERA
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERA
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERA
#define PROPSHEETHEADER_V1_SIZE PROPSHEETHEADERA_V1_SIZE
#if (_WIN32_IE >= 0x400)
#define PROPSHEETHEADER_V2_SIZE PROPSHEETHEADERA_V2_SIZE
#endif
#endif


#define PSCB_INITIALIZED  1
#define PSCB_PRECREATE    2

#if (_WIN32_IE >= 0x560)
// PSCB_BUTTONPRESSED will be sent when the user clicks a button in the
// property dialog (OK, Cancel, Apply, or Close).  The message will be sent
// to PROPSHEETHEADER's pfnCallback if the PSH_USECALLBACK flag was specified.
// The LPARAM will be equal to one of the following based on the button pressed:
// This message is only supported on comctl32 v6.
// PSBTN_FINISH (Close), PSBTN_OK, PSBTN_APPLYNOW, or PSBTN_CANCEL

#define PSCB_BUTTONPRESSED 3
#endif  // _WIN32_IE >= 0x560


WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageA(LPCPROPSHEETPAGEA constPropSheetPagePointer);
WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageW(LPCPROPSHEETPAGEW constPropSheetPagePointer);
WINCOMMCTRLAPI BOOL           WINAPI DestroyPropertySheetPage(HPROPSHEETPAGE);

WINCOMMCTRLAPI INT_PTR        WINAPI PropertySheetA(LPCPROPSHEETHEADERA);

WINCOMMCTRLAPI INT_PTR        WINAPI PropertySheetW(LPCPROPSHEETHEADERW);

#ifdef UNICODE
#define CreatePropertySheetPage  CreatePropertySheetPageW
#define PropertySheet            PropertySheetW
#else
#define CreatePropertySheetPage  CreatePropertySheetPageA
#define PropertySheet            PropertySheetA
#endif



typedef BOOL (CALLBACK *LPFNADDPROPSHEETPAGE)(HPROPSHEETPAGE, LPARAM);
typedef BOOL (CALLBACK *LPFNADDPROPSHEETPAGES)(LPVOID, LPFNADDPROPSHEETPAGE, LPARAM);


typedef struct _PSHNOTIFY
{
    NMHDR hdr;
    LPARAM lParam;
} PSHNOTIFY, *LPPSHNOTIFY;

#define PSN_FIRST               (0U-200U)
#define PSN_LAST                (0U-299U)


#define PSN_SETACTIVE           (PSN_FIRST-0)
#define PSN_KILLACTIVE          (PSN_FIRST-1)
// #define PSN_VALIDATE            (PSN_FIRST-1)
#define PSN_APPLY               (PSN_FIRST-2)
#define PSN_RESET               (PSN_FIRST-3)
// #define PSN_CANCEL              (PSN_FIRST-3)
#define PSN_HELP                (PSN_FIRST-5)
#define PSN_WIZBACK             (PSN_FIRST-6)
#define PSN_WIZNEXT             (PSN_FIRST-7)
#define PSN_WIZFINISH           (PSN_FIRST-8)
#define PSN_QUERYCANCEL         (PSN_FIRST-9)
#if (_WIN32_IE >= 0x0400)
#define PSN_GETOBJECT           (PSN_FIRST-10)
#endif // 0x0400
#if (_WIN32_IE >= 0x0500)
#define PSN_TRANSLATEACCELERATOR (PSN_FIRST-12)
#define PSN_QUERYINITIALFOCUS   (PSN_FIRST-13)
#endif // 0x0500

#define PSNRET_NOERROR              0
#define PSNRET_INVALID              1
#define PSNRET_INVALID_NOCHANGEPAGE 2
#define PSNRET_MESSAGEHANDLED       3

#define PSM_SETCURSEL           (WM_USER + 101)
#define PropSheet_SetCurSel(hDlg, hpage, index) \
        SNDMSG(hDlg, PSM_SETCURSEL, (WPARAM)(index), (LPARAM)(hpage))


#define PSM_REMOVEPAGE          (WM_USER + 102)
#define PropSheet_RemovePage(hDlg, index, hpage) \
        SNDMSG(hDlg, PSM_REMOVEPAGE, index, (LPARAM)(hpage))


#define PSM_ADDPAGE             (WM_USER + 103)
#define PropSheet_AddPage(hDlg, hpage) \
        SNDMSG(hDlg, PSM_ADDPAGE, 0, (LPARAM)(hpage))


#define PSM_CHANGED             (WM_USER + 104)
#define PropSheet_Changed(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_CHANGED, (WPARAM)(hwnd), 0L)


#define PSM_RESTARTWINDOWS      (WM_USER + 105)
#define PropSheet_RestartWindows(hDlg) \
        SNDMSG(hDlg, PSM_RESTARTWINDOWS, 0, 0L)


#define PSM_REBOOTSYSTEM        (WM_USER + 106)
#define PropSheet_RebootSystem(hDlg) \
        SNDMSG(hDlg, PSM_REBOOTSYSTEM, 0, 0L)


#define PSM_CANCELTOCLOSE       (WM_USER + 107)
#define PropSheet_CancelToClose(hDlg) \
        PostMessage(hDlg, PSM_CANCELTOCLOSE, 0, 0L)


#define PSM_QUERYSIBLINGS       (WM_USER + 108)
#define PropSheet_QuerySiblings(hDlg, wParam, lParam) \
        SNDMSG(hDlg, PSM_QUERYSIBLINGS, wParam, lParam)


#define PSM_UNCHANGED           (WM_USER + 109)
#define PropSheet_UnChanged(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_UNCHANGED, (WPARAM)(hwnd), 0L)


#define PSM_APPLY               (WM_USER + 110)
#define PropSheet_Apply(hDlg) \
        SNDMSG(hDlg, PSM_APPLY, 0, 0L)


#define PSM_SETTITLEA           (WM_USER + 111)
#define PSM_SETTITLEW           (WM_USER + 120)


#ifdef UNICODE
#define PSM_SETTITLE            PSM_SETTITLEW
#else
#define PSM_SETTITLE            PSM_SETTITLEA
#endif

#define PropSheet_SetTitle(hDlg, wStyle, lpszText)\
        SNDMSG(hDlg, PSM_SETTITLE, wStyle, (LPARAM)(LPCTSTR)(lpszText))


#define PSM_SETWIZBUTTONS       (WM_USER + 112)
#define PropSheet_SetWizButtons(hDlg, dwFlags) \
        PostMessage(hDlg, PSM_SETWIZBUTTONS, 0, (LPARAM)(dwFlags))


#define PSWIZB_BACK             0x00000001
#define PSWIZB_NEXT             0x00000002
#define PSWIZB_FINISH           0x00000004
#define PSWIZB_DISABLEDFINISH   0x00000008

#define PSWIZBF_ELEVATIONREQUIRED   0x00000001

#if _WIN32_WINNT >= 0x0600
// Only for PSH_AEROWIZARD - used in PSM_SHOWWIZBUTTONS
#define PSWIZB_CANCEL           0x00000010
#endif // 0x0605


#define PSM_PRESSBUTTON         (WM_USER + 113)
#define PropSheet_PressButton(hDlg, iButton) \
        PostMessage(hDlg, PSM_PRESSBUTTON, (WPARAM)(iButton), 0)


#define PSBTN_BACK              0
#define PSBTN_NEXT              1
#define PSBTN_FINISH            2
#define PSBTN_OK                3
#define PSBTN_APPLYNOW          4
#define PSBTN_CANCEL            5
#define PSBTN_HELP              6
#define PSBTN_MAX               6



#define PSM_SETCURSELID         (WM_USER + 114)
#define PropSheet_SetCurSelByID(hDlg, id) \
        SNDMSG(hDlg, PSM_SETCURSELID, 0, (LPARAM)(id))


#define PSM_SETFINISHTEXTA      (WM_USER + 115)
#define PSM_SETFINISHTEXTW      (WM_USER + 121)

#ifdef UNICODE
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTW
#else
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTA
#endif

#define PropSheet_SetFinishText(hDlg, lpszText) \
        SNDMSG(hDlg, PSM_SETFINISHTEXT, 0, (LPARAM)(lpszText))


#define PSM_GETTABCONTROL       (WM_USER + 116)
#define PropSheet_GetTabControl(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETTABCONTROL, 0, 0)

#define PSM_ISDIALOGMESSAGE     (WM_USER + 117)
#define PropSheet_IsDialogMessage(hDlg, pMsg) \
        (BOOL)SNDMSG(hDlg, PSM_ISDIALOGMESSAGE, 0, (LPARAM)(pMsg))

#define PSM_GETCURRENTPAGEHWND  (WM_USER + 118)
#define PropSheet_GetCurrentPageHwnd(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETCURRENTPAGEHWND, 0, 0L)

#define PSM_INSERTPAGE          (WM_USER + 119)
#define PropSheet_InsertPage(hDlg, index, hpage) \
        SNDMSG(hDlg, PSM_INSERTPAGE, (WPARAM)(index), (LPARAM)(hpage))

#if _WIN32_WINNT >= 0x0600
// Only for PSH_AEROWIZARD - used in PSM_SETHEADERTITLE
#define PSWIZF_SETCOLOR         ((UINT)(-1))
#endif

#if (_WIN32_IE >= 0x0500)
#define PSM_SETHEADERTITLEA     (WM_USER + 125)
#define PSM_SETHEADERTITLEW     (WM_USER + 126)

#ifdef UNICODE
#define PSM_SETHEADERTITLE      PSM_SETHEADERTITLEW
#else
#define PSM_SETHEADERTITLE      PSM_SETHEADERTITLEA
#endif

#define PropSheet_SetHeaderTitle(hDlg, index, lpszText) \
        SNDMSG(hDlg, PSM_SETHEADERTITLE, (WPARAM)(index), (LPARAM)(lpszText))


#define PSM_SETHEADERSUBTITLEA     (WM_USER + 127)
#define PSM_SETHEADERSUBTITLEW     (WM_USER + 128)

#ifdef UNICODE
#define PSM_SETHEADERSUBTITLE      PSM_SETHEADERSUBTITLEW
#else
#define PSM_SETHEADERSUBTITLE      PSM_SETHEADERSUBTITLEA
#endif

#define PropSheet_SetHeaderSubTitle(hDlg, index, lpszText) \
        SNDMSG(hDlg, PSM_SETHEADERSUBTITLE, (WPARAM)(index), (LPARAM)(lpszText))

#define PSM_HWNDTOINDEX            (WM_USER + 129)
#define PropSheet_HwndToIndex(hDlg, hwnd) \
        (int)SNDMSG(hDlg, PSM_HWNDTOINDEX, (WPARAM)(hwnd), 0)

#define PSM_INDEXTOHWND            (WM_USER + 130)
#define PropSheet_IndexToHwnd(hDlg, i) \
        (HWND)SNDMSG(hDlg, PSM_INDEXTOHWND, (WPARAM)(i), 0)

#define PSM_PAGETOINDEX            (WM_USER + 131)
#define PropSheet_PageToIndex(hDlg, hpage) \
        (int)SNDMSG(hDlg, PSM_PAGETOINDEX, 0, (LPARAM)(hpage))

#define PSM_INDEXTOPAGE            (WM_USER + 132)
#define PropSheet_IndexToPage(hDlg, i) \
        (HPROPSHEETPAGE)SNDMSG(hDlg, PSM_INDEXTOPAGE, (WPARAM)(i), 0)

#define PSM_IDTOINDEX              (WM_USER + 133)
#define PropSheet_IdToIndex(hDlg, id) \
        (int)SNDMSG(hDlg, PSM_IDTOINDEX, 0, (LPARAM)(id))

#define PSM_INDEXTOID              (WM_USER + 134)
#define PropSheet_IndexToId(hDlg, i) \
        SNDMSG(hDlg, PSM_INDEXTOID, (WPARAM)(i), 0)

#define PSM_GETRESULT              (WM_USER + 135)
#define PropSheet_GetResult(hDlg) \
        SNDMSG(hDlg, PSM_GETRESULT, 0, 0)

#define PSM_RECALCPAGESIZES        (WM_USER + 136)
#define PropSheet_RecalcPageSizes(hDlg) \
        SNDMSG(hDlg, PSM_RECALCPAGESIZES, 0, 0)
#endif // 0x0500


#if _WIN32_WINNT >= 0x0600
// Only UNICODE
// These messages are only for Aero Wizard style wizards. The Wizard author
// needs to specify the PSH_AEROWIZARD flag in the dwFlags member of the PROPSHEETHEADER
// structure to get this behavior.

#define PSM_SETNEXTTEXTW          (WM_USER + 137)
#define PSM_SETNEXTTEXT           PSM_SETNEXTTEXTW

#define PropSheet_SetNextText(hDlg, lpszText) \
        SNDMSG(hDlg, PSM_SETNEXTTEXT, 0, (LPARAM)(lpszText))

#define PSWIZB_SHOW                     0
#define PSWIZB_RESTORE                  1


#define PSM_SHOWWIZBUTTONS              (WM_USER + 138)
#define PropSheet_ShowWizButtons(hDlg, dwFlag, dwButton) \
        PSTMSG(hDlg, PSM_SHOWWIZBUTTONS, (WPARAM)(dwFlag), (LPARAM)(dwButton))


#define PSM_ENABLEWIZBUTTONS            (WM_USER + 139)
#define PropSheet_EnableWizButtons(hDlg, dwState, dwMask) \
        PSTMSG(hDlg, PSM_ENABLEWIZBUTTONS, (WPARAM)(dwState), (LPARAM)(dwMask))


#define PSM_SETBUTTONTEXTW         (WM_USER + 140)
#define PSM_SETBUTTONTEXT          PSM_SETBUTTONTEXTW
#define PropSheet_SetButtonText(hDlg, dwButton, lpszText) \
        SNDMSG(hDlg, PSM_SETBUTTONTEXT, (WPARAM)(dwButton), (LPARAM)(lpszText))


#endif // 0x0600


#define ID_PSRESTARTWINDOWS     0x2
#define ID_PSREBOOTSYSTEM       (ID_PSRESTARTWINDOWS | 0x1)


#define WIZ_CXDLG               276
#define WIZ_CYDLG               140

#define WIZ_CXBMP               80

#define WIZ_BODYX               92
#define WIZ_BODYCX              184

#define PROP_SM_CXDLG           212
#define PROP_SM_CYDLG           188

#define PROP_MED_CXDLG          227
#define PROP_MED_CYDLG          215

#define PROP_LG_CXDLG           252
#define PROP_LG_CYDLG           218

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif




#if !defined(RC_INVOKED) /* RC complains about long symbols in #ifs */
#if defined(ISOLATION_AWARE_ENABLED) && (ISOLATION_AWARE_ENABLED != 0)
#include "prsht.inl"
#endif /* ISOLATION_AWARE_ENABLED */
#endif /* RC */

#ifdef __cplusplus
}
#endif

#include <poppack.h>


#endif  // _PRSHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\PshPack1.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack1.h

Abstract:

    This file turns 1 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 && !defined(_M_I86)) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push,1)
#else
#pragma pack(1)
#endif
#else
#pragma pack(1)
#endif
#endif /* ! (defined(lint) || defined(RC_INVOKED)) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\ProvExce.h ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  ProvExce.h
//
//  Purpose: Exception handling classes
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _PROVIDER_EXCEPT_H
#define _PROVIDER_EXCEPT_H

#ifdef _M_CEE_PURE
#define PROVIDER_EXCEPT_API_INLINE __clrcall
#define PROVIDER_EXCEPT_SE_TRANSLATOR_FUNC_TYPE __se_translator_function_m
#else
#define PROVIDER_EXCEPT_API_INLINE __cdecl
#define PROVIDER_EXCEPT_SE_TRANSLATOR_FUNC_TYPE _se_translator_function
#endif

/**************************************************************
 *
 **************************************************************/

#include <eh.h>

/**************************************************************
 *
 **************************************************************/

class CHeap_Exception
{
public:

	enum HEAP_ERROR
	{
		E_ALLOCATION_ERROR = 0 ,
		E_FREE_ERROR
	};

private:

	HEAP_ERROR m_Error;

public:

	CHeap_Exception ( HEAP_ERROR e ) : m_Error ( e ) {}
	~CHeap_Exception () {}

	HEAP_ERROR GetError() { return m_Error ; }
} ;

/**************************************************************
 *
 **************************************************************/

class CStructured_Exception
{
private:

    UINT m_nSE ;
	EXCEPTION_POINTERS *m_pExp ;

public:

    CStructured_Exception () {}
    CStructured_Exception ( UINT n , EXCEPTION_POINTERS *pExp ) : m_nSE ( n ) , m_pExp ( pExp ) {}
    ~CStructured_Exception () {}
    UINT GetSENumber () { return m_nSE ; }
	EXCEPTION_POINTERS *GetExtendedInfo() { return m_pExp ; }
} ;

/**************************************************************
 *
 **************************************************************/

#ifndef _M_CEE_PURE

class CSetStructuredExceptionHandler
{
private:

    PROVIDER_EXCEPT_SE_TRANSLATOR_FUNC_TYPE m_PrevFunc ;

public:

    static void PROVIDER_EXCEPT_API_INLINE trans_func ( UINT u , EXCEPTION_POINTERS *pExp )
	{
		throw CStructured_Exception ( u , pExp ) ;
	}

	CSetStructuredExceptionHandler () : m_PrevFunc ( NULL )
	{
		// Foreign exception translator is no longer used
	}

	~CSetStructuredExceptionHandler ()
	{
	}
} ;

#endif // ndef _M_CEE_PURE

/**************************************************************
 *
 **************************************************************/


#endif //_PROVIDER_EXCEPT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\PshPack2.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack2.h

Abstract:

    This file turns 2 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 && !defined(_M_I86)) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push,2)
#else
#pragma pack(2)
#endif
#else
#pragma pack(2)
#endif
#endif /* ! (defined(lint) || defined(RC_INVOKED)) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Psapi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1994-1999  Microsoft Corporation

Module Name:

    psapi.h

Abstract:

    Include file for APIs provided by PSAPI.DLL

Author:

    Richard Shupak   [richards]  06-Jan-1994

Revision History:

--*/

#ifndef _PSAPI_H_
#define _PSAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define LIST_MODULES_DEFAULT 0x0  // This is the default one app would get without any flag.
#define LIST_MODULES_32BIT   0x01  // list 32bit modules in the target process.
#define LIST_MODULES_64BIT   0x02  // list all 64bit modules. 32bit exe will be stripped off.

// list all the modules
#define LIST_MODULES_ALL   (LIST_MODULES_32BIT | LIST_MODULES_64BIT)

//
// Give teams a choice of using a downlevel version of psapi.h for an OS versions.
// Teams can set C_DEFINES=$(C_DEFINES) -DPSAPI_VERSION=1 for downlevel psapi
// on windows 7 and higher.  We found that test code needs this capability.
//
#ifndef PSAPI_VERSION
#if (NTDDI_VERSION >= NTDDI_WIN7)
#define PSAPI_VERSION 2
#else
#define PSAPI_VERSION 1
#endif
#endif

#if (PSAPI_VERSION > 1)
#define EnumProcesses               K32EnumProcesses
#define EnumProcessModules          K32EnumProcessModules
#define EnumProcessModulesEx        K32EnumProcessModulesEx
#define GetModuleBaseNameA          K32GetModuleBaseNameA
#define GetModuleBaseNameW          K32GetModuleBaseNameW
#define GetModuleFileNameExA        K32GetModuleFileNameExA
#define GetModuleFileNameExW        K32GetModuleFileNameExW
#define GetModuleInformation        K32GetModuleInformation
#define EmptyWorkingSet             K32EmptyWorkingSet
#define QueryWorkingSet             K32QueryWorkingSet
#define QueryWorkingSetEx           K32QueryWorkingSetEx
#define InitializeProcessForWsWatch K32InitializeProcessForWsWatch
#define GetWsChanges                K32GetWsChanges
#define GetWsChangesEx              K32GetWsChangesEx
#define GetMappedFileNameW          K32GetMappedFileNameW
#define GetMappedFileNameA          K32GetMappedFileNameA
#define EnumDeviceDrivers           K32EnumDeviceDrivers
#define GetDeviceDriverBaseNameA    K32GetDeviceDriverBaseNameA
#define GetDeviceDriverBaseNameW    K32GetDeviceDriverBaseNameW
#define GetDeviceDriverFileNameA    K32GetDeviceDriverFileNameA
#define GetDeviceDriverFileNameW    K32GetDeviceDriverFileNameW
#define GetProcessMemoryInfo        K32GetProcessMemoryInfo
#define GetPerformanceInfo          K32GetPerformanceInfo
#define EnumPageFilesW              K32EnumPageFilesW
#define EnumPageFilesA              K32EnumPageFilesA
#define GetProcessImageFileNameA    K32GetProcessImageFileNameA
#define GetProcessImageFileNameW    K32GetProcessImageFileNameW
#endif

BOOL
WINAPI
EnumProcesses (
    __out_bcount(cb) DWORD * lpidProcess,
    __in DWORD cb,
    __out LPDWORD lpcbNeeded
    );

BOOL
WINAPI
EnumProcessModules(
    __in  HANDLE hProcess,
    __out_bcount(cb) HMODULE *lphModule,
    __in  DWORD cb,
    __out LPDWORD lpcbNeeded
    );

BOOL
WINAPI
EnumProcessModulesEx(
    __in  HANDLE hProcess,
    __out_bcount(cb)  HMODULE *lphModule,
    __in  DWORD cb,
    __out  LPDWORD lpcbNeeded,
    __in  DWORD dwFilterFlag
    );

DWORD
WINAPI
GetModuleBaseNameA(
    __in HANDLE hProcess,
    __in_opt HMODULE hModule,
    __out_ecount(nSize) LPSTR lpBaseName,
    __in DWORD nSize
    );

DWORD
WINAPI
GetModuleBaseNameW(
    __in HANDLE hProcess,
    __in_opt HMODULE hModule,
    __out_ecount(nSize) LPWSTR lpBaseName,
    __in DWORD nSize
    );

#ifdef UNICODE
#define GetModuleBaseName  GetModuleBaseNameW
#else
#define GetModuleBaseName  GetModuleBaseNameA
#endif // !UNICODE


DWORD
WINAPI
GetModuleFileNameExA(
    __in HANDLE hProcess,
    __in_opt HMODULE hModule,
    __out_ecount(nSize) LPSTR lpFilename,
    __in DWORD nSize
    );

DWORD
WINAPI
GetModuleFileNameExW(
    __in HANDLE hProcess,
    __in_opt HMODULE hModule,
    __out_ecount(nSize) LPWSTR lpFilename,
    __in DWORD nSize
    );

#ifdef UNICODE
#define GetModuleFileNameEx  GetModuleFileNameExW
#else
#define GetModuleFileNameEx  GetModuleFileNameExA
#endif // !UNICODE


typedef struct _MODULEINFO {
    LPVOID lpBaseOfDll;
    DWORD SizeOfImage;
    LPVOID EntryPoint;
} MODULEINFO, *LPMODULEINFO;


BOOL
WINAPI
GetModuleInformation(
    __in HANDLE hProcess,
    __in HMODULE hModule,
    __out LPMODULEINFO lpmodinfo,
    __in DWORD cb
    );


BOOL
WINAPI
EmptyWorkingSet(
    __in HANDLE hProcess
    );

//
// Working set information structures. All non-specified bits are reserved.
//

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)   // unnamed struct
#pragma warning(disable:4214)   // bit fields other than int

typedef union _PSAPI_WORKING_SET_BLOCK {
    ULONG_PTR Flags;
    struct {
        ULONG_PTR Protection : 5;
        ULONG_PTR ShareCount : 3;
        ULONG_PTR Shared : 1;
        ULONG_PTR Reserved : 3;
#if defined(_WIN64)
        ULONG_PTR VirtualPage : 52;
#else
        ULONG_PTR VirtualPage : 20;
#endif
    };
} PSAPI_WORKING_SET_BLOCK, *PPSAPI_WORKING_SET_BLOCK;

typedef struct _PSAPI_WORKING_SET_INFORMATION {
    ULONG_PTR NumberOfEntries;
    PSAPI_WORKING_SET_BLOCK WorkingSetInfo[1];
} PSAPI_WORKING_SET_INFORMATION, *PPSAPI_WORKING_SET_INFORMATION;

typedef union _PSAPI_WORKING_SET_EX_BLOCK {
    ULONG_PTR Flags;
    struct {
        ULONG_PTR Valid : 1;        // The following fields are valid only if this bit is set
        ULONG_PTR ShareCount : 3;
        ULONG_PTR Win32Protection : 11;
        ULONG_PTR Shared : 1;
        ULONG_PTR Node : 6;
        ULONG_PTR Locked : 1;
        ULONG_PTR LargePage : 1;
    };
} PSAPI_WORKING_SET_EX_BLOCK, *PPSAPI_WORKING_SET_EX_BLOCK;

typedef struct _PSAPI_WORKING_SET_EX_INFORMATION {
    PVOID VirtualAddress;
    PSAPI_WORKING_SET_EX_BLOCK VirtualAttributes;
} PSAPI_WORKING_SET_EX_INFORMATION, *PPSAPI_WORKING_SET_EX_INFORMATION;

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4214)
#pragma warning(default:4201)
#endif

BOOL
WINAPI
QueryWorkingSet(
    __in HANDLE hProcess,
    __out_bcount(cb) PVOID pv,
    __in DWORD cb
    );

BOOL
WINAPI
QueryWorkingSetEx(
    __in HANDLE hProcess,
    __out_bcount(cb) PVOID pv,
    __in DWORD cb
    );

BOOL
WINAPI
InitializeProcessForWsWatch(
    __in HANDLE hProcess
    );

typedef struct _PSAPI_WS_WATCH_INFORMATION {
    LPVOID FaultingPc;
    LPVOID FaultingVa;
} PSAPI_WS_WATCH_INFORMATION, *PPSAPI_WS_WATCH_INFORMATION;

typedef struct _PSAPI_WS_WATCH_INFORMATION_EX {
    PSAPI_WS_WATCH_INFORMATION BasicInfo;
    ULONG_PTR FaultingThreadId;
    ULONG_PTR Flags;    // Reserved
} PSAPI_WS_WATCH_INFORMATION_EX, *PPSAPI_WS_WATCH_INFORMATION_EX;

BOOL
WINAPI
GetWsChanges(
    __in HANDLE hProcess,
    __out_bcount(cb) PPSAPI_WS_WATCH_INFORMATION lpWatchInfo,
    __in DWORD cb
    );

BOOL
WINAPI
GetWsChangesEx(
    __in HANDLE hProcess,
    __out_bcount_part(*cb, *cb) PPSAPI_WS_WATCH_INFORMATION_EX lpWatchInfoEx,
    __inout PDWORD cb
    );

DWORD
WINAPI
GetMappedFileNameW (
    __in HANDLE hProcess,
    __in LPVOID lpv,
    __out_ecount(nSize) LPWSTR lpFilename,
    __in DWORD nSize
    );

DWORD
WINAPI
GetMappedFileNameA (
    __in HANDLE hProcess,
    __in LPVOID lpv,
    __out_ecount(nSize) LPSTR lpFilename,
    __in DWORD nSize
    );

#ifdef UNICODE
#define GetMappedFileName  GetMappedFileNameW
#else
#define GetMappedFileName  GetMappedFileNameA
#endif // !UNICODE

BOOL
WINAPI
EnumDeviceDrivers (
    __out_bcount(cb) LPVOID *lpImageBase,
    __in DWORD cb,
    __out LPDWORD lpcbNeeded
    );


DWORD
WINAPI
GetDeviceDriverBaseNameA (
    __in LPVOID ImageBase,
    __out_ecount(nSize) LPSTR lpFilename,
    __in DWORD nSize
    );

DWORD
WINAPI
GetDeviceDriverBaseNameW (
    __in LPVOID ImageBase,
    __out_ecount(nSize) LPWSTR lpBaseName,
    __in DWORD nSize
    );

#ifdef UNICODE
#define GetDeviceDriverBaseName  GetDeviceDriverBaseNameW
#else
#define GetDeviceDriverBaseName  GetDeviceDriverBaseNameA
#endif // !UNICODE


DWORD
WINAPI
GetDeviceDriverFileNameA (
    __in LPVOID ImageBase,
    __out_ecount(nSize) LPSTR lpFilename,
    __in DWORD nSize
    );

DWORD
WINAPI
GetDeviceDriverFileNameW (
    __in LPVOID ImageBase,
    __out_ecount(nSize) LPWSTR lpFilename,
    __in DWORD nSize
    );

#ifdef UNICODE
#define GetDeviceDriverFileName  GetDeviceDriverFileNameW
#else
#define GetDeviceDriverFileName  GetDeviceDriverFileNameA
#endif // !UNICODE

// Structure for GetProcessMemoryInfo()

typedef struct _PROCESS_MEMORY_COUNTERS {
    DWORD cb;
    DWORD PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
} PROCESS_MEMORY_COUNTERS;
typedef PROCESS_MEMORY_COUNTERS *PPROCESS_MEMORY_COUNTERS;

#if (_WIN32_WINNT >= 0x0501)

typedef struct _PROCESS_MEMORY_COUNTERS_EX {
    DWORD cb;
    DWORD PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivateUsage;
} PROCESS_MEMORY_COUNTERS_EX;
typedef PROCESS_MEMORY_COUNTERS_EX *PPROCESS_MEMORY_COUNTERS_EX;

#endif

BOOL
WINAPI
GetProcessMemoryInfo(
    HANDLE Process,
    PPROCESS_MEMORY_COUNTERS ppsmemCounters,
    DWORD cb
    );

typedef struct _PERFORMANCE_INFORMATION {
    DWORD cb;
    SIZE_T CommitTotal;
    SIZE_T CommitLimit;
    SIZE_T CommitPeak;
    SIZE_T PhysicalTotal;
    SIZE_T PhysicalAvailable;
    SIZE_T SystemCache;
    SIZE_T KernelTotal;
    SIZE_T KernelPaged;
    SIZE_T KernelNonpaged;
    SIZE_T PageSize;
    DWORD HandleCount;
    DWORD ProcessCount;
    DWORD ThreadCount;
} PERFORMANCE_INFORMATION, *PPERFORMANCE_INFORMATION, PERFORMACE_INFORMATION, *PPERFORMACE_INFORMATION;

BOOL
WINAPI
GetPerformanceInfo (
    PPERFORMANCE_INFORMATION pPerformanceInformation,
    DWORD cb
    );

typedef struct _ENUM_PAGE_FILE_INFORMATION {
    DWORD cb;
    DWORD Reserved;
    SIZE_T TotalSize;
    SIZE_T TotalInUse;
    SIZE_T PeakUsage;
} ENUM_PAGE_FILE_INFORMATION, *PENUM_PAGE_FILE_INFORMATION;

typedef BOOL (*PENUM_PAGE_FILE_CALLBACKW) (LPVOID pContext, PENUM_PAGE_FILE_INFORMATION pPageFileInfo, LPCWSTR lpFilename);

typedef BOOL (*PENUM_PAGE_FILE_CALLBACKA) (LPVOID pContext, PENUM_PAGE_FILE_INFORMATION pPageFileInfo, LPCSTR lpFilename);

BOOL
WINAPI
EnumPageFilesW (
    PENUM_PAGE_FILE_CALLBACKW pCallBackRoutine,
    LPVOID pContext
    );

BOOL
WINAPI
EnumPageFilesA (
    PENUM_PAGE_FILE_CALLBACKA pCallBackRoutine,
    LPVOID pContext
    );

#ifdef UNICODE
#define PENUM_PAGE_FILE_CALLBACK PENUM_PAGE_FILE_CALLBACKW
#define EnumPageFiles EnumPageFilesW
#else
#define PENUM_PAGE_FILE_CALLBACK PENUM_PAGE_FILE_CALLBACKA
#define EnumPageFiles EnumPageFilesA
#endif // !UNICODE

DWORD
WINAPI
GetProcessImageFileNameA (
    __in HANDLE hProcess,
    __out_ecount(nSize) LPSTR lpImageFileName,
    __in DWORD nSize
    );

DWORD
WINAPI
GetProcessImageFileNameW (
    __in HANDLE hProcess,
    __out_ecount(nSize) LPWSTR lpImageFileName,
    __in DWORD nSize
    );

#ifdef UNICODE
#define GetProcessImageFileName  GetProcessImageFileNameW
#else
#define GetProcessImageFileName  GetProcessImageFileNameA
#endif // !UNICODE

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\PshPack4.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack4.h

Abstract:

    This file turns 4 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 && !defined(_M_I86)) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push,4)
#else
#pragma pack(4)
#endif
#else
#pragma pack(4)
#endif
#endif /* ! (defined(lint) || defined(RC_INVOKED)) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Provider.h ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  Provider.h
//
//  Purpose: declaration of Provider class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _PROVIDER_H__
#define _PROVIDER_H__

/////////////////////////////////////////////////////
// INSTANCE Provider
//
// pure virtual base class for providers
// holds instances
// gathers information and instantiates instances
/////////////////////////////////////////////////////
class POLARITY Provider : public CThreadBase
{
    // CWbemProviderGlue needs to access some protected/private methods
    // which we don't want to publish to just anyone.

    friend class CWbemProviderGlue;

public:
    Provider( LPCWSTR a_pszName, LPCWSTR a_pszNameSpace = NULL );
    ~Provider();
    static BOOL initFailed();


protected:
    /* Override These Methods To Implement Your Provider */

    // This is the entrypoint for changes.
    // You are handed a changed instance.
    // If you can make the changes - do so.
    // If you cannot return an appropriate error code (WBEM_E_XXXXXXX)
    // base object returns WBEM_E_PROVIDER_NOT_CAPABLE
    virtual HRESULT PutInstance(const CInstance& newInstance, long lFlags = 0L);

    // entrypoint to delete an instance
    // examine the instance passed in, determine whether you can delete it
    virtual HRESULT DeleteInstance(const CInstance& newInstance, long lFlags = 0L);

    // execute a method
    virtual HRESULT ExecMethod(const CInstance& cInstance, 
        __in const BSTR bstrMethodName, 
        __in CInstance *pInParams, 
        __out CInstance *pOutParams, 
        long lFlags = 0L);

    // find and create all instances of your class
    virtual HRESULT EnumerateInstances(__in MethodContext *pMethodContext, long lFlags = 0L);

    // you will be given an object with the key properties filled in
    // you need to fill in all of the rest of the properties, or
    // return WBEM_E_NOT_FOUND if the object doesn't exist.
    virtual HRESULT GetObject(__inout CInstance *pInstance, long lFlags = 0L);

    // You will be given an object with the key properties filled in.
    // You can either fill in all the properties, or check the Query object
    // to see what properties are required.  If you don't implement this method, the
    // GetObject(CInstance, long) method will be called instead.
    virtual HRESULT GetObject(__inout CInstance *pInstance, long lFlags, __in CFrameworkQuery &Query);

    // If a provider wants to process queries, they should override this
    virtual HRESULT ExecQuery(__in MethodContext *pMethodContext, 
        __in CFrameworkQuery& cQuery, 
        long lFlags = 0L);

    // flushes cache
    // only override if you allocate memory that could be flushed
    virtual void Flush(void);

    /* Helpers - Use These, Do Not Override */

    // allocate a new instance & return pointer to it
    // the memory is your responsibility to Release()
    // UNLESS you pass it off to Provider::Commit
    CInstance *CreateNewInstance(__in MethodContext *pMethodContext);

    // used to send your new instance back to the framework
    // set bCache to true to cache object 
    // !! caching is NOT IMPLEMENTED in this release !!
    // do not delete or release the pointer once committed.
    HRESULT Commit(__inout CInstance *pInstance, bool bCache = false);

    // Helper function for building a WBEM Object Path for a local Instance
    bool GetLocalInstancePath( const CInstance *pInstance, __out CHString& strPath );

    //   Builds a full instance path from a relative path
    CHString MakeLocalPath( const CHString &strRelPath );

    // Returns the computer name as a CHString.  Save yourself the os call,
    // since we've got it hanging around anyway.
    const CHString &GetLocalComputerName() {return s_strComputerName;}
    const CHString &GetNamespace() {return m_strNameSpace;}

    // sets the CreationClassName property to the name of this provider
    bool SetCreationClassName(__inout CInstance *pInstance);

    // accesses the name of the provider
    const CHString &GetProviderName() {return m_name;}

    // Flag validation constants
    enum FlagDefs
    {
        EnumerationFlags = (WBEM_FLAG_DIRECT_READ | WBEM_FLAG_SEND_STATUS),
        GetObjFlags = (WBEM_FLAG_SEND_STATUS | WBEM_FLAG_DIRECT_READ),
        MethodFlags = WBEM_FLAG_SEND_STATUS,
        DeletionFlags = WBEM_FLAG_SEND_STATUS,
        PutInstanceFlags = (WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_SEND_STATUS),
        QueryFlags = WBEM_FLAG_SEND_STATUS | WBEM_FLAG_DIRECT_READ
    };

    // returns WBEM_E_UNSUPPORTED_PARAMETER or WBEM_S_NO_ERROR
    HRESULT ValidateFlags(long lFlags, FlagDefs lAcceptableFlags);

    // you can override the following to support flags 
    // above and beyond those listed in FlagDefs above
    virtual HRESULT ValidateEnumerationFlags(long lFlags);
    virtual HRESULT ValidateGetObjFlags(long lFlags);
    virtual HRESULT ValidateMethodFlags(long lFlags);
    virtual HRESULT ValidateQueryFlags(long lFlags);
    virtual HRESULT ValidateDeletionFlags(long lFlags);
    virtual HRESULT ValidatePutInstanceFlags(long lFlags);

private:
    static BOOL initFailed_;

    IWbemServices       *m_pIMosProvider;    // provides instances
    CHString            m_name;             // name of this provider
    CHString            m_strNameSpace;     // name of this provider's namespace
    IWbemClassObject    *m_piClassObject;    // holds class object from which others are cloned.

    static CHString     s_strComputerName;  // Holds the computer name for building
    // instance paths.

    BOOL ValidateIMOSPointer( void );       // This function ensures that our IMOS
    // pointer is available, and is called
    // by the framework entrypoint functions

    /* Interfaces For Use by the Framework         */
    HRESULT GetObject(  __in ParsedObjectPath *pParsedObjectPath, 
        __in MethodContext *pContext, long lFlags = 0L );

    HRESULT ExecuteQuery( __in MethodContext *pContext, 
        __in CFrameworkQuery &pQuery, 
        long lFlags = 0L);

    HRESULT CreateInstanceEnum( __in MethodContext *pContext, long lFlags = 0L );

    HRESULT PutInstance( __in IWbemClassObject __RPC_FAR *pInst,
        long lFlags,
        __in MethodContext *pContext );

    HRESULT DeleteInstance( __in ParsedObjectPath *pParsedObjectPath,
        long lFlags,
        __in MethodContext *pContext );

    HRESULT ExecMethod( __in ParsedObjectPath *pParsedObjectPath,
        __in BSTR bstrMethodName,
        long lFlags,
        __in CInstance *pInParams,
        __out CInstance *pOutParams,
        __in MethodContext *pContext );

    // Static helper function called by constructor to make sure the
    // computer name variable is properly initialized.
    static void WINAPI InitComputerName( void );

    // Sets an instance key from a parsed object path.
    BOOL SetKeyFromParsedObjectPath( __inout CInstance *pInstance, 
        __in ParsedObjectPath *pParsedObjectPath );

    IWbemClassObject *GetClassObjectInterface(__in MethodContext *pMethodContext);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\prsht.inl ===
/* Copyright (c) 2001-2009, Microsoft Corp. All rights reserved. */

#if _MSC_VER > 1000
#pragma once
#endif

#if defined(__cplusplus)
extern "C" {
#endif


#if !defined(RC_INVOKED) /* RC complains about long symbols in #ifs */
#if defined(ISOLATION_AWARE_ENABLED) && (ISOLATION_AWARE_ENABLED != 0)


#if !defined(ISOLATION_AWARE_USE_STATIC_LIBRARY)
#define ISOLATION_AWARE_USE_STATIC_LIBRARY 0
#endif

#if !defined(ISOLATION_AWARE_BUILD_STATIC_LIBRARY)
#define ISOLATION_AWARE_BUILD_STATIC_LIBRARY 0
#endif

#if !defined(ISOLATION_AWARE_INLINE)
#if ISOLATION_AWARE_BUILD_STATIC_LIBRARY
#define ISOLATION_AWARE_INLINE /* nothing */
#else
#if defined(__cplusplus)
#define ISOLATION_AWARE_INLINE inline
#else
#define ISOLATION_AWARE_INLINE __inline
#endif
#endif
#endif

#if !ISOLATION_AWARE_USE_STATIC_LIBRARY
FARPROC IsolationAwarePrivatenCv PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY(LPCSTR pszProcName);

#endif /* ISOLATION_AWARE_USE_STATIC_LIBRARY */
HPROPSHEETPAGE IsolationAwarePrivatenCv IsolationAwareCreatePropertySheetPageA(LPCPROPSHEETPAGEA constPropSheetPagePointer);
HPROPSHEETPAGE IsolationAwarePrivatenCv IsolationAwareCreatePropertySheetPageW(LPCPROPSHEETPAGEW constPropSheetPagePointer);
BOOL IsolationAwarePrivatenCv IsolationAwareDestroyPropertySheetPage(HPROPSHEETPAGE unnamed1);
INT_PTR IsolationAwarePrivatenCv IsolationAwarePropertySheetA(LPCPROPSHEETHEADERA unnamed1);
INT_PTR IsolationAwarePrivatenCv IsolationAwarePropertySheetW(LPCPROPSHEETHEADERW unnamed1);

#if defined(UNICODE)

#define IsolationAwareCreatePropertySheetPage IsolationAwareCreatePropertySheetPageW
#define IsolationAwarePropertySheet IsolationAwarePropertySheetW

#else /* UNICODE */

#define IsolationAwareCreatePropertySheetPage IsolationAwareCreatePropertySheetPageA
#define IsolationAwarePropertySheet IsolationAwarePropertySheetA

#endif /* UNICODE */

#if !ISOLATION_AWARE_USE_STATIC_LIBRARY
ISOLATION_AWARE_INLINE HPROPSHEETPAGE IsolationAwarePrivatenCv IsolationAwareCreatePropertySheetPageA(LPCPROPSHEETPAGEA constPropSheetPagePointer)
{
    HPROPSHEETPAGE result = NULL;
    typedef HPROPSHEETPAGE (WINAPI* PFN)(LPCPROPSHEETPAGEA constPropSheetPagePointer);
    static PFN s_pfn;
    PFN __IsolationAware_pfn = s_pfn;

    const LPPROPSHEETPAGEA_LATEST latestPropSheetPagePointer = (LPPROPSHEETPAGEA_LATEST)constPropSheetPagePointer;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        if (__IsolationAware_pfn == NULL)
        {
            __IsolationAware_pfn = (PFN) PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("CreatePropertySheetPageA");
            if (__IsolationAware_pfn == NULL)
                __leave;
            s_pfn = __IsolationAware_pfn;
        }

#ifndef _WIN64
        if (IsolationAwarePrivateT_SqbjaYRiRY)
        {
            if ((latestPropSheetPagePointer->dwFlags & PSP_USEFUSIONCONTEXT) != 0)
            {
                latestPropSheetPagePointer->dwFlags &= ~PSP_USEFUSIONCONTEXT;
            }
        }
        else
#endif
        if ((   latestPropSheetPagePointer->dwFlags & PSP_USEFUSIONCONTEXT) == 0
                    && latestPropSheetPagePointer->dwSize >= sizeof(PROPSHEETPAGEA_V3)
                  )
        {
            latestPropSheetPagePointer->dwFlags |= PSP_USEFUSIONCONTEXT;
            latestPropSheetPagePointer->hActCtx = WinbaseIsolationAwarePrivateT_UnPgpgk;
        }
        result = s_pfn(constPropSheetPagePointer);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE HPROPSHEETPAGE IsolationAwarePrivatenCv IsolationAwareCreatePropertySheetPageW(LPCPROPSHEETPAGEW constPropSheetPagePointer)
{
    HPROPSHEETPAGE result = NULL;
    typedef HPROPSHEETPAGE (WINAPI* PFN)(LPCPROPSHEETPAGEW constPropSheetPagePointer);
    static PFN s_pfn;
    PFN __IsolationAware_pfn = s_pfn;

    const LPPROPSHEETPAGEW_LATEST latestPropSheetPagePointer = (LPPROPSHEETPAGEW_LATEST)constPropSheetPagePointer;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return result;
    __try
    {
        if (__IsolationAware_pfn == NULL)
        {
            __IsolationAware_pfn = (PFN) PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("CreatePropertySheetPageW");
            if (__IsolationAware_pfn == NULL)
                __leave;
            s_pfn = __IsolationAware_pfn;
        }

#ifndef _WIN64
        if (IsolationAwarePrivateT_SqbjaYRiRY)
        {
            if ((latestPropSheetPagePointer->dwFlags & PSP_USEFUSIONCONTEXT) != 0)
            {
                latestPropSheetPagePointer->dwFlags &= ~PSP_USEFUSIONCONTEXT;
            }
        }
        else
#endif
        if ((   latestPropSheetPagePointer->dwFlags & PSP_USEFUSIONCONTEXT) == 0
                    && latestPropSheetPagePointer->dwSize >= sizeof(PROPSHEETPAGEW_V3)
                  )
        {
            latestPropSheetPagePointer->dwFlags |= PSP_USEFUSIONCONTEXT;
            latestPropSheetPagePointer->hActCtx = WinbaseIsolationAwarePrivateT_UnPgpgk;
        }
        result = s_pfn(constPropSheetPagePointer);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (result == NULL);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return result;
}

ISOLATION_AWARE_INLINE BOOL IsolationAwarePrivatenCv IsolationAwareDestroyPropertySheetPage(HPROPSHEETPAGE unnamed1)
{
    BOOL fResult = FALSE;
    typedef BOOL (WINAPI* PFN)(HPROPSHEETPAGE unnamed1);
    static PFN s_pfn;
    PFN __IsolationAware_pfn = s_pfn;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return fResult;
    __try
    {
        if (__IsolationAware_pfn == NULL)
        {
            __IsolationAware_pfn = (PFN) PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("DestroyPropertySheetPage");
            if (__IsolationAware_pfn == NULL)
                __leave;
            s_pfn = __IsolationAware_pfn;
        }
        fResult = __IsolationAware_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (fResult == FALSE);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return fResult;
}

ISOLATION_AWARE_INLINE INT_PTR IsolationAwarePrivatenCv IsolationAwarePropertySheetA(LPCPROPSHEETHEADERA unnamed1)
{
    INT_PTR nResult = -1;
    typedef INT_PTR (WINAPI* PFN)(LPCPROPSHEETHEADERA unnamed1);
    static PFN s_pfn;
    PFN __IsolationAware_pfn = s_pfn;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (__IsolationAware_pfn == NULL)
        {
            __IsolationAware_pfn = (PFN) PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("PropertySheetA");
            if (__IsolationAware_pfn == NULL)
                __leave;
            s_pfn = __IsolationAware_pfn;
        }
        nResult = __IsolationAware_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE INT_PTR IsolationAwarePrivatenCv IsolationAwarePropertySheetW(LPCPROPSHEETHEADERW unnamed1)
{
    INT_PTR nResult = -1;
    typedef INT_PTR (WINAPI* PFN)(LPCPROPSHEETHEADERW unnamed1);
    static PFN s_pfn;
    PFN __IsolationAware_pfn = s_pfn;
    ULONG_PTR ulpCookie = 0;
    const BOOL fActivateActCtxSuccess =
#ifdef _M_IX86
        IsolationAwarePrivateT_SqbjaYRiRY ||
#endif
        IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
    if (!fActivateActCtxSuccess)
        return nResult;
    __try
    {
        if (__IsolationAware_pfn == NULL)
        {
            __IsolationAware_pfn = (PFN) PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("PropertySheetW");
            if (__IsolationAware_pfn == NULL)
                __leave;
            s_pfn = __IsolationAware_pfn;
        }
        nResult = __IsolationAware_pfn(unnamed1);
    }
    __finally
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            const BOOL fPreserveLastError = (nResult == -1);
            const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (fPreserveLastError)
                SetLastError(dwLastError);
        }
    }
    return nResult;
}

ISOLATION_AWARE_INLINE FARPROC IsolationAwarePrivatenCv PrshtIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY(LPCSTR pszProcName)
/* This function is shared by the other stubs in this header. */
{
    FARPROC proc = NULL;
    static HMODULE s_module;
    BOOL fActivateActCtxSuccess = FALSE;
    ULONG_PTR ulpCookie = 0;
#ifndef _M_CEE_PURE
    const static IsolationAwarePrivatepBAFGnAG_zBqHyr_vAsB
        c = { IsolationAwarePrivatezlybNQyVOeNelJ, L"Comctl32.dll"
#ifdef _M_IX86
             , IsolationAwarePrivatezlybNQyVOeNeln, "Comctl32.dll"
#endif
    };
#else
    static IsolationAwarePrivatepBAFGnAG_zBqHyr_vAsB c;
    c.WinbaseIsolationAwarePrivateybNQJ = IsolationAwarePrivatezlybNQyVOeNelJ;
    c.WinbaseIsolationAwarePrivateANZRJ = L"Comctl32.dll";
#ifdef _M_IX86
    c.WinbaseIsolationAwarePrivateybNQn = IsolationAwarePrivatezlybNQyVOeNeln;
    c.WinbaseIsolationAwarePrivateANZRn = "Comctl32.dll";
#endif
#endif
    static IsolationAwarePrivatezHGnoyr_zBqHyr_vAsB m;

    __try
    {
#ifdef _M_IX86
        if (!IsolationAwarePrivateT_SqbjaYRiRY)
#endif
        {
            fActivateActCtxSuccess = IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);
            if (!fActivateActCtxSuccess)
                __leave;
        }
        proc = IsolationAwarePrivatezltRgCebPnQQeRff(&c, &m, pszProcName);
    }
    __finally
    {
        if (
#ifdef _M_IX86
            !IsolationAwarePrivateT_SqbjaYRiRY &&
#endif
            fActivateActCtxSuccess)
        {
            const DWORD dwLastError = (proc == NULL) ? GetLastError() : NO_ERROR;
            (void)IsolationAwareDeactivateActCtx(0, ulpCookie);
            if (proc == NULL)
                SetLastError(dwLastError);
        }
    }
    return proc;
}

#endif /* ISOLATION_AWARE_USE_STATIC_LIBRARY */

#define CreatePropertySheetPageA IsolationAwareCreatePropertySheetPageA
#define CreatePropertySheetPageW IsolationAwareCreatePropertySheetPageW
#define DestroyPropertySheetPage IsolationAwareDestroyPropertySheetPage
#define PropertySheetA IsolationAwarePropertySheetA
#define PropertySheetW IsolationAwarePropertySheetW

#endif /* ISOLATION_AWARE_ENABLED */
#endif /* RC */


#if defined(__cplusplus)
} /* __cplusplus */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\PshPack8.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pshpack8.h

Abstract:

    This file turns 8 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(RC_INVOKED))
#if ( _MSC_VER >= 800 && !defined(_M_I86)) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push,8)
#else
#pragma pack(8)
#endif
#else
#pragma pack(8)
#endif
#endif /* ! (defined(lint) || defined(RC_INVOKED)) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\qmgr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for qmgr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __qmgr_h__
#define __qmgr_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IBackgroundCopyJob1_FWD_DEFINED__
#define __IBackgroundCopyJob1_FWD_DEFINED__
typedef interface IBackgroundCopyJob1 IBackgroundCopyJob1;
#endif 	/* __IBackgroundCopyJob1_FWD_DEFINED__ */


#ifndef __IEnumBackgroundCopyJobs1_FWD_DEFINED__
#define __IEnumBackgroundCopyJobs1_FWD_DEFINED__
typedef interface IEnumBackgroundCopyJobs1 IEnumBackgroundCopyJobs1;
#endif 	/* __IEnumBackgroundCopyJobs1_FWD_DEFINED__ */


#ifndef __IBackgroundCopyGroup_FWD_DEFINED__
#define __IBackgroundCopyGroup_FWD_DEFINED__
typedef interface IBackgroundCopyGroup IBackgroundCopyGroup;
#endif 	/* __IBackgroundCopyGroup_FWD_DEFINED__ */


#ifndef __IEnumBackgroundCopyGroups_FWD_DEFINED__
#define __IEnumBackgroundCopyGroups_FWD_DEFINED__
typedef interface IEnumBackgroundCopyGroups IEnumBackgroundCopyGroups;
#endif 	/* __IEnumBackgroundCopyGroups_FWD_DEFINED__ */


#ifndef __IBackgroundCopyCallback1_FWD_DEFINED__
#define __IBackgroundCopyCallback1_FWD_DEFINED__
typedef interface IBackgroundCopyCallback1 IBackgroundCopyCallback1;
#endif 	/* __IBackgroundCopyCallback1_FWD_DEFINED__ */


#ifndef __IBackgroundCopyQMgr_FWD_DEFINED__
#define __IBackgroundCopyQMgr_FWD_DEFINED__
typedef interface IBackgroundCopyQMgr IBackgroundCopyQMgr;
#endif 	/* __IBackgroundCopyQMgr_FWD_DEFINED__ */


#ifndef __BackgroundCopyQMgr_FWD_DEFINED__
#define __BackgroundCopyQMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class BackgroundCopyQMgr BackgroundCopyQMgr;
#else
typedef struct BackgroundCopyQMgr BackgroundCopyQMgr;
#endif /* __cplusplus */

#endif 	/* __BackgroundCopyQMgr_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "ocidl.h"
#include "docobj.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_qmgr_0000_0000 */
/* [local] */ 

// Background Copy QMgr Public Interface
#define  QM_NOTIFY_FILE_DONE         0x00000001
#define  QM_NOTIFY_JOB_DONE          0x00000002
#define  QM_NOTIFY_GROUP_DONE        0x00000004
#define  QM_NOTIFY_DISABLE_NOTIFY    0x00000040
#define  QM_NOTIFY_USE_PROGRESSEX    0x00000080
#define  QM_STATUS_FILE_COMPLETE     0x00000001
#define  QM_STATUS_FILE_INCOMPLETE   0x00000002
#define  QM_STATUS_JOB_COMPLETE      0x00000004
#define  QM_STATUS_JOB_INCOMPLETE    0x00000008
#define  QM_STATUS_JOB_ERROR         0x00000010
#define  QM_STATUS_JOB_FOREGROUND    0x00000020
#define  QM_STATUS_GROUP_COMPLETE    0x00000040
#define  QM_STATUS_GROUP_INCOMPLETE  0x00000080
#define  QM_STATUS_GROUP_SUSPENDED   0x00000100
#define  QM_STATUS_GROUP_ERROR       0x00000200
#define  QM_STATUS_GROUP_FOREGROUND  0x00000400
#define  QM_PROTOCOL_HTTP            1
#define  QM_PROTOCOL_FTP             2
#define  QM_PROTOCOL_SMB             3
#define  QM_PROTOCOL_CUSTOM          4
#define  QM_PROGRESS_PERCENT_DONE    1
#define  QM_PROGRESS_TIME_DONE       2
#define  QM_PROGRESS_SIZE_DONE       3
#define  QM_E_INVALID_STATE          0x81001001
#define  QM_E_SERVICE_UNAVAILABLE    0x81001002
#define  QM_E_DOWNLOADER_UNAVAILABLE 0x81001003
#define  QM_E_ITEM_NOT_FOUND         0x81001004


extern RPC_IF_HANDLE __MIDL_itf_qmgr_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_qmgr_0000_0000_v0_0_s_ifspec;

#ifndef __IBackgroundCopyJob1_INTERFACE_DEFINED__
#define __IBackgroundCopyJob1_INTERFACE_DEFINED__

/* interface IBackgroundCopyJob1 */
/* [object][helpstring][uuid] */ 

typedef struct _FILESETINFO
    {
    BSTR bstrRemoteFile;
    BSTR bstrLocalFile;
    DWORD dwSizeHint;
    } 	FILESETINFO;


EXTERN_C const IID IID_IBackgroundCopyJob1;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59f5553c-2031-4629-bb18-2645a6970947")
    IBackgroundCopyJob1 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CancelJob( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgress( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__out DWORD *pdwProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ __RPC__out DWORD *pdwStatus,
            /* [out] */ __RPC__out DWORD *pdwWin32Result,
            /* [out] */ __RPC__out DWORD *pdwTransportResult,
            /* [out] */ __RPC__out DWORD *pdwNumOfRetries) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFiles( 
            /* [in] */ ULONG cFileCount,
            /* [size_is][in] */ __RPC__in_ecount_full(cFileCount) FILESETINFO **ppFileSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFile( 
            /* [in] */ ULONG cFileIndex,
            /* [out] */ __RPC__out FILESETINFO *pFileInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileCount( 
            /* [out] */ __RPC__out DWORD *pdwFileCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SwitchToForeground( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_JobID( 
            /* [out] */ __RPC__out GUID *pguidJobID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyJob1Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IBackgroundCopyJob1 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IBackgroundCopyJob1 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IBackgroundCopyJob1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CancelJob )( 
            __RPC__in IBackgroundCopyJob1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgress )( 
            __RPC__in IBackgroundCopyJob1 * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__out DWORD *pdwProgress);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            __RPC__in IBackgroundCopyJob1 * This,
            /* [out] */ __RPC__out DWORD *pdwStatus,
            /* [out] */ __RPC__out DWORD *pdwWin32Result,
            /* [out] */ __RPC__out DWORD *pdwTransportResult,
            /* [out] */ __RPC__out DWORD *pdwNumOfRetries);
        
        HRESULT ( STDMETHODCALLTYPE *AddFiles )( 
            __RPC__in IBackgroundCopyJob1 * This,
            /* [in] */ ULONG cFileCount,
            /* [size_is][in] */ __RPC__in_ecount_full(cFileCount) FILESETINFO **ppFileSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetFile )( 
            __RPC__in IBackgroundCopyJob1 * This,
            /* [in] */ ULONG cFileIndex,
            /* [out] */ __RPC__out FILESETINFO *pFileInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileCount )( 
            __RPC__in IBackgroundCopyJob1 * This,
            /* [out] */ __RPC__out DWORD *pdwFileCount);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToForeground )( 
            __RPC__in IBackgroundCopyJob1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_JobID )( 
            __RPC__in IBackgroundCopyJob1 * This,
            /* [out] */ __RPC__out GUID *pguidJobID);
        
        END_INTERFACE
    } IBackgroundCopyJob1Vtbl;

    interface IBackgroundCopyJob1
    {
        CONST_VTBL struct IBackgroundCopyJob1Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyJob1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBackgroundCopyJob1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBackgroundCopyJob1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBackgroundCopyJob1_CancelJob(This)	\
    ( (This)->lpVtbl -> CancelJob(This) ) 

#define IBackgroundCopyJob1_GetProgress(This,dwFlags,pdwProgress)	\
    ( (This)->lpVtbl -> GetProgress(This,dwFlags,pdwProgress) ) 

#define IBackgroundCopyJob1_GetStatus(This,pdwStatus,pdwWin32Result,pdwTransportResult,pdwNumOfRetries)	\
    ( (This)->lpVtbl -> GetStatus(This,pdwStatus,pdwWin32Result,pdwTransportResult,pdwNumOfRetries) ) 

#define IBackgroundCopyJob1_AddFiles(This,cFileCount,ppFileSet)	\
    ( (This)->lpVtbl -> AddFiles(This,cFileCount,ppFileSet) ) 

#define IBackgroundCopyJob1_GetFile(This,cFileIndex,pFileInfo)	\
    ( (This)->lpVtbl -> GetFile(This,cFileIndex,pFileInfo) ) 

#define IBackgroundCopyJob1_GetFileCount(This,pdwFileCount)	\
    ( (This)->lpVtbl -> GetFileCount(This,pdwFileCount) ) 

#define IBackgroundCopyJob1_SwitchToForeground(This)	\
    ( (This)->lpVtbl -> SwitchToForeground(This) ) 

#define IBackgroundCopyJob1_get_JobID(This,pguidJobID)	\
    ( (This)->lpVtbl -> get_JobID(This,pguidJobID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBackgroundCopyJob1_INTERFACE_DEFINED__ */


#ifndef __IEnumBackgroundCopyJobs1_INTERFACE_DEFINED__
#define __IEnumBackgroundCopyJobs1_INTERFACE_DEFINED__

/* interface IEnumBackgroundCopyJobs1 */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumBackgroundCopyJobs1;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8baeba9d-8f1c-42c4-b82c-09ae79980d25")
    IEnumBackgroundCopyJobs1 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) GUID *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyJobs1 **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *puCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumBackgroundCopyJobs1Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumBackgroundCopyJobs1 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumBackgroundCopyJobs1 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumBackgroundCopyJobs1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumBackgroundCopyJobs1 * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) GUID *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumBackgroundCopyJobs1 * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumBackgroundCopyJobs1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumBackgroundCopyJobs1 * This,
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyJobs1 **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IEnumBackgroundCopyJobs1 * This,
            /* [out] */ __RPC__out ULONG *puCount);
        
        END_INTERFACE
    } IEnumBackgroundCopyJobs1Vtbl;

    interface IEnumBackgroundCopyJobs1
    {
        CONST_VTBL struct IEnumBackgroundCopyJobs1Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumBackgroundCopyJobs1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumBackgroundCopyJobs1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumBackgroundCopyJobs1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumBackgroundCopyJobs1_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumBackgroundCopyJobs1_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumBackgroundCopyJobs1_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumBackgroundCopyJobs1_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#define IEnumBackgroundCopyJobs1_GetCount(This,puCount)	\
    ( (This)->lpVtbl -> GetCount(This,puCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumBackgroundCopyJobs1_INTERFACE_DEFINED__ */


#ifndef __IBackgroundCopyGroup_INTERFACE_DEFINED__
#define __IBackgroundCopyGroup_INTERFACE_DEFINED__

/* interface IBackgroundCopyGroup */
/* [object][helpstring][uuid] */ 

typedef 
enum GROUPPROP
    {	GROUPPROP_PRIORITY	= 0,
	GROUPPROP_REMOTEUSERID	= 1,
	GROUPPROP_REMOTEUSERPWD	= 2,
	GROUPPROP_LOCALUSERID	= 3,
	GROUPPROP_LOCALUSERPWD	= 4,
	GROUPPROP_PROTOCOLFLAGS	= 5,
	GROUPPROP_NOTIFYFLAGS	= 6,
	GROUPPROP_NOTIFYCLSID	= 7,
	GROUPPROP_PROGRESSSIZE	= 8,
	GROUPPROP_PROGRESSPERCENT	= 9,
	GROUPPROP_PROGRESSTIME	= 10,
	GROUPPROP_DISPLAYNAME	= 11,
	GROUPPROP_DESCRIPTION	= 12
    } 	GROUPPROP;


EXTERN_C const IID IID_IBackgroundCopyGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1ded80a7-53ea-424f-8a04-17fea9adc4f5")
    IBackgroundCopyGroup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProp( 
            /* [in] */ GROUPPROP propID,
            /* [out] */ __RPC__out VARIANT *pvarVal) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetProp( 
            /* [in] */ GROUPPROP propID,
            /* [in] */ VARIANT *pvarVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgress( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__out DWORD *pdwProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ __RPC__out DWORD *pdwStatus,
            /* [out] */ __RPC__out DWORD *pdwJobIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetJob( 
            /* [in] */ GUID jobID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyJob1 **ppJob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspendGroup( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResumeGroup( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelGroup( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Size( 
            /* [out] */ __RPC__out DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_GroupID( 
            /* [out] */ __RPC__out GUID *pguidGroupID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateJob( 
            /* [in] */ GUID guidJobID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyJob1 **ppJob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumJobs( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyJobs1 **ppEnumJobs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SwitchToForeground( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryNewJobInterface( 
            /* [in] */ __RPC__in REFIID iid,
            /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNotificationPointer( 
            /* [in] */ __RPC__in REFIID iid,
            /* [in] */ __RPC__in_opt IUnknown *pUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IBackgroundCopyGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IBackgroundCopyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProp )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [in] */ GROUPPROP propID,
            /* [out] */ __RPC__out VARIANT *pvarVal);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetProp )( 
            IBackgroundCopyGroup * This,
            /* [in] */ GROUPPROP propID,
            /* [in] */ VARIANT *pvarVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgress )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__out DWORD *pdwProgress);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [out] */ __RPC__out DWORD *pdwStatus,
            /* [out] */ __RPC__out DWORD *pdwJobIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetJob )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [in] */ GUID jobID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyJob1 **ppJob);
        
        HRESULT ( STDMETHODCALLTYPE *SuspendGroup )( 
            __RPC__in IBackgroundCopyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResumeGroup )( 
            __RPC__in IBackgroundCopyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *CancelGroup )( 
            __RPC__in IBackgroundCopyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_Size )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [out] */ __RPC__out DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *get_GroupID )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [out] */ __RPC__out GUID *pguidGroupID);
        
        HRESULT ( STDMETHODCALLTYPE *CreateJob )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [in] */ GUID guidJobID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyJob1 **ppJob);
        
        HRESULT ( STDMETHODCALLTYPE *EnumJobs )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyJobs1 **ppEnumJobs);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToForeground )( 
            __RPC__in IBackgroundCopyGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryNewJobInterface )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [in] */ __RPC__in REFIID iid,
            /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **pUnk);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotificationPointer )( 
            __RPC__in IBackgroundCopyGroup * This,
            /* [in] */ __RPC__in REFIID iid,
            /* [in] */ __RPC__in_opt IUnknown *pUnk);
        
        END_INTERFACE
    } IBackgroundCopyGroupVtbl;

    interface IBackgroundCopyGroup
    {
        CONST_VTBL struct IBackgroundCopyGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyGroup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBackgroundCopyGroup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBackgroundCopyGroup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBackgroundCopyGroup_GetProp(This,propID,pvarVal)	\
    ( (This)->lpVtbl -> GetProp(This,propID,pvarVal) ) 

#define IBackgroundCopyGroup_SetProp(This,propID,pvarVal)	\
    ( (This)->lpVtbl -> SetProp(This,propID,pvarVal) ) 

#define IBackgroundCopyGroup_GetProgress(This,dwFlags,pdwProgress)	\
    ( (This)->lpVtbl -> GetProgress(This,dwFlags,pdwProgress) ) 

#define IBackgroundCopyGroup_GetStatus(This,pdwStatus,pdwJobIndex)	\
    ( (This)->lpVtbl -> GetStatus(This,pdwStatus,pdwJobIndex) ) 

#define IBackgroundCopyGroup_GetJob(This,jobID,ppJob)	\
    ( (This)->lpVtbl -> GetJob(This,jobID,ppJob) ) 

#define IBackgroundCopyGroup_SuspendGroup(This)	\
    ( (This)->lpVtbl -> SuspendGroup(This) ) 

#define IBackgroundCopyGroup_ResumeGroup(This)	\
    ( (This)->lpVtbl -> ResumeGroup(This) ) 

#define IBackgroundCopyGroup_CancelGroup(This)	\
    ( (This)->lpVtbl -> CancelGroup(This) ) 

#define IBackgroundCopyGroup_get_Size(This,pdwSize)	\
    ( (This)->lpVtbl -> get_Size(This,pdwSize) ) 

#define IBackgroundCopyGroup_get_GroupID(This,pguidGroupID)	\
    ( (This)->lpVtbl -> get_GroupID(This,pguidGroupID) ) 

#define IBackgroundCopyGroup_CreateJob(This,guidJobID,ppJob)	\
    ( (This)->lpVtbl -> CreateJob(This,guidJobID,ppJob) ) 

#define IBackgroundCopyGroup_EnumJobs(This,dwFlags,ppEnumJobs)	\
    ( (This)->lpVtbl -> EnumJobs(This,dwFlags,ppEnumJobs) ) 

#define IBackgroundCopyGroup_SwitchToForeground(This)	\
    ( (This)->lpVtbl -> SwitchToForeground(This) ) 

#define IBackgroundCopyGroup_QueryNewJobInterface(This,iid,pUnk)	\
    ( (This)->lpVtbl -> QueryNewJobInterface(This,iid,pUnk) ) 

#define IBackgroundCopyGroup_SetNotificationPointer(This,iid,pUnk)	\
    ( (This)->lpVtbl -> SetNotificationPointer(This,iid,pUnk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_InternalSetProp_Proxy( 
    __RPC__in IBackgroundCopyGroup * This,
    /* [in] */ GROUPPROP propID,
    /* [in] */ __RPC__in VARIANT *pvarVal);


void __RPC_STUB IBackgroundCopyGroup_InternalSetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBackgroundCopyGroup_INTERFACE_DEFINED__ */


#ifndef __IEnumBackgroundCopyGroups_INTERFACE_DEFINED__
#define __IEnumBackgroundCopyGroups_INTERFACE_DEFINED__

/* interface IEnumBackgroundCopyGroups */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumBackgroundCopyGroups;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d993e603-4aa4-47c5-8665-c20d39c2ba4f")
    IEnumBackgroundCopyGroups : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) GUID *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyGroups **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *puCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumBackgroundCopyGroupsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumBackgroundCopyGroups * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumBackgroundCopyGroups * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumBackgroundCopyGroups * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumBackgroundCopyGroups * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) GUID *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumBackgroundCopyGroups * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumBackgroundCopyGroups * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumBackgroundCopyGroups * This,
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyGroups **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IEnumBackgroundCopyGroups * This,
            /* [out] */ __RPC__out ULONG *puCount);
        
        END_INTERFACE
    } IEnumBackgroundCopyGroupsVtbl;

    interface IEnumBackgroundCopyGroups
    {
        CONST_VTBL struct IEnumBackgroundCopyGroupsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumBackgroundCopyGroups_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumBackgroundCopyGroups_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumBackgroundCopyGroups_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumBackgroundCopyGroups_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumBackgroundCopyGroups_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumBackgroundCopyGroups_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumBackgroundCopyGroups_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#define IEnumBackgroundCopyGroups_GetCount(This,puCount)	\
    ( (This)->lpVtbl -> GetCount(This,puCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumBackgroundCopyGroups_INTERFACE_DEFINED__ */


#ifndef __IBackgroundCopyCallback1_INTERFACE_DEFINED__
#define __IBackgroundCopyCallback1_INTERFACE_DEFINED__

/* interface IBackgroundCopyCallback1 */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IBackgroundCopyCallback1;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("084f6593-3800-4e08-9b59-99fa59addf82")
    IBackgroundCopyCallback1 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStatus( 
            /* [in] */ __RPC__in_opt IBackgroundCopyGroup *pGroup,
            /* [in] */ __RPC__in_opt IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwStatus,
            /* [in] */ DWORD dwNumOfRetries,
            /* [in] */ DWORD dwWin32Result,
            /* [in] */ DWORD dwTransportResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ DWORD ProgressType,
            /* [in] */ __RPC__in_opt IBackgroundCopyGroup *pGroup,
            /* [in] */ __RPC__in_opt IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwProgressValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnProgressEx( 
            /* [in] */ DWORD ProgressType,
            /* [in] */ __RPC__in_opt IBackgroundCopyGroup *pGroup,
            /* [in] */ __RPC__in_opt IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwProgressValue,
            /* [in] */ DWORD dwByteArraySize,
            /* [size_is][in] */ __RPC__in_ecount_full(dwByteArraySize) BYTE *pByte) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyCallback1Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IBackgroundCopyCallback1 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IBackgroundCopyCallback1 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IBackgroundCopyCallback1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStatus )( 
            __RPC__in IBackgroundCopyCallback1 * This,
            /* [in] */ __RPC__in_opt IBackgroundCopyGroup *pGroup,
            /* [in] */ __RPC__in_opt IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwStatus,
            /* [in] */ DWORD dwNumOfRetries,
            /* [in] */ DWORD dwWin32Result,
            /* [in] */ DWORD dwTransportResult);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgress )( 
            __RPC__in IBackgroundCopyCallback1 * This,
            /* [in] */ DWORD ProgressType,
            /* [in] */ __RPC__in_opt IBackgroundCopyGroup *pGroup,
            /* [in] */ __RPC__in_opt IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwProgressValue);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgressEx )( 
            __RPC__in IBackgroundCopyCallback1 * This,
            /* [in] */ DWORD ProgressType,
            /* [in] */ __RPC__in_opt IBackgroundCopyGroup *pGroup,
            /* [in] */ __RPC__in_opt IBackgroundCopyJob1 *pJob,
            /* [in] */ DWORD dwFileIndex,
            /* [in] */ DWORD dwProgressValue,
            /* [in] */ DWORD dwByteArraySize,
            /* [size_is][in] */ __RPC__in_ecount_full(dwByteArraySize) BYTE *pByte);
        
        END_INTERFACE
    } IBackgroundCopyCallback1Vtbl;

    interface IBackgroundCopyCallback1
    {
        CONST_VTBL struct IBackgroundCopyCallback1Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyCallback1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBackgroundCopyCallback1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBackgroundCopyCallback1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBackgroundCopyCallback1_OnStatus(This,pGroup,pJob,dwFileIndex,dwStatus,dwNumOfRetries,dwWin32Result,dwTransportResult)	\
    ( (This)->lpVtbl -> OnStatus(This,pGroup,pJob,dwFileIndex,dwStatus,dwNumOfRetries,dwWin32Result,dwTransportResult) ) 

#define IBackgroundCopyCallback1_OnProgress(This,ProgressType,pGroup,pJob,dwFileIndex,dwProgressValue)	\
    ( (This)->lpVtbl -> OnProgress(This,ProgressType,pGroup,pJob,dwFileIndex,dwProgressValue) ) 

#define IBackgroundCopyCallback1_OnProgressEx(This,ProgressType,pGroup,pJob,dwFileIndex,dwProgressValue,dwByteArraySize,pByte)	\
    ( (This)->lpVtbl -> OnProgressEx(This,ProgressType,pGroup,pJob,dwFileIndex,dwProgressValue,dwByteArraySize,pByte) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBackgroundCopyCallback1_INTERFACE_DEFINED__ */


#ifndef __IBackgroundCopyQMgr_INTERFACE_DEFINED__
#define __IBackgroundCopyQMgr_INTERFACE_DEFINED__

/* interface IBackgroundCopyQMgr */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IBackgroundCopyQMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("16f41c69-09f5-41d2-8cd8-3c08c47bc8a8")
    IBackgroundCopyQMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateGroup( 
            /* [in] */ GUID guidGroupID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyGroup **ppGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroup( 
            /* [in] */ GUID groupID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyGroup **ppGroup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumGroups( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyGroups **ppEnumGroups) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBackgroundCopyQMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IBackgroundCopyQMgr * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IBackgroundCopyQMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IBackgroundCopyQMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateGroup )( 
            __RPC__in IBackgroundCopyQMgr * This,
            /* [in] */ GUID guidGroupID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyGroup **ppGroup);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroup )( 
            __RPC__in IBackgroundCopyQMgr * This,
            /* [in] */ GUID groupID,
            /* [out] */ __RPC__deref_out_opt IBackgroundCopyGroup **ppGroup);
        
        HRESULT ( STDMETHODCALLTYPE *EnumGroups )( 
            __RPC__in IBackgroundCopyQMgr * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IEnumBackgroundCopyGroups **ppEnumGroups);
        
        END_INTERFACE
    } IBackgroundCopyQMgrVtbl;

    interface IBackgroundCopyQMgr
    {
        CONST_VTBL struct IBackgroundCopyQMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBackgroundCopyQMgr_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBackgroundCopyQMgr_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBackgroundCopyQMgr_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBackgroundCopyQMgr_CreateGroup(This,guidGroupID,ppGroup)	\
    ( (This)->lpVtbl -> CreateGroup(This,guidGroupID,ppGroup) ) 

#define IBackgroundCopyQMgr_GetGroup(This,groupID,ppGroup)	\
    ( (This)->lpVtbl -> GetGroup(This,groupID,ppGroup) ) 

#define IBackgroundCopyQMgr_EnumGroups(This,dwFlags,ppEnumGroups)	\
    ( (This)->lpVtbl -> EnumGroups(This,dwFlags,ppEnumGroups) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBackgroundCopyQMgr_INTERFACE_DEFINED__ */



#ifndef __BackgroundCopyQMgr_LIBRARY_DEFINED__
#define __BackgroundCopyQMgr_LIBRARY_DEFINED__

/* library BackgroundCopyQMgr */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_BackgroundCopyQMgr;

EXTERN_C const CLSID CLSID_BackgroundCopyQMgr;

#ifdef __cplusplus

class DECLSPEC_UUID("69AD4AEE-51BE-439b-A92C-86AE490E8B30")
BackgroundCopyQMgr;
#endif
#endif /* __BackgroundCopyQMgr_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_SetProp_Proxy( 
    IBackgroundCopyGroup * This,
    /* [in] */ GROUPPROP propID,
    /* [in] */ VARIANT *pvarVal);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBackgroundCopyGroup_SetProp_Stub( 
    __RPC__in IBackgroundCopyGroup * This,
    /* [in] */ GROUPPROP propID,
    /* [in] */ __RPC__in VARIANT *pvarVal);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\pstore.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    pstore.h

Abstract:

    This module defines the Protected Storage COM interface and associated
    data structures.

Author:

    Scott Field (sfield)    13-Mar-97

--*/

#ifndef __PSTORE_H__
#define __PSTORE_H__

#if _MSC_VER > 1000
#pragma once
#endif

/*
    Typedefs, values
*/

// provider flags

// provider capabilities
typedef DWORD PST_PROVIDERCAPABILITIES;

#define PST_PC_PFX              0x00000001
#define PST_PC_HARDWARE         0x00000002
#define PST_PC_SMARTCARD        0x00000004
#define PST_PC_PCMCIA           0x00000008
#define PST_PC_MULTIPLE_REPOSITORIES    0x00000010
#define PST_PC_ROAMABLE         0x00000020


// NYI (not yet implemented)
typedef DWORD PST_REPOSITORYCAPABILITIES;

#define PST_RC_REMOVABLE        0x80000000


// provider storage area
typedef DWORD PST_KEY;

#define PST_KEY_CURRENT_USER    0x00000000
#define PST_KEY_LOCAL_MACHINE   0x00000001



/*
    dwDefaultConfirmationStyle flags
*/

//
// allows user to choose confirmation style
//
#define     PST_CF_DEFAULT              0x00000000

//
// forces silent item creation
//
#define     PST_CF_NONE                 0x00000001



/*
    dwPromptFlags
*/

//
// app forces confirmation to be shown
//
#define     PST_PF_ALWAYS_SHOW          0x00000001


//
// RSABase rqmt: determine if item has ui attached
//
#define     PST_PF_NEVER_SHOW           0x00000002

/*
    dwFlags values
*/

//
// Allows caller to specify creation not overwrite
// of item during WriteItem call
//
#define     PST_NO_OVERWRITE            0x00000002

//
// specifies insecure data stream to be written/read
// there is no protection or guarantees for this data
// flag only valid during item read/write calls
// default: item calls are secure
//
#define     PST_UNRESTRICTED_ITEMDATA   0x00000004


//
// on ReadItem call
// return value on success without UI on item is PST_E_OK
// return value on success with UI on item is PST_E_ITEM_EXISTS
// return value on failure is a different error code
//
#define     PST_PROMPT_QUERY            0x00000008

//
// on ReadItem, DeleteItem, for data migration purposes:
// Avoid displaying UI on ReadItem unless a custom password is required (highsecurity).
// Avoid displaying UI on DeleteItem, period.
//
#define     PST_NO_UI_MIGRATION         0x00000010



/*
    Security masks, rule modifiers
*/

//
// models access after NT access mask
//

// read, write
typedef DWORD PST_ACCESSMODE;

#define     PST_READ                0x0001
#define     PST_WRITE               0x0002


// PST_ACCESSCLAUSETYPE

// memhash, diskhash, authenticode, etc
typedef DWORD PST_ACCESSCLAUSETYPE;

//
// pbClauseData points to PST_AUTHENTICODEDATA structure.
//
#define     PST_AUTHENTICODE            1

//
// pbClauseData points to PST_BINARYCHECKDATA structure.
//
#define     PST_BINARY_CHECK            2

//
// pbClauseData points to valid Windows NT security descriptor.
// note that performance is improved on Set operations if the security
// descriptor is in self-relative format, with valid owner and group Sids
// (non-NULL).
//
#define     PST_SECURITY_DESCRIPTOR     4

//
// pbClauseData is in self-relative format
// (for internal use only)
//
#define     PST_SELF_RELATIVE_CLAUSE    0x80000000L

//
// currently access clause modifiers - NOT to be or'd together
//


//
// specified image is the immediate caller, and is an application (.exe)
//

#define     PST_AC_SINGLE_CALLER        0

//
// specified image is not necessary the immediate caller, and is an
// application (.exe)
//

#define     PST_AC_TOP_LEVEL_CALLER     1

//
// specified image is the immediate caller.  May be
// an application (.exe) or a .dll
//

#define     PST_AC_IMMEDIATE_CALLER     2


/*
    Provider Parameters
*/
//
// flush the internal cache of passwords -- temporary?
//
#define     PST_PP_FLUSH_PW_CACHE       0x1




/*
    Provider Defns
*/

//
// Microsoft Base Provider (MS_BASE_PSTPROVIDER...)
//
#define MS_BASE_PSTPROVIDER_NAME            L"System Protected Storage"

// {8A078C30-3755-11d0-A0BD-00AA0061426A}
#define MS_BASE_PSTPROVIDER_ID              { 0x8a078c30, 0x3755, 0x11d0, { 0xa0, 0xbd, 0x0, 0xaa, 0x0, 0x61, 0x42, 0x6a } }
#define MS_BASE_PSTPROVIDER_SZID            L"8A078C30-3755-11d0-A0BD-00AA0061426A"

//
// Microsoft PFX Provider (MS_PFX_PSTPROVIDER...)
//
#define MS_PFX_PSTPROVIDER_NAME             L"PFX Storage Provider"

// {3ca94f30-7ac1-11d0-8c42-00c04fc299eb}
#define MS_PFX_PSTPROVIDER_ID               { 0x3ca94f30, 0x7ac1, 0x11d0, {0x8c, 0x42, 0x00, 0xc0, 0x4f, 0xc2, 0x99, 0xeb} }
#define MS_PFX_PSTPROVIDER_SZID             L"3ca94f30-7ac1-11d0-8c42-00c04fc299eb"



/*
    Globally registered Type/Subtype guid/name pairs
*/

#define PST_CONFIGDATA_TYPE_STRING              L"Configuration Data"
// 8ec99652-8909-11d0-8c4d-00c04fc297eb
#define PST_CONFIGDATA_TYPE_GUID                        \
{   0x8ec99652,                                         \
    0x8909,                                             \
    0x11d0,                                             \
    {0x8c, 0x4d, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}    \
}

#define PST_PROTECTEDSTORAGE_SUBTYPE_STRING     L"Protected Storage"
// d3121b8e-8a7d-11d0-8c4f-00c04fc297eb
#define PST_PROTECTEDSTORAGE_SUBTYPE_GUID               \
{   0xd3121b8e,                                         \
    0x8a7d,                                             \
    0x11d0,                                             \
    {0x8c, 0x4f, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}    \
}


#define PST_PSTORE_PROVIDERS_SUBTYPE_STRING     L"Protected Storage Provider List"
// 8ed17a64-91d0-11d0-8c43-00c04fc2c621
#define PST_PSTORE_PROVIDERS_SUBTYPE_GUID               \
{                                                       \
    0x8ed17a64,                                         \
    0x91d0,                                             \
    0x11d0,                                             \
    {0x8c, 0x43, 0x00, 0xc0, 0x4f, 0xc2, 0xc6, 0x21}    \
}


//
// error codes
//


#ifndef PST_E_OK
#define PST_E_OK                        _HRESULT_TYPEDEF_(0x00000000L)


#define PST_E_FAIL                      _HRESULT_TYPEDEF_(0x800C0001L)
#define PST_E_PROV_DLL_NOT_FOUND        _HRESULT_TYPEDEF_(0x800C0002L)
#define PST_E_INVALID_HANDLE            _HRESULT_TYPEDEF_(0x800C0003L)
#define PST_E_TYPE_EXISTS               _HRESULT_TYPEDEF_(0x800C0004L)
#define PST_E_TYPE_NO_EXISTS            _HRESULT_TYPEDEF_(0x800C0005L)
#define PST_E_INVALID_RULESET           _HRESULT_TYPEDEF_(0x800C0006L)
#define PST_E_NO_PERMISSIONS            _HRESULT_TYPEDEF_(0x800C0007L)
#define PST_E_STORAGE_ERROR             _HRESULT_TYPEDEF_(0x800C0008L)
#define PST_E_CALLER_NOT_VERIFIED       _HRESULT_TYPEDEF_(0x800C0009L)
#define PST_E_WRONG_PASSWORD            _HRESULT_TYPEDEF_(0x800C000AL)
#define PST_E_DISK_IMAGE_MISMATCH       _HRESULT_TYPEDEF_(0x800C000BL)
// 000C pending
#define PST_E_UNKNOWN_EXCEPTION         _HRESULT_TYPEDEF_(0x800C000DL)
#define PST_E_BAD_FLAGS                 _HRESULT_TYPEDEF_(0x800C000EL)
#define PST_E_ITEM_EXISTS               _HRESULT_TYPEDEF_(0x800C000FL)
#define PST_E_ITEM_NO_EXISTS            _HRESULT_TYPEDEF_(0x800C0010L)
#define PST_E_SERVICE_UNAVAILABLE       _HRESULT_TYPEDEF_(0x800C0011L)
#define PST_E_NOTEMPTY                  _HRESULT_TYPEDEF_(0x800C0012L)
#define PST_E_INVALID_STRING            _HRESULT_TYPEDEF_(0x800C0013L)
#define PST_E_STATE_INVALID             _HRESULT_TYPEDEF_(0x800C0014L)
#define PST_E_NOT_OPEN                  _HRESULT_TYPEDEF_(0x800C0015L)
#define PST_E_ALREADY_OPEN              _HRESULT_TYPEDEF_(0x800C0016L)
#define PST_E_NYI                       _HRESULT_TYPEDEF_(0x800C0F00L)


#define MIN_PST_ERROR                   0x800C0001
#define MAX_PST_ERROR                   0x800C0F00

#endif  // !PST_OK



/* this ALWAYS GENERATED file contains the definitions for the interfaces */

//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

/* header files for imported files */
#include "wtypes.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Wed Apr 23 23:56:10 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */


typedef DWORD PST_PROVIDERCAPABILITIES;

typedef DWORD PST_REPOSITORYCAPABILITIES;

typedef DWORD PST_KEY;

typedef DWORD PST_ACCESSMODE;

typedef DWORD PST_ACCESSCLAUSETYPE;

typedef GUID UUID;

typedef ULARGE_INTEGER PST_PROVIDER_HANDLE;

typedef GUID PST_PROVIDERID;

typedef PST_PROVIDERID __RPC_FAR *PPST_PROVIDERID;

typedef struct  _PST_PROVIDERINFO
    {
    DWORD cbSize;
    PST_PROVIDERID ID;
    PST_PROVIDERCAPABILITIES Capabilities;
    LPWSTR szProviderName;
    }   PST_PROVIDERINFO;

typedef struct _PST_PROVIDERINFO __RPC_FAR *PPST_PROVIDERINFO;

typedef struct  _PST_TYPEINFO
    {
    DWORD cbSize;
    LPWSTR szDisplayName;
    }   PST_TYPEINFO;

typedef struct _PST_TYPEINFO __RPC_FAR *PPST_TYPEINFO;

typedef struct  _PST_PROMPTINFO
    {
    DWORD cbSize;
    DWORD dwPromptFlags;
    HWND  hwndApp;
    LPCWSTR szPrompt;
    }   PST_PROMPTINFO;

typedef struct _PST_PROMPTINFO __RPC_FAR *PPST_PROMPTINFO;

typedef struct  _PST_ACCESSCLAUSE
    {
    DWORD cbSize;
    PST_ACCESSCLAUSETYPE ClauseType;
    DWORD cbClauseData;
    /* [size_is] */ VOID __RPC_FAR *pbClauseData;
    }   PST_ACCESSCLAUSE;

typedef struct _PST_ACCESSCLAUSE __RPC_FAR *PPST_ACCESSCLAUSE;

typedef struct  _PST_ACCESSRULE
    {
    DWORD cbSize;
    PST_ACCESSMODE AccessModeFlags;
    DWORD cClauses;
    /* [size_is] */ PST_ACCESSCLAUSE __RPC_FAR *rgClauses;
    }   PST_ACCESSRULE;

typedef struct _PST_ACCESSRULE __RPC_FAR *PPST_ACCESSRULE;

typedef struct  _PST_ACCESSRULESET
    {
    DWORD cbSize;
    DWORD cRules;
    /* [size_is] */ PST_ACCESSRULE __RPC_FAR *rgRules;
    }   PST_ACCESSRULESET;

typedef struct _PST_ACCESSRULESET __RPC_FAR *PPST_ACCESSRULESET;

typedef struct  _PST_AUTHENTICODEDATA
    {
    DWORD cbSize;
    DWORD dwModifiers;
    LPCWSTR szRootCA;
    LPCWSTR szIssuer;
    LPCWSTR szPublisher;
    LPCWSTR szProgramName;
    }   PST_AUTHENTICODEDATA;

typedef struct _PST_AUTHENTICODEDATA __RPC_FAR *PPST_AUTHENTICODEDATA;

typedef struct _PST_AUTHENTICODEDATA __RPC_FAR *LPPST_AUTHENTICODEDATA;

typedef struct  _PST_BINARYCHECKDATA
    {
    DWORD cbSize;
    DWORD dwModifiers;
    LPCWSTR szFilePath;
    }   PST_BINARYCHECKDATA;

typedef struct _PST_BINARYCHECKDATA __RPC_FAR *PPST_BINARYCHECKDATA;

typedef struct _PST_BINARYCHECKDATA __RPC_FAR *LPPST_BINARYCHECKDATA;



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif



/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Wed Apr 23 23:56:14 1997
 */
/* Compiler settings for pstorec.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

#ifndef __IEnumPStoreItems_FWD_DEFINED__
#define __IEnumPStoreItems_FWD_DEFINED__
typedef interface IEnumPStoreItems IEnumPStoreItems;
#endif  /* __IEnumPStoreItems_FWD_DEFINED__ */


#ifndef __IEnumPStoreTypes_FWD_DEFINED__
#define __IEnumPStoreTypes_FWD_DEFINED__
typedef interface IEnumPStoreTypes IEnumPStoreTypes;
#endif  /* __IEnumPStoreTypes_FWD_DEFINED__ */


#ifndef __IPStore_FWD_DEFINED__
#define __IPStore_FWD_DEFINED__
typedef interface IPStore IPStore;
#endif  /* __IPStore_FWD_DEFINED__ */


#ifndef __IEnumPStoreProviders_FWD_DEFINED__
#define __IEnumPStoreProviders_FWD_DEFINED__
typedef interface IEnumPStoreProviders IEnumPStoreProviders;
#endif  /* __IEnumPStoreProviders_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

#ifndef __IEnumPStoreItems_INTERFACE_DEFINED__
#define __IEnumPStoreItems_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreItems
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IEnumPStoreItems;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IEnumPStoreItems : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ DWORD celt,
            /* [out] */ LPWSTR __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ DWORD celt) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IEnumPStoreItemsVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IEnumPStoreItems __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IEnumPStoreItems __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out] */ LPWSTR __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ DWORD celt);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IEnumPStoreItems __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IEnumPStoreItems __RPC_FAR * This,
            /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IEnumPStoreItemsVtbl;

    interface IEnumPStoreItems
    {
        CONST_VTBL struct IEnumPStoreItemsVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnumPStoreItems_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreItems_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreItems_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreItems_Next(This,celt,rgelt,pceltFetched) \
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreItems_Skip(This,celt)    \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreItems_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreItems_Clone(This,ppenum) \
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Next_Proxy(
    IEnumPStoreItems __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out] */ LPWSTR __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreItems_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Skip_Proxy(
    IEnumPStoreItems __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreItems_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Reset_Proxy(
    IEnumPStoreItems __RPC_FAR * This);


void __RPC_STUB IEnumPStoreItems_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Clone_Proxy(
    IEnumPStoreItems __RPC_FAR * This,
    /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreItems_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumPStoreItems_INTERFACE_DEFINED__ */


#ifndef __IEnumPStoreTypes_INTERFACE_DEFINED__
#define __IEnumPStoreTypes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreTypes
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IEnumPStoreTypes;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IEnumPStoreTypes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ DWORD celt,
            /* [out][size_is] */ GUID __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ DWORD celt) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IEnumPStoreTypesVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IEnumPStoreTypes __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IEnumPStoreTypes __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out][size_is] */ GUID __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ DWORD celt);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IEnumPStoreTypes __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IEnumPStoreTypes __RPC_FAR * This,
            /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IEnumPStoreTypesVtbl;

    interface IEnumPStoreTypes
    {
        CONST_VTBL struct IEnumPStoreTypesVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnumPStoreTypes_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreTypes_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreTypes_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreTypes_Next(This,celt,rgelt,pceltFetched) \
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreTypes_Skip(This,celt)    \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreTypes_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreTypes_Clone(This,ppenum) \
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Next_Proxy(
    IEnumPStoreTypes __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out][size_is] */ GUID __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreTypes_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Skip_Proxy(
    IEnumPStoreTypes __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreTypes_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Reset_Proxy(
    IEnumPStoreTypes __RPC_FAR * This);


void __RPC_STUB IEnumPStoreTypes_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Clone_Proxy(
    IEnumPStoreTypes __RPC_FAR * This,
    /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreTypes_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumPStoreTypes_INTERFACE_DEFINED__ */


#ifndef __IPStore_INTERFACE_DEFINED__
#define __IPStore_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPStore
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IPStore;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IPStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo(
            /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetProvParam(
            /* [in] */ DWORD dwParam,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE SetProvParam(
            /* [in] */ DWORD dwParam,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE CreateType(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteType(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE CreateSubtype(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetSubtypeInfo(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteSubtype(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ReadAccessRuleset(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE WriteAccessRuleset(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumTypes(
            /* [in] */ PST_KEY Key,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumSubtypes(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;

        virtual HRESULT STDMETHODCALLTYPE DeleteItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE ReadItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE WriteItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwDefaultConfirmationStyle,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE OpenItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PST_ACCESSMODE ModeFlags,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE CloseItem(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD dwFlags) = 0;

        virtual HRESULT STDMETHODCALLTYPE EnumItems(
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IPStoreVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IPStore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IPStore __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IPStore __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfo )(
            IPStore __RPC_FAR * This,
            /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProvParam )(
            IPStore __RPC_FAR * This,
            /* [in] */ DWORD dwParam,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProvParam )(
            IPStore __RPC_FAR * This,
            /* [in] */ DWORD dwParam,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateType )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteType )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSubtype )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSubtypeInfo )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteSubtype )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadAccessRuleset )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteAccessRuleset )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumTypes )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumSubtypes )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwDefaultConfirmationStyle,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PST_ACCESSMODE ModeFlags,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseItem )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD dwFlags);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumItems )(
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IPStoreVtbl;

    interface IPStore
    {
        CONST_VTBL struct IPStoreVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IPStore_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPStore_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IPStore_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IPStore_GetInfo(This,ppProperties)  \
    (This)->lpVtbl -> GetInfo(This,ppProperties)

#define IPStore_GetProvParam(This,dwParam,pcbData,ppbData,dwFlags)  \
    (This)->lpVtbl -> GetProvParam(This,dwParam,pcbData,ppbData,dwFlags)

#define IPStore_SetProvParam(This,dwParam,cbData,pbData,dwFlags)    \
    (This)->lpVtbl -> SetProvParam(This,dwParam,cbData,pbData,dwFlags)

#define IPStore_CreateType(This,Key,pType,pInfo,dwFlags)    \
    (This)->lpVtbl -> CreateType(This,Key,pType,pInfo,dwFlags)

#define IPStore_GetTypeInfo(This,Key,pType,ppInfo,dwFlags)  \
    (This)->lpVtbl -> GetTypeInfo(This,Key,pType,ppInfo,dwFlags)

#define IPStore_DeleteType(This,Key,pType,dwFlags)  \
    (This)->lpVtbl -> DeleteType(This,Key,pType,dwFlags)

#define IPStore_CreateSubtype(This,Key,pType,pSubtype,pInfo,pRules,dwFlags) \
    (This)->lpVtbl -> CreateSubtype(This,Key,pType,pSubtype,pInfo,pRules,dwFlags)

#define IPStore_GetSubtypeInfo(This,Key,pType,pSubtype,ppInfo,dwFlags)  \
    (This)->lpVtbl -> GetSubtypeInfo(This,Key,pType,pSubtype,ppInfo,dwFlags)

#define IPStore_DeleteSubtype(This,Key,pType,pSubtype,dwFlags)  \
    (This)->lpVtbl -> DeleteSubtype(This,Key,pType,pSubtype,dwFlags)

#define IPStore_ReadAccessRuleset(This,Key,pType,pSubtype,ppRules,dwFlags)  \
    (This)->lpVtbl -> ReadAccessRuleset(This,Key,pType,pSubtype,ppRules,dwFlags)

#define IPStore_WriteAccessRuleset(This,Key,pType,pSubtype,pRules,dwFlags)  \
    (This)->lpVtbl -> WriteAccessRuleset(This,Key,pType,pSubtype,pRules,dwFlags)

#define IPStore_EnumTypes(This,Key,dwFlags,ppenum)  \
    (This)->lpVtbl -> EnumTypes(This,Key,dwFlags,ppenum)

#define IPStore_EnumSubtypes(This,Key,pType,dwFlags,ppenum) \
    (This)->lpVtbl -> EnumSubtypes(This,Key,pType,dwFlags,ppenum)

#define IPStore_DeleteItem(This,Key,pItemType,pItemSubtype,szItemName,pPromptInfo,dwFlags)  \
    (This)->lpVtbl -> DeleteItem(This,Key,pItemType,pItemSubtype,szItemName,pPromptInfo,dwFlags)

#define IPStore_ReadItem(This,Key,pItemType,pItemSubtype,szItemName,pcbData,ppbData,pPromptInfo,dwFlags)    \
    (This)->lpVtbl -> ReadItem(This,Key,pItemType,pItemSubtype,szItemName,pcbData,ppbData,pPromptInfo,dwFlags)

#define IPStore_WriteItem(This,Key,pItemType,pItemSubtype,szItemName,cbData,pbData,pPromptInfo,dwDefaultConfirmationStyle,dwFlags)  \
    (This)->lpVtbl -> WriteItem(This,Key,pItemType,pItemSubtype,szItemName,cbData,pbData,pPromptInfo,dwDefaultConfirmationStyle,dwFlags)

#define IPStore_OpenItem(This,Key,pItemType,pItemSubtype,szItemName,ModeFlags,pPromptInfo,dwFlags)  \
    (This)->lpVtbl -> OpenItem(This,Key,pItemType,pItemSubtype,szItemName,ModeFlags,pPromptInfo,dwFlags)

#define IPStore_CloseItem(This,Key,pItemType,pItemSubtype,szItemName,dwFlags)   \
    (This)->lpVtbl -> CloseItem(This,Key,pItemType,pItemSubtype,szItemName,dwFlags)

#define IPStore_EnumItems(This,Key,pItemType,pItemSubtype,dwFlags,ppenum)   \
    (This)->lpVtbl -> EnumItems(This,Key,pItemType,pItemSubtype,dwFlags,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IPStore_GetInfo_Proxy(
    IPStore __RPC_FAR * This,
    /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties);


void __RPC_STUB IPStore_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetProvParam_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ DWORD dwParam,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetProvParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_SetProvParam_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ DWORD dwParam,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_SetProvParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CreateType_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CreateType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetTypeInfo_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteType_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CreateSubtype_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CreateSubtype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetSubtypeInfo_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetSubtypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteSubtype_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteSubtype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_ReadAccessRuleset_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_ReadAccessRuleset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_WriteAccessRuleset_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_WriteAccessRuleset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumTypes_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumSubtypes_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumSubtypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_ReadItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_ReadItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_WriteItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwDefaultConfirmationStyle,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_WriteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_OpenItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PST_ACCESSMODE ModeFlags,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_OpenItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CloseItem_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CloseItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumItems_Proxy(
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IPStore_INTERFACE_DEFINED__ */


#ifndef __IEnumPStoreProviders_INTERFACE_DEFINED__
#define __IEnumPStoreProviders_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreProviders
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */



EXTERN_C const IID IID_IEnumPStoreProviders;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IEnumPStoreProviders : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(
            /* [in] */ DWORD celt,
            /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;

        virtual HRESULT STDMETHODCALLTYPE Skip(
            /* [in] */ DWORD celt) = 0;

        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;

        virtual HRESULT STDMETHODCALLTYPE Clone(
            /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum) = 0;

    };

#else   /* C style interface */

    typedef struct IEnumPStoreProvidersVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IEnumPStoreProviders __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IEnumPStoreProviders __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ DWORD celt);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            IEnumPStoreProviders __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )(
            IEnumPStoreProviders __RPC_FAR * This,
            /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);

        END_INTERFACE
    } IEnumPStoreProvidersVtbl;

    interface IEnumPStoreProviders
    {
        CONST_VTBL struct IEnumPStoreProvidersVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IEnumPStoreProviders_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreProviders_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreProviders_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreProviders_Next(This,celt,rgelt,pceltFetched) \
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreProviders_Skip(This,celt)    \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreProviders_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreProviders_Clone(This,ppenum) \
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Next_Proxy(
    IEnumPStoreProviders __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreProviders_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Skip_Proxy(
    IEnumPStoreProviders __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreProviders_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Reset_Proxy(
    IEnumPStoreProviders __RPC_FAR * This);


void __RPC_STUB IEnumPStoreProviders_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Clone_Proxy(
    IEnumPStoreProviders __RPC_FAR * This,
    /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreProviders_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumPStoreProviders_INTERFACE_DEFINED__ */



#ifndef __PSTORECLib_LIBRARY_DEFINED__
#define __PSTORECLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: PSTORECLib
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [helpstring][version][uuid] */



EXTERN_C const IID LIBID_PSTORECLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CPStore;

class CPStore;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CEnumTypes;

class CEnumTypes;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CEnumItems;

class CEnumItems;
#endif
#endif /* __PSTORECLib_LIBRARY_DEFINED__ */

/****************************************
 * Generated header for interface: __MIDL__intf_0080
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */


HRESULT __stdcall PStoreCreateInstance(
    IPStore __RPC_FAR *__RPC_FAR *ppProvider,
    PST_PROVIDERID __RPC_FAR *pProviderID,
    void __RPC_FAR *pReserved,
    DWORD dwFlags);

HRESULT __stdcall PStoreEnumProviders(
    DWORD dwFlags,
    IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);



extern RPC_IF_HANDLE __MIDL__intf_0080_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0080_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif // PSTORE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\qosobjs.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    qosobjs.h

Abstract:

    This module contains QoS object definitions.

--*/

#pragma once

#ifdef __cplusplus
extern  "C" {
#endif


#define QOS_MAX_OBJECT_STRING_LENGTH    256


//
// QoS objects supported by traffic control
//
#define QOS_TRAFFIC_GENERAL_ID_BASE 4000

#define QOS_OBJECT_DS_CLASS                    (0x00000001 + QOS_TRAFFIC_GENERAL_ID_BASE)
        /* QOS_DS_CLASS structure passed */
#define QOS_OBJECT_TRAFFIC_CLASS               (0x00000002 + QOS_TRAFFIC_GENERAL_ID_BASE) 
          /* QOS_Traffic class structure passed */
#define   QOS_OBJECT_DIFFSERV                  (0x00000003 + QOS_TRAFFIC_GENERAL_ID_BASE)
          /* QOS_DIFFSERV Structure */
#define QOS_OBJECT_TCP_TRAFFIC                 (0x00000004 + QOS_TRAFFIC_GENERAL_ID_BASE)
        /* QOS_TCP_TRAFFIC structure */
#define QOS_OBJECT_FRIENDLY_NAME               (0x00000005 + QOS_TRAFFIC_GENERAL_ID_BASE)
        /* QOS_FRIENDLY_NAME structure */
#define QOS_OBJECT_STARTING_RATE               (0x00000006 + QOS_TRAFFIC_GENERAL_ID_BASE)
        /* QOS_STARTING_RATE structure */


//
// This structure is used to associate a friendly name with the flow
// 

typedef struct _QOS_FRIENDLY_NAME {
    QOS_OBJECT_HDR ObjectHdr;
    WCHAR          FriendlyName[QOS_MAX_OBJECT_STRING_LENGTH];
} QOS_FRIENDLY_NAME, *LPQOS_FRIENDLY_NAME;

//
// This structure may carry an 802.1 TrafficClass parameter which 
// has been provided to the host by a layer 2 network, for example, 
// in an 802.1 extended RSVP RESV message. If this object is obtained
// from the network, hosts will stamp the MAC headers of corresponding
// transmitted packets, with the value in the object. Otherwise, hosts
// may select a value based on the standard Intserv mapping of 
// ServiceType to 802.1 TrafficClass.
//
//

typedef struct _QOS_TRAFFIC_CLASS {

    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            TrafficClass;

} QOS_TRAFFIC_CLASS, *LPQOS_TRAFFIC_CLASS;

//
// This structure may carry an DSField parameter which  has been provided to 
// the host by a layer 3 network, for example, in an extended RSVP RESV message. 
// If this object is obtained from the network, hosts will stamp the DS Field on the
// IP header of transmitted packets, with the value in the object. Otherwise, hosts
// may select a value based on the standard Intserv mapping of ServiceType to DS Field 
//

typedef struct _QOS_DS_CLASS {

    QOS_OBJECT_HDR ObjectHdr;
    ULONG          DSField;

} QOS_DS_CLASS, *LPQOS_DS_CLASS;


//
// This structure is used to create DiffServ Flows. This creates flows in the packet scheduler
// and allows it to classify to packets based on a particular DS field. This structure takes
// a variable length array of QOS_DIFFSERV_RULE, where each DS field is specified by a 
// QOS_DIFFSERV_RULE
//
typedef struct _QOS_DIFFSERV {

    QOS_OBJECT_HDR ObjectHdr;
    ULONG          DSFieldCount;
    UCHAR          DiffservRule[1];
} QOS_DIFFSERV, *LPQOS_DIFFSERV;

//
// The rule for a Diffserv DS codepoint. 
//
typedef struct _QOS_DIFFSERV_RULE {
    UCHAR InboundDSField;
    UCHAR ConformingOutboundDSField;
    UCHAR NonConformingOutboundDSField;
    UCHAR ConformingUserPriority;
    UCHAR NonConformingUserPriority;
} QOS_DIFFSERV_RULE, *LPQOS_DIFFSERV_RULE;

// 
// This structure is passed to indicate that the IP Precedence and UserPriority mappings for the flow
// have to be set to the system defaults for TCP traffic. If this object is passed, 
// the ServiceType ==> DSField mapping, ServiceType ==> UserPriorityMapping, QOS_OBJECT_DS_CLASS
// and QOS_OBJECT_TRAFFIC_CLASS will be ignored.
//

typedef struct _QOS_TCP_TRAFFIC {
    QOS_OBJECT_HDR ObjectHdr;
} QOS_TCP_TRAFFIC, *LPQOS_TCP_TRAFFIC;


typedef struct _QOS_STARTING_RATE {
    QOS_OBJECT_HDR ObjectHdr;
    ULONG StartingTokenRate;  // In bytes per second
    ULONG RampingTime;        // In Milliseconds
} QOS_STARTING_RATE, *LPQOS_STARTING_RATE;
    

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\qnetwork.h ===
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: QuartzNetTypeLib */

#ifndef _QuartzNetTypeLib_H_
#define _QuartzNetTypeLib_H_

DEFINE_GUID(LIBID_QuartzNetTypeLib,0x56A868B1L,0x0AD4,0x11CE,0xB0,0x3A,0x00,0x20,0xAF,0x0B,0xA7,0x70);
#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

DEFINE_GUID(IID_IAMNetShowConfig,0xFA2AA8F1L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMNetShowConfig */
#undef INTERFACE
#define INTERFACE IAMNetShowConfig

DECLARE_INTERFACE_(IAMNetShowConfig, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMNetShowConfig methods */
    STDMETHOD(get_BufferingTime)(THIS_ double FAR* pBufferingTime) PURE;
    STDMETHOD(put_BufferingTime)(THIS_ double BufferingTime) PURE;
    STDMETHOD(get_UseFixedUDPPort)(THIS_ VARIANT_BOOL FAR* pUseFixedUDPPort) PURE;
    STDMETHOD(put_UseFixedUDPPort)(THIS_ VARIANT_BOOL UseFixedUDPPort) PURE;
    STDMETHOD(get_FixedUDPPort)(THIS_ long FAR* pFixedUDPPort) PURE;
    STDMETHOD(put_FixedUDPPort)(THIS_ long FixedUDPPort) PURE;
    STDMETHOD(get_UseHTTPProxy)(THIS_ VARIANT_BOOL FAR* pUseHTTPProxy) PURE;
    STDMETHOD(put_UseHTTPProxy)(THIS_ VARIANT_BOOL UseHTTPProxy) PURE;
    STDMETHOD(get_EnableAutoProxy)(THIS_ VARIANT_BOOL FAR* pEnableAutoProxy) PURE;
    STDMETHOD(put_EnableAutoProxy)(THIS_ VARIANT_BOOL EnableAutoProxy) PURE;
    STDMETHOD(get_HTTPProxyHost)(THIS_ BSTR FAR* pbstrHTTPProxyHost) PURE;
    STDMETHOD(put_HTTPProxyHost)(THIS_ BSTR bstrHTTPProxyHost) PURE;
    STDMETHOD(get_HTTPProxyPort)(THIS_ long FAR* pHTTPProxyPort) PURE;
    STDMETHOD(put_HTTPProxyPort)(THIS_ long HTTPProxyPort) PURE;
    STDMETHOD(get_EnableMulticast)(THIS_ VARIANT_BOOL FAR* pEnableMulticast) PURE;
    STDMETHOD(put_EnableMulticast)(THIS_ VARIANT_BOOL EnableMulticast) PURE;
    STDMETHOD(get_EnableUDP)(THIS_ VARIANT_BOOL FAR* pEnableUDP) PURE;
    STDMETHOD(put_EnableUDP)(THIS_ VARIANT_BOOL EnableUDP) PURE;
    STDMETHOD(get_EnableTCP)(THIS_ VARIANT_BOOL FAR* pEnableTCP) PURE;
    STDMETHOD(put_EnableTCP)(THIS_ VARIANT_BOOL EnableTCP) PURE;
    STDMETHOD(get_EnableHTTP)(THIS_ VARIANT_BOOL FAR* pEnableHTTP) PURE;
    STDMETHOD(put_EnableHTTP)(THIS_ VARIANT_BOOL EnableHTTP) PURE;
};

DEFINE_GUID(IID_IAMChannelInfo,0xFA2AA8F2L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMChannelInfo */
#undef INTERFACE
#define INTERFACE IAMChannelInfo

DECLARE_INTERFACE_(IAMChannelInfo, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMChannelInfo methods */
    STDMETHOD(get_ChannelName)(THIS_ BSTR FAR* pbstrChannelName) PURE;
    STDMETHOD(get_ChannelDescription)(THIS_ BSTR FAR* pbstrChannelDescription) PURE;
    STDMETHOD(get_ChannelURL)(THIS_ BSTR FAR* pbstrChannelURL) PURE;
    STDMETHOD(get_ContactAddress)(THIS_ BSTR FAR* pbstrContactAddress) PURE;
    STDMETHOD(get_ContactPhone)(THIS_ BSTR FAR* pbstrContactPhone) PURE;
    STDMETHOD(get_ContactEmail)(THIS_ BSTR FAR* pbstrContactEmail) PURE;
};

DEFINE_GUID(IID_IAMNetworkStatus,0xFA2AA8F3L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMNetworkStatus */
#undef INTERFACE
#define INTERFACE IAMNetworkStatus

DECLARE_INTERFACE_(IAMNetworkStatus, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMNetworkStatus methods */
    STDMETHOD(get_ReceivedPackets)(THIS_ long FAR* pReceivedPackets) PURE;
    STDMETHOD(get_RecoveredPackets)(THIS_ long FAR* pRecoveredPackets) PURE;
    STDMETHOD(get_LostPackets)(THIS_ long FAR* pLostPackets) PURE;
    STDMETHOD(get_ReceptionQuality)(THIS_ long FAR* pReceptionQuality) PURE;
    STDMETHOD(get_BufferingCount)(THIS_ long FAR* pBufferingCount) PURE;
    STDMETHOD(get_IsBroadcast)(THIS_ VARIANT_BOOL FAR* pIsBroadcast) PURE;
    STDMETHOD(get_BufferingProgress)(THIS_ long FAR* pBufferingProgress) PURE;
};

typedef enum {
    AM_EXSEEK_CANSEEK = 1,
    AM_EXSEEK_CANSCAN = 2,
    AM_EXSEEK_MARKERSEEK = 4,
    AM_EXSEEK_SCANWITHOUTCLOCK = 8,
    AM_EXSEEK_NOSTANDARDREPAINT = 16,
    AM_EXSEEK_BUFFERING = 32,
    AM_EXSEEK_SENDS_VIDEOFRAMEREADY = 64
} AMExtendedSeekingCapabilities;

DEFINE_GUID(IID_IAMExtendedSeeking,0xFA2AA8F9L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMExtendedSeeking */
#undef INTERFACE
#define INTERFACE IAMExtendedSeeking

DECLARE_INTERFACE_(IAMExtendedSeeking, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMExtendedSeeking methods */
    STDMETHOD(get_ExSeekCapabilities)(THIS_ long FAR* pExCapabilities) PURE;
    STDMETHOD(get_MarkerCount)(THIS_ long FAR* pMarkerCount) PURE;
    STDMETHOD(get_CurrentMarker)(THIS_ long FAR* pCurrentMarker) PURE;
    STDMETHOD(GetMarkerTime)(THIS_ long MarkerNum, double FAR* pMarkerTime) PURE;
    STDMETHOD(GetMarkerName)(THIS_ long MarkerNum, BSTR FAR* pbstrMarkerName) PURE;
    STDMETHOD(put_PlaybackSpeed)(THIS_ double Speed) PURE;
    STDMETHOD(get_PlaybackSpeed)(THIS_ double FAR* pSpeed) PURE;
};

DEFINE_GUID(IID_IAMNetShowExProps,0xFA2AA8F5L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMNetShowExProps */
#undef INTERFACE
#define INTERFACE IAMNetShowExProps

DECLARE_INTERFACE_(IAMNetShowExProps, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMNetShowExProps methods */
    STDMETHOD(get_SourceProtocol)(THIS_ long FAR* pSourceProtocol) PURE;
    STDMETHOD(get_Bandwidth)(THIS_ long FAR* pBandwidth) PURE;
    STDMETHOD(get_ErrorCorrection)(THIS_ BSTR FAR* pbstrErrorCorrection) PURE;
    STDMETHOD(get_CodecCount)(THIS_ long FAR* pCodecCount) PURE;
    STDMETHOD(GetCodecInstalled)(THIS_ long CodecNum, VARIANT_BOOL FAR* pCodecInstalled) PURE;
    STDMETHOD(GetCodecDescription)(THIS_ long CodecNum, BSTR FAR* pbstrCodecDescription) PURE;
    STDMETHOD(GetCodecURL)(THIS_ long CodecNum, BSTR FAR* pbstrCodecURL) PURE;
    STDMETHOD(get_CreationDate)(THIS_ DATE FAR* pCreationDate) PURE;
    STDMETHOD(get_SourceLink)(THIS_ BSTR FAR* pbstrSourceLink) PURE;
};

DEFINE_GUID(IID_IAMExtendedErrorInfo,0xFA2AA8F6L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMExtendedErrorInfo */
#undef INTERFACE
#define INTERFACE IAMExtendedErrorInfo

DECLARE_INTERFACE_(IAMExtendedErrorInfo, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMExtendedErrorInfo methods */
    STDMETHOD(get_HasError)(THIS_ VARIANT_BOOL FAR* pHasError) PURE;
    STDMETHOD(get_ErrorDescription)(THIS_ BSTR FAR* pbstrErrorDescription) PURE;
    STDMETHOD(get_ErrorCode)(THIS_ long FAR* pErrorCode) PURE;
};

DEFINE_GUID(IID_IAMMediaContent,0xFA2AA8F4L,0x8B62,0x11D0,0xA5,0x20,0x00,0x00,0x00,0x00,0x00,0x00);

/* Definition of interface: IAMMediaContent */
#undef INTERFACE
#define INTERFACE IAMMediaContent

DECLARE_INTERFACE_(IAMMediaContent, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMMediaContent methods */
    STDMETHOD(get_AuthorName)(THIS_ BSTR FAR* pbstrAuthorName) PURE;
    STDMETHOD(get_Title)(THIS_ BSTR FAR* pbstrTitle) PURE;
    STDMETHOD(get_Rating)(THIS_ BSTR FAR* pbstrRating) PURE;
    STDMETHOD(get_Description)(THIS_ BSTR FAR* pbstrDescription) PURE;
    STDMETHOD(get_Copyright)(THIS_ BSTR FAR* pbstrCopyright) PURE;
    STDMETHOD(get_BaseURL)(THIS_ BSTR FAR* pbstrBaseURL) PURE;
    STDMETHOD(get_LogoURL)(THIS_ BSTR FAR* pbstrLogoURL) PURE;
    STDMETHOD(get_LogoIconURL)(THIS_ BSTR FAR* pbstrLogoURL) PURE;
    STDMETHOD(get_WatermarkURL)(THIS_ BSTR FAR* pbstrWatermarkURL) PURE;
    STDMETHOD(get_MoreInfoURL)(THIS_ BSTR FAR* pbstrMoreInfoURL) PURE;
    STDMETHOD(get_MoreInfoBannerImage)(THIS_ BSTR FAR* pbstrMoreInfoBannerImage) PURE;
    STDMETHOD(get_MoreInfoBannerURL)(THIS_ BSTR FAR* pbstrMoreInfoBannerURL) PURE;
    STDMETHOD(get_MoreInfoText)(THIS_ BSTR FAR* pbstrMoreInfoText) PURE;
};

DEFINE_GUID(IID_IAMMediaContent2,0xCE8F78C1L,0x74D9,0x11D2,0xB0,0x9D,0x00,0xA0,0xC9,0xA8,0x11,0x17);

/* Definition of interface: IAMMediaContent2 */
#undef INTERFACE
#define INTERFACE IAMMediaContent2

DECLARE_INTERFACE_(IAMMediaContent2, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMMediaContent2 methods */
    STDMETHOD(get_MediaParameter)(THIS_ long EntryNum, BSTR bstrName, BSTR FAR* pbstrValue) PURE;
    STDMETHOD(get_MediaParameterName)(THIS_ long EntryNum, long Index, BSTR FAR* pbstrName) PURE;
    STDMETHOD(get_PlaylistCount)(THIS_ long FAR* pNumberEntries) PURE;
};

DEFINE_GUID(IID_IAMNetShowPreroll,0xAAE7E4E2L,0x6388,0x11D1,0x8D,0x93,0x00,0x60,0x97,0xC9,0xA2,0xB2);

/* Definition of interface: IAMNetShowPreroll */
#undef INTERFACE
#define INTERFACE IAMNetShowPreroll

DECLARE_INTERFACE_(IAMNetShowPreroll, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IAMNetShowPreroll methods */
    STDMETHOD(put_Preroll)(THIS_ VARIANT_BOOL fPreroll) PURE;
    STDMETHOD(get_Preroll)(THIS_ VARIANT_BOOL FAR* pfPreroll) PURE;
};

DEFINE_GUID(IID_IDShowPlugin,0x4746B7C8L,0x700E,0x11D1,0xBE,0xCC,0x00,0xC0,0x4F,0xB6,0xE9,0x37);

/* Definition of interface: IDShowPlugin */
#undef INTERFACE
#define INTERFACE IDShowPlugin

DECLARE_INTERFACE_(IDShowPlugin, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IDShowPlugin methods */
    STDMETHOD(get_URL)(THIS_ BSTR FAR* pURL) PURE;
    STDMETHOD(get_UserAgent)(THIS_ BSTR FAR* pUserAgent) PURE;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Qos.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    qos.h - QoS definitions for NDIS components.

Abstract:

    This module defines the Quality of Service structures and types used
    by Winsock applications.

WARNING:

    This api is deprecated and will be removed in a future release of Windows.
    Please use the QOS2.h api.

Revision History:

--*/

#ifndef __QOS_H_
#define __QOS_H_

#pragma once

/*
 *  Definitions for valued-based Service Type for each direction of data flow.
 */

typedef ULONG   SERVICETYPE;

#define SERVICETYPE_NOTRAFFIC               0x00000000  /* No data in this 
                                                         * direction */
#define SERVICETYPE_BESTEFFORT              0x00000001  /* Best Effort */
#define SERVICETYPE_CONTROLLEDLOAD          0x00000002  /* Controlled Load */
#define SERVICETYPE_GUARANTEED              0x00000003  /* Guaranteed */

#define SERVICETYPE_NETWORK_UNAVAILABLE     0x00000004  /* Used to notify 
                                                         * change to user */
#define SERVICETYPE_GENERAL_INFORMATION     0x00000005  /* corresponds to 
                                                         * "General Parameters"
                                                         * defined by IntServ */
#define SERVICETYPE_NOCHANGE                0x00000006  /* used to indicate
                                                         * that the flow spec
                                                         * contains no change
                                                         * from any previous
                                                         * one */
#define SERVICETYPE_NONCONFORMING           0x00000009  /* Non-Conforming Traffic */
#define SERVICETYPE_NETWORK_CONTROL         0x0000000A  /* Network Control traffic */
#define SERVICETYPE_QUALITATIVE             0x0000000D  /* Qualitative applications */ 



/*********  The usage of these is currently not supported.  ***************/
#define SERVICE_BESTEFFORT                  0x80010000
#define SERVICE_CONTROLLEDLOAD              0x80020000
#define SERVICE_GUARANTEED                  0x80040000
#define SERVICE_QUALITATIVE                 0x80200000
/* **************************** ***** ************************************ */



/*
 * Flags to control the usage of RSVP on this flow.
 */

/*
 * to turn off traffic control, 'OR' ( | ) this flag with the 
 * ServiceType field in the FLOWSPEC
 */
#define SERVICE_NO_TRAFFIC_CONTROL   0x81000000


/*
 * this flag can be used to prevent any rsvp signaling messages from being 
 * sent. Local traffic control will be invoked, but no RSVP Path messages 
 * will be sent.This flag can also be used in conjunction with a receiving 
 * flowspec to suppress the automatic generation of a Reserve message.  
 * The application would receive notification that a Path  message had arrived 
 * and would then need to alter the QOS by issuing WSAIoctl( SIO_SET_QOS ), 
 * to unset this flag and thereby causing Reserve messages to go out.
 */

#define SERVICE_NO_QOS_SIGNALING   0x40000000




/*
 *  Flow Specifications for each direction of data flow.
 */
typedef struct _flowspec
{
    ULONG       TokenRate;              /* In Bytes/sec */
    ULONG       TokenBucketSize;        /* In Bytes */
    ULONG       PeakBandwidth;          /* In Bytes/sec */
    ULONG       Latency;                /* In microseconds */
    ULONG       DelayVariation;         /* In microseconds */
    SERVICETYPE ServiceType;
    ULONG       MaxSduSize;             /* In Bytes */
    ULONG       MinimumPolicedSize;     /* In Bytes */

} FLOWSPEC, *PFLOWSPEC, * LPFLOWSPEC;

/*
 * this value can be used in the FLOWSPEC structure to instruct the Rsvp Service 
 * provider to derive the appropriate default value for the parameter.  Note 
 * that not all values in the FLOWSPEC structure can be defaults. In the
 * ReceivingFlowspec, all parameters can be defaulted except the ServiceType.  
 * In the SendingFlowspec, the MaxSduSize and MinimumPolicedSize can be
 * defaulted. Other defaults may be possible. Refer to the appropriate
 * documentation.
 */
#define QOS_NOT_SPECIFIED     0xFFFFFFFF

/*
 * define a value that can be used for the PeakBandwidth, which will map into 
 * positive infinity when the FLOWSPEC is converted into IntServ floating point 
 * format.  We can't use (-1) because that value was previously defined to mean
 * "select the default".
 */
#define   POSITIVE_INFINITY_RATE     0xFFFFFFFE



/*
 * the provider specific structure can have a number of objects in it.
 * Each next structure in the
 * ProviderSpecific will be the QOS_OBJECT_HDR struct that prefaces the actual
 * data with a type and length for that object.  This QOS_OBJECT struct can 
 * repeat several times if there are several objects.  This list of objects
 * terminates either when the buffer length has been reached ( WSABUF ) or
 * an object of type QOS_END_OF_LIST is encountered.
 */
typedef struct  {

    ULONG   ObjectType;
    ULONG   ObjectLength;  /* the length of object buffer INCLUDING 
                            * this header */

} QOS_OBJECT_HDR, *LPQOS_OBJECT_HDR;


/*
 * general QOS objects start at this offset from the base and have a range 
 * of 1000
 */
#define   QOS_GENERAL_ID_BASE                      2000

#define   QOS_OBJECT_END_OF_LIST                   (0x00000001 + QOS_GENERAL_ID_BASE) 
          /* QOS_End_of_list structure passed */
#define   QOS_OBJECT_SD_MODE                       (0x00000002 + QOS_GENERAL_ID_BASE) 
          /* QOS_ShapeDiscard structure passed */
#define   QOS_OBJECT_SHAPING_RATE	           (0x00000003 + QOS_GENERAL_ID_BASE)
          /* QOS_ShapingRate structure */
#define   QOS_OBJECT_DESTADDR                      (0x00000004 + QOS_GENERAL_ID_BASE)
          /* QOS_DestAddr structure (defined in qossp.h) */


/*
 * This structure is used to define the behaviour that the traffic
 * control packet shaper will apply to the flow.
 *
 * TC_NONCONF_BORROW - the flow will receive resources remaining 
 *  after all higher priority flows have been serviced. If a 
 *  TokenRate is specified, packets may be non-conforming and
 *  will be demoted to less than best-effort priority.
 *  
 * TC_NONCONF_SHAPE - TokenRate must be specified. Non-conforming
 *  packets will be retianed in the packet shaper until they become
 *  conforming.
 *
 * TC_NONCONF_DISCARD - TokenRate must be specified. Non-conforming
 *  packets will be discarded.
 *
 */

typedef struct _QOS_SD_MODE {

    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            ShapeDiscardMode;

} QOS_SD_MODE, *LPQOS_SD_MODE;

#define TC_NONCONF_BORROW      0
#define TC_NONCONF_SHAPE       1
#define TC_NONCONF_DISCARD     2
#define TC_NONCONF_BORROW_PLUS 3 // Not supported currently


/*
 * This structure allows an app to specify a prorated "average token rate" using by
 * the traffic shaper under SHAPE modehaper queue. It is expressed in bytes per sec.
 *
 * ShapingRate (bytes per sec.)
 *
 */

typedef struct _QOS_SHAPING_RATE {

    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            ShapingRate;

} QOS_SHAPING_RATE, *LPQOS_SHAPING_RATE;


#endif  /* __QOS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\QosPol.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    qospol.h - QOS policy elements

Abstract:

    This module defines QOS policy elements.

Revision History:

--*/

#ifndef __QOSPOL_H_
#define __QOSPOL_H_

#pragma once

#define PE_TYPE_APPID       3       // policy element contains Application Identity

// Policy Location attribute carries sub application attributes
#define PE_ATTRIB_TYPE_POLICY_LOCATOR            1

#define POLICY_LOCATOR_SUB_TYPE_ASCII_DN         1
#define POLICY_LOCATOR_SUB_TYPE_UNICODE_DN       2
#define POLICY_LOCATOR_SUB_TYPE_ASCII_DN_ENC     3
#define POLICY_LOCATOR_SUB_TYPE_UNICODE_DN_ENC   4


// Credentials attribute carries the application identity
#define PE_ATTRIB_TYPE_CREDENTIAL        2

#define CREDENTIAL_SUB_TYPE_ASCII_ID     1
#define CREDENTIAL_SUB_TYPE_UNICODE_ID   2
#define CREDENTIAL_SUB_TYPE_KERBEROS_TKT 3
#define CREDENTIAL_SUB_TYPE_X509_V3_CERT 4
#define CREDENTIAL_SUB_TYPE_PGP_CERT     5


// Identity Policy Element attribute structure
typedef struct _IDPE_ATTR {

    USHORT  PeAttribLength;
    
    UCHAR   PeAttribType;            // Use the #defines from above
    
    UCHAR   PeAttribSubType;        // Use the #defines from above
    
    UCHAR   PeAttribValue[4];
    
} IDPE_ATTR, *LPIDPE_ATTR;

#define IDPE_ATTR_HDR_LEN    (sizeof(USHORT)+sizeof(UCHAR)+sizeof(UCHAR))

#define RSVP_BYTE_MULTIPLE(x)       (((x+3) / 4) * 4)


#endif // __QOSPOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\qos2.h ===
/*++

Copyright (c) 2004  Microsoft Corporation

Module Name:

    qos2.h

Abstract:

    This module contains QOS structures and function headers

--*/

#pragma once

#include <ws2tcpip.h>
#include <mstcpip.h>

//
// Support calls from C++
//
#if defined(__cplusplus)
    #define ExternC extern "C"
#else
    #define ExternC
#endif

//
// Each admitted flow has a unique Flow ID. This ID is valid only
// in the process which called QOSAddSocketToFlow() for that flow
// with the handle returned from QOSCreateHandle
//
typedef ULONG QOS_FLOWID, *PQOS_FLOWID;

//
// Definitions of various traffic types. Application identifies
// each flow as being of a certain type. This enables the QOS
// subsystem to apply user-specified per-type policies to flows
//
// QOSTrafficTypeBestEffort:
//      
//      This service type requests the same network priority to the traffic 
//      as regular traffic not associated to the qWave api. For home scenarios, 
//      this is DLNA class DLNAQOS_1.
//
// QOSTrafficTypeBackground:
//
//      This service type requests a network priority to the traffic lower than 
//      traffic of type QOSTrafficTypeBestEffort. For example, this service 
//      could be used for traffic of applications doing data backups. For home 
//      scenarios, this is DLNA class DLNAQOS_0.
//
// QOSTrafficTypeExcellentEffort:
//
//      This service type requests a network priority to the traffic higher than 
//      QOSTrafficTypeBestEffort. This service type should be used for data 
//      traffic that, although not A/V, is more important than normal end-user 
//      scenarios. For example, email traffic. This service type is not part of 
//      the DLNA specification.
//
// QOSTrafficTypeAudioVideo:
//
//      This service type should be used for A/V streaming scenarios such as 
//      MPEG2 streaming. For home scenarios, this is DLNA class DLNAQOS_2.
//
// QOSTrafficTypeVoice:
//
//      This service type should be used for realtime voice streams such as 
//      VoIP. This service type is not part of the DLNA specification.
//
// QOSTrafficTypeControl:
//
//      This service type should only be used for the most critical data. For 
//      example, you might use it for data carrying user inputs to an A/V 
//      experience, e.g. play, pause, FF, RW, etc. The A/V traffic however 
//      should use QOSTrafficTypeAudioVideo. For home scenarios, this is DLNA 
//      class DLNAQOS_3.
//
typedef enum _QOS_TRAFFIC_TYPE 
{
    QOSTrafficTypeBestEffort        = 0,
    QOSTrafficTypeBackground        = 1,
    QOSTrafficTypeExcellentEffort   = 2,
    QOSTrafficTypeAudioVideo        = 3,
    QOSTrafficTypeVoice             = 4,
    QOSTrafficTypeControl           = 5
} QOS_TRAFFIC_TYPE, *PQOS_TRAFFIC_TYPE;

//
// This enum lists the operations that may be given to the QOSSetFlow API.
//
// QOSSetTrafficType: 
//
//      Allows an application to change the traffic type of its 
//      flow. For example, this may be useful if you are alternating between 
//      best effort and other types.
//
//      This must be accompanied by a QOS_TRAFFIC_TYPE value.
//
// QOSSetOutgoingRate:
//
//      This allows an application to define the characteristics of the 
//      outgoing traffic on its flow. This may be used to shape the outgoing 
//      traffic or to create a contract linking packet marking to packet 
//      shaping. Such a contract is required for environments were policy uses 
//      admission control. The traffic type will not be respected until a 
//      shaping rate is in place.
//
//      Must be accompagnied by a QOS_FLOWRATE_OUTGOING structure.
//
// QOSSetOutgoingDSCPValue:
//
//      This allows an application to specify the precise DSCP value used in
//      outgoing traffic.  This setting is overriden if an adaptive flow 
//      requests prioritization on the same machine.  This setting requires
//      the calling application be a member of the Administrators or the
//      Network Configuration Operators group.  This setting can only be
//      applied to a non-adaptive flow.
//
//      Must be accompanied by a DWORD value representing the DSCP value to
//      use.  The value must be from 0 to 63 inclusive.
//
//      To revert the effect of setting a DSCP value, the caller should call
//      the QOSSetFlow API again with the operation value QOSSetTrafficType.
//
typedef enum _QOS_SET_FLOW
{
    QOSSetTrafficType           = 0,
    QOSSetOutgoingRate          = 1,
    QOSSetOutgoingDSCPValue     = 2
} QOS_SET_FLOW, *PQOS_SET_FLOW;

//
// This structure is returned by QOSQueryFlow and allows the application to
// verify what priority markings (or tags) are applied to its traffic. These
// values may change as the flow changes or policies get updated.
//
typedef struct _QOS_PACKET_PRIORITY
{
    ULONG   ConformantDSCPValue;    // the DSCP marking used for the flow's 
                                    // traffic that respects the flow rate 
                                    // specified

    ULONG   NonConformantDSCPValue; // the DSCP marking used for the flow's 
                                    // traffic that exceeds the flow rate 
                                    // specified. Applicable only if shaping 
                                    // behavior is set to 
                                    // QOSUseNonConformantMarkings

    ULONG   ConformantL2Value;      // the L2 tag used for the flow's traffic 
                                    // that respects the flow rate specified

    ULONG   NonConformantL2Value;   // the L2 tag used for the flow's traffic 
                                    // that respects the flow rate specified.
                                    // Applicable only if shaping behavior is 
                                    // set to QOSUseNonConformantMarkings
} QOS_PACKET_PRIORITY, *PQOS_PACKET_PRIORITY;

typedef struct _QOS_FLOW_FUNDAMENTALS
{
    BOOL    BottleneckBandwidthSet; // TRUE if the BottleneckBandwidth field
                                    // contains a value.
    UINT64  BottleneckBandwidth;    // In units of bits/s ; does not include 
                                    // layer 3

    BOOL    AvailableBandwidthSet;  // TRUE if the AvailableBandwidth field
                                    // contains a value.
    UINT64  AvailableBandwidth;     // In units of bits/s ; does not include 
                                    // layer 3

    BOOL    RTTSet;                 // TRUE if the RTT field
                                    // contains a value.
    UINT32  RTT;                    // RTT is in microseconds. 
} QOS_FLOW_FUNDAMENTALS, *PQOS_FLOW_FUNDAMENTALS;

typedef enum _QOS_FLOWRATE_REASON
{
    QOSFlowRateNotApplicable            = 0,
    QOSFlowRateContentChange            = 1,
    QOSFlowRateCongestion               = 2,
    QOSFlowRateHigherContentEncoding    = 3,
    QOSFlowRateUserCaused               = 4
} QOS_FLOWRATE_REASON, *PQOS_FLOWRATE_REASON;

//
// This enum is used to define the shaping behavior. Remember that, if policy
// demands admission control, packet priority is only applied through a contract 
// with the application. This enum allows you to define how the contract is 
// enforced.
//
// QOSShapeOnly: if the flow is set to shape only, qWave will use Window's 
// scheduler to enforce the flow rate requested. Any data packet that would 
// exceed the rate will be delayed until appropriate. Packets will be marked
// as best effort packets.
//
// QOSShapeAndMark: if the flow is set to shape, qWave will use Window's 
// scheduler to enforce the flow rate requested. Any data packet that would 
// exceed the rate will be delayed until appropriate. Packets will always 
// receive conformant priority values.
//
// QOSUseNonConformantMarkings: if the flow is set to use non conformant values,
// qWave will not enforce the flow rate requested. If sending a data packet 
// would exceed the flow rate, this packet will receive a priority value 
// indicating it is non-conformant. Such packets will receive default treatment -
// which is best effort - from network equipment. This may lead to lost packets
// and/or re-ordered packets.
//
typedef enum _QOS_SHAPING{
    QOSShapeOnly                        = 0,
    QOSShapeAndMark                     = 1,
    QOSUseNonConformantMarkings         = 2
} QOS_SHAPING, *PQOS_SHAPING;

#define QOS_OUTGOING_DEFAULT_MINIMUM_BANDWIDTH  0xFFFFFFFF

//
// This struct describes the information required by qWave to accept a flowrate
// from the application. We recommend that you read the description for
// QOS_ADD_OVERHEAD and QOS_SUBTRACT_OVERHEAD before using this structure.
//
// Bandwidth: the rate (in bits/s) you expect to send your traffic at. As a 
// warning, you should note that traffic on the network is measured at the IP 
// level and not at the application level. Thus, the rate you specify should 
// account for the IP and protocol headers. Although there are various ways
// to estimate this final rate, you may wish to use the QOS_ADD_OVERHEAD and
// QOS_SUBTRACT_OVERHEAD functions for these calculations.
//
// If you are unsure what bandwidth value you need but expect to use very little
// use QOS_OUTGOING_DEFAULT_MINIMUM_BANDWIDTH. The system will allocate you
// a small amount of bandwidth for your operations.
//
// ShapingBehavior: how the contract for admission control will be enforced
//
// Reason: if a rate change has occured, this reason should indicate why.
typedef struct _QOS_FLOWRATE_OUTGOING
{
    UINT64                  Bandwidth;      // In units of bits/s
    QOS_SHAPING             ShapingBehavior;// Shaping behavior
    QOS_FLOWRATE_REASON     Reason;         // Optional field for the 
                                            // application to indicate why it's 
                                            // changing a flow's data rate
} QOS_FLOWRATE_OUTGOING, *PQOS_FLOWRATE_OUTGOING;

//
// When using the enum QOSQueryOutgoingRate you should expect the returned rate
// to measure bandwidth at layer 3. If you wish to adjust this rate, based on 
// your application's characteristics, for the IP header and protocol header
// overhead, you should review the QOS_SUBTRACT_OVERHEAD inlined function.
typedef enum _QOS_QUERY_FLOW
{
    QOSQueryFlowFundamentals    = 0,
    QOSQueryPacketPriority      = 1,
    QOSQueryOutgoingRate        = 2
} QOS_QUERY_FLOW, *PQOS_QUERY_FLOW;

typedef enum _QOS_NOTIFY_FLOW
{
    QOSNotifyCongested          = 0,
    QOSNotifyUncongested        = 1,       
    QOSNotifyAvailable          = 2       
} QOS_NOTIFY_FLOW, *PQOS_NOTIFY_FLOW;

//
// The type for QOS protocol version numbers.
// For Vista, the version should be
// MajorVersion: 1
// MinorVersion: 0

typedef struct _QOS_VERSION
{
    USHORT MajorVersion;
    USHORT MinorVersion;
} QOS_VERSION, *PQOS_VERSION;

#define QOS_QUERYFLOW_FRESH         0x00000001
#define QOS_NON_ADAPTIVE_FLOW       0x00000002

__inline
INT
QOS_HEADER_OVERHEAD(
    __in    INT     af, 
    __in    INT     protocol
){
    UINT32 overhead;

    if (af == AF_INET)
        overhead = 20;                          // IPv4 header overhead in bytes
    else
        overhead = 40;                          // IPv6 header overhead in bytes

    if (protocol == IPPROTO_TCP)
        overhead += 20;                         // TCP header overhead in bytes
    else
        overhead += 8;                          // UDP header overhead in bytes

    return overhead;    
}


//
// Description:
//
//  API to calculate the impact of IP and protocol header overhead on a data 
//  rate.
//
// Arguments:
//
//      .af             - Address family used to create the socket. Please 
//                        review the socket and WSASocket documentation. This 
//                        should be AF_INET or AF_INET6
//
//      .protocol       - Protocol type used to create the socket. Please review 
//                        the socket and WSASocket documentation. This should 
//                        be IPPROTO_TCP or IPPROTO_UDP
//
//      .targetDataPacketSize
//                      - This is the expected packet size of your data stream.
//                        ***See note below on targetDataPacketSize***
//
//      .dataRate       - Your dataRate in bits/s.
//
// Note on targetDataPacketSize: 
//
//  If you're using a TCP socket on IPv4 and will be making large sends then you 
//  would expect the data packet size to be 1460 bytes: Ethernet has an MTU of 
//  1500 bytes and the overhead of an IPv4 header is typically 20 bytes 
//  while a TCP header is also 20 bytes.
//
//  If you're using a UDP socket and your packet size varies, you may wish to 
//  pass in a reasonnable minimal value. This would adjust your rate for the
//  worst case.
//
//  The value 0 is an invalid parameter which will result in a division by 0.
//
// Return Values:
//
//  This call will return the data rate, in bits/s, augmented by the overhead
//  on each packet given the address family and the protocol you've created your
//  socket with.
//
__inline
UINT64
QOS_ADD_OVERHEAD(
    __in    INT     af, 
    __in    INT     protocol, 
    __in    UINT32  targetDataPacketSize, 
    __in    UINT64  dataRate
){
    UINT32 overhead;
    double d;
    UINT64 r;

    //
    // Calculate the header overhead
    overhead = QOS_HEADER_OVERHEAD(af, protocol);

    //
    // Convert overhead and dataRate to bits
    overhead *= 8;
    targetDataPacketSize *= 8;

    //
    // The adjustment is:
    //
    //                         (       dataRate                  )
    // returnRate = dataRate + ( -------------------- * overhead )
    //                         ( targetDataPacketSize            )
    //
    // For each packet we expect to see go out, we need to add the 
    // overhead
    d = (double) overhead;
    d /= (double) targetDataPacketSize;
    d *= (double) dataRate;

    r = dataRate;
    r += (UINT64) d;

    return r;
}

//
// Description:
//
//  API to calculate the impact of IP and protocol header overhead on a data 
//  rate.
//
// Arguments:
//
//      .af             - Address family used to create the socket. Please 
//                        review the socket and WSASocket documentation. This 
//                        should be AF_INET or AF_INET6
//
//      .protocol       - Protocol type used to create the socket. Please review 
//                        the socket and WSASocket documentation. This should 
//                        be IPPROTO_TCP or IPPROTO_UDP
//
//      .targetDataPacketSize
//                      - This is the expected packet size of your data stream.
//                        ***See note below on targetDataPacketSize***
//
//      .dataRate       - Your dataRate in bits/s.
//
// Note on targetDataPacketSize: 
//
//  If you're using a TCP socket on IPv4 and will be making large sends then you 
//  would expect the data packet size to be 1460 bytes: Ethernet has an MTU of 
//  1500 bytes and that the overhead of an IPv4 header is typically 20 bytes 
//  while a TCP header is also 20 bytes.
//
//  If you're using a UDP socket and your packet size varies, you may wish to 
//  pass in a reasonnable minimal value. This would adjust your rate for the
//  worst case.
//
// Return Values:
//
//  This call will return the data rate, in bits/s, reduced by the overhead
//  on each packet given the address family and the protocol you've created your
//  socket with.
//
__inline
UINT64
QOS_SUBTRACT_OVERHEAD(
    __in    INT     af, 
    __in    INT     protocol, 
    __in    UINT32  targetDataPacketSize, 
    __in    UINT64  dataRate
){
    UINT32 overhead;
    double d;
    UINT64 r;

    //
    // Calculate the header overhead
    overhead = QOS_HEADER_OVERHEAD(af, protocol);

    //
    // Convert overhead and dataRate to bits
    overhead *= 8;
    targetDataPacketSize *= 8;

    //
    // The adjustment is:
    //
    //                         (            dataRate                        )
    // returnRate = dataRate - ( ------------------------------- * overhead )
    //                         ( targetDataPacketSize + overhead            )
    //
    // For each packet we expect to see go out, we need to add the 
    // overhead
    d = (double) overhead;
    d /= (double) targetDataPacketSize + overhead;
    d *= (double) dataRate;

    r = dataRate;
    r -= (UINT64) d;

    return r;
}

//
// Description:
//
//  API to initialize QOS subsystem. Every process intending to use
//  QOS must first make the QOSCreateHandle call.
//
//  The handle returned by this call is useful for performing
//  overlapped IO. For example, it can be associated with a
//  IOCP to receive overlapped completion notifications.
//
//  Although a single QOSHandle would be sufficient for most applications,
//  applications have the option of calling QOSCreateHandle multiple times
//  to obtain multiple handles
//
//      .Version        - Specifies what version of this API you wish to use.
//                        This parameter must be of type QOS_VERSION. For Vista
//                        the only valid value is 1.0
//
//      .QOSHandle      - On output, if the call is successful, this will return
//                        a file handle to the QOS subsystem. This handle should
//                        be closed with QOSCloseHandle.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_SERVICE_DEPENDENCY_FAIL
//          One of the dependencies of the service is unavailable. The qWave
//          service could not be started.
//
//      ERROR_RESOURCE_DISABLED
//          One of the resources required by the service is unavailable. This 
//          error may be returned if the user has not enabled the firewall
//          exception for the qWave service. Please see the developer guidelines 
//          and MSFT firewall documentation for more details.
//
ExternC
BOOL
WINAPI
QOSCreateHandle(
    __in    PQOS_VERSION    Version,
    __out   PHANDLE         QOSHandle
);

//
// Description:
//
//  API to close a handle returned by QOSCreateHandle
//
//  When closing a handle, all flows added on this handle are immediately 
//  removed from the system. Any traffic going out a socket used to create these 
//  flows will no longer be marked. Moreover, any pending operations for these 
//  flows are completed with ERROR_ABORTED.
//
//  If any clients were tracked through this handle, the subsystem will continue
//  tracking these for some limited amount of time. This can be stopped by 
//  calling either QOSStopTrackingClient on this handle before closing it or 
//  through another handle once this one has been closed.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError.
//
ExternC
BOOL
WINAPI
QOSCloseHandle(
    __in    HANDLE         QOSHandle
);

//
// Description:
//
//  API to inform the QOS subsystem of the existence of a new client. 
//  The QOS subsystem will start gathering statistics about this client device. 
//  This call is NOT required to add a flow, but it is recommended for adaptive
//  flows.
//
//  Ideally, an application would make this API call as soon as it is aware of a 
//  possible client device with which it may need to create a QOS flow. By using
//  this call, you increase the likelihood that qWave will have gathered 
//  sufficient information on the network path to assist you when you attempt to
//  set the flow rate.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .DestAddr       - IP address of the client device. Note that a client 
//                        is identified strictly by it's IP address and address 
//                        family. A port number is not required and will be 
//                        ignored.
//
//      .Flags          - Used to modify the behavior of the 
//                        QOSStartTrackingClient call. Reserved for future use.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_BAD_NET_NAME
//          qWave was unable to reach the host specified. Specifically, address
//          resolution failed.
//
//      ERROR_HOST_UNREACHABLE
//          The qWave service was unable to communicate with the peer host to
//          run qWave experiments. This could be a sign that there is no 
//          qWave sink on the remote host or that a firewall is blocking 
//          communication.
//
//      ERROR_NOT_SUPPORTED
//          The qWave subsystem cannot track information about the destination
//          you've specified. It could be that the other host does does not 
//          have the required components or that it is not on the same link.
//
ExternC
BOOL
WINAPI
QOSStartTrackingClient(
    __in        HANDLE          QOSHandle,
    __in        PSOCKADDR       DestAddr,
    __reserved  DWORD           Flags
);

//
// Description:
//
//  API to remove a client. The QOS subsystem will stop gathering statistics
//  about this client device. This call will only be accepted if 
//  QOSStartTrackingClient was previously called on the host. If a flow is 
//  currently in progress, this will not affect the flow.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .DestAddr       - IP address of the client device
//
//      .Flags          - Used to modify the behavior of the 
//                        QOSStopTrackingClient call. Reserved for future use.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError.
//
ExternC
BOOL
WINAPI
QOSStopTrackingClient(
    __in        HANDLE          QOSHandle,
    __in        PSOCKADDR       DestAddr,
    __reserved  DWORD           Flags
);

//
// Description:
//
//  API to enumerate all the existing flows. This call requires administrative 
//  rights. Through it the caller can obtain the list of current flow IDs on the 
//  system. Using QOSQueryFlow, one can then query the flows.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .Size           - On input represents the size in bytes of the buffer. 
//                        On output, if successful, the amount of bytes copied 
//                        in the buffer. If the call fails with 
//                        ERROR_INSUFFICIENT_BUFFER, the parameter size will 
//                        indicate the minimum required buffer size.
//
//      .Buffer         - On output contains an array of QOS_FLOWID.
//
// Note: 
//
//  One cannot modify flows from another process.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_ACCESS_DENIED
//          The caller does not have the administrator rights required 
//          to perform this call.
//
ExternC
BOOL
WINAPI
QOSEnumerateFlows(
    __in                HANDLE      QOSHandle,
    __inout             PULONG      Size,
    __out_bcount(*Size) PVOID       Buffer
);

//
// Description:
//
//  API to add a new flow. Note that the flow's traffic is not affected through
//  this call. There are two categories of applications that will use this api:
//  adaptive and non-adaptive. An adaptive application will make use of 
//  notifications and information in QOS_FLOW_FUNDAMENTALS to adapt to changing
//  network characteristics (such as congestion). qWAVE utilizes Link Layer
//  Topology Discovery (LLTD) QoS extensions for adaptive flows, which may be
//  present on the destination. A non-adaptive application either does not 
//  desire to adapt to changing network characteristics (priority marking and/or
//  throttling only), or is sending traffic to an endpoint that does not support
//  this capability as indicated by ERROR_NOT_SUPPORTED. For adaptive 
//  applications, the caller should immediately call QOSSetFlow with the 
//  QOSSetOutgoingRate parameter. Non-adaptive applications or applications 
//  creating non-adaptive flows should call this api with the 
//  QOS_NON_ADAPTIVE_FLOW flag set.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .Socket         - The socket the application will use to source traffic. 
//                        ***See note below on Socket***
//
//      .DestAddr       - The destination address the application will send 
//                        traffic to. A  destination port must be specified. 
//                        This parameter is optional for connected sockets. See 
//                        the note below.
//
//      .TrafficType    - Describes the type of traffic your flow will be used 
//                        for. This parameter will be ignored when adding a 
//                        socket to an existing flow. 
//
//      .Flags          - Used to modify the behavior of the QOSAddSocketToFlow
//                        call. 
//                        ***See note below on Flags***
//
//      .FlowId         - On input *FlowId MUST be 0 to create a new flow. On 
//                        output, if the call is successful, a flow ID is 
//                        generated and placed in *FlowId. 
//
//                        If you are adding a socket to an existing flow, 
//                        *FlowId will be the flow ID of the existing flow.
//                        ***See note below on Flags***
//
// Note on Socket: 
//
//  If the app wishes to use a different interface to source its data
//  than the one favored by the routing table, it should bind its socket 
//  before calling QOSAddSocketToFlow.
//
// Note on the DestAddr parameter:
//
//  The DestAddr parameter is optional. Since the Qwave api must always 
//  know the destination host (and IP port) to which your traffic will be 
//  sent here are the ramifications:
//
//      1) If your socket is not connected, you MUST specify this parameter. 
//      2) If your socket is connected, you do not need to specify this 
//         parameter however, if you do, the destination host and port must 
//         match that use in the socket's connect call.
//      3) Since, for TCP, the connect call incurs a delay (dependent on  
//         network conditions and the peer host) you may start qWave experiments
//         beforehand. You would call QOSAddSocketToFlow passing in the  
//         application's peer IP address and port.
//
// Note on TrafficType: 
// 
//  Its worth noting that traffic types, if policy allows, will map to a 
//  protocol level tagging of your traffic. For example, the traffic types 
//  equivalent to DLNA may result in the DSCP markings specified in DLNA 
//  being applied. Whether marking is applied, and if so which value, is 
//  controlled by the policy system. In effect this is a request which may,
//  or may not, as appropriate for the network infrastructure, be honored.
//
//  Policy may also require that you run through some form of admission 
//  control and bind yourself to a contract. This is useful to prevent
//  applications from swamping the network. Such admission control will
//  rely on both your traffic type and the flow rate of your traffic. When 
//  possible, you should specify the flow rate of your application using the
//  QOSSetFlow call with the QOSSetOutgoingRate operation.
//
// Note on Flags:
//
//  Only one flag is currently supported for QOSAddSocketToFlow.
//
//      QOS_NON_ADAPTIVE_FLOW - If specified, the QOS subsystem will not gather
//                              data about the network path for this flow. As a 
//                              result, APIs which rely on bandwidth estimation
//                              techniques will not be available. For example, 
//                              this would block QOSQueryFlow with 
//                              QOSQueryFlowFundamentals and QOSNotifyFlow with
//                              QOSNotifyCongested, QOSNotifyUncongested or
//                              QOSNotifyAvailable.
//
//                              An application should use this flag if it does
//                              not intent to adapt its flow to changes in the
//                              state of the network be it because of its
//                              scenario, type of network or capabilities of
//                              the receiving host.
//
//                              You can only add multiple sockets to the same 
//                              flow if the flow is not adaptive. You must also 
//                              specify this flag when you call to add a socket
//                              to an existing flow.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_BAD_NET_NAME
//          qWave was unable to reach the host specified. Specifically, address
//          resolution failed.
//
//      ERROR_CONNECTION_REFUSED
//          QOS could not connect to destination device. The remote host
//          rejected the connection.
//
//      ERROR_HOST_UNREACHABLE
//          The host is not reachable given the current network configuration. 
//          If the host was previously reachable, you should confirm that there
//          hasn't been a PnP state change
//
//      ERROR_NOT_SUPPORTED
//          The qWave subsystem cannot track information about the destination
//          you've specified. It could be that the other host does does not 
//          have the required components or that it is not on the same link.
//
ExternC
BOOL
WINAPI
QOSAddSocketToFlow(
    __in        HANDLE              QOSHandle,          
    __in        SOCKET              Socket,
    __in_opt    PSOCKADDR           DestAddr,
    __in        QOS_TRAFFIC_TYPE    TrafficType,
    __in_opt    DWORD               Flags,
    __inout     PQOS_FLOWID         FlowId
);

//
// Description:
//
//  API used by app to notify QOS subsystem that a previously admitted flow has 
//  been terminated by the app. QOS subsystem uses this call to update its 
//  internal information
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .Socket         - Socket to be removed from the flow
//                        ***See note below on Socket***
//
//      .FlowId         - The flow which the app is interested in modifying. 
//                        This is obtained through QOSAddSocketToFlow.
//
//      .Flags          - Used to modify the behavior of the 
//                        QOSRemoveSocketFromFlow call. This is currently 
//                        reserved for future use.
//
// Note: 
//
//  Closing a QOSHandle will automatically abort all pending operations issued 
//  on that QOSHandle. If the handle is closed while a QOSRemoveSocketFromFlow 
//  call is still in progress, the call will complete with 
//  ERROR_OPERATION_ABORTED. 
//
// Note on Socket: 
// 
//  Only flows created with the QOS_NON_ADAPTIVE_FLOW flag may have multiple
//  sockets added to the same flow. By passing a socket parameter in this
//  api call you can remove each of these individually. 
//
//  If you do not pass a socket, the flow will be destroyed.
//
//  If only one socket was attached to the flow, passing this socket as a 
//  parameter to this api and passing NULL as a socket are equivalent calls.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_NOT_FOUND
//          Invalid FlowId specified
//
ExternC
BOOL
WINAPI
QOSRemoveSocketFromFlow(
    __in        HANDLE              QOSHandle,
    __in_opt    SOCKET              Socket,
    __in        QOS_FLOWID          FlowId,
    __reserved  DWORD               Flags
);

//
// Description:
//
//  This API is used by the app to inform the QOS subsystem of change in a flow.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .FlowId         - The flow which the app is interested in modifying 
//                        This is obtained through QOSAddSocketToFlow.
//
//      .Operation      - What modification on the flow you are trying to 
//                        apply. This must be of the type QOS_SET_FLOW. The 
//                        input parameter should match the requested flow 
//                        information.
//                        ***See note below on Operation***
//
//      .Size           - The length, in bytes, of Buffer. You should specify 
//                        the correct buffer length for the structure you
//                        specify in Buffer.
//                        ***See note below on Operation***
//
//      .Buffer         - Pointer to the buffer to describe the modication.
//                        ***See note below on Operation***
//
//      .Flags          - Used to modify the behavior of the QOSSetFlow call.
//                        This is currently reserved for future use.
//
//      .Overlapped     - Pointer to an OVERLAPPED structure. 
//
// Note on Operation:
//
//  Given the input parameter for operation, the content of the buffer passed in 
//  will differ. Here is the mapping:
//
//      QOSSetTrafficType           - QOS_TRAFFIC_TYPE
//      QOSSetOutgoingRate          - QOS_FLOWRATE_OUTGOING
//      QOSSetOutgoingDSCPValue     - DWORD
//
//  Specific to QOS_FLOWRATE_OUTGOING structure:
//
//      Bandwidth is defined as number of bits per second. It should include 
//      Layer 3 overhead (e.g. IPv4 header, UDP, etc.). You may want to use the 
//      macro QOS_ADD_OVERHEAD to help you estimate the overhead.
//
//      Using Bandwidth == 0 disables shaping and stops affecting the flow (e.g. 
//      the traffic is not marked anymore). MinPacketSize will be ignored.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_ACCESS_DISABLED_BY_POLICY
//          The QOS subsystem is currently configured by policy to not allow 
//          this operation on the network path between this host and 
//          your destination host.
//
//      ERROR_BUSY
//          Indicates that the QOS subsystem has not had enough CPU cycles to
//          estimate the network characteristics of the path.
//
//      ERROR_IO_PENDING          
//          Indicates that update flow request was successfully initiated
//          (results will be returned during overlapped completion)
//      
//      ERROR_NETWORK_BUSY
//          Indicates that the requested flow properties were not available
//          on this path. The network currently cannot support the 
//          characteristics you requested
//
//      ERROR_NOT_FOUND
//          Invalid FlowId specified
//
//      ERROR_NOT_SUPPORTED
//          The operation you're trying to do requires information about the
//          network which the qWave subsystem does not have. Obtaining this
//          information on your network is currently not supported.
//
//      ERROR_RETRY
//          There is currently insufficient data about networking conditions
//          to answer your query. This is typically a transient state where
//          qWave has erred on the side of caution as it waits for more data
//          before ascertaining the state of the network.
//
//      ERROR_ACCESS_DENIED
//          The caller does not have the administrator rights required 
//          to perform this call.
//
ExternC
BOOL
WINAPI
QOSSetFlow(
    __in                HANDLE          QOSHandle,          
    __in                QOS_FLOWID      FlowId,             
    __in                QOS_SET_FLOW    Operation,
    __in                ULONG           Size,
    __in_bcount(Size)   PVOID           Buffer,  
    __reserved          DWORD           Flags,
    __out_opt           LPOVERLAPPED    Overlapped
);

//
// Description:
//
//  API to query information about a flow. 
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .FlowId         - The flow which the app is interested in receiving 
//                        information about. This is obtained through 
//                        QOSAddSocketToFlow.
//
//      .Operation      - What information about the flow you are trying to 
//                        obtain. This must be of the type QOS_QUERY_FLOW. The 
//                        input parameter should match the requested flow 
//                        information.
//                        ***See note below on Operation***
//
//      .Size           - The length, in bytes, of Buffer. If the buffer 
//                        specified is too small, the call will fail with error
//                        ERROR_INSUFFICIENT_BUFFER and this parameter will 
//                        be updated the appropriate buffer size.
//                        ***See note below on Operation***
//
//      .Buffer         - Pointer to the buffer to receive the queried data.
//                        ***See note below on Operation***
//
//      .Flags          - Used to modify the behavior of the QOSQueryFlow call.
//                        ***See note below on Flags***
//
//      .Overlapped     - Pointer to an OVERLAPPED structure. 
//
// Note on Operation:
//
//  Given the input parameter for operation, the buffer passed in will differ.
//  Here is the mapping.
//
//      QOSQueryFlowFundamentals    - QOS_FLOW_FUNDAMENTALS
//
//      QOSQueryPacketPriority      - QOS_PACKET_PRIORITY
//
//                                    This structure will return the actual
//                                    priority markings applied to your traffic
//                                    by the QOS subsystem given your asks and
//                                    the policy subsystem.
//
//      QOSQueryOutgoingRate        - UINT64
//
// Note on Flags:
//
//  Only one flag is currently supported for QOSQueryFlow.
//
//      QOS_QUERYFLOW_FRESH -   If specified, the QOS subsystem will only return 
//                              once fresh data is available. If fresh data is 
//                              unavailable, it will try to obtain such data. 
//                              If this is not possible, the call will fail 
//                              with ERROR_RETRY.
//
//                              This flag is only valid for 
//                              QOSQueryFlowFundamentals.
//                              Note, this parameter is ignored if the caller is
//                              not the owner of the flow.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_ACCESS_DISABLED_BY_POLICY
//          The QOS subsystem is currently configured by policy to not allow 
//          this operation on the network path between this host and 
//          your destination host.
//
//      ERROR_BUSY
//          Indicates that the QOS subsystem has not had enough CPU cycles to
//          estimate the network characteristics of the path.
//
//      ERROR_HOST_UNREACHABLE
//          The host is not reachable given the current network configuration. 
//          If the host was previously reachable, you should confirm that there
//          hasn't been a PnP state change
//
//      ERROR_INSUFFICIENT_BUFFER
//          The buffer length, as specified through Size, is not sufficient
//          for the queried data. Size now contains the required size.
//
//      ERROR_IO_PENDING          
//          Indicates that update flow request was successfully initiated
//          (results will be returned during overlapped completion)
//      
//      ERROR_NOT_FOUND
//          Invalid FlowId specified
//
//      ERROR_NOT_SUPPORTED
//          The operation you're trying to do requires information about the
//          network which the qWave subsystem does not have. Obtaining this
//          information on your network is currently not supported.
//
//      ERROR_RETRY
//          There is currently insufficient data about networking conditions
//          to answer your query. This is typically a transient state where
//          qWave has erred on the side of caution as it waits for more data
//          before ascertaining the state of the network.
//
ExternC
BOOL
WINAPI
QOSQueryFlow(
    __in                HANDLE              QOSHandle,
    __in                QOS_FLOWID          FlowId,
    __in                QOS_QUERY_FLOW      Operation,
    __inout             PULONG              Size,
    __out_bcount(*Size) PVOID               Buffer,  
    __in_opt            DWORD               Flags,
    __out_opt           LPOVERLAPPED        Overlapped
);

//
// Description:
//
//  API to receive notification of change of network characteristics.
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .FlowId         - The flow which the app is interested in receiving 
//                        notifications on changes. This is obtained through 
//                        QOSAddSocketToFlow.
//
//      .Operation      - What notification about the flow you are trying to 
//                        obtain. This must be of the type QOS_NOTIFY_FLOW. The 
//                        input parameter should match the requested flow 
//                        information.
//
//      .Size           - The length, in bytes, of Buffer. You should specify 
//                        the correct buffer length for the structure you
//                        specify in Buffer.
//                        ***See note below on Operation***
//
//      .Buffer         - Pointer to the buffer to receive the queried data.
//                        ***See note below on Operation***
//
//      .Flags          - Used to modify the behavior of the QOSNotifyFlow call.
//                        This is currently reserved for future use.
//
//      .Overlapped     - Pointer to an OVERLAPPED structure. 
//
//
// Note on Operation:
//
//  The following notification may be supported.
//
//  1)  QOSNotifyCongested
//
//      QOSNotifyCongested will complete the operation when the network path
//      is congested. If the path is presently congested, the operation may 
//      complete immediately.
//
//      NOTE: The optional parameters Size and Buffer must be NULL.
//
//  2)  QOSNotifyUncongested
//
//      QOSNotifyUncongested will complete the operation when the network path
//      is not congested. If the path is not presently congested, the operation 
//      may complete immediately.
//
//      NOTE: The optional parameters Size and Buffer must be NULL.
//
//  2)  QOSNotifyAvailable
//
//      QOSNotifyAvailable will complete when available capacity is sufficient 
//      to allow an existing flow to be upgraded from its currently admitted
//      bandwidth to the specified bandwidth. This should be used to upgrade a 
//      transrated flow back to full bandwidth.
//      Requested bandwidth should include Layer 3 overhead. Please use the 
//      QOS_ADD_OVERHEAD function inlined in this header file as a starting 
//      point for your calculations.
//
//      The Buffer parameter should point to a UINT64 value with the requested
//      bandwidth. This value should be the target bandwidth of the flow.
//      For example, if your flow is using 3 Mb but you want to increase that 
//      by 2 Mb, the parameter Buffer should point to a UINT64 with the value
//      5 Mb.
//
//      UINT64    Requested bandwidth
//
//      The call will fail if the requested bandwidth is less than or equal 
//      to the bandwidth the flow is already using.
//
// Return Values:
//
//  If the function succeeds, the return value is nonzero.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError. Here are some of the errors possible.
//  This list is not exhaustive.
//
//      ERROR_ACCESS_DISABLED_BY_POLICY
//          The QOS subsystem is currently configured by policy to not allow 
//          this operation on the network path between this host and 
//          your destination host.
//
//      ERROR_ALREADY_EXISTS
//          There is already a request for notification of the same type pending
//          on this flow.
//
//      ERROR_HOST_UNREACHABLE
//          The host is not reachable given the current network configuration. 
//          If the host was previously reachable, you should confirm that there
//          hasn't been a PnP state change
//
//      ERROR_IO_PENDING          
//          Indicates that update flow request was successfully initiated
//          (results will be returned during overlapped completion)
//      
//      ERROR_NOT_FOUND
//          Invalid FlowId specified
//
//      ERROR_NOT_SUPPORTED
//          The operation you're trying to do requires information about the
//          network which the qWave subsystem does not have. Obtaining this
//          information on your network is currently not supported.
//
ExternC
BOOL
WINAPI
QOSNotifyFlow(
    __in                        HANDLE          QOSHandle,
    __in                        QOS_FLOWID      FlowId,
    __in                        QOS_NOTIFY_FLOW Operation,
    __inout_opt                 PULONG          Size,
    __inout_bcount_opt(*Size)   PVOID           Buffer,
    __reserved                  DWORD           Flags,
    __out_opt                   LPOVERLAPPED    Overlapped
);

//
// Description:
//
//  API to cancel a pending operation like QOSSetFlow.
// 
//  Closing a QOSHandle will automatically abort all pending
//  operations issued on that QOSHandle. If the handle is closed while
//  a QOSCancel call is still in progress, the call will complete 
//  with ERROR_OPERATION_ABORTED. 
//
// Arguments:
//
//      .QOSHandle      - Handle to the QOS subsystem obtained through 
//                        QOSCreateHandle.
//
//      .Overlapped     - Pointer to an OVERLAPPED structure. This is the 
//                        OVERLAPPED structure used in the original operation.
//
// Note: 
//
//  The QOSCancel call must be made in the same process from
//  which the original to-be-cancelled call was made.
// 
// Return Values:
//
//  If the function can successfully initiate cancellation of the specified 
//  operation, the return value is nonzero. The cancelled operation completes 
//  via its completion mechanism and indicates ERROR_OPERATION_ABORTED as the 
//  completion code.
//
//  If the function fails, the return value is zero. To get extended error 
//  information, call GetLastError.
//
ExternC
BOOL
WINAPI
QOSCancel(
    __in    HANDLE          QOSHandle,          
    __in    LPOVERLAPPED    Overlapped
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Query.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for query.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __query_h__
#define __query_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISearchQueryHits_FWD_DEFINED__
#define __ISearchQueryHits_FWD_DEFINED__
typedef interface ISearchQueryHits ISearchQueryHits;
#endif 	/* __ISearchQueryHits_FWD_DEFINED__ */


#ifndef __IRowsetQueryStatus_FWD_DEFINED__
#define __IRowsetQueryStatus_FWD_DEFINED__
typedef interface IRowsetQueryStatus IRowsetQueryStatus;
#endif 	/* __IRowsetQueryStatus_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "filter.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IQueryStructures_INTERFACE_DEFINED__
#define __IQueryStructures_INTERFACE_DEFINED__

/* interface IQueryStructures */
/* [unique][uuid] */ 

#define DBQUERYGUID  { 0x49691C90, \
                       0x7E17, 0x101A, \
                       0xA9, 0x1C, 0x08, 0x00, 0x2B, \
                       0x2E, 0xCD, 0xA9 } 
#define	DISPID_QUERY_RANKVECTOR	( 2 )

#define	DISPID_QUERY_RANK	( 3 )

#define	DISPID_QUERY_HITCOUNT	( 4 )

#define	DISPID_QUERY_WORKID	( 5 )

#define	DISPID_QUERY_ALL	( 6 )

#define	DISPID_QUERY_UNFILTERED	( 7 )

#define	DISPID_QUERY_REVNAME	( 8 )

#define	DISPID_QUERY_VIRTUALPATH	( 9 )

#define	DISPID_QUERY_LASTSEENTIME	( 10 )

#define	CQUERYDISPIDS	( 11 )

#define PSGUID_QUERY_METADATA { 0x624C9360, \
                                0x93D0, 0x11CF, \
                                0xA7, 0x87, 0x00, 0x00, 0x4C, \
                                0x75, 0x27, 0x52 } 
#define	DISPID_QUERY_METADATA_VROOTUSED	( 2 )

#define	DISPID_QUERY_METADATA_VROOTAUTOMATIC	( 3 )

#define	DISPID_QUERY_METADATA_VROOTMANUAL	( 4 )

#define	DISPID_QUERY_METADATA_PROPGUID	( 5 )

#define	DISPID_QUERY_METADATA_PROPDISPID	( 6 )

#define	DISPID_QUERY_METADATA_PROPNAME	( 7 )

#define	DISPID_QUERY_METADATA_STORELEVEL	( 8 )

#define	DISPID_QUERY_METADATA_PROPMODIFIABLE	( 9 )

#define	CQUERYMETADISPIDS	( 10 )

#define DBBMKGUID { 0xC8B52232L, \
                 0x5CF3, 0x11CE, \
                 {0xAD, 0xE5, 0x00, 0xAA, 0x00, \
                  0x44, 0x77, 0x3D } }
#define	PROPID_DBBMK_BOOKMARK	( 2 )

#define	PROPID_DBBMK_CHAPTER	( 3 )

#define	CDBBMKDISPIDS	( 8 )

#define DBSELFGUID {0xc8b52231,0x5cf3,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
#define	PROPID_DBSELF_SELF	( 2 )

#define	CDBSELFDISPIDS	( 8 )

#define	CDBCOLDISPIDS	( 28 )

#define	CQUERYPROPERTY	( 64 )

#define PSGUID_CHARACTERIZATION { 0x560c36c0, \
                                  0x503a, 0x11cf, \
                                  0xba, 0xa1, 0x00, 0x00, \
                                  0x4c, 0x75, 0x2a, 0x9a } 
#define	QUERY_VALIDBITS	( 3 )

#define	RTNone	( 0 )

#define	RTAnd	( 1 )

#define	RTOr	( 2 )

#define	RTNot	( 3 )

#define	RTContent	( 4 )

#define	RTProperty	( 5 )

#define	RTProximity	( 6 )

#define	RTVector	( 7 )

#define	RTNatLanguage	( 8 )

typedef struct tagRESTRICTION RESTRICTION;

typedef struct tagNOTRESTRICTION
    {
    RESTRICTION *pRes;
    } 	NOTRESTRICTION;

typedef struct tagNODERESTRICTION
    {
    ULONG cRes;
    RESTRICTION **paRes;
    ULONG reserved;
    } 	NODERESTRICTION;

#define	VECTOR_RANK_MIN	( 0 )

#define	VECTOR_RANK_MAX	( 1 )

#define	VECTOR_RANK_INNER	( 2 )

#define	VECTOR_RANK_DICE	( 3 )

#define	VECTOR_RANK_JACCARD	( 4 )

typedef struct tagVECTORRESTRICTION
    {
    NODERESTRICTION Node;
    ULONG RankMethod;
    } 	VECTORRESTRICTION;

#define	GENERATE_METHOD_EXACT	( 0 )

#define	GENERATE_METHOD_PREFIXMATCH	( 1 )

#define	GENERATE_METHOD_STEMMED	( 2 )

typedef struct tagCONTENTRESTRICTION
    {
    FULLPROPSPEC prop;
    WCHAR *pwcsPhrase;
    LCID lcid;
    ULONG ulGenerateMethod;
    } 	CONTENTRESTRICTION;

typedef struct tagNATLANGUAGERESTRICTION
    {
    FULLPROPSPEC prop;
    WCHAR *pwcsPhrase;
    LCID lcid;
    } 	NATLANGUAGERESTRICTION;

#define	PRLT	( 0 )

#define	PRLE	( 1 )

#define	PRGT	( 2 )

#define	PRGE	( 3 )

#define	PREQ	( 4 )

#define	PRNE	( 5 )

#define	PRRE	( 6 )

#define	PRAllBits	( 7 )

#define	PRSomeBits	( 8 )

#define	PRAll	( 0x100 )

#define	PRAny	( 0x200 )

typedef struct tagPROPERTYRESTRICTION
    {
    ULONG rel;
    FULLPROPSPEC prop;
    PROPVARIANT prval;
    } 	PROPERTYRESTRICTION;


struct tagRESTRICTION
    {
    ULONG rt;
    ULONG weight;
    union _URes
        {
        NODERESTRICTION ar;
        NODERESTRICTION or;
        NODERESTRICTION pxr;
        VECTORRESTRICTION vr;
        NOTRESTRICTION nr;
        CONTENTRESTRICTION cr;
        NATLANGUAGERESTRICTION nlr;
        PROPERTYRESTRICTION pr;
         /* Empty union arm */ 
        } 	res;
    } ;
typedef struct tagCOLUMNSET
    {
    ULONG cCol;
    FULLPROPSPEC *aCol;
    } 	COLUMNSET;

#define	QUERY_SORTASCEND	( 0 )

#define	QUERY_SORTDESCEND	( 1 )

#define	QUERY_SORTXASCEND	( 2 )

#define	QUERY_SORTXDESCEND	( 3 )

#define	QUERY_SORTDEFAULT	( 4 )

typedef struct tagSORTKEY
    {
    FULLPROPSPEC propColumn;
    ULONG dwOrder;
    LCID locale;
    } 	SORTKEY;

typedef struct tagSORTSET
    {
    ULONG cCol;
    SORTKEY *aCol;
    } 	SORTSET;

#define	CATEGORIZE_UNIQUE	( 0 )

#define	CATEGORIZE_CLUSTER	( 1 )

#define	CATEGORIZE_BUCKETS	( 2 )

#define	BUCKET_LINEAR	( 0 )

#define	BUCKET_EXPONENTIAL	( 1 )

typedef struct tagBUCKETCATEGORIZE
    {
    ULONG cBuckets;
    ULONG Distribution;
    } 	BUCKETCATEGORIZE;

#define	CATEGORIZE_RANGE	( 3 )

typedef struct tagRANGECATEGORIZE
    {
    ULONG cRange;
    PROPVARIANT *aRangeBegin;
    } 	RANGECATEGORIZE;

typedef struct tagCATEGORIZATION
    {
    ULONG ulCatType;
    union 
        {
        ULONG cClusters;
        BUCKETCATEGORIZE bucket;
        RANGECATEGORIZE range;
         /* Empty union arm */ 
        } 	;
    COLUMNSET csColumns;
    } 	CATEGORIZATION;

typedef struct tagCATEGORIZATIONSET
    {
    ULONG cCat;
    CATEGORIZATION *aCat;
    } 	CATEGORIZATIONSET;

typedef unsigned long OCCURRENCE;

#define	OCC_INVALID	( 0xffffffff )

#define	MAX_QUERY_RANK	( 1000 )



extern RPC_IF_HANDLE IQueryStructures_v0_0_c_ifspec;
extern RPC_IF_HANDLE IQueryStructures_v0_0_s_ifspec;
#endif /* __IQueryStructures_INTERFACE_DEFINED__ */

#ifndef __ISearchQueryHits_INTERFACE_DEFINED__
#define __ISearchQueryHits_INTERFACE_DEFINED__

/* interface ISearchQueryHits */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ISearchQueryHits;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ed8ce7e0-106c-11ce-84e2-00aa004b9986")
    ISearchQueryHits : public IUnknown
    {
    public:
        virtual SCODE STDMETHODCALLTYPE Init( 
            /* [in] */ IFilter *pflt,
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual SCODE STDMETHODCALLTYPE NextHitMoniker( 
            /* [out][in] */ ULONG *pcMnk,
            /* [size_is][out] */ IMoniker ***papMnk) = 0;
        
        virtual SCODE STDMETHODCALLTYPE NextHitOffset( 
            /* [out][in] */ ULONG *pcRegion,
            /* [size_is][out] */ FILTERREGION **paRegion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchQueryHitsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISearchQueryHits * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISearchQueryHits * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISearchQueryHits * This);
        
        SCODE ( STDMETHODCALLTYPE *Init )( 
            ISearchQueryHits * This,
            /* [in] */ IFilter *pflt,
            /* [in] */ ULONG ulFlags);
        
        SCODE ( STDMETHODCALLTYPE *NextHitMoniker )( 
            ISearchQueryHits * This,
            /* [out][in] */ ULONG *pcMnk,
            /* [size_is][out] */ IMoniker ***papMnk);
        
        SCODE ( STDMETHODCALLTYPE *NextHitOffset )( 
            ISearchQueryHits * This,
            /* [out][in] */ ULONG *pcRegion,
            /* [size_is][out] */ FILTERREGION **paRegion);
        
        END_INTERFACE
    } ISearchQueryHitsVtbl;

    interface ISearchQueryHits
    {
        CONST_VTBL struct ISearchQueryHitsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchQueryHits_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISearchQueryHits_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISearchQueryHits_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISearchQueryHits_Init(This,pflt,ulFlags)	\
    ( (This)->lpVtbl -> Init(This,pflt,ulFlags) ) 

#define ISearchQueryHits_NextHitMoniker(This,pcMnk,papMnk)	\
    ( (This)->lpVtbl -> NextHitMoniker(This,pcMnk,papMnk) ) 

#define ISearchQueryHits_NextHitOffset(This,pcRegion,paRegion)	\
    ( (This)->lpVtbl -> NextHitOffset(This,pcRegion,paRegion) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISearchQueryHits_INTERFACE_DEFINED__ */


#ifndef __IRowsetQueryStatus_INTERFACE_DEFINED__
#define __IRowsetQueryStatus_INTERFACE_DEFINED__

/* interface IRowsetQueryStatus */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IRowsetQueryStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a7ac77ed-f8d7-11ce-a798-0020f8008024")
    IRowsetQueryStatus : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ DWORD *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusEx( 
            /* [out] */ DWORD *pdwStatus,
            /* [out] */ DWORD *pcFilteredDocuments,
            /* [out] */ DWORD *pcDocumentsToFilter,
            /* [out] */ ULONG_PTR *pdwRatioFinishedDenominator,
            /* [out] */ ULONG_PTR *pdwRatioFinishedNumerator,
            /* [in] */ ULONG_PTR cbBmk,
            /* [size_is][in] */ const BYTE *pBmk,
            /* [out] */ ULONG_PTR *piRowBmk,
            /* [out] */ ULONG_PTR *pcRowsTotal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetQueryStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRowsetQueryStatus * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRowsetQueryStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRowsetQueryStatus * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IRowsetQueryStatus * This,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusEx )( 
            IRowsetQueryStatus * This,
            /* [out] */ DWORD *pdwStatus,
            /* [out] */ DWORD *pcFilteredDocuments,
            /* [out] */ DWORD *pcDocumentsToFilter,
            /* [out] */ ULONG_PTR *pdwRatioFinishedDenominator,
            /* [out] */ ULONG_PTR *pdwRatioFinishedNumerator,
            /* [in] */ ULONG_PTR cbBmk,
            /* [size_is][in] */ const BYTE *pBmk,
            /* [out] */ ULONG_PTR *piRowBmk,
            /* [out] */ ULONG_PTR *pcRowsTotal);
        
        END_INTERFACE
    } IRowsetQueryStatusVtbl;

    interface IRowsetQueryStatus
    {
        CONST_VTBL struct IRowsetQueryStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetQueryStatus_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRowsetQueryStatus_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRowsetQueryStatus_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRowsetQueryStatus_GetStatus(This,pdwStatus)	\
    ( (This)->lpVtbl -> GetStatus(This,pdwStatus) ) 

#define IRowsetQueryStatus_GetStatusEx(This,pdwStatus,pcFilteredDocuments,pcDocumentsToFilter,pdwRatioFinishedDenominator,pdwRatioFinishedNumerator,cbBmk,pBmk,piRowBmk,pcRowsTotal)	\
    ( (This)->lpVtbl -> GetStatusEx(This,pdwStatus,pcFilteredDocuments,pcDocumentsToFilter,pdwRatioFinishedDenominator,pdwRatioFinishedNumerator,cbBmk,pBmk,piRowBmk,pcRowsTotal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRowsetQueryStatus_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_query_0000_0003 */
/* [local] */ 

#include <indexsrv.h>


extern RPC_IF_HANDLE __MIDL_itf_query_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_query_0000_0003_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Ras.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ras.h

Abstract:

    Remote Access external API

    WINVER values in this file:
        WINVER < 0x400 = Windows NT 3.5, Windows NT 3.51
        WINVER = 0x400 = Windows 95, Windows98, Windows NT4 (default)
        WINVER > 0x400 = Windows NT4 enhancements
        WINVER = 0x500 = Windows 2000

--*/

#ifndef _RAS_H_
#define _RAS_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#pragma warning(push)
#pragma warning(disable:4201)//nameless struct/union

#ifndef UNLEN
#include <lmcons.h>
#endif

// To use Quarantine APIs, applications should explicitly 
// define USES_RAS_QUARANTINE_APIS.
#ifdef USES_RAS_QUARANTINE_APIS
#include <naptypes.h>

#define RASNAP_ProbationTime            0x00000001

typedef struct _tagRasNapState
{
    DWORD          dwSize;
    DWORD          dwFlags;
    IsolationState isolationState;
    ProbationTime  probationTime;
} RASNAPSTATE, *LPRASNAPSTATE;
#endif // USES_RAS_QUARANTINE_APIS

#include <pshpack4.h>
#include <inaddr.h>
#include <in6addr.h>

/* RAS API Version
*/
#define RASAPIVERSION enum RASAPIVERSION
RASAPIVERSION
{
    RASAPIVERSION_500 = 1,
    RASAPIVERSION_501,
    RASAPIVERSION_600,
    RASAPIVERSION_601,
};

#define RASAPIVERSION_CURRENT   RASAPIVERSION_601

/* A RAS IP address.
*/
#define RASIPADDR struct RASIPADDR
RASIPADDR
{
    BYTE a;
    BYTE b;
    BYTE c;
    BYTE d;
};

#if (WINVER >= 0x600)

/* A RAS IPv4 address.
*/
typedef struct in_addr RASIPV4ADDR;

/* A RAS IPv6 address.
*/
typedef struct in6_addr RASIPV6ADDR;
#endif

#if (WINVER >= 0x601)

#define RASTUNNELENDPOINT_UNKNOWN      0
#define RASTUNNELENDPOINT_IPv4         1
#define RASTUNNELENDPOINT_IPv6         2

/* RAS Tunnel endpoint address
*/
#define RASTUNNELENDPOINT struct tagRASTUNNELENDPOINT
RASTUNNELENDPOINT
{
    DWORD dwType;
    union {
        RASIPV4ADDR ipv4;
        RASIPV6ADDR ipv6;
    };
};

#endif

#define RAS_MaxDeviceType     16
#define RAS_MaxPhoneNumber    128
#define RAS_MaxIpAddress      15
#define RAS_MaxIpxAddress     21

#if (WINVER >= 0x400)
#define RAS_MaxEntryName      256
#define RAS_MaxDeviceName     128
#define RAS_MaxCallbackNumber RAS_MaxPhoneNumber
#else
#define RAS_MaxEntryName      20
#define RAS_MaxDeviceName     32
#define RAS_MaxCallbackNumber 48
#endif

#define RAS_MaxAreaCode       10
#define RAS_MaxPadType        32
#define RAS_MaxX25Address     200
#define RAS_MaxFacilities     200
#define RAS_MaxUserData       200
#define RAS_MaxReplyMessage   1024
#define RAS_MaxDnsSuffix      256

DECLARE_HANDLE( HRASCONN );
#define LPHRASCONN HRASCONN*

#if (WINVER >= 0x501)
#define RASCF_AllUsers        0x00000001
#define RASCF_GlobalCreds     0x00000002
#define RASCF_OwnerKnown      0x00000004
#define RASCF_OwnerMatch      0x00000008

#define RASCF_IsOwner(rascFlags)    (((rascFlags) & (RASCF_OwnerKnown | RASCF_OwnerMatch)) == (RASCF_OwnerKnown | RASCF_OwnerMatch))
#define RASCF_IsNotOwner(rascFlags) (((rascFlags) & (RASCF_OwnerKnown | RASCF_OwnerMatch)) == (RASCF_OwnerKnown))
#endif

/* Identifies an active RAS connection.  (See RasEnumConnections)
*/
#define RASCONNW struct tagRASCONNW
RASCONNW
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    WCHAR    szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x400)
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
#endif
#if (WINVER >= 0x401)
    WCHAR    szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
#endif
#if (WINVER >= 0x500)
    GUID     guidEntry;
#endif
#if (WINVER >= 0x501)
    DWORD    dwFlags;
    LUID     luid;
#endif
#if (WINVER >= 0x600)
    GUID     guidCorrelationId;
#endif
};

#define RASCONNA struct tagRASCONNA
RASCONNA
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x400)
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
#endif
#if (WINVER >= 0x401)
    CHAR     szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
#endif
#if (WINVER >= 0x500)
    GUID     guidEntry;
#endif
#if (WINVER >= 0x501)
    DWORD    dwFlags;
    LUID     luid;
#endif
#if (WINVER >= 0x600)
    GUID     guidCorrelationId;
#endif
};

#ifdef UNICODE
#define RASCONN RASCONNW
#else
#define RASCONN RASCONNA
#endif

#define LPRASCONNW RASCONNW*
#define LPRASCONNA RASCONNA*
#define LPRASCONN  RASCONN*


/* Enumerates intermediate states to a connection.  (See RasDial)
*/
#define RASCS_PAUSED    0x1000
#define RASCS_DONE      0x2000

#define RASCONNSTATE enum tagRASCONNSTATE
RASCONNSTATE
{
    RASCS_OpenPort = 0,
    RASCS_PortOpened,
    RASCS_ConnectDevice,
    RASCS_DeviceConnected,
    RASCS_AllDevicesConnected,
    RASCS_Authenticate,
    RASCS_AuthNotify,
    RASCS_AuthRetry,
    RASCS_AuthCallback,
    RASCS_AuthChangePassword,
    RASCS_AuthProject,
    RASCS_AuthLinkSpeed,
    RASCS_AuthAck,
    RASCS_ReAuthenticate,
    RASCS_Authenticated,
    RASCS_PrepareForCallback,
    RASCS_WaitForModemReset,
    RASCS_WaitForCallback,
    RASCS_Projected,
#if (WINVER >= 0x400)
    RASCS_StartAuthentication,
    RASCS_CallbackComplete,
    RASCS_LogonNetwork,
#endif
    RASCS_SubEntryConnected,
    RASCS_SubEntryDisconnected,
#if (WINVER >= 0x601)
    RASCS_ApplySettings,
#endif
    
    RASCS_Interactive = RASCS_PAUSED,
    RASCS_RetryAuthentication,
    RASCS_CallbackSetByCaller,
    RASCS_PasswordExpired,
#if (WINVER >= 0x500)
    RASCS_InvokeEapUI,
#endif

    RASCS_Connected = RASCS_DONE,
    RASCS_Disconnected
};

#define LPRASCONNSTATE RASCONNSTATE*

#if (WINVER >= 0x601)

#define RASCSS_DONE      0x2000

#define RASCONNSUBSTATE enum tagRASCONNSUBSTATE
RASCONNSUBSTATE
{
    RASCSS_None = 0,
    RASCSS_Dormant,
    RASCSS_Reconnecting,
    RASCSS_Reconnected = RASCSS_DONE,
};

#define LPRASCONNSUBSTATE RASCONNSUBSTATE*

#endif

/* Describes the status of a RAS connection.  (See RasGetConnectStatus)
*/
#define RASCONNSTATUSW struct tagRASCONNSTATUSW
RASCONNSTATUSW
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    WCHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
#if (WINVER >= 0x401)
    WCHAR        szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
#endif
#if (WINVER >= 0x601)
    RASTUNNELENDPOINT localEndPoint;
    RASTUNNELENDPOINT remoteEndPoint;
    RASCONNSUBSTATE   rasconnsubstate;
#endif
};

#define RASCONNSTATUSA struct tagRASCONNSTATUSA
RASCONNSTATUSA
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    CHAR         szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR         szDeviceName[ RAS_MaxDeviceName + 1 ];
#if (WINVER >= 0x401)
    CHAR         szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
#endif
#if (WINVER >= 0x601)
    RASTUNNELENDPOINT localEndPoint;
    RASTUNNELENDPOINT remoteEndPoint;
    RASCONNSUBSTATE   rasconnsubstate;
#endif
};

#ifdef UNICODE
#define RASCONNSTATUS RASCONNSTATUSW
#else
#define RASCONNSTATUS RASCONNSTATUSA
#endif

#define LPRASCONNSTATUSW RASCONNSTATUSW*
#define LPRASCONNSTATUSA RASCONNSTATUSA*
#define LPRASCONNSTATUS  RASCONNSTATUS*

/* Describes connection establishment parameters.  (See RasDial)
*/
#define RASDIALPARAMSW struct tagRASDIALPARAMSW
RASDIALPARAMSW
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
    WCHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    WCHAR szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
#if (WINVER >= 0x401)
    DWORD dwSubEntry;
    ULONG_PTR dwCallbackId;
#endif
#if (WINVER >= 0x601)
    DWORD dwIfIndex;
#endif
};

#define RASDIALPARAMSA struct tagRASDIALPARAMSA
RASDIALPARAMSA
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN + 1 ];
#if (WINVER >= 0x401)
    DWORD dwSubEntry;
    ULONG_PTR dwCallbackId;
#endif
#if (WINVER >= 0x601)
    DWORD dwIfIndex;
#endif
};

#ifdef UNICODE
#define RASDIALPARAMS RASDIALPARAMSW
#else
#define RASDIALPARAMS RASDIALPARAMSA
#endif

#define LPRASDIALPARAMSW RASDIALPARAMSW*
#define LPRASDIALPARAMSA RASDIALPARAMSA*
#define LPRASDIALPARAMS  RASDIALPARAMS*

#if (WINVER >= 0x500)

#define RASEAPINFO struct tagRASEAPINFO
RASEAPINFO
{
    DWORD dwSizeofEapInfo;
    BYTE  *pbEapInfo;
};

#endif

#if (WINVER >= 0x601)
typedef struct tagRASDEVSPECIFICINFO
{
    DWORD   dwSize;
    BYTE   *pbDevSpecificInfo;
} RASDEVSPECIFICINFO, *PRASDEVSPECIFICINFO;


#endif

/* Describes extended connection establishment options.  (See RasDial)
*/
#define RASDIALEXTENSIONS struct tagRASDIALEXTENSIONS
RASDIALEXTENSIONS
{
    DWORD      dwSize;
    DWORD      dwfOptions;
    HWND       hwndParent;
    ULONG_PTR  reserved;
#if (WINVER >= 0x500)
    ULONG_PTR  reserved1;
    RASEAPINFO RasEapInfo;
#endif
#if (WINVER >= 0x601)
    BOOL                fSkipPppAuth;
    RASDEVSPECIFICINFO  RasDevSpecificInfo;
#endif 
};

#define LPRASDIALEXTENSIONS RASDIALEXTENSIONS*

/* 'dwfOptions' bit flags.
*/
#define RDEOPT_UsePrefixSuffix           0x00000001
#define RDEOPT_PausedStates              0x00000002
#define RDEOPT_IgnoreModemSpeaker        0x00000004
#define RDEOPT_SetModemSpeaker           0x00000008
#define RDEOPT_IgnoreSoftwareCompression 0x00000010
#define RDEOPT_SetSoftwareCompression    0x00000020
#define RDEOPT_DisableConnectedUI        0x00000040
#define RDEOPT_DisableReconnectUI        0x00000080
#define RDEOPT_DisableReconnect          0x00000100
#define RDEOPT_NoUser                    0x00000200
#define RDEOPT_PauseOnScript             0x00000400
#define RDEOPT_Router                    0x00000800

#if (WINVER >= 0x500)
#define RDEOPT_CustomDial                0x00001000
#endif

#if (WINVER >= 0x501)
#define RDEOPT_UseCustomScripting        0x00002000
#endif

//
// This flag when set in the RASENTRYNAME structure
// indicates that the phonebook to which this entry
// belongs is a system phonebook.
//
#define REN_User                         0x00000000
#define REN_AllUsers                     0x00000001


/* Describes an enumerated RAS phone book entry name.  (See RasEntryEnum)
*/
#define RASENTRYNAMEW struct tagRASENTRYNAMEW
RASENTRYNAMEW
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x500)
    //
    // If this flag is REN_AllUsers then its a
    // system phonebook.
    //
    DWORD dwFlags;
    WCHAR szPhonebookPath[MAX_PATH + 1];
#endif
};

#define RASENTRYNAMEA struct tagRASENTRYNAMEA
RASENTRYNAMEA
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x500)
    DWORD dwFlags;
    CHAR  szPhonebookPath[MAX_PATH + 1];
#endif

};

#ifdef UNICODE
#define RASENTRYNAME RASENTRYNAMEW
#else
#define RASENTRYNAME RASENTRYNAMEA
#endif

#define LPRASENTRYNAMEW RASENTRYNAMEW*
#define LPRASENTRYNAMEA RASENTRYNAMEA*
#define LPRASENTRYNAME  RASENTRYNAME*


/* Protocol code to projection data structure mapping.
*/
#define RASPROJECTION enum tagRASPROJECTION
RASPROJECTION
{
    RASP_Amb = 0x10000,
    RASP_PppNbf = 0x803F,
    RASP_PppIpx = 0x802B,
    RASP_PppIp = 0x8021,
#if (WINVER >= 0x500)
    RASP_PppCcp = 0x80FD,
#endif
    RASP_PppLcp = 0xC021,
#if (WINVER >= 0x600)
    RASP_PppIpv6 = 0x8057,   // To get Ipv6 projection information
#endif
#if (WINVER < 0x600) // SLIP
    RASP_Slip = 0x20000
#endif // (WINVER < 0x600) // SLIP
};

#define LPRASPROJECTION RASPROJECTION*


/* Describes the result of a RAS AMB (Authentication Message Block)
** projection.  This protocol is used with NT 3.1 and OS/2 1.3 downlevel
** RAS servers.
*/
#define RASAMBW struct tagRASAMBW
RASAMBW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#define RASAMBA struct tagRASAMBA
RASAMBA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#ifdef UNICODE
#define RASAMB RASAMBW
#else
#define RASAMB RASAMBA
#endif

#define LPRASAMBW RASAMBW*
#define LPRASAMBA RASAMBA*
#define LPRASAMB  RASAMB*


/* Describes the result of a PPP NBF (NetBEUI) projection.
*/
#define RASPPPNBFW struct tagRASPPPNBFW
RASPPPNBFW
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwNetBiosError;
    WCHAR szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    WCHAR szWorkstationName[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#define RASPPPNBFA struct tagRASPPPNBFA
RASPPPNBFA
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwNetBiosError;
    CHAR  szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    CHAR  szWorkstationName[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#ifdef UNICODE
#define RASPPPNBF RASPPPNBFW
#else
#define RASPPPNBF RASPPPNBFA
#endif

#define LPRASPPPNBFW RASPPPNBFW*
#define LPRASPPPNBFA RASPPPNBFA*
#define LPRASPPPNBF  RASPPPNBF*


/* Describes the results of a PPP IPX (Internetwork Packet Exchange)
** projection.
*/
#define RASPPPIPXW struct tagRASIPXW
RASPPPIPXW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpxAddress[ RAS_MaxIpxAddress + 1 ];
};


#define RASPPPIPXA struct tagRASPPPIPXA
RASPPPIPXA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpxAddress[ RAS_MaxIpxAddress + 1 ];
};

#ifdef UNICODE
#define RASPPPIPX RASPPPIPXW
#else
#define RASPPPIPX RASPPPIPXA
#endif

#define LPRASPPPIPXW RASPPPIPXW*
#define LPRASPPPIPXA RASPPPIPXA*
#define LPRASPPPIPX  RASPPPIPX*


/* Describes the results of a PPP IP (Internet) projection.
*/

#if (WINVER >= 0x500)

/* RASPPPIP 'dwOptions' and 'dwServerOptions' flags.
*/
#define RASIPO_VJ       0x00000001

#endif

#define RASPPPIPW struct tagRASPPPIPW
RASPPPIPW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];

#ifndef WINNT35COMPATIBLE

    /* This field was added between Windows NT 3.51 beta and Windows NT 3.51
    ** final, and between Windows 95 M8 beta and Windows 95 final.  If you do
    ** not require the server address and wish to retrieve PPP IP information
    ** from Windows NT 3.5 or early Windows NT 3.51 betas, or on early Windows
    ** 95 betas, define WINNT35COMPATIBLE.
    **
    ** The server IP address is not provided by all PPP implementations,
    ** though Windows NT server's do provide it.
    */
    WCHAR szServerIpAddress[ RAS_MaxIpAddress + 1 ];

#endif
#if (WINVER >= 0x500)
    DWORD dwOptions;
    DWORD dwServerOptions;
#endif
};

#define RASPPPIPA struct tagRASPPPIPA
RASPPPIPA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpAddress[ RAS_MaxIpAddress + 1 ];

#ifndef WINNT35COMPATIBLE

    /* See RASPPPIPW comment.
    */
    CHAR  szServerIpAddress[ RAS_MaxIpAddress + 1 ];

#endif
#if (WINVER >= 0x500)
    DWORD dwOptions;
    DWORD dwServerOptions;
#endif
};

#ifdef UNICODE
#define RASPPPIP RASPPPIPW
#else
#define RASPPPIP RASPPPIPA
#endif

#define LPRASPPPIPW RASPPPIPW*
#define LPRASPPPIPA RASPPPIPA*
#define LPRASPPPIP  RASPPPIP*

/* Describes the results of a Ipv6 projection info
*/
#if (WINVER >= 0x600)

#define RASPPPIPV6 struct tagRASPPPIPV6
RASPPPIPV6
{
    DWORD dwSize;
    DWORD dwError;
    BYTE  bLocalInterfaceIdentifier[8];
    BYTE  bPeerInterfaceIdentifier[8];
    BYTE  bLocalCompressionProtocol[2];
    BYTE  bPeerCompressionProtocol[2];
};

#define LPRASPPPIPV6  RASPPPIPV6*
#endif
  

/* Describes the results of a PPP LCP/multi-link negotiation.
*/

#if (WINVER >= 0x500)

/* RASPPPLCP 'dwAuthenticatonProtocol' values.
*/
#define RASLCPAP_PAP          0xC023
#define RASLCPAP_SPAP         0xC027
#define RASLCPAP_CHAP         0xC223
#define RASLCPAP_EAP          0xC227

/* RASPPPLCP 'dwAuthenticatonData' values.
*/
#define RASLCPAD_CHAP_MD5     0x05
#define RASLCPAD_CHAP_MS      0x80
#define RASLCPAD_CHAP_MSV2    0x81

/* RASPPPLCP 'dwOptions' and 'dwServerOptions' flags.
*/
#define RASLCPO_PFC           0x00000001
#define RASLCPO_ACFC          0x00000002
#define RASLCPO_SSHF          0x00000004
#define RASLCPO_DES_56        0x00000008
#define RASLCPO_3_DES         0x00000010

#if (WINVER >= 0x600)
#define RASLCPO_AES_128       0x00000020
#define RASLCPO_AES_256       0x00000040
#endif /* WINVER >= 0x0600 */

#endif


#define RASPPPLCPW struct tagRASPPPLCPW
RASPPPLCPW
{
    DWORD dwSize;
    BOOL  fBundled;

#if (WINVER >= 0x500)
    DWORD dwError;
    DWORD dwAuthenticationProtocol;
    DWORD dwAuthenticationData;
    DWORD dwEapTypeId;
    DWORD dwServerAuthenticationProtocol;
    DWORD dwServerAuthenticationData;
    DWORD dwServerEapTypeId;
    BOOL  fMultilink;
    DWORD dwTerminateReason;
    DWORD dwServerTerminateReason;
    WCHAR szReplyMessage[RAS_MaxReplyMessage];
    DWORD dwOptions;
    DWORD dwServerOptions;
#endif

};

#define RASPPPLCPA struct tagRASPPPLCPA
RASPPPLCPA
{
    DWORD dwSize;
    BOOL  fBundled;

#if (WINVER >= 0x500)
    DWORD dwError;
    DWORD dwAuthenticationProtocol;
    DWORD dwAuthenticationData;
    DWORD dwEapTypeId;
    DWORD dwServerAuthenticationProtocol;
    DWORD dwServerAuthenticationData;
    DWORD dwServerEapTypeId;
    BOOL  fMultilink;
    DWORD dwTerminateReason;
    DWORD dwServerTerminateReason;
    CHAR  szReplyMessage[RAS_MaxReplyMessage];
    DWORD dwOptions;
    DWORD dwServerOptions;
#endif

};


#ifdef UNICODE
#define RASPPPLCP RASPPPLCPW
#else
#define RASPPPLCP RASPPPLCPA
#endif

#define LPRASPPPLCPW RASPPPLCPW*
#define LPRASPPPLCPA RASPPPLCPA*
#define LPRASPPPLCP  RASPPPLCP*

#if (WINVER < 0x600) // SLIP

/* Describes the results of a SLIP (Serial Line IP) projection.
*/
#define RASSLIPW struct tagRASSLIPW
RASSLIPW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];
};

#define RASSLIPA struct tagRASSLIPA
RASSLIPA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpAddress[ RAS_MaxIpAddress + 1 ];
};

#ifdef UNICODE
#define RASSLIP RASSLIPW
#else
#define RASSLIP RASSLIPA
#endif

#define LPRASSLIPW RASSLIPW*
#define LPRASSLIPA RASSLIPA*
#define LPRASSLIP  RASSLIP*

#endif // SLIP

#if (WINVER >= 0x500)

/* Describes the results of a PPP CCP (Compression Control Protocol)
projection.
*/

/* RASPPPCCP 'dwCompressionAlgorithm' values.
*/
#define RASCCPCA_MPPC             0x00000006
#define RASCCPCA_STAC             0x00000005

/* RASPPPCCP 'dwOptions' values.
*/
#define RASCCPO_Compression       0x00000001
#define RASCCPO_HistoryLess       0x00000002
#define RASCCPO_Encryption56bit   0x00000010
#define RASCCPO_Encryption40bit   0x00000020
#define RASCCPO_Encryption128bit  0x00000040

#define RASPPPCCP struct tagRASPPPCCP
RASPPPCCP
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwCompressionAlgorithm;
    DWORD dwOptions;
    DWORD dwServerCompressionAlgorithm;
    DWORD dwServerOptions;
};

#define LPRASPPPCCP  RASPPPCCP*

#endif

/* 
** New Projection Information structure for PPP and IKEv2
** 
*/
#if (WINVER >= 0x601)

typedef struct _RASPPP_PROJECTION_INFO {

    // IPv4 Projection Parameters
    DWORD        dwIPv4NegotiationError;
    RASIPV4ADDR  ipv4Address;
    RASIPV4ADDR  ipv4ServerAddress;
    DWORD        dwIPv4Options;
    DWORD        dwIPv4ServerOptions;

    // IPv6 Projection Parameters
    DWORD        dwIPv6NegotiationError;
    BYTE         bInterfaceIdentifier[8];
    BYTE         bServerInterfaceIdentifier[8];

    // LCP Options
    BOOL         fBundled;
    BOOL         fMultilink;
    DWORD        dwAuthenticationProtocol;
    DWORD        dwAuthenticationData;
    DWORD        dwServerAuthenticationProtocol;
    DWORD        dwServerAuthenticationData;
    DWORD        dwEapTypeId;
    DWORD        dwServerEapTypeId;
    DWORD        dwLcpOptions;
    DWORD        dwLcpServerOptions;

    // CCP options
    DWORD        dwCcpError;
    DWORD        dwCcpCompressionAlgorithm;
    DWORD        dwCcpServerCompressionAlgorithm;
    DWORD        dwCcpOptions;
    DWORD        dwCcpServerOptions;
}
RASPPP_PROJECTION_INFO, *PRASPPP_PROJECTION_INFO;

/* RASIKEV2_PROJECTION_INFO 'dwFlags' values.
*/
#define RASIKEv2_FLAGS_MOBIKESUPPORTED     0x00000001
#define RASIKEv2_FLAGS_BEHIND_NAT          0x00000002
#define RASIKEv2_FLAGS_SERVERBEHIND_NAT    0x00000004

/* RASIKEV2_PROJECTION_INFO 'dwAuthenticatonProtocol' values.
*/
#define RASIKEv2_AUTH_MACHINECERTIFICATES  1
#define RASIKEv2_AUTH_EAP                  2

typedef struct _RASIKEV2_PROJECTION_INFO {

    // IPv4 Projection Parameters
    DWORD         dwIPv4NegotiationError;
    RASIPV4ADDR   ipv4Address;
    RASIPV4ADDR   ipv4ServerAddress;

    // IPv6 Projection Parameters
    DWORD         dwIPv6NegotiationError;
    RASIPV6ADDR   ipv6Address;
    RASIPV6ADDR   ipv6ServerAddress;
    DWORD         dwPrefixLength;

    // AUTH
    DWORD         dwAuthenticationProtocol;
    DWORD         dwEapTypeId;

    DWORD         dwFlags;
    DWORD         dwEncryptionMethod;

    DWORD         numIPv4ServerAddresses;
    RASIPV4ADDR*  ipv4ServerAddresses;
    DWORD         numIPv6ServerAddresses;
    RASIPV6ADDR*  ipv6ServerAddresses;
}
RASIKEV2_PROJECTION_INFO, *PRASIKEV2_PROJECTION_INFO;

typedef enum _RASPROJECTION_INFO_TYPE {

    PROJECTION_INFO_TYPE_PPP = 1,
    PROJECTION_INFO_TYPE_IKEv2,
}
RASPROJECTION_INFO_TYPE;

typedef struct _RAS_PROJECTION_INFO { 

    RASAPIVERSION             version;
    RASPROJECTION_INFO_TYPE   type;
    
    // Based on the connectionFlags, it should use appropriate projection info 
    union {
        RASPPP_PROJECTION_INFO     ppp;
        RASIKEV2_PROJECTION_INFO   ikev2;
    };
}
RAS_PROJECTION_INFO, *PRAS_PROJECTION_INFO;

#endif

/* If using RasDial message notifications, get the notification message code
** by passing this string to the RegisterWindowMessageA() API.
** WM_RASDIALEVENT is used only if a unique message cannot be registered.
*/
#define RASDIALEVENT    "RasDialEvent"
#define WM_RASDIALEVENT 0xCCCD

/* Prototypes for caller's RasDial callback handler.  Arguments are the
** message ID (currently always WM_RASDIALEVENT), the current RASCONNSTATE and
** the error that has occurred (or 0 if none).  Extended arguments are the
** handle of the RAS connection and an extended error code.
**
** For RASDIALFUNC2, subsequent callback notifications for all
** subentries can be cancelled by returning FALSE.
*/
typedef VOID (WINAPI *RASDIALFUNC)( UINT, RASCONNSTATE, DWORD );
typedef VOID (WINAPI *RASDIALFUNC1)( HRASCONN, UINT, RASCONNSTATE, DWORD, DWORD );
typedef DWORD (WINAPI *RASDIALFUNC2)( ULONG_PTR, DWORD, HRASCONN, UINT, RASCONNSTATE, DWORD, DWORD );


/* Information describing a RAS-capable device.
*/
#define RASDEVINFOW struct tagRASDEVINFOW
RASDEVINFOW
{
    DWORD    dwSize;
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#define RASDEVINFOA struct tagRASDEVINFOA
RASDEVINFOA
{
    DWORD    dwSize;
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#ifdef UNICODE
#define RASDEVINFO RASDEVINFOW
#else
#define RASDEVINFO RASDEVINFOA
#endif

#define LPRASDEVINFOW RASDEVINFOW*
#define LPRASDEVINFOA RASDEVINFOA*
#define LPRASDEVINFO  RASDEVINFO*

/* RAS country information (currently retrieved from TAPI).
*/
#define RASCTRYINFO struct RASCTRYINFO
RASCTRYINFO
{
    DWORD   dwSize;
    DWORD   dwCountryID;
    DWORD   dwNextCountryID;
    DWORD   dwCountryCode;
    DWORD   dwCountryNameOffset;
};

/* There is currently no difference between
** RASCTRYINFOA and RASCTRYINFOW.  This may
** change in the future.
*/
#define RASCTRYINFOW   RASCTRYINFO
#define RASCTRYINFOA   RASCTRYINFO

#define LPRASCTRYINFOW RASCTRYINFOW*
#define LPRASCTRYINFOA RASCTRYINFOW*
#define LPRASCTRYINFO  RASCTRYINFO*

#if (WINVER >= 0x500)

#define ET_None         0  // No encryption
#define ET_Require      1  // Require Encryption
#define ET_RequireMax   2  // Require max encryption
#define ET_Optional     3  // Do encryption if possible. None Ok.

#endif

#define VS_Default      0   // default (PPTP for now)
#define VS_PptpOnly     1   // Only PPTP is attempted.
#define VS_PptpFirst    2   // PPTP is tried first.
#define VS_L2tpOnly     3   // Only L2TP is attempted.
#define VS_L2tpFirst    4   // L2TP is tried first.

#if (WINVER >= 0x600)
#define VS_SstpOnly     5   // Only SSTP is attempted
#define VS_SstpFirst    6   // SSTP is attempted first
#endif

#if (WINVER >= 0x601)
#define VS_Ikev2Only    7   // Only VPN Ikev2 is attempted
#define VS_Ikev2First   8   // VPN Ikev2 is attempted first
#endif

#if (WINVER >= 0x601)
#define VS_PptpSstp     12  // PPTP is attempted followed only by SSTP
#define VS_L2tpSstp     13  // L2TP is attempted followed only by SSTP
#define VS_Ikev2Sstp    14  // IKEv2 is attempted followed only by SSTP
#endif

/* A RAS phone book entry.
*/
#define RASENTRYA struct tagRASENTRYA
RASENTRYA
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif

#if (WINVER >= 0x500)

    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // Encryption type
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial Dll
    //
    CHAR        szCustomDialDll[MAX_PATH];

    //
    // DwVpnStrategy
    //
    DWORD       dwVpnStrategy;
#endif

#if (WINVER >= 0x501)
    //
    // More RASEO_* options
    //
    DWORD       dwfOptions2;

    //
    // For future use
    //
    DWORD       dwfOptions3;

    CHAR        szDnsSuffix[RAS_MaxDnsSuffix];

    DWORD       dwTcpWindowSize;

    CHAR        szPrerequisitePbk[MAX_PATH];

    CHAR        szPrerequisiteEntry[RAS_MaxEntryName + 1];

    DWORD       dwRedialCount;

    DWORD       dwRedialPause;
#endif

#if (WINVER >= 0x600)
    //
    // PPP/IPv6
    //
    RASIPV6ADDR   ipv6addrDns;
    RASIPV6ADDR   ipv6addrDnsAlt;
    DWORD         dwIPv4InterfaceMetric;
    DWORD         dwIPv6InterfaceMetric;
#endif

#if (WINVER >= 0x601)
    // Fields required for supporting static IPv6 address 
    // configuration for a vpn interface by the user 
    RASIPV6ADDR   ipv6addr;
    DWORD         dwIPv6PrefixLength;

    //
    // IKEv2 related
    DWORD         dwNetworkOutageTime;
#endif
};

#define RASENTRYW struct tagRASENTRYW
RASENTRYW
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif

#if (WINVER >= 0x500)
    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // EncryptionType
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial Dll
    //
    WCHAR       szCustomDialDll[MAX_PATH];

    //
    // Vpn Strategy
    //
    DWORD       dwVpnStrategy;
#endif

#if (WINVER >= 0x501)
    //
    // More RASEO_* options
    //
    DWORD       dwfOptions2;

    //
    // For future use
    //
    DWORD       dwfOptions3;

    WCHAR       szDnsSuffix[RAS_MaxDnsSuffix];

    DWORD       dwTcpWindowSize;

    WCHAR       szPrerequisitePbk[MAX_PATH];

    WCHAR       szPrerequisiteEntry[RAS_MaxEntryName + 1];

    DWORD       dwRedialCount;

    DWORD       dwRedialPause;
#endif

#if (WINVER >= 0x600)
    //
    // PPP/IPv6
    //
    RASIPV6ADDR   ipv6addrDns;
    RASIPV6ADDR   ipv6addrDnsAlt;
    DWORD         dwIPv4InterfaceMetric;
    DWORD         dwIPv6InterfaceMetric;
#endif

#if (WINVER >= 0x601)
    //Fields required for supporting static IPv6 address 
    // configuration for a vpn interface by the user
    RASIPV6ADDR   ipv6addr;
    DWORD         dwIPv6PrefixLength;

    //
    // IKEv2 related
    DWORD         dwNetworkOutageTime;
#endif
};

#ifdef UNICODE
#define RASENTRY RASENTRYW
#else
#define RASENTRY RASENTRYA
#endif

#define LPRASENTRYW RASENTRYW*
#define LPRASENTRYA RASENTRYA*
#define LPRASENTRY  RASENTRY*

/* RASENTRY 'dwfOptions' bit flags.
*/
#define RASEO_UseCountryAndAreaCodes    0x00000001
#define RASEO_SpecificIpAddr            0x00000002
#define RASEO_SpecificNameServers       0x00000004
#define RASEO_IpHeaderCompression       0x00000008
#define RASEO_RemoteDefaultGateway      0x00000010
#define RASEO_DisableLcpExtensions      0x00000020
#define RASEO_TerminalBeforeDial        0x00000040
#define RASEO_TerminalAfterDial         0x00000080
#define RASEO_ModemLights               0x00000100
#define RASEO_SwCompression             0x00000200
#define RASEO_RequireEncryptedPw        0x00000400
#define RASEO_RequireMsEncryptedPw      0x00000800
#define RASEO_RequireDataEncryption     0x00001000
#define RASEO_NetworkLogon              0x00002000
#define RASEO_UseLogonCredentials       0x00004000
#define RASEO_PromoteAlternates         0x00008000

#if (WINVER >= 0x401)
#define RASEO_SecureLocalFiles          0x00010000
#endif

#if (WINVER >= 0x500)
#define RASEO_RequireEAP                0x00020000
#define RASEO_RequirePAP                0x00040000
#define RASEO_RequireSPAP               0x00080000
#define RASEO_Custom                    0x00100000

#define RASEO_PreviewPhoneNumber        0x00200000
#define RASEO_SharedPhoneNumbers        0x00800000
#define RASEO_PreviewUserPw             0x01000000
#define RASEO_PreviewDomain             0x02000000
#define RASEO_ShowDialingProgress       0x04000000
#define RASEO_RequireCHAP               0x08000000
#define RASEO_RequireMsCHAP             0x10000000
#define RASEO_RequireMsCHAP2            0x20000000
#define RASEO_RequireW95MSCHAP          0x40000000
#define RASEO_CustomScript              0x80000000
#endif

#if (WINVER >= 0x501)
//
// RASENTRY dwfOptions2 bit flags
//
#define RASEO2_SecureFileAndPrint       0x00000001
#define RASEO2_SecureClientForMSNet     0x00000002
#define RASEO2_DontNegotiateMultilink   0x00000004
#define RASEO2_DontUseRasCredentials    0x00000008
#define RASEO2_UsePreSharedKey          0x00000010
#define RASEO2_Internet                 0x00000020
#define RASEO2_DisableNbtOverIP         0x00000040
#define RASEO2_UseGlobalDeviceSettings  0x00000080
#define RASEO2_ReconnectIfDropped       0x00000100
#define RASEO2_SharePhoneNumbers        0x00000200
#endif

#if (WINVER >= 0x600)
#define RASEO2_SecureRoutingCompartment     0x00000400
#define RASEO2_UseTypicalSettings           0x00000800
#define RASEO2_IPv6SpecificNameServers      0x00001000
#define RASEO2_IPv6RemoteDefaultGateway     0x00002000
#define RASEO2_RegisterIpWithDNS            0x00004000
#define RASEO2_UseDNSSuffixForRegistration  0x00008000
#define RASEO2_IPv4ExplicitMetric           0x00010000
#define RASEO2_IPv6ExplicitMetric           0x00020000
#define RASEO2_DisableIKENameEkuCheck       0x00040000
#endif

#if (WINVER >= 0x601)
#define RASEO2_DisableClassBasedStaticRoute 0x00080000
#define RASEO2_SpecificIPv6Addr             0x00100000
#define RASEO2_DisableMobility              0x00200000
#define RASEO2_RequireMachineCertificates   0x00400000
#endif

/* RASENTRY 'dwProtocols' bit flags.
*/
#define RASNP_NetBEUI                   0x00000001
#define RASNP_Ipx                       0x00000002
#define RASNP_Ip                        0x00000004
#if (WINVER >= 0x600)
#define RASNP_Ipv6                      0x00000008
#endif

/* RASENTRY 'dwFramingProtocols' bit flags.
*/
#define RASFP_Ppp                       0x00000001
#define RASFP_Slip                      0x00000002
#define RASFP_Ras                       0x00000004

/* RASENTRY 'szDeviceType' default strings.
*/
#define RASDT_Modem                     TEXT("modem")
#define RASDT_Isdn                      TEXT("isdn")
#define RASDT_X25                       TEXT("x25")
#define RASDT_Vpn                       TEXT("vpn")
#define RASDT_Pad                       TEXT("pad")
#define RASDT_Generic                   TEXT("GENERIC")
#define RASDT_Serial                    TEXT("SERIAL")
#define RASDT_FrameRelay                TEXT("FRAMERELAY")
#define RASDT_Atm                       TEXT("ATM")
#define RASDT_Sonet                     TEXT("SONET")
#define RASDT_SW56                      TEXT("SW56")
#define RASDT_Irda                      TEXT("IRDA")
#define RASDT_Parallel                  TEXT("PARALLEL")
#if (WINVER >= 0x501)
#define RASDT_PPPoE                     TEXT("PPPoE")
#endif


// The entry type used to determine which UI properties
// are to be presented to user.  This generally corresponds
// to a Connections "add" wizard selection.
//
#define RASET_Phone     1  // Phone lines: modem, ISDN, X.25, etc
#define RASET_Vpn       2  // Virtual private network

#if (WINVER < 0x600)
#define RASET_Direct    3  // Direct connect: serial, parallel
#endif // (WINVER < 0x600)

#define RASET_Internet  4  // BaseCamp internet
#if (WINVER >= 0x501)
#define RASET_Broadband 5  // Broadband
#endif

/* Old AutoDial DLL function prototype.
**
** This prototype is documented for backward-compatibility
** purposes only.  It is superceded by the RASADFUNCA
** and RASADFUNCW definitions below.  DO NOT USE THIS
** PROTOTYPE IN NEW CODE.  SUPPORT FOR IT MAY BE REMOVED
** IN FUTURE VERSIONS OF RAS.
*/
typedef BOOL (WINAPI *ORASADFUNC)( HWND, LPSTR, DWORD, LPDWORD );

#if (WINVER >= 0x400)

/* Flags for RasConnectionNotification().
*/
#define RASCN_Connection        0x00000001
#define RASCN_Disconnection     0x00000002
#define RASCN_BandwidthAdded    0x00000004
#define RASCN_BandwidthRemoved  0x00000008
#define RASCN_Dormant           0x00000010
#define RASCN_ReConnection      0x00000020
#endif

#if (WINVER >= 0x401)
/* RASENTRY 'dwDialMode' values.
*/
#define RASEDM_DialAll                  1
#define RASEDM_DialAsNeeded             2

/* RASENTRY 'dwIdleDisconnectSeconds' constants.
*/
#define RASIDS_Disabled                 0xffffffff
#define RASIDS_UseGlobalValue           0

/* AutoDial DLL function parameter block.
*/
#define RASADPARAMS struct tagRASADPARAMS
RASADPARAMS
{
    DWORD       dwSize;
    HWND        hwndOwner;
    DWORD       dwFlags;
    LONG        xDlg;
    LONG        yDlg;
};

#define LPRASADPARAMS RASADPARAMS*

/* AutoDial DLL function parameter block 'dwFlags.'
*/
#define RASADFLG_PositionDlg            0x00000001

/* Prototype AutoDial DLL function.
*/
typedef BOOL (WINAPI *RASADFUNCA)( LPSTR, LPSTR, LPRASADPARAMS, LPDWORD );
typedef BOOL (WINAPI *RASADFUNCW)( LPWSTR, LPWSTR, LPRASADPARAMS, LPDWORD );

#ifdef UNICODE
#define RASADFUNC RASADFUNCW
#else
#define RASADFUNC RASADFUNCA
#endif

/* A RAS phone book multilinked sub-entry.
*/
#define RASSUBENTRYA struct tagRASSUBENTRYA
RASSUBENTRYA
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#define RASSUBENTRYW struct tagRASSUBENTRYW
RASSUBENTRYW
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#ifdef UNICODE
#define RASSUBENTRY RASSUBENTRYW
#else
#define RASSUBENTRY RASSUBENTRYA
#endif

#define LPRASSUBENTRYW RASSUBENTRYW*
#define LPRASSUBENTRYA RASSUBENTRYA*
#define LPRASSUBENTRY  RASSUBENTRY*

/* Ras{Get,Set}Credentials structure.  These calls
** supercede Ras{Get,Set}EntryDialParams.
*/
#define RASCREDENTIALSA struct tagRASCREDENTIALSA
RASCREDENTIALSA
{
    DWORD dwSize;
    DWORD dwMask;
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN + 1 ];
};

#define RASCREDENTIALSW struct tagRASCREDENTIALSW
RASCREDENTIALSW
{
    DWORD dwSize;
    DWORD dwMask;
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#ifdef UNICODE
#define RASCREDENTIALS RASCREDENTIALSW
#else
#define RASCREDENTIALS RASCREDENTIALSA
#endif

#define LPRASCREDENTIALSW RASCREDENTIALSW*
#define LPRASCREDENTIALSA RASCREDENTIALSA*
#define LPRASCREDENTIALS  RASCREDENTIALS*

/* RASCREDENTIALS 'dwMask' values.
*/
#define RASCM_UserName           0x00000001
#define RASCM_Password           0x00000002
#define RASCM_Domain             0x00000004
#if (WINVER >= 501)
#define RASCM_DefaultCreds       0x00000008
#define RASCM_PreSharedKey       0x00000010
#define RASCM_ServerPreSharedKey 0x00000020
#define RASCM_DDMPreSharedKey    0x00000040
#endif

/* AutoDial address properties.
*/
#define RASAUTODIALENTRYA struct tagRASAUTODIALENTRYA
RASAUTODIALENTRYA
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    CHAR szEntry[ RAS_MaxEntryName + 1 ];
};

#define RASAUTODIALENTRYW struct tagRASAUTODIALENTRYW
RASAUTODIALENTRYW
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    WCHAR szEntry[ RAS_MaxEntryName + 1 ];
};

#ifdef UNICODE
#define RASAUTODIALENTRY RASAUTODIALENTRYW
#else
#define RASAUTODIALENTRY RASAUTODIALENTRYA
#endif

#define LPRASAUTODIALENTRYW RASAUTODIALENTRYW*
#define LPRASAUTODIALENTRYA RASAUTODIALENTRYA*
#define LPRASAUTODIALENTRY  RASAUTODIALENTRY*

/* AutoDial control parameter values for
** Ras{Get,Set}AutodialParam.
*/
#define RASADP_DisableConnectionQuery           0
#define RASADP_LoginSessionDisable              1
#define RASADP_SavedAddressesLimit              2
#define RASADP_FailedConnectionTimeout          3
#define RASADP_ConnectionQueryTimeout           4

#endif // (WINVER >= 0x401)

#if (WINVER >= 0x500)

/* RasGetEapUserIdentity bit flags.
** These have the same values as the RAS_EAP_FLAG_ flags in raseapif.h
*/
#define RASEAPF_NonInteractive          0x00000002
#define RASEAPF_Logon                   0x00000004
#define RASEAPF_Preview                 0x00000008

/* RasGetEapUserIdentity structure.
*/
#define RASEAPUSERIDENTITYA struct tagRASEAPUSERIDENTITYA
RASEAPUSERIDENTITYA
{
    CHAR        szUserName[ UNLEN + 1 ];
    DWORD       dwSizeofEapInfo;
    BYTE        pbEapInfo[ 1 ];
};

#define RASEAPUSERIDENTITYW struct tagRASEAPUSERIDENTITYW
RASEAPUSERIDENTITYW
{
    WCHAR       szUserName[ UNLEN + 1 ];
    DWORD       dwSizeofEapInfo;
    BYTE        pbEapInfo[ 1 ];
};

#ifdef UNICODE
#define RASEAPUSERIDENTITY RASEAPUSERIDENTITYW
#else
#define RASEAPUSERIDENTITY RASEAPUSERIDENTITYA
#endif

#define LPRASEAPUSERIDENTITYW RASEAPUSERIDENTITYW*
#define LPRASEAPUSERIDENTITYA RASEAPUSERIDENTITYA*

#define LPRASEAPUSERIDENTITY  RASEAPUSERIDENTITY*

typedef DWORD (WINAPI *PFNRASGETBUFFER) (
                            PBYTE *ppBuffer,
                            PDWORD pdwSize
                            );

typedef DWORD (WINAPI *PFNRASFREEBUFFER) (
                            PBYTE pBufer);

typedef DWORD (WINAPI *PFNRASSENDBUFFER) (
                            HANDLE hPort,
                            PBYTE  pBuffer,
                            DWORD  dwSize
                            );

typedef DWORD (WINAPI *PFNRASRECEIVEBUFFER) (
                            HANDLE hPort,
                            PBYTE pBuffer,
                            PDWORD pdwSize,
                            DWORD  dwTimeOut,
                            HANDLE hEvent
                            );

typedef DWORD (WINAPI *PFNRASRETRIEVEBUFFER) (
                            HANDLE hPort,
                            PBYTE pBuffer,
                            PDWORD pdwSize
                            );

typedef  DWORD (WINAPI *RasCustomScriptExecuteFn) (
                            HANDLE hPort,
                            LPCWSTR lpszPhonebook,
                            LPCWSTR lpszEntryName,
                            PFNRASGETBUFFER pfnRasGetBuffer,
                            PFNRASFREEBUFFER pfnRasFreeBuffer,
                            PFNRASSENDBUFFER pfnRasSendBuffer,
                            PFNRASRECEIVEBUFFER pfnRasReceiveBuffer,
                            PFNRASRETRIEVEBUFFER pfnRasRetrieveBuffer,
                            HWND hWnd,
                            RASDIALPARAMS *pRasDialParams,
                            PVOID pvReserved
                            );

#endif // (WINVER >= 0x500)

#if (WINVER >= 0x0501)

#define RASCOMMSETTINGS struct tagRASCOMMSETTINGS
RASCOMMSETTINGS
{
    DWORD     dwSize;
    BYTE      bParity;
    BYTE      bStop;
    BYTE      bByteSize;
    BYTE      bAlign;
};

typedef DWORD (WINAPI *PFNRASSETCOMMSETTINGS) (
                            HANDLE hPort,
                            RASCOMMSETTINGS *pRasCommSettings,
                            PVOID  pvReserved
                            );

#define RASCUSTOMSCRIPTEXTENSIONS struct tagRASCUSTOMSCRIPTEXTENSIONS
RASCUSTOMSCRIPTEXTENSIONS
{
    DWORD                 dwSize;
    PFNRASSETCOMMSETTINGS pfnRasSetCommSettings;
};

#endif


/* External RAS API function prototypes.
*/
DWORD APIENTRY RasDialA( __in_opt LPRASDIALEXTENSIONS, __in_opt LPCSTR, __in LPRASDIALPARAMSA, __in DWORD,
                         __in_opt LPVOID, __out LPHRASCONN );

DWORD APIENTRY RasDialW( __in_opt LPRASDIALEXTENSIONS, __in_opt LPCWSTR, __in LPRASDIALPARAMSW, __in DWORD,
                         __in_opt LPVOID, __out LPHRASCONN );

DWORD APIENTRY RasEnumConnectionsA( __inout_opt LPRASCONNA, __inout LPDWORD, __out LPDWORD );

DWORD APIENTRY RasEnumConnectionsW( __inout_opt LPRASCONNW, __inout LPDWORD, __out LPDWORD );

DWORD APIENTRY RasEnumEntriesA( __in_opt LPCSTR, __in_opt LPCSTR, __inout_opt LPRASENTRYNAMEA, __inout LPDWORD,
                                __out LPDWORD );

DWORD APIENTRY RasEnumEntriesW( __in_opt LPCWSTR, __in_opt LPCWSTR, __inout_opt LPRASENTRYNAMEW, __inout LPDWORD,
                                __out LPDWORD );

DWORD APIENTRY RasGetConnectStatusA( __in HRASCONN, __inout LPRASCONNSTATUSA );

DWORD APIENTRY RasGetConnectStatusW( __in HRASCONN, __inout LPRASCONNSTATUSW );

DWORD APIENTRY RasGetErrorStringA( __in UINT ResourceId, __out_bcount(InBufSize) LPSTR lpszString, __in DWORD  InBufSize);

DWORD APIENTRY RasGetErrorStringW( __in UINT ResourceId, __out_bcount(InBufSize) LPWSTR lpszString, __in DWORD  InBufSize);

DWORD APIENTRY RasHangUpA( __in HRASCONN );

DWORD APIENTRY RasHangUpW( __in HRASCONN );

DWORD APIENTRY RasGetProjectionInfoA( __in HRASCONN, __in RASPROJECTION, __out LPVOID, __inout LPDWORD );

DWORD APIENTRY RasGetProjectionInfoW( __in HRASCONN, __in RASPROJECTION, __out LPVOID, __inout LPDWORD );

DWORD APIENTRY RasCreatePhonebookEntryA( __in HWND, __in_opt LPCSTR );

DWORD APIENTRY RasCreatePhonebookEntryW( __in HWND, __in_opt LPCWSTR );

DWORD APIENTRY RasEditPhonebookEntryA( __in HWND, __in_opt LPCSTR, __in LPCSTR );

DWORD APIENTRY RasEditPhonebookEntryW( __in HWND, __in_opt LPCWSTR, __in LPCWSTR );

DWORD APIENTRY RasSetEntryDialParamsA( __in_opt LPCSTR, __in LPRASDIALPARAMSA, __in BOOL );

DWORD APIENTRY RasSetEntryDialParamsW( __in_opt LPCWSTR, __in LPRASDIALPARAMSW, __in BOOL );

DWORD APIENTRY RasGetEntryDialParamsA( __in_opt LPCSTR, __inout LPRASDIALPARAMSA, __out LPBOOL );

DWORD APIENTRY RasGetEntryDialParamsW( __in_opt LPCWSTR, __inout LPRASDIALPARAMSW, __out LPBOOL );

DWORD APIENTRY RasEnumDevicesA( __inout_opt LPRASDEVINFOA, __inout LPDWORD, __out LPDWORD );

DWORD APIENTRY RasEnumDevicesW( __inout_opt LPRASDEVINFOW, __inout LPDWORD, __out LPDWORD );

DWORD APIENTRY RasGetCountryInfoA( __inout_opt LPRASCTRYINFOA, __inout LPDWORD );

DWORD APIENTRY RasGetCountryInfoW( __inout_opt LPRASCTRYINFOW, __inout LPDWORD );

DWORD APIENTRY RasGetEntryPropertiesA( __in_opt LPCSTR, __in LPCSTR, __inout_opt LPRASENTRYA, __inout LPDWORD, __out_opt LPBYTE, __inout_opt LPDWORD );

DWORD APIENTRY RasGetEntryPropertiesW( __in_opt LPCWSTR, __in LPCWSTR, __inout_opt LPRASENTRYW, __inout LPDWORD, __out_opt LPBYTE, __inout_opt LPDWORD );

DWORD APIENTRY RasSetEntryPropertiesA( __in_opt LPCSTR, __in LPCSTR, __in LPRASENTRYA, __in DWORD, __in_opt LPBYTE, __in DWORD );

DWORD APIENTRY RasSetEntryPropertiesW( __in_opt LPCWSTR, __in LPCWSTR, __in LPRASENTRYW, __in DWORD, __in_opt LPBYTE, __in DWORD );

DWORD APIENTRY RasRenameEntryA( __in_opt LPCSTR, __in LPCSTR, __in LPCSTR );

DWORD APIENTRY RasRenameEntryW( __in_opt LPCWSTR, __in LPCWSTR, __in LPCWSTR );

DWORD APIENTRY RasDeleteEntryA( __in_opt LPCSTR, __in LPCSTR );

DWORD APIENTRY RasDeleteEntryW( __in_opt LPCWSTR, __in LPCWSTR );

DWORD APIENTRY RasValidateEntryNameA( __in_opt LPCSTR, __in LPCSTR );

DWORD APIENTRY RasValidateEntryNameW( __in_opt LPCWSTR, __in LPCWSTR );

DWORD APIENTRY RasConnectionNotificationA( __in HRASCONN, __in HANDLE, __in DWORD );

DWORD APIENTRY RasConnectionNotificationW( __in HRASCONN, __in HANDLE, __in DWORD );

#if (WINVER >= 0x401)
DWORD APIENTRY RasGetSubEntryHandleA( __in HRASCONN, __in DWORD, __out LPHRASCONN );

DWORD APIENTRY RasGetSubEntryHandleW( __in HRASCONN, __in DWORD, __out LPHRASCONN );

DWORD APIENTRY RasGetCredentialsA( __in_opt LPCSTR, __in LPCSTR, __inout LPRASCREDENTIALSA );

DWORD APIENTRY RasGetCredentialsW( __in_opt LPCWSTR, __in LPCWSTR, __inout LPRASCREDENTIALSW );

DWORD APIENTRY RasSetCredentialsA( __in_opt LPCSTR, __in LPCSTR, __in LPRASCREDENTIALSA, __in BOOL );

DWORD APIENTRY RasSetCredentialsW( __in_opt LPCWSTR, __in LPCWSTR, __in LPRASCREDENTIALSW, __in BOOL );

DWORD APIENTRY RasGetSubEntryPropertiesA( __in_opt LPCSTR, __in LPCSTR, __in DWORD,
                    __inout_opt  LPRASSUBENTRYA, __inout_opt LPDWORD, __out_opt  LPBYTE, __inout_opt LPDWORD );

DWORD APIENTRY RasGetSubEntryPropertiesW( __in_opt LPCWSTR, __in LPCWSTR, __in DWORD,
                    __inout_opt LPRASSUBENTRYW, __inout_opt LPDWORD, __out_opt LPBYTE, __inout_opt LPDWORD );

DWORD APIENTRY RasSetSubEntryPropertiesA( __in_opt LPCSTR, __in LPCSTR, __in DWORD, 
                    __in LPRASSUBENTRYA, __in DWORD, __in_opt  LPBYTE, __in DWORD );

DWORD APIENTRY RasSetSubEntryPropertiesW( __in_opt LPCWSTR, __in LPCWSTR, __in DWORD,
                    __in LPRASSUBENTRYW, __in DWORD, __in_opt  LPBYTE, __in DWORD );

DWORD APIENTRY RasGetAutodialAddressA( __in_opt LPCSTR, __in_opt LPDWORD, __inout_opt LPRASAUTODIALENTRYA,
                                       __inout LPDWORD, __out LPDWORD );

DWORD APIENTRY RasGetAutodialAddressW( __in_opt LPCWSTR, __in_opt LPDWORD, __inout_opt LPRASAUTODIALENTRYW,
                                       __inout LPDWORD, __out LPDWORD );

DWORD APIENTRY RasSetAutodialAddressA( __in_opt   LPCSTR, __in DWORD, __in_opt   LPRASAUTODIALENTRYA,
                                       __in DWORD, __in DWORD );

DWORD APIENTRY RasSetAutodialAddressW( __in_opt   LPCWSTR, __in DWORD, __in_opt   LPRASAUTODIALENTRYW,
                                       __in DWORD, __in DWORD );

DWORD APIENTRY RasEnumAutodialAddressesA(
    __inout_bcount_opt(*lpdwcbRasAutodialAddresses) LPSTR *lppRasAutodialAddresses,
    __inout  LPDWORD lpdwcbRasAutodialAddresses,
    __out    LPDWORD lpdwcRasAutodialAddresses);

DWORD APIENTRY RasEnumAutodialAddressesW(
    __inout_bcount_opt(*lpdwcbRasAutodialAddresses) LPWSTR *lppRasAutodialAddresses,
    __inout  LPDWORD lpdwcbRasAutodialAddresses,
    __out    LPDWORD lpdwcRasAutodialAddresses);

DWORD APIENTRY RasGetAutodialEnableA( __in DWORD, __out LPBOOL );

DWORD APIENTRY RasGetAutodialEnableW( __in DWORD, __out LPBOOL );

DWORD APIENTRY RasSetAutodialEnableA( __in DWORD, __in BOOL );

DWORD APIENTRY RasSetAutodialEnableW( __in DWORD, __in BOOL );

DWORD APIENTRY RasGetAutodialParamA( __in DWORD, __out LPVOID, __inout LPDWORD );

DWORD APIENTRY RasGetAutodialParamW( __in DWORD, __out LPVOID, __inout LPDWORD );

DWORD APIENTRY RasSetAutodialParamA( __in DWORD, __in LPVOID, __in DWORD );

DWORD APIENTRY RasSetAutodialParamW( __in DWORD, __in LPVOID, __in DWORD );

#endif

#if (WINVER >= 0x500)

typedef struct _RAS_STATS
{
    DWORD   dwSize;
    DWORD   dwBytesXmited;
    DWORD   dwBytesRcved;
    DWORD   dwFramesXmited;
    DWORD   dwFramesRcved;
    DWORD   dwCrcErr;
    DWORD   dwTimeoutErr;
    DWORD   dwAlignmentErr;
    DWORD   dwHardwareOverrunErr;
    DWORD   dwFramingErr;
    DWORD   dwBufferOverrunErr;
    DWORD   dwCompressionRatioIn;
    DWORD   dwCompressionRatioOut;
    DWORD   dwBps;
    DWORD   dwConnectDuration;

} RAS_STATS, *PRAS_STATS;


typedef DWORD (WINAPI *RasCustomHangUpFn) (
                            HRASCONN hRasConn
                            );

typedef DWORD (WINAPI *RasCustomDialFn) (
        HINSTANCE           hInstDll,
        LPRASDIALEXTENSIONS lpRasDialExtensions,
        LPCWSTR             lpszPhonebook,
        LPRASDIALPARAMS     lpRasDialParams,
        DWORD               dwNotifierType,
        LPVOID              lpvNotifier,
        LPHRASCONN          lphRasConn,
        DWORD               dwFlags
        );

typedef DWORD (WINAPI *RasCustomDeleteEntryNotifyFn) (
        LPCWSTR     lpszPhonebook,
        LPCWSTR     lpszEntry,
        DWORD       dwFlags );


#define RCD_SingleUser  0
#define RCD_AllUsers    0x00000001
#define RCD_Eap         0x00000002
#define RCD_Logon       0x00000004

DWORD APIENTRY RasInvokeEapUI( __in HRASCONN, __in DWORD, __in LPRASDIALEXTENSIONS, __in HWND);

DWORD APIENTRY RasGetLinkStatistics(__in HRASCONN hRasConn,
                                    __in DWORD dwSubEntry,
                                    __inout RAS_STATS *lpStatistics );

DWORD APIENTRY RasGetConnectionStatistics( __in HRASCONN hRasConn,
                                           __inout RAS_STATS *lpStatistics );

DWORD APIENTRY RasClearLinkStatistics(__in HRASCONN hRasConn,
                                      __in DWORD dwSubEntry);


DWORD APIENTRY RasClearConnectionStatistics( __in HRASCONN hRasConn );

DWORD APIENTRY RasGetEapUserDataA(
                   __in_opt HANDLE hToken,
                   __in_opt LPCSTR pszPhonebook,
                   __in LPCSTR pszEntry,
                   __out_opt BYTE   *pbEapData,
                   __inout DWORD *pdwSizeofEapData );


DWORD APIENTRY RasGetEapUserDataW(
                   __in_opt HANDLE  hToken,
                   __in_opt LPCWSTR pszPhonebook,
                   __in LPCWSTR pszEntry,
                   __out_opt BYTE    *pbEapData,
                   __inout DWORD *pdwSizeofEapData );

DWORD APIENTRY RasSetEapUserDataA(
                   __in_opt HANDLE hToken,
                   __in_opt LPCSTR pszPhonebook,
                   __in LPCSTR pszEntry,
                   __in BYTE   *pbEapData,
                   __in DWORD dwSizeofEapData );

DWORD APIENTRY RasSetEapUserDataW(
                   __in_opt HANDLE  hToken,
                   __in_opt LPCWSTR pszPhonebook,
                   __in LPCWSTR pszEntry,
                   __in BYTE    *pbEapData,
                   __in DWORD dwSizeofEapData );

DWORD APIENTRY RasGetCustomAuthDataA(
                   __in_opt LPCSTR pszPhonebook,
                   __in LPCSTR pszEntry,
                   __out_opt BYTE   *pbCustomAuthData,
                   __inout DWORD  *pdwSizeofCustomAuthData );


DWORD APIENTRY RasGetCustomAuthDataW(
                   __in_opt LPCWSTR pszPhonebook,
                   __in LPCWSTR pszEntry,
                   __out_opt BYTE    *pbCustomAuthData,
                   __inout DWORD   *pdwSizeofCustomAuthData );

DWORD APIENTRY RasSetCustomAuthDataA(
                   __in_opt LPCSTR pszPhonebook,
                   __in LPCSTR pszEntry,
                   __in BYTE   *pbCustomAuthData,
                   __in DWORD  dwSizeofCustomAuthData
                   );

DWORD APIENTRY RasSetCustomAuthDataW(
                   __in_opt LPCWSTR pszPhonebook,
                   __in LPCWSTR pszEntry,
                   __in BYTE    *pbCustomAuthData,
                   __in DWORD   dwSizeofCustomAuthData
                   );
DWORD APIENTRY RasGetEapUserIdentityW(
                   __in_opt LPCWSTR              pszPhonebook,
                   __in LPCWSTR                  pszEntry,
                   __in DWORD                    dwFlags,
                   __in HWND                     hwnd,
                   __out LPRASEAPUSERIDENTITYW*  ppRasEapUserIdentity
);
DWORD APIENTRY RasGetEapUserIdentityA(
                   __in_opt LPCSTR                   pszPhonebook,
                   __in LPCSTR                   pszEntry,
                   __in DWORD                    dwFlags,
                   __in HWND                     hwnd,
                   __out LPRASEAPUSERIDENTITYA*   ppRasEapUserIdentity
);
VOID APIENTRY RasFreeEapUserIdentityW(
                   __in LPRASEAPUSERIDENTITYW    pRasEapUserIdentity
);
VOID APIENTRY RasFreeEapUserIdentityA(
                   __in LPRASEAPUSERIDENTITYA    pRasEapUserIdentity
);
#endif

#if (WINVER >= 0x501)

DWORD APIENTRY  RasDeleteSubEntryA(
                __in_opt LPCSTR pszPhonebook,
                __in LPCSTR pszEntry,
                __in DWORD  dwSubentryId );

DWORD APIENTRY  RasDeleteSubEntryW(
                __in_opt LPCWSTR pszPhonebook,
                __in LPCWSTR pszEntry,
                __in DWORD   dwSubEntryId );


// To use Quarantine APIs, applications should explicitly 
// define USES_RAS_QUARANTINE_APIS.

#ifdef USES_RAS_QUARANTINE_APIS

DWORD APIENTRY
RasGetNapStatus(
        __in HRASCONN hRasconn,
        __out LPRASNAPSTATE pRasNapState);

#endif //USES_RAS_QUARANTINE_APIS

#endif

#if (WINVER >= 0x601)

/* Update an active RAS connection.Localendpoint if specified is used for performing 
/  mobike update.If not specified then dwIfIndex value is used for performing mobike.
/  (See RasUpdateConnection)
*/
#define RASUPDATECONN struct tagRASUPDATECONN
RASUPDATECONN
{
    RASAPIVERSION       version;
    DWORD               dwSize;
    DWORD 		dwFlags;
    DWORD               dwIfIndex;
    RASTUNNELENDPOINT   localEndPoint;
    RASTUNNELENDPOINT   remoteEndPoint;
};

#define LPRASUPDATECONN  RASUPDATECONN*

DWORD APIENTRY
RasUpdateConnection(
        __in HRASCONN        hrasconn,
        __in LPRASUPDATECONN lprasupdateconn);

/* Ras Projection information for PPP or IKEv2
*/
DWORD APIENTRY 
RasGetProjectionInfoEx( 
        __in HRASCONN              hrasconn, 
        __inout_opt PRAS_PROJECTION_INFO  pRasProjection,
        __inout LPDWORD               lpdwSize);

#endif

#ifdef UNICODE
#define RasDial                     RasDialW
#define RasEnumConnections          RasEnumConnectionsW
#define RasEnumEntries              RasEnumEntriesW
#define RasGetConnectStatus         RasGetConnectStatusW
#define RasGetErrorString           RasGetErrorStringW
#define RasHangUp                   RasHangUpW
#define RasGetProjectionInfo        RasGetProjectionInfoW
#define RasCreatePhonebookEntry     RasCreatePhonebookEntryW
#define RasEditPhonebookEntry       RasEditPhonebookEntryW
#define RasSetEntryDialParams       RasSetEntryDialParamsW
#define RasGetEntryDialParams       RasGetEntryDialParamsW
#define RasEnumDevices              RasEnumDevicesW
#define RasGetCountryInfo           RasGetCountryInfoW
#define RasGetEntryProperties       RasGetEntryPropertiesW
#define RasSetEntryProperties       RasSetEntryPropertiesW
#define RasRenameEntry              RasRenameEntryW
#define RasDeleteEntry              RasDeleteEntryW
#define RasValidateEntryName        RasValidateEntryNameW
#if (WINVER >= 0x401)
#define RasGetSubEntryHandle        RasGetSubEntryHandleW
#define RasConnectionNotification   RasConnectionNotificationW
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesW
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesW
#define RasGetCredentials           RasGetCredentialsW
#define RasSetCredentials           RasSetCredentialsW
#define RasGetAutodialAddress       RasGetAutodialAddressW
#define RasSetAutodialAddress       RasSetAutodialAddressW
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesW
#define RasGetAutodialEnable        RasGetAutodialEnableW
#define RasSetAutodialEnable        RasSetAutodialEnableW
#define RasGetAutodialParam         RasGetAutodialParamW
#define RasSetAutodialParam         RasSetAutodialParamW
#endif
#if (WINVER >= 0x500)
#define RasGetEapUserData           RasGetEapUserDataW
#define RasSetEapUserData           RasSetEapUserDataW
#define RasGetCustomAuthData        RasGetCustomAuthDataW
#define RasSetCustomAuthData        RasSetCustomAuthDataW
#define RasGetEapUserIdentity       RasGetEapUserIdentityW
#define RasFreeEapUserIdentity      RasFreeEapUserIdentityW
#endif
#if (WINVER >= 0x501)
#define RasDeleteSubEntry           RasDeleteSubEntryW
#endif
#else
#define RasDial                     RasDialA
#define RasEnumConnections          RasEnumConnectionsA
#define RasEnumEntries              RasEnumEntriesA
#define RasGetConnectStatus         RasGetConnectStatusA
#define RasGetErrorString           RasGetErrorStringA
#define RasHangUp                   RasHangUpA
#define RasGetProjectionInfo        RasGetProjectionInfoA
#define RasCreatePhonebookEntry     RasCreatePhonebookEntryA
#define RasEditPhonebookEntry       RasEditPhonebookEntryA
#define RasSetEntryDialParams       RasSetEntryDialParamsA
#define RasGetEntryDialParams       RasGetEntryDialParamsA
#define RasEnumDevices              RasEnumDevicesA
#define RasGetCountryInfo           RasGetCountryInfoA
#define RasGetEntryProperties       RasGetEntryPropertiesA
#define RasSetEntryProperties       RasSetEntryPropertiesA
#define RasRenameEntry              RasRenameEntryA
#define RasDeleteEntry              RasDeleteEntryA
#define RasValidateEntryName        RasValidateEntryNameA
#if (WINVER >= 0x401)
#define RasGetSubEntryHandle        RasGetSubEntryHandleA
#define RasConnectionNotification   RasConnectionNotificationA
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesA
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesA
#define RasGetCredentials           RasGetCredentialsA
#define RasSetCredentials           RasSetCredentialsA
#define RasGetAutodialAddress       RasGetAutodialAddressA
#define RasSetAutodialAddress       RasSetAutodialAddressA
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesA
#define RasGetAutodialEnable        RasGetAutodialEnableA
#define RasSetAutodialEnable        RasSetAutodialEnableA
#define RasGetAutodialParam         RasGetAutodialParamA
#define RasSetAutodialParam         RasSetAutodialParamA
#endif
#if (WINVER >= 0x500)
#define RasGetEapUserData           RasGetEapUserDataA
#define RasSetEapUserData           RasSetEapUserDataA
#define RasGetCustomAuthData        RasGetCustomAuthDataA
#define RasSetCustomAuthData        RasSetCustomAuthDataA
#define RasGetEapUserIdentity       RasGetEapUserIdentityA
#define RasFreeEapUserIdentity      RasFreeEapUserIdentityA
#endif
#if (WINVER >= 0x501)
#define RasDeleteSubEntry           RasDeleteSubEntryA
#endif
#endif

#pragma warning(pop)

#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif // _RAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Qossp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    qos.h - QoS definitions for NDIS components.

Abstract:

    This module defines the type of objects that can go into the 
    ProviderSpecific buffer in the QOS structure.

Revision History:

--*/

#ifndef __QOSSP_H_
#define __QOSSP_H_

#pragma once

/*
 * Definition of object Types
 *
 *
 * define the values for ObjectType above - RSVP Objects ids start at an 
 * offset from zero to allow for ATM objects that might be defined in the 
 * lower number range.
 */
#define   RSVP_OBJECT_ID_BASE         1000
#define   RSVP_OBJECT_STATUS_INFO     (0x00000000 + RSVP_OBJECT_ID_BASE)
          /* RSVP_STATUS_INFO structure passed */
#define   RSVP_OBJECT_RESERVE_INFO    (0x00000001 + RSVP_OBJECT_ID_BASE)
          /* RSVP_RESERVE_INFO structure passed */
#define   RSVP_OBJECT_ADSPEC          (0x00000002 + RSVP_OBJECT_ID_BASE)
          /* RSVP_ADSPEC structure passed */
#define   RSVP_OBJECT_POLICY_INFO     (0x00000003 + RSVP_OBJECT_ID_BASE)
          /* RSVP POLICY ELEMENT(S) retrieved */
#define   RSVP_OBJECT_FILTERSPEC_LIST (0x00000004 + RSVP_OBJECT_ID_BASE)
          /* RSVP SENDER LIST returned */


/* 
 * IPV4 addressing for RSVP FILTERSPECS
 */
typedef union _IN_ADDR_IPV4 {

    ULONG  Addr;
    UCHAR  AddrBytes[4];

} IN_ADDR_IPV4, *LPIN_ADDR_IPV4;

/*
 * IPV6 addressing for RSVP FILTERSPECS
 */
typedef struct _IN_ADDR_IPV6 {

    UCHAR  Addr[16];               //IPV6 address

} IN_ADDR_IPV6, *LPIN_ADDR_IPV6;

typedef const IN_ADDR_IPV6  *LPCIN_ADDR_IPV6;

/*
 * IPV4 addressing for RSVP FILTERSPECS
 */
typedef struct _RSVP_FILTERSPEC_V4 {

    IN_ADDR_IPV4    Address;
    USHORT          Unused;
    USHORT          Port;

} RSVP_FILTERSPEC_V4, *LPRSVP_FILTERSPEC_V4;

typedef struct _RSVP_FILTERSPEC_V6 {

    IN_ADDR_IPV6    Address;
    USHORT          UnUsed;
    USHORT          Port;

} RSVP_FILTERSPEC_V6, *LPRSVP_FILTERSPEC_V6;


typedef struct _RSVP_FILTERSPEC_V6_FLOW {

    IN_ADDR_IPV6    Address;
    UCHAR           UnUsed;
    UCHAR           FlowLabel[3];

} RSVP_FILTERSPEC_V6_FLOW, *LPRSVP_FILTERSPEC_V6_FLOW;

typedef struct _RSVP_FILTERSPEC_V4_GPI {

    IN_ADDR_IPV4    Address;
    ULONG           GeneralPortId;

} RSVP_FILTERSPEC_V4_GPI, *LPRSVP_FILTERSPEC_V4_GPI;

typedef struct _RSVP_FILTERSPEC_V6_GPI {

    IN_ADDR_IPV6    Address;
    ULONG           GeneralPortId;

} RSVP_FILTERSPEC_V6_GPI, *LPRSVP_FILTERSPEC_V6_GPI;


/*
 * FILTERSPEC TYPES used in making reservations.
 */
typedef enum {

        FILTERSPECV4 = 1,
        FILTERSPECV6,
        FILTERSPECV6_FLOW,
        FILTERSPECV4_GPI,
        FILTERSPECV6_GPI,
        FILTERSPEC_END

} FilterType;

typedef struct _RSVP_FILTERSPEC {

    FilterType   Type;

    union {
        RSVP_FILTERSPEC_V4      FilterSpecV4;
        RSVP_FILTERSPEC_V6      FilterSpecV6;
        RSVP_FILTERSPEC_V6_FLOW FilterSpecV6Flow;
        RSVP_FILTERSPEC_V4_GPI  FilterSpecV4Gpi;
        RSVP_FILTERSPEC_V6_GPI  FilterSpecV6Gpi;
    };

} RSVP_FILTERSPEC, *LPRSVP_FILTERSPEC;

/*
 * FLOWDESCRIPTOR Structure used for specifying one or more
 * Filters per Flowspec.
 */
typedef struct _FLOWDESCRIPTOR {

    FLOWSPEC            FlowSpec;
    ULONG               NumFilters;
    LPRSVP_FILTERSPEC   FilterList;

} FLOWDESCRIPTOR, *LPFLOWDESCRIPTOR;

/*
 * RSVP_POLICY contains undefined policy data.  RSVP transports this
 * data on behalf of the Policy Control component.
 */
typedef struct _RSVP_POLICY {
    USHORT  Len;         /* total length of this element object */
    USHORT  Type;
    UCHAR   Info[4];
} RSVP_POLICY, *LPRSVP_POLICY;

typedef const RSVP_POLICY *LPCRSVP_POLICY;
#define RSVP_POLICY_HDR_LEN    ( sizeof(USHORT) + sizeof(USHORT) )

/*
 * RSVP_POLICY_INFO contains undefined policy element(s) retrieved from RSVP.  
 */
typedef struct _RSVP_POLICY_INFO  {

    QOS_OBJECT_HDR     ObjectHdr;
    ULONG              NumPolicyElement;         /* count of the 
                                                  * number of policy elements */
    RSVP_POLICY        PolicyElement[1];         /* a list of the policy 
                                                  * elements retrieved */

} RSVP_POLICY_INFO, *LPRSVP_POLICY_INFO;

/*
 * RSVP_RESERVE_INFO Structure used for storing RSVP specific
 * information for fine tuning interaction via the Winsock2
 * Generic QoS API via the provider specific buffer. This structure
 * includes the QOS_OBJECT_HDR structure directly
 */

typedef struct _RSVP_RESERVE_INFO {

    QOS_OBJECT_HDR      ObjectHdr;            /* type and length of this object */
    ULONG               Style;                /* RSVP Style (FF,WF,SE) */
    ULONG               ConfirmRequest;       /* Non Zero for Confirm Request (receive only) */
    LPRSVP_POLICY_INFO  PolicyElementList;    /* Points to the set of policy elements */
    ULONG               NumFlowDesc;          /* Number of FlowDesc */
    LPFLOWDESCRIPTOR    FlowDescList;         /* Points to the FlowDesc list */

} RSVP_RESERVE_INFO, *LPRSVP_RESERVE_INFO;

typedef const RSVP_RESERVE_INFO *LPCRSVP_RESERVE_INFO;

/*
 * definitions for the ulStyle in the previous structure
 */
#define RSVP_DEFAULT_STYLE            0x00000000
#define RSVP_WILDCARD_STYLE           0x00000001
#define RSVP_FIXED_FILTER_STYLE       0x00000002
#define RSVP_SHARED_EXPLICIT_STYLE    0x00000003

/*
 * RSVP_STATUS_INFO Structure used for storing RSVP specific
 * error of status indications.  This also serves as a header
 * for additional objects in the provider specific buffer when
 * interacting via Winsock2 Generic QoS API. This structure includes
 * the QOS_OBJECT_COUNT and QOS_OBJECT_HDR structures directly It is
 * expected to be the first structure in the provider specific structure
 * since it includes the QOS_OBJECT_COUNT
 */

typedef struct _RSVP_STATUS_INFO {

    QOS_OBJECT_HDR      ObjectHdr;      /* Object Hdr */
    ULONG               StatusCode;     /* Error or Status Information see 
                                         * Winsock2.h */
    ULONG               ExtendedStatus1;/* Provider specific status extension */
    ULONG               ExtendedStatus2;/* Provider specific status extension */

} RSVP_STATUS_INFO, *LPRSVP_STATUS_INFO;

typedef const RSVP_STATUS_INFO *LPCRSVP_STATUS_INFO;


/*
 * QOS_DestAddr structure -- used for WSAIoctl(SIO_SET_QOS) when we
 * do not want to issue a connect for a sending socket.  The destination
 * address is required so we can generate the session information for
 * RSVP signalling.
*/

typedef struct _QOS_DESTADDR {
    QOS_OBJECT_HDR ObjectHdr;                     /* Object header */
    const struct sockaddr *  SocketAddress;       /* Destination socket address */
    ULONG                    SocketAddressLength; /* Length of the address structure */
} QOS_DESTADDR, *LPQOS_DESTADDR;

typedef const QOS_DESTADDR * LPCQOS_DESTADDR;



/*
 * this structure defines the "General Characterization Parameters" contained in
 * the RSVP Adspec object
 */
typedef struct _AD_GENERAL_PARAMS{

    ULONG       IntServAwareHopCount;   /* number of hops that conform to
                                         * Integrated Services requirements */
    ULONG       PathBandwidthEstimate;  /* minimum bandwidth available from 
                                         * sender to receiver */
    ULONG       MinimumLatency;         /* sum of minimum latency of the packet
                                         * forwarding process in routers 
                                         * (in usec)*/
    ULONG       PathMTU;                /* max transmission unit end to end that
                                         * will not incur fragmentation */
    ULONG       Flags;                  /* used to hold break bits.*/

} AD_GENERAL_PARAMS, *LPAD_GENERAL_PARAMS;

/*
 * Minimum Latency may be set to this "undefined" value
 */
#define INDETERMINATE_LATENCY   0xFFFFFFFF;

/*
 * This Flag is used to indicate the existence of a network element not 
 * supporting  QoS control services somewhere in the data path. If this bit 
 * is set in the specific service override then it indicates that that
 * service was not supported at at least one hop.
 */
#define AD_FLAG_BREAK_BIT    0x00000001

/*
 * this structure describes the Guaranteed service parameters
 */
typedef struct _AD_GUARANTEED {

    ULONG       CTotal;
    ULONG       DTotal;
    ULONG       CSum;
    ULONG       DSum;

} AD_GUARANTEED, *LPAD_GUARANTEED;

/*
 * this structure describes the format of the parameter buffer that can be
 * included in the Service_Type structure below.  This structure allows an
 * application to include any valid Int Serv service parameter in the Buffer 
 * value, after providing the Int Serv parameter id in the ParameterId field.
 */
typedef struct _PARAM_BUFFER {

    ULONG   ParameterId;    /* Int Server parameter ID */
    ULONG   Length;         /* total length of this structure 
                             * ( 8 bytes + length of Buffer ) */
    UCHAR   Buffer[1];      /* Paramter itself */

} PARAM_BUFFER, *LPPARAM_BUFFER;

/*
 * this structure contains the service types supported
 */
typedef struct _CONTROL_SERVICE {

    /*
     * the length of this entire structure including the following buffer.  
     * This length value can be added to the ptr to the structure to get the ptr
     * to the next SERVICE_TYPE structure in the list, until the
     * NumberOfServices count has been exhausted.
     */
    ULONG               Length;

    SERVICETYPE         Service;
    AD_GENERAL_PARAMS   Overrides;

    /*
     * service specific information ( controlled load has no service specific 
     * info here )
     */
    union {
        AD_GUARANTEED   Guaranteed;
        PARAM_BUFFER    ParamBuffer[1];     /* allows for other services down 
                                             * the road */
    };

} CONTROL_SERVICE, *LPCONTROL_SERVICE;

/*
 * This structure defines the information which is carried in the Rsvp 
 * Adspec.  This Rsvp object typically indicates which service types are 
 * available ( Controlled Load and/or Guaranteed Service ), if a non-Rsvp
 * hop has been encountered by the Path message, and the minumum MTU along 
 * the path. The services array indicates which services are supported
 */
typedef struct _RSVP_ADSPEC  {

    QOS_OBJECT_HDR     ObjectHdr;
    AD_GENERAL_PARAMS  GeneralParams;      /* contains the general 
                                            * characterization paramters */
    ULONG              NumberOfServices;   /* count of the number of services */
    CONTROL_SERVICE    Services[1];        /* a list of the services 
                                            * supported/requested */

} RSVP_ADSPEC, *LPRSVP_ADSPEC;


//
// Opcode for the SIO_CHK_QOS ioctl
// (specific for the Microsoft QOS Service Provider
//
// Bascially:
//
// SIO_CHK_QOS = _WSAIORW(IOC_VENDOR,1)
//             = mIOC_IN | mIOC_OUT | mIOC_VENDOR | mCOMPANY | ioctl_code
//    where
//         mIOC_IN     = 0x80000000
//         mIOC_OUT    = 0x40000000
//         mIOC_VENDOR = 0x04000000
//         mCOMPANY    = 0x18000000
//         ioctl_code  = 0x00000001
//         
// See WSAIoctl man page for details.
//

#define    mIOC_IN       0x80000000
#define    mIOC_OUT      0x40000000
#define    mIOC_VENDOR   0x04000000
#define    mCOMPANY      0x18000000
#define    ioctl_code    0x00000001

#define SIO_CHK_QOS   (mIOC_IN | mIOC_OUT | mIOC_VENDOR | mCOMPANY | ioctl_code)

//
// The following may be specified in the input buffer 
// of the SIO_CHK_IOCTL ioctl call 
//

#define QOSSPBASE           50000

#define ALLOWED_TO_SEND_DATA  (QOSSPBASE+1)     // query the SBM/BEST_EFFORT limit 
                                                //   -- result is based on a comparison between
                                                //      the user-specified token rate and the
                                                //      SBM/BEST_EFFORT bandwidth parameters in
                                                //      the system
                                                //   -- result is a YES(1) or NO(0) answer
                                                //      in the output buffer 

#define ABLE_TO_RECV_RSVP     (QOSSPBASE+2)     // query the SBM/BEST_EFFORT limit 
                                                //   -- result is based on a comparison between
                                                //      the user-specified token rate and the
                                                //      SBM/BEST_EFFORT bandwidth parameters in
                                                //      the system
                                                //   -- result is a YES(1) or NO(0) answer
                                                //      in the output buffer 

#define LINE_RATE             (QOSSPBASE+3)     // query the interface capacity 
                                                //   -- result returned in the output buffer
                                                //      in kilo-bits per second

#define LOCAL_TRAFFIC_CONTROL (QOSSPBASE+4)     // check if Kernel Traffic Control is available or not
                                                //   -- 0 if not available
                                                //   -- 1 if avaiable
                                                //   -- INFO_NOT_AVAILABLE if there is no way to check

#define LOCAL_QOSABILITY      (QOSSPBASE+5)     // The followings are for 
                                                // the Discovery of Local QOSability
                                                //   -- 0 if no local QOS support
                                                //   -- 1 if local QOS support available
                                                //   -- INFO_NOT_AVAILABLE if there is no way to check

#define END_TO_END_QOSABILITY (QOSSPBASE+6)     // The followings are for 
                                                // the Discovery of End-to-End QOSability
                                                //   -- 0 if no end-to-end QOS support
                                                //   -- 1 if end-to-end QOS support available
                                                //   -- INFO_NOT_AVAILABLE if there is no way to check

#define INFO_NOT_AVAILABLE  0xFFFFFFFF          // used when LINE_RATE is not known


#define ANY_DEST_ADDR       0xFFFFFFFF          // for QOS_OBJECT_DEST_ADDR


// The followings are for Guaranteed_Service+Latency -> ISSLOW_Traffic_Class Mapping

#define MODERATELY_DELAY_SENSITIVE   0xFFFFFFFD  

#define HIGHLY_DELAY_SENSITIVE       0xFFFFFFFE

//
// QOSSP Error Code/Value
//

#define QOSSP_ERR_BASE                                 (QOSSPBASE+6000)

// No error
#define GQOS_NO_ERRORCODE                              (0)

#define GQOS_NO_ERRORVALUE                             (0)

// Unknown error
#define GQOS_ERRORCODE_UNKNOWN                         (0xFFFFFFFF)

#define GQOS_ERRORVALUE_UNKNOWN                        (0xFFFFFFFF)

// Admission (Resource) Error
#define GQOS_NET_ADMISSION                             (QOSSP_ERR_BASE+100)

#define GQOS_OTHER                                     (QOSSP_ERR_BASE+100+1)
#define GQOS_DELAYBND                                  (QOSSP_ERR_BASE+100+2)
#define GQOS_BANDWIDTH                                 (QOSSP_ERR_BASE+100+3)
#define GQOS_MTU                                       (QOSSP_ERR_BASE+100+4)
#define GQOS_FLOW_RATE                                 (QOSSP_ERR_BASE+100+5)
#define GQOS_PEAK_RATE                                 (QOSSP_ERR_BASE+100+6)
#define GQOS_AGG_PEAK_RATE                             (QOSSP_ERR_BASE+100+7)

// Policy Error
#define GQOS_NET_POLICY                                (QOSSP_ERR_BASE+200)

#define GQOS_POLICY_ERROR_UNKNOWN                      (QOSSP_ERR_BASE+200+0)

#define GQOS_POLICY_GLOBAL_DEF_FLOW_COUNT              (QOSSP_ERR_BASE+200+1)
#define GQOS_POLICY_GLOBAL_GRP_FLOW_COUNT              (QOSSP_ERR_BASE+200+2)
#define GQOS_POLICY_GLOBAL_USER_FLOW_COUNT             (QOSSP_ERR_BASE+200+3)
#define GQOS_POLICY_GLOBAL_UNK_USER_FLOW_COUNT         (QOSSP_ERR_BASE+200+4)
#define GQOS_POLICY_SUBNET_DEF_FLOW_COUNT              (QOSSP_ERR_BASE+200+5)
#define GQOS_POLICY_SUBNET_GRP_FLOW_COUNT              (QOSSP_ERR_BASE+200+6)
#define GQOS_POLICY_SUBNET_USER_FLOW_COUNT             (QOSSP_ERR_BASE+200+7)
#define GQOS_POLICY_SUBNET_UNK_USER_FLOW_COUNT         (QOSSP_ERR_BASE+200+8)

#define GQOS_POLICY_GLOBAL_DEF_FLOW_DURATION           (QOSSP_ERR_BASE+200+9)
#define GQOS_POLICY_GLOBAL_GRP_FLOW_DURATION           (QOSSP_ERR_BASE+200+10)
#define GQOS_POLICY_GLOBAL_USER_FLOW_DURATION          (QOSSP_ERR_BASE+200+11)
#define GQOS_POLICY_GLOBAL_UNK_USER_FLOW_DURATION      (QOSSP_ERR_BASE+200+12)
#define GQOS_POLICY_SUBNET_DEF_FLOW_DURATION           (QOSSP_ERR_BASE+200+13)
#define GQOS_POLICY_SUBNET_GRP_FLOW_DURATION           (QOSSP_ERR_BASE+200+14) 
#define GQOS_POLICY_SUBNET_USER_FLOW_DURATION          (QOSSP_ERR_BASE+200+15)
#define GQOS_POLICY_SUBNET_UNK_USER_FLOW_DURATION      (QOSSP_ERR_BASE+200+16)

#define GQOS_POLICY_GLOBAL_DEF_FLOW_RATE               (QOSSP_ERR_BASE+200+17)
#define GQOS_POLICY_GLOBAL_GRP_FLOW_RATE               (QOSSP_ERR_BASE+200+18)
#define GQOS_POLICY_GLOBAL_USER_FLOW_RATE              (QOSSP_ERR_BASE+200+19)
#define GQOS_POLICY_GLOBAL_UNK_USER_FLOW_RATE          (QOSSP_ERR_BASE+200+20)
#define GQOS_POLICY_SUBNET_DEF_FLOW_RATE               (QOSSP_ERR_BASE+200+21)
#define GQOS_POLICY_SUBNET_GRP_FLOW_RATE               (QOSSP_ERR_BASE+200+22)
#define GQOS_POLICY_SUBNET_USER_FLOW_RATE              (QOSSP_ERR_BASE+200+23)
#define GQOS_POLICY_SUBNET_UNK_USER_FLOW_RATE          (QOSSP_ERR_BASE+200+24)

#define GQOS_POLICY_GLOBAL_DEF_PEAK_RATE               (QOSSP_ERR_BASE+200+25)
#define GQOS_POLICY_GLOBAL_GRP_PEAK_RATE               (QOSSP_ERR_BASE+200+26)
#define GQOS_POLICY_GLOBAL_USER_PEAK_RATE              (QOSSP_ERR_BASE+200+27)
#define GQOS_POLICY_GLOBAL_UNK_USER_PEAK_RATE          (QOSSP_ERR_BASE+200+28)
#define GQOS_POLICY_SUBNET_DEF_PEAK_RATE               (QOSSP_ERR_BASE+200+29)
#define GQOS_POLICY_SUBNET_GRP_PEAK_RATE               (QOSSP_ERR_BASE+200+30)
#define GQOS_POLICY_SUBNET_USER_PEAK_RATE              (QOSSP_ERR_BASE+200+31)
#define GQOS_POLICY_SUBNET_UNK_USER_PEAK_RATE          (QOSSP_ERR_BASE+200+32)

#define GQOS_POLICY_GLOBAL_DEF_SUM_FLOW_RATE           (QOSSP_ERR_BASE+200+33)
#define GQOS_POLICY_GLOBAL_GRP_SUM_FLOW_RATE           (QOSSP_ERR_BASE+200+34)
#define GQOS_POLICY_GLOBAL_USER_SUM_FLOW_RATE          (QOSSP_ERR_BASE+200+35)
#define GQOS_POLICY_GLOBAL_UNK_USER_SUM_FLOW_RATE      (QOSSP_ERR_BASE+200+36)
#define GQOS_POLICY_SUBNET_DEF_SUM_FLOW_RATE           (QOSSP_ERR_BASE+200+37)
#define GQOS_POLICY_SUBNET_GRP_SUM_FLOW_RATE           (QOSSP_ERR_BASE+200+38)
#define GQOS_POLICY_SUBNET_USER_SUM_FLOW_RATE          (QOSSP_ERR_BASE+200+39)
#define GQOS_POLICY_SUBNET_UNK_USER_SUM_FLOW_RATE      (QOSSP_ERR_BASE+200+40)

#define GQOS_POLICY_GLOBAL_DEF_SUM_PEAK_RATE           (QOSSP_ERR_BASE+200+41)
#define GQOS_POLICY_GLOBAL_GRP_SUM_PEAK_RATE           (QOSSP_ERR_BASE+200+42)
#define GQOS_POLICY_GLOBAL_USER_SUM_PEAK_RATE          (QOSSP_ERR_BASE+200+43)
#define GQOS_POLICY_GLOBAL_UNK_USER_SUM_PEAK_RATE      (QOSSP_ERR_BASE+200+44)
#define GQOS_POLICY_SUBNET_DEF_SUM_PEAK_RATE           (QOSSP_ERR_BASE+200+45)
#define GQOS_POLICY_SUBNET_GRP_SUM_PEAK_RATE           (QOSSP_ERR_BASE+200+46)
#define GQOS_POLICY_SUBNET_USER_SUM_PEAK_RATE          (QOSSP_ERR_BASE+200+47)
#define GQOS_POLICY_SUBNET_UNK_USER_SUM_PEAK_RATE      (QOSSP_ERR_BASE+200+48)

#define GQOS_POLICY_UNKNOWN_USER                       (QOSSP_ERR_BASE+200+49)
#define GQOS_POLICY_NO_PRIVILEGES                      (QOSSP_ERR_BASE+200+50)
#define GQOS_POLICY_EXPIRED_USER_TOKEN                 (QOSSP_ERR_BASE+200+51)
#define GQOS_POLICY_NO_RESOURCES                       (QOSSP_ERR_BASE+200+52)
#define GQOS_POLICY_PRE_EMPTED                         (QOSSP_ERR_BASE+200+53)
#define GQOS_POLICY_USER_CHANGED                       (QOSSP_ERR_BASE+200+54)
#define GQOS_POLICY_NO_ACCEPTS                         (QOSSP_ERR_BASE+200+55)
#define GQOS_POLICY_NO_MEMORY                          (QOSSP_ERR_BASE+200+56)
#define GQOS_POLICY_CRAZY_FLOWSPEC                     (QOSSP_ERR_BASE+200+57)

#define GQOS_POLICY_NO_MORE_INFO                       (QOSSP_ERR_BASE+200+58)
#define GQOS_POLICY_UNSUPPORTED_CREDENTIAL_TYPE        (QOSSP_ERR_BASE+200+59)
#define GQOS_POLICY_INSUFFICIENT_PRIVILEGES            (QOSSP_ERR_BASE+200+60)
#define GQOS_POLICY_EXPIRED_CREDENTIAL                 (QOSSP_ERR_BASE+200+61)
#define GQOS_POLICY_IDENTITY_CHANGED                   (QOSSP_ERR_BASE+200+62)
#define GQOS_POLICY_NO_QOS_PROVIDED                    (QOSSP_ERR_BASE+200+63)
#define GQOS_POLICY_DO_NOT_SEND                        (QOSSP_ERR_BASE+200+64)

#define GQOS_POLICY_ERROR_USERID                       (QOSSP_ERR_BASE+200+99)

// RSVP Error
#define GQOS_RSVP                                      (QOSSP_ERR_BASE+300)

#define GQOS_NO_PATH                                   (QOSSP_ERR_BASE+300+1)
#define GQOS_NO_SENDER                                 (QOSSP_ERR_BASE+300+2)
#define GQOS_BAD_STYLE                                 (QOSSP_ERR_BASE+300+3)
#define GQOS_UNKNOWN_STYLE                             (QOSSP_ERR_BASE+300+4)
#define GQOS_BAD_DSTPORT                               (QOSSP_ERR_BASE+300+5) 
#define GQOS_BAD_SNDPORT                               (QOSSP_ERR_BASE+300+6)
#define GQOS_AMBIG_FILTER                              (QOSSP_ERR_BASE+300+7)
#define GQOS_PREEMPTED                                 (QOSSP_ERR_BASE+300+8)
#define GQOS_UNKN_OBJ_CLASS                            (QOSSP_ERR_BASE+300+9)
#define GQOS_UNKNOWN_CTYPE                             (QOSSP_ERR_BASE+300+10)
#define GQOS_INVALID                                   (QOSSP_ERR_BASE+300+11)

// API Error
#define GQOS_API                                       (QOSSP_ERR_BASE+400)

#define GQOS_API_BADSEND                               (QOSSP_ERR_BASE+400+1) /* Sender addr not my interface */
#define GQOS_API_BADRECV                               (QOSSP_ERR_BASE+400+2) /* Recv addr not my interface */
#define GQOS_API_BADSPORT                              (QOSSP_ERR_BASE+400+3) /* Sport !=0 but Dport == 0 */

// TC System Error
#define GQOS_KERNEL_TC_SYS                             (QOSSP_ERR_BASE+500)

#define GQOS_TC_GENERIC                                (QOSSP_ERR_BASE+500+1)
#define GQOS_TC_INVALID                                (QOSSP_ERR_BASE+500+2)
#define GQOS_NO_MEMORY                                 (QOSSP_ERR_BASE+500+3)
#define GQOS_BAD_ADDRESSTYPE                           (QOSSP_ERR_BASE+500+4) 
#define GQOS_BAD_DUPLICATE                             (QOSSP_ERR_BASE+500+5)
#define GQOS_CONFLICT                                  (QOSSP_ERR_BASE+500+6)
#define GQOS_NOTREADY                                  (QOSSP_ERR_BASE+500+7)
#define GQOS_WOULDBLOCK                                (QOSSP_ERR_BASE+500+8)
#define GQOS_INCOMPATIBLE                              (QOSSP_ERR_BASE+500+9)
#define GQOS_BAD_SDMODE                                (QOSSP_ERR_BASE+500+10)
#define GQOS_BAD_QOSPRIORITY                           (QOSSP_ERR_BASE+500+11)
#define GQOS_BAD_TRAFFICCLASS                          (QOSSP_ERR_BASE+500+12)
#define GQOS_NO_SYS_RESOURCES                          (QOSSP_ERR_BASE+500+13)

// RSVP System Error
#define GQOS_RSVP_SYS                                  (QOSSP_ERR_BASE+600)

#define GQOS_OTHER_SYS                                 (QOSSP_ERR_BASE+600+1)
#define GQOS_MEMORY_SYS                                (QOSSP_ERR_BASE+600+2)
#define GQOS_API_SYS                                   (QOSSP_ERR_BASE+600+3)
#define GQOS_SETQOS_NO_LOCAL_APPS                      (QOSSP_ERR_BASE+600+4)

// TC Error
#define GQOS_KERNEL_TC                                 (QOSSP_ERR_BASE+700)

#define GQOS_CONFLICT_SERV                             (QOSSP_ERR_BASE+700+1)
#define GQOS_NO_SERV                                   (QOSSP_ERR_BASE+700+2)
#define GQOS_BAD_FLOWSPEC                              (QOSSP_ERR_BASE+700+3)
#define GQOS_BAD_TSPEC                                 (QOSSP_ERR_BASE+700+4)
#define GQOS_BAD_ADSPEC                                (QOSSP_ERR_BASE+700+5)

// GQOS API ERRORS

// WSAIoctl Error

#define GQOS_IOCTL_SYSTEMFAILURE                       (QOSSP_ERR_BASE+800+1)
#define GQOS_IOCTL_NOBYTESRETURNED                     (QOSSP_ERR_BASE+800+2)
#define GQOS_IOCTL_INVALIDSOCKET                       (QOSSP_ERR_BASE+800+3)
#define GQOS_IOCTL_INV_FUNCPTR                         (QOSSP_ERR_BASE+800+4)
#define GQOS_IOCTL_INV_OVERLAPPED                      (QOSSP_ERR_BASE+800+5)

// SIO_SET_QOS error

#define GQOS_SETQOS_BADINBUFFER                        (QOSSP_ERR_BASE+810+1)
#define GQOS_SETQOS_BADFLOWSPEC                        (QOSSP_ERR_BASE+810+2)
#define GQOS_SETQOS_COLLISION                          (QOSSP_ERR_BASE+810+3)
#define GQOS_SETQOS_BADPROVSPECBUF                     (QOSSP_ERR_BASE+810+4)
#define GQOS_SETQOS_ILLEGALOP                          (QOSSP_ERR_BASE+810+5)
#define GQOS_SETQOS_INVALIDADDRESS                     (QOSSP_ERR_BASE+810+6)
#define GQOS_SETQOS_OUTOFMEMORY                        (QOSSP_ERR_BASE+810+7)
#define GQOS_SETQOS_EXCEPTION                          (QOSSP_ERR_BASE+810+8)
#define GQOS_SETQOS_BADADDRLEN                         (QOSSP_ERR_BASE+810+9)
#define GQOS_SETQOS_NOSOCKNAME                         (QOSSP_ERR_BASE+810+10)
#define GQOS_SETQOS_IPTOSFAIL                          (QOSSP_ERR_BASE+810+11)
#define GQOS_SETQOS_OPENSESSIONFAIL                    (QOSSP_ERR_BASE+810+12)
#define GQOS_SETQOS_SENDFAIL                           (QOSSP_ERR_BASE+810+13)
#define GQOS_SETQOS_RECVFAIL                           (QOSSP_ERR_BASE+810+14)
#define GQOS_SETQOS_BADPOLICYOBJECT                    (QOSSP_ERR_BASE+810+15)
#define GQOS_SETQOS_UNKNOWNFILTEROBJ                   (QOSSP_ERR_BASE+810+16)
#define GQOS_SETQOS_BADFILTERTYPE                      (QOSSP_ERR_BASE+810+17)
#define GQOS_SETQOS_BADFILTERCOUNT                     (QOSSP_ERR_BASE+810+18)
#define GQOS_SETQOS_BADOBJLENGTH                       (QOSSP_ERR_BASE+810+19)
#define GQOS_SETQOS_BADFLOWCOUNT                       (QOSSP_ERR_BASE+810+20)
#define GQOS_SETQOS_UNKNOWNPSOBJ                       (QOSSP_ERR_BASE+810+21)
#define GQOS_SETQOS_BADPOLICYOBJ                       (QOSSP_ERR_BASE+810+22)
#define GQOS_SETQOS_BADFLOWDESC                        (QOSSP_ERR_BASE+810+23)
#define GQOS_SETQOS_BADPROVSPECOBJ                     (QOSSP_ERR_BASE+810+24)
#define GQOS_SETQOS_NOLOOPBACK                         (QOSSP_ERR_BASE+810+25)
#define GQOS_SETQOS_MODENOTSUPPORTED                   (QOSSP_ERR_BASE+810+26)
#define GQOS_SETQOS_MISSINGFLOWDESC                    (QOSSP_ERR_BASE+810+27)

// SIO_GET_QOS error

#define GQOS_GETQOS_BADOUTBUFFER                       (QOSSP_ERR_BASE+840+1)
#define GQOS_GETQOS_SYSTEMFAILURE                      (QOSSP_ERR_BASE+840+2)
#define GQOS_GETQOS_EXCEPTION                          (QOSSP_ERR_BASE+840+3)
#define GQOS_GETQOS_INTERNALFAILURE                    (QOSSP_ERR_BASE+840+4)

// SIO_CHK_QOS error

#define GQOS_CHKQOS_BADINBUFFER                        (QOSSP_ERR_BASE+850+1)
#define GQOS_CHKQOS_BADOUTBUFFER                       (QOSSP_ERR_BASE+850+2)
#define GQOS_CHKQOS_SYSTEMFAILURE                      (QOSSP_ERR_BASE+850+3)
#define GQOS_CHKQOS_INTERNALFAILURE                    (QOSSP_ERR_BASE+850+4)
#define GQOS_CHKQOS_BADPARAMETER                       (QOSSP_ERR_BASE+850+5)
#define GQOS_CHKQOS_EXCEPTION                          (QOSSP_ERR_BASE+850+6)

#endif  /* __QOSSP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RasError.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    raserror.h

Abstract:

    RAS specific error codes
    
--*/

#ifndef _RASERROR_H_
#define _RASERROR_H_

#if _MSC_VER > 1000
#pragma once
#endif

#define RASBASE 600
#define SUCCESS 0


#define PENDING                              (RASBASE+0)
/*
 * An operation is pending.%0
 */

#define ERROR_INVALID_PORT_HANDLE            (RASBASE+1)
/*
 * An invalid port handle was detected.%0
 */

#define ERROR_PORT_ALREADY_OPEN              (RASBASE+2)
/*
 * The specified port is already open.%0
 */

#define ERROR_BUFFER_TOO_SMALL               (RASBASE+3)
/*
 * The caller's buffer is too small.%0
 */

#define ERROR_WRONG_INFO_SPECIFIED           (RASBASE+4)
/*
 * Incorrect information was specified.%0
 */

#if (WINVER < 0x600)
//
// The port information cannot be set.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_CANNOT_SET_PORT_INFO           (RASBASE+5)
/*
 * %0
 */
#endif

#define ERROR_PORT_NOT_CONNECTED             (RASBASE+6)
/*
 * The specified port is not connected.%0
 */

#if (WINVER < 0x600)
//
// An invalid event was detected.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_EVENT_INVALID                  (RASBASE+7)
/*
 * %0
 */
#endif

#define ERROR_DEVICE_DOES_NOT_EXIST          (RASBASE+8)
/*
 * A device was specified that does not exist.%0
 */

#define ERROR_DEVICETYPE_DOES_NOT_EXIST      (RASBASE+9)
/*
 * A device type was specified that does not exist.%0
 */

#define ERROR_BUFFER_INVALID                 (RASBASE+10)
/*
 * An invalid buffer was specified.%0
 */

#if (WINVER < 0x600)
//
// A route was specified that is not available.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_ROUTE_NOT_AVAILABLE            (RASBASE+11)
/*
 * %0
 */
#endif

#define ERROR_ROUTE_NOT_ALLOCATED            (RASBASE+12)
/*
 * A route was specified that is not allocated.%0
 */

#if (WINVER < 0x600)
//
// An invalid compression was specified.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_INVALID_COMPRESSION_SPECIFIED  (RASBASE+13)
/*
 * %0
 */

//
// There were insufficient buffers available.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_OUT_OF_BUFFERS                 (RASBASE+14)
/*
 * %0
 */
#endif

#define ERROR_PORT_NOT_FOUND                 (RASBASE+15)
/*
 * The specified port was not found.%0
 */ 

#define ERROR_ASYNC_REQUEST_PENDING          (RASBASE+16)
/*
 * An asynchronous request is pending.%0
 */

#define ERROR_ALREADY_DISCONNECTING          (RASBASE+17)
/*
 * The modem (or other connecting device) is already disconnecting.%0
 */

#define ERROR_PORT_NOT_OPEN                  (RASBASE+18)
/*
 * The specified port is not open.%0
 */ 

#define ERROR_PORT_DISCONNECTED              (RASBASE+19)
/*
 * A connection to the remote computer could not be established, so the port used for this connection was closed.%0
 */

#if (WINVER < 0x600)
//
//  No endpoints could be determined.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_NO_ENDPOINTS                   (RASBASE+20)
/*
 * %0
 */
#endif

#define ERROR_CANNOT_OPEN_PHONEBOOK          (RASBASE+21)
/*
 * The system could not open the phone book file.%0
 */ 

#define ERROR_CANNOT_LOAD_PHONEBOOK          (RASBASE+22)
/*
 * The system could not load the phone book file.%0
 */

#define ERROR_CANNOT_FIND_PHONEBOOK_ENTRY    (RASBASE+23)
/*
 * The system could not find the phone book entry for this connection.%0
 */

#define ERROR_CANNOT_WRITE_PHONEBOOK         (RASBASE+24)
/*
 * The system could not update the phone book file.%0
 */

#define ERROR_CORRUPT_PHONEBOOK              (RASBASE+25)
/*
 * The system found invalid information in the phone book file.%0
 */

#if (WINVER < 0x600)
//
// A string could not be loaded.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_CANNOT_LOAD_STRING             (RASBASE+26)
/*
 * %0
 */
#endif

#define ERROR_KEY_NOT_FOUND                  (RASBASE+27)
/*
 * A key could not be found.%0
 */

#define ERROR_DISCONNECTION                  (RASBASE+28)
/*
 * The connection was terminated by the remote computer before it could be completed.%0
 */ 

#define ERROR_REMOTE_DISCONNECTION           (RASBASE+29)
/*
 * The connection was closed by the remote computer.%0
 */

#define ERROR_HARDWARE_FAILURE               (RASBASE+30)
/*
 * The modem (or other connecting device) was disconnected due to hardware failure.%0
 */

#define ERROR_USER_DISCONNECTION             (RASBASE+31)
/*
 * The user disconnected the modem (or other connecting device).%0
 */

#define ERROR_INVALID_SIZE                   (RASBASE+32)
/*
 * An incorrect structure size was detected.%0
 */

#define ERROR_PORT_NOT_AVAILABLE             (RASBASE+33)
/*
 * The modem (or other connecting device) is already in use or is not configured properly.%0 
 */

#if (WINVER < 0x600)
//
// Your computer could not be registered on the remote network.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_CANNOT_PROJECT_CLIENT          (RASBASE+34)
/*
 * %0
 */
#endif

#define ERROR_UNKNOWN                        (RASBASE+35)
/*
 * There was an unknown error.%0
 */

#define ERROR_WRONG_DEVICE_ATTACHED          (RASBASE+36)
/*
 * The device attached to the port is not the one expected.%0
 */

#if (WINVER < 0x600)
//
// A string was detected that could not be converted.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_BAD_STRING                     (RASBASE+37)
/*
 * %0
 */
#endif

#define ERROR_REQUEST_TIMEOUT                (RASBASE+38)
/*
 * The remote server is not responding in a timely fashion.%0
 */

#if (WINVER < 0x600)
//
// No asynchronous net is available.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_CANNOT_GET_LANA                (RASBASE+39)
/*
 * %0
 */

//
// An error has occurred involving NetBIOS.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_NETBIOS_ERROR                  (RASBASE+40)
/*
 * %0
 */

//
// The server cannot allocate NetBIOS resources needed to support the client.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_SERVER_OUT_OF_RESOURCES        (RASBASE+41)
/*
 * %0
 */

//
// One of your computer's NetBIOS names is already registered on the remote network.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_NAME_EXISTS_ON_NET             (RASBASE+42)
/*
 * %0
 */

//
// A network adapter at the server failed.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_SERVER_GENERAL_NET_FAILURE     (RASBASE+43)
/*
 * %0
 */

//
// You will not receive network message popups.
//
// This error was obsoleted in the Windows Vista  release.
//
#define WARNING_MSG_ALIAS_NOT_ADDED          (RASBASE+44)
/*
 * %0
 */
#endif

#define ERROR_AUTH_INTERNAL                  (RASBASE+45)
/*
 * There was an internal authentication error.%0
 */

#define ERROR_RESTRICTED_LOGON_HOURS         (RASBASE+46)
/*
 * The account is not permitted to log on at this time of day.%0
 */

#define ERROR_ACCT_DISABLED                  (RASBASE+47)
/*
 * The account is disabled.%0
 */

#define ERROR_PASSWD_EXPIRED                 (RASBASE+48)
/*
 * The password for this account has expired.%0
 */

#define ERROR_NO_DIALIN_PERMISSION           (RASBASE+49)
/*
 * The account does not have permission to dial in.%0
 */

#if (WINVER < 0x600)
//
// The remote access server is not responding.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_SERVER_NOT_RESPONDING          (RASBASE+50)
/*
 * %0
 */
#endif

#define ERROR_FROM_DEVICE                    (RASBASE+51)
/*
 * The modem (or other connecting device) has reported an error.%0
 */

#define ERROR_UNRECOGNIZED_RESPONSE          (RASBASE+52)
/*
 * There was an unrecognized response from the modem (or other connecting device).%0
 */

#define ERROR_MACRO_NOT_FOUND                (RASBASE+53)
/*
 * A macro required by the modem (or other connecting device) was not found in the device.INF file.%0
 */

#define ERROR_MACRO_NOT_DEFINED              (RASBASE+54)
/*
 * A command or response in the device.INF file section refers to an undefined macro.%0
 */

#define ERROR_MESSAGE_MACRO_NOT_FOUND        (RASBASE+55)
/*
 * The <message> macro was not found in the device.INF file section.%0
 */

#define ERROR_DEFAULTOFF_MACRO_NOT_FOUND     (RASBASE+56)
/*
 * The <defaultoff> macro in the device.INF file section contains an undefined macro.%0
 */

#define ERROR_FILE_COULD_NOT_BE_OPENED       (RASBASE+57)
/*
 * The device.INF file could not be opened.%0
 */

#define ERROR_DEVICENAME_TOO_LONG            (RASBASE+58)
/*
 * The device name in the device.INF or media.INI file is too long.%0
 */

#define ERROR_DEVICENAME_NOT_FOUND           (RASBASE+59)
/*
 * The media.INI file refers to an unknown device name.%0
 */

#define ERROR_NO_RESPONSES                   (RASBASE+60)
/*
 * The device.INF file contains no responses for the command.%0
 */

#define ERROR_NO_COMMAND_FOUND               (RASBASE+61)
/*
 * The device.INF file is missing a command.%0
 */

#define ERROR_WRONG_KEY_SPECIFIED            (RASBASE+62)
/*
 * There was an attempt to set a macro not listed in device.INF file section.%0
 */

#define ERROR_UNKNOWN_DEVICE_TYPE            (RASBASE+63)
/*
 * The media.INI file refers to an unknown device type.%0
 */

#define ERROR_ALLOCATING_MEMORY              (RASBASE+64)
/*
 * The system has run out of memory.%0
 */

#define ERROR_PORT_NOT_CONFIGURED            (RASBASE+65)
/*
 * The modem (or other connecting device) is not properly configured.%0
 */

#define ERROR_DEVICE_NOT_READY               (RASBASE+66)
/*
 * The modem (or other connecting device) is not functioning.%0
 */

#define ERROR_READING_INI_FILE               (RASBASE+67)
/*
 * The system was unable to read the media.INI file.%0
 */

#define ERROR_NO_CONNECTION                  (RASBASE+68)
/*
 * The connection was terminated.%0
 */

#define ERROR_BAD_USAGE_IN_INI_FILE          (RASBASE+69)
/*
 * The usage parameter in the media.INI file is invalid.%0
 */

#define ERROR_READING_SECTIONNAME            (RASBASE+70)
/*
 * The system was unable to read the section name from the media.INI file.%0
 */

#define ERROR_READING_DEVICETYPE             (RASBASE+71)
/*
 * The system was unable to read the device type from the media.INI file.%0
 */

#define ERROR_READING_DEVICENAME             (RASBASE+72)
/*
 * The system was unable to read the device name from the media.INI file.%0
 */

#define ERROR_READING_USAGE                  (RASBASE+73)
/*
 * The system was unable to read the usage from the media.INI file.%0
 */

#if (WINVER < 0x600)
//
// The system was unable to read the maximum connection BPS rate from the media.INI file.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_READING_MAXCONNECTBPS          (RASBASE+74)
/*
 * %0
 */

//
// The system was unable to read the maximum carrier connection speed from the media.INI file.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_READING_MAXCARRIERBPS          (RASBASE+75)
/*
 * %0
 */
#endif

#define ERROR_LINE_BUSY                      (RASBASE+76)
/*
 * The phone line is busy.%0
 */

#define ERROR_VOICE_ANSWER                   (RASBASE+77)
/*
 * A person answered instead of a modem (or other connecting device).%0
 */

#define ERROR_NO_ANSWER                      (RASBASE+78)
/*
 * The remote computer did not respond. To make sure that the server can be reached, ping the remote computer.%0
 */

#define ERROR_NO_CARRIER                     (RASBASE+79)
/*
 * The system could not detect the carrier.%0
 */

#define ERROR_NO_DIALTONE                    (RASBASE+80)
/*
 * There was no dial tone.%0
 */

#if (WINVER < 0x600)
//
// The modem (or other connecting device) reported a general error.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_IN_COMMAND                     (RASBASE+81)
/*
 * %0
 */

//
// There was an error in writing the section name.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_WRITING_SECTIONNAME            (RASBASE+82)
/*
 * %0
 */

//
// There was an error in writing the device type.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_WRITING_DEVICETYPE             (RASBASE+83)
/*
 * %0
 */

//
// There was an error in writing the device name.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_WRITING_DEVICENAME             (RASBASE+84)
/*
 * %0
 */

//
// There was an error in writing the maximum connection speed.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_WRITING_MAXCONNECTBPS          (RASBASE+85)
/*
 * %0
 */

//
// There was an error in writing the maximum carrier speed.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_WRITING_MAXCARRIERBPS          (RASBASE+86)
/*
 * %0
 */

//
// There was an error in writing the usage.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_WRITING_USAGE                  (RASBASE+87)
/*
 * %0
 */

//
// There was an error in writing the default-off.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_WRITING_DEFAULTOFF             (RASBASE+88)
/*
 * %0
 */

//
// There was an error in reading the default-off.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_READING_DEFAULTOFF             (RASBASE+89)
/*
 * %0
 */

//
// ERROR_EMPTY_INI_FILE
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_EMPTY_INI_FILE                 (RASBASE+90)
/*
 * %0
 */
#endif

#define ERROR_AUTHENTICATION_FAILURE         (RASBASE+91)
/*
 * The remote connection was denied because the user name and password combination you provided is not recognized, or the selected authentication protocol is not permitted on the remote access server.%0
 */

#define ERROR_PORT_OR_DEVICE                 (RASBASE+92)
/*
 * There was a hardware failure in the modem (or other connecting device).%0
 */

#define ERROR_NOT_BINARY_MACRO               (RASBASE+93)
/*
 * ERROR_NOT_BINARY_MACRO%0
 */

#define ERROR_DCB_NOT_FOUND                  (RASBASE+94)
/*
 * ERROR_DCB_NOT_FOUND%0
 */

#define ERROR_STATE_MACHINES_NOT_STARTED     (RASBASE+95)
/*
 * The state machines are not started.%0
 */

#define ERROR_STATE_MACHINES_ALREADY_STARTED (RASBASE+96)
/*
 * The state machines are already started.%0
 */

#define ERROR_PARTIAL_RESPONSE_LOOPING       (RASBASE+97)
/*
 * The response looping did not complete.%0
 */

#define ERROR_UNKNOWN_RESPONSE_KEY           (RASBASE+98)
/*
 * A response keyname in the device.INF file is not in the expected format.%0
 */

#define ERROR_RECV_BUF_FULL                  (RASBASE+99)
/*
 * The modem (or other connecting device) response caused a buffer overflow.%0
 */

#define ERROR_CMD_TOO_LONG                   (RASBASE+100)
/*
 * The expanded command in the device.INF file is too long.%0
 */

#define ERROR_UNSUPPORTED_BPS                (RASBASE+101)
/*
 * The modem moved to a connection speed not supported by the COM driver.%0
 */

#define ERROR_UNEXPECTED_RESPONSE            (RASBASE+102)
/*
 * Device response received when none expected.%0
 */

#define ERROR_INTERACTIVE_MODE               (RASBASE+103)
/*
 * The connection needs information from you, but the application does not allow user interaction.%0
 */

#define ERROR_BAD_CALLBACK_NUMBER            (RASBASE+104)
/*
 * The callback number is invalid.%0
 */

#define ERROR_INVALID_AUTH_STATE             (RASBASE+105)
/*
 * The authorization state is invalid.%0
 */

#if (WINVER < 0x600)
//
// ERROR_WRITING_INITBPS
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_WRITING_INITBPS                (RASBASE+106)
/*
 * %0
 */
#endif

#define ERROR_X25_DIAGNOSTIC                 (RASBASE+107)
/*
 * There was an error related to the X.25 protocol.%0
 */

#define ERROR_ACCT_EXPIRED                   (RASBASE+108)
/*
 * The account has expired.%0
 */

#define ERROR_CHANGING_PASSWORD              (RASBASE+109)
/*
 * There was an error changing the password on the domain.  The password might have been too short or might have matched a previously used password.%0
 */

#define ERROR_OVERRUN                        (RASBASE+110)
/*
 * Serial overrun errors were detected while communicating with the modem.%0
 */

#define ERROR_RASMAN_CANNOT_INITIALIZE	     (RASBASE+111)
/*
 * The operation could not finish because it could not start the Remote Access Connection Manager service in time. Please try the operation again.%0
 */

#if (WINVER < 0x600)
//
// The two-way port is initializing.  Wait a few seconds and redial.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_BIPLEX_PORT_NOT_AVAILABLE      (RASBASE+112)
/*
 * %0
 */
#endif

#define ERROR_NO_ACTIVE_ISDN_LINES           (RASBASE+113)
/*
 * No active ISDN lines are available.%0
 */

#if (WINVER < 0x600)
//
// No ISDN channels are available to make the call.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_NO_ISDN_CHANNELS_AVAILABLE     (RASBASE+114)
/*
 * %0
 */

//
// Too many errors occurred because of poor phone line quality.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_TOO_MANY_LINE_ERRORS           (RASBASE+115)
/*
 * %0
 */
#endif

#define ERROR_IP_CONFIGURATION               (RASBASE+116)
/*
 * The Remote Access Service IP configuration is unusable.%0
 */

#define ERROR_NO_IP_ADDRESSES                (RASBASE+117)
/*
 * No IP addresses are available in the static pool of Remote Access Service IP addresses.%0
 */

#define ERROR_PPP_TIMEOUT                    (RASBASE+118)
/*
 * The connection was terminated because the remote computer did not respond in a timely manner.%0
 */

#if (WINVER < 0x600)
//
// The connection was terminated by the remote computer.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_PPP_REMOTE_TERMINATED          (RASBASE+119)
/*
 * %0
 */
#endif

#define ERROR_PPP_NO_PROTOCOLS_CONFIGURED    (RASBASE+120)
/*
 * A connection to the remote computer could not be established.  You might need to change the network settings for this connection.%0
 */

#define ERROR_PPP_NO_RESPONSE                (RASBASE+121)
/*
 * A connection to the remote access server was not made because the remote access server did not respond.%0
 */

#define ERROR_PPP_INVALID_PACKET             (RASBASE+122)
/*
 * Invalid data was received from the remote computer.  This data was ignored.%0
 */

#define ERROR_PHONE_NUMBER_TOO_LONG          (RASBASE+123)
/*
 * The phone number, including prefix and suffix, is too long.%0
 */

#if (WINVER < 0x600)
//
// The IPX protocol cannot dial out on the modem (or other connecting device) because this computer is not configured for dialing out (it is an IPX router).
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_IPXCP_NO_DIALOUT_CONFIGURED    (RASBASE+124)
/*
 * %0
 */

//
// The IPX protocol cannot dial in on the modem (or other connecting device) because this computer is not configured for dialing in (the IPX router is not installed).
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_IPXCP_NO_DIALIN_CONFIGURED     (RASBASE+125)
/*
 * %0
 */
#endif

#define ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE   (RASBASE+126)
/*
 * The IPX protocol cannot be used for dialing out on more than one modem (or other connecting device) at a time.%0
 */

#if (WINVER < 0x600)
//
// Cannot access TCPCFG.DLL.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_ACCESSING_TCPCFGDLL            (RASBASE+127)
/*
 * %0
 */
#endif

#define ERROR_NO_IP_RAS_ADAPTER              (RASBASE+128)
/*
 * The system cannot find an IP adapter.%0
 */

#define ERROR_SLIP_REQUIRES_IP               (RASBASE+129)
/*
 * SLIP cannot be used unless the IP protocol is installed.%0
 */

#if (WINVER < 0x600)
//
// Computer registration is not complete.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_PROJECTION_NOT_COMPLETE        (RASBASE+130)
/*
 * %0
 */
#endif

#define ERROR_PROTOCOL_NOT_CONFIGURED        (RASBASE+131)
/*
 * The protocol is not configured.%0
 */

#define ERROR_PPP_NOT_CONVERGING             (RASBASE+132)
/*
 *Your computer and the remote computer could not agree on PPP control protocols.%0
 */

#define ERROR_PPP_CP_REJECTED                (RASBASE+133)
/*
 * A connection to the remote computer could not be completed.  You might need to adjust the protocols on this computer.%0
 */

#define ERROR_PPP_LCP_TERMINATED             (RASBASE+134)
/*
 * The PPP link control protocol was terminated.%0
 */

#define ERROR_PPP_REQUIRED_ADDRESS_REJECTED  (RASBASE+135)
/*
 * The requested address was rejected by the server.%0
 */

#define ERROR_PPP_NCP_TERMINATED             (RASBASE+136)
/*
 * The remote computer terminated the control protocol.%0
 */

#define ERROR_PPP_LOOPBACK_DETECTED          (RASBASE+137)
/*
 * Loopback was detected.%0
 */

#define ERROR_PPP_NO_ADDRESS_ASSIGNED        (RASBASE+138)
/*
 * The remote connection was not made because the remote access server did not assign an IP address.%0
 */

#define ERROR_CANNOT_USE_LOGON_CREDENTIALS   (RASBASE+139)
/*
 * The authentication protocol required by the remote server cannot use the stored password.  Redial, entering the password explicitly.%0
 */

#define ERROR_TAPI_CONFIGURATION             (RASBASE+140)
/*
 * An invalid dialing rule was detected.%0
 */

#define ERROR_NO_LOCAL_ENCRYPTION            (RASBASE+141)
/*
 * The local computer does not support the required data encryption type.%0
 */

#define ERROR_NO_REMOTE_ENCRYPTION           (RASBASE+142)
/*
 * The remote computer does not support the required data encryption type.%0
 */

#if (WINVER < 0x600)
//
// The remote computer requires data encryption.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_REMOTE_REQUIRES_ENCRYPTION     (RASBASE+143)
/*
 * %0
 */

//
// The system cannot use the IPX network number assigned by the remote computer.  Additional information is provided in the event log.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_IPXCP_NET_NUMBER_CONFLICT      (RASBASE+144)
/*
 * %0
 */

//
// ERROR_INVALID_SMM
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_INVALID_SMM                    (RASBASE+145)
/*
 * %0
 */

//
// ERROR_SMM_UNINITIALIZED
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_SMM_UNINITIALIZED              (RASBASE+146)
/*
 * %0
 */

//
// ERROR_NO_MAC_FOR_PORT
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_NO_MAC_FOR_PORT                (RASBASE+147)
/*
 * %0
 */

//
// ERROR_SMM_TIMEOUT
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_SMM_TIMEOUT                    (RASBASE+148)
/*
 * %0
 */
#endif


#define ERROR_BAD_PHONE_NUMBER               (RASBASE+149)
/*
 * The destination address or phone number is either invalid or not present.%0
 */


#if (WINVER < 0x600)

//
// ERROR_WRONG_MODULE
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_WRONG_MODULE                   (RASBASE+150)
/*
 * %0
 */

//
// The callback number contains an invalid character.  Only the following 18 characters are allowed:  0 to 9, T, P, W, (, ), -, @, and space.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_INVALID_CALLBACK_NUMBER        (RASBASE+151)
/*
 * %0
 */
#endif

#define ERROR_SCRIPT_SYNTAX                  (RASBASE+152)
/*
 * A syntax error was encountered while processing a script.%0
 */

#define ERROR_HANGUP_FAILED                  (RASBASE+153)
/*
 * The connection could not be disconnected because the user does not have the required permission to disconnect.%0
 */

#define ERROR_BUNDLE_NOT_FOUND               (RASBASE+154)
/*
 * The system could not find the multi-link bundle.%0
 */

#define ERROR_CANNOT_DO_CUSTOMDIAL           (RASBASE+155)
/*
 * The system cannot perform automated dial because this connection has a custom dialer specified.%0
 */ 

#define ERROR_DIAL_ALREADY_IN_PROGRESS       (RASBASE+156)
/*
 * This connection is already being dialed.%0
 */

#define ERROR_RASAUTO_CANNOT_INITIALIZE      (RASBASE+157)
/*
 * Remote Access Services could not be started automatically.  Additional information is provided in the event log.%0
 */

#if (WINVER < 0x600)
//
// Internet Connection Sharing is already enabled on the connection.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_CONNECTION_ALREADY_SHARED      (RASBASE+158)
/*
 * %0
 */

//
// An error occurred while the existing Internet Connection Sharing settings were being changed.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_SHARING_CHANGE_FAILED          (RASBASE+159)
/*
 * %0
 */

//
// An error occurred while routing capabilities were being enabled.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_SHARING_ROUTER_INSTALL         (RASBASE+160)
/*
 * %0
 */

//
// An error occurred while Internet Connection Sharing was being enabled for the connection.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_SHARE_CONNECTION_FAILED        (RASBASE+161)
/*
 * %0
 */

//
// An error occurred while the local network was being configured for sharing.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_SHARING_PRIVATE_INSTALL        (RASBASE+162)
/*
 * %0
 */

//
// Internet Connection Sharing cannot be enabled.  There is more than one LAN connection other than the connection to be shared.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_CANNOT_SHARE_CONNECTION        (RASBASE+163)
/*
 * %0
 */
#endif

#define ERROR_NO_SMART_CARD_READER           (RASBASE+164)
/*
 * No smart card reader is installed.%0
 */

#define ERROR_SHARING_ADDRESS_EXISTS         (RASBASE+165)
/*
 * Internet Connection Sharing cannot be enabled.  A LAN connection is already configured with the IP address that is required for automatic IP addressing.%0
 */

#define ERROR_NO_CERTIFICATE                 (RASBASE+166)
/*
 * A certificate could not be found.  Connections that use the L2TP protocol over IPSec require the installation of a machine certificate, also known as a computer certificate.%0
 */

#define ERROR_SHARING_MULTIPLE_ADDRESSES     (RASBASE+167)
/*
 * Internet Connection Sharing cannot be enabled.  The LAN connection selected as the private network has more than one IP address configured.  Please reconfigure the LAN connection with a single IP address before enabling Internet Connection Sharing.%0
 */

#define ERROR_FAILED_TO_ENCRYPT              (RASBASE+168)
/*
 * The connection attempt failed because of failure to encrypt data.%0
 */

#define ERROR_BAD_ADDRESS_SPECIFIED          (RASBASE+169)
/*
 * The specified destination is not reachable.%0
 */

#define ERROR_CONNECTION_REJECT              (RASBASE+170)
/*
 * The remote computer rejected the connection attempt.%0
 */

#define ERROR_CONGESTION                     (RASBASE+171)
/*
 * The connection attempt failed because the network is busy.%0
 */

#define ERROR_INCOMPATIBLE                   (RASBASE+172)
/*
 * The remote computer's network hardware is incompatible with the type of call requested.%0
 */

#define ERROR_NUMBERCHANGED                  (RASBASE+173)
/*
 * The connection attempt failed because the destination number has changed.%0
 */

#define ERROR_TEMPFAILURE                    (RASBASE+174)
/*
 * The connection attempt failed because of a temporary failure.  Try connecting again.%0
 */ 

#define ERROR_BLOCKED                        (RASBASE+175)
/*
 * The call was blocked by the remote computer.%0
 */

#define ERROR_DONOTDISTURB                   (RASBASE+176)
/*
 * The call could not be connected because the remote computer has invoked the Do Not Disturb feature.%0
 */

#define ERROR_OUTOFORDER                     (RASBASE+177)
/*
 * The connection attempt failed because the modem (or other connecting device) on the remote computer is out of order.%0
 */

#define ERROR_UNABLE_TO_AUTHENTICATE_SERVER  (RASBASE+178)
/*
 * It was not possible to verify the identity of the server.%0
 */

#if (WINVER < 0x600)
//
// To dial out using this connection you must use a smart card.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_SMART_CARD_REQUIRED            (RASBASE+179)
/*
 * %0
 */
#endif

#define ERROR_INVALID_FUNCTION_FOR_ENTRY     (RASBASE+180)
/*
 * An attempted function is not valid for this connection.%0
 */

#if (WINVER < 0x600)
//
// The connection requires a certificate, and no valid certificate was found.  For further assistance, click More Info or search Help and Support Center for this error number.
//
// This error was obsoleted in the Windows Vista  release.
//
#define ERROR_CERT_FOR_ENCRYPTION_NOT_FOUND  (RASBASE+181)
/*
 * %0
 */
#endif

#define ERROR_SHARING_RRAS_CONFLICT          (RASBASE+182)
/*
 * Internet Connection Sharing (ICS) and Internet Connection Firewall (ICF) cannot be enabled because Routing and Remote Access has been enabled on this computer.  To enable ICS or ICF, first disable Routing and Remote Access.  For more information about Routing and Remote Access, ICS, or ICF, see Help and Support.%0
 */

#define ERROR_SHARING_NO_PRIVATE_LAN         (RASBASE+183)
/*
 * Internet Connection Sharing cannot be enabled.  The LAN connection selected as the private network is either not present, or is disconnected from the network.  Please ensure that the LAN adapter is connected before enabling Internet Connection Sharing.%0
 */

#define ERROR_NO_DIFF_USER_AT_LOGON          (RASBASE+184)
/*
 * You cannot dial using this connection at logon time, because it is configured to use a user name different than the one on the smart card.  If you want to use it at logon time, you must configure it to use the user name on the smart card.%0
 */

#define ERROR_NO_REG_CERT_AT_LOGON           (RASBASE+185)
/*
 * You cannot dial using this connection at logon time, because it is not configured to use a smart card.  If you want to use it at logon time, you must edit the properties of this connection so that it uses a smart card.%0
 */

#define ERROR_OAKLEY_NO_CERT                 (RASBASE+186)
/*
 * The connection attempt failed because there is no valid machine certificate on your computer for security authentication.%0
 */

#define ERROR_OAKLEY_AUTH_FAIL               (RASBASE+187)
/*
 * The L2TP connection attempt failed because the security layer could not authenticate the remote computer.%0
 */

#define ERROR_OAKLEY_ATTRIB_FAIL             (RASBASE+188)
/*
 * The L2TP connection attempt failed because the security layer could not negotiate compatible parameters with the remote computer.%0
 */

#define ERROR_OAKLEY_GENERAL_PROCESSING      (RASBASE+189)
/*
 * The L2TP connection attempt failed because the security layer encountered a processing error during initial negotiations with the remote computer.%0
 */

#define ERROR_OAKLEY_NO_PEER_CERT            (RASBASE+190)
/*
 * The L2TP connection attempt failed because certificate validation of the remote computer failed.%0
 */

#define ERROR_OAKLEY_NO_POLICY               (RASBASE+191)
/*
 * The L2TP connection attempt failed because security policy for the connection was not found.%0
 */

#define ERROR_OAKLEY_TIMED_OUT               (RASBASE+192)
/*
 * The L2TP connection attempt failed because security negotiation timed out.%0
 */

#define ERROR_OAKLEY_ERROR                   (RASBASE+193)
/*
 * The L2TP connection attempt failed because an error occurred while negotiating security.%0
 */

#define ERROR_UNKNOWN_FRAMED_PROTOCOL        (RASBASE+194)
/*
 * The Framed Protocol RADIUS attribute for this user is not PPP.%0
 */

#define ERROR_WRONG_TUNNEL_TYPE              (RASBASE+195)
/*
 * The remote connection request was denied because the VPN tunnel type being used is not allowed.%0
 */

#define ERROR_UNKNOWN_SERVICE_TYPE           (RASBASE+196)
/*
 * The Service Type RADIUS attribute for this user is neither Framed nor Callback Framed.%0
 */

#define ERROR_CONNECTING_DEVICE_NOT_FOUND    (RASBASE+197)
/*
 * A connection to the remote access server was not made because the modem was not found.%0
 */

#define ERROR_NO_EAPTLS_CERTIFICATE          (RASBASE+198)
/*
 * A certificate could not be found that can be used with this Extensible Authentication Protocol.%0
 */

#define ERROR_SHARING_HOST_ADDRESS_CONFLICT  (RASBASE+199)
/*
 * Internet Connection Sharing (ICS) cannot be enabled due to an IP address conflict on the network.  ICS requires the host be configured to use 192.168.137.1.  Please ensure that no other client on the network is configured to use 192.168.137.1.%0
 */

#define ERROR_AUTOMATIC_VPN_FAILED           (RASBASE+200)
/*
 * The remote connection was not made because the attempted VPN tunnels failed. The VPN server might be unreachable. If this connection is attempting to use an L2TP/IPsec tunnel, the security parameters required for IPsec negotiation might not be configured properly.%0
 */

#define ERROR_VALIDATING_SERVER_CERT         (RASBASE+201)
/*
 * This connection is configured to validate the identity of the access server, but Windows cannot verify the digital certificate sent by the server.%0
 */

#define ERROR_READING_SCARD                  (RASBASE+202)
/*
 * The card supplied was not recognized.  Please check that the card is inserted correctly, and fits tightly.%0
 */

#define ERROR_INVALID_PEAP_COOKIE_CONFIG     (RASBASE+203)
/*
 * The PEAP configuration stored in the session cookie does not match the current session configuration.%0
 */

#define ERROR_INVALID_PEAP_COOKIE_USER       (RASBASE+204)
/*
 * The PEAP identity stored in the session cookie does not match the current identity.%0
 */

#define ERROR_INVALID_MSCHAPV2_CONFIG        (RASBASE+205)
/*
 * You cannot dial using this connection at logon time, because it is configured to use logged on user's credentials.%0
 */

//
// New Errors for Windows Vista
//
#define ERROR_VPN_GRE_BLOCKED                 (RASBASE+206)
/*
 * The VPN connection between your computer and the VPN server could not be completed. The most common cause for this failure is that at least one Internet device (for example, a firewall or a router) between your computer and the VPN server is not configured to allow Generic Routing Encapsulation (GRE) protocol packets. If the problem persists, contact your network administrator or Internet Service Provider.%0
 */

#define ERROR_VPN_DISCONNECT                 (RASBASE+207)
/*
 * The network connection between your computer and the VPN server was interrupted.  This can be caused by a problem in the VPN transmission and is commonly the result of internet latency or simply that your VPN server has reached capacity.  Please try to reconnect to the VPN server.  If this problem persists, contact the VPN administrator and analyze quality of network connectivity.%0
 */

#define ERROR_VPN_REFUSED                    (RASBASE+208)
/*
 * The network connection between your computer and the VPN server could not be established because the remote server refused the connection. This is typically caused by a mismatch between the server's configuration and your connection settings. Please contact the remote server's Administrator to verify the server configuration and your connection settings.%0
 */

#define ERROR_VPN_TIMEOUT                    (RASBASE+209)
/*
 * The network connection between your computer and the VPN server could not be established because the remote server is not responding. This could be because one of the network devices (e.g, firewalls, NAT, routers, etc) between your computer and the remote server is not configured to allow VPN connections. Please contact your Administrator or your service provider to determine which device may be causing the problem.%0
 */

#define ERROR_VPN_BAD_CERT                   (RASBASE+210)
/*
 * A network connection between your computer and the VPN server was started, but the VPN connection was not completed. This is typically caused by the use of an incorrect or expired certificate for authentication between the client and the server. Please contact your Administrator to ensure that the certificate being used for authentication is valid.%0
 */

#define ERROR_VPN_BAD_PSK                    (RASBASE+211)
/*
 * The network conection between your computer and the VPN server could not be established because the remote server is not responding.  This is typically caused by a pre-shared key problem between the client and server.  A pre-shared key is used to guarantee you are who you say you are in an IP Security (IPSec) communication cycle.  Please get the assistance of your administrator to determine where the pre-shared key problem is originating.%0
 */

#define ERROR_SERVER_POLICY                  (RASBASE+212)
/*
 *The connection was prevented because of a policy configured on your RAS/VPN server. Specifically, the authentication method used by the server to verify your username and password may not match the authentication method configured in your connection profile. Please contact the Administrator of the RAS server and notify them of this error.%0
 */

#define ERROR_BROADBAND_ACTIVE               (RASBASE+213)
/*
 * You have attempted to establish a second broadband connection while a previous broadband connection is already established using the same device or port. Please disconnect the earlier connection and then reestablish the connection.%0
 */

#define ERROR_BROADBAND_NO_NIC               (RASBASE+214)
/*
 * The underlying Ethernet connectivity required for the broadband connection was not found. Please install and enable the Ethernet adapter on your computer via the Network Connections folder before attempting this connection.%0
 */

#define ERROR_BROADBAND_TIMEOUT              (RASBASE+215)
/*
 * The broadband network conection could not be established on your computer because the remote server is not responding. This could be caused by an invalid value for the 'Service Name' field for this connection. Please contact your Internet Service Provider and inquire about the correct value for this field and update it in the Connection Properties.%0
 */

#define ERROR_FEATURE_DEPRECATED             (RASBASE+216)
/*
 * A feature or setting you have tried to enable is no longer supported by the remote access service.%0
 */

#define ERROR_CANNOT_DELETE                  (RASBASE+217)
/*
 * Cannot delete a connection while it is connected.%0
 */

#if (WINVER <= 0x600)

#define ERROR_RASQEC_RESOURCE_CREATION_FAILED (RASBASE+218)
/*
* The Network Access Protection (NAP) enforcement client could not create system resources for remote access connections. Some network services or resources might not be available. If the problem persists, disconnect and retry the remote access connection or contact the administrator for the remote access server.
*/

#define ERROR_RASQEC_NAPAGENT_NOT_ENABLED    (RASBASE+219)
/*
* The Network Access Protection Agent (NAPAgent) service has been disabled or is not installed on this computer. Some network services or resources might not be available. If the problem persists, disconnect and retry the remote access connection or contact the administrator for the remote access server.
*/

#define ERROR_RASQEC_NAPAGENT_NOT_CONNECTED  (RASBASE+220)
/*
* The Network Access Protection (NAP) enforcement client failed to register with the Network Access Protection Agent (NAPAgent) service. Some network services or resources might not be available. If the problem persists, disconnect and retry the remote access connection or contact the administrator for the remote access server.
*/

#define ERROR_RASQEC_CONN_DOESNOTEXIST       (RASBASE+221)
/*
* The Network Access Protection (NAP) enforcement client was unable to process the request because the remote access connection does not exist. Retry the remote access connection. If the problem persists, make sure that you can connect to the Internet, and then contact the administrator for the remote access server.
*/

#define ERROR_RASQEC_TIMEOUT                 (RASBASE+222)
/*
* The Network Access Protection (NAP) enforcement client did not respond. Some network services or resources might not be available. If the problem persists, disconnect and retry the remote access connection or contact the administrator for the remote access server.
*/

#endif

#define ERROR_PEAP_CRYPTOBINDING_INVALID    (RASBASE+223)
/*
* Received Crypto-Binding TLV is invalid.%0
*/

#define ERROR_PEAP_CRYPTOBINDING_NOTRECEIVED   (RASBASE+224)
/*
* Crypto-Binding TLV is not received.%0
*/

#if (WINVER >= 0x600)

#define ERROR_INVALID_VPNSTRATEGY   (RASBASE+225)
/*
* The remote connection was not made because Point-to-Point Tunneling Protocol (PPTP) is incompatible with IPv6. Use any other tunneling protocol. %0
*/

#endif

#define ERROR_EAPTLS_CACHE_CREDENTIALS_INVALID   (RASBASE+226)
/*
* EAPTLS validation of the cached credentials failed. Please discard 
* cached credentials.
*/

#define ERROR_IPSEC_SERVICE_STOPPED                 (RASBASE+227)
/*
* The VPN connection cannot be completed because the 'IKE and AuthIP IPSec Keying Modules' service and/or the 'Base Filtering Engine' service is not running. These services are required to establish the connection. Please ensure that these services have been started before dialing the connection.
*/

#if (WINVER >= 0x600)

#define ERROR_IDLE_TIMEOUT               (RASBASE+228)
/*
 * The connection was terminated because of idle timeout.%0
 */

#define ERROR_LINK_FAILURE               (RASBASE+229)
/*
 * The modem (or other connecting device) was disconnected due to link failure.%0
 */

#define ERROR_USER_LOGOFF                (RASBASE+230)
/*
 * The connection was terminated because user logged off.%0
 */

#define ERROR_FAST_USER_SWITCH           (RASBASE+231)
/*
 * The connection was terminated because user switch happened.%0
 */

#define ERROR_HIBERNATION                 (RASBASE+232)
/*
 * The connection was terminated because of hibernation.%0
 */

#define ERROR_SYSTEM_SUSPENDED            (RASBASE+233)
/*
 * The connection was terminated because the system got suspended.%0
 */

#define ERROR_RASMAN_SERVICE_STOPPED      (RASBASE+234)
/*
 * The connection was terminated because Remote Access Connection manager stopped.%0
 */

#define ERROR_INVALID_SERVER_CERT         (RASBASE+235)
/*
* The L2TP connection attempt failed because the security layer could not authenticate the remote computer. This could be because one or more fields of the certificate presented by the remote server could not be validated as belonging to the target destination.
*/

#define ERROR_NOT_NAP_CAPABLE             (RASBASE+236)
/*
* The Network Access Protection (NAP) health state of the computer cannot be determined. Contact your administrator to verify that the NAP enforcement client is enabled, the NAP Agent service is running, and NAP is enforced in the Protected Extensible Authentication Protocol (PEAP) properties of the remote access connection.  
*/

#endif

#if (WINVER >= 0x601)

#define ERROR_INVALID_TUNNELID           (RASBASE+237)
/*
* Invalid Tunnel ID.%0
*/

#define ERROR_UPDATECONNECTION_REQUEST_IN_PROCESS    (RASBASE+238)
/*
* Another Update connection request is in progress. RAS allows only one Update Connection request at a time.%0
*/

#define ERROR_PROTOCOL_ENGINE_DISABLED    (RASBASE+239)
/*
* Negotiating using configured protocol is disable. Edit connection properties and select different protocol for negotiation and try again.%0
*/

#define ERROR_INTERNAL_ADDRESS_FAILURE    (RASBASE+240)
/*
 *  Internal address negotiation failed.%0
 */

#define ERROR_FAILED_CP_REQUIRED          (RASBASE+241)
/*
 * Client has to request a Internal IPv4 or IPv6 address.%0
 */

#define ERROR_TS_UNACCEPTABLE             (RASBASE+242)
/*
 *  Traffic Selectors negotiation failed.%0
 */

#define ERROR_MOBIKE_DISABLED             (RASBASE+243)
/*
* Mobility is disabled for this connection.
*/

#define ERROR_CANNOT_INITIATE_MOBIKE_UPDATE  (RASBASE+244)
/*
* The VPN Connection is still connecting or reauthenticating because of Quarantine state change. Initiate mobike update only when connection state is 'Connected'.
*/

#define ERROR_PEAP_SERVER_REJECTED_CLIENT_TLV           (RASBASE+245)
/*
* Server rejected client authentication, due unexpected TLV or value mismatch for a TLV.
*/

#define ERROR_INVALID_PREFERENCES           (RASBASE+246)
/*
* Either VPN Destination preference is not selected by the user or it is no longer valid. 
*/

#define ERROR_EAPTLS_SCARD_CACHE_CREDENTIALS_INVALID (RASBASE+247)
/*
* Cached smart card credential is invalid.
*/

#define ERROR_SSTP_COOKIE_SET_FAILURE             (RASBASE + 248)
/*
* VPN connection attempt failed due to internal error occurred while adding cookies to the Secure Socket Tunneling Protocol (SSTP). Please see the System Event Log for the detailed information.
*/
#define ERROR_INVALID_PEAP_COOKIE_ATTRIBUTES (RASBASE+249)
/*
* The PEAP inner method attributes stored in the cookie is invalid
*/

#define ERROR_EAP_METHOD_NOT_INSTALLED            (RASBASE+250)
/*
* The Extensible Authentication Protocol type required for authentication of the remote access connection is not installed on your computer. 
*/

#define ERROR_EAP_METHOD_DOES_NOT_SUPPORT_SSO     (RASBASE+251)
/*
* The Extensible Authentication Protocol type configured on the remote access connection does not support single sign-on. 
*/

#define ERROR_EAP_METHOD_OPERATION_NOT_SUPPORTED  (RASBASE+252)
/*
* The Extensible Authentication Protocol type configured on the remote access connection does not support the requested operation. 
*/

#define ERROR_EAP_USER_CERT_INVALID               (RASBASE+253)
/*
* The remote access connection completed, but authentication failed because the certificate that authenticates the client to the server is not valid. Ensure that the certificate used for authentication is valid. 
*/

#define ERROR_EAP_USER_CERT_EXPIRED               (RASBASE+254)
/*
* The remote access connection completed, but authentication failed because the certificate that authenticates the client to the server is expired. Renew the certificate. 
*/

#define ERROR_EAP_USER_CERT_REVOKED               (RASBASE+255)
/*
* The remote access connection completed, but authentication failed because the certificate that authenticates the client to the server is revoked. 
*/

#define ERROR_EAP_USER_CERT_OTHER_ERROR           (RASBASE+256)
/*
* The remote access connection completed, but authentication failed because of an error in the certificate that authenticates the client to the server. 
*/

#define ERROR_EAP_SERVER_CERT_INVALID             (RASBASE+257)
/*
* The remote access connection completed, but authentication failed because the certificate that the client uses to authenticate the server is not valid. 
*/

#define ERROR_EAP_SERVER_CERT_EXPIRED             (RASBASE+258)
/*
* The remote access connection completed, but authentication failed because the certificate that the client uses to authenticate the server is expired. 
*/

#define ERROR_EAP_SERVER_CERT_REVOKED             (RASBASE+259)
/*
* The remote access connection completed, but authentication failed because the certificate that the client uses to authenticate the server is revoked. 
*/

#define ERROR_EAP_SERVER_CERT_OTHER_ERROR         (RASBASE+260)
/*
* The remote access connection completed, but authentication failed because of an error in the certificate that the client uses to authenticate the server. 
*/

#define ERROR_EAP_USER_ROOT_CERT_NOT_FOUND        (RASBASE+261)
/*
* The remote access connection completed, but authentication failed because a trusted root certificate that validates the user certificate was not found in the Trusted Root Certification Authorities certificate store. 
*/

#define ERROR_EAP_USER_ROOT_CERT_INVALID          (RASBASE+262)
/*
* The remote access connection completed, but authentication failed because the trusted root certificate that is used to validate the user certificate is not valid. 
*/

#define ERROR_EAP_USER_ROOT_CERT_EXPIRED          (RASBASE+263)
/*
* The remote access connection completed, but authentication failed because the certificate in the Trusted Root Certification Authorities certificate store that authenticates the user certificate is expired. Renew the certificate. 
*/

#define ERROR_EAP_SERVER_ROOT_CERT_NOT_FOUND      (RASBASE+264)
/*
* The remote access connection completed, but authentication failed because a certificate that validates the server certificate was not found in the Trusted Root Certification Authorities certificate store.
*/

#define ERROR_EAP_SERVER_ROOT_CERT_INVALID        (RASBASE+265)
/*
* The remote zccess connection completed, but authentication failed because the certificate in the Trusted Root Certification Authorities certificate store that validates the server certificate is not valid. 
*/

#define ERROR_EAP_SERVER_ROOT_CERT_NAME_REQUIRED  (RASBASE+266)
/*
* The remote access connection completed, but authentication failed because the certificate on the server computer does not have a server name specified. 
*/

#define ERROR_PEAP_IDENTITY_MISMATCH (RASBASE+267)
/*
*    The PEAP outer identity is not same as the inner identity when identity privacy is turned OFF.
*/

#define ERROR_DNSNAME_NOT_RESOLVABLE (RASBASE+268)
/*
*    The remote connection was not made because the name of the remote access server did not resolve.
*/

#endif

#define RASBASEEND                        (RASBASE+268)

#endif // _RASERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Ratings.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*        Copyright (c) Microsoft Corporation. All rights reserved. **
//*********************************************************************
#pragma once

#ifndef _RATINGS_H_
#define _RATINGS_H_

#include <winerror.h>
#include <shlwapi.h>

STDAPI RatingEnable(HWND hwndParent, LPCSTR pszUsername, BOOL fEnable);
STDAPI RatingEnableW(HWND hwndParent, LPCWSTR pszUsername, BOOL fEnable);
STDAPI RatingCheckUserAccess(__in_opt LPCSTR pszUsername, __in_opt LPCSTR pszURL, __in_opt LPCSTR pszRatingInfo,
    __in_bcount_opt(cbData) LPBYTE pData, DWORD cbData, __out_opt void **ppRatingDetails);
STDAPI RatingCheckUserAccessW(__in_opt LPCWSTR pszUsername, __in_opt LPCWSTR pszURL, __in_opt LPCWSTR pszRatingInfo,
    __in_bcount_opt(cbData) LPBYTE pData, DWORD cbData, __out_opt void **ppRatingDetails);
STDAPI RatingAccessDeniedDialog(HWND hDlg, __in_opt LPCSTR pszUsername, LPCSTR pszContentDescription, __out void *pRatingDetails);
STDAPI RatingAccessDeniedDialogW(HWND hDlg, __in_opt LPCWSTR pszUsername, LPCWSTR pszContentDescription, __out void *pRatingDetails);
STDAPI RatingAccessDeniedDialog2(HWND hDlg, __in_opt LPCSTR pszUsername, __out void *pRatingDetails);
STDAPI RatingAccessDeniedDialog2W(HWND hDlg, __in_opt LPCWSTR pszUsername, __out void *pRatingDetails);
STDAPI RatingFreeDetails(__in_opt void *pRatingDetails);
STDAPI RatingObtainCancel(HANDLE hRatingObtainQuery);
STDAPI RatingObtainQuery(LPCSTR pszTargetUrl, DWORD dwUserData,
    void (*fCallback)(DWORD dwUserData, HRESULT hr, LPCSTR pszRating, void *lpvRatingDetails),
    __out_opt HANDLE *phRatingObtainQuery);
STDAPI RatingObtainQueryW(LPCWSTR pszTargetUrl, DWORD dwUserData,
    void (*fCallback)(DWORD dwUserData, HRESULT hr, LPCWSTR pszRating, void *lpvRatingDetails),
    __out_opt HANDLE *phRatingObtainQuery);
STDAPI RatingSetupUI(HWND hDlg, LPCSTR pszUsername);
STDAPI RatingSetupUIW(HWND hDlg, LPCWSTR pszUsername);
#ifdef _INC_COMMCTRL
STDAPI RatingAddPropertyPage(PROPSHEETHEADER *ppsh);
#endif

STDAPI RatingAddToApprovedSites(HWND hDlg,
                                DWORD cbPasswordBlob,
                                __inout_bcount(cbPasswordBlob) BYTE *pbPasswordBlob,
                                __in LPCWSTR lpszUrl,
                                BOOL fAlwaysNever,
                                BOOL fSitePage,
                                BOOL fApprovedSitesEnforced);

STDAPI RatingClickedOnPRFInternal(HWND hWndOwner, HINSTANCE /*p_hInstance*/, __in LPSTR lpszFileName, int nShow);
STDAPI RatingClickedOnRATInternal(HWND hWndOwner, HINSTANCE /*p_hInstance*/, __in LPSTR lpszFileName, int nShow);

STDAPI RatingEnabledQuery();
STDAPI RatingInit();
STDAPI_(void) RatingTerm();

// A way to check if ratings are installed. We still need to calling
// ratings dll to find out for sure but this allows us to delay load ratings.
__inline BOOL IS_RATINGS_ENABLED()
{
    TCHAR szSup[200];
    DWORD dwType;
    DWORD cbSize = sizeof(szSup);

    return (SHGetValue(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Ratings"),
                       TEXT("Key"),
                       &dwType, szSup, &cbSize) == ERROR_SUCCESS);
}

#endif
// _RATINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RasDlg.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rasdlg.h

Abstract:

    Remote Access Common Dialog APIs

    These APIs live in RASDLG.DLL.

    The APIs in this header are added in Windows NT SUR and are not available
    in prior Windows NT or Windows 95 releases.
    
--*/

#ifndef _RASDLG_H_
#define _RASDLG_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <pshpack4.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <ras.h>


/* RasPhonebookDlg API callback.
*/
typedef VOID (WINAPI* RASPBDLGFUNCW)( ULONG_PTR, DWORD, LPWSTR, LPVOID );
typedef VOID (WINAPI* RASPBDLGFUNCA)( ULONG_PTR, DWORD, LPSTR, LPVOID );

#define RASPBDEVENT_AddEntry    1
#define RASPBDEVENT_EditEntry   2
#define RASPBDEVENT_RemoveEntry 3
#define RASPBDEVENT_DialEntry   4
#define RASPBDEVENT_EditGlobals 5
#define RASPBDEVENT_NoUser      6
#define RASPBDEVENT_NoUserEdit  7

#define  RASNOUSER_SmartCard    0x00000001

/* Defines the information passed in the 4th argument of RASPBDLGFUNC on
** "NoUser" and "NoUserEdit" events.  Usage shown is for "NoUser".  For
** "NoUserEdit", the timeout is ignored and the three strings are INs.
*/
#define RASNOUSERW struct tagRASNOUSERW
RASNOUSERW
{
    IN  DWORD dwSize;
    IN  DWORD dwFlags;
    OUT DWORD dwTimeoutMs;
    OUT WCHAR szUserName[ UNLEN + 1 ];
    OUT WCHAR szPassword[ PWLEN + 1 ];
    OUT WCHAR szDomain[ DNLEN + 1 ];
};

#define RASNOUSERA struct tagRASNOUSERA
RASNOUSERA
{
    IN  DWORD dwSize;
    IN  DWORD dwFlags;
    OUT DWORD dwTimeoutMs;
    OUT CHAR  szUserName[ UNLEN + 1 ];
    OUT CHAR  szPassword[ PWLEN + 1 ];
    OUT CHAR  szDomain[ DNLEN + 1 ];
};

#ifdef UNICODE
#define RASNOUSER RASNOUSERW
#else
#define RASNOUSER RASNOUSERA
#endif

#define LPRASNOUSERW RASNOUSERW*
#define LPRASNOUSERA RASNOUSERA*
#define LPRASNOUSER  RASNOUSER*


/* RasPhonebookDlg API parameters.
*/
#define RASPBDFLAG_PositionDlg      0x00000001
#define RASPBDFLAG_ForceCloseOnDial 0x00000002
#define RASPBDFLAG_NoUser           0x00000010
#define RASPBDFLAG_UpdateDefaults   0x80000000

#define RASPBDLGW struct tagRASPBDLGW
RASPBDLGW
{
    IN  DWORD         dwSize;
    IN  HWND          hwndOwner;
    IN  DWORD         dwFlags;
    IN  LONG          xDlg;
    IN  LONG          yDlg;
    IN  ULONG_PTR     dwCallbackId;
    IN  RASPBDLGFUNCW pCallback;
    OUT DWORD         dwError;
    IN  ULONG_PTR     reserved;
    IN  ULONG_PTR     reserved2;
};

#define RASPBDLGA struct tagRASPBDLGA
RASPBDLGA
{
    IN  DWORD         dwSize;
    IN  HWND          hwndOwner;
    IN  DWORD         dwFlags;
    IN  LONG          xDlg;
    IN  LONG          yDlg;
    IN  ULONG_PTR     dwCallbackId;
    IN  RASPBDLGFUNCA pCallback;
    OUT DWORD         dwError;
    IN  ULONG_PTR     reserved;
    IN  ULONG_PTR     reserved2;
};

#ifdef UNICODE
#define RASPBDLG     RASPBDLGW
#define RASPBDLGFUNC RASPBDLGFUNCW
#else
#define RASPBDLG     RASPBDLGA
#define RASPBDLGFUNC RASPBDLGFUNCA
#endif

#define LPRASPBDLGW RASPBDLGW*
#define LPRASPBDLGA RASPBDLGA*
#define LPRASPBDLG  RASPBDLG*


/* RasEntryDlg API parameters.
*/
#define RASEDFLAG_PositionDlg    	0x00000001
#define RASEDFLAG_NewEntry       	0x00000002
#if (WINVER < 0x600)
#define RASEDFLAG_CloneEntry     	0x00000004
#endif // (WINVER < 0x600)
#define RASEDFLAG_NoRename       	0x00000008
#define RASEDFLAG_ShellOwned     	0x40000000
#define RASEDFLAG_NewPhoneEntry  	0x00000010
#define RASEDFLAG_NewTunnelEntry 	0x00000020
#if (WINVER < 0x600)
#define RASEDFLAG_NewDirectEntry 	0x00000040
#endif // (WINVER < 0x600)
#define RASEDFLAG_NewBroadbandEntry  	0x00000080
#define RASEDFLAG_InternetEntry      	0x00000100
#define RASEDFLAG_NAT                	0x00000200
#if (WINVER >= 0x600)
#define RASEDFLAG_IncomingConnection 	0x00000400
#endif

#define RASENTRYDLGW struct tagRASENTRYDLGW
RASENTRYDLGW
{
    IN  DWORD dwSize;
    IN  HWND  hwndOwner;
    IN  DWORD dwFlags;
    IN  LONG  xDlg;
    IN  LONG  yDlg;
    OUT WCHAR szEntry[ RAS_MaxEntryName + 1 ];
    OUT DWORD dwError;
    IN  ULONG_PTR reserved;
    IN  ULONG_PTR reserved2;
};

#define RASENTRYDLGA struct tagRASENTRYDLGA
RASENTRYDLGA
{
    IN  DWORD dwSize;
    IN  HWND  hwndOwner;
    IN  DWORD dwFlags;
    IN  LONG  xDlg;
    IN  LONG  yDlg;
    OUT CHAR  szEntry[ RAS_MaxEntryName + 1 ];
    OUT DWORD dwError;
    IN  ULONG_PTR reserved;
    IN  ULONG_PTR reserved2;
};

#ifdef UNICODE
#define RASENTRYDLG RASENTRYDLGW
#else
#define RASENTRYDLG RASENTRYDLGA
#endif

#define LPRASENTRYDLGW RASENTRYDLGW*
#define LPRASENTRYDLGA RASENTRYDLGA*
#define LPRASENTRYDLG  RASENTRYDLG*


/* RasDialDlg API parameters.
*/
#define RASDDFLAG_PositionDlg 0x00000001
#define RASDDFLAG_NoPrompt    0x00000002
#define RASDDFLAG_LinkFailure 0x80000000

#define RASDIALDLG struct tagRASDIALDLG
RASDIALDLG
{
    IN  DWORD dwSize;
    IN  HWND  hwndOwner;
    IN  DWORD dwFlags;
    IN  LONG  xDlg;
    IN  LONG  yDlg;
    IN  DWORD dwSubEntry;
    OUT DWORD dwError;
    IN  ULONG_PTR reserved;
    IN  ULONG_PTR reserved2;
};

#define LPRASDIALDLG RASDIALDLG*


#if (WINVER >= 0x500)
typedef BOOL (WINAPI *RasCustomDialDlgFn) (
                            HINSTANCE hInstDll,
                            DWORD dwFlags,
                            LPWSTR lpszPhonebook,
                            LPWSTR lpszEntry,
                            LPWSTR lpszPhoneNumber,
                            LPRASDIALDLG lpInfo,
                            PVOID pvInfo
                            );

typedef BOOL (WINAPI *RasCustomEntryDlgFn) (
                            HINSTANCE hInstDll,
                            LPWSTR lpszPhonebook,
                            LPWSTR lpszEntry,
                            LPRASENTRYDLG lpInfo,
                            DWORD  dwFlags
                            );


#endif


/* RAS common dialog API prototypes.
*/
BOOL APIENTRY RasPhonebookDlgA(
    __in_opt LPSTR lpszPhonebook, __in_opt LPSTR lpszEntry, LPRASPBDLGA lpInfo );

BOOL APIENTRY RasPhonebookDlgW(
    __in_opt LPWSTR lpszPhonebook, __in_opt LPWSTR lpszEntry, LPRASPBDLGW lpInfo );

BOOL APIENTRY RasEntryDlgA(
    __in_opt LPSTR lpszPhonebook, __in_opt LPSTR lpszEntry, LPRASENTRYDLGA lpInfo );

BOOL APIENTRY RasEntryDlgW(
    __in_opt LPWSTR lpszPhonebook, __in_opt LPWSTR lpszEntry, LPRASENTRYDLGW lpInfo );

BOOL APIENTRY RasDialDlgA(
    __in_opt LPSTR lpszPhonebook, __in_opt LPSTR lpszEntry, __in_opt LPSTR lpszPhoneNumber,
    __inout LPRASDIALDLG lpInfo );

BOOL APIENTRY RasDialDlgW(
    __in_opt LPWSTR lpszPhonebook, __in_opt LPWSTR lpszEntry, __in_opt LPWSTR lpszPhoneNumber,
    __inout LPRASDIALDLG lpInfo );


#ifdef UNICODE
#define RasPhonebookDlg RasPhonebookDlgW
#define RasEntryDlg     RasEntryDlgW
#define RasDialDlg      RasDialDlgW
#if (WINVER <= 0x500)
#define RasMonitorDlg   RasMonitorDlgW
#endif
#else
#define RasPhonebookDlg RasPhonebookDlgA
#define RasEntryDlg     RasEntryDlgA
#define RasDialDlg      RasDialDlgA
#if (WINVER <= 0x500)
#define RasMonitorDlg   RasMonitorDlgA
#endif
#endif



#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif // _RASDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RassHost.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rasshost.h

Abstract:

    This header defines the interface between third party security
    DLLs and the RAS server.
    
--*/

#ifndef _RASSHOST_
#define _RASSHOST_

#if _MSC_VER > 1000
#pragma once
#endif

#include <mprapi.h>

typedef HANDLE  HPORT;

typedef struct _SECURITY_MESSAGE
{
    DWORD dwMsgId;

    HPORT hPort;

    DWORD dwError;                  // Should be non-zero only if error
                                    // occurred during the security dialog.
                                    // Should contain errors from winerror.h
                                    // or raserror.h

    CHAR  UserName[UNLEN+1];        // Should always contain username if
                                    // dwMsgId is SUCCESS/FAILURE

    CHAR  Domain[DNLEN+1];          // Should always contain domain if
                                    // dwMsgId is SUCCESS/FAILURE

} SECURITY_MESSAGE, *PSECURITY_MESSAGE;


// Values for dwMsgId in SECURITY_MESSAGE structure

#define SECURITYMSG_SUCCESS     1
#define SECURITYMSG_FAILURE     2
#define SECURITYMSG_ERROR       3

// Used by RasSecurityGetInfo call

typedef struct _RAS_SECURITY_INFO
{

    DWORD LastError;                    // SUCCESS = receive completed
                                        // PENDING = receive pending
                                        // else completed with error

    DWORD BytesReceived;                // only valid if LastError == SUCCESS

    CHAR  DeviceName[MAX_DEVICE_NAME+1];


}RAS_SECURITY_INFO,*PRAS_SECURITY_INFO;

typedef DWORD (WINAPI *RASSECURITYPROC)();

//
// Called by third party DLL to notify the supervisor of termination of
// the security dialog
//

VOID WINAPI
RasSecurityDialogComplete(
    IN SECURITY_MESSAGE * pSecMsg       // Pointer to the above info. structure
);

//
// Called by supervisor into the security DLL to notify it to begin the
// security dialog for a client.
//
// Should return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogBegin(
    IN HPORT  hPort,        // RAS handle to port
    IN PBYTE  pSendBuf,     // Pointer to the buffer used in
                            // RasSecurityDialogSend
    IN DWORD  SendBufSize,  // Size of above bufer in bytes
    IN PBYTE  pRecvBuf,     // Pointer to the buffer used in
                            // RasSecurityDialogReceive
    IN DWORD  RecvBufSize,  // Size of above buffer
    IN VOID  (WINAPI *RasSecurityDialogComplete)( SECURITY_MESSAGE* )
                            // Pointer to function RasSecurityDialogComplete.
                            // Guaranteed to be the same on every call.
);

//
// Called by supervisor into the security DLL to notify it to stop the
// security dialog for a client. If this call returns an error, then it is not
// neccesary for the dll to call RasSecurityDialogComplete. Otherwise the DLL
// must call RasSecurityDialogComplete.
//
// Should return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogEnd(
    IN HPORT    hPort           // RAS handle to port.
);

//
// The following entrypoints should be loaded by calling GetProcAddress from
// RasMan.lib
//
// Called to send data to remote host
// Will return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogSend(
    IN HPORT    hPort,          // RAS handle to port.
    IN PBYTE    pBuffer,        // Pointer to buffer containing data to send
    IN WORD     BufferLength    // Length of above buffer.
);

//
// Called to receive data from remote host
// Will return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogReceive(
    IN HPORT    hPort,          // RAS handle to port.
    IN PBYTE    pBuffer,        // Pointer to buffer to receive data
    IN PWORD    pBufferLength,  // length of data received in bytes.
    IN DWORD    Timeout,        // in seconds
    IN HANDLE   hEvent          // Event to set when receive completes or
                                // timeouts
);

//
// Called to get Information about port.
// Will return errors from winerror.h or raserror.h
//

DWORD WINAPI
RasSecurityDialogGetInfo(
    IN HPORT                hPort,      // RAS handle to port.
    IN RAS_SECURITY_INFO*   pBuffer     // Pointer to get info structure.
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Raseapif.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    raseapif.h

Abstract:

    Defines interface between a third party authentication module
    and the Remote Access Service PPP engine.

--*/

#ifndef _RASEAPIF_
#define _RASEAPIF_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if(WINVER >= 0x0500)

//
// Defines used for installtion of EAP DLL
//
// Custom EAP DLL (ex. Name=Sample.dll, Type=(decimal 40) regsitry installation)
//
// HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Rasman\PPP\EAP\40)
//      Path                (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      ConfigUIPath        (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      InteractiveUIPath   (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      IdentityPath        (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      FriendlyName        (REG_SZ) Sample EAP Protocol
//      RequireConfigUI     (REG_DWORD)     1
//      ConfigCLSID         (REG_SZ)        {0000031A-0000-0000-C000-000000000046}
//      StandaloneSupported (REG_DWORD)     1
//

#define RAS_EAP_REGISTRY_LOCATION   \
    TEXT("System\\CurrentControlSet\\Services\\Rasman\\PPP\\EAP")

#define RAS_EAP_VALUENAME_PATH                  TEXT("Path")
#define RAS_EAP_VALUENAME_CONFIGUI              TEXT("ConfigUIPath")
#define RAS_EAP_VALUENAME_INTERACTIVEUI         TEXT("InteractiveUIPath")
#define RAS_EAP_VALUENAME_IDENTITY              TEXT("IdentityPath")
#define RAS_EAP_VALUENAME_FRIENDLY_NAME         TEXT("FriendlyName")
#define RAS_EAP_VALUENAME_DEFAULT_DATA          TEXT("ConfigData")
#define RAS_EAP_VALUENAME_REQUIRE_CONFIGUI      TEXT("RequireConfigUI")
#define RAS_EAP_VALUENAME_ENCRYPTION            TEXT("MPPEEncryptionSupported")
#define RAS_EAP_VALUENAME_INVOKE_NAMEDLG        TEXT("InvokeUsernameDialog")
#define RAS_EAP_VALUENAME_INVOKE_PWDDLG         TEXT("InvokePasswordDialog")
#define RAS_EAP_VALUENAME_CONFIG_CLSID          TEXT("ConfigCLSID")
#define RAS_EAP_VALUENAME_STANDALONE_SUPPORTED  TEXT("StandaloneSupported")
#define RAS_EAP_VALUENAME_ROLES_SUPPORTED       TEXT("RolesSupported")
#define RAS_EAP_VALUENAME_PER_POLICY_CONFIG     TEXT("PerPolicyConfig")
#define RAS_EAP_VALUENAME_ISTUNNEL_METHOD       TEXT("IsTunnelMethod")
#define RAS_EAP_VALUENAME_FILTER_INNERMETHODS   TEXT("FilterInnerMethods")


// Flags for RolesSupported.
#define RAS_EAP_ROLE_AUTHENTICATOR   0x00000001
#define RAS_EAP_ROLE_AUTHENTICATEE   0x00000002

//
// Following flags describe the hosting of EAP
// methods in PEAP or in EAP.  If this role is
// missing the default behavior is to show the
// EAP method in PEAP and in EAP.
//
#define RAS_EAP_ROLE_EXCLUDE_IN_EAP  0x00000004
#define RAS_EAP_ROLE_EXCLUDE_IN_PEAP 0x00000008
#define RAS_EAP_ROLE_EXCLUDE_IN_VPN  0x00000010

typedef enum _RAS_AUTH_ATTRIBUTE_TYPE_
{
    raatMinimum = 0,                // Undefined
    raatUserName,                   // Value field is a Pointer
    raatUserPassword,               // Value field is a Pointer
    raatMD5CHAPPassword,            // Value field is a Pointer
    raatNASIPAddress,               // Value field is a 32 bit integral value
    raatNASPort,                    // Value field is a 32 bit integral value
    raatServiceType,                // Value field is a 32 bit integral value
    raatFramedProtocol,             // Value field is a 32 bit integral value
    raatFramedIPAddress,            // Value field is a 32 bit integral value
    raatFramedIPNetmask,            // Value field is a 32 bit integral value
    raatFramedRouting = 10,         // Value field is a 32 bit integral value
    raatFilterId,                   // Value field is a Pointer
    raatFramedMTU,                  // Value field is a 32 bit integral value
    raatFramedCompression,          // Value field is a 32 bit integral value
    raatLoginIPHost,                // Value field is a 32 bit integral value
    raatLoginService,               // Value field is a 32 bit integral value
    raatLoginTCPPort,               // Value field is a 32 bit integral value
    raatUnassigned17,               // Undefined
    raatReplyMessage,               // Value field is a Pointer
    raatCallbackNumber,             // Value field is a Pointer
    raatCallbackId =20,             // Value field is a Pointer
    raatUnassigned21,               // Undefined
    raatFramedRoute,                // Value field is a Pointer
    raatFramedIPXNetwork,           // Value field is a 32 bit integral value
    raatState,                      // Value field is a Pointer
    raatClass,                      // Value field is a Pointer
    raatVendorSpecific,             // Value field is a Pointer
    raatSessionTimeout,             // Value field is a 32 bit integral value
    raatIdleTimeout,                // Value field is a 32 bit integral value
    raatTerminationAction,          // Value field is a 32 bit integral value
    raatCalledStationId = 30,       // Value field is a Pointer
    raatCallingStationId,           // Value field is a Pointer
    raatNASIdentifier,              // Value field is a Pointer
    raatProxyState,                 // Value field is a Pointer
    raatLoginLATService,            // Value field is a Pointer
    raatLoginLATNode,               // Value field is a Pointer
    raatLoginLATGroup,              // Value field is a Pointer
    raatFramedAppleTalkLink,        // Value field is a 32 bit integral value
    raatFramedAppleTalkNetwork,     // Value field is a 32 bit integral value
    raatFramedAppleTalkZone,        // Value field is a Pointer
    raatAcctStatusType = 40,        // Value field is a 32 bit integral value
    raatAcctDelayTime,              // Value field is a 32 bit integral value
    raatAcctInputOctets,            // Value field is a 32 bit integral value
    raatAcctOutputOctets,           // Value field is a 32 bit integral value
    raatAcctSessionId,              // Value field is a Pointer
    raatAcctAuthentic,              // Value field is a 32 bit integral value
    raatAcctSessionTime,            // Value field is a 32 bit integral value
    raatAcctInputPackets,           // Value field is a 32 bit integral value
    raatAcctOutputPackets,          // Value field is a 32 bit integral value
    raatAcctTerminateCause,         // Value field is a 32 bit integral value
    raatAcctMultiSessionId = 50,    // Value field is a Pointer
    raatAcctLinkCount,              // Value field is a 32 bit integral value
    raatAcctEventTimeStamp = 55,    // Value field is a 32 bit integral value
    raatMD5CHAPChallenge = 60,      // Value field is a Pointer
    raatNASPortType,                // Value field is a 32 bit integral value
    raatPortLimit,                  // Value field is a 32 bit integral value
    raatLoginLATPort,               // Value field is a Pointer
    raatTunnelType,                 // Value field is a 32 bit integral value
    raatTunnelMediumType,           // Value field is a 32 bit integral value
    raatTunnelClientEndpoint,       // Value field is a Pointer
    raatTunnelServerEndpoint,       // Value field is a Pointer
    raatARAPPassword = 70,          // Value field is a Pointer
    raatARAPFeatures,               // Value field is a Pointer
    raatARAPZoneAccess,             // Value field is a 32 bit integral value
    raatARAPSecurity,               // Value field is a 32 bit integral value
    raatARAPSecurityData,           // Value field is a Pointer
    raatPasswordRetry,              // Value field is a 32 bit integral value
    raatPrompt,                     // Value field is a 32 bit integral value
    raatConnectInfo,                // Value field is a Pointer
    raatConfigurationToken,         // Value field is a Pointer
    raatEAPMessage,                 // Value field is a Pointer
    raatSignature = 80,             // Value field is a Pointer
    raatARAPChallengeResponse = 84, // Value field is a Pointer
    raatAcctInterimInterval = 85,   // Value field is a 32 bit integral value
    raatNASIPv6Address = 95,
    raatFramedInterfaceId,
    raatFramedIPv6Prefix,
    raatLoginIPv6Host,
    raatFramedIPv6Route,
    raatFramedIPv6Pool,
    raatARAPGuestLogon = 8096,      // Value field is a 32 bit integral value
    raatCertificateOID,             // Value field is a Pointer
    raatEAPConfiguration,           // Value field is a Pointer
    raatPEAPEmbeddedEAPTypeId,      // Value field is a 32 bit integral value
    raatPEAPFastRoamedSession,      // Value field is a 32 bit integral value
    raatEAPTLV = 8102,              // Value field is a Pointer
    raatCredentialsChanged,         // Value field is a Integer with boolean semantics
    raatPeerId = 9000,              // Value field is a pointer
    raatServerId,                   // Value field is a pointer
    raatMethodId,                   // Value field is a pointer
    raatEMSK,                       // Value field is a pointer
    raatSessionId,                  // Value field is a pointer
    raatReserved = 0xFFFFFFFF       // Undefined

}RAS_AUTH_ATTRIBUTE_TYPE;


//
// VSA attribute ids for ARAP
//
#define  raatARAPChallenge              33
#define  raatARAPOldPassword            19
#define  raatARAPNewPassword            20
#define  raatARAPPasswordChangeReason   21

//
// Value is set to the 32 bit integral value or a pointer to data.
// 32 bit integral values should be in host format, not network format.
// Length for a 32 bit integral value can be 1, 2 or 4. The array of
// attributes must be terminated with an attribute of type raatMinimum.
//

typedef struct _RAS_AUTH_ATTRIBUTE
{
    RAS_AUTH_ATTRIBUTE_TYPE raaType;
    DWORD                   dwLength;
    __field_ecount(dwLength) PVOID                   Value;

}RAS_AUTH_ATTRIBUTE, *PRAS_AUTH_ATTRIBUTE;

//
// EAP packet codes from EAP spec.
//

#define EAPCODE_Request         1
#define EAPCODE_Response        2
#define EAPCODE_Success         3
#define EAPCODE_Failure         4

#define MAXEAPCODE              4

//
// Values of the fFlags field in PPP_EAP_INPUT
// These have the same values as the RASEAPF_ flags in ras.h
//

#define RAS_EAP_FLAG_ROUTER                 0x00000001  // This is a router
#define RAS_EAP_FLAG_NON_INTERACTIVE        0x00000002  // No UI should be displayed
#define RAS_EAP_FLAG_LOGON                  0x00000004  // The user data was
                                                        // obtained from Winlogon
#define RAS_EAP_FLAG_PREVIEW                0x00000008  // User has checked
                                                        // "Prompt for information
                                                        // before dialing"
#define RAS_EAP_FLAG_FIRST_LINK             0x00000010  // This is the first link
#define RAS_EAP_FLAG_MACHINE_AUTH           0x00000020  // Use the default machine cert
                                                        // or user cert based on the
                                                        // application logon context
#define RAS_EAP_FLAG_GUEST_ACCESS           0x00000040  // Request to provide guest
                                                        // access.
#define RAS_EAP_FLAG_8021X_AUTH             0x00000080  // Anything specific to 8021x
                                                        // to be done in TLS
#define RAS_EAP_FLAG_HOSTED_IN_PEAP         0x00000100  // This EAP Method is hosted
                                                        // in PEAP
#define RAS_EAP_FLAG_RESUME_FROM_HIBERNATE  0x00000200  // Indicates this is the
                                                        // first call after m/c
                                                        // resumed from hibernation.
#define RAS_EAP_FLAG_PEAP_UPFRONT           0x00000400  // Indicate peap is enabled
                                                        // at the beginning of IAS pipeline.
#define RAS_EAP_FLAG_ALTERNATIVE_USER_DB    0x00000800  // The user database is
                                                        // not active directory
#define RAS_EAP_FLAG_PEAP_FORCE_FULL_AUTH   0x00001000  // Indicate peap should not
                                                        //fast reconnect

#define RAS_EAP_FLAG_PRE_LOGON              0x00020000  // Pre logon scenario like PLAP


#define RAS_EAP_FLAG_RESERVED               0x00100000   // PEAP specific flag

#define RAS_EAP_FLAG_SAVE_CREDMAN           0x00200000   // Save credentials to CredMan

typedef struct _PPP_EAP_PACKET
{
    BYTE    Code;       // 1-Request, 2-Response, 3-Success, 4-Failure

    BYTE    Id;         // Id of this packet

    BYTE    Length[2];  // Length of this packet

    BYTE    Data[1];    // Data - First byte is Type for Request/Response

}PPP_EAP_PACKET, *PPPP_EAP_PACKET;

#define PPP_EAP_PACKET_HDR_LEN  ( sizeof( PPP_EAP_PACKET ) - 1 )

//
// Interface structure between the engine and APs. This is passed to the
// AP's via the RasCpBegin call.
//

typedef struct _PPP_EAP_INPUT
{
    //
    // Size of this structure
    //

    DWORD       dwSizeInBytes;

    //
    // The following five fields are valid only in RasEapBegin call
    //

    DWORD       fFlags;         // See RAS_EAP_FLAG_*

    BOOL        fAuthenticator; // Act as authenticator or authenticatee

    WCHAR *     pwszIdentity;   // Users's identity

    WCHAR *     pwszPassword;   // Client's account password. Only valid when
                                // fAuthenticator is FALSE.

    BYTE        bInitialId;     // Initial packet identifier. Must be used for
                                // the first EAP packet sent by the DLL and
                                // incremented by one for each subsequent
                                // request packet.

    //
    // During the RasEapBegin call on the authenticator side, pUserAttributes
    // contains the set of attributes for the currently dialed in user, e.g.,
    // the port used, NAS IP Address, etc.
    //
    // When the fAuthenticationComplete flag is TRUE, pUserAttributes contains
    // attributes (if any) returned by the authentication provider.
    //
    // This memory is not owned by the EAP DLL and should be treated as
    // read-only.
    //

    RAS_AUTH_ATTRIBUTE * pUserAttributes;

    //
    // The next two fields are used only if the EAP DLL is using the
    // currently configured authentication provider ex: RADIUS or Windows NT
    // domain authentication, and the fAuthenticator field above is set to
    // TRUE.
    //

    //
    // Indicates that the authenticator has completed authentication.
    // Ignore this field if an authentication provider is not being used.
    //

    BOOL                fAuthenticationComplete;

    //
    // Result of the authentication process by the authentication provider.
    // NO_ERROR indicates success, otherwise it is a value from winerror.h,
    // raserror.h or mprerror.h indicating failure reason.
    //

    DWORD               dwAuthResultCode;

    //
    // Valid only on the authenticatee side. This may be used on the
    // authenticatee side to impersonate the user being authenticated.
    //

    OPTIONAL HANDLE     hTokenImpersonateUser;

    //
    // This variable should be examined only by the authenticatee side.
    // The EAP specification states that the success packet may be lost and
    // since it is a non-acknowledged packet, reception of an NCP packet should
    // be interpreted as a success packet. This varable is set to TRUE in this
    // case only on the authenticatee side
    //

    BOOL                fSuccessPacketReceived;

    //
    // Will be set to TRUE only when the user dismissed the interactive
    // UI that was invoked by the EAP dll
    //

    BOOL                fDataReceivedFromInteractiveUI;

    //
    // Data received from the Interactive UI. Will be set to
    // non-NULL when fDataReceivedFromInteractiveUI is set to TRUE and
    // RasEapInvokeInteractiveUI returned non-NULL data. This buffer will be
    // freed by the PPP engine on return from the RasEapMakeMessage call. A
    // copy of this data should be made in the EAP Dll's memory space.
    //

    OPTIONAL PBYTE      pDataFromInteractiveUI;

    //
    // Size in bytes of data pointed to by pInteractiveConnectionData. This may
    // be 0 if there was no data passed back by RasEapInvokeInteractiveUI.
    //

    DWORD               dwSizeOfDataFromInteractiveUI;

    //
    // Connection data received from the Config UI. Will be set to non-NULL
    // when the RasEapBegin call is made and the RasEapInvokeConfigUI
    // returned non-NULL data. This buffer will be freed by the PPP engine
    // on return from the RasEapBegin call. A copy of this data should
    // be made in the EAP Dll's memory space.
    //

    OPTIONAL PBYTE      pConnectionData;

    //
    // Size in bytes of data pointed to by pConnectionData. This may be
    // 0 if there was no data passed back by the RasEapInvokeConfigUI call.
    //

    DWORD               dwSizeOfConnectionData;

    //
    // User data received from the Identity UI or Interactive UI. Will be set
    // to non-NULL when the RasEapBegin call is made if such data exists.
    // This buffer will be freed by the PPP engine on return from the
    // RasEapBegin call. A copy of this data should be made in the EAP Dll's
    // memory space.
    //

    __field_bcount(dwSizeOfUserData) OPTIONAL PBYTE      pUserData;

    //
    // Size in bytes of data pointed to by pUserData. This may be 0 if there
    // is no data.
    //

    DWORD               dwSizeOfUserData;

    //
    // Reserved.
    //

    HANDLE              hReserved;

}PPP_EAP_INPUT, *PPPP_EAP_INPUT;

typedef enum _PPP_EAP_ACTION
{
    //
    // These actions are provided by the EAP DLL as output from the
    // RasEapMakeMessage API.  They tell the PPP engine what action (if any) to
    // take on the EAP DLL's behalf, and eventually inform the engine that the
    // EAP DLL has finished authentication.
    //

    EAPACTION_NoAction,     // Be passive, i.e. listen without timeout (default)
    EAPACTION_Authenticate, // Invoke the back-end authenticator.
    EAPACTION_Done,         // End auth session, dwAuthResultCode is set
    EAPACTION_SendAndDone,  // As above but send message without timeout first
    EAPACTION_Send,         // Send message, don't timeout waiting for reply
    EAPACTION_SendWithTimeout, // Send message, timeout if reply not received
    EAPACTION_SendWithTimeoutInteractive,  // As above, but don't increment
                                           // retry count

	EAPACTION_IndicateTLV,		// Do not use
	EAPACTION_IndicateIdentity	// Do not use
}PPP_EAP_ACTION;

typedef struct _PPP_EAP_OUTPUT
{
    //
    // Size of this structure
    //

    DWORD                   dwSizeInBytes;

    //
    // Action that the PPP engine should take
    //

    PPP_EAP_ACTION          Action;

    //
    // dwAuthResultCode is valid only with an Action code of Done or
    // SendAndDone. Zero value indicates succesful authentication.
    // Non-zero indicates unsuccessful authentication with the value
    // indicating the reason for authentication failure.
    // Non-zero return codes should be only from winerror.h, raserror.h and
    // mprerror.h
    //

    DWORD                   dwAuthResultCode;

    //
    // When Action is EAPACTION_Authenticate, pUserAttributes may contain
    // additional attributes necessary to authenticate the user, e.g.,
    // User-Password. If no credentials are presented, the back-end
    // authenticator will assume the user is authentic and only retrieve
    // authorizations.
    //
    // When Action is EAPACTION_Done, EAPACTION_SendAndDone, or EAPACTION_Send,
    // pUserAttributes may contain additional attributes for the user. These
    // attributes will overwrite any attributes of the same type returned by
    // the back-end authenticator.
    //
    // It is up to the EAP DLL to free this memory in RasEapEnd call.
    //

    OPTIONAL RAS_AUTH_ATTRIBUTE * pUserAttributes;
    //
    // Flag set to true will cause the RasEapInvokeInteractiveUI call to be
    // made.
    //

    BOOL                    fInvokeInteractiveUI;

    //
    // Pointer to context data, if any, to be sent to the UI. The EAP dll
    // is responsible for freeing this buffer in the RasEapEnd call or when
    // a response from the user for this invocation is obtained.
    //

    OPTIONAL PBYTE          pUIContextData;

    //
    // Size in bytes of the data pointed to by pUIContextData. Ignored if
    // pUIContextData is NULL
    //

    DWORD                   dwSizeOfUIContextData;

    //
    // When set to TRUE, indicates that the information pointed to by
    // pConnectionData should be saved in the phonebook. Only valid on
    // the authenticatee side.
    //

    BOOL                    fSaveConnectionData;

    //
    // If fSaveConnectionData above is true, the data pointed to by
    // pConnectionData will be saved in the phonebook. This data
    // must be freed by the DLL when the RasEapEnd call is made.
    //

    OPTIONAL PBYTE          pConnectionData;

    //
    // Size, in bytes, of the data pointed to by pConnectionData
    //

    DWORD                   dwSizeOfConnectionData;

    //
    // When set to TRUE, indicates that the information pointed to by
    // pUserData should be saved in the registry for this user. Only valid
    // on the authenticatee side.
    //

    BOOL                    fSaveUserData;

    //
    // If fSaveUserData above is true, the data pointed to by pUserData will be
    // saved in the registry for this user. This data must be freed by the DLL
    // when the RasEapEnd call is made.
    //

    OPTIONAL PBYTE          pUserData;

    //
    // Size, in bytes, of the data pointed to by pUserData
    //

    DWORD                   dwSizeOfUserData;

}PPP_EAP_OUTPUT, *PPPP_EAP_OUTPUT;

typedef struct _PPP_EAP_INFO
{
    //
    // Size of this structure
    //

    DWORD   dwSizeInBytes;

    DWORD   dwEapTypeId;

    //
    // Called to initialize/uninitialize this module. This will be called before
    // any other call is made. fInitialize will be TRUE iff the module has to be
    // initialized. Must return errorcodes only from winerror.h, raserror.h or
    // mprerror.h
    //

    DWORD   (APIENTRY *RasEapInitialize)(   IN  BOOL        fInitialize );

    //
    // Called to get a context buffer for this EAP session and pass
    // initialization information. This will be called before any other
    // call is made, except RasEapInitialize. Must return errorcodes only from
    // winerror.h, raserror.h or mprerror.h
    //

    DWORD   (APIENTRY *RasEapBegin)( OUT VOID **             ppWorkBuffer,
                                     IN  PPP_EAP_INPUT *     pPppEapInput );

    //
    // Called to free the context buffer for this EAP session.
    // Called after this session is completed successfully or not, provided
    // the RasEapBegin call for this EAP session returned successfully.
    // Must return errorcodes only from winerror.h, raserror.h or mprerror.h
    //

    DWORD   (APIENTRY *RasEapEnd)(   IN  VOID *     pWorkBuffer );

    //
    // Called to process an incomming packet and/or send a packet.
    // cbSendPacket is the size in bytes of the buffer pointed to by
    // pSendPacket. Must return errorcodes only from winerror.h, raserror.h or
    // mprerror.h. Error return code indicates an error occurance during the
    // authentication process.
    //

    DWORD   (APIENTRY *RasEapMakeMessage)(
                            IN  VOID*               pWorkBuf,
                            IN  PPP_EAP_PACKET*     pReceivePacket,
                            OUT PPP_EAP_PACKET*     pSendPacket,
                            IN  DWORD               cbSendPacket,
                            OUT PPP_EAP_OUTPUT*     pEapOutput,
                            IN  PPP_EAP_INPUT*      pEapInput );

}PPP_EAP_INFO, *PPPP_EAP_INFO;

//
// RasEapGetInfo should be exported by the 3rd party EAP dll installed in the
// registry via the Path value.
//

DWORD APIENTRY
RasEapGetInfo(
    IN  DWORD           dwEapTypeId,
    OUT PPP_EAP_INFO*   pEapInfo
);

//
// RasEapFreeMemory should be exported by the 3rd party EAP dlls installed in
// the registry via the InteractiveUIPath, ConfigUIPath, and IdentityPath
// values.
//

DWORD APIENTRY
RasEapFreeMemory(
    IN  BYTE*           pMemory
);

//
// RasEapInvokeInteractiveUI and RasEapFreeMemory should be exported by the
// 3rd party EAP dll installed in the registry via the InteractiveUIPath
// value.
//

DWORD APIENTRY
RasEapInvokeInteractiveUI(
    IN  DWORD           dwEapTypeId,
    IN  HWND            hwndParent,
    IN  BYTE*           pUIContextData,
    IN  DWORD           dwSizeOfUIContextData,
    OUT BYTE**          ppDataFromInteractiveUI,
    OUT DWORD*          pdwSizeOfDataFromInteractiveUI
);

//
// RasEapInvokeConfigUI and RasEapFreeMemory should be exported by the
// 3rd party EAP dll installed in the registry via the ConfigUIPath value.
//

DWORD APIENTRY
RasEapInvokeConfigUI(
    IN  DWORD           dwEapTypeId,
    IN  HWND            hwndParent,
    IN  DWORD           dwFlags,
    IN  BYTE*           pConnectionDataIn,
    IN  DWORD           dwSizeOfConnectionDataIn,
    OUT BYTE**          ppConnectionDataOut,
    OUT DWORD*          pdwSizeOfConnectionDataOut
);

//
// RasEapGetIdentity and RasEapFreeMemory should be exported by the
// 3rd party EAP dll installed in the registry via the IdentityPath value.
//

DWORD APIENTRY
RasEapGetIdentity(
    IN  DWORD           dwEapTypeId,
    IN  HWND            hwndParent,
    IN  DWORD           dwFlags,
    IN  const WCHAR*    pwszPhonebook,
    IN  const WCHAR*    pwszEntry,
    IN  BYTE*           pConnectionDataIn,
    IN  DWORD           dwSizeOfConnectionDataIn,
    IN  BYTE*           pUserDataIn,
    IN  DWORD           dwSizeOfUserDataIn,
    OUT BYTE**          ppUserDataOut,
    OUT DWORD*          pdwSizeOfUserDataOut,
    OUT __deref_out     WCHAR** ppwszIdentityOut
);

#endif /* WINVER >= 0x0500 */

#ifdef __cplusplus
}
#endif

#endif // _RASEAPIF_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\rdpencomapi_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for rdpencomapi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIDebug,0xaa1e42b5,0x496d,0x4ca4,0xa6,0x90,0x34,0x8d,0xcb,0x2e,0xc4,0xad);


MIDL_DEFINE_GUID(IID, LIBID_RDPCOMAPILib,0xCC802D05,0xAE07,0x4C15,0xB4,0x96,0xDB,0x9D,0x22,0xAA,0x0A,0x84);


MIDL_DEFINE_GUID(IID, DIID__IRDPSessionEvents,0x98a97042,0x6698,0x40e9,0x8e,0xfd,0xb3,0x20,0x09,0x90,0x00,0x4b);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIApplication,0x41e7a09d,0xeb7a,0x436e,0x93,0x5d,0x78,0x0c,0xa2,0x62,0x83,0x24);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIWindow,0xbeafe0f9,0xc77b,0x4933,0xba,0x9f,0xa2,0x4c,0xdd,0xcc,0x27,0xcf);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIWindowList,0x8a05ce44,0x715a,0x4116,0xa1,0x89,0xa1,0x18,0xf3,0x0a,0x07,0xbd);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIApplicationList,0xd4b4aeb3,0x22dc,0x4837,0xb3,0xb6,0x42,0xea,0x25,0x17,0x84,0x9a);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIApplicationFilter,0xd20f10ca,0x6637,0x4f06,0xb1,0xd5,0x27,0x7e,0xa7,0xe5,0x16,0x0d);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPISessionProperties,0x339b24f2,0x9bc0,0x4f16,0x9a,0xac,0xf1,0x65,0x43,0x3d,0x13,0xd4);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIInvitation,0x4fac1d43,0xfc51,0x45bb,0xb1,0xb4,0x2b,0x53,0xaa,0x56,0x2f,0xa3);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIInvitationManager,0x4722b049,0x92c3,0x4c2d,0x8a,0x65,0xf7,0x34,0x8f,0x64,0x4d,0xcf);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPITcpConnectionInfo,0xf74049a4,0x3d06,0x4028,0x81,0x93,0x0a,0x8c,0x29,0xbc,0x24,0x52);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIAttendee,0xec0671b3,0x1b78,0x4b80,0xa4,0x64,0x91,0x32,0x24,0x75,0x43,0xe3);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIAttendeeManager,0xba3a37e8,0x33da,0x4749,0x8d,0xa0,0x07,0xfa,0x34,0xda,0x79,0x44);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIAttendeeDisconnectInfo,0xc187689f,0x447c,0x44a1,0x9c,0x14,0xff,0xfb,0xb3,0xb7,0xec,0x17);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIVirtualChannel,0x05e12f95,0x28b3,0x4c9a,0x87,0x80,0xd0,0x24,0x85,0x74,0xa1,0xe0);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIVirtualChannelManager,0x0d11c661,0x5d0d,0x4ee4,0x89,0xdf,0x21,0x66,0xae,0x1f,0xdf,0xed);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPISharingSession,0xeeb20886,0xe470,0x4cf6,0x84,0x2b,0x27,0x39,0xc0,0xec,0x5c,0xfb);


MIDL_DEFINE_GUID(IID, IID_IRDPSRAPIViewer,0xc6bfcd38,0x8ce9,0x404d,0x8a,0xe8,0xf3,0x1d,0x00,0xc6,0x5c,0xb5);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPViewer,0x32be5ed2,0x5c86,0x480f,0xa9,0x14,0x0f,0xf8,0x88,0x5a,0x1b,0x3f);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSession,0x9B78F0E6,0x3E05,0x4A5B,0xB2,0xE8,0xE7,0x43,0xA8,0x95,0x6B,0x65);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPISessionProperties,0xdd7594ff,0xea2a,0x4c06,0x8f,0xdf,0x13,0x2d,0xe4,0x8b,0x65,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPIInvitationManager,0x53d9c9db,0x75ab,0x4271,0x94,0x8a,0x4c,0x4e,0xb3,0x6a,0x8f,0x2b);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPIInvitation,0x49174dc6,0x0731,0x4b5e,0x8e,0xe1,0x83,0xa6,0x3d,0x38,0x68,0xfa);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPIAttendeeManager,0xd7b13a01,0xf7d4,0x42a6,0x85,0x95,0x12,0xfc,0x8c,0x24,0xe8,0x51);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPIAttendee,0x74f93bb5,0x755f,0x488e,0x8a,0x29,0x23,0x90,0x10,0x8a,0xef,0x55);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPIAttendeeDisconnectInfo,0xb47d7250,0x5bdb,0x405d,0xb4,0x87,0xca,0xad,0x9c,0x56,0xf4,0xf8);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPIApplicationFilter,0xe35ace89,0xc7e8,0x427e,0xa4,0xf9,0xb9,0xda,0x07,0x28,0x26,0xbd);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPIApplicationList,0x9e31c815,0x7433,0x4876,0x97,0xfb,0xed,0x59,0xfe,0x2b,0xaa,0x22);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPIApplication,0xc116a484,0x4b25,0x4b9f,0x8a,0x54,0xb9,0x34,0xb0,0x6e,0x57,0xfa);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPIWindowList,0x9c21e2b8,0x5dd4,0x42cc,0x81,0xba,0x1c,0x09,0x98,0x52,0xe6,0xfa);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPIWindow,0x03cf46db,0xce45,0x4d36,0x86,0xed,0xed,0x28,0xb7,0x43,0x98,0xbf);


MIDL_DEFINE_GUID(CLSID, CLSID_RDPSRAPITcpConnectionInfo,0xbe49db3f,0xebb6,0x4278,0x8c,0xe0,0xd5,0x45,0x58,0x33,0xea,0xee);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\rdpencomapi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for rdpencomapi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rdpencomapi_h__
#define __rdpencomapi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IRDPSRAPIDebug_FWD_DEFINED__
#define __IRDPSRAPIDebug_FWD_DEFINED__
typedef interface IRDPSRAPIDebug IRDPSRAPIDebug;
#endif 	/* __IRDPSRAPIDebug_FWD_DEFINED__ */


#ifndef ___IRDPSessionEvents_FWD_DEFINED__
#define ___IRDPSessionEvents_FWD_DEFINED__
typedef interface _IRDPSessionEvents _IRDPSessionEvents;
#endif 	/* ___IRDPSessionEvents_FWD_DEFINED__ */


#ifndef __IRDPSRAPIApplication_FWD_DEFINED__
#define __IRDPSRAPIApplication_FWD_DEFINED__
typedef interface IRDPSRAPIApplication IRDPSRAPIApplication;
#endif 	/* __IRDPSRAPIApplication_FWD_DEFINED__ */


#ifndef __IRDPSRAPIWindow_FWD_DEFINED__
#define __IRDPSRAPIWindow_FWD_DEFINED__
typedef interface IRDPSRAPIWindow IRDPSRAPIWindow;
#endif 	/* __IRDPSRAPIWindow_FWD_DEFINED__ */


#ifndef __IRDPSRAPIWindowList_FWD_DEFINED__
#define __IRDPSRAPIWindowList_FWD_DEFINED__
typedef interface IRDPSRAPIWindowList IRDPSRAPIWindowList;
#endif 	/* __IRDPSRAPIWindowList_FWD_DEFINED__ */


#ifndef __IRDPSRAPIApplicationList_FWD_DEFINED__
#define __IRDPSRAPIApplicationList_FWD_DEFINED__
typedef interface IRDPSRAPIApplicationList IRDPSRAPIApplicationList;
#endif 	/* __IRDPSRAPIApplicationList_FWD_DEFINED__ */


#ifndef __IRDPSRAPIApplicationFilter_FWD_DEFINED__
#define __IRDPSRAPIApplicationFilter_FWD_DEFINED__
typedef interface IRDPSRAPIApplicationFilter IRDPSRAPIApplicationFilter;
#endif 	/* __IRDPSRAPIApplicationFilter_FWD_DEFINED__ */


#ifndef __IRDPSRAPISessionProperties_FWD_DEFINED__
#define __IRDPSRAPISessionProperties_FWD_DEFINED__
typedef interface IRDPSRAPISessionProperties IRDPSRAPISessionProperties;
#endif 	/* __IRDPSRAPISessionProperties_FWD_DEFINED__ */


#ifndef __IRDPSRAPIInvitation_FWD_DEFINED__
#define __IRDPSRAPIInvitation_FWD_DEFINED__
typedef interface IRDPSRAPIInvitation IRDPSRAPIInvitation;
#endif 	/* __IRDPSRAPIInvitation_FWD_DEFINED__ */


#ifndef __IRDPSRAPIInvitationManager_FWD_DEFINED__
#define __IRDPSRAPIInvitationManager_FWD_DEFINED__
typedef interface IRDPSRAPIInvitationManager IRDPSRAPIInvitationManager;
#endif 	/* __IRDPSRAPIInvitationManager_FWD_DEFINED__ */


#ifndef __IRDPSRAPITcpConnectionInfo_FWD_DEFINED__
#define __IRDPSRAPITcpConnectionInfo_FWD_DEFINED__
typedef interface IRDPSRAPITcpConnectionInfo IRDPSRAPITcpConnectionInfo;
#endif 	/* __IRDPSRAPITcpConnectionInfo_FWD_DEFINED__ */


#ifndef __IRDPSRAPIAttendee_FWD_DEFINED__
#define __IRDPSRAPIAttendee_FWD_DEFINED__
typedef interface IRDPSRAPIAttendee IRDPSRAPIAttendee;
#endif 	/* __IRDPSRAPIAttendee_FWD_DEFINED__ */


#ifndef __IRDPSRAPIAttendeeManager_FWD_DEFINED__
#define __IRDPSRAPIAttendeeManager_FWD_DEFINED__
typedef interface IRDPSRAPIAttendeeManager IRDPSRAPIAttendeeManager;
#endif 	/* __IRDPSRAPIAttendeeManager_FWD_DEFINED__ */


#ifndef __IRDPSRAPIAttendeeDisconnectInfo_FWD_DEFINED__
#define __IRDPSRAPIAttendeeDisconnectInfo_FWD_DEFINED__
typedef interface IRDPSRAPIAttendeeDisconnectInfo IRDPSRAPIAttendeeDisconnectInfo;
#endif 	/* __IRDPSRAPIAttendeeDisconnectInfo_FWD_DEFINED__ */


#ifndef __IRDPSRAPIVirtualChannel_FWD_DEFINED__
#define __IRDPSRAPIVirtualChannel_FWD_DEFINED__
typedef interface IRDPSRAPIVirtualChannel IRDPSRAPIVirtualChannel;
#endif 	/* __IRDPSRAPIVirtualChannel_FWD_DEFINED__ */


#ifndef __IRDPSRAPIVirtualChannelManager_FWD_DEFINED__
#define __IRDPSRAPIVirtualChannelManager_FWD_DEFINED__
typedef interface IRDPSRAPIVirtualChannelManager IRDPSRAPIVirtualChannelManager;
#endif 	/* __IRDPSRAPIVirtualChannelManager_FWD_DEFINED__ */


#ifndef __IRDPSRAPISharingSession_FWD_DEFINED__
#define __IRDPSRAPISharingSession_FWD_DEFINED__
typedef interface IRDPSRAPISharingSession IRDPSRAPISharingSession;
#endif 	/* __IRDPSRAPISharingSession_FWD_DEFINED__ */


#ifndef __IRDPSRAPIViewer_FWD_DEFINED__
#define __IRDPSRAPIViewer_FWD_DEFINED__
typedef interface IRDPSRAPIViewer IRDPSRAPIViewer;
#endif 	/* __IRDPSRAPIViewer_FWD_DEFINED__ */


#ifndef __RDPViewer_FWD_DEFINED__
#define __RDPViewer_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPViewer RDPViewer;
#else
typedef struct RDPViewer RDPViewer;
#endif /* __cplusplus */

#endif 	/* __RDPViewer_FWD_DEFINED__ */


#ifndef __RDPSession_FWD_DEFINED__
#define __RDPSession_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSession RDPSession;
#else
typedef struct RDPSession RDPSession;
#endif /* __cplusplus */

#endif 	/* __RDPSession_FWD_DEFINED__ */


#ifndef __RDPSRAPISessionProperties_FWD_DEFINED__
#define __RDPSRAPISessionProperties_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPISessionProperties RDPSRAPISessionProperties;
#else
typedef struct RDPSRAPISessionProperties RDPSRAPISessionProperties;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPISessionProperties_FWD_DEFINED__ */


#ifndef __RDPSRAPIInvitationManager_FWD_DEFINED__
#define __RDPSRAPIInvitationManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPIInvitationManager RDPSRAPIInvitationManager;
#else
typedef struct RDPSRAPIInvitationManager RDPSRAPIInvitationManager;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPIInvitationManager_FWD_DEFINED__ */


#ifndef __RDPSRAPIInvitation_FWD_DEFINED__
#define __RDPSRAPIInvitation_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPIInvitation RDPSRAPIInvitation;
#else
typedef struct RDPSRAPIInvitation RDPSRAPIInvitation;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPIInvitation_FWD_DEFINED__ */


#ifndef __RDPSRAPIAttendeeManager_FWD_DEFINED__
#define __RDPSRAPIAttendeeManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPIAttendeeManager RDPSRAPIAttendeeManager;
#else
typedef struct RDPSRAPIAttendeeManager RDPSRAPIAttendeeManager;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPIAttendeeManager_FWD_DEFINED__ */


#ifndef __RDPSRAPIAttendee_FWD_DEFINED__
#define __RDPSRAPIAttendee_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPIAttendee RDPSRAPIAttendee;
#else
typedef struct RDPSRAPIAttendee RDPSRAPIAttendee;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPIAttendee_FWD_DEFINED__ */


#ifndef __RDPSRAPIAttendeeDisconnectInfo_FWD_DEFINED__
#define __RDPSRAPIAttendeeDisconnectInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPIAttendeeDisconnectInfo RDPSRAPIAttendeeDisconnectInfo;
#else
typedef struct RDPSRAPIAttendeeDisconnectInfo RDPSRAPIAttendeeDisconnectInfo;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPIAttendeeDisconnectInfo_FWD_DEFINED__ */


#ifndef __RDPSRAPIApplicationFilter_FWD_DEFINED__
#define __RDPSRAPIApplicationFilter_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPIApplicationFilter RDPSRAPIApplicationFilter;
#else
typedef struct RDPSRAPIApplicationFilter RDPSRAPIApplicationFilter;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPIApplicationFilter_FWD_DEFINED__ */


#ifndef __RDPSRAPIApplicationList_FWD_DEFINED__
#define __RDPSRAPIApplicationList_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPIApplicationList RDPSRAPIApplicationList;
#else
typedef struct RDPSRAPIApplicationList RDPSRAPIApplicationList;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPIApplicationList_FWD_DEFINED__ */


#ifndef __RDPSRAPIApplication_FWD_DEFINED__
#define __RDPSRAPIApplication_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPIApplication RDPSRAPIApplication;
#else
typedef struct RDPSRAPIApplication RDPSRAPIApplication;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPIApplication_FWD_DEFINED__ */


#ifndef __RDPSRAPIWindowList_FWD_DEFINED__
#define __RDPSRAPIWindowList_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPIWindowList RDPSRAPIWindowList;
#else
typedef struct RDPSRAPIWindowList RDPSRAPIWindowList;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPIWindowList_FWD_DEFINED__ */


#ifndef __RDPSRAPIWindow_FWD_DEFINED__
#define __RDPSRAPIWindow_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPIWindow RDPSRAPIWindow;
#else
typedef struct RDPSRAPIWindow RDPSRAPIWindow;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPIWindow_FWD_DEFINED__ */


#ifndef __RDPSRAPITcpConnectionInfo_FWD_DEFINED__
#define __RDPSRAPITcpConnectionInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class RDPSRAPITcpConnectionInfo RDPSRAPITcpConnectionInfo;
#else
typedef struct RDPSRAPITcpConnectionInfo RDPSRAPITcpConnectionInfo;
#endif /* __cplusplus */

#endif 	/* __RDPSRAPITcpConnectionInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_rdpencomapi_0000_0000 */
/* [local] */ 

#define	DISPID_RDPSRAPI_METHOD_OPEN	( 100 )

#define	DISPID_RDPSRAPI_METHOD_CLOSE	( 101 )

#define	DISPID_RDPSRAPI_METHOD_SETSHAREDRECT	( 102 )

#define	DISPID_RDPSRAPI_METHOD_GETSHAREDRECT	( 103 )

#define	DISPID_RDPSRAPI_METHOD_VIEWERCONNECT	( 104 )

#define	DISPID_RDPSRAPI_METHOD_VIEWERDISCONNECT	( 105 )

#define	DISPID_RDPSRAPI_METHOD_TERMINATE_CONNECTION	( 106 )

#define	DISPID_RDPSRAPI_METHOD_CREATE_INVITATION	( 107 )

#define	DISPID_RDPSRAPI_METHOD_REQUEST_CONTROL	( 108 )

#define	DISPID_RDPSRAPI_METHOD_VIRTUAL_CHANNEL_CREATE	( 109 )

#define	DISPID_RDPSRAPI_METHOD_VIRTUAL_CHANNEL_SEND_DATA	( 110 )

#define	DISPID_RDPSRAPI_METHOD_VIRTUAL_CHANNEL_SET_ACCESS	( 111 )

#define	DISPID_RDPSRAPI_METHOD_PAUSE	( 112 )

#define	DISPID_RDPSRAPI_METHOD_RESUME	( 113 )

#define	DISPID_RDPSRAPI_METHOD_SHOW_WINDOW	( 114 )

#define	DISPID_RDPSRAPI_METHOD_REQUEST_COLOR_DEPTH_CHANGE	( 115 )

#define	DISPID_RDPSRAPI_METHOD_STARTREVCONNECTLISTENER	( 116 )

#define	DISPID_RDPSRAPI_METHOD_CONNECTTOCLIENT	( 117 )

#define	DISPID_RDPSRAPI_PROP_DISPIDVALUE	( 200 )

#define	DISPID_RDPSRAPI_PROP_ID	( 201 )

#define	DISPID_RDPSRAPI_PROP_SESSION_PROPERTIES	( 202 )

#define	DISPID_RDPSRAPI_PROP_ATTENDEES	( 203 )

#define	DISPID_RDPSRAPI_PROP_INVITATIONS	( 204 )

#define	DISPID_RDPSRAPI_PROP_INVITATION	( 205 )

#define	DISPID_RDPSRAPI_PROP_CHANNELMANAGER	( 206 )

#define	DISPID_RDPSRAPI_PROP_VIRTUAL_CHANNEL_GETNAME	( 207 )

#define	DISPID_RDPSRAPI_PROP_VIRTUAL_CHANNEL_GETFLAGS	( 208 )

#define	DISPID_RDPSRAPI_PROP_VIRTUAL_CHANNEL_GETPRIORITY	( 209 )

#define	DISPID_RDPSRAPI_PROP_WINDOWID	( 210 )

#define	DISPID_RDPSRAPI_PROP_APPLICATION	( 211 )

#define	DISPID_RDPSRAPI_PROP_WINDOWSHARED	( 212 )

#define	DISPID_RDPSRAPI_PROP_WINDOWNAME	( 213 )

#define	DISPID_RDPSRAPI_PROP_APPNAME	( 214 )

#define	DISPID_RDPSRAPI_PROP_APPLICATION_FILTER	( 215 )

#define	DISPID_RDPSRAPI_PROP_WINDOW_LIST	( 216 )

#define	DISPID_RDPSRAPI_PROP_APPLICATION_LIST	( 217 )

#define	DISPID_RDPSRAPI_PROP_APPFILTER_ENABLED	( 218 )

#define	DISPID_RDPSRAPI_PROP_APPFILTERENABLED	( 219 )

#define	DISPID_RDPSRAPI_PROP_SHARED	( 220 )

#define	DISPID_RDPSRAPI_PROP_INVITATIONITEM	( 221 )

#define	DISPID_RDPSRAPI_PROP_DBG_CLX_CMDLINE	( 222 )

#define	DISPID_RDPSRAPI_PROP_APPFLAGS	( 223 )

#define	DISPID_RDPSRAPI_PROP_WNDFLAGS	( 224 )

#define	DISPID_RDPSRAPI_PROP_PROTOCOL_TYPE	( 225 )

#define	DISPID_RDPSRAPI_PROP_LOCAL_PORT	( 226 )

#define	DISPID_RDPSRAPI_PROP_LOCAL_IP	( 227 )

#define	DISPID_RDPSRAPI_PROP_PEER_PORT	( 228 )

#define	DISPID_RDPSRAPI_PROP_PEER_IP	( 229 )

#define	DISPID_RDPSRAPI_PROP_ATTENDEE_FLAGS	( 230 )

#define	DISPID_RDPSRAPI_PROP_CONINFO	( 231 )

#define	DISPID_RDPSRAPI_PROP_CONNECTION_STRING	( 232 )

#define	DISPID_RDPSRAPI_PROP_GROUP_NAME	( 233 )

#define	DISPID_RDPSRAPI_PROP_PASSWORD	( 234 )

#define	DISPID_RDPSRAPI_PROP_ATTENDEELIMIT	( 235 )

#define	DISPID_RDPSRAPI_PROP_REVOKED	( 236 )

#define	DISPID_RDPSRAPI_PROP_DISCONNECTED_STRING	( 237 )

#define	DISPID_RDPSRAPI_PROP_USESMARTSIZING	( 238 )

#define	DISPID_RDPSRAPI_PROP_SESSION_COLORDEPTH	( 239 )

#define	DISPID_RDPSRAPI_PROP_REASON	( 240 )

#define	DISPID_RDPSRAPI_PROP_CODE	( 241 )

#define	DISPID_RDPSRAPI_PROP_CTRL_LEVEL	( 242 )

#define	DISPID_RDPSRAPI_PROP_REMOTENAME	( 243 )

#define	DISPID_RDPSRAPI_PROP_COUNT	( 244 )

#define	DISPID_RDPSRAPI_EVENT_ON_ATTENDEE_CONNECTED	( 301 )

#define	DISPID_RDPSRAPI_EVENT_ON_ATTENDEE_DISCONNECTED	( 302 )

#define	DISPID_RDPSRAPI_EVENT_ON_ATTENDEE_UPDATE	( 303 )

#define	DISPID_RDPSRAPI_EVENT_ON_ERROR	( 304 )

#define	DISPID_RDPSRAPI_EVENT_ON_VIEWER_CONNECTED	( 305 )

#define	DISPID_RDPSRAPI_EVENT_ON_VIEWER_DISCONNECTED	( 306 )

#define	DISPID_RDPSRAPI_EVENT_ON_VIEWER_AUTHENTICATED	( 307 )

#define	DISPID_RDPSRAPI_EVENT_ON_VIEWER_CONNECTFAILED	( 308 )

#define	DISPID_RDPSRAPI_EVENT_ON_CTRLLEVEL_CHANGE_REQUEST	( 309 )

#define	DISPID_RDPSRAPI_EVENT_ON_GRAPHICS_STREAM_PAUSED	( 310 )

#define	DISPID_RDPSRAPI_EVENT_ON_GRAPHICS_STREAM_RESUMED	( 311 )

#define	DISPID_RDPSRAPI_EVENT_ON_VIRTUAL_CHANNEL_JOIN	( 312 )

#define	DISPID_RDPSRAPI_EVENT_ON_VIRTUAL_CHANNEL_LEAVE	( 313 )

#define	DISPID_RDPSRAPI_EVENT_ON_VIRTUAL_CHANNEL_DATARECEIVED	( 314 )

#define	DISPID_RDPSRAPI_EVENT_ON_VIRTUAL_CHANNEL_SENDCOMPLETED	( 315 )

#define	DISPID_RDPSRAPI_EVENT_ON_APPLICATION_OPEN	( 316 )

#define	DISPID_RDPSRAPI_EVENT_ON_APPLICATION_CLOSE	( 317 )

#define	DISPID_RDPSRAPI_EVENT_ON_APPLICATION_UPDATE	( 318 )

#define	DISPID_RDPSRAPI_EVENT_ON_WINDOW_OPEN	( 319 )

#define	DISPID_RDPSRAPI_EVENT_ON_WINDOW_CLOSE	( 320 )

#define	DISPID_RDPSRAPI_EVENT_ON_WINDOW_UPDATE	( 321 )

#define	DISPID_RDPSRAPI_EVENT_ON_APPFILTER_UPDATE	( 322 )

#define	DISPID_RDPSRAPI_EVENT_ON_SHARED_RECT_CHANGED	( 323 )

#define	DISPID_RDPSRAPI_EVENT_ON_FOCUSRELEASED	( 324 )

#define	DISPID_RDPSRAPI_EVENT_ON_SHARED_DESKTOP_SETTINGS_CHANGED	( 325 )



extern RPC_IF_HANDLE __MIDL_itf_rdpencomapi_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rdpencomapi_0000_0000_v0_0_s_ifspec;

#ifndef __IRDPSRAPIDebug_INTERFACE_DEFINED__
#define __IRDPSRAPIDebug_INTERFACE_DEFINED__

/* interface IRDPSRAPIDebug */
/* [unique][hidden][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIDebug;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa1e42b5-496d-4ca4-a690-348dcb2ec4ad")
    IRDPSRAPIDebug : public IUnknown
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_CLXCmdLine( 
            /* [in] */ __RPC__in BSTR CLXCmdLine) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_CLXCmdLine( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pCLXCmdLine) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIDebugVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIDebug * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIDebug * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIDebug * This);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CLXCmdLine )( 
            __RPC__in IRDPSRAPIDebug * This,
            /* [in] */ __RPC__in BSTR CLXCmdLine);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CLXCmdLine )( 
            __RPC__in IRDPSRAPIDebug * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pCLXCmdLine);
        
        END_INTERFACE
    } IRDPSRAPIDebugVtbl;

    interface IRDPSRAPIDebug
    {
        CONST_VTBL struct IRDPSRAPIDebugVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIDebug_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIDebug_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIDebug_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIDebug_put_CLXCmdLine(This,CLXCmdLine)	\
    ( (This)->lpVtbl -> put_CLXCmdLine(This,CLXCmdLine) ) 

#define IRDPSRAPIDebug_get_CLXCmdLine(This,pCLXCmdLine)	\
    ( (This)->lpVtbl -> get_CLXCmdLine(This,pCLXCmdLine) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIDebug_INTERFACE_DEFINED__ */



#ifndef __RDPCOMAPILib_LIBRARY_DEFINED__
#define __RDPCOMAPILib_LIBRARY_DEFINED__

/* library RDPCOMAPILib */
/* [version][uuid] */ 

typedef /* [public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_rdpencomapi_0000_0001_0001
    {	CTRL_LEVEL_MIN	= 0,
	CTRL_LEVEL_INVALID	= 0,
	CTRL_LEVEL_NONE	= 1,
	CTRL_LEVEL_VIEW	= 2,
	CTRL_LEVEL_INTERACTIVE	= 3,
	CTRL_LEVEL_MAX	= 3
    } 	CTRL_LEVEL;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_rdpencomapi_0000_0001_0002
    {	ATTENDEE_DISCONNECT_REASON_MIN	= 0,
	ATTENDEE_DISCONNECT_REASON_APP	= 0,
	ATTENDEE_DISCONNECT_REASON_ERR	= 1,
	ATTENDEE_DISCONNECT_REASON_CLI	= 2,
	ATTENDEE_DISCONNECT_REASON_MAX	= 2
    } 	ATTENDEE_DISCONNECT_REASON;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_rdpencomapi_0000_0001_0003
    {	CHANNEL_PRIORITY_LO	= 0,
	CHANNEL_PRIORITY_MED	= ( CHANNEL_PRIORITY_LO + 1 ) ,
	CHANNEL_PRIORITY_HI	= ( CHANNEL_PRIORITY_MED + 1 ) 
    } 	CHANNEL_PRIORITY;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_rdpencomapi_0000_0001_0004
    {	CHANNEL_FLAGS_LEGACY	= 0x1,
	CHANNEL_FLAGS_UNCOMPRESSED	= 0x2
    } 	CHANNEL_FLAGS;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_rdpencomapi_0000_0001_0005
    {	CHANNEL_ACCESS_ENUM_NONE	= 0,
	CHANNEL_ACCESS_ENUM_SENDRECEIVE	= ( CHANNEL_ACCESS_ENUM_NONE + 1 ) 
    } 	CHANNEL_ACCESS_ENUM;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_rdpencomapi_0000_0001_0006
    {	CONST_MAX_CHANNEL_MESSAGE_SIZE	= 1024,
	CONST_MAX_CHANNEL_NAME_LEN	= 8,
	CONST_MAX_LEGACY_CHANNEL_MESSAGE_SIZE	= 409600,
	CONST_ATTENDEE_ID_EVERYONE	= -1,
	CONST_ATTENDEE_ID_HOST	= 0,
	CONST_CONN_INTERVAL	= 50
    } 	RDPENCOMAPI_CONSTANTS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_rdpencomapi_0000_0001_0007
    {	ATTENDEE_FLAGS_LOCAL	= 1
    } 	RDPENCOMAPI_ATTENDEE_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_rdpencomapi_0000_0001_0008
    {	WND_FLAG_PRIVILEGED	= 1
    } 	RDPSRAPI_WND_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_rdpencomapi_0000_0001_0009
    {	APP_FLAG_PRIVILEGED	= 1
    } 	RDPSRAPI_APP_FLAGS;



EXTERN_C const IID LIBID_RDPCOMAPILib;

#ifndef ___IRDPSessionEvents_DISPINTERFACE_DEFINED__
#define ___IRDPSessionEvents_DISPINTERFACE_DEFINED__

/* dispinterface _IRDPSessionEvents */
/* [uuid] */ 


EXTERN_C const IID DIID__IRDPSessionEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("98a97042-6698-40e9-8efd-b3200990004b")
    _IRDPSessionEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _IRDPSessionEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in _IRDPSessionEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in _IRDPSessionEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in _IRDPSessionEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in _IRDPSessionEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in _IRDPSessionEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in _IRDPSessionEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            _IRDPSessionEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } _IRDPSessionEventsVtbl;

    interface _IRDPSessionEvents
    {
        CONST_VTBL struct _IRDPSessionEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _IRDPSessionEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define _IRDPSessionEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define _IRDPSessionEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define _IRDPSessionEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define _IRDPSessionEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define _IRDPSessionEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define _IRDPSessionEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___IRDPSessionEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIApplication_INTERFACE_DEFINED__
#define __IRDPSRAPIApplication_INTERFACE_DEFINED__

/* interface IRDPSRAPIApplication */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIApplication;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41e7a09d-eb7a-436e-935d-780ca2628324")
    IRDPSRAPIApplication : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Windows( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIWindowList **pWindowList) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ __RPC__out long *pRetVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Shared( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pRetVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Shared( 
            /* [in] */ VARIANT_BOOL NewVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pRetVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Flags( 
            /* [retval][out] */ __RPC__out unsigned long *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIApplicationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIApplication * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIApplication * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIApplication * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIApplication * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIApplication * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIApplication * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIApplication * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Windows )( 
            __RPC__in IRDPSRAPIApplication * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIWindowList **pWindowList);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            __RPC__in IRDPSRAPIApplication * This,
            /* [retval][out] */ __RPC__out long *pRetVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Shared )( 
            __RPC__in IRDPSRAPIApplication * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pRetVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Shared )( 
            __RPC__in IRDPSRAPIApplication * This,
            /* [in] */ VARIANT_BOOL NewVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IRDPSRAPIApplication * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pRetVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Flags )( 
            __RPC__in IRDPSRAPIApplication * This,
            /* [retval][out] */ __RPC__out unsigned long *pdwFlags);
        
        END_INTERFACE
    } IRDPSRAPIApplicationVtbl;

    interface IRDPSRAPIApplication
    {
        CONST_VTBL struct IRDPSRAPIApplicationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIApplication_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIApplication_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIApplication_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIApplication_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIApplication_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIApplication_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIApplication_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIApplication_get_Windows(This,pWindowList)	\
    ( (This)->lpVtbl -> get_Windows(This,pWindowList) ) 

#define IRDPSRAPIApplication_get_Id(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Id(This,pRetVal) ) 

#define IRDPSRAPIApplication_get_Shared(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Shared(This,pRetVal) ) 

#define IRDPSRAPIApplication_put_Shared(This,NewVal)	\
    ( (This)->lpVtbl -> put_Shared(This,NewVal) ) 

#define IRDPSRAPIApplication_get_Name(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Name(This,pRetVal) ) 

#define IRDPSRAPIApplication_get_Flags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_Flags(This,pdwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIApplication_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIWindow_INTERFACE_DEFINED__
#define __IRDPSRAPIWindow_INTERFACE_DEFINED__

/* interface IRDPSRAPIWindow */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("beafe0f9-c77b-4933-ba9f-a24cddcc27cf")
    IRDPSRAPIWindow : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ __RPC__out long *pRetVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIApplication **pApplication) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Shared( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pRetVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Shared( 
            /* [in] */ VARIANT_BOOL NewVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pRetVal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Show( void) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Flags( 
            /* [retval][out] */ __RPC__out unsigned long *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIWindow * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIWindow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIWindow * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIWindow * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIWindow * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIWindow * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIWindow * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            __RPC__in IRDPSRAPIWindow * This,
            /* [retval][out] */ __RPC__out long *pRetVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Application )( 
            __RPC__in IRDPSRAPIWindow * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIApplication **pApplication);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Shared )( 
            __RPC__in IRDPSRAPIWindow * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pRetVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Shared )( 
            __RPC__in IRDPSRAPIWindow * This,
            /* [in] */ VARIANT_BOOL NewVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IRDPSRAPIWindow * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pRetVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Show )( 
            __RPC__in IRDPSRAPIWindow * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Flags )( 
            __RPC__in IRDPSRAPIWindow * This,
            /* [retval][out] */ __RPC__out unsigned long *pdwFlags);
        
        END_INTERFACE
    } IRDPSRAPIWindowVtbl;

    interface IRDPSRAPIWindow
    {
        CONST_VTBL struct IRDPSRAPIWindowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIWindow_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIWindow_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIWindow_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIWindow_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIWindow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIWindow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIWindow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIWindow_get_Id(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Id(This,pRetVal) ) 

#define IRDPSRAPIWindow_get_Application(This,pApplication)	\
    ( (This)->lpVtbl -> get_Application(This,pApplication) ) 

#define IRDPSRAPIWindow_get_Shared(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Shared(This,pRetVal) ) 

#define IRDPSRAPIWindow_put_Shared(This,NewVal)	\
    ( (This)->lpVtbl -> put_Shared(This,NewVal) ) 

#define IRDPSRAPIWindow_get_Name(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Name(This,pRetVal) ) 

#define IRDPSRAPIWindow_Show(This)	\
    ( (This)->lpVtbl -> Show(This) ) 

#define IRDPSRAPIWindow_get_Flags(This,pdwFlags)	\
    ( (This)->lpVtbl -> get_Flags(This,pdwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIWindow_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIWindowList_INTERFACE_DEFINED__
#define __IRDPSRAPIWindowList_INTERFACE_DEFINED__

/* interface IRDPSRAPIWindowList */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIWindowList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8a05ce44-715a-4116-a189-a118f30a07bd")
    IRDPSRAPIWindowList : public IDispatch
    {
    public:
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long item,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIWindow **pWindow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIWindowListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIWindowList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIWindowList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIWindowList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIWindowList * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIWindowList * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIWindowList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIWindowList * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IRDPSRAPIWindowList * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IRDPSRAPIWindowList * This,
            /* [in] */ long item,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIWindow **pWindow);
        
        END_INTERFACE
    } IRDPSRAPIWindowListVtbl;

    interface IRDPSRAPIWindowList
    {
        CONST_VTBL struct IRDPSRAPIWindowListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIWindowList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIWindowList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIWindowList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIWindowList_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIWindowList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIWindowList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIWindowList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIWindowList_get__NewEnum(This,retval)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retval) ) 

#define IRDPSRAPIWindowList_get_Item(This,item,pWindow)	\
    ( (This)->lpVtbl -> get_Item(This,item,pWindow) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIWindowList_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIApplicationList_INTERFACE_DEFINED__
#define __IRDPSRAPIApplicationList_INTERFACE_DEFINED__

/* interface IRDPSRAPIApplicationList */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIApplicationList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d4b4aeb3-22dc-4837-b3b6-42ea2517849a")
    IRDPSRAPIApplicationList : public IDispatch
    {
    public:
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long item,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIApplication **pApplication) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIApplicationListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIApplicationList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIApplicationList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIApplicationList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIApplicationList * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIApplicationList * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIApplicationList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIApplicationList * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IRDPSRAPIApplicationList * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IRDPSRAPIApplicationList * This,
            /* [in] */ long item,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIApplication **pApplication);
        
        END_INTERFACE
    } IRDPSRAPIApplicationListVtbl;

    interface IRDPSRAPIApplicationList
    {
        CONST_VTBL struct IRDPSRAPIApplicationListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIApplicationList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIApplicationList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIApplicationList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIApplicationList_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIApplicationList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIApplicationList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIApplicationList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIApplicationList_get__NewEnum(This,retval)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retval) ) 

#define IRDPSRAPIApplicationList_get_Item(This,item,pApplication)	\
    ( (This)->lpVtbl -> get_Item(This,item,pApplication) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIApplicationList_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIApplicationFilter_INTERFACE_DEFINED__
#define __IRDPSRAPIApplicationFilter_INTERFACE_DEFINED__

/* interface IRDPSRAPIApplicationFilter */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIApplicationFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d20f10ca-6637-4f06-b1d5-277ea7e5160d")
    IRDPSRAPIApplicationFilter : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Applications( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIApplicationList **pApplications) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Windows( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIWindowList **pWindows) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pRetVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL NewVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIApplicationFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIApplicationFilter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIApplicationFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIApplicationFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIApplicationFilter * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIApplicationFilter * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIApplicationFilter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIApplicationFilter * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Applications )( 
            __RPC__in IRDPSRAPIApplicationFilter * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIApplicationList **pApplications);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Windows )( 
            __RPC__in IRDPSRAPIApplicationFilter * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIWindowList **pWindows);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            __RPC__in IRDPSRAPIApplicationFilter * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pRetVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            __RPC__in IRDPSRAPIApplicationFilter * This,
            /* [in] */ VARIANT_BOOL NewVal);
        
        END_INTERFACE
    } IRDPSRAPIApplicationFilterVtbl;

    interface IRDPSRAPIApplicationFilter
    {
        CONST_VTBL struct IRDPSRAPIApplicationFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIApplicationFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIApplicationFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIApplicationFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIApplicationFilter_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIApplicationFilter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIApplicationFilter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIApplicationFilter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIApplicationFilter_get_Applications(This,pApplications)	\
    ( (This)->lpVtbl -> get_Applications(This,pApplications) ) 

#define IRDPSRAPIApplicationFilter_get_Windows(This,pWindows)	\
    ( (This)->lpVtbl -> get_Windows(This,pWindows) ) 

#define IRDPSRAPIApplicationFilter_get_Enabled(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Enabled(This,pRetVal) ) 

#define IRDPSRAPIApplicationFilter_put_Enabled(This,NewVal)	\
    ( (This)->lpVtbl -> put_Enabled(This,NewVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIApplicationFilter_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPISessionProperties_INTERFACE_DEFINED__
#define __IRDPSRAPISessionProperties_INTERFACE_DEFINED__

/* interface IRDPSRAPISessionProperties */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPISessionProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("339b24f2-9bc0-4f16-9aac-f165433d13d4")
    IRDPSRAPISessionProperties : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Property( 
            /* [in] */ __RPC__in BSTR PropertyName,
            /* [retval][out] */ __RPC__out VARIANT *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Property( 
            /* [in] */ __RPC__in BSTR PropertyName,
            /* [in] */ VARIANT newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPISessionPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPISessionProperties * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPISessionProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPISessionProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPISessionProperties * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPISessionProperties * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPISessionProperties * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPISessionProperties * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Property )( 
            __RPC__in IRDPSRAPISessionProperties * This,
            /* [in] */ __RPC__in BSTR PropertyName,
            /* [retval][out] */ __RPC__out VARIANT *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Property )( 
            __RPC__in IRDPSRAPISessionProperties * This,
            /* [in] */ __RPC__in BSTR PropertyName,
            /* [in] */ VARIANT newVal);
        
        END_INTERFACE
    } IRDPSRAPISessionPropertiesVtbl;

    interface IRDPSRAPISessionProperties
    {
        CONST_VTBL struct IRDPSRAPISessionPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPISessionProperties_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPISessionProperties_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPISessionProperties_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPISessionProperties_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPISessionProperties_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPISessionProperties_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPISessionProperties_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPISessionProperties_get_Property(This,PropertyName,pVal)	\
    ( (This)->lpVtbl -> get_Property(This,PropertyName,pVal) ) 

#define IRDPSRAPISessionProperties_put_Property(This,PropertyName,newVal)	\
    ( (This)->lpVtbl -> put_Property(This,PropertyName,newVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPISessionProperties_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIInvitation_INTERFACE_DEFINED__
#define __IRDPSRAPIInvitation_INTERFACE_DEFINED__

/* interface IRDPSRAPIInvitation */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIInvitation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4fac1d43-fc51-45bb-b1b4-2b53aa562fa3")
    IRDPSRAPIInvitation : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionString( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GroupName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Password( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_AttendeeLimit( 
            /* [retval][out] */ __RPC__out long *pRetVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_AttendeeLimit( 
            /* [in] */ long NewVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Revoked( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pRetVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Revoked( 
            /* [in] */ VARIANT_BOOL NewVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIInvitationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIInvitation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIInvitation * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIInvitation * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectionString )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GroupName )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Password )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AttendeeLimit )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [retval][out] */ __RPC__out long *pRetVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AttendeeLimit )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [in] */ long NewVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Revoked )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pRetVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Revoked )( 
            __RPC__in IRDPSRAPIInvitation * This,
            /* [in] */ VARIANT_BOOL NewVal);
        
        END_INTERFACE
    } IRDPSRAPIInvitationVtbl;

    interface IRDPSRAPIInvitation
    {
        CONST_VTBL struct IRDPSRAPIInvitationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIInvitation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIInvitation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIInvitation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIInvitation_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIInvitation_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIInvitation_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIInvitation_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIInvitation_get_ConnectionString(This,pbstrVal)	\
    ( (This)->lpVtbl -> get_ConnectionString(This,pbstrVal) ) 

#define IRDPSRAPIInvitation_get_GroupName(This,pbstrVal)	\
    ( (This)->lpVtbl -> get_GroupName(This,pbstrVal) ) 

#define IRDPSRAPIInvitation_get_Password(This,pbstrVal)	\
    ( (This)->lpVtbl -> get_Password(This,pbstrVal) ) 

#define IRDPSRAPIInvitation_get_AttendeeLimit(This,pRetVal)	\
    ( (This)->lpVtbl -> get_AttendeeLimit(This,pRetVal) ) 

#define IRDPSRAPIInvitation_put_AttendeeLimit(This,NewVal)	\
    ( (This)->lpVtbl -> put_AttendeeLimit(This,NewVal) ) 

#define IRDPSRAPIInvitation_get_Revoked(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Revoked(This,pRetVal) ) 

#define IRDPSRAPIInvitation_put_Revoked(This,NewVal)	\
    ( (This)->lpVtbl -> put_Revoked(This,NewVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIInvitation_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIInvitationManager_INTERFACE_DEFINED__
#define __IRDPSRAPIInvitationManager_INTERFACE_DEFINED__

/* interface IRDPSRAPIInvitationManager */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIInvitationManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4722b049-92c3-4c2d-8a65-f7348f644dcf")
    IRDPSRAPIInvitationManager : public IDispatch
    {
    public:
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT item,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIInvitation **ppInvitation) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pRetVal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreateInvitation( 
            /* [in] */ __RPC__in BSTR bstrAuthString,
            /* [in] */ __RPC__in BSTR bstrGroupName,
            /* [in] */ __RPC__in BSTR bstrPassword,
            /* [in] */ long AttendeeLimit,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIInvitation **ppInvitation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIInvitationManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIInvitationManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIInvitationManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIInvitationManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIInvitationManager * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIInvitationManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIInvitationManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIInvitationManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IRDPSRAPIInvitationManager * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IRDPSRAPIInvitationManager * This,
            /* [in] */ VARIANT item,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIInvitation **ppInvitation);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IRDPSRAPIInvitationManager * This,
            /* [retval][out] */ __RPC__out long *pRetVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *CreateInvitation )( 
            __RPC__in IRDPSRAPIInvitationManager * This,
            /* [in] */ __RPC__in BSTR bstrAuthString,
            /* [in] */ __RPC__in BSTR bstrGroupName,
            /* [in] */ __RPC__in BSTR bstrPassword,
            /* [in] */ long AttendeeLimit,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIInvitation **ppInvitation);
        
        END_INTERFACE
    } IRDPSRAPIInvitationManagerVtbl;

    interface IRDPSRAPIInvitationManager
    {
        CONST_VTBL struct IRDPSRAPIInvitationManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIInvitationManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIInvitationManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIInvitationManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIInvitationManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIInvitationManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIInvitationManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIInvitationManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIInvitationManager_get__NewEnum(This,retval)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retval) ) 

#define IRDPSRAPIInvitationManager_get_Item(This,item,ppInvitation)	\
    ( (This)->lpVtbl -> get_Item(This,item,ppInvitation) ) 

#define IRDPSRAPIInvitationManager_get_Count(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Count(This,pRetVal) ) 

#define IRDPSRAPIInvitationManager_CreateInvitation(This,bstrAuthString,bstrGroupName,bstrPassword,AttendeeLimit,ppInvitation)	\
    ( (This)->lpVtbl -> CreateInvitation(This,bstrAuthString,bstrGroupName,bstrPassword,AttendeeLimit,ppInvitation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIInvitationManager_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPITcpConnectionInfo_INTERFACE_DEFINED__
#define __IRDPSRAPITcpConnectionInfo_INTERFACE_DEFINED__

/* interface IRDPSRAPITcpConnectionInfo */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPITcpConnectionInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f74049a4-3d06-4028-8193-0a8c29bc2452")
    IRDPSRAPITcpConnectionInfo : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Protocol( 
            /* [retval][out] */ __RPC__out long *plProtocol) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LocalPort( 
            /* [retval][out] */ __RPC__out long *plPort) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LocalIP( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsrLocalIP) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PeerPort( 
            /* [retval][out] */ __RPC__out long *plPort) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PeerIP( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrIP) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPITcpConnectionInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPITcpConnectionInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Protocol )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This,
            /* [retval][out] */ __RPC__out long *plProtocol);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocalPort )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This,
            /* [retval][out] */ __RPC__out long *plPort);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocalIP )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsrLocalIP);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PeerPort )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This,
            /* [retval][out] */ __RPC__out long *plPort);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PeerIP )( 
            __RPC__in IRDPSRAPITcpConnectionInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrIP);
        
        END_INTERFACE
    } IRDPSRAPITcpConnectionInfoVtbl;

    interface IRDPSRAPITcpConnectionInfo
    {
        CONST_VTBL struct IRDPSRAPITcpConnectionInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPITcpConnectionInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPITcpConnectionInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPITcpConnectionInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPITcpConnectionInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPITcpConnectionInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPITcpConnectionInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPITcpConnectionInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPITcpConnectionInfo_get_Protocol(This,plProtocol)	\
    ( (This)->lpVtbl -> get_Protocol(This,plProtocol) ) 

#define IRDPSRAPITcpConnectionInfo_get_LocalPort(This,plPort)	\
    ( (This)->lpVtbl -> get_LocalPort(This,plPort) ) 

#define IRDPSRAPITcpConnectionInfo_get_LocalIP(This,pbsrLocalIP)	\
    ( (This)->lpVtbl -> get_LocalIP(This,pbsrLocalIP) ) 

#define IRDPSRAPITcpConnectionInfo_get_PeerPort(This,plPort)	\
    ( (This)->lpVtbl -> get_PeerPort(This,plPort) ) 

#define IRDPSRAPITcpConnectionInfo_get_PeerIP(This,pbstrIP)	\
    ( (This)->lpVtbl -> get_PeerIP(This,pbstrIP) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPITcpConnectionInfo_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIAttendee_INTERFACE_DEFINED__
#define __IRDPSRAPIAttendee_INTERFACE_DEFINED__

/* interface IRDPSRAPIAttendee */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIAttendee;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ec0671b3-1b78-4b80-a464-9132247543e3")
    IRDPSRAPIAttendee : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ __RPC__out long *pId) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_RemoteName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ControlLevel( 
            /* [retval][out] */ __RPC__out CTRL_LEVEL *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ControlLevel( 
            /* [in] */ CTRL_LEVEL pNewVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Invitation( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIInvitation **ppVal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE TerminateConnection( void) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Flags( 
            /* [retval][out] */ __RPC__out long *plFlags) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectivityInfo( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIAttendeeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIAttendee * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIAttendee * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIAttendee * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [retval][out] */ __RPC__out long *pId);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RemoteName )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ControlLevel )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [retval][out] */ __RPC__out CTRL_LEVEL *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ControlLevel )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [in] */ CTRL_LEVEL pNewVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Invitation )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIInvitation **ppVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *TerminateConnection )( 
            __RPC__in IRDPSRAPIAttendee * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Flags )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [retval][out] */ __RPC__out long *plFlags);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectivityInfo )( 
            __RPC__in IRDPSRAPIAttendee * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppVal);
        
        END_INTERFACE
    } IRDPSRAPIAttendeeVtbl;

    interface IRDPSRAPIAttendee
    {
        CONST_VTBL struct IRDPSRAPIAttendeeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIAttendee_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIAttendee_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIAttendee_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIAttendee_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIAttendee_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIAttendee_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIAttendee_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIAttendee_get_Id(This,pId)	\
    ( (This)->lpVtbl -> get_Id(This,pId) ) 

#define IRDPSRAPIAttendee_get_RemoteName(This,pVal)	\
    ( (This)->lpVtbl -> get_RemoteName(This,pVal) ) 

#define IRDPSRAPIAttendee_get_ControlLevel(This,pVal)	\
    ( (This)->lpVtbl -> get_ControlLevel(This,pVal) ) 

#define IRDPSRAPIAttendee_put_ControlLevel(This,pNewVal)	\
    ( (This)->lpVtbl -> put_ControlLevel(This,pNewVal) ) 

#define IRDPSRAPIAttendee_get_Invitation(This,ppVal)	\
    ( (This)->lpVtbl -> get_Invitation(This,ppVal) ) 

#define IRDPSRAPIAttendee_TerminateConnection(This)	\
    ( (This)->lpVtbl -> TerminateConnection(This) ) 

#define IRDPSRAPIAttendee_get_Flags(This,plFlags)	\
    ( (This)->lpVtbl -> get_Flags(This,plFlags) ) 

#define IRDPSRAPIAttendee_get_ConnectivityInfo(This,ppVal)	\
    ( (This)->lpVtbl -> get_ConnectivityInfo(This,ppVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIAttendee_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIAttendeeManager_INTERFACE_DEFINED__
#define __IRDPSRAPIAttendeeManager_INTERFACE_DEFINED__

/* interface IRDPSRAPIAttendeeManager */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIAttendeeManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ba3a37e8-33da-4749-8da0-07fa34da7944")
    IRDPSRAPIAttendeeManager : public IDispatch
    {
    public:
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long id,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIAttendee **ppItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIAttendeeManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIAttendeeManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIAttendeeManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIAttendeeManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIAttendeeManager * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIAttendeeManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIAttendeeManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIAttendeeManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IRDPSRAPIAttendeeManager * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IRDPSRAPIAttendeeManager * This,
            /* [in] */ long id,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIAttendee **ppItem);
        
        END_INTERFACE
    } IRDPSRAPIAttendeeManagerVtbl;

    interface IRDPSRAPIAttendeeManager
    {
        CONST_VTBL struct IRDPSRAPIAttendeeManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIAttendeeManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIAttendeeManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIAttendeeManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIAttendeeManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIAttendeeManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIAttendeeManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIAttendeeManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIAttendeeManager_get__NewEnum(This,retval)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retval) ) 

#define IRDPSRAPIAttendeeManager_get_Item(This,id,ppItem)	\
    ( (This)->lpVtbl -> get_Item(This,id,ppItem) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIAttendeeManager_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIAttendeeDisconnectInfo_INTERFACE_DEFINED__
#define __IRDPSRAPIAttendeeDisconnectInfo_INTERFACE_DEFINED__

/* interface IRDPSRAPIAttendeeDisconnectInfo */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIAttendeeDisconnectInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c187689f-447c-44a1-9c14-fffbb3b7ec17")
    IRDPSRAPIAttendeeDisconnectInfo : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Attendee( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIAttendee **retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Reason( 
            /* [retval][out] */ __RPC__out ATTENDEE_DISCONNECT_REASON *pReason) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Code( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIAttendeeDisconnectInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIAttendeeDisconnectInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIAttendeeDisconnectInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIAttendeeDisconnectInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIAttendeeDisconnectInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIAttendeeDisconnectInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIAttendeeDisconnectInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIAttendeeDisconnectInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Attendee )( 
            __RPC__in IRDPSRAPIAttendeeDisconnectInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIAttendee **retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Reason )( 
            __RPC__in IRDPSRAPIAttendeeDisconnectInfo * This,
            /* [retval][out] */ __RPC__out ATTENDEE_DISCONNECT_REASON *pReason);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Code )( 
            __RPC__in IRDPSRAPIAttendeeDisconnectInfo * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        END_INTERFACE
    } IRDPSRAPIAttendeeDisconnectInfoVtbl;

    interface IRDPSRAPIAttendeeDisconnectInfo
    {
        CONST_VTBL struct IRDPSRAPIAttendeeDisconnectInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIAttendeeDisconnectInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIAttendeeDisconnectInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIAttendeeDisconnectInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIAttendeeDisconnectInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIAttendeeDisconnectInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIAttendeeDisconnectInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIAttendeeDisconnectInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIAttendeeDisconnectInfo_get_Attendee(This,retval)	\
    ( (This)->lpVtbl -> get_Attendee(This,retval) ) 

#define IRDPSRAPIAttendeeDisconnectInfo_get_Reason(This,pReason)	\
    ( (This)->lpVtbl -> get_Reason(This,pReason) ) 

#define IRDPSRAPIAttendeeDisconnectInfo_get_Code(This,pVal)	\
    ( (This)->lpVtbl -> get_Code(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIAttendeeDisconnectInfo_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIVirtualChannel_INTERFACE_DEFINED__
#define __IRDPSRAPIVirtualChannel_INTERFACE_DEFINED__

/* interface IRDPSRAPIVirtualChannel */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIVirtualChannel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05e12f95-28b3-4c9a-8780-d0248574a1e0")
    IRDPSRAPIVirtualChannel : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SendData( 
            /* [in] */ __RPC__in BSTR bstrData,
            /* [in] */ long lAttendeeId,
            /* [in] */ unsigned long ChannelSendFlags) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetAccess( 
            /* [in] */ long lAttendeeId,
            /* [in] */ CHANNEL_ACCESS_ENUM AccessType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Flags( 
            /* [retval][out] */ __RPC__out long *plFlags) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Priority( 
            /* [retval][out] */ __RPC__out CHANNEL_PRIORITY *pPriority) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIVirtualChannelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIVirtualChannel * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIVirtualChannel * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIVirtualChannel * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIVirtualChannel * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIVirtualChannel * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIVirtualChannel * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIVirtualChannel * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SendData )( 
            __RPC__in IRDPSRAPIVirtualChannel * This,
            /* [in] */ __RPC__in BSTR bstrData,
            /* [in] */ long lAttendeeId,
            /* [in] */ unsigned long ChannelSendFlags);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetAccess )( 
            __RPC__in IRDPSRAPIVirtualChannel * This,
            /* [in] */ long lAttendeeId,
            /* [in] */ CHANNEL_ACCESS_ENUM AccessType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IRDPSRAPIVirtualChannel * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Flags )( 
            __RPC__in IRDPSRAPIVirtualChannel * This,
            /* [retval][out] */ __RPC__out long *plFlags);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Priority )( 
            __RPC__in IRDPSRAPIVirtualChannel * This,
            /* [retval][out] */ __RPC__out CHANNEL_PRIORITY *pPriority);
        
        END_INTERFACE
    } IRDPSRAPIVirtualChannelVtbl;

    interface IRDPSRAPIVirtualChannel
    {
        CONST_VTBL struct IRDPSRAPIVirtualChannelVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIVirtualChannel_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIVirtualChannel_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIVirtualChannel_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIVirtualChannel_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIVirtualChannel_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIVirtualChannel_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIVirtualChannel_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIVirtualChannel_SendData(This,bstrData,lAttendeeId,ChannelSendFlags)	\
    ( (This)->lpVtbl -> SendData(This,bstrData,lAttendeeId,ChannelSendFlags) ) 

#define IRDPSRAPIVirtualChannel_SetAccess(This,lAttendeeId,AccessType)	\
    ( (This)->lpVtbl -> SetAccess(This,lAttendeeId,AccessType) ) 

#define IRDPSRAPIVirtualChannel_get_Name(This,pbstrName)	\
    ( (This)->lpVtbl -> get_Name(This,pbstrName) ) 

#define IRDPSRAPIVirtualChannel_get_Flags(This,plFlags)	\
    ( (This)->lpVtbl -> get_Flags(This,plFlags) ) 

#define IRDPSRAPIVirtualChannel_get_Priority(This,pPriority)	\
    ( (This)->lpVtbl -> get_Priority(This,pPriority) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIVirtualChannel_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIVirtualChannelManager_INTERFACE_DEFINED__
#define __IRDPSRAPIVirtualChannelManager_INTERFACE_DEFINED__

/* interface IRDPSRAPIVirtualChannelManager */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIVirtualChannelManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0d11c661-5d0d-4ee4-89df-2166ae1fdfed")
    IRDPSRAPIVirtualChannelManager : public IDispatch
    {
    public:
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT item,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIVirtualChannel **pChannel) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreateVirtualChannel( 
            /* [in] */ __RPC__in BSTR bstrChannelName,
            /* [in] */ CHANNEL_PRIORITY Priority,
            /* [in] */ unsigned long ChannelFlags,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIVirtualChannel **ppChannel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIVirtualChannelManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIVirtualChannelManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIVirtualChannelManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIVirtualChannelManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIVirtualChannelManager * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIVirtualChannelManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIVirtualChannelManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIVirtualChannelManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IRDPSRAPIVirtualChannelManager * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **retval);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IRDPSRAPIVirtualChannelManager * This,
            /* [in] */ VARIANT item,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIVirtualChannel **pChannel);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *CreateVirtualChannel )( 
            __RPC__in IRDPSRAPIVirtualChannelManager * This,
            /* [in] */ __RPC__in BSTR bstrChannelName,
            /* [in] */ CHANNEL_PRIORITY Priority,
            /* [in] */ unsigned long ChannelFlags,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIVirtualChannel **ppChannel);
        
        END_INTERFACE
    } IRDPSRAPIVirtualChannelManagerVtbl;

    interface IRDPSRAPIVirtualChannelManager
    {
        CONST_VTBL struct IRDPSRAPIVirtualChannelManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIVirtualChannelManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIVirtualChannelManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIVirtualChannelManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIVirtualChannelManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIVirtualChannelManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIVirtualChannelManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIVirtualChannelManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIVirtualChannelManager_get__NewEnum(This,retval)	\
    ( (This)->lpVtbl -> get__NewEnum(This,retval) ) 

#define IRDPSRAPIVirtualChannelManager_get_Item(This,item,pChannel)	\
    ( (This)->lpVtbl -> get_Item(This,item,pChannel) ) 

#define IRDPSRAPIVirtualChannelManager_CreateVirtualChannel(This,bstrChannelName,Priority,ChannelFlags,ppChannel)	\
    ( (This)->lpVtbl -> CreateVirtualChannel(This,bstrChannelName,Priority,ChannelFlags,ppChannel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIVirtualChannelManager_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPISharingSession_INTERFACE_DEFINED__
#define __IRDPSRAPISharingSession_INTERFACE_DEFINED__

/* interface IRDPSRAPISharingSession */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPISharingSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eeb20886-e470-4cf6-842b-2739c0ec5cfb")
    IRDPSRAPISharingSession : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Open( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ColorDepth( 
            /* [in] */ long colorDepth) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ColorDepth( 
            /* [retval][out] */ __RPC__out long *pColorDepth) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPISessionProperties **ppVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Attendees( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIAttendeeManager **ppVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Invitations( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIInvitationManager **ppVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ApplicationFilter( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIApplicationFilter **ppVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_VirtualChannelManager( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIVirtualChannelManager **ppVal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ConnectToClient( 
            /* [in] */ __RPC__in BSTR bstrConnectionString) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetDesktopSharedRect( 
            /* [in] */ long left,
            /* [in] */ long top,
            /* [in] */ long right,
            /* [in] */ long bottom) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetDesktopSharedRect( 
            /* [out] */ __RPC__out long *pleft,
            /* [out] */ __RPC__out long *ptop,
            /* [out] */ __RPC__out long *pright,
            /* [out] */ __RPC__out long *pbottom) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPISharingSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPISharingSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPISharingSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPISharingSession * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            __RPC__in IRDPSRAPISharingSession * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Close )( 
            __RPC__in IRDPSRAPISharingSession * This);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ColorDepth )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [in] */ long colorDepth);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ColorDepth )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [retval][out] */ __RPC__out long *pColorDepth);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPISessionProperties **ppVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Attendees )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIAttendeeManager **ppVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Invitations )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIInvitationManager **ppVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ApplicationFilter )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIApplicationFilter **ppVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VirtualChannelManager )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIVirtualChannelManager **ppVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            __RPC__in IRDPSRAPISharingSession * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Resume )( 
            __RPC__in IRDPSRAPISharingSession * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *ConnectToClient )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [in] */ __RPC__in BSTR bstrConnectionString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetDesktopSharedRect )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [in] */ long left,
            /* [in] */ long top,
            /* [in] */ long right,
            /* [in] */ long bottom);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetDesktopSharedRect )( 
            __RPC__in IRDPSRAPISharingSession * This,
            /* [out] */ __RPC__out long *pleft,
            /* [out] */ __RPC__out long *ptop,
            /* [out] */ __RPC__out long *pright,
            /* [out] */ __RPC__out long *pbottom);
        
        END_INTERFACE
    } IRDPSRAPISharingSessionVtbl;

    interface IRDPSRAPISharingSession
    {
        CONST_VTBL struct IRDPSRAPISharingSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPISharingSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPISharingSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPISharingSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPISharingSession_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPISharingSession_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPISharingSession_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPISharingSession_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPISharingSession_Open(This)	\
    ( (This)->lpVtbl -> Open(This) ) 

#define IRDPSRAPISharingSession_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IRDPSRAPISharingSession_put_ColorDepth(This,colorDepth)	\
    ( (This)->lpVtbl -> put_ColorDepth(This,colorDepth) ) 

#define IRDPSRAPISharingSession_get_ColorDepth(This,pColorDepth)	\
    ( (This)->lpVtbl -> get_ColorDepth(This,pColorDepth) ) 

#define IRDPSRAPISharingSession_get_Properties(This,ppVal)	\
    ( (This)->lpVtbl -> get_Properties(This,ppVal) ) 

#define IRDPSRAPISharingSession_get_Attendees(This,ppVal)	\
    ( (This)->lpVtbl -> get_Attendees(This,ppVal) ) 

#define IRDPSRAPISharingSession_get_Invitations(This,ppVal)	\
    ( (This)->lpVtbl -> get_Invitations(This,ppVal) ) 

#define IRDPSRAPISharingSession_get_ApplicationFilter(This,ppVal)	\
    ( (This)->lpVtbl -> get_ApplicationFilter(This,ppVal) ) 

#define IRDPSRAPISharingSession_get_VirtualChannelManager(This,ppVal)	\
    ( (This)->lpVtbl -> get_VirtualChannelManager(This,ppVal) ) 

#define IRDPSRAPISharingSession_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IRDPSRAPISharingSession_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IRDPSRAPISharingSession_ConnectToClient(This,bstrConnectionString)	\
    ( (This)->lpVtbl -> ConnectToClient(This,bstrConnectionString) ) 

#define IRDPSRAPISharingSession_SetDesktopSharedRect(This,left,top,right,bottom)	\
    ( (This)->lpVtbl -> SetDesktopSharedRect(This,left,top,right,bottom) ) 

#define IRDPSRAPISharingSession_GetDesktopSharedRect(This,pleft,ptop,pright,pbottom)	\
    ( (This)->lpVtbl -> GetDesktopSharedRect(This,pleft,ptop,pright,pbottom) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPISharingSession_INTERFACE_DEFINED__ */


#ifndef __IRDPSRAPIViewer_INTERFACE_DEFINED__
#define __IRDPSRAPIViewer_INTERFACE_DEFINED__

/* interface IRDPSRAPIViewer */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDPSRAPIViewer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c6bfcd38-8ce9-404d-8ae8-f31d00c65cb5")
    IRDPSRAPIViewer : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ __RPC__in BSTR bstrConnectionString,
            /* [in] */ __RPC__in BSTR bstrName,
            /* [in] */ __RPC__in BSTR bstrPassword) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Attendees( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIAttendeeManager **ppVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Invitations( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIInvitationManager **ppVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ApplicationFilter( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIApplicationFilter **ppVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_VirtualChannelManager( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIVirtualChannelManager **ppVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SmartSizing( 
            /* [in] */ VARIANT_BOOL vbSmartSizing) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SmartSizing( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pvbSmartSizing) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RequestControl( 
            /* [in] */ CTRL_LEVEL CtrlLevel) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DisconnectedText( 
            /* [in] */ __RPC__in BSTR bstrDisconnectedText) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DisconnectedText( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDisconnectedText) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RequestColorDepthChange( 
            /* [in] */ long Bpp) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Properties( 
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPISessionProperties **ppVal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE StartReverseConnectListener( 
            /* [in] */ __RPC__in BSTR bstrConnectionString,
            /* [in] */ __RPC__in BSTR bstrUserName,
            /* [in] */ __RPC__in BSTR bstrPassword,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrReverseConnectString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDPSRAPIViewerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRDPSRAPIViewer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRDPSRAPIViewer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRDPSRAPIViewer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [in] */ __RPC__in BSTR bstrConnectionString,
            /* [in] */ __RPC__in BSTR bstrName,
            /* [in] */ __RPC__in BSTR bstrPassword);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            __RPC__in IRDPSRAPIViewer * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Attendees )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIAttendeeManager **ppVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Invitations )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIInvitationManager **ppVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ApplicationFilter )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIApplicationFilter **ppVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VirtualChannelManager )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPIVirtualChannelManager **ppVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SmartSizing )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [in] */ VARIANT_BOOL vbSmartSizing);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SmartSizing )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pvbSmartSizing);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *RequestControl )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [in] */ CTRL_LEVEL CtrlLevel);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisconnectedText )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [in] */ __RPC__in BSTR bstrDisconnectedText);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisconnectedText )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDisconnectedText);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *RequestColorDepthChange )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [in] */ long Bpp);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Properties )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [retval][out] */ __RPC__deref_out_opt IRDPSRAPISessionProperties **ppVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *StartReverseConnectListener )( 
            __RPC__in IRDPSRAPIViewer * This,
            /* [in] */ __RPC__in BSTR bstrConnectionString,
            /* [in] */ __RPC__in BSTR bstrUserName,
            /* [in] */ __RPC__in BSTR bstrPassword,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrReverseConnectString);
        
        END_INTERFACE
    } IRDPSRAPIViewerVtbl;

    interface IRDPSRAPIViewer
    {
        CONST_VTBL struct IRDPSRAPIViewerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDPSRAPIViewer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRDPSRAPIViewer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRDPSRAPIViewer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRDPSRAPIViewer_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRDPSRAPIViewer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRDPSRAPIViewer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRDPSRAPIViewer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRDPSRAPIViewer_Connect(This,bstrConnectionString,bstrName,bstrPassword)	\
    ( (This)->lpVtbl -> Connect(This,bstrConnectionString,bstrName,bstrPassword) ) 

#define IRDPSRAPIViewer_Disconnect(This)	\
    ( (This)->lpVtbl -> Disconnect(This) ) 

#define IRDPSRAPIViewer_get_Attendees(This,ppVal)	\
    ( (This)->lpVtbl -> get_Attendees(This,ppVal) ) 

#define IRDPSRAPIViewer_get_Invitations(This,ppVal)	\
    ( (This)->lpVtbl -> get_Invitations(This,ppVal) ) 

#define IRDPSRAPIViewer_get_ApplicationFilter(This,ppVal)	\
    ( (This)->lpVtbl -> get_ApplicationFilter(This,ppVal) ) 

#define IRDPSRAPIViewer_get_VirtualChannelManager(This,ppVal)	\
    ( (This)->lpVtbl -> get_VirtualChannelManager(This,ppVal) ) 

#define IRDPSRAPIViewer_put_SmartSizing(This,vbSmartSizing)	\
    ( (This)->lpVtbl -> put_SmartSizing(This,vbSmartSizing) ) 

#define IRDPSRAPIViewer_get_SmartSizing(This,pvbSmartSizing)	\
    ( (This)->lpVtbl -> get_SmartSizing(This,pvbSmartSizing) ) 

#define IRDPSRAPIViewer_RequestControl(This,CtrlLevel)	\
    ( (This)->lpVtbl -> RequestControl(This,CtrlLevel) ) 

#define IRDPSRAPIViewer_put_DisconnectedText(This,bstrDisconnectedText)	\
    ( (This)->lpVtbl -> put_DisconnectedText(This,bstrDisconnectedText) ) 

#define IRDPSRAPIViewer_get_DisconnectedText(This,pbstrDisconnectedText)	\
    ( (This)->lpVtbl -> get_DisconnectedText(This,pbstrDisconnectedText) ) 

#define IRDPSRAPIViewer_RequestColorDepthChange(This,Bpp)	\
    ( (This)->lpVtbl -> RequestColorDepthChange(This,Bpp) ) 

#define IRDPSRAPIViewer_get_Properties(This,ppVal)	\
    ( (This)->lpVtbl -> get_Properties(This,ppVal) ) 

#define IRDPSRAPIViewer_StartReverseConnectListener(This,bstrConnectionString,bstrUserName,bstrPassword,pbstrReverseConnectString)	\
    ( (This)->lpVtbl -> StartReverseConnectListener(This,bstrConnectionString,bstrUserName,bstrPassword,pbstrReverseConnectString) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRDPSRAPIViewer_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_RDPViewer;

#ifdef __cplusplus

class DECLSPEC_UUID("32be5ed2-5c86-480f-a914-0ff8885a1b3f")
RDPViewer;
#endif

EXTERN_C const CLSID CLSID_RDPSession;

#ifdef __cplusplus

class DECLSPEC_UUID("9B78F0E6-3E05-4A5B-B2E8-E743A8956B65")
RDPSession;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPISessionProperties;

#ifdef __cplusplus

class DECLSPEC_UUID("dd7594ff-ea2a-4c06-8fdf-132de48b6510")
RDPSRAPISessionProperties;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPIInvitationManager;

#ifdef __cplusplus

class DECLSPEC_UUID("53d9c9db-75ab-4271-948a-4c4eb36a8f2b")
RDPSRAPIInvitationManager;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPIInvitation;

#ifdef __cplusplus

class DECLSPEC_UUID("49174dc6-0731-4b5e-8ee1-83a63d3868fa")
RDPSRAPIInvitation;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPIAttendeeManager;

#ifdef __cplusplus

class DECLSPEC_UUID("d7b13a01-f7d4-42a6-8595-12fc8c24e851")
RDPSRAPIAttendeeManager;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPIAttendee;

#ifdef __cplusplus

class DECLSPEC_UUID("74f93bb5-755f-488e-8a29-2390108aef55")
RDPSRAPIAttendee;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPIAttendeeDisconnectInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("b47d7250-5bdb-405d-b487-caad9c56f4f8")
RDPSRAPIAttendeeDisconnectInfo;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPIApplicationFilter;

#ifdef __cplusplus

class DECLSPEC_UUID("e35ace89-c7e8-427e-a4f9-b9da072826bd")
RDPSRAPIApplicationFilter;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPIApplicationList;

#ifdef __cplusplus

class DECLSPEC_UUID("9e31c815-7433-4876-97fb-ed59fe2baa22")
RDPSRAPIApplicationList;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPIApplication;

#ifdef __cplusplus

class DECLSPEC_UUID("c116a484-4b25-4b9f-8a54-b934b06e57fa")
RDPSRAPIApplication;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPIWindowList;

#ifdef __cplusplus

class DECLSPEC_UUID("9c21e2b8-5dd4-42cc-81ba-1c099852e6fa")
RDPSRAPIWindowList;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPIWindow;

#ifdef __cplusplus

class DECLSPEC_UUID("03cf46db-ce45-4d36-86ed-ed28b74398bf")
RDPSRAPIWindow;
#endif

EXTERN_C const CLSID CLSID_RDPSRAPITcpConnectionInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("be49db3f-ebb6-4278-8ce0-d5455833eaee")
RDPSRAPITcpConnectionInfo;
#endif
#endif /* __RDPCOMAPILib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RecGuids.h ===
// Copyright (C) Microsoft Corporation, 1990-1999
#if _MSC_VER > 1000
#pragma once
#endif

/*
 * recguids.h - OLE reconciliation interface GUID definitions.
 */


/* GUIDs
 ********/

DEFINE_GUID(IID_IReconcileInitiator, 0x99180161L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_IReconcilableObject, 0x99180162L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_INotifyReplica,      0x99180163L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_IBriefcaseInitiator, 0x99180164L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\recdefs.h ===
//--------------------------------------------------------------------------
//  This is part of the Microsoft Tablet PC Platform SDK
//  Copyright (C) 2002 Microsoft Corporation
//  All rights reserved.
//
//
// Module:       
//      RecDefs.h
//
//--------------------------------------------------------------------------


#ifndef __INC_RECDEFS_H
#define __INC_RECDEFS_H

// RECO FLAGS
#define RECOFLAG_WORDMODE		0x00000001
#define RECOFLAG_COERCE			0x00000002
#define RECOFLAG_SINGLESEG		0x00000004
#define RECOFLAG_PREFIXOK		0x00000008
#define RECOFLAG_LINEMODE		0x00000010
#define RECOFLAG_DISABLEPERSONALIZATION 0x00000020
#define RECOFLAG_AUTOSPACE		0x00000040

// Confidence constants
#define RECOCONF_LOWCONFIDENCE -1
#define RECOCONF_MEDIUMCONFIDENCE 0
#define RECOCONF_HIGHCONFIDENCE 1
#define RECOCONF_NOTSET    128

// Gesture ids
#define GESTURE_NULL                        0xf000
#define GESTURE_SCRATCHOUT                  0xf001
#define GESTURE_TRIANGLE                    0xf002
#define GESTURE_SQUARE                      0xf003
#define GESTURE_STAR                        0xf004
#define GESTURE_CHECK                       0xf005
#define GESTURE_INFINITY                    0xf006
#define GESTURE_CROSS                       0xf007
#define GESTURE_PARAGRAPH                   0xf008
#define GESTURE_SECTION                     0xf009
#define GESTURE_BULLET                      0xf00a
#define GESTURE_BULLET_CROSS                0xf00b
#define GESTURE_SQUIGGLE                    0xf00c
#define GESTURE_SWAP                        0xf00d
#define GESTURE_OPENUP                      0xf00e
#define GESTURE_CLOSEUP                     0xf00f
#define GESTURE_CURLICUE                    0xf010
#define GESTURE_DOUBLE_CURLICUE             0xf011
#define GESTURE_RECTANGLE                   0xf012
#define GESTURE_CIRCLE                      0xf020
#define GESTURE_DOUBLE_CIRCLE               0xf021
#define GESTURE_CIRCLE_TAP                  0xf022
#define GESTURE_CIRCLE_CIRCLE               0xf023
#define GESTURE_CIRCLE_CROSS                0xf025
#define GESTURE_CIRCLE_LINE_VERT            0xf026
#define GESTURE_CIRCLE_LINE_HORZ            0xf027
#define GESTURE_SEMICIRCLE_LEFT             0xf028
#define GESTURE_SEMICIRCLE_RIGHT            0xf029
#define GESTURE_CHEVRON_UP                  0xf030
#define GESTURE_CHEVRON_DOWN                0xf031
#define GESTURE_CHEVRON_LEFT                0xf032
#define GESTURE_CHEVRON_RIGHT               0xf033
#define GESTURE_ARROW_UP                    0xf038
#define GESTURE_ARROW_DOWN                  0xf039
#define GESTURE_ARROW_LEFT                  0xf03a
#define GESTURE_ARROW_RIGHT                 0xf03b
#define GESTURE_DOUBLE_ARROW_UP             0xf03c
#define GESTURE_DOUBLE_ARROW_DOWN           0xf03d
#define GESTURE_DOUBLE_ARROW_LEFT           0xf03e
#define GESTURE_DOUBLE_ARROW_RIGHT          0xf03f
#define GESTURE_UP_ARROW_LEFT               0xf040
#define GESTURE_UP_ARROW_RIGHT              0xf041
#define GESTURE_DOWN_ARROW_LEFT             0xf042
#define GESTURE_DOWN_ARROW_RIGHT            0xf043
#define GESTURE_LEFT_ARROW_UP               0xf044
#define GESTURE_LEFT_ARROW_DOWN             0xf045
#define GESTURE_RIGHT_ARROW_UP              0xf046
#define GESTURE_RIGHT_ARROW_DOWN            0xf047
#define GESTURE_UP                          0xf058
#define GESTURE_DOWN                        0xf059
#define GESTURE_LEFT                        0xf05a
#define GESTURE_RIGHT                       0xf05b
#define GESTURE_DIAGONAL_LEFTUP             0xf05c
#define GESTURE_DIAGONAL_RIGHTUP            0xf05d
#define GESTURE_DIAGONAL_LEFTDOWN           0xf05e
#define GESTURE_DIAGONAL_RIGHTDOWN          0xf05f
#define GESTURE_UP_DOWN                     0xf060
#define GESTURE_DOWN_UP                     0xf061
#define GESTURE_LEFT_RIGHT                  0xf062
#define GESTURE_RIGHT_LEFT                  0xf063
#define GESTURE_UP_LEFT_LONG                0xf064
#define GESTURE_UP_RIGHT_LONG               0xf065
#define GESTURE_DOWN_LEFT_LONG              0xf066
#define GESTURE_DOWN_RIGHT_LONG             0xf067
#define GESTURE_UP_LEFT                     0xf068
#define GESTURE_UP_RIGHT                    0xf069
#define GESTURE_DOWN_LEFT                   0xf06a
#define GESTURE_DOWN_RIGHT                  0xf06b
#define GESTURE_LEFT_UP                     0xf06c
#define GESTURE_LEFT_DOWN                   0xf06d
#define GESTURE_RIGHT_UP                    0xf06e
#define GESTURE_RIGHT_DOWN                  0xf06f
#define GESTURE_LETTER_A                    0xf080
#define GESTURE_LETTER_B                    0xf081
#define GESTURE_LETTER_C                    0xf082
#define GESTURE_LETTER_D                    0xf083
#define GESTURE_LETTER_E                    0xf084
#define GESTURE_LETTER_F                    0xf085
#define GESTURE_LETTER_G                    0xf086
#define GESTURE_LETTER_H                    0xf087
#define GESTURE_LETTER_I                    0xf088
#define GESTURE_LETTER_J                    0xf089
#define GESTURE_LETTER_K                    0xf08a
#define GESTURE_LETTER_L                    0xf08b
#define GESTURE_LETTER_M                    0xf08c
#define GESTURE_LETTER_N                    0xf08d
#define GESTURE_LETTER_O                    0xf08e
#define GESTURE_LETTER_P                    0xf08f
#define GESTURE_LETTER_Q                    0xf090
#define GESTURE_LETTER_R                    0xf091
#define GESTURE_LETTER_S                    0xf092
#define GESTURE_LETTER_T                    0xf093
#define GESTURE_LETTER_U                    0xf094
#define GESTURE_LETTER_V                    0xf095
#define GESTURE_LETTER_W                    0xf096
#define GESTURE_LETTER_X                    0xf097
#define GESTURE_LETTER_Y                    0xf098
#define GESTURE_LETTER_Z                    0xf099
#define GESTURE_DIGIT_0                     0xf09a
#define GESTURE_DIGIT_1                     0xf09b
#define GESTURE_DIGIT_2                     0xf09c
#define GESTURE_DIGIT_3                     0xf09d
#define GESTURE_DIGIT_4                     0xf09e
#define GESTURE_DIGIT_5                     0xf09f
#define GESTURE_DIGIT_6                     0xf0a0
#define GESTURE_DIGIT_7                     0xf0a1
#define GESTURE_DIGIT_8                     0xf0a2
#define GESTURE_DIGIT_9                     0xf0a3
#define GESTURE_EXCLAMATION                 0xf0a4
#define GESTURE_QUESTION                    0xf0a5
#define GESTURE_SHARP                       0xf0a6
#define GESTURE_DOLLAR                      0xf0a7
#define GESTURE_ASTERISK                    0xf0a8
#define GESTURE_PLUS                        0xf0a9
#define GESTURE_DOUBLE_UP                   0xf0b8
#define GESTURE_DOUBLE_DOWN                 0xf0b9
#define GESTURE_DOUBLE_LEFT                 0xf0ba
#define GESTURE_DOUBLE_RIGHT                0xf0bb
#define GESTURE_TRIPLE_UP                   0xf0bc
#define GESTURE_TRIPLE_DOWN                 0xf0bd
#define GESTURE_TRIPLE_LEFT                 0xf0be
#define GESTURE_TRIPLE_RIGHT                0xf0bf
#define GESTURE_BRACKET_OVER                0xf0e4
#define GESTURE_BRACKET_UNDER               0xf0e5
#define GESTURE_BRACKET_LEFT                0xf0e6
#define GESTURE_BRACKET_RIGHT               0xf0e7
#define GESTURE_BRACE_OVER                  0xf0e8
#define GESTURE_BRACE_UNDER                 0xf0e9
#define GESTURE_BRACE_LEFT                  0xf0ea
#define GESTURE_BRACE_RIGHT                 0xf0eb
#define GESTURE_TAP                         0xf0f0
#define GESTURE_DOUBLE_TAP                  0xf0f1
#define GESTURE_TRIPLE_TAP                  0xf0f2
#define GESTURE_QUAD_TAP                    0xf0f3
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Reason.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:        reason.h
//
//  Contents:    Shutdown reason code values.
//
//  History:     8-00        Created         Hughleat
//
//--------------------------------------------------------------------
#if !defined SENTINEL_Reason
# define SENTINEL_Reason
#pragma once

// Reason flags

// Flags used by the various UIs.
#define SHTDN_REASON_FLAG_COMMENT_REQUIRED          0x01000000
#define SHTDN_REASON_FLAG_DIRTY_PROBLEM_ID_REQUIRED 0x02000000
#define SHTDN_REASON_FLAG_CLEAN_UI                  0x04000000
#define SHTDN_REASON_FLAG_DIRTY_UI                  0x08000000

// Flags that end up in the event log code.
#define SHTDN_REASON_FLAG_USER_DEFINED          0x40000000
#define SHTDN_REASON_FLAG_PLANNED               0x80000000

// Microsoft major reasons.
#define SHTDN_REASON_MAJOR_OTHER                0x00000000
#define SHTDN_REASON_MAJOR_NONE                 0x00000000
#define SHTDN_REASON_MAJOR_HARDWARE             0x00010000
#define SHTDN_REASON_MAJOR_OPERATINGSYSTEM      0x00020000
#define SHTDN_REASON_MAJOR_SOFTWARE             0x00030000
#define SHTDN_REASON_MAJOR_APPLICATION          0x00040000
#define SHTDN_REASON_MAJOR_SYSTEM               0x00050000
#define SHTDN_REASON_MAJOR_POWER                0x00060000
#define SHTDN_REASON_MAJOR_LEGACY_API           0x00070000

// Microsoft minor reasons.
#define SHTDN_REASON_MINOR_OTHER                0x00000000
#define SHTDN_REASON_MINOR_NONE                 0x000000ff
#define SHTDN_REASON_MINOR_MAINTENANCE          0x00000001
#define SHTDN_REASON_MINOR_INSTALLATION         0x00000002
#define SHTDN_REASON_MINOR_UPGRADE              0x00000003
#define SHTDN_REASON_MINOR_RECONFIG             0x00000004
#define SHTDN_REASON_MINOR_HUNG                 0x00000005
#define SHTDN_REASON_MINOR_UNSTABLE             0x00000006
#define SHTDN_REASON_MINOR_DISK                 0x00000007
#define SHTDN_REASON_MINOR_PROCESSOR            0x00000008
#define SHTDN_REASON_MINOR_NETWORKCARD          0x00000009
#define SHTDN_REASON_MINOR_POWER_SUPPLY         0x0000000a
#define SHTDN_REASON_MINOR_CORDUNPLUGGED        0x0000000b
#define SHTDN_REASON_MINOR_ENVIRONMENT          0x0000000c
#define SHTDN_REASON_MINOR_HARDWARE_DRIVER      0x0000000d
#define SHTDN_REASON_MINOR_OTHERDRIVER          0x0000000e
#define SHTDN_REASON_MINOR_BLUESCREEN           0x0000000F
#define SHTDN_REASON_MINOR_SERVICEPACK          0x00000010
#define SHTDN_REASON_MINOR_HOTFIX               0x00000011
#define SHTDN_REASON_MINOR_SECURITYFIX          0x00000012
#define SHTDN_REASON_MINOR_SECURITY             0x00000013
#define SHTDN_REASON_MINOR_NETWORK_CONNECTIVITY 0x00000014
#define SHTDN_REASON_MINOR_WMI                  0x00000015 
#define SHTDN_REASON_MINOR_SERVICEPACK_UNINSTALL 0x00000016
#define SHTDN_REASON_MINOR_HOTFIX_UNINSTALL     0x00000017
#define SHTDN_REASON_MINOR_SECURITYFIX_UNINSTALL 0x00000018
#define SHTDN_REASON_MINOR_MMC                  0x00000019
#define SHTDN_REASON_MINOR_SYSTEMRESTORE        0x0000001a
#define SHTDN_REASON_MINOR_TERMSRV              0x00000020
#define SHTDN_REASON_MINOR_DC_PROMOTION         0x00000021
#define SHTDN_REASON_MINOR_DC_DEMOTION          0x00000022

#define SHTDN_REASON_UNKNOWN                    SHTDN_REASON_MINOR_NONE
#define SHTDN_REASON_LEGACY_API                 (SHTDN_REASON_MAJOR_LEGACY_API | SHTDN_REASON_FLAG_PLANNED)

// This mask cuts out UI flags.
#define SHTDN_REASON_VALID_BIT_MASK             0xc0ffffff

// Convenience flags.
#define PCLEANUI                (SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_FLAG_CLEAN_UI)
#define UCLEANUI                (SHTDN_REASON_FLAG_CLEAN_UI)
#define PDIRTYUI                (SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_FLAG_DIRTY_UI)
#define UDIRTYUI                (SHTDN_REASON_FLAG_DIRTY_UI)

/*
 * Maximum character lengths for reason name, description, problem id, and
 * comment respectively.
 */
#define MAX_REASON_NAME_LEN  64
#define MAX_REASON_DESC_LEN  256
#define MAX_REASON_BUGID_LEN 32
#define MAX_REASON_COMMENT_LEN  512
#define SHUTDOWN_TYPE_LEN 32

/*
 *	S.E.T. policy value
 *
 */
#define POLICY_SHOWREASONUI_NEVER				0
#define POLICY_SHOWREASONUI_ALWAYS				1
#define POLICY_SHOWREASONUI_WORKSTATIONONLY		2
#define POLICY_SHOWREASONUI_SERVERONLY			3


/*
 * Snapshot policy values
 */
#define SNAPSHOT_POLICY_NEVER            0
#define SNAPSHOT_POLICY_ALWAYS           1
#define SNAPSHOT_POLICY_UNPLANNED        2

/*
 * Maximue user defined reasons
 */
#define MAX_NUM_REASONS 256

#endif // !defined SENTINEL_Reason
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\recapis.h ===
//--------------------------------------------------------------------------
//  This is part of the Microsoft Tablet PC Platform SDK
//  Copyright (C) 2002 Microsoft Corporation
//  All rights reserved.
//
//
// Module:       
//      RecApis.h
//
//--------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#include "tpcshrd.h"
#include "RecTypes.h"

#ifndef __HRECOALT__
#define __HRECOALT__
DECLARE_HANDLE(HRECOALT); // definition of a handle for the alternate
#endif

#ifndef __HRECOCONTEXT__
#define __HRECOCONTEXT__
DECLARE_HANDLE(HRECOCONTEXT); // definition of a handle for the reco context
#endif

#ifndef __HRECOGNIZER__
#define __HRECOGNIZER__
DECLARE_HANDLE(HRECOGNIZER); // definition of a handle for the recognizer
#endif

#ifndef __HRECOLATTICE__
#define __HRECOLATTICE__
DECLARE_HANDLE(HRECOLATTICE); // definition of a handle for the lattice
#endif

#ifndef __HRECOWORDLIST__
#define __HRECOWORDLIST__
DECLARE_HANDLE(HRECOWORDLIST); // definition of a handle for the lattice
#endif

typedef HRESULT (*PfnRecoCallback)(DWORD, LPBYTE, HRECOCONTEXT);


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

////////////////////////
// IRecognizer
////////////////////////
HRESULT WINAPI CreateRecognizer(CLSID *pCLSID, HRECOGNIZER *phrec);
HRESULT WINAPI DestroyRecognizer(HRECOGNIZER hrec);
HRESULT WINAPI GetRecoAttributes(HRECOGNIZER hrec, RECO_ATTRS* pRecoAttrs);
HRESULT WINAPI CreateContext(HRECOGNIZER hrec, HRECOCONTEXT *phrc);
HRESULT WINAPI DestroyContext(HRECOCONTEXT hrc);
HRESULT WINAPI GetResultPropertyList(HRECOGNIZER hrec, ULONG* pPropertyCount, GUID*pPropertyGuid);
HRESULT WINAPI GetPreferredPacketDescription(HRECOGNIZER hrec, PACKET_DESCRIPTION* pPacketDescription);
HRESULT WINAPI GetUnicodeRanges(HRECOGNIZER hrec, ULONG *pcRanges, CHARACTER_RANGE *pcr);

////////////////////////
// IRecoContext
////////////////////////
HRESULT WINAPI AddStroke(HRECOCONTEXT hrc, const PACKET_DESCRIPTION* pPacketDesc, ULONG cbPacket, const BYTE *pPacket, const XFORM *pXForm);
HRESULT WINAPI GetBestResultString(HRECOCONTEXT hrc, __inout ULONG *pcSize, __out_ecount_opt (*pcSize) WCHAR* pwcBestResult);
HRESULT WINAPI DestroyAlternate(HRECOALT hrcalt);
HRESULT WINAPI SetGuide(HRECOCONTEXT hrc, const RECO_GUIDE* pGuide, ULONG iIndex);
HRESULT WINAPI GetGuide(HRECOCONTEXT hrc, RECO_GUIDE* pGuide, ULONG *piIndex);
HRESULT WINAPI AdviseInkChange(HRECOCONTEXT hrc, BOOL bNewStroke);
HRESULT WINAPI SetCACMode(HRECOCONTEXT hrc, int iMode);
HRESULT WINAPI EndInkInput(HRECOCONTEXT hrc);
HRESULT WINAPI CloneContext(HRECOCONTEXT hrc, HRECOCONTEXT* pCloneHrc);
HRESULT WINAPI ResetContext(HRECOCONTEXT hrc);
HRESULT WINAPI Process(HRECOCONTEXT hrc, BOOL *pbPartialProcessing);
HRESULT WINAPI SetFactoid(HRECOCONTEXT hrc, ULONG cwcFactoid, const WCHAR *pwcFactoid);
HRESULT WINAPI SetFlags(HRECOCONTEXT hrc, DWORD dwFlags);
HRESULT WINAPI GetLatticePtr(HRECOCONTEXT hrc, RECO_LATTICE **ppLattice);
HRESULT WINAPI SetTextContext(HRECOCONTEXT hrc, ULONG cwcBefore, __ecount(cwcBefore) const WCHAR *pwcBefore, ULONG cwcAfter, __ecount(cwcAfter) const WCHAR *pwcAfter);
HRESULT WINAPI GetEnabledUnicodeRanges(HRECOCONTEXT hrc, ULONG *pcRanges, CHARACTER_RANGE *pcr);
HRESULT WINAPI SetEnabledUnicodeRanges(HRECOCONTEXT hrc, ULONG cRanges, CHARACTER_RANGE *pcr);
HRESULT WINAPI GetContextPropertyList(HRECOCONTEXT hrc, ULONG *pcProperties, GUID *pPropertyGUIDS);
HRESULT WINAPI GetContextPropertyValue(HRECOCONTEXT hrc, GUID *pGuid, ULONG *pcbSize, BYTE *pProperty);
HRESULT WINAPI SetContextPropertyValue(HRECOCONTEXT hrc, GUID *pGuid, ULONG cbSize, BYTE *pProperty);
HRESULT WINAPI IsStringSupported(HRECOCONTEXT hrc, ULONG wcString, const WCHAR *pwcString);
HRESULT WINAPI SetWordList(HRECOCONTEXT hrc, HRECOWORDLIST hwl);
HRESULT WINAPI GetContextPreferenceFlags(HRECOCONTEXT hrc, DWORD *pdwContextPreferenceFlags);
HRESULT WINAPI GetRightSeparator(HRECOCONTEXT hrc, __inout ULONG *pcSize, __out_ecount(*pcSize) OPTIONAL WCHAR* pwcRightSeparator);
HRESULT WINAPI GetLeftSeparator(HRECOCONTEXT hrc, __inout ULONG *pcSize, __out_ecount(*pcSize) OPTIONAL WCHAR* pwcLeftSeparator);

////////////////////////
// IRecoWordList
////////////////////////
HRESULT WINAPI DestroyWordList(HRECOWORDLIST hwl);
HRESULT WINAPI AddWordsToWordList(HRECOWORDLIST hwl, __nullnullterminated WCHAR * pwcWords);
HRESULT WINAPI MakeWordList(HRECOGNIZER hrec, __nullnullterminated WCHAR *pBuffer, HRECOWORDLIST *phwl);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Reconcil.h ===
/*
 * Copyright (C) Microsoft Corporation, 1990-1999
 * reconcil.h - OLE reconciliation interface definitions.
 */


#ifndef __RECONCIL_H__
#define __RECONCIL_H__

#if _MSC_VER > 1000
#pragma once
#endif

/* Headers
 **********/

#include <recguids.h>


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Constants
 ************/

/* for use in IStorage::SetStateBits() */

#define STATEBITS_FLAT                 (0x0001)

/* reconciliation SCODEs */

#define REC_S_IDIDTHEUPDATES           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1000)
#define REC_S_NOTCOMPLETE              MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1001)
#define REC_S_NOTCOMPLETEBUTPROPAGATE  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1002)

#define REC_E_ABORTED                  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1000)
#define REC_E_NOCALLBACK               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1001)
#define REC_E_NORESIDUES               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1002)
#define REC_E_TOODIFFERENT             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1003)
#define REC_E_INEEDTODOTHEUPDATES      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1004)


/* Interfaces
 *************/

#undef  INTERFACE
#define INTERFACE INotifyReplica

DECLARE_INTERFACE_(INotifyReplica, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* INotifyReplica methods */

   STDMETHOD(YouAreAReplica)(THIS_
                             ULONG ulcOtherReplicas,
                             IMoniker **rgpmkOtherReplicas) PURE;
};

#undef  INTERFACE
#define INTERFACE IReconcileInitiator

DECLARE_INTERFACE_(IReconcileInitiator, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IReconcileInitiator methods */

   STDMETHOD(SetAbortCallback)(THIS_
                               IUnknown *punkForAbort) PURE;

   STDMETHOD(SetProgressFeedback)(THIS_
                                  ULONG ulProgress,
                                  ULONG ulProgressMax) PURE;
};

/* IReconcilableObject::Reconcile() flags */

typedef enum _reconcilef
{
   /* interaction with the user is allowed */

   RECONCILEF_MAYBOTHERUSER         = 0x0001,

   /*
    * hwndProgressFeedback may be used to provide reconciliation progress
    * feedback to the user.
    */

   RECONCILEF_FEEDBACKWINDOWVALID   = 0x0002,

   /* residue support not required */

   RECONCILEF_NORESIDUESOK          = 0x0004,

   /* caller not interested in callee's residues */

   RECONCILEF_OMITSELFRESIDUE       = 0x0008,

   /*
    * Reconcile() call resuming after a previous Reconcile() call returned
    * REC_E_NOTCOMPLETE
    */

   RECONCILEF_RESUMERECONCILIATION  = 0x0010,

   /* Object may perform all updates. */

   RECONCILEF_YOUMAYDOTHEUPDATES    = 0x0020,

   /* Only this object has been changed. */

   RECONCILEF_ONLYYOUWERECHANGED    = 0x0040,

   /* flag combinations */

   ALL_RECONCILE_FLAGS              = (RECONCILEF_MAYBOTHERUSER |
                                       RECONCILEF_FEEDBACKWINDOWVALID |
                                       RECONCILEF_NORESIDUESOK |
                                       RECONCILEF_OMITSELFRESIDUE |
                                       RECONCILEF_RESUMERECONCILIATION |
                                       RECONCILEF_YOUMAYDOTHEUPDATES |
                                       RECONCILEF_ONLYYOUWERECHANGED)
}
RECONCILEF;

#undef  INTERFACE
#define INTERFACE IReconcilableObject

DECLARE_INTERFACE_(IReconcilableObject, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IReconcilableObject methods */

   STDMETHOD(Reconcile)(THIS_
                        IReconcileInitiator *pInitiator,
                        DWORD dwFlags,
                        HWND hwndOwner,
                        HWND hwndProgressFeedback,
                        ULONG ulcInput,
                        IMoniker **rgpmkOtherInput,
                        PLONG plOutIndex,
                        IStorage *pstgNewResidues,
                        PVOID pvReserved) PURE;

   STDMETHOD(GetProgressFeedbackMaxEstimate)(THIS_
                                             PULONG pulProgressMax) PURE;
};

#undef  INTERFACE
#define INTERFACE IBriefcaseInitiator

DECLARE_INTERFACE_(IBriefcaseInitiator, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IBriefcaseInitiator methods */

   STDMETHOD(IsMonikerInBriefcase)(THIS_
                                   IMoniker *pmk) PURE;
};


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */


#endif   /* ! __RECONCIL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\rectypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for rectypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __rectypes_h__
#define __rectypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_rectypes_0000_0000 */
/* [local] */ 

#include "RecDefs.h"
#define SAFE_PARTIAL     1
#define BEST_COMPLETE    2
#define MAX_VENDORNAME   32
#define MAX_FRIENDLYNAME 64
#define MAX_LANGUAGES    64
#define CAC_FULL     0
#define CAC_PREFIX   1
#define CAC_RANDOM   2
#define ASYNC_RECO_INTERRUPTED               0x1     //when the process is interrupted
#define ASYNC_RECO_PROCESS_FAILED            0x2
#define ASYNC_RECO_ADDSTROKE_FAILED          0x4
#define ASYNC_RECO_SETCACMODE_FAILED         0x8
#define ASYNC_RECO_RESETCONTEXT_FAILED       0x10
#define ASYNC_RECO_SETGUIDE_FAILED           0x20
#define ASYNC_RECO_SETFLAGS_FAILED           0x40
#define ASYNC_RECO_SETFACTOID_FAILED         0x80
#define ASYNC_RECO_SETTEXTCONTEXT_FAILED     0x100
#define ASYNC_RECO_SETWORDLIST_FAILED        0x200
#define RF_DONTCARE              1L      // overrides all other ones if set
#define RF_OBJECT                2L      // if not set, this is a text recognizer
#define RF_FREE_INPUT            4L      // supports free input
#define RF_LINED_INPUT           8L      // supports simple guide structure with lines only
#define RF_BOXED_INPUT           16L     // supports boxed (guided) input
#define RF_CAC_INPUT             32L     // supports boxed Character Auto Completion
#define RF_RIGHT_AND_DOWN        64L     // used in western and FE languages
#define RF_LEFT_AND_DOWN         128L    // used in Hebrew and Arabic
#define RF_DOWN_AND_LEFT         256L    // used in most FE languages
#define RF_DOWN_AND_RIGHT        512L    // used in Chinese only
#define RF_ARBITRARY_ANGLE       1024L   // can read text written at arbitrary angles (mimio)
#define RF_LATTICE               2048L   // can return lattice in results
#define RF_ADVISEINKCHANGE       4096L   // advise ink change can interrupt process
#define RF_STROKEREORDER         8192L   // indicates that stroke order - spatial and temporal is handled
#define RF_PERSONALIZABLE        16384L  // Supports personalization
//                               32768L is reserved.
#define RF_PERFORMSLINEBREAKING  65536L  // Recognizer prefers to do the line breaking
#define RF_REQUIRESSEGMENTATIONBREAKING 131072L // Recognizer wants only segments of ink
#ifndef __RECOTYPES__
#define __RECOTYPES__
typedef struct tagRECO_GUIDE
    {
    int xOrigin;
    int yOrigin;
    int cxBox;
    int cyBox;
    int cxBase;
    int cyBase;
    int cHorzBox;
    int cVertBox;
    int cyMid;
    } 	RECO_GUIDE;

typedef struct tagRECO_ATTRS
    {
    DWORD dwRecoCapabilityFlags;
    WCHAR awcVendorName[ 32 ];
    WCHAR awcFriendlyName[ 64 ];
    WORD awLanguageId[ 64 ];
    } 	RECO_ATTRS;

typedef struct tagRECO_RANGE
    {
    ULONG iwcBegin;
    ULONG cCount;
    } 	RECO_RANGE;

typedef struct tagLINE_SEGMENT
    {
    POINT PtA;
    POINT PtB;
    } 	LINE_SEGMENT;

typedef struct tagLATTICE_METRICS
    {
    LINE_SEGMENT lsBaseline;
    short iMidlineOffset;
    } 	LATTICE_METRICS;

typedef 
enum enumLINE_METRICS
    {	LM_BASELINE	= 0,
	LM_MIDLINE	= 1,
	LM_ASCENDER	= 2,
	LM_DESCENDER	= 3
    } 	LINE_METRICS;

typedef 
enum enumCONFIDENCE_LEVEL
    {	CFL_STRONG	= 0,
	CFL_INTERMEDIATE	= 1,
	CFL_POOR	= 2
    } 	CONFIDENCE_LEVEL;

typedef 
enum enumALT_BREAKS
    {	ALT_BREAKS_SAME	= 0,
	ALT_BREAKS_UNIQUE	= 1,
	ALT_BREAKS_FULL	= 2
    } 	ALT_BREAKS;

typedef 
enum enumRECO_TYPE
    {	RECO_TYPE_WSTRING	= 0,
	RECO_TYPE_WCHAR	= 1
    } 	RECO_TYPE;

typedef struct tagRECO_LATTICE_PROPERTY
    {
    GUID guidProperty;
    USHORT cbPropertyValue;
    BYTE *pPropertyValue;
    } 	RECO_LATTICE_PROPERTY;

typedef struct tagRECO_LATTICE_PROPERTIES
    {
    ULONG cProperties;
    RECO_LATTICE_PROPERTY **apProps;
    } 	RECO_LATTICE_PROPERTIES;

typedef int RECO_SCORE;

typedef struct tagRECO_LATTICE_ELEMENT
    {
    RECO_SCORE score;
    WORD type;
    BYTE *pData;
    ULONG ulNextColumn;
    ULONG ulStrokeNumber;
    RECO_LATTICE_PROPERTIES epProp;
    } 	RECO_LATTICE_ELEMENT;

typedef struct tagRECO_LATTICE_COLUMN
    {
    ULONG key;
    RECO_LATTICE_PROPERTIES cpProp;
    ULONG cStrokes;
    ULONG *pStrokes;
    ULONG cLatticeElements;
    RECO_LATTICE_ELEMENT *pLatticeElements;
    } 	RECO_LATTICE_COLUMN;

typedef struct tagRECO_LATTICE
    {
    ULONG ulColumnCount;
    RECO_LATTICE_COLUMN *pLatticeColumns;
    ULONG ulPropertyCount;
    GUID *pGuidProperties;
    ULONG ulBestResultColumnCount;
    ULONG *pulBestResultColumns;
    ULONG *pulBestResultIndexes;
    } 	RECO_LATTICE;

typedef struct tagCHARACTER_RANGE
    {
    WCHAR wcLow;
    USHORT cChars;
    } 	CHARACTER_RANGE;

typedef struct tagCHARACTER_RANGE *PCHARACTER_RANGE;

#endif


extern RPC_IF_HANDLE __MIDL_itf_rectypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rectypes_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RefPtrCo.h ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  RefPtrCo.h
//
//  Purpose: definition of TRefPointerCollection template
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __REFPTRCOLLECTION_H__
#define __REFPTRCOLLECTION_H__

#include <chptrarr.h>

// Enumeration helpers
typedef	DWORD	REFPTRCOLLECTION_POSITION;
#define	REFPTRCOLLECTION_START	0xFFFFFFFF;

template <class TYPED_PTR> class TRefPointerCollection : public CThreadBase
{
public:

	// Construction/Destruction
	TRefPointerCollection();
	~TRefPointerCollection();
    TRefPointerCollection(const TRefPointerCollection& trpc);

	// Allows addition and enumeration of collection
	BOOL	Add( TYPED_PTR* ptr );

	BOOL		BeginEnum( REFPTRCOLLECTION_POSITION& pos );
	TYPED_PTR*	GetNext( REFPTRCOLLECTION_POSITION& pos );
	void		EndEnum( void );

	void		Empty( void );
    int         GetSize( void ) const;

protected:

	// Allows easy and quick transference of data (it was =, but
	// because we'll inherit classes off the template, we won't
	// inherit that particular overload (some C++ thingie)

	const TRefPointerCollection<TYPED_PTR>& Copy( const TRefPointerCollection<TYPED_PTR>& );


private:

	CHPtrArray		m_ptrArray;

};

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::TRefPointerCollection
//
//	Class Constructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TRefPointerCollection<TYPED_PTR>::TRefPointerCollection( void )
:	CThreadBase(),
	m_ptrArray()
{
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPointerCollection::~CRefPointerCollection
//
//	Class Destructor.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TRefPointerCollection<TYPED_PTR>::~TRefPointerCollection( void )
{
	Empty();
}


////////////////////////////////////////////////////////////////////////
//
//	Function:	CRefPointerCollection::CRefPointerCollection
//              Copy constructor
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////
template <class TYPED_PTR>
TRefPointerCollection<TYPED_PTR>::TRefPointerCollection(
    const TRefPointerCollection& trpc)
{
    Copy(trpc);	
}


////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::Add
//
//	Adds a new referenced pointer to the collection.
//
//	Inputs:		T*				ptr - Pointer to add.
//
//	Outputs:	None.
//
//	Return:		TRUE/FALSE		Success/Failure of Add.
//
//	Comments:	AddRefs the pointer, then adds it to the array.  We
//				will need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
BOOL TRefPointerCollection<TYPED_PTR>::Add( TYPED_PTR* ptr )
{
	BOOL	fReturn = FALSE;

	if ( NULL != ptr )
	{
		// Get write access
		if ( BeginWrite() )
		{
            try
            {
			    // If Add succeeds, the pointer will be released when it
			    // is removed.

			    ptr->AddRef();

			    if ( m_ptrArray.Add( (void*) ptr ) >= 0 )
			    {
				    fReturn = TRUE;
			    }
			    else
			    {
				    ptr->Release();	// Add failed, so Release the AddRef
			    }
            }
            catch ( CHeap_Exception& )
            {
    	        EndWrite() ;
                throw;
            }
            catch ( CFramework_Exception& e_FR )
            {
    	        EndWrite() ;
                throw;
            }

			EndWrite();	// Release the BeginWrite()
		}
	}

	return fReturn;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::BeginEnum
//
//	Gains Read Access to the collection, then returns an appropriate
//	REFPTRCOLLECTION_POSITION to get the first index in the array.
//
//	Inputs:		None.
//
//	Outputs:	REFPTRCOLLECTION_POSITION&	pos - Position we retrieved.
//
//	Return:		BOOL		TRUE/FALSE - Access was granted
//
//	Comments:	We need Read Access to do this.  This can effectively
//				lock out other threads.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
BOOL TRefPointerCollection<TYPED_PTR>::BeginEnum( REFPTRCOLLECTION_POSITION& pos )
{
	BOOL	fReturn	=	FALSE;

	if ( BeginRead() )
	{
		pos = REFPTRCOLLECTION_START;
		fReturn = TRUE;
	}

	return fReturn;

}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::EndEnum
//
//	Signals the end of an enumeration.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		BOOL		TRUE/FALSE - Access was granted
//
//	Comments:	Ends Read Access granted by calling BeginEnum().
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
void TRefPointerCollection<TYPED_PTR>::EndEnum( void )
{
	EndRead();
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::GetNext
//
//	Uses the REFPTRCOLLECTION_POSITION to get the next index in the
//	collection.
//
//	Inputs:		None.
//
//	Outputs:	REFPTRCOLLECTION_POSITION&	pos - Position we retrieved.
//
//	Return:		T*		NULL if failure.
//
//	Comments:	We need Read Access to do this.  The pointer is AddRef'd
//				on the way out.  User must Release the pointer himself.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
TYPED_PTR* TRefPointerCollection<TYPED_PTR>::GetNext( REFPTRCOLLECTION_POSITION& pos )
{
	TYPED_PTR*	ptr = NULL;

	if ( BeginRead() )
	{
		if ( ++pos < (DWORD) m_ptrArray.GetSize() )
		{
			ptr = (TYPED_PTR*) m_ptrArray.GetAt( pos );

			if ( NULL != ptr )
			{
				ptr->AddRef();
			}
		}

		EndRead();
	}

	return ptr;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::Empty
//
//	Empties out the collection, Releasing Pointers as it does do.
//
//	Inputs:		None.
//
//	Outputs:	None.
//
//	Return:		None.
//
//	Comments:	We need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
void TRefPointerCollection<TYPED_PTR>::Empty( void )
{
	// By default this is an infinite wait, so it best come back

	BeginWrite();

    try
    {

	    int	nSize	=	m_ptrArray.GetSize();

	    // Only empty it if it is not empty
	    if ( nSize > 0 )
	    {
		    TYPED_PTR*	ptr		=	NULL;

		    for ( int nCtr = 0; nCtr < nSize; nCtr++ )
		    {
			    ptr = (TYPED_PTR*) m_ptrArray[nCtr];

			    if ( NULL != ptr )
			    {
				    ptr->Release();	// AddRef we did when we added it
			    }
		    }

		    // Now dump the array
		    m_ptrArray.RemoveAll();

	    }	// IF nSize > 0

    }
    catch ( CHeap_Exception& )
    {
    	EndWrite() ;
        throw;
    }
    catch ( CFramework_Exception& e_FR )
    {
        EndWrite() ;
        throw;
    }

	EndWrite();
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::Copy
//
//	Empties out the collection, copies in another one, addrefing
//	pointers as we go.
//
//	Inputs:		const T&	collection
//
//	Outputs:	None.
//
//	Return:		const T&	this
//
//	Comments:	We need Write Access to do this.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
const TRefPointerCollection<TYPED_PTR>& TRefPointerCollection<TYPED_PTR>::Copy( const TRefPointerCollection<TYPED_PTR>& collection )
{
	// By default this is an infinite wait, so it best come back
	BeginWrite();

    try
    {

	    // Dump out the array
	    Empty();

	    int	nSize = collection.m_ptrArray.GetSize();

	    for ( int nCount = 0; nCount < nSize; nCount++ )
	    {
		    TYPED_PTR*	ptr = (TYPED_PTR*) collection.m_ptrArray[nCount];

		    // Add will automatically AddRef the pointer again.
		    Add( ptr );
	    }
    }
    catch ( CHeap_Exception& )
    {
    	EndWrite() ;
        throw;
    }
    catch ( CFramework_Exception& e_FR )
    {
        EndWrite() ;
        throw;
    }

	EndWrite();

	return *this;
}

////////////////////////////////////////////////////////////////////////
//
//	Function:	TRefPointerCollection::GetSize
//
//	Inputs:		None.
//
//	Outputs:	Number of elements in the collection
//
//	Return:		None.
//
//	Comments:	None.
//
////////////////////////////////////////////////////////////////////////

template <class TYPED_PTR>
int TRefPointerCollection<TYPED_PTR>::GetSize(void) const
{
    return m_ptrArray.GetSize();
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\rendezvoussession_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for rendezvoussession.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_RendezvousSessionLib,0xEFD856A4,0x5A85,0x4A1B,0xAD,0xD5,0x2E,0xAD,0xAC,0xE6,0xF6,0xA2);


MIDL_DEFINE_GUID(IID, IID_IRendezvousSession,0x9BA4B1DD,0x8B0C,0x48B7,0x9E,0x7C,0x2F,0x25,0x85,0x7C,0x8D,0xF5);


MIDL_DEFINE_GUID(IID, DIID_DRendezvousSessionEvents,0x3FA19CF8,0x64C4,0x4F53,0xAE,0x60,0x63,0x5B,0x38,0x06,0xEC,0xA6);


MIDL_DEFINE_GUID(IID, IID_IRendezvousApplication,0x4F4D070B,0xA275,0x49FB,0xB1,0x0D,0x8E,0xC2,0x63,0x87,0xB5,0x0D);


MIDL_DEFINE_GUID(CLSID, CLSID_RendezvousApplication,0x0B7E019A,0xB5DE,0x47fa,0x89,0x66,0x90,0x82,0xF8,0x2F,0xB1,0x92);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\rendezvoussession.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for rendezvoussession.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __rendezvoussession_h__
#define __rendezvoussession_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IRendezvousSession_FWD_DEFINED__
#define __IRendezvousSession_FWD_DEFINED__
typedef interface IRendezvousSession IRendezvousSession;
#endif 	/* __IRendezvousSession_FWD_DEFINED__ */


#ifndef __DRendezvousSessionEvents_FWD_DEFINED__
#define __DRendezvousSessionEvents_FWD_DEFINED__
typedef interface DRendezvousSessionEvents DRendezvousSessionEvents;
#endif 	/* __DRendezvousSessionEvents_FWD_DEFINED__ */


#ifndef __IRendezvousApplication_FWD_DEFINED__
#define __IRendezvousApplication_FWD_DEFINED__
typedef interface IRendezvousApplication IRendezvousApplication;
#endif 	/* __IRendezvousApplication_FWD_DEFINED__ */


#ifndef __RendezvousApplication_FWD_DEFINED__
#define __RendezvousApplication_FWD_DEFINED__

#ifdef __cplusplus
typedef class RendezvousApplication RendezvousApplication;
#else
typedef struct RendezvousApplication RendezvousApplication;
#endif /* __cplusplus */

#endif 	/* __RendezvousApplication_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_rendezvoussession_0000_0000 */
/* [local] */ 

#define	DISPID_EVENT_ON_STATE_CHANGED	( 5 )

#define	DISPID_EVENT_ON_TERMINATION	( 6 )

#define	DISPID_EVENT_ON_CONTEXT_DATA	( 7 )

#define	DISPID_EVENT_ON_SEND_ERROR	( 8 )



extern RPC_IF_HANDLE __MIDL_itf_rendezvoussession_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rendezvoussession_0000_0000_v0_0_s_ifspec;


#ifndef __RendezvousSessionLib_LIBRARY_DEFINED__
#define __RendezvousSessionLib_LIBRARY_DEFINED__

/* library RendezvousSessionLib */
/* [helpstring][version][uuid] */ 

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_rendezvoussession_0000_0000_0001
    {	RSS_UNKNOWN	= 0,
	RSS_READY	= ( RSS_UNKNOWN + 1 ) ,
	RSS_INVITATION	= ( RSS_READY + 1 ) ,
	RSS_ACCEPTED	= ( RSS_INVITATION + 1 ) ,
	RSS_CONNECTED	= ( RSS_ACCEPTED + 1 ) ,
	RSS_CANCELLED	= ( RSS_CONNECTED + 1 ) ,
	RSS_DECLINED	= ( RSS_CANCELLED + 1 ) ,
	RSS_TERMINATED	= ( RSS_DECLINED + 1 ) 
    } 	RENDEZVOUS_SESSION_STATE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_rendezvoussession_0000_0000_0002
    {	RSF_NONE	= 0,
	RSF_INVITER	= 0x1,
	RSF_INVITEE	= 0x2,
	RSF_ORIGINAL_INVITER	= 0x4,
	RSF_REMOTE_LEGACYSESSION	= 0x8,
	RSF_REMOTE_WIN7SESSION	= 0x10
    } 	RENDEZVOUS_SESSION_FLAGS;


EXTERN_C const IID LIBID_RendezvousSessionLib;

#ifndef __IRendezvousSession_INTERFACE_DEFINED__
#define __IRendezvousSession_INTERFACE_DEFINED__

/* interface IRendezvousSession */
/* [unique][oleautomation][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRendezvousSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9BA4B1DD-8B0C-48B7-9E7C-2F25857C8DF5")
    IRendezvousSession : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out RENDEZVOUS_SESSION_STATE *pSessionState) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RemoteUser( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bstrUserName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Flags( 
            /* [retval][out] */ __RPC__out LONG *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendContextData( 
            /* [in] */ __RPC__in BSTR bstrData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( 
            /* [in] */ HRESULT hr,
            /* [in] */ __RPC__in BSTR bstrAppData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRendezvousSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRendezvousSession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRendezvousSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRendezvousSession * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            __RPC__in IRendezvousSession * This,
            /* [retval][out] */ __RPC__out RENDEZVOUS_SESSION_STATE *pSessionState);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RemoteUser )( 
            __RPC__in IRendezvousSession * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bstrUserName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Flags )( 
            __RPC__in IRendezvousSession * This,
            /* [retval][out] */ __RPC__out LONG *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SendContextData )( 
            __RPC__in IRendezvousSession * This,
            /* [in] */ __RPC__in BSTR bstrData);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            __RPC__in IRendezvousSession * This,
            /* [in] */ HRESULT hr,
            /* [in] */ __RPC__in BSTR bstrAppData);
        
        END_INTERFACE
    } IRendezvousSessionVtbl;

    interface IRendezvousSession
    {
        CONST_VTBL struct IRendezvousSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRendezvousSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRendezvousSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRendezvousSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRendezvousSession_get_State(This,pSessionState)	\
    ( (This)->lpVtbl -> get_State(This,pSessionState) ) 

#define IRendezvousSession_get_RemoteUser(This,bstrUserName)	\
    ( (This)->lpVtbl -> get_RemoteUser(This,bstrUserName) ) 

#define IRendezvousSession_get_Flags(This,pFlags)	\
    ( (This)->lpVtbl -> get_Flags(This,pFlags) ) 

#define IRendezvousSession_SendContextData(This,bstrData)	\
    ( (This)->lpVtbl -> SendContextData(This,bstrData) ) 

#define IRendezvousSession_Terminate(This,hr,bstrAppData)	\
    ( (This)->lpVtbl -> Terminate(This,hr,bstrAppData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRendezvousSession_INTERFACE_DEFINED__ */


#ifndef __DRendezvousSessionEvents_DISPINTERFACE_DEFINED__
#define __DRendezvousSessionEvents_DISPINTERFACE_DEFINED__

/* dispinterface DRendezvousSessionEvents */
/* [uuid] */ 


EXTERN_C const IID DIID_DRendezvousSessionEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("3FA19CF8-64C4-4F53-AE60-635B3806ECA6")
    DRendezvousSessionEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DRendezvousSessionEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in DRendezvousSessionEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in DRendezvousSessionEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in DRendezvousSessionEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in DRendezvousSessionEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in DRendezvousSessionEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in DRendezvousSessionEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DRendezvousSessionEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DRendezvousSessionEventsVtbl;

    interface DRendezvousSessionEvents
    {
        CONST_VTBL struct DRendezvousSessionEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DRendezvousSessionEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DRendezvousSessionEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DRendezvousSessionEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DRendezvousSessionEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DRendezvousSessionEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DRendezvousSessionEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DRendezvousSessionEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DRendezvousSessionEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IRendezvousApplication_INTERFACE_DEFINED__
#define __IRendezvousApplication_INTERFACE_DEFINED__

/* interface IRendezvousApplication */
/* [unique][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_IRendezvousApplication;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F4D070B-A275-49FB-B10D-8EC26387B50D")
    IRendezvousApplication : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRendezvousSession( 
            /* [in] */ __RPC__in_opt IUnknown *pRendezvousSession) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRendezvousApplicationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRendezvousApplication * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRendezvousApplication * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRendezvousApplication * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRendezvousSession )( 
            __RPC__in IRendezvousApplication * This,
            /* [in] */ __RPC__in_opt IUnknown *pRendezvousSession);
        
        END_INTERFACE
    } IRendezvousApplicationVtbl;

    interface IRendezvousApplication
    {
        CONST_VTBL struct IRendezvousApplicationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRendezvousApplication_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRendezvousApplication_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRendezvousApplication_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRendezvousApplication_SetRendezvousSession(This,pRendezvousSession)	\
    ( (This)->lpVtbl -> SetRendezvousSession(This,pRendezvousSession) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRendezvousApplication_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_RendezvousApplication;

#ifdef __cplusplus

class DECLSPEC_UUID("0B7E019A-B5DE-47fa-8966-9082F82FB192")
RendezvousApplication;
#endif
#endif /* __RendezvousSessionLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RegStr.h ===
/*** regstr.h - Registry string definitions
 *
 *  This module contains public registry string definitions.
 *
 *  Copyright (c) Microsoft Corporation.  All rights reserved.
 *  Created     12/10/92
 *
 *  MODIFICATION HISTORY
 */


#ifndef _INC_REGSTR
#define _INC_REGSTR

#if _MSC_VER > 1000
#pragma once
#endif


/*** Public registry key names
 */

#define REGSTR_KEY_CLASS        TEXT("Class")      // under LOCAL_MACHINE
#define REGSTR_KEY_CONFIG       TEXT("Config")     // under LOCAL_MACHINE
#define REGSTR_KEY_ENUM         TEXT("Enum")       // under LOCAL_MACHINE
#define REGSTR_KEY_ROOTENUM     TEXT("Root")       // child of ENUM
#define REGSTR_KEY_BIOSENUM     TEXT("BIOS")       // child of ENUM
#define REGSTR_KEY_ACPIENUM     TEXT("ACPI")       // child of ENUM
#define REGSTR_KEY_PCMCIAENUM   TEXT("PCMCIA")     // child of ENUM
#define REGSTR_KEY_PCIENUM      TEXT("PCI")        // child of ENUM
#define REGSTR_KEY_VPOWERDENUM  TEXT("VPOWERD")    // child of ENUM
#ifndef NEC_98
#define REGSTR_KEY_ISAENUM      TEXT("ISAPnP")     // child of ENUM
#define REGSTR_KEY_EISAENUM     TEXT("EISA")       // child of ENUM
#else // ifdef NEC_98
#define REGSTR_KEY_ISAENUM      TEXT("C98PnP")     // child of ENUM
#define REGSTR_KEY_EISAENUM     TEXT("NESA")       // child of ENUM
#endif // ifdef NEC_98
#define REGSTR_KEY_LOGCONFIG    TEXT("LogConfig")  // child of enum\<enumerator>\<deviceid>\<instanceid>
#define REGSTR_KEY_SYSTEMBOARD  TEXT("*PNP0C01")   // child of enum\root
#define REGSTR_KEY_APM          TEXT("*PNP0C05")   // child of enum\root

#define REGSTR_KEY_INIUPDATE    TEXT("IniUpdate")
#define REG_KEY_INSTDEV         TEXT("Installed")  // child of hklm\class\classname (Win98-only)

#define REGSTR_KEY_DOSOPTCDROM  TEXT("CD-ROM")
#define REGSTR_KEY_DOSOPTMOUSE  TEXT("MOUSE")

#define REGSTR_KEY_KNOWNDOCKINGSTATES TEXT("Hardware Profiles")
#define REGSTR_KEY_DEVICEPARAMETERS   TEXT("Device Parameters")


/*** Public registry paths
 */

#define REGSTR_DEFAULT_INSTANCE          TEXT("0000")
#define REGSTR_PATH_MOTHERBOARD          REGSTR_KEY_SYSTEMBOARD TEXT("\\") REGSTR_DEFAULT_INSTANCE
#define REGSTR_PATH_SETUP                TEXT("Software\\Microsoft\\Windows\\CurrentVersion")
#define REGSTR_PATH_DRIVERSIGN           TEXT("Software\\Microsoft\\Driver Signing")
#define REGSTR_PATH_NONDRIVERSIGN        TEXT("Software\\Microsoft\\Non-Driver Signing")
#define REGSTR_PATH_DRIVERSIGN_POLICY    TEXT("Software\\Policies\\Microsoft\\Windows NT\\Driver Signing")
#define REGSTR_PATH_NONDRIVERSIGN_POLICY TEXT("Software\\Policies\\Microsoft\\Windows NT\\Non-Driver Signing")
#define REGSTR_PATH_PIFCONVERT           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\PIFConvert")
#define REGSTR_PATH_MSDOSOPTS            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\MS-DOSOptions")
#define REGSTR_PATH_NOSUGGMSDOS          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\NoMSDOSWarn")
#define REGSTR_PATH_NEWDOSBOX            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\MS-DOSSpecialConfig")
#define REGSTR_PATH_RUNONCE              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce")
#define REGSTR_PATH_RUNONCEEX            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx")
#define REGSTR_PATH_RUN                  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run")
#define REGSTR_PATH_RUNSERVICESONCE      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce")
#define REGSTR_PATH_RUNSERVICES          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunServices")
#define REGSTR_PATH_EXPLORER             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer")
#define REGSTR_PATH_PROPERTYSYSTEM       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\PropertySystem")
#define REGSTR_PATH_DETECT               TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Detect")
#define REGSTR_PATH_APPPATHS             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths")
#define REGSTR_PATH_UNINSTALL            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall")
#define REGSTR_PATH_REALMODENET          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Network\\Real Mode Net")
#define REGSTR_PATH_NETEQUIV             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Network\\Equivalent")
#define REGSTR_PATH_CVNETWORK            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Network")
#define REGSTR_PATH_WMI_SECURITY         TEXT("System\\CurrentControlSet\\Control\\Wmi\\Security")
#define REGSTR_PATH_RELIABILITY          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Reliability")
#define REGSTR_PATH_RELIABILITY_POLICY   TEXT("Software\\Policies\\Microsoft\\Windows NT\\Reliability")
#define REGSTR_PATH_RELIABILITY_POLICY_SHUTDOWNREASONUI TEXT("ShutdownReasonUI")
#define REGSTR_PATH_RELIABILITY_POLICY_SNAPSHOT         TEXT("Snapshot")
#define REGSTR_PATH_RELIABILITY_POLICY_REPORTSNAPSHOT   TEXT("ReportSnapshot")

#define REGSTR_PATH_REINSTALL            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Reinstall")
#define REGSTR_PATH_NT_CURRENTVERSION TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")

#define REGSTR_PATH_VOLUMECACHE TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VolumeCaches")
#define REGSTR_VAL_DISPLAY      TEXT("display")


#define REGSTR_PATH_IDCONFIGDB  TEXT("System\\CurrentControlSet\\Control\\IDConfigDB")
#define REGSTR_PATH_CRITICALDEVICEDATABASE  TEXT("System\\CurrentControlSet\\Control\\CriticalDeviceDatabase")
#define REGSTR_PATH_CLASS       TEXT("System\\CurrentControlSet\\Services\\Class")
#define REGSTR_PATH_DISPLAYSETTINGS TEXT("Display\\Settings")
#define REGSTR_PATH_FONTS           TEXT("Display\\Fonts")
#define REGSTR_PATH_ENUM        TEXT("Enum")
#define REGSTR_PATH_ROOT        TEXT("Enum\\Root")

#define REGSTR_PATH_CURRENTCONTROLSET TEXT("System\\CurrentControlSet")
#define REGSTR_PATH_SYSTEMENUM  TEXT("System\\CurrentControlSet\\Enum")
#define REGSTR_PATH_HWPROFILES  TEXT("System\\CurrentControlSet\\Hardware Profiles")
#define REGSTR_PATH_HWPROFILESCURRENT TEXT("System\\CurrentControlSet\\Hardware Profiles\\Current")
#define REGSTR_PATH_CLASS_NT    TEXT("System\\CurrentControlSet\\Control\\Class")
#define REGSTR_PATH_PER_HW_ID_STORAGE TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\PerHwIdStorage")

#define REGSTR_PATH_DEVICE_CLASSES TEXT("System\\CurrentControlSet\\Control\\DeviceClasses")

#define REGSTR_PATH_CODEVICEINSTALLERS TEXT("System\\CurrentControlSet\\Control\\CoDeviceInstallers")
#define REGSTR_PATH_BUSINFORMATION TEXT("System\\CurrentControlSet\\Control\\PnP\\BusInformation")

#define REGSTR_PATH_SERVICES    TEXT("System\\CurrentControlSet\\Services")
#define REGSTR_PATH_VXD         TEXT("System\\CurrentControlSet\\Services\\VxD")
#define REGSTR_PATH_IOS     TEXT("System\\CurrentControlSet\\Services\\VxD\\IOS")
#define REGSTR_PATH_VMM         TEXT("System\\CurrentControlSet\\Services\\VxD\\VMM")
#define REGSTR_PATH_VPOWERD     TEXT("System\\CurrentControlSet\\Services\\VxD\\VPOWERD")
#define REGSTR_PATH_VNETSUP     TEXT("System\\CurrentControlSet\\Services\\VxD\\VNETSUP")
#define REGSTR_PATH_NWREDIR     TEXT("System\\CurrentControlSet\\Services\\VxD\\NWREDIR")
#define REGSTR_PATH_NCPSERVER   TEXT("System\\CurrentControlSet\\Services\\NcpServer\\Parameters")
#define REGSTR_PATH_VCOMM       TEXT("System\\CurrentControlSet\\Services\\VxD\\VCOMM")

#define REGSTR_PATH_IOARB       TEXT("System\\CurrentControlSet\\Services\\Arbitrators\\IOArb")
#define REGSTR_PATH_ADDRARB     TEXT("System\\CurrentControlSet\\Services\\Arbitrators\\AddrArb")
#define REGSTR_PATH_DMAARB      TEXT("System\\CurrentControlSet\\Services\\Arbitrators\\DMAArb")
#define REGSTR_PATH_IRQARB      TEXT("System\\CurrentControlSet\\Services\\Arbitrators\\IRQArb")

#define REGSTR_PATH_CODEPAGE                            TEXT("System\\CurrentControlSet\\Control\\Nls\\Codepage")
#define REGSTR_PATH_FILESYSTEM                          TEXT("System\\CurrentControlSet\\Control\\FileSystem")
#define REGSTR_PATH_FILESYSTEM_NOVOLTRACK       TEXT("System\\CurrentControlSet\\Control\\FileSystem\\NoVolTrack")
#define REGSTR_PATH_CDFS                                        TEXT("System\\CurrentControlSet\\Control\\FileSystem\\CDFS")
#define REGSTR_PATH_WINBOOT                                 TEXT("System\\CurrentControlSet\\Control\\WinBoot")
#define REGSTR_PATH_INSTALLEDFILES                      TEXT("System\\CurrentControlSet\\Control\\InstalledFiles")
#define REGSTR_PATH_VMM32FILES                          TEXT("System\\CurrentControlSet\\Control\\VMM32Files")

//
// Reasonable Limit for Values Names
//
#define REGSTR_MAX_VALUE_LENGTH     256

//
// Values used by user mode Pnp Manager
//
#define REGSTR_KEY_DEVICE_PROPERTIES               TEXT("Properties")
#define REGSTR_VAL_SLOTNUMBER                      TEXT("SlotNumber")
#define REGSTR_VAL_ATTACHEDCOMPONENTS              TEXT("AttachedComponents")
#define REGSTR_VAL_BASEDEVICEPATH                  TEXT("BaseDevicePath")
#define REGSTR_VAL_SYSTEMBUSNUMBER                 TEXT("SystemBusNumber")
#define REGSTR_VAL_BUSDATATYPE                     TEXT("BusDataType")
#define REGSTR_VAL_INTERFACETYPE                   TEXT("InterfaceType")
#define REGSTR_VAL_SERVICE                         TEXT("Service")
#define REGSTR_VAL_DETECTSIGNATURE                 TEXT("DetectSignature")
#define REGSTR_VAL_CLASSGUID                       TEXT("ClassGUID")
#define REGSTR_VAL_INSTANCEIDENTIFIER              TEXT("InstanceIdentifier")
#define REGSTR_VAL_DUPLICATEOF                     TEXT("DuplicateOf")
#define REGSTR_VAL_STATUSFLAGS                     TEXT("StatusFlags")
#define REGSTR_VAL_DISABLECOUNT                    TEXT("DisableCount")
#define REGSTR_VAL_UNKNOWNPROBLEMS                 TEXT("UnknownProblem")
#define REGSTR_VAL_DOCKSTATE                       TEXT("DockState")
#define REGSTR_VAL_PREFERENCEORDER                 TEXT("PreferenceOrder")
#define REGSTR_VAL_USERWAITINTERVAL                TEXT("UserWaitInterval")
#define REGSTR_VAL_DEVICE_INSTANCE                 TEXT("DeviceInstance")
#define REGSTR_VAL_SYMBOLIC_LINK                   TEXT("SymbolicLink")
#define REGSTR_VAL_DEFAULT                         TEXT("Default")
#define REGSTR_VAL_LOWERFILTERS                    TEXT("LowerFilters")
#define REGSTR_VAL_UPPERFILTERS                    TEXT("UpperFilters")
#define REGSTR_VAL_LOCATION_INFORMATION            TEXT("LocationInformation")
#define REGSTR_VAL_UI_NUMBER                       TEXT("UINumber")
#define REGSTR_VAL_UI_NUMBER_DESC_FORMAT           TEXT("UINumberDescFormat")
#define REGSTR_VAL_CAPABILITIES                    TEXT("Capabilities")
#define REGSTR_VAL_DEVICE_TYPE                     TEXT("DeviceType")
#define REGSTR_VAL_DEVICE_CHARACTERISTICS          TEXT("DeviceCharacteristics")
#define REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR      TEXT("Security")
#define REGSTR_VAL_DEVICE_EXCLUSIVE                TEXT("Exclusive")
#define REGSTR_VAL_RESOURCE_PICKER_TAGS            TEXT("ResourcePickerTags")
#define REGSTR_VAL_RESOURCE_PICKER_EXCEPTIONS      TEXT("ResourcePickerExceptions")
#define REGSTR_VAL_CUSTOM_PROPERTY_CACHE_DATE      TEXT("CustomPropertyCacheDate")
#define REGSTR_VAL_CUSTOM_PROPERTY_HW_ID_KEY       TEXT("CustomPropertyHwIdKey")
#define REGSTR_VAL_LAST_UPDATE_TIME                TEXT("LastUpdateTime")
#define REGSTR_VAL_CONTAINERID                     TEXT("ContainerID")

//
// Values used by kernel mode Pnp Manager
//
#define REGSTR_VALUE_DEVICE_OBJECT_NAME            TEXT("DeviceObjectName")
#define REGSTR_VALUE_DEVICE_SYMBOLIC_NAME          TEXT("DeviceSymbolicName")
#define REGSTR_VAL_EJECT_PRIORITY                  TEXT("EjectPriority")

//
// Values used by both kernel-mode and user-mode PnP Managers
//
#define REGSTR_KEY_CONTROL                         TEXT("Control")
#define REGSTR_VAL_ACTIVESERVICE                   TEXT("ActiveService")
#define REGSTR_VAL_LINKED                          TEXT("Linked")
#define REGSTR_VAL_PHYSICALDEVICEOBJECT            TEXT("PhysicalDeviceObject")
#define REGSTR_VAL_REMOVAL_POLICY                  TEXT("RemovalPolicy")

//
// Values under REGSTR_PATH_NT_CURRENTVERSION
//
#define REGSTR_VAL_CURRENT_VERSION  TEXT("CurrentVersion")
#define REGSTR_VAL_CURRENT_BUILD    TEXT("CurrentBuildNumber")
#define REGSTR_VAL_CURRENT_CSDVERSION TEXT("CSDVersion")
#define REGSTR_VAL_CURRENT_TYPE     TEXT("CurrentType")

//
// Values under REGSTR_PATH_DISPLAYSETTINGS
//

#define REGSTR_VAL_BITSPERPIXEL  TEXT("BitsPerPixel")
#define REGSTR_VAL_RESOLUTION    TEXT("Resolution")
#define REGSTR_VAL_DPILOGICALX   TEXT("DPILogicalX")
#define REGSTR_VAL_DPILOGICALY   TEXT("DPILogicalY")
#define REGSTR_VAL_DPIPHYSICALX  TEXT("DPIPhysicalX")
#define REGSTR_VAL_DPIPHYSICALY  TEXT("DPIPhysicalY")
#define REGSTR_VAL_REFRESHRATE   TEXT("RefreshRate")
#define REGSTR_VAL_DISPLAYFLAGS  TEXT("DisplayFlags")


// under HKEY_CURRENT_USER
#define REGSTR_PATH_CONTROLPANEL    TEXT("Control Panel")

// under HKEY_LOCAL_MACHINE
#define REGSTR_PATH_CONTROLSFOLDER  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Controls Folder")

//
// Entries under REGSTR_PATH_CODEPAGE
//

#define REGSTR_VAL_DOSCP        TEXT("OEMCP")
#define REGSTR_VAL_WINCP        TEXT("ACP")

#define REGSTR_PATH_DYNA_ENUM   TEXT("Config Manager\\Enum")

//
// Entries under REGSTR_PATH_DYNA_ENUM
//
#define REGSTR_VAL_HARDWARE_KEY TEXT("HardWareKey")
#define REGSTR_VAL_ALLOCATION   TEXT("Allocation")
#define REGSTR_VAL_PROBLEM      TEXT("Problem")
#define REGSTR_VAL_STATUS       TEXT("Status")

//
//  Used by address arbitrator
//
#define REGSTR_VAL_DONTUSEMEM   TEXT("DontAllocLastMem")

//
//  Entries under REGSTR_PATH_SETUP
//
#define REGSTR_VAL_SYSTEMROOT           TEXT("SystemRoot")
#define REGSTR_VAL_BOOTCOUNT            TEXT("BootCount")
#define REGSTR_VAL_REALNETSTART         TEXT("RealNetStart")
#define REGSTR_VAL_MEDIA                TEXT("MediaPath")
#define REGSTR_VAL_CONFIG               TEXT("ConfigPath")
#define REGSTR_VAL_DEVICEPATH           TEXT("DevicePath")      //default search path for .INFs
#define REGSTR_VAL_SRCPATH              TEXT("SourcePath")      //last source files path during setup.
#define REGSTR_VAL_DRIVERCACHEPATH      TEXT("DriverCachePath") //location of driver cache

#define REGSTR_VAL_OLDWINDIR            TEXT("OldWinDir")       //old windows location
#define REGSTR_VAL_SETUPFLAGS           TEXT("SetupFlags")      //flags that setup passes on after install.
#define REGSTR_VAL_REGOWNER             TEXT("RegisteredOwner")
#define REGSTR_VAL_REGORGANIZATION      TEXT("RegisteredOrganization")
#define REGSTR_VAL_LICENSINGINFO        TEXT("LicensingInfo")
#define REGSTR_VAL_OLDMSDOSVER          TEXT("OldMSDOSVer") // will be DOS ver < 7 (when Setup run)
#define REGSTR_VAL_FIRSTINSTALLDATETIME TEXT("FirstInstallDateTime") // will Win 95 install date-time

#define REGSTR_VAL_INSTALLTYPE          TEXT("InstallType")
//  Values for InstallType
#define IT_COMPACT          0x0000
#define IT_TYPICAL          0x0001
#define IT_PORTABLE         0x0002
#define IT_CUSTOM           0x0003

#define REGSTR_VAL_WRAPPER              TEXT("Wrapper")

#define REGSTR_KEY_RUNHISTORY           TEXT("RunHistory")
#define REGSTR_VAL_LASTALIVEINTERVAL    TEXT("TimeStampInterval")
#define REGSTR_VAL_DIRTYSHUTDOWN        TEXT("DirtyShutdown")
#define REGSTR_VAL_DIRTYSHUTDOWNTIME    TEXT("DirtyShutdownTime")
#define REGSTR_VAL_BT                   TEXT("6005BT")
#define REGSTR_VAL_LASTCOMPUTERNAME     TEXT("LastComputerName")
#define REGSTR_VAL_LASTALIVEBT          TEXT("LastAliveBT")
#define REGSTR_VAL_LASTALIVESTAMP       TEXT("LastAliveStamp")
#define REGSTR_VAL_LASTALIVESTAMPFORCED TEXT("LastAliveStampForced")
#define REGSTR_VAL_LASTALIVESTAMPINTERVAL   TEXT("LastAliveStampInterval")
#define REGSTR_VAL_LASTALIVESTAMPPOLICYINTERVAL TEXT("LastAliveStampPolicyInterval")
#define REGSTR_VAL_LASTALIVEUPTIME      TEXT("LastAliveUptime")
#define REGSTR_VAL_LASTALIVEPMPOLICY    TEXT("LastAlivePMPolicy")

#define REGSTR_VAL_REASONCODE           TEXT("ReasonCode")
#define REGSTR_VAL_COMMENT              TEXT("Comment")

#define REGSTR_VAL_SHUTDOWNREASON       TEXT("ShutdownReason")
#define REGSTR_VAL_SHUTDOWNREASON_CODE          TEXT("ShutdownReasonCode")
#define REGSTR_VAL_SHUTDOWNREASON_COMMENT       TEXT("ShutdownReasonComment")
#define REGSTR_VAL_SHUTDOWNREASON_PROCESS       TEXT("ShutdownReasonProcess")
#define REGSTR_VAL_SHUTDOWNREASON_USERNAME      TEXT("ShutdownReasonUserName")
#define REGSTR_VAL_SHOWREASONUI                 TEXT("ShutdownReasonUI")
#define REGSTR_VAL_SHUTDOWN_IGNORE_PREDEFINED   TEXT("ShutdownIgnorePredefinedReasons")
#define REGSTR_VAL_SHUTDOWN_STATE_SNAPSHOT      TEXT("ShutdownStateSnapshot")


#define REGSTR_KEY_SETUP                TEXT("\\Setup")
#define REGSTR_VAL_BOOTDIR              TEXT("BootDir")
#define REGSTR_VAL_WINBOOTDIR           TEXT("WinbootDir")
#define REGSTR_VAL_WINDIR               TEXT("WinDir")

#define REGSTR_VAL_APPINSTPATH          TEXT("AppInstallPath")    // Used by install wizard

// Values for international startup disk
#define REGSTR_PATH_EBD          REGSTR_PATH_SETUP REGSTR_KEY_SETUP TEXT("\\EBD")
// Keys under REGSTR_KEY_EBD
#define REGSTR_KEY_EBDFILESLOCAL     TEXT("EBDFilesLocale")
#define REGSTR_KEY_EBDFILESKEYBOARD     TEXT("EBDFilesKeyboard")
#define REGSTR_KEY_EBDAUTOEXECBATLOCAL TEXT("EBDAutoexecBatLocale")
#define REGSTR_KEY_EBDAUTOEXECBATKEYBOARD TEXT("EBDAutoexecBatKeyboard")
#define REGSTR_KEY_EBDCONFIGSYSLOCAL   TEXT("EBDConfigSysLocale")
#define REGSTR_KEY_EBDCONFIGSYSKEYBOARD   TEXT("EBDConfigSysKeyboard")


// Values under REGSTR_PATH_DRIVERSIGN and REGSTR_PATH_NONDRIVERSIGN
#define REGSTR_VAL_POLICY                     TEXT("Policy")

// Values under REGSTR_PATH_DRIVERSIGN_POLICY and REGSTR_PATH_NONDRIVERSIGN_POLICY
#define REGSTR_VAL_BEHAVIOR_ON_FAILED_VERIFY  TEXT("BehaviorOnFailedVerify")

// Types of driver signing policies (apply to both preference and policy values
// defined above)
#define DRIVERSIGN_NONE             0x00000000
#define DRIVERSIGN_WARNING          0x00000001
#define DRIVERSIGN_BLOCKING         0x00000002

//
//  Entries under REGSTR_PATH_PIFCONVERT
//
#define REGSTR_VAL_MSDOSMODE            TEXT("MSDOSMode")
#define REGSTR_VAL_MSDOSMODEDISCARD     TEXT("Discard")

//
//  Entries under REGSTR_PATH_MSDOSOPTS (global settings)
//
#define REGSTR_VAL_DOSOPTGLOBALFLAGS    TEXT("GlobalFlags")
//  Flags for GlobalFlags
#define DOSOPTGF_DEFCLEAN   0x00000001L // Default action is clean config

//
//  Entries under REGSTR_PATH_MSDOSOPTS \ OptionSubkey
//
#define REGSTR_VAL_DOSOPTFLAGS          TEXT("Flags")
#define REGSTR_VAL_OPTORDER             TEXT("Order")
#define REGSTR_VAL_CONFIGSYS            TEXT("Config.Sys")
#define REGSTR_VAL_AUTOEXEC             TEXT("Autoexec.Bat")
#define REGSTR_VAL_STDDOSOPTION         TEXT("StdOption")
#define REGSTR_VAL_DOSOPTTIP            TEXT("TipText")

//  Flags for DOSOPTFLAGS
#define DOSOPTF_DEFAULT     0x00000001L // Default enabled for clean config
#define DOSOPTF_SUPPORTED   0x00000002L // Option actually supported
#define DOSOPTF_ALWAYSUSE   0x00000004L // Always use this option
#define DOSOPTF_USESPMODE   0x00000008L // Option puts machine in Prot Mode
#define DOSOPTF_PROVIDESUMB 0x00000010L // Can load drivers high
#define DOSOPTF_NEEDSETUP   0x00000020L // Need to configure option
#define DOSOPTF_INDOSSTART  0x00000040L // Suppored by DOSSTART.BAT
#define DOSOPTF_MULTIPLE    0x00000080L // Load multiple configuration lines

//
//  Flags returned by SUGetSetSetupFlags and in the registry
//
#define SUF_FIRSTTIME   0x00000001L // First boot into Win95.
#define SUF_EXPRESS     0x00000002L // User Setup via express mode (vs customize).
#define SUF_BATCHINF    0x00000004L // Setup using batch file (MSBATCH.INF).
#define SUF_CLEAN       0x00000008L // Setup was done to a clean directory.
#define SUF_INSETUP     0x00000010L // You're in Setup.
#define SUF_NETSETUP    0x00000020L // Doing a net (workstation) setup.
#define SUF_NETHDBOOT   0x00000040L // Workstation boots from local harddrive
#define SUF_NETRPLBOOT  0x00000080L // Workstation boots via RPL (vs floppy)
#define SUF_SBSCOPYOK   0x00000100L // Can copy to LDID_SHARED (SBS)

//
//  Entries under REGSTR_PATH_VMM
//
#define REGSTR_VAL_DOSPAGER     TEXT("DOSPager")
#define REGSTR_VAL_VXDGROUPS    TEXT("VXDGroups")

//
//  Entries under REGSTR_PATH_VPOWERD
//
#define REGSTR_VAL_VPOWERDFLAGS TEXT("Flags")
#define VPDF_DISABLEPWRMGMT         0x00000001  // Don't load device
#define VPDF_FORCEAPM10MODE         0x00000002  // Always go into 1.0 mode
#define VPDF_SKIPINTELSLCHECK       0x00000004  // Don't detect Intel SL chipset
#define VPDF_DISABLEPWRSTATUSPOLL   0x00000008  // Don't poll power status
#define VPDF_DISABLERINGRESUME      0x00000010  // Don't let the modem wake the machine (APM 1.2 only)
#define VPDF_SHOWMULTIBATT          0x00000020  // Show all batteries checkbox in power control panel

//
// Entries under REGSTR_PATH_BUSINFORMATION
//
#define BIF_SHOWSIMILARDRIVERS      0x00000001  // Show similar drivers instead of all class drivers in UI.
#define BIF_RAWDEVICENEEDSDRIVER    0x00000002  // RAW device needs a driver installed.

//
//  Entries under REGSTR_PATH_VNETSUP
//
#define REGSTR_VAL_WORKGROUP TEXT("Workgroup")
#define REGSTR_VAL_DIRECTHOST TEXT("DirectHost")
#define REGSTR_VAL_FILESHARING          TEXT("FileSharing")
#define REGSTR_VAL_PRINTSHARING         TEXT("PrintSharing")

//
//  Entries under REGSTR_PATH_NWREDIR
//
#define REGSTR_VAL_FIRSTNETDRIVE        TEXT("FirstNetworkDrive")
#define REGSTR_VAL_MAXCONNECTIONS       TEXT("MaxConnections")
#define REGSTR_VAL_APISUPPORT           TEXT("APISupport")
#define REGSTR_VAL_MAXRETRY             TEXT("MaxRetry")
#define REGSTR_VAL_MINRETRY             TEXT("MinRetry")
#define REGSTR_VAL_SUPPORTLFN           TEXT("SupportLFN")
#define REGSTR_VAL_SUPPORTBURST         TEXT("SupportBurst")
#define REGSTR_VAL_SUPPORTTUNNELLING    TEXT("SupportTunnelling")
#define REGSTR_VAL_FULLTRACE            TEXT("FullTrace")
#define REGSTR_VAL_READCACHING          TEXT("ReadCaching")
#define REGSTR_VAL_SHOWDOTS             TEXT("ShowDots")
#define REGSTR_VAL_GAPTIME              TEXT("GapTime")
#define REGSTR_VAL_SEARCHMODE           TEXT("SearchMode")
#define REGSTR_VAL_SHELLVERSION     TEXT("ShellVersion")
#define REGSTR_VAL_MAXLIP           TEXT("MaxLIP")
#define REGSTR_VAL_PRESERVECASE     TEXT("PreserveCase")
#define REGSTR_VAL_OPTIMIZESFN      TEXT("OptimizeSFN")

//
//  Entries under REGSTR_PATH_NCPSERVER
//
#define REGSTR_VAL_NCP_BROWSEMASTER     TEXT("BrowseMaster")
#define REGSTR_VAL_NCP_USEPEERBROWSING  TEXT("Use_PeerBrowsing")
#define REGSTR_VAL_NCP_USESAP           TEXT("Use_Sap")

//
// Entries under REGSTR_PATH_VCOMM
//

#define REGSTR_VAL_PCCARD_POWER         TEXT("EnablePowerManagement")

//
//  Entries under REGSTR_PATH_FILESYSTEM
//
#define REGSTR_VAL_WIN31FILESYSTEM              TEXT("Win31FileSystem")
#define REGSTR_VAL_PRESERVELONGNAMES            TEXT("PreserveLongNames")
#define REGSTR_VAL_DRIVEWRITEBEHIND             TEXT("DriveWriteBehind")
#define REGSTR_VAL_ASYNCFILECOMMIT              TEXT("AsyncFileCommit")
#define REGSTR_VAL_PATHCACHECOUNT               TEXT("PathCache")
#define REGSTR_VAL_NAMECACHECOUNT               TEXT("NameCache")
#define REGSTR_VAL_CONTIGFILEALLOC              TEXT("ContigFileAllocSize")
#define REGSTR_VAL_FREESPACERATIO               TEXT("FreeSpaceRatio")
#define REGSTR_VAL_VOLIDLETIMEOUT               TEXT("VolumeIdleTimeout")
#define REGSTR_VAL_BUFFIDLETIMEOUT              TEXT("BufferIdleTimeout")
#define REGSTR_VAL_BUFFAGETIMEOUT               TEXT("BufferAgeTimeout")
#define REGSTR_VAL_NAMENUMERICTAIL              TEXT("NameNumericTail")
#define REGSTR_VAL_READAHEADTHRESHOLD           TEXT("ReadAheadThreshold")
#define REGSTR_VAL_DOUBLEBUFFER                 TEXT("DoubleBuffer")
#define REGSTR_VAL_SOFTCOMPATMODE               TEXT("SoftCompatMode")
#define REGSTR_VAL_DRIVESPINDOWN                TEXT("DriveSpinDown")
#define REGSTR_VAL_FORCEPMIO                    TEXT("ForcePMIO")
#define REGSTR_VAL_FORCERMIO                    TEXT("ForceRMIO")
#define REGSTR_VAL_LASTBOOTPMDRVS               TEXT("LastBootPMDrvs")
#define REGSTR_VAL_ACSPINDOWNPREVIOUS           TEXT("ACSpinDownPrevious")
#define REGSTR_VAL_BATSPINDOWNPREVIOUS          TEXT("BatSpinDownPrevious")
#define REGSTR_VAL_VIRTUALHDIRQ                 TEXT("VirtualHDIRQ")
#define REGSTR_VAL_SRVNAMECACHECOUNT            TEXT("ServerNameCacheMax")
#define REGSTR_VAL_SRVNAMECACHE                 TEXT("ServerNameCache")
#define REGSTR_VAL_SRVNAMECACHENETPROV          TEXT("ServerNameCacheNumNets")
#define REGSTR_VAL_AUTOMOUNT                    TEXT("AutoMountDrives")
#define REGSTR_VAL_COMPRESSIONMETHOD            TEXT("CompressionAlgorithm")
#define REGSTR_VAL_COMPRESSIONTHRESHOLD         TEXT("CompressionThreshold")
#define REGSTR_VAL_ACDRIVESPINDOWN              TEXT("ACDriveSpinDown")
#define REGSTR_VAL_BATDRIVESPINDOWN             TEXT("BatDriveSpinDown")

//
//      Entries under REGSTR_PATH_FILESYSTEM_NOVOLTRACK
//
//      A sub-key under which a variable number of variable length structures are stored.
//
//      Each structure contains an offset followed by a number of pattern bytes.
//      The pattern in each structure is compared at the specified offset within
//      the boot record at the time a volume is mounted.  If any pattern in this
//      set of patterns matches a pattern already in the boot record, VFAT will not
//      write a volume tracking serial number in the OEM_SerialNum field of the
//      boot record on the volume being mounted.
//

//
//  Entries under REGSTR_PATH_CDFS
//
#define REGSTR_VAL_CDCACHESIZE  TEXT("CacheSize")       // Number of 2K cache sectors
#define REGSTR_VAL_CDPREFETCH   TEXT("Prefetch")        // Number of 2K cache sectors for prefetching
#define REGSTR_VAL_CDPREFETCHTAIL TEXT("PrefetchTail")// Number of LRU1 prefetch sectors
#define REGSTR_VAL_CDRAWCACHE   TEXT("RawCache")        // Number of 2352-byte cache sectors
#define REGSTR_VAL_CDEXTERRORS  TEXT("ExtendedErrors")// Return extended error codes
#define REGSTR_VAL_CDSVDSENSE   TEXT("SVDSense")        // 0=PVD, 1=Kanji, 2=Unicode
#define REGSTR_VAL_CDSHOWVERSIONS TEXT("ShowVersions")// Show file version numbers
#define REGSTR_VAL_CDCOMPATNAMES TEXT("MSCDEXCompatNames")// Disable Numeric Tails on long file names
#define REGSTR_VAL_CDNOREADAHEAD TEXT("NoReadAhead")    // Disable Read Ahead if set to 1

//
//      define values for IOS devices
//
#define REGSTR_VAL_SCSI TEXT("SCSI\\")
#define REGSTR_VAL_ESDI TEXT("ESDI\\")
#define REGSTR_VAL_FLOP TEXT("FLOP\\")

//
// define defs for IOS device types and values for IOS devices
//

#define REGSTR_VAL_DISK TEXT("GenDisk")
#define REGSTR_VAL_CDROM        TEXT("GenCD")
#define REGSTR_VAL_TAPE TEXT("TAPE")
#define REGSTR_VAL_SCANNER TEXT("SCANNER")
#define REGSTR_VAL_FLOPPY       TEXT("FLOPPY")

#define REGSTR_VAL_SCSITID TEXT("SCSITargetID")
#define REGSTR_VAL_SCSILUN TEXT("SCSILUN")
#define REGSTR_VAL_REVLEVEL TEXT("RevisionLevel")
#define REGSTR_VAL_PRODUCTID TEXT("ProductId")
#define REGSTR_VAL_PRODUCTTYPE TEXT("ProductType")
#define REGSTR_VAL_DEVTYPE TEXT("DeviceType")
#define REGSTR_VAL_REMOVABLE TEXT("Removable")
#define  REGSTR_VAL_CURDRVLET TEXT("CurrentDriveLetterAssignment")
#define REGSTR_VAL_USRDRVLET TEXT("UserDriveLetterAssignment")
#define REGSTR_VAL_SYNCDATAXFER TEXT("SyncDataXfer")
#define REGSTR_VAL_AUTOINSNOTE  TEXT("AutoInsertNotification")
#define REGSTR_VAL_DISCONNECT TEXT("Disconnect")
#define REGSTR_VAL_INT13 TEXT("Int13")
#define REGSTR_VAL_PMODE_INT13 TEXT("PModeInt13")
#define REGSTR_VAL_USERSETTINGS TEXT("AdapterSettings")
#define REGSTR_VAL_NOIDE TEXT("NoIDE")

// The foll. clase name definitions should be the same as in dirkdrv.inx and
// cdrom.inx
#define REGSTR_VAL_DISKCLASSNAME        TEXT("DiskDrive")
#define REGSTR_VAL_CDROMCLASSNAME       TEXT("CDROM")

// The foll. value determines whether a port driver should be force loaded
// or not.

#define REGSTR_VAL_FORCELOAD    TEXT("ForceLoadPD")

// The foll. value determines whether or not the FIFO is used on the Floppy
// controller.

#define REGSTR_VAL_FORCEFIFO    TEXT("ForceFIFO")
#define REGSTR_VAL_FORCECL              TEXT("ForceChangeLine")

//
// Generic CLASS Entries
//
#define REGSTR_VAL_NOUSECLASS       TEXT("NoUseClass")            // Don't include this class in PnP functions
#define REGSTR_VAL_NOINSTALLCLASS   TEXT("NoInstallClass")        // Don't include this class in New Device Wizard
#define REGSTR_VAL_NODISPLAYCLASS   TEXT("NoDisplayClass")        // Don't include this class in Device Manager
#define REGSTR_VAL_SILENTINSTALL    TEXT("SilentInstall")         // Always Silent Install devices of this class.
//
//  Class Names
//
#define REGSTR_KEY_PCMCIA_CLASS     TEXT("PCMCIA")              //child of PATH_CLASS
#define REGSTR_KEY_SCSI_CLASS       TEXT("SCSIAdapter")
#define REGSTR_KEY_PORTS_CLASS      TEXT("ports")
#define REGSTR_KEY_MEDIA_CLASS      TEXT("MEDIA")
#define REGSTR_KEY_DISPLAY_CLASS    TEXT("Display")
#define REGSTR_KEY_KEYBOARD_CLASS   TEXT("Keyboard")
#define REGSTR_KEY_MOUSE_CLASS      TEXT("Mouse")
#define REGSTR_KEY_MONITOR_CLASS    TEXT("Monitor")
#define REGSTR_KEY_MODEM_CLASS      TEXT("Modem")

//
//  Values under PATH_CLASS\PCMCIA
//
#define REGSTR_VAL_PCMCIA_OPT   TEXT("Options")
#define PCMCIA_OPT_HAVE_SOCKET  0x00000001l
//#define PCMCIA_OPT_ENABLED    0x00000002l
#define PCMCIA_OPT_AUTOMEM      0x00000004l
#define PCMCIA_OPT_NO_SOUND     0x00000008l
#define PCMCIA_OPT_NO_AUDIO     0x00000010l
#define PCMCIA_OPT_NO_APMREMOVE 0x00000020l

#define REGSTR_VAL_PCMCIA_MEM   TEXT("Memory")  // Card services shared mem range
#define PCMCIA_DEF_MEMBEGIN     0x000C0000      // default 0xC0000 - 0x00FFFFFF
#define PCMCIA_DEF_MEMEND       0x00FFFFFF      // (0 - 16meg)
#define PCMCIA_DEF_MEMLEN       0x00001000      // default 4k window

#define REGSTR_VAL_PCMCIA_ALLOC TEXT("AllocMemWin")     // PCCard alloced memory Window
#define REGSTR_VAL_PCMCIA_ATAD  TEXT("ATADelay")        // ATA device config start delay

#define REGSTR_VAL_PCMCIA_SIZ   TEXT("MinRegionSize") // Minimum region size
#define PCMCIA_DEF_MIN_REGION   0x00010000      // 64K minimum region size

// Values in LPTENUM keys
#define REGSTR_VAL_P1284MDL     TEXT("Model")
#define REGSTR_VAL_P1284MFG     TEXT("Manufacturer")

//
//  Values under PATH_CLASS\ISAPNP
//
#define REGSTR_VAL_ISAPNP               TEXT("ISAPNP")  // ISAPNP VxD name
#define REGSTR_VAL_ISAPNP_RDP_OVERRIDE  TEXT("RDPOverRide")     // ReadDataPort OverRide

//
//  Values under PATH_CLASS\PCI
//
#define REGSTR_VAL_PCI                  TEXT("PCI")             // PCI VxD name
#define REGSTR_PCI_OPTIONS              TEXT("Options") // Possible PCI options
#define REGSTR_PCI_DUAL_IDE             TEXT("PCIDualIDE")      // Dual IDE flag
#define PCI_OPTIONS_USE_BIOS            0x00000001l
#define PCI_OPTIONS_USE_IRQ_STEERING    0x00000002l

//
//  Values under PATH_CLASS\AGPxxxx
//
//  note:  These flags affect standard AGP capabilities,
//         and are set in agplib
//
#define AGP_FLAG_NO_1X_RATE             0x00000001l
#define AGP_FLAG_NO_2X_RATE             0x00000002l
#define AGP_FLAG_NO_4X_RATE             0x00000004l
#define AGP_FLAG_NO_8X_RATE             0x00000008l
#define AGP_FLAG_REVERSE_INITIALIZATION 0x00000080l

#define AGP_FLAG_NO_SBA_ENABLE          0x00000100l
#define AGP_FLAG_NO_FW_ENABLE           0x00000200l

//
// AGP flags > AGP_SPECIAL_TARGET are platform specific
//
#define AGP_FLAG_SPECIAL_TARGET         0x000FFFFFl
#define AGP_FLAG_SPECIAL_RESERVE        0x000F8000l

//
// Detection related values
//
#define REGSTR_KEY_CRASHES      TEXT("Crashes") // key of REGSTR_PATH_DETECT
#define REGSTR_KEY_DANGERS      TEXT("Dangers") // key of REGSTR_PATH_DETECT
#define REGSTR_KEY_DETMODVARS   TEXT("DetModVars")      // key of REGSTR_PATH_DETECT
#define REGSTR_KEY_NDISINFO     TEXT("NDISInfo")        // key of netcard hw entry
#define REGSTR_VAL_PROTINIPATH  TEXT("ProtIniPath")     // protocol.ini path
#define REGSTR_VAL_RESOURCES    TEXT("Resources")       // resources of crash func.
#define REGSTR_VAL_CRASHFUNCS   TEXT("CrashFuncs")      // detfunc caused the crash
#define REGSTR_VAL_CLASS        TEXT("Class")   // device class
#define REGSTR_VAL_CLASSDESC    TEXT("ClassDesc")       // class description
#define REGSTR_VAL_DEVDESC      TEXT("DeviceDesc")      // device description
#define REGSTR_VAL_BOOTCONFIG   TEXT("BootConfig")      // detected configuration
#define REGSTR_VAL_DETFUNC      TEXT("DetFunc") // specifies detect mod/func.
#define REGSTR_VAL_DETFLAGS     TEXT("DetFlags")        // detection flags
#define REGSTR_VAL_COMPATIBLEIDS TEXT("CompatibleIDs") //value of enum\dev\inst
#define REGSTR_VAL_DETCONFIG    TEXT("DetConfig")       // detected configuration
#define REGSTR_VAL_VERIFYKEY    TEXT("VerifyKey")       // key used in verify mode
#define REGSTR_VAL_COMINFO      TEXT("ComInfo") // com info. for serial mouse
#define REGSTR_VAL_INFNAME      TEXT("InfName") // INF filename
#define REGSTR_VAL_CARDSPECIFIC TEXT("CardSpecific")    // Netcard specific info (WORD)
#define REGSTR_VAL_NETOSTYPE    TEXT("NetOSType")       // NetOS type associate w/ card
#define REGSTR_DATA_NETOS_NDIS  TEXT("NDIS")            // Data of REGSTR_VAL_NETOSTYPE
#define REGSTR_DATA_NETOS_ODI   TEXT("ODI")             // Data of REGSTR_VAL_NETOSTYPE
#define REGSTR_DATA_NETOS_IPX   TEXT("IPX")             // Data of REGSTR_VAL_NETOSTYPE
#define REGSTR_VAL_MFG      TEXT("Mfg")
#define REGSTR_VAL_SCAN_ONLY_FIRST      TEXT("ScanOnlyFirstDrive")      // used with IDE driver
#define REGSTR_VAL_SHARE_IRQ    TEXT("ForceIRQSharing") // used with IDE driver
#define REGSTR_VAL_NONSTANDARD_ATAPI    TEXT("NonStandardATAPI")        // used with IDE driver
#define REGSTR_VAL_IDE_FORCE_SERIALIZE  TEXT("ForceSerialization")      // used with IDE driver
#define REGSTR_VAL_MAX_HCID_LEN 1024            // Maximum hardware/compat ID len
#define REGSTR_VAL_HWREV            TEXT("HWRevision")
#define REGSTR_VAL_ENABLEINTS  TEXT("EnableInts")
//
// Bit values of REGSTR_VAL_DETFLAGS
//
#define REGDF_NOTDETIO          0x00000001      //cannot detect I/O resource
#define REGDF_NOTDETMEM         0x00000002      //cannot detect mem resource
#define REGDF_NOTDETIRQ         0x00000004      //cannot detect IRQ resource
#define REGDF_NOTDETDMA         0x00000008      //cannot detect DMA resource
#define REGDF_NOTDETALL         (REGDF_NOTDETIO | REGDF_NOTDETMEM | REGDF_NOTDETIRQ | REGDF_NOTDETDMA)
#define REGDF_NEEDFULLCONFIG    0x00000010      //stop devnode if lack resource
#define REGDF_GENFORCEDCONFIG   0x00000020      //also generate forceconfig
#define REGDF_NODETCONFIG       0x00008000      //don't write detconfig to reg.
#define REGDF_CONFLICTIO        0x00010000      //I/O res. in conflict
#define REGDF_CONFLICTMEM       0x00020000      //mem res. in conflict
#define REGDF_CONFLICTIRQ       0x00040000      //IRQ res. in conflict
#define REGDF_CONFLICTDMA       0x00080000      //DMA res. in conflict
#define REGDF_CONFLICTALL       (REGDF_CONFLICTIO | REGDF_CONFLICTMEM | REGDF_CONFLICTIRQ | REGDF_CONFLICTDMA)
#define REGDF_MAPIRQ2TO9        0x00100000      //IRQ2 has been mapped to 9
#define REGDF_NOTVERIFIED       0x80000000      //previous device unverified

//
//  Values in REGSTR_KEY_SYSTEMBOARD
//
#define REGSTR_VAL_APMBIOSVER           TEXT("APMBiosVer")
#define REGSTR_VAL_APMFLAGS             TEXT("APMFlags")
#define REGSTR_VAL_SLSUPPORT            TEXT("SLSupport")
#define REGSTR_VAL_MACHINETYPE          TEXT("MachineType")
#define REGSTR_VAL_SETUPMACHINETYPE TEXT("SetupMachineType")
#define REGSTR_MACHTYPE_UNKNOWN         TEXT("Unknown")
#define REGSTR_MACHTYPE_IBMPC           TEXT("IBM PC")
#define REGSTR_MACHTYPE_IBMPCJR         TEXT("IBM PCjr")
#define REGSTR_MACHTYPE_IBMPCCONV       TEXT("IBM PC Convertible")
#define REGSTR_MACHTYPE_IBMPCXT         TEXT("IBM PC/XT")
#define REGSTR_MACHTYPE_IBMPCXT_286     TEXT("IBM PC/XT 286")
#define REGSTR_MACHTYPE_IBMPCAT         TEXT("IBM PC/AT")
#define REGSTR_MACHTYPE_IBMPS2_25       TEXT("IBM PS/2-25")
#define REGSTR_MACHTYPE_IBMPS2_30_286   TEXT("IBM PS/2-30 286")
#define REGSTR_MACHTYPE_IBMPS2_30       TEXT("IBM PS/2-30")
#define REGSTR_MACHTYPE_IBMPS2_50       TEXT("IBM PS/2-50")
#define REGSTR_MACHTYPE_IBMPS2_50Z      TEXT("IBM PS/2-50Z")
#define REGSTR_MACHTYPE_IBMPS2_55SX     TEXT("IBM PS/2-55SX")
#define REGSTR_MACHTYPE_IBMPS2_60       TEXT("IBM PS/2-60")
#define REGSTR_MACHTYPE_IBMPS2_65SX     TEXT("IBM PS/2-65SX")
#define REGSTR_MACHTYPE_IBMPS2_70       TEXT("IBM PS/2-70")
#define REGSTR_MACHTYPE_IBMPS2_P70      TEXT("IBM PS/2-P70")
#define REGSTR_MACHTYPE_IBMPS2_70_80    TEXT("IBM PS/2-70/80")
#define REGSTR_MACHTYPE_IBMPS2_80       TEXT("IBM PS/2-80")
#define REGSTR_MACHTYPE_IBMPS2_90       TEXT("IBM PS/2-90")
#define REGSTR_MACHTYPE_IBMPS1          TEXT("IBM PS/1")
#define REGSTR_MACHTYPE_PHOENIX_PCAT    TEXT("Phoenix PC/AT Compatible")
#define REGSTR_MACHTYPE_HP_VECTRA       TEXT("HP Vectra")
#define REGSTR_MACHTYPE_ATT_PC          TEXT("AT&T PC")
#define REGSTR_MACHTYPE_ZENITH_PC       TEXT("Zenith PC")

#define REGSTR_VAL_APMMENUSUSPEND       TEXT("APMMenuSuspend")
#define APMMENUSUSPEND_DISABLED         0                   // always disabled
#define APMMENUSUSPEND_ENABLED          1                   // always enabled
#define APMMENUSUSPEND_UNDOCKED         2                   // enabled undocked
#define APMMENUSUSPEND_NOCHANGE     0x80        // bitflag - cannot change setting via UI

#define REGSTR_VAL_APMACTIMEOUT         TEXT("APMACTimeout")
#define REGSTR_VAL_APMBATTIMEOUT        TEXT("APMBatTimeout")
#define APMTIMEOUT_DISABLED             0

#define REGSTR_VAL_APMSHUTDOWNPOWER TEXT("APMShutDownPower")

#define REGSTR_VAL_BUSTYPE          TEXT("BusType")
#define REGSTR_VAL_CPU              TEXT("CPU")
#define REGSTR_VAL_NDP              TEXT("NDP")
#define REGSTR_VAL_PNPBIOSVER       TEXT("PnPBIOSVer")
#define REGSTR_VAL_PNPSTRUCOFFSET   TEXT("PnPStrucOffset")
#define REGSTR_VAL_PCIBIOSVER       TEXT("PCIBIOSVer")
#define REGSTR_VAL_HWMECHANISM      TEXT("HWMechanism")
#define REGSTR_VAL_LASTPCIBUSNUM    TEXT("LastPCIBusNum")
#define REGSTR_VAL_CONVMEM          TEXT("ConvMem")
#define REGSTR_VAL_EXTMEM           TEXT("ExtMem")
#define REGSTR_VAL_COMPUTERNAME     TEXT("ComputerName")
#define REGSTR_VAL_BIOSNAME         TEXT("BIOSName")
#define REGSTR_VAL_BIOSVERSION      TEXT("BIOSVersion")
#define REGSTR_VAL_BIOSDATE         TEXT("BIOSDate")
#define REGSTR_VAL_MODEL            TEXT("Model")
#define REGSTR_VAL_SUBMODEL         TEXT("Submodel")
#define REGSTR_VAL_REVISION         TEXT("Revision")

//
//  Values used in the LPT(ECP) device entry
//
#define REGSTR_VAL_FIFODEPTH            TEXT("FIFODepth")
#define REGSTR_VAL_RDINTTHRESHOLD       TEXT("RDIntThreshold")
#define REGSTR_VAL_WRINTTHRESHOLD       TEXT("WRIntThreshold")

//used in enum\xxx\<devname>\<instname>
#define REGSTR_VAL_PRIORITY     TEXT("Priority")
#define REGSTR_VAL_DRIVER       TEXT("Driver")          //
#define REGSTR_VAL_FUNCDESC     TEXT("FunctionDesc")            //
#define REGSTR_VAL_FORCEDCONFIG TEXT("ForcedConfig")            //
#define REGSTR_VAL_CONFIGFLAGS  TEXT("ConfigFlags")             // (binary ULONG)
#define REGSTR_VAL_CSCONFIGFLAGS TEXT("CSConfigFlags")  // (binary ULONG)

#define CONFIGFLAG_DISABLED             0x00000001      // Set if disabled
#define CONFIGFLAG_REMOVED              0x00000002      // Set if a present hardware enum device deleted
#define CONFIGFLAG_MANUAL_INSTALL       0x00000004      // Set if the devnode was manually installed
#define CONFIGFLAG_IGNORE_BOOT_LC       0x00000008      // Set if skip the boot config
#define CONFIGFLAG_NET_BOOT             0x00000010      // Load this devnode when in net boot
#define CONFIGFLAG_REINSTALL            0x00000020      // Redo install
#define CONFIGFLAG_FAILEDINSTALL        0x00000040      // Failed the install
#define CONFIGFLAG_CANTSTOPACHILD       0x00000080      // Can't stop/remove a single child
#define CONFIGFLAG_OKREMOVEROM          0x00000100      // Can remove even if rom.
#define CONFIGFLAG_NOREMOVEEXIT         0x00000200      // Don't remove at exit.
#define CONFIGFLAG_FINISH_INSTALL       0x00000400      // Complete install for devnode running 'raw'
#define CONFIGFLAG_NEEDS_FORCED_CONFIG  0x00000800      // This devnode requires a forced config
#if defined(REMOTE_BOOT)
#define CONFIGFLAG_NETBOOT_CARD         0x00001000      // This is the remote boot network card
#endif // defined(REMOTE_BOOT)
#define CONFIGFLAG_PARTIAL_LOG_CONF     0x00002000      // This device has a partial logconfig
#define CONFIGFLAG_SUPPRESS_SURPRISE    0x00004000      // Set if unsafe removals should be ignored
#define CONFIGFLAG_VERIFY_HARDWARE      0x00008000      // Set if hardware should be tested for logo failures
#define CONFIGFLAG_FINISHINSTALL_UI     0x00010000      // Show the finish install wizard pages for the installed device.
#define CONFIGFLAG_FINISHINSTALL_ACTION 0x00020000      // Call installer with DIF_FINISHINSTALL_ACTION in client context.

#define CSCONFIGFLAG_BITS               0x00000007      // OR of below bits
#define CSCONFIGFLAG_DISABLED           0x00000001      // Set if
#define CSCONFIGFLAG_DO_NOT_CREATE      0x00000002      // Set if
#define CSCONFIGFLAG_DO_NOT_START       0x00000004      // Set if

#define DMSTATEFLAG_APPLYTOALL      0x00000001  // Set if Apply To All check box is checked

//
// Special devnodes name
//
#define REGSTR_VAL_ROOT_DEVNODE         TEXT("HTREE\\ROOT\\0")
#define REGSTR_VAL_RESERVED_DEVNODE     TEXT("HTREE\\RESERVED\\0")
#define REGSTR_PATH_READDATAPORT        REGSTR_KEY_ISAENUM TEXT("\\ReadDataPort\\0")

//
// Multifunction definitions
//
#define REGSTR_PATH_MULTI_FUNCTION              TEXT("MF")
#define REGSTR_VAL_RESOURCE_MAP                 TEXT("ResourceMap")
#define REGSTR_PATH_CHILD_PREFIX                TEXT("Child")
#define NUM_RESOURCE_MAP                        256
#define REGSTR_VAL_MF_FLAGS                     TEXT("MFFlags")
#define MF_FLAGS_EVEN_IF_NO_RESOURCE            0x00000001
#define MF_FLAGS_NO_CREATE_IF_NO_RESOURCE       0x00000002
#define MF_FLAGS_FILL_IN_UNKNOWN_RESOURCE       0x00000004
#define MF_FLAGS_CREATE_BUT_NO_SHOW_DISABLED    0x00000008

//
// EISA multi functions add-on
//
#ifndef NEC_98
#define REGSTR_VAL_EISA_RANGES          TEXT("EISARanges")
#define REGSTR_VAL_EISA_FUNCTIONS       TEXT("EISAFunctions")
#define REGSTR_VAL_EISA_FUNCTIONS_MASK  TEXT("EISAFunctionsMask")
#define REGSTR_VAL_EISA_FLAGS           TEXT("EISAFlags")
#define REGSTR_VAL_EISA_SIMULATE_INT15  TEXT("EISASimulateInt15")
#else // ifdef NEC_98
#define REGSTR_VAL_EISA_RANGES          TEXT("NESARanges")
#define REGSTR_VAL_EISA_FUNCTIONS       TEXT("NESAFunctions")
#define REGSTR_VAL_EISA_FUNCTIONS_MASK  TEXT("NESAFunctionsMask")
#define REGSTR_VAL_EISA_FLAGS           TEXT("NESAFlags")
#define REGSTR_VAL_EISA_SIMULATE_INT15  TEXT("NESASimulateInt15")
#endif // ifdef NEC_98
#define EISAFLAG_NO_IO_MERGE            0x00000001
#define EISAFLAG_SLOT_IO_FIRST          0x00000002
#define EISA_NO_MAX_FUNCTION            0xFF
#define NUM_EISA_RANGES                 4


//
//  Driver entries
//
#define REGSTR_VAL_DRVDESC      TEXT("DriverDesc")      // value of enum\dev\inst\DRV
#define REGSTR_VAL_DEVLOADER    TEXT("DevLoader")       // value of DRV
#define REGSTR_VAL_STATICVXD    TEXT("StaticVxD")       // value of DRV
#define REGSTR_VAL_PROPERTIES   TEXT("Properties")      // value of DRV
#define REGSTR_VAL_MANUFACTURER TEXT("Manufacturer")
#define REGSTR_VAL_EXISTS       TEXT("Exists")  // value of HCC\HW\ENUM\ROOT\dev\inst
#define REGSTR_VAL_CMENUMFLAGS  TEXT("CMEnumFlags")     // (binary ULONG)
#define REGSTR_VAL_CMDRIVFLAGS  TEXT("CMDrivFlags")     // (binary ULONG)
#define REGSTR_VAL_ENUMERATOR   TEXT("Enumerator")      // value of DRV
#define REGSTR_VAL_DEVICEDRIVER TEXT("DeviceDriver")    // value of DRV
#define REGSTR_VAL_PORTNAME     TEXT("PortName")        // VCOMM uses this for it's port names
#define REGSTR_VAL_INFPATH      TEXT("InfPath")
#define REGSTR_VAL_INFSECTION   TEXT("InfSection")
#define REGSTR_VAL_INFSECTIONEXT TEXT("InfSectionExt")
#define REGSTR_VAL_POLLING      TEXT("Polling")             // SCSI specific
#define REGSTR_VAL_DONTLOADIFCONFLICT TEXT("DontLoadIfConflict")  // SCSI specific
#define REGSTR_VAL_PORTSUBCLASS TEXT("PortSubClass")
#define REGSTR_VAL_NETCLEAN TEXT("NetClean") // Driver required for NetClean boot
#define REGSTR_VAL_IDE_NO_SERIALIZE TEXT("IDENoSerialize") // IDE specific
#define REGSTR_VAL_NOCMOSORFDPT TEXT("NoCMOSorFDPT")       // IDE specific
#define REGSTR_VAL_COMVERIFYBASE TEXT("COMVerifyBase")     // VCD specific
#define REGSTR_VAL_MATCHINGDEVID TEXT("MatchingDeviceId")
#define REGSTR_VAL_DRIVERDATE   TEXT("DriverDate")      // value of DRV
#define REGSTR_VAL_DRIVERDATEDATA TEXT("DriverDateData")// value of DRV
#define REGSTR_VAL_DRIVERVERSION TEXT("DriverVersion")  // value of DRV
#define REGSTR_VAL_LOCATION_INFORMATION_OVERRIDE    TEXT("LocationInformationOverride")  // value of DRV


//
//  Driver keys
//
#define REGSTR_KEY_OVERRIDE     TEXT("Override")        // key under the software section

//used by CONFIGMG
#define REGSTR_VAL_CONFIGMG     TEXT("CONFIGMG")        // Config Manager VxD name
#define REGSTR_VAL_SYSDM        TEXT("SysDM")           // The device installer DLL
#define REGSTR_VAL_SYSDMFUNC    TEXT("SysDMFunc")       // The device installer DLL function
#define REGSTR_VAL_PRIVATE      TEXT("Private") // The private library
#define REGSTR_VAL_PRIVATEFUNC  TEXT("PrivateFunc")     // The private library function
#define REGSTR_VAL_DETECT       TEXT("Detect")  // The detection library
#define REGSTR_VAL_DETECTFUNC   TEXT("DetectFunc")      // The detection library function
#define REGSTR_VAL_ASKFORCONFIG TEXT("AskForConfig")    // The AskForConfig library
#define REGSTR_VAL_ASKFORCONFIGFUNC TEXT("AskForConfigFunc") // The AskForConfig library function
#define REGSTR_VAL_WAITFORUNDOCK TEXT("WaitForUndock")  // The WaitForUndock library
#define REGSTR_VAL_WAITFORUNDOCKFUNC TEXT("WaitForUndockFunc") // The WaitForUndock library function
#define REGSTR_VAL_REMOVEROMOKAY TEXT("RemoveRomOkay")  // The RemoveRomOkay library
#define REGSTR_VAL_REMOVEROMOKAYFUNC TEXT("RemoveRomOkayFunc") // The RemoveRomOkay library function

//used in IDCONFIGDB
#define REGSTR_VAL_CURCONFIG    TEXT("CurrentConfig")           //value of idconfigdb
#define REGSTR_VAL_FRIENDLYNAME TEXT("FriendlyName")            //value of idconfigdb
#define REGSTR_VAL_CURRENTCONFIG TEXT("CurrentConfig")  //value of idconfigdb
#define REGSTR_VAL_MAP          TEXT("Map")                     //value of idconfigdb
#define REGSTR_VAL_ID           TEXT("CurrentID")               //value of idconfigdb
#define REGSTR_VAL_DOCKED       TEXT("CurrentDockedState")      //value of idconfigdb
#define REGSTR_VAL_CHECKSUM     TEXT("CurrentChecksum") //value of idconfigdb
#define REGSTR_VAL_HWDETECT     TEXT("HardwareDetect")  //value of idconfigdb
#define REGSTR_VAL_INHIBITRESULTS TEXT("InhibitResults")        //value of idconfigdb

//used in HKEY_CURRENT_CONFIG
#define REGSTR_VAL_PROFILEFLAGS TEXT("ProfileFlags")    // value of HKEY_CURRENT_CONFIG

//used in PCMCIA
#define REGSTR_KEY_PCMCIA       TEXT("PCMCIA\\")        //PCMCIA dev ID prefix
#define REGSTR_KEY_PCUNKNOWN    TEXT("UNKNOWN_MANUFACTURER")    //PCMCIA dev ID manuf
#define REGSTR_VAL_PCSSDRIVER   TEXT("Driver")  //value of DRV
#define REGSTR_KEY_PCMTD        TEXT("MTD-")            //MTD dev ID component
#define REGSTR_VAL_PCMTDRIVER   TEXT("MTD")             //value of Mem Tech DRV

//used in hardware\enum\dev\inst by Device Installer
#define REGSTR_VAL_HARDWAREID    TEXT("HardwareID")      //value of enum\dev\inst

//value names under class brach REGSTR_KEY_CLASS + class name
// and for the drivers REGSTR_KEY_CLASS\classname\xxxx
#define REGSTR_VAL_INSTALLER          TEXT("Installer")         // 16-bit class installer module/entry point
#define REGSTR_VAL_INSTALLER_32       TEXT("Installer32")       // 32-bit class installer module/entry point
#define REGSTR_VAL_INSICON            TEXT("Icon")              // value of class\name
#define REGSTR_VAL_ENUMPROPPAGES      TEXT("EnumPropPages")     // For Class/Device Properties (16-bit)
#define REGSTR_VAL_ENUMPROPPAGES_32   TEXT("EnumPropPages32")   // For Class/Device Properties (32-bit)
#define REGSTR_VAL_BASICPROPERTIES    TEXT("BasicProperties")   // For CPL basic Properties (16-bit)
#define REGSTR_VAL_BASICPROPERTIES_32 TEXT("BasicProperties32") // For CPL basic Properties (32-bit)
#define REGSTR_VAL_COINSTALLERS_32    TEXT("CoInstallers32")    // Device-specific co-installer multi-sz list (32-bit)
#define REGSTR_VAL_PRIVATEPROBLEM     TEXT("PrivateProblem")    // For Handling Private Problems

// names used for display driver set information
#define REGSTR_KEY_CURRENT      TEXT("Current") // current mode information
#define REGSTR_KEY_DEFAULT      TEXT("Default") // default configuration
#define REGSTR_KEY_MODES        TEXT("Modes")   // modes subtree

#define REGSTR_VAL_MODE         TEXT("Mode")            // default mode
#define REGSTR_VAL_BPP          TEXT("BPP")             // bits per pixel
#define REGSTR_VAL_HRES         TEXT("HRes")            // horizontal resolution
#define REGSTR_VAL_VRES         TEXT("VRes")            // vertical resolution
#define REGSTR_VAL_FONTSIZE     TEXT("FontSize")        // used in default or override
#define REGSTR_VAL_DRV          TEXT("drv")             // the driver file
#define REGSTR_VAL_GRB          TEXT("grb")             // the grabber file
#define REGSTR_VAL_VDD          TEXT("vdd")             // vdds used here
#define REGSTR_VAL_VER          TEXT("Ver")
#define REGSTR_VAL_MAXRES       TEXT("MaxResolution") // max res for monitors
#define REGSTR_VAL_DPMS         TEXT("DPMS")            // DPMS enabled
#define REGSTR_VAL_RESUMERESET  TEXT("ResumeReset")   // need reset on resume

#define REGSTR_VAL_DESCRIPTION TEXT("Description")

// keys in fontsize tree
#define REGSTR_KEY_SYSTEM       TEXT("System")  // entries for system.ini
#define REGSTR_KEY_USER         TEXT("User")            // entries for win.ini
#define REGSTR_VAL_DPI          TEXT("dpi")             // dpi of fontsize

//
// Used by PCIC socket services
//
#define REGSTR_VAL_PCICOPTIONS  TEXT("PCICOptions")     // Binary DWORD.  IRQ mask in
                                                // low word.  # skts in high
#ifndef NEC_98
#define PCIC_DEFAULT_IRQMASK    0x4EB8          // Default IRQ masks
#else // ifdef NEC_98
#define PCIC_DEFAULT_IRQMASK    0x1468          // Default IRQ masks
#endif // ifdef NEC_98
#define PCIC_DEFAULT_NUMSOCKETS 0               // 0 = Automatic detection
#define REGSTR_VAL_PCICIRQMAP   TEXT("PCICIRQMap")      // Binary 16 byte IRQ map table

// names used for control panel entries
#define REGSTR_PATH_APPEARANCE  TEXT("Control Panel\\Appearance")
#define REGSTR_PATH_LOOKSCHEMES TEXT("Control Panel\\Appearance\\Schemes")
#define REGSTR_VAL_CUSTOMCOLORS TEXT("CustomColors")

#define REGSTR_PATH_SCREENSAVE          TEXT("Control Panel\\Desktop")
#define REGSTR_VALUE_USESCRPASSWORD TEXT("ScreenSaveUsePassword")
#define REGSTR_VALUE_SCRPASSWORD    TEXT("ScreenSave_Data")

#define REGSTR_VALUE_LOWPOWERTIMEOUT    TEXT("ScreenSaveLowPowerTimeout")
#define REGSTR_VALUE_POWEROFFTIMEOUT    TEXT("ScreenSavePowerOffTimeout")
#define REGSTR_VALUE_LOWPOWERACTIVE     TEXT("ScreenSaveLowPowerActive")
#define REGSTR_VALUE_POWEROFFACTIVE     TEXT("ScreenSavePowerOffActive")

// used for Windows applets
#define REGSTR_PATH_WINDOWSAPPLETS TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets")

//
// system tray.  Flag values defined in systrap.h
//
#define REGSTR_PATH_SYSTRAY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\SysTray")
#define REGSTR_VAL_SYSTRAYSVCS TEXT("Services")
#define REGSTR_VAL_SYSTRAYBATFLAGS TEXT("PowerFlags")
#define REGSTR_VAL_SYSTRAYPCCARDFLAGS TEXT("PCMCIAFlags")

//
// Used by system networking components to store per-user values.
// All keys here are under HKCU.
//
#define REGSTR_PATH_NETWORK_USERSETTINGS        TEXT("Network")

#define REGSTR_KEY_NETWORK_PERSISTENT           TEXT("\\Persistent")
#define REGSTR_KEY_NETWORK_RECENT               TEXT("\\Recent")
#define REGSTR_VAL_REMOTE_PATH                  TEXT("RemotePath")
#define REGSTR_VAL_USER_NAME                    TEXT("UserName")
#define REGSTR_VAL_PROVIDER_NAME                TEXT("ProviderName")
#define REGSTR_VAL_CONNECTION_TYPE              TEXT("ConnectionType")
#define REGSTR_VAL_UPGRADE                      TEXT("Upgrade")

#define REGSTR_KEY_LOGON TEXT("\\Logon")
#define REGSTR_VAL_MUSTBEVALIDATED  TEXT("MustBeValidated")
#define REGSTR_VAL_RUNLOGINSCRIPT       TEXT("ProcessLoginScript")

//
// NetworkProvider entries. These entries are under
// REGSTR_PATH_SERVICES\\xxx\\NetworkProvider
//
#define REGSTR_KEY_NETWORKPROVIDER TEXT("\\NetworkProvider")
#define REGSTR_PATH_NW32NETPROVIDER REGSTR_PATH_SERVICES TEXT("\\NWNP32") REGSTR_KEY_NETWORKPROVIDER
#define REGSTR_PATH_MS32NETPROVIDER REGSTR_PATH_SERVICES TEXT("\\MSNP32") REGSTR_KEY_NETWORKPROVIDER
#define REGSTR_VAL_AUTHENT_AGENT TEXT("AuthenticatingAgent")

//
// Entries under REGSTR_PATH_REALMODENET
//
#define REGSTR_VAL_PREFREDIR TEXT("PreferredRedir")
#define REGSTR_VAL_AUTOSTART TEXT("AutoStart")
#define REGSTR_VAL_AUTOLOGON TEXT("AutoLogon")
#define REGSTR_VAL_NETCARD TEXT("Netcard")
#define REGSTR_VAL_TRANSPORT TEXT("Transport")
#define REGSTR_VAL_DYNAMIC TEXT("Dynamic")
#define REGSTR_VAL_TRANSITION TEXT("Transition")
#define REGSTR_VAL_STATICDRIVE TEXT("StaticDrive")
#define REGSTR_VAL_LOADHI TEXT("LoadHi")
#define REGSTR_VAL_LOADRMDRIVERS TEXT("LoadRMDrivers")
#define REGSTR_VAL_SETUPN TEXT("SetupN")
#define REGSTR_VAL_SETUPNPATH TEXT("SetupNPath")

//
// Entries under REGSTR_PATH_CVNETWORK
//
#define REGSTR_VAL_WRKGRP_FORCEMAPPING TEXT("WrkgrpForceMapping")
#define REGSTR_VAL_WRKGRP_REQUIRED TEXT("WrkgrpRequired")

//
// NT-compatible place where the name of the currently logged-on user is stored.
//
#define REGSTR_PATH_CURRENT_CONTROL_SET TEXT("System\\CurrentControlSet\\Control")
#define REGSTR_VAL_CURRENT_USER                 TEXT("Current User")

// section where password providers are installed (each provider has subkey under this key)
#define REGSTR_PATH_PWDPROVIDER         TEXT("System\\CurrentControlSet\\Control\\PwdProvider")
#define REGSTR_VAL_PWDPROVIDER_PATH TEXT("ProviderPath")
#define REGSTR_VAL_PWDPROVIDER_DESC TEXT("Description")
#define REGSTR_VAL_PWDPROVIDER_CHANGEPWD TEXT("ChangePassword")
#define REGSTR_VAL_PWDPROVIDER_CHANGEPWDHWND TEXT("ChangePasswordHwnd")
#define REGSTR_VAL_PWDPROVIDER_GETPWDSTATUS TEXT("GetPasswordStatus")
#define REGSTR_VAL_PWDPROVIDER_ISNP TEXT("NetworkProvider")
#define REGSTR_VAL_PWDPROVIDER_CHANGEORDER TEXT("ChangeOrder")

//
// Used by administrator configuration tool and various components who enforce
// policies.
//
#define REGSTR_PATH_POLICIES    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies")

// used to control remote update of administrator policies
#define REGSTR_PATH_UPDATE              TEXT("System\\CurrentControlSet\\Control\\Update")
#define REGSTR_VALUE_ENABLE             TEXT("Enable")
#define REGSTR_VALUE_VERBOSE    TEXT("Verbose")
#define REGSTR_VALUE_NETPATH    TEXT("NetworkPath")
#define REGSTR_VALUE_DEFAULTLOC TEXT("UseDefaultNetLocation")

//
//      Entries under REGSTR_PATH_POLICIES
//
#define REGSTR_KEY_NETWORK              TEXT("Network")
#define REGSTR_KEY_SYSTEM               TEXT("System")
#define REGSTR_KEY_PRINTERS             TEXT("Printers")
#define REGSTR_KEY_WINOLDAPP            TEXT("WinOldApp")
#define REGSTR_KEY_EXPLORER             TEXT("Explorer")

// Explorer run policy
#define REGSTR_PATH_RUN_POLICY          REGSTR_PATH_POLICIES TEXT("\\Explorer\\Run")

// (following are values REG_DWORD, legal values 0 or 1, treat as TEXT("0") if value not present)
// policies under NETWORK key
#define REGSTR_VAL_NOFILESHARING                TEXT("NoFileSharing") // TEXT("1") prevents server from loading
#define REGSTR_VAL_NOPRINTSHARING               TEXT("NoPrintSharing")
#define REGSTR_VAL_NOFILESHARINGCTRL    TEXT("NoFileSharingControl") // TEXT("1") removes sharing ui
#define REGSTR_VAL_NOPRINTSHARINGCTRL   TEXT("NoPrintSharingControl")
#define REGSTR_VAL_HIDESHAREPWDS                TEXT("HideSharePwds") // TEXT("1") hides share passwords with asterisks
#define REGSTR_VAL_DISABLEPWDCACHING    TEXT("DisablePwdCaching") // TEXT("1") disables caching
#define REGSTR_VAL_ALPHANUMPWDS                 TEXT("AlphanumPwds") // TEXT("1") forces alphanumeric passwords
#define REGSTR_VAL_NETSETUP_DISABLE                     TEXT("NoNetSetup")
#define REGSTR_VAL_NETSETUP_NOCONFIGPAGE        TEXT("NoNetSetupConfigPage")
#define REGSTR_VAL_NETSETUP_NOIDPAGE            TEXT("NoNetSetupIDPage")
#define REGSTR_VAL_NETSETUP_NOSECURITYPAGE      TEXT("NoNetSetupSecurityPage")
#define REGSTR_VAL_SYSTEMCPL_NOVIRTMEMPAGE  TEXT("NoVirtMemPage")
#define REGSTR_VAL_SYSTEMCPL_NODEVMGRPAGE   TEXT("NoDevMgrPage")
#define REGSTR_VAL_SYSTEMCPL_NOCONFIGPAGE       TEXT("NoConfigPage")
#define REGSTR_VAL_SYSTEMCPL_NOFILESYSPAGE      TEXT("NoFileSysPage")
#define REGSTR_VAL_DISPCPL_NODISPCPL            TEXT("NoDispCPL")
#define REGSTR_VAL_DISPCPL_NOBACKGROUNDPAGE TEXT("NoDispBackgroundPage")
#define REGSTR_VAL_DISPCPL_NOSCRSAVPAGE TEXT("NoDispScrSavPage")
#define REGSTR_VAL_DISPCPL_NOAPPEARANCEPAGE TEXT("NoDispAppearancePage")
#define REGSTR_VAL_DISPCPL_NOSETTINGSPAGE TEXT("NoDispSettingsPage")
#define REGSTR_VAL_SECCPL_NOSECCPL                      TEXT("NoSecCPL")
#define REGSTR_VAL_SECCPL_NOPWDPAGE                     TEXT("NoPwdPage")
#define REGSTR_VAL_SECCPL_NOADMINPAGE           TEXT("NoAdminPage")
#define REGSTR_VAL_SECCPL_NOPROFILEPAGE         TEXT("NoProfilePage")
#define REGSTR_VAL_PRINTERS_HIDETABS            TEXT("NoPrinterTabs")
#define REGSTR_VAL_PRINTERS_NODELETE            TEXT("NoDeletePrinter")
#define REGSTR_VAL_PRINTERS_NOADD                       TEXT("NoAddPrinter")
#define REGSTR_VAL_WINOLDAPP_DISABLED           TEXT("Disabled")
#define REGSTR_VAL_WINOLDAPP_NOREALMODE         TEXT("NoRealMode")
#define REGSTR_VAL_NOENTIRENETWORK                      TEXT("NoEntireNetwork")
#define REGSTR_VAL_NOWORKGROUPCONTENTS          TEXT("NoWorkgroupContents")

// (following are values REG_DWORD, legal values 0 or 1, treat as TEXT("1") if value not present)
// policies under Policies\SYSTEM key
#define REGSTR_VAL_UNDOCK_WITHOUT_LOGON         TEXT("UndockWithoutLogon")

// REG_DWORD, 0=off, otherwise value is minimum # of chars to allow in password
#define REGSTR_VAL_MINPWDLEN                    TEXT("MinPwdLen")
// REG_DWORD, 0=off, otherwise value is # of days for pwd to expire
#define REGSTR_VAL_PWDEXPIRATION                TEXT("PwdExpiration")

#define REGSTR_VAL_WIN31PROVIDER                TEXT("Win31Provider") // REG_SZ

// policies under SYSTEM key
#define REGSTR_VAL_DISABLEREGTOOLS              TEXT("DisableRegistryTools")

#define REGSTR_PATH_WINLOGON    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Winlogon")
#define REGSTR_VAL_LEGALNOTICECAPTION   TEXT("LegalNoticeCaption")      // REG_SZ
#define REGSTR_VAL_LEGALNOTICETEXT              TEXT("LegalNoticeText")         // REG_SZ
#define REGSTR_VAL_DRIVE_SPINDOWN               TEXT("NoDispSpinDown")
#define REGSTR_VAL_SHUTDOWN_FLAGS       	TEXT("ShutdownFlags")


#define REGSTR_VAL_RESTRICTRUN  TEXT("RestrictRun")
//
//  Entries in policy file.  (Won't be in local registry, only policy hive)
#define REGSTR_KEY_POL_USERS            TEXT("Users")
#define REGSTR_KEY_POL_COMPUTERS        TEXT("Computers")
#define REGSTR_KEY_POL_USERGROUPS       TEXT("UserGroups")
#define REGSTR_KEY_POL_DEFAULT          TEXT(".default")
#define REGSTR_KEY_POL_USERGROUPDATA TEXT("GroupData\\UserGroups\\Priority")

//
//      Entries for time zone information under LOCAL_MACHINE
//
#define REGSTR_PATH_TIMEZONE        TEXT("System\\CurrentControlSet\\Control\\TimeZoneInformation")
#define REGSTR_VAL_TZBIAS           TEXT("Bias")
#define REGSTR_VAL_TZDLTBIAS        TEXT("DaylightBias")
#define REGSTR_VAL_TZSTDBIAS        TEXT("StandardBias")
#define REGSTR_VAL_TZACTBIAS        TEXT("ActiveTimeBias")
#define REGSTR_VAL_TZDLTFLAG        TEXT("DaylightFlag")
#define REGSTR_VAL_TZSTDSTART       TEXT("StandardStart")
#define REGSTR_VAL_TZDLTSTART       TEXT("DaylightStart")
#define REGSTR_VAL_TZDLTNAME        TEXT("DaylightName")
#define REGSTR_VAL_TZSTDNAME        TEXT("StandardName")
#define REGSTR_VAL_TZNOCHANGESTART  TEXT("NoChangeStart")
#define REGSTR_VAL_TZNOCHANGEEND    TEXT("NoChangeEnd")
#define REGSTR_VAL_TZNOAUTOTIME     TEXT("DisableAutoDaylightTimeSet")

//
//      Entries for floating point processor existence under LOCAL_MACHINE
//
#define REGSTR_PATH_FLOATINGPOINTPROCESSOR TEXT("HARDWARE\\DESCRIPTION\\System\\FloatingPointProcessor")
#define REGSTR_PATH_FLOATINGPOINTPROCESSOR0 TEXT("HARDWARE\\DESCRIPTION\\System\\FloatingPointProcessor\\0")


//
//      Entries for computer name under LOCAL_MACHINE
//
#define REGSTR_PATH_COMPUTRNAME TEXT("System\\CurrentControlSet\\Control\\ComputerName\\ComputerName")
#define REGSTR_VAL_COMPUTRNAME TEXT("ComputerName")

//      Entry so that we force a reboot on shutdown / single instance dos app
#define REGSTR_PATH_SHUTDOWN TEXT("System\\CurrentControlSet\\Control\\Shutdown")
#define REGSTR_VAL_FORCEREBOOT     TEXT("ForceReboot")
#define REGSTR_VAL_SETUPPROGRAMRAN TEXT("SetupProgramRan")
#define REGSTR_VAL_DOES_POLLING    TEXT("PollingSupportNeeded")

//
//      Entries for known system DLLs under LOCAL_MACHINE
//
//      The VAL keys here are the actual DLL names (FOO.DLL)
//
#define REGSTR_PATH_KNOWNDLLS   TEXT("System\\CurrentControlSet\\Control\\SessionManager\\KnownDLLs")
#define REGSTR_PATH_KNOWN16DLLS TEXT("System\\CurrentControlSet\\Control\\SessionManager\\Known16DLLs")

//      Entries here for system dlls we need to version check in case overwritten
#define REGSTR_PATH_CHECKVERDLLS TEXT("System\\CurrentControlSet\\Control\\SessionManager\\CheckVerDLLs")
#define REGSTR_PATH_WARNVERDLLS  TEXT("System\\CurrentControlSet\\Control\\SessionManager\\WarnVerDLLs")

//      Entries here for app ini files we (msgsrv32) need to hack
#define REGSTR_PATH_HACKINIFILE  TEXT("System\\CurrentControlSet\\Control\\SessionManager\\HackIniFiles")

//      Keys here for bad applications we want to warn the user about before running
#define REGSTR_PATH_CHECKBADAPPS TEXT("System\\CurrentControlSet\\Control\\SessionManager\\CheckBadApps")

//      Keys here for applications we need to update
#define REGSTR_PATH_APPPATCH TEXT("System\\CurrentControlSet\\Control\\SessionManager\\AppPatches")

#define REGSTR_PATH_CHECKBADAPPS400 TEXT("System\\CurrentControlSet\\Control\\SessionManager\\CheckBadApps400")

//
//      Entries for known system VxDs under LOCAL_MACHINE
//
//      The VAL keys here are the full path names of VxDs (c:\app\vapp.vxd)
//      It is suggested that the keynames be the same as the module name of
//      the VxD.
//      This section is used to dyna-load VxDs with
//      CreateFile(\\.\vxd_regstr_keyname).
//

#define REGSTR_PATH_KNOWNVXDS   TEXT("System\\CurrentControlSet\\Control\\SessionManager\\KnownVxDs")

//
// Entries for values in uninstaller keys under REGSTR_PATH_UNINSTALL \ appname
//
#define REGSTR_VAL_UNINSTALLER_DISPLAYNAME     TEXT("DisplayName")
#define REGSTR_VAL_UNINSTALLER_COMMANDLINE     TEXT("UninstallString")

//
// Entries for values in uninstaller keys under REGSTR_PATH_REINSTALL \ instanceid
//
#define REGSTR_VAL_REINSTALL_DISPLAYNAME        TEXT("DisplayName")
#define REGSTR_VAL_REINSTALL_STRING             TEXT("ReinstallString")
#define REGSTR_VAL_REINSTALL_DEVICEINSTANCEIDS  TEXT("DeviceInstanceIds")

//
//      Entries for known per user settings: Under HKEY_CURRENT_USER
//
#define REGSTR_PATH_DESKTOP     REGSTR_PATH_SCREENSAVE
#define REGSTR_PATH_MOUSE           TEXT("Control Panel\\Mouse")
#define REGSTR_PATH_KEYBOARD    TEXT("Control Panel\\Keyboard")
#define REGSTR_PATH_COLORS          TEXT("Control Panel\\Colors")
#define REGSTR_PATH_SOUND           TEXT("Control Panel\\Sound")
#define REGSTR_PATH_METRICS         TEXT("Control Panel\\Desktop\\WindowMetrics")
#define REGSTR_PATH_ICONS       TEXT("Control Panel\\Icons")
#define REGSTR_PATH_CURSORS     TEXT("Control Panel\\Cursors")
#define REGSTR_PATH_CHECKDISK   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Check Drive")
#define REGSTR_PATH_CHECKDISKSET    TEXT("Settings")
#define REGSTR_PATH_CHECKDISKUDRVS  TEXT("NoUnknownDDErrDrvs")
//
//  Entries under REGSTR_PATH_FAULT
//
#define REGSTR_PATH_FAULT               TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Fault")
#define REGSTR_VAL_FAULT_LOGFILE        TEXT("LogFile")

//
//  Entries under REGSTR_PATH_AEDEBUG
//
#define REGSTR_PATH_AEDEBUG             TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug")
#define REGSTR_VAL_AEDEBUG_DEBUGGER     TEXT("Debugger")
#define REGSTR_VAL_AEDEBUG_AUTO         TEXT("Auto")

//
//  Entries under REGSTR_PATH_GRPCONV
//
#define REGSTR_PATH_GRPCONV     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\GrpConv")

//
//  Entries under the RegItem key in a shell namespace
//
#define REGSTR_VAL_REGITEMDELETEMESSAGE TEXT("Removal Message")

//
//  Entries for the Drives Tools page
//
//  NOTE that these items are not recorded for removable drives. These
//  keys record X=DSKTLSYSTEMTIME where X is the drive letter. Since
//  these tools actually work on the disk in the drive, as opposed to
//  the drive itself, it is pointless to record them on a removable media
//  since if a different disk is inserted in the drive, the data is
//  meaningless.
//
#define REGSTR_PATH_LASTCHECK           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\LastCheck")
#define REGSTR_PATH_LASTOPTIMIZE        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\LastOptimize")
#define REGSTR_PATH_LASTBACKUP          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\LastBackup")
//
// The above 3 keys record with the registry value of the drive letter
// a SYSTEMTIME structure
//

//
// Entries under HKEY_LOCAL_MACHINE for Check Drive specific stuff
//
#define REGSTR_PATH_CHKLASTCHECK        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Check Drive\\LastCheck")
#define REGSTR_PATH_CHKLASTSURFAN       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Check Drive\\LastSurfaceAnalysis")

#ifndef _IN_KERNEL_

//
// The above 2 keys record the following binary structure which is
// a system time structure with the addition of a result code field.
// Note that the time part of REGSTR_PATH_CHKLASTCHECK is effectively
// identical to REGSTR_PATH_LASTCHECK under the explorer key
//
typedef struct _DSKTLSYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
    WORD wResult;
} DSKTLSYSTEMTIME, *PDSKTLSYSTEMTIME, *LPDSKTLSYSTEMTIME;

#endif

//
// The following are defines for the wResult field
//
#define DTRESULTOK      0       // Operation was successful, no errors
#define DTRESULTFIX     1       // Operation was successful, errors were found
                                //   but all were fixed.
#define DTRESULTPROB    2       // Operation was not successful or errors
                                //   were found and some or all were not fixed.
#define DTRESULTPART    3       // Operation was partially completed but was
                                //   terminated either by the user or an error.

//
//  Entries for persistent shares
//
#define REGSTR_KEY_SHARES             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Network\\LanMan")
#define REGSTR_VAL_SHARES_FLAGS   TEXT("Flags")
#define REGSTR_VAL_SHARES_TYPE    TEXT("Type")
#define REGSTR_VAL_SHARES_PATH    TEXT("Path")
#define REGSTR_VAL_SHARES_REMARK  TEXT("Remark")
#define REGSTR_VAL_SHARES_RW_PASS TEXT("Parm1")
#define REGSTR_VAL_SHARES_RO_PASS TEXT("Parm2")

//
//      Entries for printer settings under LOCAL_MACHINE
//
#define REGSTR_PATH_PRINT           TEXT("System\\CurrentControlSet\\Control\\Print")
#define REGSTR_PATH_PRINTERS        TEXT("System\\CurrentControlSet\\Control\\Print\\Printers")
#define REGSTR_PATH_PROVIDERS       TEXT("System\\CurrentControlSet\\Control\\Print\\Providers")
#define REGSTR_PATH_MONITORS        TEXT("System\\CurrentControlSet\\Control\\Print\\Monitors")
#define REGSTR_PATH_ENVIRONMENTS    TEXT("System\\CurrentControlSet\\Control\\Print\\Environments")
#define REGSTR_VAL_START_ON_BOOT    TEXT("StartOnBoot")
#define REGSTR_VAL_PRINTERS_MASK    TEXT("PrintersMask")
#define REGSTR_VAL_DOS_SPOOL_MASK   TEXT("DOSSpoolMask")
#define REGSTR_KEY_CURRENT_ENV      TEXT("\\Windows 4.0")
#define REGSTR_KEY_DRIVERS          TEXT("\\Drivers")
#define REGSTR_KEY_PRINT_PROC       TEXT("\\Print Processors")

//
// Entries for MultiMedia under HKEY_CURRENT_USER
//
#define REGSTR_PATH_EVENTLABELS     TEXT("AppEvents\\EventLabels")
#define REGSTR_PATH_SCHEMES         TEXT("AppEvents\\Schemes")
#define REGSTR_PATH_APPS            REGSTR_PATH_SCHEMES TEXT("\\Apps")
#define REGSTR_PATH_APPS_DEFAULT    REGSTR_PATH_SCHEMES TEXT("\\Apps\\.Default")
#define REGSTR_PATH_NAMES           REGSTR_PATH_SCHEMES TEXT("\\Names")
#define REGSTR_PATH_MULTIMEDIA      REGSTR_PATH_SETUP TEXT("\\Multimedia")
#define REGSTR_PATH_MULTIMEDIA_AUDIO TEXT("Software\\Microsoft\\Multimedia\\Audio")
#define REGSTR_PATH_MULTIMEDIA_AUDIO_IMAGES REGSTR_PATH_MULTIMEDIA_AUDIO TEXT("\\Images")

//
// Entries for MultiMedia under HKEY_LOCAL_MACHINE
//
#define REGSTR_PATH_MEDIARESOURCES  REGSTR_PATH_CURRENT_CONTROL_SET TEXT("\\MediaResources")
#define REGSTR_PATH_MEDIAPROPERTIES REGSTR_PATH_CURRENT_CONTROL_SET TEXT("\\MediaProperties")
#define REGSTR_PATH_PRIVATEPROPERTIES REGSTR_PATH_MEDIAPROPERTIES TEXT("\\PrivateProperties")
#define REGSTR_PATH_PUBLICPROPERTIES REGSTR_PATH_MEDIAPROPERTIES TEXT("\\PublicProperties")

// joysticks
#define REGSTR_PATH_JOYOEM           REGSTR_PATH_PRIVATEPROPERTIES TEXT("\\Joystick\\OEM")
#define REGSTR_PATH_JOYCONFIG        REGSTR_PATH_MEDIARESOURCES TEXT("\\Joystick")
#define REGSTR_KEY_JOYCURR           TEXT("CurrentJoystickSettings")
#define REGSTR_KEY_JOYSETTINGS       TEXT("JoystickSettings")

// joystick values found under REGSTR_PATH_JOYCONFIG
#define REGSTR_VAL_JOYUSERVALUES     TEXT("JoystickUserValues")
#define REGSTR_VAL_JOYCALLOUT        TEXT("JoystickCallout")

// joystick values found under REGSTR_KEY_JOYCURR and REGSTR_KEY_JOYSETTINGS
#define REGSTR_VAL_JOYNCONFIG        TEXT("Joystick%dConfiguration")
#define REGSTR_VAL_JOYNOEMNAME       TEXT("Joystick%dOEMName")
#define REGSTR_VAL_JOYNOEMCALLOUT    TEXT("Joystick%dOEMCallout")

// joystick values found under keys under REGSTR_PATH_JOYOEM
#define REGSTR_VAL_JOYOEMCALLOUT        TEXT("OEMCallout")
#define REGSTR_VAL_JOYOEMNAME           TEXT("OEMName")
#define REGSTR_VAL_JOYOEMDATA           TEXT("OEMData")
#define REGSTR_VAL_JOYOEMXYLABEL        TEXT("OEMXYLabel")
#define REGSTR_VAL_JOYOEMZLABEL         TEXT("OEMZLabel")
#define REGSTR_VAL_JOYOEMRLABEL         TEXT("OEMRLabel")
#define REGSTR_VAL_JOYOEMPOVLABEL       TEXT("OEMPOVLabel")
#define REGSTR_VAL_JOYOEMULABEL         TEXT("OEMULabel")
#define REGSTR_VAL_JOYOEMVLABEL         TEXT("OEMVLabel")
#define REGSTR_VAL_JOYOEMTESTMOVEDESC   TEXT("OEMTestMoveDesc")
#define REGSTR_VAL_JOYOEMTESTBUTTONDESC TEXT("OEMTestButtonDesc")
#define REGSTR_VAL_JOYOEMTESTMOVECAP    TEXT("OEMTestMoveCap")
#define REGSTR_VAL_JOYOEMTESTBUTTONCAP  TEXT("OEMTestButtonCap")
#define REGSTR_VAL_JOYOEMTESTWINCAP     TEXT("OEMTestWinCap")
#define REGSTR_VAL_JOYOEMCALCAP         TEXT("OEMCalCap")
#define REGSTR_VAL_JOYOEMCALWINCAP      TEXT("OEMCalWinCap")
#define REGSTR_VAL_JOYOEMCAL1           TEXT("OEMCal1")
#define REGSTR_VAL_JOYOEMCAL2           TEXT("OEMCal2")
#define REGSTR_VAL_JOYOEMCAL3           TEXT("OEMCal3")
#define REGSTR_VAL_JOYOEMCAL4           TEXT("OEMCal4")
#define REGSTR_VAL_JOYOEMCAL5           TEXT("OEMCal5")
#define REGSTR_VAL_JOYOEMCAL6           TEXT("OEMCal6")
#define REGSTR_VAL_JOYOEMCAL7           TEXT("OEMCal7")
#define REGSTR_VAL_JOYOEMCAL8           TEXT("OEMCal8")
#define REGSTR_VAL_JOYOEMCAL9           TEXT("OEMCal9")
#define REGSTR_VAL_JOYOEMCAL10          TEXT("OEMCal10")
#define REGSTR_VAL_JOYOEMCAL11          TEXT("OEMCal11")
#define REGSTR_VAL_JOYOEMCAL12          TEXT("OEMCal12")

// Image values under REGSTR_PATH_MULTIMEDIA_AUDIO_IMAGES
#define REGSTR_VAL_AUDIO_BITMAP TEXT("bitmap")
#define REGSTR_VAL_AUDIO_ICON TEXT("icon")

//
// Entries for Device Installer under HKEY_LOCAL_MACHINE and HKEY_CURRENT_USER
//
#define REGSTR_PATH_DEVICEINSTALLER     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Device Installer")

//
// Entries for DIFX (Device Install Frameworks) under HKEY_LOCAL_MACHINE
//
#define REGSTR_PATH_DIFX     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\DIFX")


// Device Installer values found under REGSTR_PATH_DEVICEINSTALLER
#define REGSTR_VAL_SEARCHOPTIONS        TEXT("SearchOptions")

// BiosInfo defines.
#ifndef _IN_KERNEL_

#define REGSTR_PATH_BIOSINFO            TEXT("System\\CurrentControlSet\\Control\\BiosInfo")

#else

#define REGSTR_PATH_BIOSINFO            L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\BiosInfo"

#endif

// Pci Irq Routing registry defines.
#ifndef _IN_KERNEL_

#define REGSTR_PATH_PCIIR               TEXT("System\\CurrentControlSet\\Control\\Pnp\\PciIrqRouting")
#define REGSTR_VAL_OPTIONS              TEXT("Options")
#define REGSTR_VAL_STAT                 TEXT("Status")
#define REGSTR_VAL_TABLE_STAT           TEXT("TableStatus")
#define REGSTR_VAL_MINIPORT_STAT        TEXT("MiniportStatus")

#else

#define REGSTR_PATH_PCIIR               L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Pnp\\PciIrqRouting"
#define REGSTR_VAL_OPTIONS              L"Options"
#define REGSTR_VAL_STAT                 L"Status"
#define REGSTR_VAL_TABLE_STAT           L"TableStatus"
#define REGSTR_VAL_MINIPORT_STAT        L"MiniportStatus"

#endif

// Pci Irq Routing Option values.
#define PIR_OPTION_ENABLED                  0x00000001
#define PIR_OPTION_REGISTRY                 0x00000002
#define PIR_OPTION_MSSPEC                   0x00000004
#define PIR_OPTION_REALMODE                 0x00000008
#define PIR_OPTION_DEFAULT                  0x0000000f

// Pci Irq Routing Status values.
#define PIR_STATUS_ERROR                    0x00000000
#define PIR_STATUS_ENABLED                  0x00000001
#define PIR_STATUS_DISABLED                 0x00000002
#define PIR_STATUS_MAX                      0x00000003

#define PIR_STATUS_TABLE_REGISTRY           0x00000000
#define PIR_STATUS_TABLE_MSSPEC                     0x00000001
#define PIR_STATUS_TABLE_REALMODE                   0x00000002
#define PIR_STATUS_TABLE_NONE                   0x00000003
#define PIR_STATUS_TABLE_ERROR                      0x00000004
#define PIR_STATUS_TABLE_BAD                        0x00000005
#define PIR_STATUS_TABLE_SUCCESS            0x00000006
#define PIR_STATUS_TABLE_MAX                0x00000007

#define PIR_STATUS_MINIPORT_NORMAL                  0x00000000
#define PIR_STATUS_MINIPORT_COMPATIBLE      0x00000001
#define PIR_STATUS_MINIPORT_OVERRIDE        0x00000002
#define PIR_STATUS_MINIPORT_NONE                    0x00000003
#define PIR_STATUS_MINIPORT_ERROR                   0x00000004
#define PIR_STATUS_MINIPORT_NOKEY                   0x00000005
#define PIR_STATUS_MINIPORT_SUCCESS                 0x00000006
#define PIR_STATUS_MINIPORT_INVALID                 0x00000007
#define PIR_STATUS_MINIPORT_MAX             0x00000008

//
// entries for LastKnownGood
// each value name under this key is SubPath/File (note reversal of '\\' to '/')
// each value is an indication of post-processing to be done after files have been recovered
// LASTGOOD_OPERATION bits indicate the primary post-processing operation
// remaining bits may be used as flags (allocate flags from highest bits first)
// a value of 0 is the same as the value being omitted, ie, no post processing.
//

#define REGSTR_PATH_LASTGOOD            TEXT("System\\LastKnownGoodRecovery\\LastGood")
#define REGSTR_PATH_LASTGOODTMP         TEXT("System\\LastKnownGoodRecovery\\LastGood.Tmp")

#define LASTGOOD_OPERATION              0x000000FF // operation to perform
#define LASTGOOD_OPERATION_NOPOSTPROC   0x00000000 // no post-processing
#define LASTGOOD_OPERATION_DELETE       0x00000001 // Delete file during recovery

#endif  //_INC_REGSTR
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\regbag.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for regbag.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __regbag_h__
#define __regbag_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICreatePropBagOnRegKey_FWD_DEFINED__
#define __ICreatePropBagOnRegKey_FWD_DEFINED__
typedef interface ICreatePropBagOnRegKey ICreatePropBagOnRegKey;
#endif 	/* __ICreatePropBagOnRegKey_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_regbag_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2000.
//
//--------------------------------------------------------------------------
#pragma once


extern RPC_IF_HANDLE __MIDL_itf_regbag_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_regbag_0000_0000_v0_0_s_ifspec;

#ifndef __ICreatePropBagOnRegKey_INTERFACE_DEFINED__
#define __ICreatePropBagOnRegKey_INTERFACE_DEFINED__

/* interface ICreatePropBagOnRegKey */
/* [local][unique][helpstring][uuid][restricted][hidden][object] */ 


EXTERN_C const IID IID_ICreatePropBagOnRegKey;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8A674B48-1F63-11d3-B64C-00C04F79498E")
    ICreatePropBagOnRegKey : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ HKEY hkey,
            /* [in] */ LPCOLESTR subkey,
            /* [in] */ DWORD ulOptions,
            /* [in] */ DWORD samDesired,
            REFIID iid,
            /* [out] */ LPVOID *ppBag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreatePropBagOnRegKeyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICreatePropBagOnRegKey * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICreatePropBagOnRegKey * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICreatePropBagOnRegKey * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            ICreatePropBagOnRegKey * This,
            /* [in] */ HKEY hkey,
            /* [in] */ LPCOLESTR subkey,
            /* [in] */ DWORD ulOptions,
            /* [in] */ DWORD samDesired,
            REFIID iid,
            /* [out] */ LPVOID *ppBag);
        
        END_INTERFACE
    } ICreatePropBagOnRegKeyVtbl;

    interface ICreatePropBagOnRegKey
    {
        CONST_VTBL struct ICreatePropBagOnRegKeyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreatePropBagOnRegKey_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICreatePropBagOnRegKey_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICreatePropBagOnRegKey_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICreatePropBagOnRegKey_Create(This,hkey,subkey,ulOptions,samDesired,iid,ppBag)	\
    ( (This)->lpVtbl -> Create(This,hkey,subkey,ulOptions,samDesired,iid,ppBag) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICreatePropBagOnRegKey_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\REND.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for rend.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rend_h__
#define __rend_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITDirectoryObjectConference_FWD_DEFINED__
#define __ITDirectoryObjectConference_FWD_DEFINED__
typedef interface ITDirectoryObjectConference ITDirectoryObjectConference;
#endif 	/* __ITDirectoryObjectConference_FWD_DEFINED__ */


#ifndef __ITDirectoryObjectUser_FWD_DEFINED__
#define __ITDirectoryObjectUser_FWD_DEFINED__
typedef interface ITDirectoryObjectUser ITDirectoryObjectUser;
#endif 	/* __ITDirectoryObjectUser_FWD_DEFINED__ */


#ifndef __IEnumDialableAddrs_FWD_DEFINED__
#define __IEnumDialableAddrs_FWD_DEFINED__
typedef interface IEnumDialableAddrs IEnumDialableAddrs;
#endif 	/* __IEnumDialableAddrs_FWD_DEFINED__ */


#ifndef __ITDirectoryObject_FWD_DEFINED__
#define __ITDirectoryObject_FWD_DEFINED__
typedef interface ITDirectoryObject ITDirectoryObject;
#endif 	/* __ITDirectoryObject_FWD_DEFINED__ */


#ifndef __IEnumDirectoryObject_FWD_DEFINED__
#define __IEnumDirectoryObject_FWD_DEFINED__
typedef interface IEnumDirectoryObject IEnumDirectoryObject;
#endif 	/* __IEnumDirectoryObject_FWD_DEFINED__ */


#ifndef __ITILSConfig_FWD_DEFINED__
#define __ITILSConfig_FWD_DEFINED__
typedef interface ITILSConfig ITILSConfig;
#endif 	/* __ITILSConfig_FWD_DEFINED__ */


#ifndef __ITDirectory_FWD_DEFINED__
#define __ITDirectory_FWD_DEFINED__
typedef interface ITDirectory ITDirectory;
#endif 	/* __ITDirectory_FWD_DEFINED__ */


#ifndef __IEnumDirectory_FWD_DEFINED__
#define __IEnumDirectory_FWD_DEFINED__
typedef interface IEnumDirectory IEnumDirectory;
#endif 	/* __IEnumDirectory_FWD_DEFINED__ */


#ifndef __ITRendezvous_FWD_DEFINED__
#define __ITRendezvous_FWD_DEFINED__
typedef interface ITRendezvous ITRendezvous;
#endif 	/* __ITRendezvous_FWD_DEFINED__ */


#ifndef __ITRendezvous_FWD_DEFINED__
#define __ITRendezvous_FWD_DEFINED__
typedef interface ITRendezvous ITRendezvous;
#endif 	/* __ITRendezvous_FWD_DEFINED__ */


#ifndef __ITDirectoryObjectConference_FWD_DEFINED__
#define __ITDirectoryObjectConference_FWD_DEFINED__
typedef interface ITDirectoryObjectConference ITDirectoryObjectConference;
#endif 	/* __ITDirectoryObjectConference_FWD_DEFINED__ */


#ifndef __ITDirectoryObjectUser_FWD_DEFINED__
#define __ITDirectoryObjectUser_FWD_DEFINED__
typedef interface ITDirectoryObjectUser ITDirectoryObjectUser;
#endif 	/* __ITDirectoryObjectUser_FWD_DEFINED__ */


#ifndef __ITDirectoryObject_FWD_DEFINED__
#define __ITDirectoryObject_FWD_DEFINED__
typedef interface ITDirectoryObject ITDirectoryObject;
#endif 	/* __ITDirectoryObject_FWD_DEFINED__ */


#ifndef __ITILSConfig_FWD_DEFINED__
#define __ITILSConfig_FWD_DEFINED__
typedef interface ITILSConfig ITILSConfig;
#endif 	/* __ITILSConfig_FWD_DEFINED__ */


#ifndef __ITDirectory_FWD_DEFINED__
#define __ITDirectory_FWD_DEFINED__
typedef interface ITDirectory ITDirectory;
#endif 	/* __ITDirectory_FWD_DEFINED__ */


#ifndef __Rendezvous_FWD_DEFINED__
#define __Rendezvous_FWD_DEFINED__

#ifdef __cplusplus
typedef class Rendezvous Rendezvous;
#else
typedef struct Rendezvous Rendezvous;
#endif /* __cplusplus */

#endif 	/* __Rendezvous_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "tapi3if.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_rend_0000_0000 */
/* [local] */ 

/* Copyright (c) Microsoft Corporation. All rights reserved. */
#define	IDISPDIROBJECT	( 0x10000 )

#define	IDISPDIROBJCONFERENCE	( 0x20000 )

#define	IDISPDIROBJUSER	( 0x30000 )

#define	IDISPDIRECTORY	( 0x10000 )

#define	IDISPILSCONFIG	( 0x20000 )

typedef 
enum DIRECTORY_TYPE
    {	DT_NTDS	= 1,
	DT_ILS	= 2
    } 	DIRECTORY_TYPE;

typedef 
enum DIRECTORY_OBJECT_TYPE
    {	OT_CONFERENCE	= 1,
	OT_USER	= 2
    } 	DIRECTORY_OBJECT_TYPE;

typedef 
enum RND_ADVERTISING_SCOPE
    {	RAS_LOCAL	= 1,
	RAS_SITE	= 2,
	RAS_REGION	= 3,
	RAS_WORLD	= 4
    } 	RND_ADVERTISING_SCOPE;



extern RPC_IF_HANDLE __MIDL_itf_rend_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rend_0000_0000_v0_0_s_ifspec;

#ifndef __ITDirectoryObjectConference_INTERFACE_DEFINED__
#define __ITDirectoryObjectConference_INTERFACE_DEFINED__

/* interface ITDirectoryObjectConference */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITDirectoryObjectConference;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F1029E5D-CB5B-11D0-8D59-00C04FD91AC0")
    ITDirectoryObjectConference : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Protocol( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppProtocol) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Originator( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppOriginator) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Originator( 
            /* [in] */ __RPC__in BSTR pOriginator) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AdvertisingScope( 
            /* [retval][out] */ __RPC__out RND_ADVERTISING_SCOPE *pAdvertisingScope) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AdvertisingScope( 
            /* [in] */ RND_ADVERTISING_SCOPE AdvertisingScope) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Url( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppUrl) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Url( 
            /* [in] */ __RPC__in BSTR pUrl) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppDescription) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ __RPC__in BSTR pDescription) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsEncrypted( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfEncrypted) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_IsEncrypted( 
            /* [in] */ VARIANT_BOOL fEncrypted) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartTime( 
            /* [retval][out] */ __RPC__out DATE *pDate) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StartTime( 
            /* [in] */ DATE Date) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StopTime( 
            /* [retval][out] */ __RPC__out DATE *pDate) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StopTime( 
            /* [in] */ DATE Date) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDirectoryObjectConferenceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITDirectoryObjectConference * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITDirectoryObjectConference * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDirectoryObjectConference * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Protocol )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppProtocol);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Originator )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppOriginator);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Originator )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [in] */ __RPC__in BSTR pOriginator);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AdvertisingScope )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [retval][out] */ __RPC__out RND_ADVERTISING_SCOPE *pAdvertisingScope);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AdvertisingScope )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [in] */ RND_ADVERTISING_SCOPE AdvertisingScope);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Url )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppUrl);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Url )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [in] */ __RPC__in BSTR pUrl);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppDescription);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [in] */ __RPC__in BSTR pDescription);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsEncrypted )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfEncrypted);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IsEncrypted )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [in] */ VARIANT_BOOL fEncrypted);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartTime )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [retval][out] */ __RPC__out DATE *pDate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartTime )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [in] */ DATE Date);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StopTime )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [retval][out] */ __RPC__out DATE *pDate);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StopTime )( 
            __RPC__in ITDirectoryObjectConference * This,
            /* [in] */ DATE Date);
        
        END_INTERFACE
    } ITDirectoryObjectConferenceVtbl;

    interface ITDirectoryObjectConference
    {
        CONST_VTBL struct ITDirectoryObjectConferenceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDirectoryObjectConference_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITDirectoryObjectConference_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITDirectoryObjectConference_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITDirectoryObjectConference_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITDirectoryObjectConference_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITDirectoryObjectConference_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITDirectoryObjectConference_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITDirectoryObjectConference_get_Protocol(This,ppProtocol)	\
    ( (This)->lpVtbl -> get_Protocol(This,ppProtocol) ) 

#define ITDirectoryObjectConference_get_Originator(This,ppOriginator)	\
    ( (This)->lpVtbl -> get_Originator(This,ppOriginator) ) 

#define ITDirectoryObjectConference_put_Originator(This,pOriginator)	\
    ( (This)->lpVtbl -> put_Originator(This,pOriginator) ) 

#define ITDirectoryObjectConference_get_AdvertisingScope(This,pAdvertisingScope)	\
    ( (This)->lpVtbl -> get_AdvertisingScope(This,pAdvertisingScope) ) 

#define ITDirectoryObjectConference_put_AdvertisingScope(This,AdvertisingScope)	\
    ( (This)->lpVtbl -> put_AdvertisingScope(This,AdvertisingScope) ) 

#define ITDirectoryObjectConference_get_Url(This,ppUrl)	\
    ( (This)->lpVtbl -> get_Url(This,ppUrl) ) 

#define ITDirectoryObjectConference_put_Url(This,pUrl)	\
    ( (This)->lpVtbl -> put_Url(This,pUrl) ) 

#define ITDirectoryObjectConference_get_Description(This,ppDescription)	\
    ( (This)->lpVtbl -> get_Description(This,ppDescription) ) 

#define ITDirectoryObjectConference_put_Description(This,pDescription)	\
    ( (This)->lpVtbl -> put_Description(This,pDescription) ) 

#define ITDirectoryObjectConference_get_IsEncrypted(This,pfEncrypted)	\
    ( (This)->lpVtbl -> get_IsEncrypted(This,pfEncrypted) ) 

#define ITDirectoryObjectConference_put_IsEncrypted(This,fEncrypted)	\
    ( (This)->lpVtbl -> put_IsEncrypted(This,fEncrypted) ) 

#define ITDirectoryObjectConference_get_StartTime(This,pDate)	\
    ( (This)->lpVtbl -> get_StartTime(This,pDate) ) 

#define ITDirectoryObjectConference_put_StartTime(This,Date)	\
    ( (This)->lpVtbl -> put_StartTime(This,Date) ) 

#define ITDirectoryObjectConference_get_StopTime(This,pDate)	\
    ( (This)->lpVtbl -> get_StopTime(This,pDate) ) 

#define ITDirectoryObjectConference_put_StopTime(This,Date)	\
    ( (This)->lpVtbl -> put_StopTime(This,Date) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITDirectoryObjectConference_INTERFACE_DEFINED__ */


#ifndef __ITDirectoryObjectUser_INTERFACE_DEFINED__
#define __ITDirectoryObjectUser_INTERFACE_DEFINED__

/* interface ITDirectoryObjectUser */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITDirectoryObjectUser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D6F-6CFF-11d1-AFF7-00C04FC31FEE")
    ITDirectoryObjectUser : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IPPhonePrimary( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_IPPhonePrimary( 
            /* [in] */ __RPC__in BSTR pName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDirectoryObjectUserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITDirectoryObjectUser * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITDirectoryObjectUser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITDirectoryObjectUser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ITDirectoryObjectUser * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ITDirectoryObjectUser * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ITDirectoryObjectUser * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDirectoryObjectUser * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IPPhonePrimary )( 
            __RPC__in ITDirectoryObjectUser * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IPPhonePrimary )( 
            __RPC__in ITDirectoryObjectUser * This,
            /* [in] */ __RPC__in BSTR pName);
        
        END_INTERFACE
    } ITDirectoryObjectUserVtbl;

    interface ITDirectoryObjectUser
    {
        CONST_VTBL struct ITDirectoryObjectUserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDirectoryObjectUser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITDirectoryObjectUser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITDirectoryObjectUser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITDirectoryObjectUser_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITDirectoryObjectUser_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITDirectoryObjectUser_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITDirectoryObjectUser_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITDirectoryObjectUser_get_IPPhonePrimary(This,ppName)	\
    ( (This)->lpVtbl -> get_IPPhonePrimary(This,ppName) ) 

#define ITDirectoryObjectUser_put_IPPhonePrimary(This,pName)	\
    ( (This)->lpVtbl -> put_IPPhonePrimary(This,pName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITDirectoryObjectUser_INTERFACE_DEFINED__ */


#ifndef __IEnumDialableAddrs_INTERFACE_DEFINED__
#define __IEnumDialableAddrs_INTERFACE_DEFINED__

/* interface IEnumDialableAddrs */
/* [object][unique][restricted][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumDialableAddrs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D70-6CFF-11d1-AFF7-00C04FC31FEE")
    IEnumDialableAddrs : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) BSTR *ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumDialableAddrs **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDialableAddrsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumDialableAddrs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumDialableAddrs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumDialableAddrs * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumDialableAddrs * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) BSTR *ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumDialableAddrs * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumDialableAddrs * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumDialableAddrs * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumDialableAddrs **ppEnum);
        
        END_INTERFACE
    } IEnumDialableAddrsVtbl;

    interface IEnumDialableAddrs
    {
        CONST_VTBL struct IEnumDialableAddrsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDialableAddrs_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDialableAddrs_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDialableAddrs_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDialableAddrs_Next(This,celt,ppElements,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pcFetched) ) 

#define IEnumDialableAddrs_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDialableAddrs_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumDialableAddrs_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumDialableAddrs_INTERFACE_DEFINED__ */


#ifndef __ITDirectoryObject_INTERFACE_DEFINED__
#define __ITDirectoryObject_INTERFACE_DEFINED__

/* interface ITDirectoryObject */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITDirectoryObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D6E-6CFF-11d1-AFF7-00C04FC31FEE")
    ITDirectoryObject : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ObjectType( 
            /* [retval][out] */ __RPC__out DIRECTORY_OBJECT_TYPE *pObjectType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ __RPC__in BSTR pName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DialableAddrs( 
            /* [in] */ long dwAddressType,
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateDialableAddrs( 
            /* [in] */ DWORD dwAddressType,
            /* [out] */ __RPC__deref_out_opt IEnumDialableAddrs **ppEnumDialableAddrs) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SecurityDescriptor( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppSecDes) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SecurityDescriptor( 
            /* [in] */ __RPC__in_opt IDispatch *pSecDes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDirectoryObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITDirectoryObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITDirectoryObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITDirectoryObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ITDirectoryObject * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ITDirectoryObject * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ITDirectoryObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDirectoryObject * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectType )( 
            __RPC__in ITDirectoryObject * This,
            /* [retval][out] */ __RPC__out DIRECTORY_OBJECT_TYPE *pObjectType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in ITDirectoryObject * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            __RPC__in ITDirectoryObject * This,
            /* [in] */ __RPC__in BSTR pName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DialableAddrs )( 
            __RPC__in ITDirectoryObject * This,
            /* [in] */ long dwAddressType,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateDialableAddrs )( 
            __RPC__in ITDirectoryObject * This,
            /* [in] */ DWORD dwAddressType,
            /* [out] */ __RPC__deref_out_opt IEnumDialableAddrs **ppEnumDialableAddrs);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SecurityDescriptor )( 
            __RPC__in ITDirectoryObject * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppSecDes);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SecurityDescriptor )( 
            __RPC__in ITDirectoryObject * This,
            /* [in] */ __RPC__in_opt IDispatch *pSecDes);
        
        END_INTERFACE
    } ITDirectoryObjectVtbl;

    interface ITDirectoryObject
    {
        CONST_VTBL struct ITDirectoryObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDirectoryObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITDirectoryObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITDirectoryObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITDirectoryObject_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITDirectoryObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITDirectoryObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITDirectoryObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITDirectoryObject_get_ObjectType(This,pObjectType)	\
    ( (This)->lpVtbl -> get_ObjectType(This,pObjectType) ) 

#define ITDirectoryObject_get_Name(This,ppName)	\
    ( (This)->lpVtbl -> get_Name(This,ppName) ) 

#define ITDirectoryObject_put_Name(This,pName)	\
    ( (This)->lpVtbl -> put_Name(This,pName) ) 

#define ITDirectoryObject_get_DialableAddrs(This,dwAddressType,pVariant)	\
    ( (This)->lpVtbl -> get_DialableAddrs(This,dwAddressType,pVariant) ) 

#define ITDirectoryObject_EnumerateDialableAddrs(This,dwAddressType,ppEnumDialableAddrs)	\
    ( (This)->lpVtbl -> EnumerateDialableAddrs(This,dwAddressType,ppEnumDialableAddrs) ) 

#define ITDirectoryObject_get_SecurityDescriptor(This,ppSecDes)	\
    ( (This)->lpVtbl -> get_SecurityDescriptor(This,ppSecDes) ) 

#define ITDirectoryObject_put_SecurityDescriptor(This,pSecDes)	\
    ( (This)->lpVtbl -> put_SecurityDescriptor(This,pSecDes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITDirectoryObject_INTERFACE_DEFINED__ */


#ifndef __IEnumDirectoryObject_INTERFACE_DEFINED__
#define __IEnumDirectoryObject_INTERFACE_DEFINED__

/* interface IEnumDirectoryObject */
/* [unique][restricted][hidden][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDirectoryObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("06C9B64A-306D-11D1-9774-00C04FD91AC0")
    IEnumDirectoryObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) ITDirectoryObject **pVal,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumDirectoryObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDirectoryObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumDirectoryObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumDirectoryObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumDirectoryObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumDirectoryObject * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) ITDirectoryObject **pVal,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumDirectoryObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumDirectoryObject * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumDirectoryObject * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumDirectoryObject **ppEnum);
        
        END_INTERFACE
    } IEnumDirectoryObjectVtbl;

    interface IEnumDirectoryObject
    {
        CONST_VTBL struct IEnumDirectoryObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDirectoryObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDirectoryObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDirectoryObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDirectoryObject_Next(This,celt,pVal,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,pVal,pcFetched) ) 

#define IEnumDirectoryObject_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDirectoryObject_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumDirectoryObject_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumDirectoryObject_INTERFACE_DEFINED__ */


#ifndef __ITILSConfig_INTERFACE_DEFINED__
#define __ITILSConfig_INTERFACE_DEFINED__

/* interface ITILSConfig */
/* [helpstring][dual][uuid][public][object] */ 


EXTERN_C const IID IID_ITILSConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D72-6CFF-11d1-AFF7-00C04FC31FEE")
    ITILSConfig : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Port( 
            /* [retval][out] */ __RPC__out long *pPort) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Port( 
            /* [in] */ long Port) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITILSConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITILSConfig * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITILSConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITILSConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ITILSConfig * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ITILSConfig * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ITILSConfig * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITILSConfig * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Port )( 
            __RPC__in ITILSConfig * This,
            /* [retval][out] */ __RPC__out long *pPort);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Port )( 
            __RPC__in ITILSConfig * This,
            /* [in] */ long Port);
        
        END_INTERFACE
    } ITILSConfigVtbl;

    interface ITILSConfig
    {
        CONST_VTBL struct ITILSConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITILSConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITILSConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITILSConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITILSConfig_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITILSConfig_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITILSConfig_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITILSConfig_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITILSConfig_get_Port(This,pPort)	\
    ( (This)->lpVtbl -> get_Port(This,pPort) ) 

#define ITILSConfig_put_Port(This,Port)	\
    ( (This)->lpVtbl -> put_Port(This,Port) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITILSConfig_INTERFACE_DEFINED__ */


#ifndef __ITDirectory_INTERFACE_DEFINED__
#define __ITDirectory_INTERFACE_DEFINED__

/* interface ITDirectory */
/* [helpstring][dual][uuid][public][object] */ 


EXTERN_C const IID IID_ITDirectory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D6C-6CFF-11d1-AFF7-00C04FC31FEE")
    ITDirectory : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DirectoryType( 
            /* [retval][out] */ __RPC__out DIRECTORY_TYPE *pDirectoryType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsDynamic( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfDynamic) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultObjectTTL( 
            /* [retval][out] */ __RPC__out long *pTTL) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DefaultObjectTTL( 
            /* [in] */ long TTL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnableAutoRefresh( 
            /* [in] */ VARIANT_BOOL fEnable) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ VARIANT_BOOL fSecure) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Bind( 
            /* [in] */ __RPC__in BSTR pDomainName,
            /* [in] */ __RPC__in BSTR pUserName,
            /* [in] */ __RPC__in BSTR pPassword,
            /* [in] */ long lFlags) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddDirectoryObject( 
            /* [in] */ __RPC__in_opt ITDirectoryObject *pDirectoryObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ModifyDirectoryObject( 
            /* [in] */ __RPC__in_opt ITDirectoryObject *pDirectoryObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RefreshDirectoryObject( 
            /* [in] */ __RPC__in_opt ITDirectoryObject *pDirectoryObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeleteDirectoryObject( 
            /* [in] */ __RPC__in_opt ITDirectoryObject *pDirectoryObject) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DirectoryObjects( 
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ __RPC__in BSTR pName,
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateDirectoryObjects( 
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ __RPC__in BSTR pName,
            /* [out] */ __RPC__deref_out_opt IEnumDirectoryObject **ppEnumObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDirectoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITDirectory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITDirectory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITDirectory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ITDirectory * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ITDirectory * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ITDirectory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDirectory * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DirectoryType )( 
            __RPC__in ITDirectory * This,
            /* [retval][out] */ __RPC__out DIRECTORY_TYPE *pDirectoryType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayName )( 
            __RPC__in ITDirectory * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsDynamic )( 
            __RPC__in ITDirectory * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfDynamic);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultObjectTTL )( 
            __RPC__in ITDirectory * This,
            /* [retval][out] */ __RPC__out long *pTTL);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultObjectTTL )( 
            __RPC__in ITDirectory * This,
            /* [in] */ long TTL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnableAutoRefresh )( 
            __RPC__in ITDirectory * This,
            /* [in] */ VARIANT_BOOL fEnable);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            __RPC__in ITDirectory * This,
            /* [in] */ VARIANT_BOOL fSecure);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Bind )( 
            __RPC__in ITDirectory * This,
            /* [in] */ __RPC__in BSTR pDomainName,
            /* [in] */ __RPC__in BSTR pUserName,
            /* [in] */ __RPC__in BSTR pPassword,
            /* [in] */ long lFlags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddDirectoryObject )( 
            __RPC__in ITDirectory * This,
            /* [in] */ __RPC__in_opt ITDirectoryObject *pDirectoryObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ModifyDirectoryObject )( 
            __RPC__in ITDirectory * This,
            /* [in] */ __RPC__in_opt ITDirectoryObject *pDirectoryObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RefreshDirectoryObject )( 
            __RPC__in ITDirectory * This,
            /* [in] */ __RPC__in_opt ITDirectoryObject *pDirectoryObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeleteDirectoryObject )( 
            __RPC__in ITDirectory * This,
            /* [in] */ __RPC__in_opt ITDirectoryObject *pDirectoryObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DirectoryObjects )( 
            __RPC__in ITDirectory * This,
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ __RPC__in BSTR pName,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateDirectoryObjects )( 
            __RPC__in ITDirectory * This,
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ __RPC__in BSTR pName,
            /* [out] */ __RPC__deref_out_opt IEnumDirectoryObject **ppEnumObject);
        
        END_INTERFACE
    } ITDirectoryVtbl;

    interface ITDirectory
    {
        CONST_VTBL struct ITDirectoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDirectory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITDirectory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITDirectory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITDirectory_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITDirectory_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITDirectory_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITDirectory_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITDirectory_get_DirectoryType(This,pDirectoryType)	\
    ( (This)->lpVtbl -> get_DirectoryType(This,pDirectoryType) ) 

#define ITDirectory_get_DisplayName(This,pName)	\
    ( (This)->lpVtbl -> get_DisplayName(This,pName) ) 

#define ITDirectory_get_IsDynamic(This,pfDynamic)	\
    ( (This)->lpVtbl -> get_IsDynamic(This,pfDynamic) ) 

#define ITDirectory_get_DefaultObjectTTL(This,pTTL)	\
    ( (This)->lpVtbl -> get_DefaultObjectTTL(This,pTTL) ) 

#define ITDirectory_put_DefaultObjectTTL(This,TTL)	\
    ( (This)->lpVtbl -> put_DefaultObjectTTL(This,TTL) ) 

#define ITDirectory_EnableAutoRefresh(This,fEnable)	\
    ( (This)->lpVtbl -> EnableAutoRefresh(This,fEnable) ) 

#define ITDirectory_Connect(This,fSecure)	\
    ( (This)->lpVtbl -> Connect(This,fSecure) ) 

#define ITDirectory_Bind(This,pDomainName,pUserName,pPassword,lFlags)	\
    ( (This)->lpVtbl -> Bind(This,pDomainName,pUserName,pPassword,lFlags) ) 

#define ITDirectory_AddDirectoryObject(This,pDirectoryObject)	\
    ( (This)->lpVtbl -> AddDirectoryObject(This,pDirectoryObject) ) 

#define ITDirectory_ModifyDirectoryObject(This,pDirectoryObject)	\
    ( (This)->lpVtbl -> ModifyDirectoryObject(This,pDirectoryObject) ) 

#define ITDirectory_RefreshDirectoryObject(This,pDirectoryObject)	\
    ( (This)->lpVtbl -> RefreshDirectoryObject(This,pDirectoryObject) ) 

#define ITDirectory_DeleteDirectoryObject(This,pDirectoryObject)	\
    ( (This)->lpVtbl -> DeleteDirectoryObject(This,pDirectoryObject) ) 

#define ITDirectory_get_DirectoryObjects(This,DirectoryObjectType,pName,pVariant)	\
    ( (This)->lpVtbl -> get_DirectoryObjects(This,DirectoryObjectType,pName,pVariant) ) 

#define ITDirectory_EnumerateDirectoryObjects(This,DirectoryObjectType,pName,ppEnumObject)	\
    ( (This)->lpVtbl -> EnumerateDirectoryObjects(This,DirectoryObjectType,pName,ppEnumObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITDirectory_INTERFACE_DEFINED__ */


#ifndef __IEnumDirectory_INTERFACE_DEFINED__
#define __IEnumDirectory_INTERFACE_DEFINED__

/* interface IEnumDirectory */
/* [object][unique][restricted][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumDirectory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D6D-6CFF-11d1-AFF7-00C04FC31FEE")
    IEnumDirectory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pcFetched) ITDirectory **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumDirectory **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDirectoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumDirectory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumDirectory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumDirectory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumDirectory * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pcFetched) ITDirectory **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumDirectory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumDirectory * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumDirectory * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumDirectory **ppEnum);
        
        END_INTERFACE
    } IEnumDirectoryVtbl;

    interface IEnumDirectory
    {
        CONST_VTBL struct IEnumDirectoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDirectory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDirectory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDirectory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDirectory_Next(This,celt,ppElements,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pcFetched) ) 

#define IEnumDirectory_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDirectory_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumDirectory_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumDirectory_INTERFACE_DEFINED__ */


#ifndef __ITRendezvous_INTERFACE_DEFINED__
#define __ITRendezvous_INTERFACE_DEFINED__

/* interface ITRendezvous */
/* [helpstring][dual][uuid][public][object] */ 


EXTERN_C const IID IID_ITRendezvous;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34621D6B-6CFF-11d1-AFF7-00C04FC31FEE")
    ITRendezvous : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultDirectories( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateDefaultDirectories( 
            /* [out] */ __RPC__deref_out_opt IEnumDirectory **ppEnumDirectory) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateDirectory( 
            /* [in] */ DIRECTORY_TYPE DirectoryType,
            /* [in] */ __RPC__in BSTR pName,
            /* [retval][out] */ __RPC__deref_out_opt ITDirectory **ppDir) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateDirectoryObject( 
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ __RPC__in BSTR pName,
            /* [retval][out] */ __RPC__deref_out_opt ITDirectoryObject **ppDirectoryObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITRendezvousVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITRendezvous * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITRendezvous * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITRendezvous * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ITRendezvous * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ITRendezvous * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ITRendezvous * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITRendezvous * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultDirectories )( 
            __RPC__in ITRendezvous * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateDefaultDirectories )( 
            __RPC__in ITRendezvous * This,
            /* [out] */ __RPC__deref_out_opt IEnumDirectory **ppEnumDirectory);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateDirectory )( 
            __RPC__in ITRendezvous * This,
            /* [in] */ DIRECTORY_TYPE DirectoryType,
            /* [in] */ __RPC__in BSTR pName,
            /* [retval][out] */ __RPC__deref_out_opt ITDirectory **ppDir);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateDirectoryObject )( 
            __RPC__in ITRendezvous * This,
            /* [in] */ DIRECTORY_OBJECT_TYPE DirectoryObjectType,
            /* [in] */ __RPC__in BSTR pName,
            /* [retval][out] */ __RPC__deref_out_opt ITDirectoryObject **ppDirectoryObject);
        
        END_INTERFACE
    } ITRendezvousVtbl;

    interface ITRendezvous
    {
        CONST_VTBL struct ITRendezvousVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITRendezvous_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITRendezvous_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITRendezvous_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITRendezvous_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITRendezvous_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITRendezvous_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITRendezvous_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITRendezvous_get_DefaultDirectories(This,pVariant)	\
    ( (This)->lpVtbl -> get_DefaultDirectories(This,pVariant) ) 

#define ITRendezvous_EnumerateDefaultDirectories(This,ppEnumDirectory)	\
    ( (This)->lpVtbl -> EnumerateDefaultDirectories(This,ppEnumDirectory) ) 

#define ITRendezvous_CreateDirectory(This,DirectoryType,pName,ppDir)	\
    ( (This)->lpVtbl -> CreateDirectory(This,DirectoryType,pName,ppDir) ) 

#define ITRendezvous_CreateDirectoryObject(This,DirectoryObjectType,pName,ppDirectoryObject)	\
    ( (This)->lpVtbl -> CreateDirectoryObject(This,DirectoryObjectType,pName,ppDirectoryObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITRendezvous_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rend_0000_0009 */
/* [local] */ 



/***************************************************************/
/* Rend constants -- defined here for C apps                   */
/* The subsequent definitions that MIDL generates from the     */
/* module declaration are not used. The module declaration is  */
/* retained, however, so that the constants show up in the     */
/* type library.                                               */
/***************************************************************/

#define RENDBIND_AUTHENTICATE       0x00000001
#define RENDBIND_DEFAULTDOMAINNAME  0x00000002
#define RENDBIND_DEFAULTUSERNAME    0x00000004
#define RENDBIND_DEFAULTPASSWORD    0x00000008
/* this is just the previous three |'ed together for convenience. */
#define RENDBIND_DEFAULTCREDENTIALS 0x0000000e

#define __RendConstants_MODULE_DEFINED__

/***************************************************************/
/* end of rend constants section                               */
/***************************************************************/




extern RPC_IF_HANDLE __MIDL_itf_rend_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rend_0000_0009_v0_0_s_ifspec;


#ifndef __RENDLib_LIBRARY_DEFINED__
#define __RENDLib_LIBRARY_DEFINED__

/* library RENDLib */
/* [helpstring][version][uuid] */ 








EXTERN_C const IID LIBID_RENDLib;

EXTERN_C const CLSID CLSID_Rendezvous;

#ifdef __cplusplus

class DECLSPEC_UUID("F1029E5B-CB5B-11D0-8D59-00C04FD91AC0")
Rendezvous;
#endif


#ifndef __RendConstants_MODULE_DEFINED__
#define __RendConstants_MODULE_DEFINED__


/* module RendConstants */
/* [helpstring][dllname][uuid] */ 

const long RENDBIND_AUTHENTICATE	=	0x1;

const long RENDBIND_DEFAULTDOMAINNAME	=	0x2;

const long RENDBIND_DEFAULTUSERNAME	=	0x4;

const long RENDBIND_DEFAULTPASSWORD	=	0x8;

const long RENDBIND_DEFAULTCREDENTIALS	=	0xe;

#endif /* __RendConstants_MODULE_DEFINED__ */
#endif /* __RENDLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Richedit.h ===
/*
 *	RICHEDIT.H
 *	
 *	Purpose:
 *		RICHEDIT v2.0/3.0/4.0 public definitions
 *		functionality available for v2.0 and 3.0 that is not in the original
 *		Windows 95 release.
 *	
 *	Copyright (c) Microsoft Corporation. All rights reserved.
 */

#ifndef _RICHEDIT_
#define	_RICHEDIT_
#pragma once

#ifdef _WIN32
#include <pshpack4.h>
#elif !defined(RC_INVOKED)
#pragma pack(4)
#endif

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// To mimic older RichEdit behavior, set _RICHEDIT_VER to appropriate value
//		Version 1.0		0x0100	
//		Version 2.0		0x0200	
//		Version 2.1		0x0210	
#ifndef _RICHEDIT_VER
#define _RICHEDIT_VER	0x0300
#endif

#define cchTextLimitDefault 32767

#define MSFTEDIT_CLASS		L"RICHEDIT50W"
// NOTE:  MSFTEDIT.DLL only registers MSFTEDIT_CLASS.  If an application wants
// to use the following Richedit classes, it needs to load the riched20.dll.
// Otherwise, CreateWindow with RICHEDIT_CLASS would fail.
// This also applies to any dialog that uses RICHEDIT_CLASS, 

// RichEdit 2.0 Window Class 
// On Windows CE, avoid possible conflicts on Win95
#define CERICHEDIT_CLASSA	"RichEditCEA"
#define CERICHEDIT_CLASSW	L"RichEditCEW"

#define RICHEDIT_CLASSA		"RichEdit20A"
#define RICHEDIT_CLASS10A	"RICHEDIT"			// Richedit 1.0

#ifndef MACPORT
#define RICHEDIT_CLASSW		L"RichEdit20W"
#else	//----------------------MACPORT 
#define RICHEDIT_CLASSW		TEXT("RichEdit20W")	// MACPORT change 
#endif // MACPORT  

#if (_RICHEDIT_VER >= 0x0200 )
#ifdef UNICODE
#define RICHEDIT_CLASS		RICHEDIT_CLASSW
#else
#define RICHEDIT_CLASS		RICHEDIT_CLASSA
#endif // UNICODE 
#else
#define RICHEDIT_CLASS		RICHEDIT_CLASS10A
#endif // _RICHEDIT_VER >= 0x0200 

// RichEdit messages 

#ifndef WM_CONTEXTMENU
#define WM_CONTEXTMENU			0x007B
#endif

#ifndef WM_UNICHAR
#define WM_UNICHAR				0x0109
#endif

#ifndef WM_PRINTCLIENT
#define WM_PRINTCLIENT			0x0318
#endif

#ifndef EM_GETLIMITTEXT
#define EM_GETLIMITTEXT			(WM_USER + 37)
#endif

#ifndef EM_POSFROMCHAR	
#define EM_POSFROMCHAR			(WM_USER + 38)
#define EM_CHARFROMPOS			(WM_USER + 39)
#endif

#ifndef EM_SCROLLCARET
#define EM_SCROLLCARET			(WM_USER + 49)
#endif
#define EM_CANPASTE				(WM_USER + 50)
#define EM_DISPLAYBAND			(WM_USER + 51)
#define EM_EXGETSEL				(WM_USER + 52)
#define EM_EXLIMITTEXT			(WM_USER + 53)
#define EM_EXLINEFROMCHAR		(WM_USER + 54)
#define EM_EXSETSEL				(WM_USER + 55)
#define EM_FINDTEXT				(WM_USER + 56)
#define EM_FORMATRANGE			(WM_USER + 57)
#define EM_GETCHARFORMAT		(WM_USER + 58)
#define EM_GETEVENTMASK			(WM_USER + 59)
#define EM_GETOLEINTERFACE		(WM_USER + 60)
#define EM_GETPARAFORMAT		(WM_USER + 61)
#define EM_GETSELTEXT			(WM_USER + 62)
#define EM_HIDESELECTION		(WM_USER + 63)
#define EM_PASTESPECIAL			(WM_USER + 64)
#define EM_REQUESTRESIZE		(WM_USER + 65)
#define EM_SELECTIONTYPE		(WM_USER + 66)
#define EM_SETBKGNDCOLOR		(WM_USER + 67)
#define EM_SETCHARFORMAT		(WM_USER + 68)
#define EM_SETEVENTMASK			(WM_USER + 69)
#define EM_SETOLECALLBACK		(WM_USER + 70)
#define EM_SETPARAFORMAT		(WM_USER + 71)
#define EM_SETTARGETDEVICE		(WM_USER + 72)
#define EM_STREAMIN				(WM_USER + 73)
#define EM_STREAMOUT			(WM_USER + 74)
#define EM_GETTEXTRANGE			(WM_USER + 75)
#define EM_FINDWORDBREAK		(WM_USER + 76)
#define EM_SETOPTIONS			(WM_USER + 77)
#define EM_GETOPTIONS			(WM_USER + 78)
#define EM_FINDTEXTEX			(WM_USER + 79)
#ifdef _WIN32
#define EM_GETWORDBREAKPROCEX	(WM_USER + 80)
#define EM_SETWORDBREAKPROCEX	(WM_USER + 81)
#endif

// RichEdit 2.0 messages 
#define	EM_SETUNDOLIMIT			(WM_USER + 82)
#define EM_REDO					(WM_USER + 84)
#define EM_CANREDO				(WM_USER + 85)
#define EM_GETUNDONAME			(WM_USER + 86)
#define EM_GETREDONAME			(WM_USER + 87)
#define EM_STOPGROUPTYPING		(WM_USER + 88)

#define EM_SETTEXTMODE			(WM_USER + 89)
#define EM_GETTEXTMODE			(WM_USER + 90)

// enum for use with EM_GET/SETTEXTMODE 
typedef enum tagTextMode
{
	TM_PLAINTEXT			= 1,
	TM_RICHTEXT				= 2,	// Default behavior 
	TM_SINGLELEVELUNDO		= 4,
	TM_MULTILEVELUNDO		= 8,	// Default behavior 
	TM_SINGLECODEPAGE		= 16,
	TM_MULTICODEPAGE		= 32	// Default behavior 
} TEXTMODE;

#define EM_AUTOURLDETECT		(WM_USER + 91)
#define EM_GETAUTOURLDETECT		(WM_USER + 92)
#define EM_SETPALETTE			(WM_USER + 93)
#define EM_GETTEXTEX			(WM_USER + 94)
#define EM_GETTEXTLENGTHEX		(WM_USER + 95)
#define EM_SHOWSCROLLBAR		(WM_USER + 96)
#define EM_SETTEXTEX			(WM_USER + 97)

// East Asia specific messages 
#define EM_SETPUNCTUATION		(WM_USER + 100)
#define EM_GETPUNCTUATION		(WM_USER + 101)
#define EM_SETWORDWRAPMODE		(WM_USER + 102)
#define EM_GETWORDWRAPMODE		(WM_USER + 103)
#define EM_SETIMECOLOR			(WM_USER + 104)
#define EM_GETIMECOLOR			(WM_USER + 105)
#define EM_SETIMEOPTIONS		(WM_USER + 106)
#define EM_GETIMEOPTIONS		(WM_USER + 107)
#define EM_CONVPOSITION 		(WM_USER + 108)

#define EM_SETLANGOPTIONS		(WM_USER + 120)
#define EM_GETLANGOPTIONS		(WM_USER + 121)
#define EM_GETIMECOMPMODE		(WM_USER + 122)

#define EM_FINDTEXTW			(WM_USER + 123)
#define EM_FINDTEXTEXW			(WM_USER + 124)

// RE3.0 FE messages 
#define EM_RECONVERSION			(WM_USER + 125)
#define EM_SETIMEMODEBIAS		(WM_USER + 126)	
#define EM_GETIMEMODEBIAS		(WM_USER + 127)

// BiDi specific messages 
#define EM_SETBIDIOPTIONS		(WM_USER + 200)
#define EM_GETBIDIOPTIONS		(WM_USER + 201)

#define EM_SETTYPOGRAPHYOPTIONS	(WM_USER + 202)
#define EM_GETTYPOGRAPHYOPTIONS	(WM_USER + 203)

// Extended edit style specific messages 
#define EM_SETEDITSTYLE			(WM_USER + 204)
#define EM_GETEDITSTYLE			(WM_USER + 205)

// Extended edit style masks 
#define	SES_EMULATESYSEDIT		1
#define SES_BEEPONMAXTEXT		2
#define	SES_EXTENDBACKCOLOR		4
#define SES_MAPCPS			8	// (obsolete)
#define SES_EMULATE10			16	// (obsolete)
#define	SES_USECRLF			32	// (obsolete)
#define SES_NOXLTSYMBOLRANGE		32
#define SES_USEAIMM			64
#define SES_NOIME			128

#define SES_ALLOWBEEPS			256
#define SES_UPPERCASE			512
#define	SES_LOWERCASE			1024
#define SES_NOINPUTSEQUENCECHK	2048
#define SES_BIDI				4096
#define SES_SCROLLONKILLFOCUS	8192
#define	SES_XLTCRCRLFTOCR		16384
#define SES_DRAFTMODE			32768

#define	SES_USECTF				0x0010000
#define SES_HIDEGRIDLINES		0x0020000
#define SES_USEATFONT			0x0040000
#define SES_CUSTOMLOOK			0x0080000
#define SES_LBSCROLLNOTIFY		0x0100000
#define SES_CTFALLOWEMBED		0x0200000
#define SES_CTFALLOWSMARTTAG	0x0400000
#define SES_CTFALLOWPROOFING	0x0800000

// Options for EM_SETLANGOPTIONS and EM_GETLANGOPTIONS 
#define IMF_AUTOKEYBOARD		0x0001
#define IMF_AUTOFONT			0x0002
#define IMF_IMECANCELCOMPLETE	0x0004	// High completes comp string when aborting, low cancels
#define IMF_IMEALWAYSSENDNOTIFY 0x0008
#define IMF_AUTOFONTSIZEADJUST	0x0010
#define IMF_UIFONTS				0x0020
#define IMF_DUALFONT			0x0080
#define IMF_NORTFFONTSUBSTITUTE 0x0400


// Values for EM_GETIMECOMPMODE 
#define ICM_NOTOPEN				0x0000
#define ICM_LEVEL3				0x0001
#define ICM_LEVEL2				0x0002
#define ICM_LEVEL2_5			0x0003
#define ICM_LEVEL2_SUI			0x0004
#define ICM_CTF					0x0005

// Options for EM_SETTYPOGRAPHYOPTIONS 
#define	TO_ADVANCEDTYPOGRAPHY	1
#define	TO_SIMPLELINEBREAK		2
#define TO_DISABLECUSTOMTEXTOUT	4
#define TO_ADVANCEDLAYOUT		8

// Pegasus outline mode messages (RE 3.0) 

// Outline mode message
#define EM_OUTLINE              (WM_USER + 220)
// Message for getting and restoring scroll pos
#define EM_GETSCROLLPOS         (WM_USER + 221)
#define EM_SETSCROLLPOS         (WM_USER + 222)
// Change fontsize in current selection by wParam
#define EM_SETFONTSIZE          (WM_USER + 223)
#define EM_GETZOOM				(WM_USER + 224)
#define EM_SETZOOM				(WM_USER + 225)
#define EM_GETVIEWKIND			(WM_USER + 226)
#define EM_SETVIEWKIND			(WM_USER + 227)

// RichEdit 4.0 messages
#define EM_GETPAGE				(WM_USER + 228)
#define EM_SETPAGE				(WM_USER + 229)
#define EM_GETHYPHENATEINFO		(WM_USER + 230)
#define EM_SETHYPHENATEINFO		(WM_USER + 231)
#define EM_GETPAGEROTATE		(WM_USER + 235)
#define EM_SETPAGEROTATE		(WM_USER + 236)
#define EM_GETCTFMODEBIAS		(WM_USER + 237)
#define EM_SETCTFMODEBIAS		(WM_USER + 238)
#define EM_GETCTFOPENSTATUS		(WM_USER + 240)
#define EM_SETCTFOPENSTATUS		(WM_USER + 241)
#define EM_GETIMECOMPTEXT		(WM_USER + 242)
#define EM_ISIME				(WM_USER + 243)
#define EM_GETIMEPROPERTY		(WM_USER + 244)

// These messages control what rich edit does when it comes accross
// OLE objects during RTF stream in.  Normally rich edit queries the client
// application only after OleLoad has been called.  With these messages it is possible to
// set the rich edit control to a mode where it will query the client application before
// OleLoad is called
#define EM_GETQUERYRTFOBJ		(WM_USER + 269)
#define EM_SETQUERYRTFOBJ		(WM_USER + 270)

// EM_SETPAGEROTATE wparam values
#define EPR_0					0		// Text flows left to right and top to bottom
#define EPR_270					1		// Text flows top to bottom and right to left
#define EPR_180					2		// Text flows right to left and bottom to top
#define	EPR_90					3		// Text flows bottom to top and left to right

// EM_SETCTFMODEBIAS wparam values
#define CTFMODEBIAS_DEFAULT					0x0000
#define CTFMODEBIAS_FILENAME				0x0001
#define CTFMODEBIAS_NAME					0x0002
#define CTFMODEBIAS_READING					0x0003
#define CTFMODEBIAS_DATETIME				0x0004
#define CTFMODEBIAS_CONVERSATION			0x0005
#define CTFMODEBIAS_NUMERIC					0x0006
#define CTFMODEBIAS_HIRAGANA				0x0007
#define CTFMODEBIAS_KATAKANA				0x0008
#define CTFMODEBIAS_HANGUL					0x0009
#define CTFMODEBIAS_HALFWIDTHKATAKANA		0x000A
#define CTFMODEBIAS_FULLWIDTHALPHANUMERIC	0x000B
#define CTFMODEBIAS_HALFWIDTHALPHANUMERIC	0x000C

// EM_SETIMEMODEBIAS lparam values
#define IMF_SMODE_PLAURALCLAUSE	0x0001
#define IMF_SMODE_NONE			0x0002

// EM_GETIMECOMPTEXT wparam structure
typedef struct _imecomptext {
	LONG	cb;			// count of bytes in the output buffer.
	DWORD	flags;		// value specifying the composition string type.
						//	Currently only support ICT_RESULTREADSTR
} IMECOMPTEXT;
#define ICT_RESULTREADSTR		1

// Outline mode wparam values
#define EMO_EXIT                0       // Enter normal mode,  lparam ignored
#define EMO_ENTER               1       // Enter outline mode, lparam ignored
#define EMO_PROMOTE             2       // LOWORD(lparam) == 0 ==>
                                        //  promote  to body-text
                                        // LOWORD(lparam) != 0 ==>
                                        //  promote/demote current selection
                                        //  by indicated number of levels
#define EMO_EXPAND              3       // HIWORD(lparam) = EMO_EXPANDSELECTION
                                        //  -> expands selection to level
                                        //  indicated in LOWORD(lparam)
                                        //  LOWORD(lparam) = -1/+1 corresponds
                                        //  to collapse/expand button presses
                                        //  in winword (other values are
                                        //  equivalent to having pressed these
                                        //  buttons more than once)
                                        //  HIWORD(lparam) = EMO_EXPANDDOCUMENT
                                        //  -> expands whole document to
                                        //  indicated level
#define EMO_MOVESELECTION       4       // LOWORD(lparam) != 0 -> move current
                                        //  selection up/down by indicated amount
#define EMO_GETVIEWMODE			5		// Returns VM_NORMAL or VM_OUTLINE

// EMO_EXPAND options
#define EMO_EXPANDSELECTION     0
#define EMO_EXPANDDOCUMENT      1

#define VM_NORMAL				4		// Agrees with RTF \viewkindN
#define VM_OUTLINE				2
#define VM_PAGE					9		// Screen page view (not print layout)

// New notifications 
#define EN_MSGFILTER			0x0700
#define EN_REQUESTRESIZE		0x0701
#define EN_SELCHANGE			0x0702
#define EN_DROPFILES			0x0703
#define EN_PROTECTED			0x0704
#define EN_CORRECTTEXT			0x0705			// PenWin specific 
#define EN_STOPNOUNDO			0x0706
#define EN_IMECHANGE			0x0707			// East Asia specific 
#define EN_SAVECLIPBOARD		0x0708
#define EN_OLEOPFAILED			0x0709
#define EN_OBJECTPOSITIONS		0x070a
#define EN_LINK					0x070b
#define EN_DRAGDROPDONE			0x070c
#define EN_PARAGRAPHEXPANDED	0x070d
#define EN_PAGECHANGE			0x070e
#define EN_LOWFIRTF				0x070f
#define EN_ALIGNLTR				0x0710			// BiDi specific notification
#define EN_ALIGNRTL				0x0711			// BiDi specific notification

// Event notification masks 
#define ENM_NONE				0x00000000
#define ENM_CHANGE				0x00000001
#define ENM_UPDATE				0x00000002
#define ENM_SCROLL				0x00000004
#define ENM_SCROLLEVENTS		0x00000008
#define ENM_DRAGDROPDONE		0x00000010
#define ENM_PARAGRAPHEXPANDED	0x00000020
#define ENM_PAGECHANGE			0x00000040
#define ENM_KEYEVENTS			0x00010000
#define ENM_MOUSEEVENTS			0x00020000
#define ENM_REQUESTRESIZE		0x00040000
#define ENM_SELCHANGE			0x00080000
#define ENM_DROPFILES			0x00100000
#define ENM_PROTECTED			0x00200000
#define ENM_CORRECTTEXT			0x00400000		// PenWin specific 
#define ENM_IMECHANGE			0x00800000		// Used by RE1.0 compatibility
#define ENM_LANGCHANGE			0x01000000
#define ENM_OBJECTPOSITIONS		0x02000000
#define ENM_LINK				0x04000000
#define ENM_LOWFIRTF			0x08000000


// New edit control styles 
#define ES_SAVESEL				0x00008000
#define ES_SUNKEN				0x00004000
#define ES_DISABLENOSCROLL		0x00002000
// Same as WS_MAXIMIZE, but that doesn't make sense so we re-use the value 
#define ES_SELECTIONBAR			0x01000000
// Same as ES_UPPERCASE, but re-used to completely disable OLE drag'n'drop 
#define ES_NOOLEDRAGDROP		0x00000008

// New edit control extended style 
#if (_WIN32_WINNT > 0x0400) || (WINVER > 0x0400)
#define ES_EX_NOCALLOLEINIT		0x00000000		// Not supported in RE 2.0/3.0 
#else
#ifdef	_WIN32
#define ES_EX_NOCALLOLEINIT		0x01000000
#endif	
#endif

// These flags are used in FE Windows 
#define ES_VERTICAL				0x00400000		// Not supported in RE 2.0/3.0 
#define	ES_NOIME				0x00080000
#define ES_SELFIME				0x00040000

// Edit control options 
#define ECO_AUTOWORDSELECTION	0x00000001
#define ECO_AUTOVSCROLL			0x00000040
#define ECO_AUTOHSCROLL			0x00000080
#define ECO_NOHIDESEL			0x00000100
#define ECO_READONLY			0x00000800
#define ECO_WANTRETURN			0x00001000
#define ECO_SAVESEL				0x00008000
#define ECO_SELECTIONBAR		0x01000000
#define ECO_VERTICAL			0x00400000		// FE specific 


// ECO operations 
#define ECOOP_SET				0x0001
#define ECOOP_OR				0x0002
#define ECOOP_AND				0x0003
#define ECOOP_XOR				0x0004

// New word break function actions 
#define WB_CLASSIFY			3
#define WB_MOVEWORDLEFT		4
#define WB_MOVEWORDRIGHT	5
#define WB_LEFTBREAK		6
#define WB_RIGHTBREAK		7

// East Asia specific flags 
#define WB_MOVEWORDPREV		4
#define WB_MOVEWORDNEXT		5
#define WB_PREVBREAK		6
#define WB_NEXTBREAK		7

#define PC_FOLLOWING		1
#define	PC_LEADING			2
#define	PC_OVERFLOW			3
#define	PC_DELIMITER		4
#define WBF_WORDWRAP		0x010
#define WBF_WORDBREAK		0x020
#define	WBF_OVERFLOW		0x040	
#define WBF_LEVEL1			0x080
#define	WBF_LEVEL2			0x100
#define	WBF_CUSTOM			0x200

// East Asia specific flags 
#define IMF_FORCENONE           0x0001
#define IMF_FORCEENABLE         0x0002
#define IMF_FORCEDISABLE        0x0004
#define IMF_CLOSESTATUSWINDOW   0x0008
#define IMF_VERTICAL            0x0020
#define IMF_FORCEACTIVE         0x0040
#define IMF_FORCEINACTIVE       0x0080
#define IMF_FORCEREMEMBER       0x0100
#define IMF_MULTIPLEEDIT        0x0400

// Word break flags (used with WB_CLASSIFY) 
#define WBF_CLASS			((BYTE) 0x0F)
#define WBF_ISWHITE			((BYTE) 0x10)
#define WBF_BREAKLINE		((BYTE) 0x20)
#define WBF_BREAKAFTER		((BYTE) 0x40)


// Data types 

#ifdef _WIN32
// Extended edit word break proc (character set aware) 
typedef LONG (*EDITWORDBREAKPROCEX)(char *pchText, LONG cchText, BYTE bCharSet, INT action);
#endif

// All character format measurements are in twips 
typedef struct _charformat
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	char		szFaceName[LF_FACESIZE];
} CHARFORMATA;

typedef struct _charformatw
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	WCHAR		szFaceName[LF_FACESIZE];
} CHARFORMATW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define CHARFORMAT CHARFORMATW
#else
#define CHARFORMAT CHARFORMATA
#endif // UNICODE 
#else
#define CHARFORMAT CHARFORMATA
#endif // _RICHEDIT_VER >= 0x0200 

// CHARFORMAT2 structure 

#ifdef __cplusplus

struct CHARFORMAT2W : _charformatw
{
	WORD		wWeight;			// Font weight (LOGFONT value)
	SHORT		sSpacing;			// Amount to space between letters
	COLORREF	crBackColor;		// Background color
	LCID		lcid;				// Locale ID
	DWORD		dwReserved;			// Reserved. Must be 0
	SHORT		sStyle;				// Style handle
	WORD		wKerning;			// Twip size above which to kern char pair
	BYTE		bUnderlineType;		// Underline type
	BYTE		bAnimation;			// Animated text like marching ants
	BYTE		bRevAuthor;			// Revision author index
};

struct CHARFORMAT2A : _charformat
{
	WORD		wWeight;			// Font weight (LOGFONT value)
	SHORT		sSpacing;			// Amount to space between letters
	COLORREF	crBackColor;		// Background color
	LCID		lcid;				// Locale ID
	DWORD		dwReserved;			// Reserved. Must be 0
	SHORT		sStyle;				// Style handle
	WORD		wKerning;			// Twip size above which to kern char pair
	BYTE		bUnderlineType;		// Underline type
	BYTE		bAnimation;			// Animated text like marching ants
	BYTE		bRevAuthor;			// Revision author index
};

#else	// regular C-style  

typedef struct _charformat2w
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;			// > 0 for superscript, < 0 for subscript 
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	WCHAR		szFaceName[LF_FACESIZE];
	WORD		wWeight;			// Font weight (LOGFONT value)		
	SHORT		sSpacing;			// Amount to space between letters	
	COLORREF	crBackColor;		// Background color					
	LCID		lcid;				// Locale ID						
	DWORD		dwReserved;			// Reserved. Must be 0				
	SHORT		sStyle;				// Style handle						
	WORD		wKerning;			// Twip size above which to kern char pair
	BYTE		bUnderlineType;		// Underline type					
	BYTE		bAnimation;			// Animated text like marching ants	
	BYTE		bRevAuthor;			// Revision author index			
	BYTE		bReserved1;
} CHARFORMAT2W;

typedef struct _charformat2a
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;			// > 0 for superscript, < 0 for subscript 
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	char		szFaceName[LF_FACESIZE];
	WORD		wWeight;			// Font weight (LOGFONT value)		
	SHORT		sSpacing;			// Amount to space between letters	
	COLORREF	crBackColor;		// Background color					
	LCID		lcid;				// Locale ID						
	DWORD		dwReserved;			// Reserved. Must be 0				
	SHORT		sStyle;				// Style handle						
	WORD		wKerning;			// Twip size above which to kern char pair
	BYTE		bUnderlineType;		// Underline type					
	BYTE		bAnimation;			// Animated text like marching ants	
	BYTE		bRevAuthor;			// Revision author index			
} CHARFORMAT2A;

#endif // C++ 

#ifdef UNICODE
#define CHARFORMAT2	CHARFORMAT2W
#else
#define CHARFORMAT2 CHARFORMAT2A
#endif

#define CHARFORMATDELTA		(sizeof(CHARFORMAT2) - sizeof(CHARFORMAT))


// CFM_COLOR mirrors CFE_AUTOCOLOR, a little hack to easily deal with autocolor

// CHARFORMAT masks 
#define CFM_BOLD		0x00000001
#define CFM_ITALIC		0x00000002
#define CFM_UNDERLINE	0x00000004
#define CFM_STRIKEOUT	0x00000008
#define CFM_PROTECTED	0x00000010
#define CFM_LINK		0x00000020			// Exchange hyperlink extension 
#define CFM_SIZE		0x80000000
#define CFM_COLOR		0x40000000
#define CFM_FACE		0x20000000
#define CFM_OFFSET		0x10000000
#define CFM_CHARSET		0x08000000

// CHARFORMAT effects 
#define CFE_BOLD		0x0001
#define CFE_ITALIC		0x0002
#define CFE_UNDERLINE	0x0004
#define CFE_STRIKEOUT	0x0008
#define CFE_PROTECTED	0x0010
#define CFE_LINK		0x0020
#define CFE_AUTOCOLOR	0x40000000			// NOTE: this corresponds to 
											// CFM_COLOR, which controls it 
// Masks and effects defined for CHARFORMAT2 -- an (*) indicates
// that the data is stored by RichEdit 2.0/3.0, but not displayed
#define CFM_SMALLCAPS		0x0040			// (*)	
#define	CFM_ALLCAPS			0x0080			// Displayed by 3.0	
#define	CFM_HIDDEN			0x0100			// Hidden by 3.0 
#define	CFM_OUTLINE			0x0200			// (*)	
#define	CFM_SHADOW			0x0400			// (*)	
#define	CFM_EMBOSS			0x0800			// (*)	
#define	CFM_IMPRINT			0x1000			// (*)	
#define CFM_DISABLED		0x2000
#define	CFM_REVISED			0x4000

#define CFM_BACKCOLOR		0x04000000
#define CFM_LCID			0x02000000
#define	CFM_UNDERLINETYPE	0x00800000		// Many displayed by 3.0 
#define	CFM_WEIGHT			0x00400000
#define CFM_SPACING			0x00200000		// Displayed by 3.0	
#define CFM_KERNING			0x00100000		// (*)	
#define CFM_STYLE			0x00080000		// (*)	
#define CFM_ANIMATION		0x00040000		// (*)	
#define CFM_REVAUTHOR		0x00008000

#define CFE_SUBSCRIPT		0x00010000		// Superscript and subscript are 
#define CFE_SUPERSCRIPT		0x00020000		//  mutually exclusive			 

#define CFM_SUBSCRIPT		(CFE_SUBSCRIPT | CFE_SUPERSCRIPT)
#define CFM_SUPERSCRIPT		CFM_SUBSCRIPT

// CHARFORMAT "ALL" masks
#define CFM_EFFECTS (CFM_BOLD | CFM_ITALIC | CFM_UNDERLINE | CFM_COLOR | \
					 CFM_STRIKEOUT | CFE_PROTECTED | CFM_LINK)
#define CFM_ALL (CFM_EFFECTS | CFM_SIZE | CFM_FACE | CFM_OFFSET | CFM_CHARSET)

#define	CFM_EFFECTS2 (CFM_EFFECTS | CFM_DISABLED | CFM_SMALLCAPS | CFM_ALLCAPS \
					| CFM_HIDDEN  | CFM_OUTLINE | CFM_SHADOW | CFM_EMBOSS \
					| CFM_IMPRINT | CFM_DISABLED | CFM_REVISED \
					| CFM_SUBSCRIPT | CFM_SUPERSCRIPT | CFM_BACKCOLOR)

#define CFM_ALL2	 (CFM_ALL | CFM_EFFECTS2 | CFM_BACKCOLOR | CFM_LCID \
					| CFM_UNDERLINETYPE | CFM_WEIGHT | CFM_REVAUTHOR \
					| CFM_SPACING | CFM_KERNING | CFM_STYLE | CFM_ANIMATION)

#define	CFE_SMALLCAPS		CFM_SMALLCAPS
#define	CFE_ALLCAPS			CFM_ALLCAPS
#define	CFE_HIDDEN			CFM_HIDDEN
#define	CFE_OUTLINE			CFM_OUTLINE
#define	CFE_SHADOW			CFM_SHADOW
#define	CFE_EMBOSS			CFM_EMBOSS
#define	CFE_IMPRINT			CFM_IMPRINT
#define	CFE_DISABLED		CFM_DISABLED
#define	CFE_REVISED			CFM_REVISED

// CFE_AUTOCOLOR and CFE_AUTOBACKCOLOR correspond to CFM_COLOR and
// CFM_BACKCOLOR, respectively, which control them
#define CFE_AUTOBACKCOLOR	CFM_BACKCOLOR

// Underline types. RE 1.0 displays only CFU_UNDERLINE
#define CFU_CF1UNDERLINE	0xFF	// Map charformat's bit underline to CF2
#define CFU_INVERT			0xFE	// For IME composition fake a selection
#define CFU_UNDERLINETHICKLONGDASH		18	// (*) display as dash
#define CFU_UNDERLINETHICKDOTTED		17	// (*) display as dot
#define CFU_UNDERLINETHICKDASHDOTDOT	16	// (*) display as dash dot dot
#define CFU_UNDERLINETHICKDASHDOT		15	// (*) display as dash dot
#define CFU_UNDERLINETHICKDASH			14	// (*) display as dash
#define CFU_UNDERLINELONGDASH			13	// (*) display as dash
#define CFU_UNDERLINEHEAVYWAVE			12	// (*) display as wave
#define CFU_UNDERLINEDOUBLEWAVE			11	// (*) display as wave
#define CFU_UNDERLINEHAIRLINE			10	// (*) display as single	
#define CFU_UNDERLINETHICK				9
#define CFU_UNDERLINEWAVE				8
#define	CFU_UNDERLINEDASHDOTDOT			7
#define	CFU_UNDERLINEDASHDOT			6
#define	CFU_UNDERLINEDASH				5
#define	CFU_UNDERLINEDOTTED				4
#define	CFU_UNDERLINEDOUBLE				3	// (*) display as single
#define CFU_UNDERLINEWORD				2	// (*) display as single	
#define CFU_UNDERLINE					1
#define CFU_UNDERLINENONE				0

#define yHeightCharPtsMost 1638

// EM_SETCHARFORMAT wParam masks 
#define SCF_SELECTION		0x0001
#define SCF_WORD			0x0002
#define SCF_DEFAULT			0x0000	// Set default charformat or paraformat
#define SCF_ALL				0x0004	// Not valid with SCF_SELECTION or SCF_WORD
#define SCF_USEUIRULES		0x0008	// Modifier for SCF_SELECTION; says that
									//  format came from a toolbar, etc., and
									//  hence UI formatting rules should be
									//  used instead of literal formatting
#define SCF_ASSOCIATEFONT	0x0010	// Associate fontname with bCharSet (one
									//  possible for each of Western, ME, FE,
									//  Thai)
#define SCF_NOKBUPDATE		0x0020	// Do not update KB layput for this change
									//  even if autokeyboard is on
#define SCF_ASSOCIATEFONT2	0x0040	// Associate plane-2 (surrogate) font

typedef struct _charrange
{
	LONG	cpMin;
	LONG	cpMax;
} CHARRANGE;

typedef struct _textrange
{
	CHARRANGE chrg;
	LPSTR lpstrText;	// Allocated by caller, zero terminated by RichEdit 
} TEXTRANGEA;

typedef struct _textrangew
{
	CHARRANGE chrg;
	LPWSTR lpstrText;	// Allocated by caller, zero terminated by RichEdit 
} TEXTRANGEW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define TEXTRANGE 	TEXTRANGEW
#else
#define TEXTRANGE	TEXTRANGEA
#endif // UNICODE 
#else
#define TEXTRANGE	TEXTRANGEA
#endif // _RICHEDIT_VER >= 0x0200 

typedef DWORD (CALLBACK *EDITSTREAMCALLBACK)(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb);

typedef struct _editstream
{
	DWORD_PTR dwCookie;		// User value passed to callback as first parameter 
	DWORD	  dwError;		// Last error 
	EDITSTREAMCALLBACK pfnCallback;
} EDITSTREAM;

// Stream formats. Flags are all in low word, since high word
// gives possible codepage choice. 
#define SF_TEXT			0x0001
#define SF_RTF			0x0002
#define SF_RTFNOOBJS	0x0003		// Write only 
#define SF_TEXTIZED		0x0004		// Write only 

#define SF_UNICODE		0x0010		// Unicode file (UCS2 little endian) 
#define SF_USECODEPAGE	0x0020		// CodePage given by high word 
#define SF_NCRFORNONASCII 0x40		// Output /uN for nonASCII 
#define	SFF_WRITEXTRAPAR  0x80		// Output \par at end

// Flag telling stream operations to operate on selection only 
// EM_STREAMIN  replaces current selection 
// EM_STREAMOUT streams out current selection 
#define SFF_SELECTION	0x8000

// Flag telling stream operations to ignore some FE control words 
// having to do with FE word breaking and horiz vs vertical text. 
// Not used in RichEdit 2.0 and later	
#define SFF_PLAINRTF	0x4000

// Flag telling file stream output (SFF_SELECTION flag not set) to persist 
// \viewscaleN control word. 
#define SFF_PERSISTVIEWSCALE 0x2000

// Flag telling file stream input with SFF_SELECTION flag not set not to 
// close the document 
#define SFF_KEEPDOCINFO	0x1000

// Flag telling stream operations to output in Pocket Word format 
#define SFF_PWD			0x0800

// 3-bit field specifying the value of N - 1 to use for \rtfN or \pwdN 
#define SF_RTFVAL		0x0700

typedef struct _findtext
{
	CHARRANGE chrg;
	LPCSTR lpstrText;
} FINDTEXTA;

typedef struct _findtextw
{
	CHARRANGE chrg;
	LPCWSTR lpstrText;
} FINDTEXTW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define FINDTEXT	FINDTEXTW
#else
#define FINDTEXT	FINDTEXTA
#endif	// UNICODE 
#else
#define FINDTEXT	FINDTEXTA
#endif // _RICHEDIT_VER >= 0x0200 

typedef struct _findtextexa
{
	CHARRANGE chrg;
	LPCSTR	  lpstrText;
	CHARRANGE chrgText;
} FINDTEXTEXA;

typedef struct _findtextexw
{
	CHARRANGE chrg;
	LPCWSTR	  lpstrText;
	CHARRANGE chrgText;
} FINDTEXTEXW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define FINDTEXTEX	FINDTEXTEXW
#else
#define FINDTEXTEX	FINDTEXTEXA
#endif // UNICODE 
#else
#define FINDTEXTEX	FINDTEXTEXA
#endif // _RICHEDIT_VER >= 0x0200 


typedef struct _formatrange
{
	HDC hdc;
	HDC hdcTarget;
	RECT rc;
	RECT rcPage;
	CHARRANGE chrg;
} FORMATRANGE;

// All paragraph measurements are in twips 

#define MAX_TAB_STOPS 32
#define lDefaultTab 720
#define MAX_TABLE_CELLS 63

typedef struct _paraformat
{
	UINT	cbSize;
	DWORD	dwMask;
	WORD	wNumbering;
	WORD	wEffects;
	LONG	dxStartIndent;
	LONG	dxRightIndent;
	LONG	dxOffset;
	WORD	wAlignment;
	SHORT	cTabCount;
	LONG	rgxTabs[MAX_TAB_STOPS];
} PARAFORMAT;

#ifdef __cplusplus
struct PARAFORMAT2 : _paraformat
{
	LONG	dySpaceBefore;			// Vertical spacing before para
	LONG	dySpaceAfter;			// Vertical spacing after para
	LONG	dyLineSpacing;			// Line spacing depending on Rule
	SHORT	sStyle;					// Style handle
	BYTE	bLineSpacingRule;		// Rule for line spacing (see tom.doc)
	BYTE	bOutlineLevel;			// Outline level
	WORD	wShadingWeight;			// Shading in hundredths of a per cent
	WORD	wShadingStyle;			// Nibble 0: style, 1: cfpat, 2: cbpat
	WORD	wNumberingStart;		// Starting value for numbering
	WORD	wNumberingStyle;		// Alignment, roman/arabic, (), ), ., etc.
	WORD	wNumberingTab;			// Space bet FirstIndent & 1st-line text
	WORD	wBorderSpace;			// Border-text spaces (nbl/bdr in pts)
	WORD	wBorderWidth;			// Pen widths (nbl/bdr in half pts)
	WORD	wBorders;				// Border styles (nibble/border)
};

#else	// Regular C-style	

typedef struct _paraformat2
{
	UINT	cbSize;
	DWORD	dwMask;
	WORD	wNumbering;
	WORD	wReserved;
	LONG	dxStartIndent;
	LONG	dxRightIndent;
	LONG	dxOffset;
	WORD	wAlignment;
	SHORT	cTabCount;
	LONG	rgxTabs[MAX_TAB_STOPS];
 	LONG	dySpaceBefore;			// Vertical spacing before para			
	LONG	dySpaceAfter;			// Vertical spacing after para			
	LONG	dyLineSpacing;			// Line spacing depending on Rule		
	SHORT	sStyle;					// Style handle							
	BYTE	bLineSpacingRule;		// Rule for line spacing (see tom.doc)	
	BYTE	bOutlineLevel;			// Outline Level						
	WORD	wShadingWeight;			// Shading in hundredths of a per cent	
	WORD	wShadingStyle;			// Byte 0: style, nib 2: cfpat, 3: cbpat
	WORD	wNumberingStart;		// Starting value for numbering				
	WORD	wNumberingStyle;		// Alignment, Roman/Arabic, (), ), ., etc.
	WORD	wNumberingTab;			// Space bet 1st indent and 1st-line text
	WORD	wBorderSpace;			// Border-text spaces (nbl/bdr in pts)	
	WORD	wBorderWidth;			// Pen widths (nbl/bdr in half twips)	
	WORD	wBorders;				// Border styles (nibble/border)		
} PARAFORMAT2;

#endif // C++	


// PARAFORMAT mask values 
#define PFM_STARTINDENT			0x00000001
#define PFM_RIGHTINDENT			0x00000002
#define PFM_OFFSET				0x00000004
#define PFM_ALIGNMENT			0x00000008
#define PFM_TABSTOPS			0x00000010
#define PFM_NUMBERING			0x00000020
#define PFM_OFFSETINDENT		0x80000000

// PARAFORMAT 2.0 masks and effects 
#define PFM_SPACEBEFORE			0x00000040
#define PFM_SPACEAFTER			0x00000080
#define PFM_LINESPACING			0x00000100
#define	PFM_STYLE				0x00000400
#define PFM_BORDER				0x00000800	// (*)	
#define PFM_SHADING				0x00001000	// (*)	
#define PFM_NUMBERINGSTYLE		0x00002000	// RE 3.0	
#define PFM_NUMBERINGTAB		0x00004000	// RE 3.0	
#define PFM_NUMBERINGSTART		0x00008000	// RE 3.0	

#define PFM_RTLPARA				0x00010000
#define PFM_KEEP				0x00020000	// (*)	
#define PFM_KEEPNEXT			0x00040000	// (*)	
#define PFM_PAGEBREAKBEFORE		0x00080000	// (*)	
#define PFM_NOLINENUMBER		0x00100000	// (*)	
#define PFM_NOWIDOWCONTROL		0x00200000	// (*)	
#define PFM_DONOTHYPHEN			0x00400000	// (*)	
#define PFM_SIDEBYSIDE			0x00800000	// (*)	
#define PFM_TABLE				0x40000000	// RE 3.0 
#define PFM_TEXTWRAPPINGBREAK	0x20000000	// RE 3.0 
#define PFM_TABLEROWDELIMITER	0x10000000	// RE 4.0 

// The following three properties are read only
#define PFM_COLLAPSED			0x01000000	// RE 3.0 
#define PFM_OUTLINELEVEL		0x02000000	// RE 3.0 
#define PFM_BOX					0x04000000	// RE 3.0 
#define PFM_RESERVED2			0x08000000	// RE 4.0 


// PARAFORMAT "ALL" masks
#define	PFM_ALL (PFM_STARTINDENT | PFM_RIGHTINDENT | PFM_OFFSET	| \
				 PFM_ALIGNMENT   | PFM_TABSTOPS    | PFM_NUMBERING | \
				 PFM_OFFSETINDENT| PFM_RTLPARA)

// Note: PARAFORMAT has no effects (BiDi RichEdit 1.0 does have PFE_RTLPARA)
#define PFM_EFFECTS (PFM_RTLPARA | PFM_KEEP | PFM_KEEPNEXT | PFM_TABLE \
					| PFM_PAGEBREAKBEFORE | PFM_NOLINENUMBER  \
					| PFM_NOWIDOWCONTROL | PFM_DONOTHYPHEN | PFM_SIDEBYSIDE \
					| PFM_TABLE | PFM_TABLEROWDELIMITER)

#define PFM_ALL2	(PFM_ALL | PFM_EFFECTS | PFM_SPACEBEFORE | PFM_SPACEAFTER \
					| PFM_LINESPACING | PFM_STYLE | PFM_SHADING | PFM_BORDER \
					| PFM_NUMBERINGTAB | PFM_NUMBERINGSTART | PFM_NUMBERINGSTYLE)

#define PFE_RTLPARA				(PFM_RTLPARA		 >> 16)
#define PFE_KEEP				(PFM_KEEP			 >> 16)	// (*)	
#define PFE_KEEPNEXT			(PFM_KEEPNEXT		 >> 16)	// (*)	
#define PFE_PAGEBREAKBEFORE		(PFM_PAGEBREAKBEFORE >> 16)	// (*)	
#define PFE_NOLINENUMBER		(PFM_NOLINENUMBER	 >> 16)	// (*)	
#define PFE_NOWIDOWCONTROL		(PFM_NOWIDOWCONTROL	 >> 16)	// (*)	
#define PFE_DONOTHYPHEN			(PFM_DONOTHYPHEN 	 >> 16)	// (*)	
#define PFE_SIDEBYSIDE			(PFM_SIDEBYSIDE		 >> 16)	// (*)	
#define PFE_TEXTWRAPPINGBREAK	(PFM_TEXTWRAPPINGBREAK>>16) // (*)	

// The following four effects are read only
#define PFE_COLLAPSED			(PFM_COLLAPSED		 >> 16)	// (+)	
#define PFE_BOX					(PFM_BOX			 >> 16)	// (+)	
#define PFE_TABLE				(PFM_TABLE			 >> 16)	// Inside table row. RE 3.0 
#define PFE_TABLEROWDELIMITER	(PFM_TABLEROWDELIMITER>>16)	// Table row start. RE 4.0 

// PARAFORMAT numbering options 
#define PFN_BULLET		1		// tomListBullet

// PARAFORMAT2 wNumbering options 
#define PFN_ARABIC		2		// tomListNumberAsArabic:   0, 1, 2,	...
#define PFN_LCLETTER	3		// tomListNumberAsLCLetter: a, b, c,	...
#define	PFN_UCLETTER	4		// tomListNumberAsUCLetter: A, B, C,	...
#define	PFN_LCROMAN		5		// tomListNumberAsLCRoman:  i, ii, iii,	...
#define	PFN_UCROMAN		6		// tomListNumberAsUCRoman:  I, II, III,	...

// PARAFORMAT2 wNumberingStyle options 
#define PFNS_PAREN		0x000	// default, e.g.,				  1)	
#define	PFNS_PARENS		0x100	// tomListParentheses/256, e.g., (1)	
#define PFNS_PERIOD		0x200	// tomListPeriod/256, e.g.,		  1.	
#define PFNS_PLAIN		0x300	// tomListPlain/256, e.g.,		  1		
#define PFNS_NONUMBER	0x400	// Used for continuation w/o number

#define PFNS_NEWNUMBER	0x8000	// Start new number with wNumberingStart		
								// (can be combined with other PFNS_xxx)
// PARAFORMAT alignment options 
#define PFA_LEFT			 1
#define PFA_RIGHT			 2
#define PFA_CENTER			 3

// PARAFORMAT2 alignment options 
#define	PFA_JUSTIFY			 4	// New paragraph-alignment option 2.0 (*) 
#define PFA_FULL_INTERWORD	 4	// These are supported in 3.0 with advanced
#define PFA_FULL_INTERLETTER 5	//  typography enabled
#define PFA_FULL_SCALED		 6
#define	PFA_FULL_GLYPHS		 7
#define	PFA_SNAP_GRID		 8


// Notification structures 
#ifndef WM_NOTIFY
#define WM_NOTIFY		0x004E

typedef struct _nmhdr
{
	HWND	hwndFrom;
	UINT	idFrom;
	UINT	code;
} NMHDR;
#endif  // !WM_NOTIFY 

typedef struct _msgfilter
{
	NMHDR	nmhdr;
	UINT	msg;
	WPARAM	wParam;
	LPARAM	lParam;
} MSGFILTER;

typedef struct _reqresize
{
	NMHDR nmhdr;
	RECT rc;
} REQRESIZE;

typedef struct _selchange
{
	NMHDR nmhdr;
	CHARRANGE chrg;
	WORD seltyp;
} SELCHANGE;


#define SEL_EMPTY		0x0000
#define SEL_TEXT		0x0001
#define SEL_OBJECT		0x0002
#define SEL_MULTICHAR	0x0004
#define SEL_MULTIOBJECT	0x0008

// Used with IRichEditOleCallback::GetContextMenu, this flag will be
// passed as a "selection type".  It indicates that a context menu for
// a right-mouse drag drop should be generated.  The IOleObject parameter
// will really be the IDataObject for the drop
#define GCM_RIGHTMOUSEDROP  0x8000

typedef struct _endropfiles
{
	NMHDR nmhdr;
	HANDLE hDrop;
	LONG cp;
	BOOL fProtected;
} ENDROPFILES;

typedef struct _enprotected
{
	NMHDR nmhdr;
	UINT msg;
	WPARAM wParam;
	LPARAM lParam;
	CHARRANGE chrg;
} ENPROTECTED;

typedef struct _ensaveclipboard
{
	NMHDR nmhdr;
	LONG cObjectCount;
    LONG cch;
} ENSAVECLIPBOARD;

#ifndef MACPORT
typedef struct _enoleopfailed
{
	NMHDR nmhdr;
	LONG iob;
	LONG lOper;
	HRESULT hr;
} ENOLEOPFAILED;
#endif

#define	OLEOP_DOVERB	1

typedef struct _objectpositions
{
    NMHDR nmhdr;
    LONG cObjectCount;
    LONG *pcpPositions;
} OBJECTPOSITIONS;

typedef struct _enlink
{
    NMHDR nmhdr;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    CHARRANGE chrg;
} ENLINK;

typedef struct _enlowfirtf
{
    NMHDR nmhdr;
	char *szControl;
} ENLOWFIRTF;

// PenWin specific 
typedef struct _encorrecttext
{
	NMHDR nmhdr;
	CHARRANGE chrg;
	WORD seltyp;
} ENCORRECTTEXT;

// East Asia specific 
typedef struct _punctuation
{
	UINT	iSize;
	LPSTR	szPunctuation;
} PUNCTUATION;

// East Asia specific 
typedef struct _compcolor
{
	COLORREF crText;
	COLORREF crBackground;
	DWORD dwEffects;
}COMPCOLOR;


// Clipboard formats - use as parameter to RegisterClipboardFormat() 
#define CF_RTF 			TEXT("Rich Text Format")
#define CF_RTFNOOBJS 	TEXT("Rich Text Format Without Objects")
#define CF_RETEXTOBJ 	TEXT("RichEdit Text and Objects")

// Paste Special 
typedef struct _repastespecial
{
	DWORD		dwAspect;
	DWORD_PTR	dwParam;
} REPASTESPECIAL;

//	UndoName info 
typedef enum _undonameid
{
    UID_UNKNOWN     = 0,
	UID_TYPING		= 1,
	UID_DELETE 		= 2,
	UID_DRAGDROP	= 3,
	UID_CUT			= 4,
	UID_PASTE		= 5,
	UID_AUTOCORRECT = 6
} UNDONAMEID;

// Flags for the SETEXTEX data structure 
#define ST_DEFAULT		0
#define ST_KEEPUNDO		1
#define ST_SELECTION	2
#define ST_NEWCHARS 	4

// EM_SETTEXTEX info; this struct is passed in the wparam of the message 
typedef struct _settextex
{
	DWORD	flags;			// Flags (see the ST_XXX defines)			
	UINT	codepage;		// Code page for translation (CP_ACP for sys default,
						    //  1200 for Unicode, -1 for control default)	
} SETTEXTEX;

// Flags for the GETEXTEX data structure 
#define GT_DEFAULT		0
#define GT_USECRLF		1
#define GT_SELECTION	2
#define GT_RAWTEXT		4
#define GT_NOHIDDENTEXT	8

// EM_GETTEXTEX info; this struct is passed in the wparam of the message 
typedef struct _gettextex
{
	DWORD	cb;				// Count of bytes in the string				
	DWORD	flags;			// Flags (see the GT_XXX defines			
	UINT	codepage;		// Code page for translation (CP_ACP for sys default,
						    //  1200 for Unicode, -1 for control default)	
	LPCSTR	lpDefaultChar;	// Replacement for unmappable chars			
	LPBOOL	lpUsedDefChar;	// Pointer to flag set when def char used	
} GETTEXTEX;

// Flags for the GETTEXTLENGTHEX data structure							
#define GTL_DEFAULT		0	// Do default (return # of chars)		
#define GTL_USECRLF		1	// Compute answer using CRLFs for paragraphs
#define GTL_PRECISE		2	// Compute a precise answer					
#define GTL_CLOSE		4	// Fast computation of a "close" answer		
#define GTL_NUMCHARS	8	// Return number of characters			
#define GTL_NUMBYTES	16	// Return number of _bytes_				

// EM_GETTEXTLENGTHEX info; this struct is passed in the wparam of the msg 
typedef struct _gettextlengthex
{
	DWORD	flags;			// Flags (see GTL_XXX defines)				
	UINT	codepage;		// Code page for translation (CP_ACP for default,
							//  1200 for Unicode)							
} GETTEXTLENGTHEX;
	
// BiDi specific features 
typedef struct _bidioptions
{
	UINT	cbSize;
	WORD	wMask;
	WORD	wEffects; 
} BIDIOPTIONS;

// BIDIOPTIONS masks 
#if (_RICHEDIT_VER == 0x0100)
#define BOM_DEFPARADIR			0x0001	// Default paragraph direction (implies alignment) (obsolete) 
#define BOM_PLAINTEXT			0x0002	// Use plain text layout (obsolete) 
#endif // _RICHEDIT_VER == 0x0100 
#define BOM_NEUTRALOVERRIDE		0x0004	// Override neutral layout (obsolete) 
#define BOM_CONTEXTREADING		0x0008	// Context reading order 
#define BOM_CONTEXTALIGNMENT	0x0010	// Context alignment 
#define BOM_LEGACYBIDICLASS		0x0040	// Legacy Bidi classification 

// BIDIOPTIONS effects 
#if (_RICHEDIT_VER == 0x0100)
#define BOE_RTLDIR				0x0001	// Default paragraph direction (implies alignment) (obsolete) 
#define BOE_PLAINTEXT			0x0002	// Use plain text layout (obsolete) 
#endif // _RICHEDIT_VER == 0x0100 
#define BOE_NEUTRALOVERRIDE		0x0004	// Override neutral layout (obsolete) 
#define BOE_CONTEXTREADING		0x0008	// Context reading order 
#define BOE_CONTEXTALIGNMENT	0x0010	// Context alignment 
#define BOE_LEGACYBIDICLASS		0x0040	// Legacy Bidi classification 

// Additional EM_FINDTEXT[EX] flags 
#define FR_MATCHDIAC                    0x20000000
#define FR_MATCHKASHIDA                 0x40000000
#define FR_MATCHALEFHAMZA               0x80000000
	
// UNICODE embedding character 
#ifndef WCH_EMBEDDING
#define WCH_EMBEDDING (WCHAR)0xFFFC
#endif // WCH_EMBEDDING 
		
// khyph - Kind of hyphenation
typedef enum tagKHYPH
{
	khyphNil,				// No Hyphenation
	khyphNormal,			// Normal Hyphenation
	khyphAddBefore,			// Add letter before hyphen
	khyphChangeBefore,		// Change letter before hyphen
	khyphDeleteBefore,		// Delete letter before hyphen
	khyphChangeAfter,		// Change letter after hyphen
	khyphDelAndChange		// Delete letter before hyphen and change
							//  letter preceding hyphen
} KHYPH;

typedef struct hyphresult
{
	KHYPH khyph;			// Kind of hyphenation
	long  ichHyph;			// Character which was hyphenated
	WCHAR chHyph;			// Depending on hyphenation type, character added, changed, etc.
} HYPHRESULT;

void WINAPI HyphenateProc(__in WCHAR *pszWord, LANGID langid, long ichExceed, HYPHRESULT *phyphresult);
typedef struct tagHyphenateInfo
{
	SHORT cbSize;			// Size of HYPHENATEINFO structure
	SHORT dxHyphenateZone;	// If a space character is closer to the margin
							//  than this value, don't hyphenate (in TWIPs)
	void (WINAPI* pfnHyphenate)(WCHAR*, LANGID, long, HYPHRESULT*);
} HYPHENATEINFO;

#ifdef _WIN32
#include <poppack.h>
#elif !defined(RC_INVOKED)
#pragma pack()
#endif

#ifdef __cplusplus
}
#endif  // __cplusplus 

#endif // !_RICHEDIT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Resapi.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    resapi.h

Abstract:

    This module defines the interface exported by Windows Clusters resources.

Revision History:

--*/

#ifndef _RESAPI_DEFINES_
#define _RESAPI_DEFINES_

#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#include <winsvc.h>
#include <clusapi.h>
#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif

#define IN
#define OUT

//
// Definitions for entrypoints exported by a resource DLL.
//
#define STARTUP_ROUTINE "Startup"

#define CLRES_V1_FUNCTION_SIZE   sizeof(CLRES_V1_FUNCTIONS)
#define CLRES_VERSION_V1_00    0x100

#define CLRES_V1_FUNCTION_TABLE( _Name,                     \
                                 _Version,                  \
                                 _Prefix,                   \
                                 _Arbitrate,                \
                                 _Release,                  \
                                 _ResControl,               \
                                 _ResTypeControl            \
                                 )                          \
CLRES_FUNCTION_TABLE _Name = { CLRES_V1_FUNCTION_SIZE,      \
                               _Version,                    \
                               _Prefix##Open,               \
                               _Prefix##Close,              \
                               _Prefix##Online,             \
                               _Prefix##Offline,            \
                               _Prefix##Terminate,          \
                               _Prefix##LooksAlive,         \
                               _Prefix##IsAlive,            \
                               _Arbitrate,                  \
                               _Release,                    \
                               _ResControl,                 \
                               _ResTypeControl }

#endif // ifndef _RESAPI_DEFINES_

#ifndef _RESAPI_
#define _RESAPI_

//
// Define a RESID
//

typedef PVOID RESID;

//
// Define a RESOURCE_HANDLE
//

typedef HANDLE   RESOURCE_HANDLE;

//
// Define the Resource Status structure.
//

#define ClusterResourceCannotComeOnlineOnThisNode ( CLUSTER_RESOURCE_STATE ) ( ClusterResourcePending - 1 )
#define ClusterResourceCannotComeOnlineOnAnyNode  ( CLUSTER_RESOURCE_STATE ) ( ClusterResourcePending - 2 )

typedef struct RESOURCE_STATUS {
    CLUSTER_RESOURCE_STATE  ResourceState;
    DWORD           CheckPoint;
    DWORD           WaitHint;
    HANDLE          EventHandle;
} RESOURCE_STATUS, *PRESOURCE_STATUS;


#define ResUtilInitializeResourceStatus( _resource_status_ ) \
    ZeroMemory( _resource_status_, sizeof(RESOURCE_STATUS) )

//
// Define Resource DLL callback method for updating the state of a resource.
//

typedef
DWORD
(_stdcall *PSET_RESOURCE_STATUS_ROUTINE) (
    IN RESOURCE_HANDLE ResourceHandle,
    IN PRESOURCE_STATUS ResourceStatus
    );

//
// Define Resource DLL callback method for notifying that a quorum
// resource DLL failed to hold the quorum resource.
//
typedef
VOID
(_stdcall *PQUORUM_RESOURCE_LOST) (
    IN RESOURCE_HANDLE Resource
    );

//
// Define Resource DLL callback method for logging events.
//
typedef enum LOG_LEVEL {
    LOG_INFORMATION,
    LOG_WARNING,
    LOG_ERROR,
    LOG_SEVERE
} LOG_LEVEL, *PLOG_LEVEL;

typedef
VOID
(_stdcall *PLOG_EVENT_ROUTINE) (
    IN RESOURCE_HANDLE ResourceHandle,
    IN LOG_LEVEL LogLevel,
    IN LPCWSTR FormatString,
    ...
    );

typedef
RESID
(_stdcall *POPEN_ROUTINE) (
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    );

typedef
VOID
(_stdcall *PCLOSE_ROUTINE) (
    IN RESID Resource
    );

typedef
DWORD
(_stdcall *PONLINE_ROUTINE) (
    IN RESID Resource,
    IN OUT LPHANDLE EventHandle
    );

typedef
DWORD
(_stdcall *POFFLINE_ROUTINE) (
    IN RESID Resource
    );

typedef
VOID
(_stdcall *PTERMINATE_ROUTINE) (
    IN RESID Resource
    );

typedef
BOOL
(_stdcall *PIS_ALIVE_ROUTINE) (
    IN RESID Resource
    );

typedef
BOOL
(_stdcall *PLOOKS_ALIVE_ROUTINE) (
    IN RESID Resource
    );

typedef
DWORD
(_stdcall *PARBITRATE_ROUTINE) (
    IN RESID Resource,
    IN PQUORUM_RESOURCE_LOST LostQuorumResource
    );

typedef
DWORD
(_stdcall *PRELEASE_ROUTINE) (
    IN RESID Resource
    );

typedef
DWORD
(_stdcall *PRESOURCE_CONTROL_ROUTINE) (
    IN RESID Resource,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

typedef
DWORD
(_stdcall *PRESOURCE_TYPE_CONTROL_ROUTINE) (
    IN LPCWSTR ResourceTypeName,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

typedef enum _RESOURCE_EXIT_STATE {
    ResourceExitStateContinue,
    ResourceExitStateTerminate,
    ResourceExitStateMax
} RESOURCE_EXIT_STATE;


//***************************************************************
//
// Define the Function Table Format
//
//***************************************************************

//
// Version 1 Resource DLL Interface definition
//
typedef struct CLRES_V1_FUNCTIONS {
    POPEN_ROUTINE Open;
    PCLOSE_ROUTINE Close;
    PONLINE_ROUTINE Online;
    POFFLINE_ROUTINE Offline;
    PTERMINATE_ROUTINE Terminate;
    PLOOKS_ALIVE_ROUTINE LooksAlive;
    PIS_ALIVE_ROUTINE IsAlive;
    PARBITRATE_ROUTINE Arbitrate;
    PRELEASE_ROUTINE Release;
    PRESOURCE_CONTROL_ROUTINE ResourceControl;
    PRESOURCE_TYPE_CONTROL_ROUTINE ResourceTypeControl;
} CLRES_V1_FUNCTIONS, *PCLRES_V1_FUNCTIONS;

//
// Resource DLL Function Table definition
//
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union
typedef struct CLRES_FUNCTION_TABLE {
    DWORD   TableSize;
    DWORD   Version;
    union {
        CLRES_V1_FUNCTIONS V1Functions;
    } DUMMYUNIONNAME;
} CLRES_FUNCTION_TABLE, *PCLRES_FUNCTION_TABLE;
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default : 4201 ) // nonstandard extension used : nameless struct/union
#endif

//
// Define the Resource DLL Startup routine. This is the only routine
// that should be exported from a resource DLL.
//

//
// Calculate the byte offset of a field in a structure of type type.
//

#ifndef FIELD_OFFSET
#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
#endif

//
// large ints need more space than what was originally allocated.
//
typedef struct RESUTIL_LARGEINT_DATA {
    LARGE_INTEGER   Default;
    LARGE_INTEGER   Minimum;
    LARGE_INTEGER   Maximum;
} RESUTIL_LARGEINT_DATA, *PRESUTIL_LARGEINT_DATA;

typedef struct RESUTIL_ULARGEINT_DATA {
    ULARGE_INTEGER  Default;
    ULARGE_INTEGER  Minimum;
    ULARGE_INTEGER  Maximum;
} RESUTIL_ULARGEINT_DATA, *PRESUTIL_ULARGEINT_DATA;

typedef struct RESUTIL_FILETIME_DATA {
    FILETIME  Default;
    FILETIME  Minimum;
    FILETIME  Maximum;
} RESUTIL_FILETIME_DATA, *PRESUTIL_FILETIME_DATA;

//
// Property list structures and functions
//
typedef struct RESUTIL_PROPERTY_ITEM {
    LPWSTR  Name;               // Property name
    LPWSTR  KeyName;            // Name of value in cluster database
    DWORD   Format;             // Format: REG_SZ, REG_DWORD, etc.
    union {
        DWORD_PTR               DefaultPtr;
        DWORD                   Default;     // Default value
        LPVOID                  lpDefault;
        PRESUTIL_LARGEINT_DATA  LargeIntData;
        PRESUTIL_ULARGEINT_DATA ULargeIntData;
        PRESUTIL_FILETIME_DATA  FileTimeData;
    } DUMMYUNIONNAME;
    DWORD   Minimum;            // Minimum value
    DWORD   Maximum;            // Maximum value
    DWORD   Flags;              // Flags for this item
#define RESUTIL_PROPITEM_READ_ONLY  0x00000001  // Property is read-only
#define RESUTIL_PROPITEM_REQUIRED   0x00000002  // Property is required
#define RESUTIL_PROPITEM_SIGNED     0x00000004  // Numeric property is signed (defaults to unsigned)

    DWORD   Offset;             // Byte offset to value in parameter block
                                //   Assumes MULTI_SZ and BINARY parameters
                                //   are LPWSTRs followed by DWORDs for length
} RESUTIL_PROPERTY_ITEM, *PRESUTIL_PROPERTY_ITEM;


typedef
DWORD
(_stdcall *PSTARTUP_ROUTINE) (
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    );

//
// Define layout of shared memory used for tracking Resource Monitor state.
//
typedef enum RESOURCE_MONITOR_STATE {
    RmonInitializing,
    RmonIdle,
    RmonStartingResource,
    RmonInitializingResource,
    RmonOnlineResource,
    RmonOfflineResource,
    RmonShutdownResource,
    RmonDeletingResource,
    RmonIsAlivePoll,
    RmonLooksAlivePoll,
    RmonArbitrateResource,
    RmonReleaseResource,
    RmonResourceControl,
    RmonResourceTypeControl,
    RmonTerminateResource,
    RmonDeadlocked
} RESOURCE_MONITOR_STATE;

typedef struct MONITOR_STATE {
    LARGE_INTEGER LastUpdate;
    RESOURCE_MONITOR_STATE State;
    HANDLE ActiveResource;
    BOOL   ResmonStop;
} MONITOR_STATE, *PMONITOR_STATE;


//
// Resource Utility Routines
//

DWORD
WINAPI
ResUtilStartResourceService(
    IN LPCWSTR pszServiceName,
    OUT LPSC_HANDLE phServiceHandle
    );

typedef DWORD
(WINAPI * PRESUTIL_START_RESOURCE_SERVICE)(
    IN LPCWSTR pszServiceName,
    OUT LPSC_HANDLE phServiceHandle
    );

DWORD
WINAPI
ResUtilVerifyResourceService(
    IN LPCWSTR pszServiceName
    );

typedef DWORD
(WINAPI * PRESUTIL_VERIFY_RESOURCE_SERVICE)(
    IN LPCWSTR pszServiceName
    );

DWORD
WINAPI
ResUtilStopResourceService(
    IN LPCWSTR pszServiceName
    );

typedef DWORD
(WINAPI * PRESUTIL_STOP_RESOURCE_SERVICE)(
    IN LPCWSTR pszServiceName
    );

DWORD
WINAPI
ResUtilVerifyService(
    IN SC_HANDLE hServiceHandle
    );

typedef DWORD
(WINAPI * PRESUTIL_VERIFY_SERVICE)(
    IN SC_HANDLE hServiceHandle
    );

DWORD
WINAPI
ResUtilStopService(
    IN SC_HANDLE hServiceHandle
    );

typedef DWORD
(WINAPI * PRESUTIL_STOP_SERVICE)(
    IN SC_HANDLE hServiceHandle
    );

DWORD
WINAPI
ResUtilCreateDirectoryTree(
    IN LPCWSTR pszPath
    );

typedef DWORD
(WINAPI * PRESUTIL_CREATE_DIRECTORY_TREE)(
    IN LPCWSTR pszPath
    );

BOOL
WINAPI
ResUtilIsPathValid(
    IN LPCWSTR pszPath
    );

typedef BOOL
(WINAPI * PRESUTIL_IS_PATH_VALID)(
    IN LPCWSTR pszPath
    );

DWORD
WINAPI
ResUtilEnumProperties(
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out_bcount_part(cbOutPropertiesSize, *pcbBytesReturned) LPWSTR pszOutProperties,
    __in DWORD cbOutPropertiesSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

typedef DWORD
(WINAPI * PRESUTIL_ENUM_PROPERTIES)(
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out_bcount_part(cbOutPropertiesSize, *pcbBytesReturned) LPWSTR pszOutProperties,
    __in DWORD cbOutPropertiesSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilEnumPrivateProperties(
    __in HKEY hkeyClusterKey,
    __out_bcount_part(cbOutPropertiesSize, *pcbBytesReturned) LPWSTR pszOutProperties,
    __in DWORD cbOutPropertiesSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

typedef DWORD
(WINAPI * PRESUTIL_ENUM_PRIVATE_PROPERTIES)(
    __in HKEY hkeyClusterKey,
    __out_bcount_part(cbOutPropertiesSize, *pcbBytesReturned) LPWSTR pszOutProperties,
    __in DWORD cbOutPropertiesSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilGetProperties(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out_bcount_part(cbOutPropertyListSize, *pcbBytesReturned) PVOID pOutPropertyList,
    __in DWORD cbOutPropertyListSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_PROPERTIES)(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out_bcount_part(cbOutPropertyListSize, *pcbBytesReturned) PVOID pOutPropertyList,
    __in DWORD cbOutPropertyListSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilGetAllProperties(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out_bcount_part(cbOutPropertyListSize, *pcbBytesReturned) PVOID pOutPropertyList,
    __in DWORD cbOutPropertyListSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_ALL_PROPERTIES)(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out_bcount_part(cbOutPropertyListSize, *pcbBytesReturned) PVOID pOutPropertyList,
    __in DWORD cbOutPropertyListSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilGetPrivateProperties(
    __in HKEY hkeyClusterKey,
    __out_bcount_part(cbOutPropertyListSize, *pcbBytesReturned) PVOID pOutPropertyList,
    __in DWORD cbOutPropertyListSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_PRIVATE_PROPERTIES)(
    __in HKEY hkeyClusterKey,
    __out_bcount_part(cbOutPropertyListSize, *pcbBytesReturned) PVOID pOutPropertyList,
    __in DWORD cbOutPropertyListSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilGetPropertySize(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pnPropertyCount
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_PROPERTY_SIZE)(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    IN OUT LPDWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pnPropertyCount
    );

__success( return == ERROR_SUCCESS )
DWORD
WINAPI
ResUtilGetProperty(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    __deref_inout_bcount_part(*pcbOutPropertyItemSize, *pcbOutPropertyItemSize) PVOID *pOutPropertyItem,
    __inout LPDWORD pcbOutPropertyItemSize
    );

typedef
__success( return == ERROR_SUCCESS )
DWORD
(WINAPI * PRESUTIL_GET_PROPERTY)(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTableItem,
    __deref_inout_bcount_part(*pcbOutPropertyItemSize, *pcbOutPropertyItemSize) PVOID *pOutPropertyItem,
    __inout LPDWORD pcbOutPropertyItemSize
    );

DWORD
WINAPI
ResUtilVerifyPropertyTable(
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __reserved PVOID Reserved,
    __in BOOL bAllowUnknownProperties,
    __in_bcount(cbInPropertyListSize) const PVOID pInPropertyList,
    __in DWORD cbInPropertyListSize,
    __out_opt LPBYTE pOutParams
    );

typedef DWORD
(WINAPI * PRESUTIL_VERIFY_PROPERTY_TABLE)(
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __reserved PVOID Reserved,
    __in BOOL bAllowUnknownProperties,
    __in_bcount(cbInPropertyListSize) const PVOID pInPropertyList,
    __in DWORD cbInPropertyListSize,
    __out_opt LPBYTE pOutParams
    );

DWORD
WINAPI
ResUtilSetPropertyTable(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __reserved PVOID Reserved,
    __in BOOL bAllowUnknownProperties,
    __in_bcount(cbInPropertyListSize) const PVOID pInPropertyList,
    __in DWORD cbInPropertyListSize,
    __out_opt LPBYTE pOutParams
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_PROPERTY_TABLE)(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __reserved PVOID Reserved,
    __in BOOL bAllowUnknownProperties,
    __in_bcount(cbInPropertyListSize) const PVOID pInPropertyList,
    __in DWORD cbInPropertyListSize,
    __out_opt LPBYTE pOutParams
    );

DWORD
WINAPI
ResUtilSetPropertyTableEx(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL LPBYTE pOutParams
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_PROPERTY_TABLE_EX)(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN BOOL bAllowUnknownProperties,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL LPBYTE pOutParams
    );

DWORD
WINAPI
ResUtilSetPropertyParameterBlock(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE pInParams,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    OUT OPTIONAL LPBYTE pOutParams
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_PROPERTY_PARAMETER_BLOCK)(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE pInParams,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    OUT OPTIONAL LPBYTE pOutParams
    );

DWORD
WINAPI
ResUtilSetPropertyParameterBlockEx(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE pInParams,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL LPBYTE pOutParams
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_PROPERTY_PARAMETER_BLOCK_EX)(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN PVOID Reserved,
    IN const LPBYTE pInParams,
    IN const PVOID pInPropertyList,
    IN DWORD cbInPropertyListSize,
    IN BOOL bForceWrite,
    OUT OPTIONAL LPBYTE pOutParams
    );

DWORD
WINAPI
ResUtilSetUnknownProperties(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __in_bcount(cbInPropertyListSize) const PVOID pInPropertyList,
    __in DWORD cbInPropertyListSize
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_UNKNOWN_PROPERTIES)(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __in_bcount(cbInPropertyListSize) const PVOID pInPropertyList,
    __in DWORD cbInPropertyListSize
    );

DWORD
WINAPI
ResUtilGetPropertiesToParameterBlock(
    __in HKEY hkeyClusterKey,
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out LPBYTE pOutParams,
    __in BOOL bCheckForRequiredProperties,
    __deref_out_opt LPWSTR * pszNameOfPropInError
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_PROPERTIES_TO_PARAMETER_BLOCK)(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT LPBYTE pOutParams,
    IN BOOL bCheckForRequiredProperties,
    OUT OPTIONAL LPWSTR * pszNameOfPropInError
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_PROPERTIES_TO_PARAMETER_BLOCK)(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    OUT LPBYTE pOutParams,
    IN BOOL bCheckForRequiredProperties,
    OUT OPTIONAL LPWSTR * pszNameOfPropInError
    );

DWORD
WINAPI
ResUtilPropertyListFromParameterBlock(
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out_bcount_part_opt(*pcbOutPropertyListSize, *pcbBytesReturned ) PVOID  pOutPropertyList,
    __inout LPDWORD pcbOutPropertyListSize,
    __in const LPBYTE pInParams,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

typedef DWORD
(WINAPI * PRESUTIL_PROPERTY_LIST_FROM_PARAMETER_BLOCK)(
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out_bcount_part_opt(*pcbOutPropertyListSize, *pcbBytesReturned ) PVOID  pOutPropertyList,
    __inout LPDWORD pcbOutPropertyListSize,
    __in const LPBYTE pInParams,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilDupParameterBlock(
    OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    );

typedef DWORD
(WINAPI * PRESUTIL_DUP_PARAMETER_BLOCK)(
    OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    );

void
WINAPI
ResUtilFreeParameterBlock(
    IN OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    );

typedef void
(WINAPI * PRESUTIL_FREE_PARAMETER_BLOCK)(
    IN OUT LPBYTE pOutParams,
    IN const LPBYTE pInParams,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable
    );

DWORD
WINAPI
ResUtilAddUnknownProperties(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN OUT PVOID pOutPropertyList,
    IN DWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pcbBytesReturned,
    IN OUT LPDWORD pcbRequired
    );

typedef DWORD
(WINAPI * PRESUTIL_ADD_UNKNOWN_PROPERTIES)(
    IN HKEY hkeyClusterKey,
    IN const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    IN OUT PVOID pOutPropertyList,
    IN DWORD pcbOutPropertyListSize,
    IN OUT LPDWORD pcbBytesReturned,
    IN OUT LPDWORD pcbRequired
    );

DWORD
WINAPI
ResUtilSetPrivatePropertyList(
    __in HKEY hkeyClusterKey,
    __in_bcount(cbInPropertyListSize) const PVOID pInPropertyList,
    __in DWORD cbInPropertyListSize
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_PRIVATE_PROPERTY_LIST)(
    __in HKEY hkeyClusterKey,
    __in_bcount(cbInPropertyListSize) const PVOID pInPropertyList,
    __in DWORD cbInPropertyListSize
    );

DWORD
WINAPI
ResUtilVerifyPrivatePropertyList(
    __in_bcount(cbInPropertyListSize) const PVOID pInPropertyList,
    __in DWORD cbInPropertyListSize
    );

typedef DWORD
(WINAPI * PRESUTIL_VERIFY_PRIVATE_PROPERTY_LIST)(
    __in_bcount(cbInPropertyListSize) const PVOID pInPropertyList,
    __in DWORD cbInPropertyListSize
    );

PWSTR
WINAPI
ResUtilDupString(
    IN LPCWSTR pszInString
    );

typedef PWSTR
(WINAPI * PRESUTIL_DUP_STRING)(
    IN LPCWSTR pszInString
    );

DWORD
WINAPI
ResUtilGetBinaryValue(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __deref_out_bcount_full_opt(*pcbOutValueSize) LPBYTE *ppbOutValue,
    __out LPDWORD pcbOutValueSize
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_BINARY_VALUE)(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __deref_out_bcount_full_opt(*pcbOutValueSize) LPBYTE *ppbOutValue,
    __out LPDWORD pcbOutValueSize
    );

LPWSTR
WINAPI
ResUtilGetSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName
    );

typedef LPWSTR
(WINAPI * PRESUTIL_GET_SZ_VALUE)(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName
    );

LPWSTR
WINAPI
ResUtilGetExpandSzValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN BOOL bExpand
    );

typedef LPWSTR
(WINAPI * PRESUTIL_GET_EXPAND_SZ_VALUE)(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN BOOL bExpand
    );

FORCEINLINE
DWORD
WINAPI_INLINE
ResUtilGetMultiSzValue(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __deref_out_bcount_full_opt(*pcbOutValueSize) LPWSTR *ppszOutValue,
    __out LPDWORD pcbOutValueSize
    )
{
    return ResUtilGetBinaryValue( hkeyClusterKey, pszValueName, (LPBYTE *) ppszOutValue, pcbOutValueSize );
}

DWORD
WINAPI
ResUtilGetDwordValue(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __out LPDWORD pdwOutValue,
    __in DWORD dwDefaultValue
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_DWORD_VALUE)(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __out LPDWORD pdwOutValue,
    __in DWORD dwDefaultValue
    );

DWORD
WINAPI
ResUtilGetQwordValue(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __out PULONGLONG pqwOutValue,
    __in ULONGLONG qwDefaultValue
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_QWORD_VALUE)(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __out PULONGLONG pqwOutValue,
    __in ULONGLONG qwDefaultValue
    );

DWORD
WINAPI
ResUtilSetBinaryValue(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __in_bcount(cbNewValueSize) const LPBYTE pbNewValue,
    __in DWORD cbNewValueSize,
    __deref_opt_inout_bcount_full(*pcbOutValueSize) LPBYTE *ppbOutValue,
    __inout LPDWORD pcbOutValueSize
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_BINARY_VALUE)(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __in_bcount(cbNewValueSize) const LPBYTE pbNewValue,
    __in DWORD cbNewValueSize,
    __deref_opt_inout_bcount_full(*pcbOutValueSize) LPBYTE *ppbOutValue,
    __inout LPDWORD pcbOutValueSize
    );

DWORD
WINAPI
ResUtilSetSzValue(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __in LPCWSTR pszNewValue,
    __deref_opt_inout LPWSTR *ppszOutString
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_SZ_VALUE)(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __in LPCWSTR pszNewValue,
    __deref_opt_inout LPWSTR *ppszOutString
    );

DWORD
WINAPI
ResUtilSetExpandSzValue(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __in LPCWSTR pszNewValue,
    __inout_opt LPWSTR *ppszOutString
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_EXPAND_SZ_VALUE)(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __in LPCWSTR pszNewValue,
    __inout_opt LPWSTR *ppszOutString
    );

DWORD
WINAPI
ResUtilSetMultiSzValue(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __in_bcount(cbNewValueSize) LPCWSTR pszNewValue,
    __in DWORD cbNewValueSize,
    __deref_opt_out_bcount_full(*pcbOutValueSize) LPWSTR *ppszOutValue,
    __inout_opt LPDWORD pcbOutValueSize
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_MULTI_SZ_VALUE)(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __in_bcount(cbNewValueSize) LPCWSTR pszNewValue,
    __in DWORD cbNewValueSize,
    __deref_opt_out_bcount_full(*pcbOutValueSize) LPWSTR *ppszOutValue,
    __inout_opt LPDWORD pcbOutValueSize
    );

DWORD
WINAPI
ResUtilSetDwordValue(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN DWORD dwNewValue,
    IN OUT LPDWORD pdwOutValue
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_DWORD_VALUE)(
    IN HKEY hkeyClusterKey,
    IN LPCWSTR pszValueName,
    IN DWORD dwNewValue,
    IN OUT LPDWORD pdwOutValue
    );

DWORD
WINAPI
ResUtilSetQwordValue(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __in ULONGLONG qwNewValue,
    __inout_opt PULONGLONG pqwOutValue
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_QWORD_VALUE)(
    __in HKEY hkeyClusterKey,
    __in LPCWSTR pszValueName,
    __in ULONGLONG qwNewValue,
    __inout_opt PULONGLONG pqwOutValue
    );

DWORD
WINAPI
ResUtilGetBinaryProperty(
    __deref_out_bcount(*pcbOutValueSize) LPBYTE *ppbOutValue,
    __out LPDWORD pcbOutValueSize,
    __in const PCLUSPROP_BINARY pValueStruct,
    __in_bcount_opt( cbOldValueSize ) const LPBYTE pbOldValue,
    __in DWORD cbOldValueSize,
    __deref_inout_bcount(*pcbPropertyListSize) LPBYTE *ppPropertyList,
    __inout LPDWORD pcbPropertyListSize
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_BINARY_PROPERTY)(
    __deref_out_bcount(*pcbOutValueSize) LPBYTE *ppbOutValue,
    __out LPDWORD pcbOutValueSize,
    __in const PCLUSPROP_BINARY pValueStruct,
    __in_bcount_opt( cbOldValueSize ) const LPBYTE pbOldValue,
    __in DWORD cbOldValueSize,
    __deref_inout_bcount(*pcbPropertyListSize) LPBYTE *ppPropertyList,
    __inout LPDWORD pcbPropertyListSize
    );

DWORD
WINAPI
ResUtilGetSzProperty(
    __deref_out LPWSTR *ppszOutValue,
    __in const PCLUSPROP_SZ pValueStruct,
    __in_opt LPCWSTR pszOldValue,
    __deref_inout_bcount(*pcbPropertyListSize) LPBYTE *ppPropertyList,
    __inout LPDWORD pcbPropertyListSize
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_SZ_PROPERTY)(
    __deref_out LPWSTR *ppszOutValue,
    __in const PCLUSPROP_SZ pValueStruct,
    __in_opt LPCWSTR pszOldValue,
    __deref_inout_bcount(*pcbPropertyListSize) LPBYTE *ppPropertyList,
    __inout LPDWORD pcbPropertyListSize
    );

DWORD
WINAPI
ResUtilGetMultiSzProperty(
    __deref_out_bcount(*pcbOutValueSize) LPWSTR *ppszOutValue,
    __out LPDWORD pcbOutValueSize,
    __in const PCLUSPROP_SZ pValueStruct,
    __in_bcount_opt(cbOldValueSize) LPCWSTR pszOldValue,
    __in DWORD cbOldValueSize,
    __deref_inout_bcount(*pcbPropertyListSize) LPBYTE *ppPropertyList,
    __inout LPDWORD pcbPropertyListSize
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_MULTI_SZ_PROPERTY)(
    __deref_out_bcount(*pcbOutValueSize) LPWSTR *ppszOutValue,
    __out LPDWORD pcbOutValueSize,
    __in const PCLUSPROP_SZ pValueStruct,
    __in_bcount_opt(cbOldValueSize) LPCWSTR pszOldValue,
    __in DWORD cbOldValueSize,
    __deref_inout_bcount(*pcbPropertyListSize) LPBYTE *ppPropertyList,
    __inout LPDWORD pcbPropertyListSize
    );

DWORD
WINAPI
ResUtilGetDwordProperty(
    OUT LPDWORD pdwOutValue,
    IN const PCLUSPROP_DWORD pValueStruct,
    IN DWORD dwOldValue,
    IN DWORD dwMinimum,
    IN DWORD dwMaximum,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_DWORD_PROPERTY)(
    OUT LPDWORD pdwOutValue,
    IN const PCLUSPROP_DWORD pValueStruct,
    IN DWORD dwOldValue,
    IN DWORD dwMinimum,
    IN DWORD dwMaximum,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    );

DWORD
WINAPI
ResUtilGetLongProperty(
    OUT LPLONG plOutValue,
    IN const PCLUSPROP_LONG pValueStruct,
    IN LONG lOldValue,
    IN LONG lMinimum,
    IN LONG lMaximum,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_LONG_PROPERTY)(
    OUT LPLONG plOutValue,
    IN const PCLUSPROP_LONG pValueStruct,
    IN LONG lOldValue,
    IN LONG lMinimum,
    IN LONG lMaximum,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    );

DWORD
WINAPI
ResUtilGetFileTimeProperty(
    OUT LPFILETIME pftOutValue,
    IN const PCLUSPROP_FILETIME pValueStruct,
    IN FILETIME ftOldValue,
    IN FILETIME ftMinimum,
    IN FILETIME ftMaximum,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_FILETIME_PROPERTY)(
    OUT LPFILETIME pftOutValue,
    IN const PCLUSPROP_FILETIME pValueStruct,
    IN FILETIME ftOldValue,
    IN FILETIME ftMinimum,
    IN FILETIME ftMaximum,
    OUT LPBYTE * ppPropertyList,
    OUT LPDWORD pcbPropertyListSize
    );

LPVOID
WINAPI
ResUtilGetEnvironmentWithNetName(
    __in HRESOURCE hResource
    );

typedef LPVOID
(WINAPI * PRESUTIL_GET_ENVIRONMENT_WITH_NET_NAME)(
    __in HRESOURCE hResource
    );

DWORD
WINAPI
ResUtilFreeEnvironment(
    IN LPVOID lpEnvironment
    );

typedef DWORD
(WINAPI * PRESUTIL_FREE_ENVIRONMENT)(
    IN LPVOID lpEnvironment
    );

LPWSTR
WINAPI
ResUtilExpandEnvironmentStrings(
    IN LPCWSTR pszSrc
    );

typedef LPWSTR
(WINAPI * PRESUTIL_EXPAND_ENVIRONMENT_STRINGS)(
    IN LPCWSTR pszSrc
    );

DWORD
WINAPI
ResUtilSetResourceServiceEnvironment(
    IN LPCWSTR pszServiceName,
    IN HRESOURCE hResource,
    IN PLOG_EVENT_ROUTINE pfnLogEvent,
    IN RESOURCE_HANDLE hResourceHandle
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_RESOURCE_SERVICE_ENVIRONMENT)(
    IN LPCWSTR pszServiceName,
    IN HRESOURCE hResource,
    IN PLOG_EVENT_ROUTINE pfnLogEvent,
    IN RESOURCE_HANDLE hResourceHandle
    );

DWORD
WINAPI
ResUtilRemoveResourceServiceEnvironment(
    IN  LPCWSTR             pszServiceName,
    IN  PLOG_EVENT_ROUTINE  pfnLogEvent,
    IN  RESOURCE_HANDLE     hResourceHandle
    );

typedef DWORD
(WINAPI * PRESUTIL_REMOVE_RESOURCE_SERVICE_ENVIRONMENT)(
    IN  LPCWSTR             pszServiceName,
    IN  PLOG_EVENT_ROUTINE  pfnLogEvent,
    IN  RESOURCE_HANDLE     hResourceHandle
    );

DWORD
WINAPI
ResUtilSetResourceServiceStartParameters(
    IN LPCWSTR pszServiceName,
    IN SC_HANDLE schSCMHandle,
    IN OUT LPSC_HANDLE phService,
    IN PLOG_EVENT_ROUTINE pfnLogEvent,
    IN RESOURCE_HANDLE hResourceHandle
    );

typedef DWORD
(WINAPI * PRESUTIL_SET_RESOURCE_SERVICE_START_PARAMETERS)(
    IN LPCWSTR pszServiceName,
    IN SC_HANDLE schSCMHandle,
    IN OUT LPSC_HANDLE phService,
    IN PLOG_EVENT_ROUTINE pfnLogEvent,
    IN RESOURCE_HANDLE hResourceHandle
    );

DWORD
WINAPI
ResUtilFindSzProperty(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __deref_opt_out LPWSTR *pszPropertyValue
    );

typedef DWORD
(WINAPI * PRESUTIL_FIND_SZ_PROPERTY)(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __deref_opt_out LPWSTR *pszPropertyValue
    );

DWORD
WINAPI
ResUtilFindExpandSzProperty(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __deref_opt_out LPWSTR *pszPropertyValue
    );

typedef DWORD
(WINAPI * PRESUTIL_FIND_EXPAND_SZ_PROPERTY)(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __deref_opt_out LPWSTR *pszPropertyValue
    );

DWORD
WINAPI
ResUtilFindExpandedSzProperty(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __deref_opt_out LPWSTR *pszPropertyValue
    );

typedef DWORD
(WINAPI * PRESUTIL_FIND_EXPANDED_SZ_PROPERTY)(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __deref_opt_out LPWSTR *pszPropertyValue
    );

DWORD
WINAPI
ResUtilFindDwordProperty(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __out LPDWORD pdwPropertyValue
    );

typedef DWORD
(WINAPI * PRESUTIL_FIND_DWORD_PROPERTY)(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __out LPDWORD pdwPropertyValue
    );

DWORD
WINAPI
ResUtilFindBinaryProperty(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __deref_opt_out_bcount_full(*pcbPropertyValueSize) LPBYTE *pbPropertyValue,
    __out_opt LPDWORD pcbPropertyValueSize
    );

typedef DWORD
(WINAPI * PRESUTIL_FIND_BINARY_PROPERTY)(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __deref_opt_out_bcount_full(*pcbPropertyValueSize) LPBYTE *pbPropertyValue,
    __out_opt LPDWORD pcbPropertyValueSize
    );

DWORD
WINAPI
ResUtilFindMultiSzProperty(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __deref_out_bcount_full(*pcbPropertyValueSize) LPWSTR *pszPropertyValue,
    __out LPDWORD pcbPropertyValueSize
    );

typedef DWORD
(WINAPI * PRESUTIL_FIND_MULTI_SZ_PROPERTY)(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __deref_out_bcount_full(*pcbPropertyValueSize) LPWSTR *pszPropertyValue,
    __out LPDWORD pcbPropertyValueSize
    );

DWORD
WINAPI
ResUtilFindLongProperty(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __out LPLONG plPropertyValue
    );

typedef DWORD
(WINAPI * PRESUTIL_FIND_LONG_PROPERTY)(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __out LPLONG plPropertyValue
    );

DWORD
WINAPI
ResUtilFindFileTimeProperty(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __out LPFILETIME pftPropertyValue
    );

typedef DWORD
(WINAPI * PRESUTIL_FIND_FILETIME_PROPERTY)(
    __in_bcount(cbPropertyListSize) const PVOID pPropertyList,
    __in DWORD cbPropertyListSize,
    __in LPCWSTR pszPropertyName,
    __out LPFILETIME pftPropertyValue
    );


//
// Common worker thread routines that allow a pending operation to
// be cancelled with CORRECT synchronization.
//
typedef struct CLUS_WORKER {
    HANDLE hThread;
    BOOL Terminate;
} CLUS_WORKER, *PCLUS_WORKER;

typedef DWORD (WINAPI *PWORKER_START_ROUTINE)(
    PCLUS_WORKER pWorker,
    LPVOID lpThreadParameter
    );

DWORD
WINAPI
ClusWorkerCreate(
    OUT PCLUS_WORKER lpWorker,
    IN PWORKER_START_ROUTINE lpStartAddress,
    IN PVOID lpParameter
    );

typedef DWORD
(WINAPI * PCLUSAPI_CLUS_WORKER_CREATE)(
    OUT PCLUS_WORKER lpWorker,
    IN PWORKER_START_ROUTINE lpStartAddress,
    IN PVOID lpParameter
    );

BOOL
WINAPI
ClusWorkerCheckTerminate(
    IN PCLUS_WORKER lpWorker
    );

typedef BOOL
(WINAPI * PCLUSAPIClusWorkerCheckTerminate)(
    IN PCLUS_WORKER lpWorker
    );

VOID
WINAPI
ClusWorkerTerminate(
    __in PCLUS_WORKER lpWorker
    );

typedef VOID
(WINAPI * PCLUSAPI_CLUS_WORKER_TERMINATE)(
    __in PCLUS_WORKER lpWorker
    );


//Define enumerate resource callback function. This gets called for each resource enumerated
//by ResUtilEnumResources
typedef   DWORD (*LPRESOURCE_CALLBACK)( HRESOURCE, HRESOURCE , PVOID );
typedef   DWORD (*LPRESOURCE_CALLBACK_EX)( HCLUSTER, HRESOURCE, HRESOURCE , PVOID );


BOOL
WINAPI
ResUtilResourcesEqual(
    IN HRESOURCE    hSelf,
    IN HRESOURCE    hResource
    );


typedef BOOL
(WINAPI * PRESUTIL_RESOURCES_EQUAL)(
    IN HRESOURCE    hSelf,
    IN HRESOURCE    hResource
    );


BOOL
WINAPI
ResUtilResourceTypesEqual(
    IN LPCWSTR      lpszResourceTypeName,
    IN HRESOURCE    hResource
    );


typedef BOOL
(WINAPI * PRESUTIL_RESOURCE_TYPES_EQUAL)(
    IN LPCWSTR      lpszResourceTypeName,
    IN HRESOURCE    hResource
    );

BOOL
WINAPI
ResUtilIsResourceClassEqual(
    IN PCLUS_RESOURCE_CLASS_INFO    prci,
    IN HRESOURCE                    hResource
    );

typedef BOOL
(WINAPI * PRESUTIL_IS_RESOURCE_CLASS_EQUAL)(
    IN PCLUS_RESOURCE_CLASS_INFO    prci,
    IN HRESOURCE                    hResource
    );

DWORD
WINAPI
ResUtilEnumResources(
    IN HRESOURCE            hSelf,
    IN LPCWSTR              lpszResTypeName,
    IN LPRESOURCE_CALLBACK  pResCallBack,
    IN PVOID                pParameter
    );

typedef DWORD
(WINAPI * PRESUTIL_ENUM_RESOURCES)(
    IN HRESOURCE            hSelf,
    IN LPCWSTR              lpszResTypeName,
    IN LPRESOURCE_CALLBACK  pResCallBack,
    IN PVOID                pParameter
    );

DWORD
WINAPI
ResUtilEnumResourcesEx(
    IN HCLUSTER                 hCluster,
    IN HRESOURCE                hSelf,
    IN LPCWSTR                  lpszResTypeName,
    IN LPRESOURCE_CALLBACK_EX   pResCallBack,
    IN PVOID                    pParameter
    );

typedef DWORD
(WINAPI * PRESUTIL_ENUM_RESOURCES_EX)(
    IN HCLUSTER                 hCluster,
    IN HRESOURCE                hSelf,
    IN LPCWSTR                  lpszResTypeName,
    IN LPRESOURCE_CALLBACK_EX   pResCallBack,
    IN PVOID                    pParameter
    );

HRESOURCE
WINAPI
ResUtilGetResourceDependency(
    IN HANDLE       hSelf,
    IN LPCWSTR      lpszResourceType
    );

typedef HRESOURCE
(WINAPI * PRESUTIL_GET_RESOURCE_DEPENDENCY)(
    IN HANDLE       hSelf,
    IN LPCWSTR      lpszResourceType
    );

HRESOURCE
WINAPI
ResUtilGetResourceDependencyByName(
    IN HCLUSTER hCluster,
    IN HANDLE   hSelf,
    IN LPCWSTR  lpszResourceType,
    IN BOOL     bRecurse
    );

typedef HRESOURCE
(WINAPI * PRESUTIL_GET_RESOURCE_DEPENDENCY_BY_NAME)(
    IN HCLUSTER hCluster,
    IN HANDLE   hSelf,
    IN LPCWSTR  lpszResourceType,
    IN BOOL     bRecurse
    );

HRESOURCE
WINAPI
ResUtilGetResourceDependencyByClass(
    IN HCLUSTER                     hCluster,
    IN HANDLE                       hSelf,
    IN PCLUS_RESOURCE_CLASS_INFO    prci,
    IN BOOL                         bRecurse
    );

typedef HRESOURCE
(WINAPI * PRESUTIL_GET_RESOURCE_DEPENDENCY_BY_CLASS)(
    IN HCLUSTER                     hCluster,
    IN HANDLE                       hSelf,
    IN PCLUS_RESOURCE_CLASS_INFO    prci,
    IN BOOL                         bRecurse
    );

HRESOURCE
WINAPI
ResUtilGetResourceNameDependency(
    IN LPCWSTR      lpszResourceName,
    IN LPCWSTR      lpszResourceType
    );

typedef HRESOURCE
(WINAPI * PRESUTIL_GET_RESOURCE_NAME_DEPENDENCY)(
    IN LPCWSTR      lpszResourceName,
    IN LPCWSTR      lpszResourceType
    );

__success( return == ERROR_SUCCESS )
DWORD
WINAPI
ResUtilGetResourceDependentIPAddressProps(
    __in HRESOURCE hResource,
    __out_ecount_part(*pcchAddress, *pcchAddress) LPWSTR pszAddress,
    __inout DWORD *pcchAddress,
    __out_ecount_part(*pcchSubnetMask, *pcchSubnetMask) LPWSTR pszSubnetMask,
    __inout DWORD *pcchSubnetMask,
    __out_ecount_part(*pcchNetwork, *pcchNetwork) LPWSTR pszNetwork,
    __inout DWORD *pcch_Network
    );

typedef
__success( return == ERROR_SUCCESS )
DWORD
(WINAPI * PRESUTIL_GET_RESOURCE_DEPENDENTIP_ADDRESS_PROPS)(
    __in HRESOURCE hResource,
    __out_ecount_part(*pcchAddress, *pcchAddress) LPWSTR pszAddress,
    __inout DWORD *pcchAddress,
    __out_ecount_part(*pcchSubnetMask, *pcchSubnetMask) LPWSTR pszSubnetMask,
    __inout DWORD *pcchSubnetMask,
    __out_ecount_part(*pcchNetwork, *pcchNetwork) LPWSTR pszNetwork,
    __inout DWORD *pcchNetwork
    );

__success( return == ERROR_SUCCESS )
DWORD
WINAPI
ResUtilFindDependentDiskResourceDriveLetter(
    __in HCLUSTER hCluster,              // handle to cluster
    __in HRESOURCE hResource,            // handle to resource to query for dependencies
    __out_ecount_part(*pcchDriveLetter, *pcchDriveLetter) LPWSTR pszDriveLetter,       // buffer to store drive letter (ex. "X:\0")
    __inout DWORD * pcchDriveLetter      // IN size of the pszDriveLetter buffer, OUT size of buffer required
    );

typedef
__success( return == ERROR_SUCCESS ) DWORD
(WINAPI * PRESUTIL_FIND_DEPENDENT_DISK_RESOURCE_DRIVE_LETTER)(
    __in HCLUSTER hCluster,              // handle to cluster
    __in HRESOURCE hResource,            // handle to resource to query for dependencies
    __out_ecount_part(*pcchDriveLetter, *pcchDriveLetter) LPWSTR pszDriveLetter,       // buffer to store drive letter (ex. "X:\0")
    __inout DWORD *pcchDriveLetter       // IN size of the pszDriveLetter buffer, OUT size of buffer required
    );

DWORD
WINAPI
ResUtilTerminateServiceProcessFromResDll(
    __in DWORD dwServicePid,
    __in BOOL bOffline,
    __out PDWORD pdwResourceState,
    __in PLOG_EVENT_ROUTINE pfnLogEvent,
    __in RESOURCE_HANDLE hResourceHandle
    );

typedef DWORD
(WINAPI * PRESUTIL_TERMINATE_SERVICE_PROCESS_FROM_RES_DLL)(
    __in DWORD dwServicePid,
    __in BOOL bOffline,
    __out PDWORD pdwResourceState,
    __in PLOG_EVENT_ROUTINE pfnLogEvent,
    __in RESOURCE_HANDLE hResourceHandle
    );

DWORD
WINAPI
ResUtilGetPropertyFormats(
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out_bcount_part(cbPropertyFormatListSize, *pcbBytesReturned) PVOID pOutPropertyFormatList,
    __in DWORD cbPropertyFormatListSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_PROPERTY_FORMATS)(
    __in const PRESUTIL_PROPERTY_ITEM pPropertyTable,
    __out_bcount_part(cbPropertyFormatListSize, *pcbBytesReturned) PVOID pOutPropertyFormatList,
    __in DWORD cbPropertyFormatListSize,
    __out LPDWORD pcbBytesReturned,
    __out LPDWORD pcbRequired
    );


DWORD
WINAPI
ResUtilGetCoreClusterResources(
    __in HCLUSTER hCluster,
    __out HRESOURCE *phClusterNameResource,
    __out HRESOURCE *phClusterIPAddressResource,
    __out HRESOURCE *phClusterQuorumResource
    );


typedef DWORD
(WINAPI * PRESUTIL_GET_CORE_CLUSTER_RESOURCES)(
    __in HCLUSTER hCluster,
    __out HRESOURCE *phClusterNameResource,
    __out HRESOURCE *phClusterIPAddressResource,
    __out HRESOURCE *phClusterQuorumResource
    );

DWORD
WINAPI
ResUtilGetResourceName(
    __in HRESOURCE hResource,
    __out_ecount_part(*pcchResourceNameInOut, *pcchResourceNameInOut) PWSTR pszResourceName,
    __inout DWORD *pcchResourceNameInOut
    );

typedef DWORD
(WINAPI * PRESUTIL_GET_RESOURCE_NAME)(
    __in HRESOURCE hResource,
    __out_ecount_part(*pcchResourceNameInOut, *pcchResourceNameInOut) PWSTR pszResourceName,
    __inout DWORD *pcchResourceNameInOut
    );

typedef enum _CLUSTER_ROLE {
    ClusterRoleDHCP,
    ClusterRoleDTC,
    ClusterRoleFileServer,
    ClusterRoleGenericApplication,
    ClusterRoleGenericScript,
    ClusterRoleGenericService,
    ClusterRoleISCSINameServer,
    ClusterRoleMSMQ,
    ClusterRoleNFS,
    ClusterRolePrintServer,
    ClusterRoleStandAloneNamespaceServer,
    ClusterRoleVolumeShadowCopyServiceTask,
    ClusterRoleWINS,
} CLUSTER_ROLE;

typedef enum _CLUSTER_ROLE_STATE {
    ClusterRoleUnknown = -1,
    ClusterRoleClustered,
    ClusterRoleUnclustered
} CLUSTER_ROLE_STATE;

__success(return >= 0) // != ClusterRoleUnknown
CLUSTER_ROLE_STATE
WINAPI
ResUtilGetClusterRoleState(
    __in HCLUSTER       hCluster,
    __in CLUSTER_ROLE   eClusterRole
    );

// TODO: should we implement versioning here like ClusApi - maybe overkill for now.
BOOL
WINAPI
ClusterIsPathOnSharedVolume(
    __in LPCWSTR lpszPathName
);

typedef BOOL
(WINAPI * PCLUSTER_IS_PATH_ON_SHARED_VOLUME)(
    __in LPCWSTR lpszPathName
    );

BOOL
WINAPI
ClusterGetVolumePathName(
    __in   LPCWSTR lpszFileName,
    __out  LPWSTR lpszVolumePathName,
    __in   DWORD cchBufferLength
    );

typedef BOOL
(WINAPI * PCLUSTER_GET_VOLUME_PATH_NAME)(
    __in   LPCWSTR lpszFileName,
    __out  LPWSTR lpszVolumePathName,
    __in   DWORD cchBufferLength
    );

BOOL
WINAPI
ClusterGetVolumeNameForVolumeMountPoint(
    __in   LPCWSTR lpszVolumeMountPoint,
    __out  LPWSTR lpszVolumeName,
    __in   DWORD cchBufferLength
    );

typedef BOOL
(WINAPI * PCLUSTER_GET_VOLUME_NAME_FOR_VOLUME_MOUNT_POINT)(
    __in   LPCWSTR lpszVolumeMountPoint,
    __out  LPWSTR lpszVolumeName,
    __in   DWORD cchBufferLength
    );

DWORD
WINAPI
ClusterPrepareSharedVolumeForBackup(
    __in LPCWSTR lpszFileName,
    __out LPWSTR lpszVolumePathName,
    __inout LPDWORD lpcchVolumePathName,
    __out LPWSTR lpszVolumeName,
    __inout LPDWORD lpcchVolumeName
    );

typedef DWORD
(WINAPI * PCLUSTER_PREPARE_SHARED_VOLUME_FOR_BACKUP)(
    __in LPCWSTR lpszFileName,
    __out LPWSTR lpszVolumePathName,
    __inout LPDWORD lpcchVolumePathName,
    __out LPWSTR lpszVolumeName,
    __inout LPDWORD lpcchVolumeName
    );

DWORD
WINAPI
ClusterClearBackupStateForSharedVolume(
    __in LPCWSTR lpszVolumePathName
    );

typedef DWORD
(WINAPI * PCLUSTER_CLEAR_BACKUP_STATE_FOR_SHARED_VOLUME)(
    __in LPCWSTR lpszVolumePathName
    );

#ifdef __cplusplus
}
#endif


#endif // ifdef _RESAPI_DEFINES_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RestartManager.h ===
////////////////////////////////////////////////////////////////////////
//
//  RestartManager.h --  Header for RestartManager API
//
//  Copyright (c) Microsoft Corp.  All rights reserverd.
//
////////////////////////////////////////////////////////////////////////

#pragma once

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


// Macros and Types

// RM_SESSION_KEY_LEN - size in bytes of binary session key
#define RM_SESSION_KEY_LEN  sizeof(GUID)
// CCH_RM_SESSION_KEY - character count of text-encoded session key
#define CCH_RM_SESSION_KEY  RM_SESSION_KEY_LEN*2
// CCH_RM_MAX_APP_NAME - maximum character count of application friendly name
#define CCH_RM_MAX_APP_NAME 255
// CCH_RM_MAX_SVC_NAME - maximum character count of service short name
#define CCH_RM_MAX_SVC_NAME 63
// Uninitialized value for TS Session ID
#define RM_INVALID_TS_SESSION -1
// Uninitialized value for Process ID
#define RM_INVALID_PROCESS -1

typedef enum _RM_APP_TYPE {
    RmUnknownApp = 0,   // Application type cannot be classified in
                        // known categories
    RmMainWindow = 1,   // Application is a windows application that
                        // displays a top-level window
    RmOtherWindow = 2,  // Application is a windows app but does not
                        // display a top-level window
    RmService = 3,      // Application is an NT service
    RmExplorer = 4,     // Application is Explorer
    RmConsole = 5,      // Application is Console application
    RmCritical = 1000   // Application is critical system process
                        // where a reboot is required to restart
} RM_APP_TYPE;

typedef enum _RM_SHUTDOWN_TYPE {
    RmForceShutdown = 0x1,          // Force app shutdown
    RmShutdownOnlyRegistered = 0x10 // Only shudown apps if all apps
                                    // registered for restart
} RM_SHUTDOWN_TYPE;

typedef enum _RM_APP_STATUS {
    RmStatusUnknown = 0x0,          // Application in unknown state 
                                    // or state not important
    RmStatusRunning = 0x1,          // Application is currently running
    RmStatusStopped = 0x2,          // Application stopped by Restart Manager
    RmStatusStoppedOther = 0x4,     // Application detected stopped 
                                    // by outside action
    RmStatusRestarted = 0x8,        // Application restarted by Restart Manager
    RmStatusErrorOnStop = 0x10,     // An error occurred when stopping
                                    // this application
    RmStatusErrorOnRestart = 0x20,  // An error occurred when restarting
                                    // this application
    RmStatusShutdownMasked = 0x40,  // Shutdown action masked by filer
    RmStatusRestartMasked = 0x80    // Restart action masked by filter
} RM_APP_STATUS;

typedef enum _RM_REBOOT_REASON {
    RmRebootReasonNone = 0x0,               // Reboot not required
    RmRebootReasonPermissionDenied = 0x1,   // Current user does not have
                                            // permission to shut down
                                            // one or more detected processes
    RmRebootReasonSessionMismatch = 0x2,    // One or more processes are
                                            // running in another TS session.
    RmRebootReasonCriticalProcess = 0x4,    // A critical process has been
                                            // detected
    RmRebootReasonCriticalService = 0x8,    // A critical service has been
                                            // detected
    RmRebootReasonDetectedSelf = 0x10       // The current process has been
                                            // detected
} RM_REBOOT_REASON;

typedef struct _RM_UNIQUE_PROCESS {
    DWORD dwProcessId;              // PID
    FILETIME ProcessStartTime;      // Process creation time
} RM_UNIQUE_PROCESS, *PRM_UNIQUE_PROCESS;

typedef struct _RM_PROCESS_INFO{
    RM_UNIQUE_PROCESS Process;      // Unique process identification
    WCHAR strAppName[CCH_RM_MAX_APP_NAME+1];    // Application friendly name
    WCHAR strServiceShortName[CCH_RM_MAX_SVC_NAME+1];   // Service short name,
                                                        // if applicable
    RM_APP_TYPE ApplicationType;    // Application type
    ULONG AppStatus;                // Bit mask of application status
    DWORD TSSessionId;              // Terminal Service session ID of 
                                    // process (-1 if n/a)
    BOOL bRestartable;              // Is application restartable?
} RM_PROCESS_INFO, *PRM_PROCESS_INFO;

typedef enum _RM_FILTER_TRIGGER
{
    RmFilterTriggerInvalid = 0,         // Invalid value
    RmFilterTriggerFile,                // Filter is triggered by EXE name
    RmFilterTriggerProcess,             // Filter is triggered by PID/create time
    RmFilterTriggerService              // Filter is triggered by service short name
} RM_FILTER_TRIGGER;

typedef enum _RM_FILTER_ACTION {
    RmInvalidFilterAction = 0,          // Invalid value
    RmNoRestart = 1,                    // Prevent restart of application
    RmNoShutdown = 2                    // Prevent shutdown and restart of
                                        // application
} RM_FILTER_ACTION;

typedef struct _RM_FILTER_INFO
{
    RM_FILTER_ACTION FilterAction;      // Filter action
    RM_FILTER_TRIGGER FilterTrigger;    // Filter trigger
    DWORD cbNextOffset;                 // Bytes to next structure
    union
    {
        LPWSTR strFilename;             // When RmFilterTrigger == RmFilterTriggerFile,
                                        // this contains the filename this filter applies to
        RM_UNIQUE_PROCESS Process;      // When RmFilterTrigger == RmFilterTriggerProcess,
                                        // this contains the process this filter applies to
        LPWSTR strServiceShortName;     // When RmFilterTrigger == RmFilterTriggerService,
                                        // this contians the service name this filter applies to
    };
} RM_FILTER_INFO, *PRM_FILTER_INFO;

typedef void (*RM_WRITE_STATUS_CALLBACK)( __in UINT nPercentComplete );

// Functions

// Function: RmStartSession
// Purpose: Begins a Restart Manager session as the Conductor
// Error Codes:
//        ERROR_SEM_TIMEOUT
//            Failed to obtain semaphore lock in allotted time.
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_WRITE_FAULT
//            Read/write operation failed.
//        ERROR_OUTOFMEMORY
//            Could not allocate memory or instantiate class object.
DWORD WINAPI
RmStartSession(
    __out DWORD *pSessionHandle,
    __reserved DWORD dwSessionFlags,
    __out_ecount(CCH_RM_SESSION_KEY+1) WCHAR strSessionKey[]);

// Function: RmJoinSession
// Purpose: Joins an existing Restart Manager session as a Subordinate
// Error Codes:
//        ERROR_SEM_TIMEOUT
//            Failed to obtain semaphore lock in allotted time.
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_WRITE_FAULT
//            Read/write operation failed.
//        ERROR_OUTOFMEMORY
//            Could not allocate memory or instantiate class object.
DWORD WINAPI
RmJoinSession(
    __out DWORD *pSessionHandle,
    __in_ecount(CCH_RM_SESSION_KEY+1) const WCHAR strSessionKey[]);

// Function: RmEndSession
// Purpose: Terminates and cleans up an existing session.
// Error Codes:
//        ERROR_SEM_TIMEOUT
//            Failed to obtain semaphore lock in allotted time.
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_WRITE_FAULT
//            Read/write operation failed.
//        ERROR_OUTOFMEMORY
//            Could not allocate memory or instantiate class object.
//        ERROR_INVALID_HANDLE
//            No session exists for the supplied handle.
DWORD WINAPI
RmEndSession( __in DWORD dwSessionHandle );

// Function: RmRegisterResources
// Purpose: Called if error is encountered. Installer
//          must pass in all files to be updated 
//          that may prevent the install from completing. Processes
//          passed in array are forced to stop/start. Services short
//          names passed in array are stopped (along with dependencies
//          and restarted.
// Error Codes:
//        ERROR_SEM_TIMEOUT
//            Failed to obtain semaphore lock in allotted time.
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_WRITE_FAULT
//            Read/write operation failed.
//        ERROR_OUTOFMEMORY
//            Could not allocate memory or instantiate class object.
//        ERROR_INVALID_HANDLE
//            No session exists for the supplied handle.
DWORD WINAPI
RmRegisterResources(
    __in DWORD dwSessionHandle,
    __in UINT nFiles,
    __in_ecount_opt(nFiles) LPCWSTR rgsFileNames[],
    __in UINT nApplications,
    __in_ecount_opt(nApplications) RM_UNIQUE_PROCESS rgApplications[],
    __in UINT nServices,
    __in_ecount_opt(nServices) LPCWSTR rgsServiceNames[]);

// Function: RmGetList
// Purpose: Gets the list of applications affected by registered
//          resources and their current status.
// Returns: An array of RM_PROCESS_INFO structs containing a list of
//          all applications affected by registered items, the number
//          of structs needed to retreive all application information,
//          the number of structs that were populated, and a series
//          of flags describing why a reboot will be necessary.
// Error Codes:
//        ERROR_MORE_DATA
//            Buffer is not large enough for all information.
//        ERROR_CANCELLED
//            Operation was cancelled by user.
//        ERROR_SEM_TIMEOUT
//            Failed to obtain semaphore lock in allotted time.
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_WRITE_FAULT
//            Read/write operation failed.
//        ERROR_OUTOFMEMORY
//            Could not allocate memory or instantiate class object.
//        ERROR_INVALID_HANDLE
//            No session exists for the supplied handle.
DWORD WINAPI
RmGetList(
    __in DWORD dwSessionHandle,
    __out UINT *pnProcInfoNeeded,
    __inout UINT *pnProcInfo,
    __inout_ecount_opt(*pnProcInfo) RM_PROCESS_INFO rgAffectedApps[],
    __out LPDWORD lpdwRebootReasons );

// Function: RmShutdown
// Purpose: Initiates application shutdown sequence.
// Error Codes:
//        ERROR_FAIL_NOACTION_REBOOT
//            One or more of the affected applications requires a reboot
//            to be shut down.
//        ERROR_FAIL_SHUTDOWN
//            There was an error shuting down some application(s).
//        ERROR_CANCELLED
//            Operation was cancelled by user.
//        ERROR_SEM_TIMEOUT
//            Failed to obtain semaphore lock in allotted time.
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_WRITE_FAULT
//            Read/write operation failed.
//        ERROR_OUTOFMEMORY
//            Could not allocate memory or instantiate class object.
//        ERROR_INVALID_HANDLE
//            No session exists for the supplied handle.
DWORD WINAPI
RmShutdown(
    __in DWORD dwSessionHandle,
    __in ULONG lActionFlags,
    __in_opt RM_WRITE_STATUS_CALLBACK fnStatus);

// Function: RmRestart
// Purpose: Applications automatically shutdown by RmShutdown() 
//          and are registered for restart or are services are restarted.
// Error Codes:
//        ERROR_FAIL_NOACTION_REBOOT
//            One or more of the affected applications requires a reboot
//            to be shut down.
//        ERROR_FAIL_SHUTDOWN
//            There was an error shuting down some application(s).
//        ERROR_CANCELLED
//            Operation was cancelled by user.
//        ERROR_SEM_TIMEOUT
//            Failed to obtain semaphore lock in allotted time.
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_WRITE_FAULT
//            Read/write operation failed.
//        ERROR_OUTOFMEMORY
//            Could not allocate memory or instantiate class object.
//        ERROR_INVALID_HANDLE
//            No session exists for the supplied handle.
DWORD WINAPI
RmRestart(
        __in DWORD dwSessionHandle,
        __reserved DWORD dwRestartFlags,
        __in_opt RM_WRITE_STATUS_CALLBACK fnStatus);

// Function: RmCancelCurrentTask()
// Purpose: Notifies Restart Manager to cancel the task it is performing
//          as soon as possible.
// Error Codes:
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_OUTOFMEMORY
//            Could not allocate memory or instantiate class object.
//        ERROR_INVALID_HANDLE
//            No session exists for the supplied handle.
DWORD WINAPI
RmCancelCurrentTask(
        __in DWORD dwSessionHandle);

// Function: RmAddFilter()
// Purpose: Adds a filter for process module (ie. executable name), process ID,
//          or service short name to prevent Restart Manager from performing
//          the specified action on the process(es) or service noted. 
// Error Codes:
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_INVALID_HANDLE
//            No session exists for the supplied handle.
DWORD WINAPI
RmAddFilter(
        __in DWORD dwSessionHandle,
        __in_opt LPCWSTR strModuleName,
        __in_opt RM_UNIQUE_PROCESS *pProcess,
        __in_opt LPCWSTR strServiceShortName,
        __in RM_FILTER_ACTION FilterAction );

// Function: RmRemoveFilter()
// Purpose: Removes a previously added filter for process module
//          (ie. executable name), process ID, or service short name
//          enabling all Restart Manager actions on the process(es)
//          or service noted. 
// Error Codes:
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_INVALID_HANDLE
//            No session exists for the supplied handle.
DWORD WINAPI
RmRemoveFilter(
        __in DWORD dwSessionHandle,
        __in_opt LPCWSTR strModuleName,
        __in_opt RM_UNIQUE_PROCESS *pProcess,
        __in_opt LPCWSTR strServiceShortName );

// Function: RmGetFilterList()
// Purpose: Writes a set of currenly applied filters
//          to a caller-allocated buffer.
// Error Codes:
//        ERROR_BAD_ARGUMENTS
//            An invalid argument was supplied to the function.
//        ERROR_INVALID_HANDLE
//            No session exists for the supplied handle.
DWORD WINAPI
RmGetFilterList(
        __in DWORD dwSessionHandle,
        __out_bcount_opt(cbFilterBuf) PBYTE pbFilterBuf,
        __in DWORD cbFilterBuf,
        __out LPDWORD cbFilterBufNeeded );

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RpcAsync.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcasync.h

Abstract:

    This module contains the RPC runtime APIs needed to use
    [async] RPC features.

--*/

#ifndef __RPCASYNC_H__
#define __RPCASYNC_H__

#if _MSC_VER > 1000
#pragma once
#endif

#if defined(__RPC_WIN64__)
#include <pshpack8.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(_KRPCENV_)

#include <ntddk.h>

#endif // _KRPCENV_

#if defined(RPC_NO_WINDOWS_H) || defined(_KRPCENV_)

// We've gotta have windef.h--can't live without it.

#include <windef.h>

#endif // RPC_NO_WINDOWS_H || _KRPCENV_


#define RPC_ASYNC_VERSION_1_0     sizeof(RPC_ASYNC_STATE)

typedef
enum _RPC_NOTIFICATION_TYPES
{
    RpcNotificationTypeNone,
    RpcNotificationTypeEvent,
#if !defined(_KRPCENV_)
    RpcNotificationTypeApc,
    RpcNotificationTypeIoc,
    RpcNotificationTypeHwnd,
#endif
    RpcNotificationTypeCallback
} RPC_NOTIFICATION_TYPES;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef
enum _RPC_ASYNC_EVENT {
    RpcCallComplete,
    RpcSendComplete,
    RpcReceiveComplete,
    RpcClientDisconnect,
    RpcClientCancel
    } RPC_ASYNC_EVENT;
    
#else // (NTDDI_VERSION >= NTDDI_VISTA)

typedef
enum _RPC_ASYNC_EVENT {
    RpcCallComplete,
    RpcSendComplete,
    RpcReceiveComplete,
    RpcClientDisconnect
    } RPC_ASYNC_EVENT;    
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

struct _RPC_ASYNC_STATE;

typedef void RPC_ENTRY
RPCNOTIFICATION_ROUTINE (
                  struct _RPC_ASYNC_STATE *pAsync,
                  void *Context,
                  RPC_ASYNC_EVENT Event);
typedef RPCNOTIFICATION_ROUTINE *PFN_RPCNOTIFICATION_ROUTINE;

typedef union _RPC_ASYNC_NOTIFICATION_INFO {
#if !defined(_KRPCENV_)
    //
    // Notification by APC
    //
    struct {
        PFN_RPCNOTIFICATION_ROUTINE NotificationRoutine;
        HANDLE hThread;
        } APC;


#if !defined(RPC_NO_WINDOWS_H) || defined (_WINBASE_)

    //
    // Notification by IO completion port
    //
    struct {
        HANDLE hIOPort;
        DWORD dwNumberOfBytesTransferred;
        DWORD_PTR dwCompletionKey;
        LPOVERLAPPED lpOverlapped;
        } IOC;

#endif // !RPC_NO_WINDOWS_H || _WINBASE_
#if !defined(RPC_NO_WINDOWS_H)
    //
    // Notification by window message
    //
    struct {
        HWND hWnd;
        UINT Msg;
        } HWND;

#endif // RPC_NO_WINDOWS_H
#endif // _KRPCENV_


    #if !defined(_KRPCENV_)
    //
    // Notification by event
    //
    HANDLE hEvent;
    #else   // _KRPCENV_
    //
    // Notification by event
    //
    PKEVENT Event;
    #endif  // _KRPCENV_

    //
    // Notification by callback function
    //
    // This option is available only to OLE
    //
    PFN_RPCNOTIFICATION_ROUTINE NotificationRoutine;
} RPC_ASYNC_NOTIFICATION_INFO, *PRPC_ASYNC_NOTIFICATION_INFO;

typedef struct _RPC_ASYNC_STATE {
    unsigned int    Size; // size of this structure
    unsigned long   Signature;
    long   Lock;
    unsigned long   Flags;
    void           *StubInfo;
    void           *UserInfo;
    void           *RuntimeInfo;
    RPC_ASYNC_EVENT Event;

    RPC_NOTIFICATION_TYPES NotificationType;
    RPC_ASYNC_NOTIFICATION_INFO u;

    LONG_PTR Reserved[4];
    } RPC_ASYNC_STATE, *PRPC_ASYNC_STATE;

// Possible values for Flags
#define RPC_C_NOTIFY_ON_SEND_COMPLETE      0x1
#define RPC_C_INFINITE_TIMEOUT             INFINITE

#define RpcAsyncGetCallHandle(pAsync) (((PRPC_ASYNC_STATE) pAsync)->RuntimeInfo)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncInitializeHandle (
    __out_bcount(Size) PRPC_ASYNC_STATE pAsync,
    __in unsigned int     Size
    );

#if !defined(_KRPCENV_)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncRegisterInfo (
    __in PRPC_ASYNC_STATE pAsync
    ) ;
#endif

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncGetCallStatus (
    __in PRPC_ASYNC_STATE pAsync
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncCompleteCall (
    __inout PRPC_ASYNC_STATE pAsync,
    __out_opt void *Reply
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncAbortCall (
    __inout PRPC_ASYNC_STATE pAsync,
    __in unsigned long ExceptionCode
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncCancelCall (
    __inout PRPC_ASYNC_STATE pAsync,
    __in BOOL fAbort
    ) ;

#if (NTDDI_VERSION >= NTDDI_WINXP)

// EEINFO needs k-mode or needs winbase.h
#if !defined(RPC_NO_WINDOWS_H) || defined(_KRPCENV_) || defined(_WINBASE_)

typedef enum tagExtendedErrorParamTypes
{
    eeptAnsiString = 1,
    eeptUnicodeString,
    eeptLongVal,
    eeptShortVal,
    eeptPointerVal,
    eeptNone,
    eeptBinary
} ExtendedErrorParamTypes;

#define MaxNumberOfEEInfoParams    4
#define RPC_EEINFO_VERSION         1

typedef struct tagBinaryParam
{
    void *Buffer;
    short Size;
} BinaryParam;

typedef struct tagRPC_EE_INFO_PARAM
{
    ExtendedErrorParamTypes ParameterType;
    union
        {
        LPSTR AnsiString;
        LPWSTR UnicodeString;
        long LVal;
        short SVal;
        ULONGLONG PVal;
        BinaryParam BVal;
        } u;
} RPC_EE_INFO_PARAM;

#define EEInfoPreviousRecordsMissing     1
#define EEInfoNextRecordsMissing         2
#define EEInfoUseFileTime                4

#define EEInfoGCCOM                     11
#if (NTDDI_VERSION >= NTDDI_WS03)
#define EEInfoGCFRS                     12
#endif // (NTDDI_VERSION >= NTDDI_WS03)

typedef struct tagRPC_EXTENDED_ERROR_INFO
{
    ULONG Version;
    LPWSTR ComputerName;
    ULONG ProcessID;
    union
        {
#if !defined(_KRPCENV_)
        SYSTEMTIME SystemTime;
        FILETIME FileTime;
#else    // _KRPCENV_
        LARGE_INTEGER KernelTime;
#endif   // _KRPCENV_
        } u;
    ULONG GeneratingComponent;
    ULONG Status;
    USHORT DetectionLocation;
    USHORT Flags;
    int NumberOfParameters;
    RPC_EE_INFO_PARAM Parameters[MaxNumberOfEEInfoParams];
} RPC_EXTENDED_ERROR_INFO;

typedef struct tagRPC_ERROR_ENUM_HANDLE
{
    ULONG Signature;
    void *CurrentPos;
    void *Head;
} RPC_ERROR_ENUM_HANDLE;

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorStartEnumeration (
    __out RPC_ERROR_ENUM_HANDLE *EnumHandle
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorGetNextRecord (
    __in RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    __in BOOL CopyStrings, 
    __out RPC_EXTENDED_ERROR_INFO *ErrorInfo
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorEndEnumeration (
    __inout RPC_ERROR_ENUM_HANDLE *EnumHandle
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorResetEnumeration (
    __inout RPC_ERROR_ENUM_HANDLE *EnumHandle
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorGetNumberOfRecords (
    __in RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    __out int *Records
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorSaveErrorInfo (
    __in RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    __deref_out_bcount(*BlobSize) PVOID *ErrorBlob, 
    __out size_t *BlobSize
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorLoadErrorInfo (
    __in_bcount(BlobSize) PVOID ErrorBlob, 
    __in size_t BlobSize, 
    __out RPC_ERROR_ENUM_HANDLE *EnumHandle
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorAddRecord (
    __in RPC_EXTENDED_ERROR_INFO *ErrorInfo
    );

RPCRTAPI
void 
RPC_ENTRY
RpcErrorClearInformation (
    void
    );

#endif // !RPC_NO_WINDOWS_H || _KRPCENV_ || _WINBASE_

#if !defined(_KRPCENV_)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncCleanupThread (
    __in DWORD dwTimeout
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcGetAuthorizationContextForClient (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __in BOOL ImpersonateOnReturn,
    __in_opt PVOID Reserved1,
    __in_opt PLARGE_INTEGER pExpirationTime,
    __in LUID Reserved2,
    __in DWORD Reserved3,
    __in_opt PVOID Reserved4,
    __out PVOID *pAuthzClientContext
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcFreeAuthorizationContext (
    __deref PVOID *pAuthzClientContext
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSsContextLockExclusive (
    __in_opt RPC_BINDING_HANDLE ServerBindingHandle,
    __in PVOID UserContext
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSsContextLockShared (
    __in RPC_BINDING_HANDLE ServerBindingHandle,
    __in PVOID UserContext
    );

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef enum tagRpcLocalAddressFormat
{
    rlafInvalid = 0,
    rlafIPv4,
    rlafIPv6
} RpcLocalAddressFormat;

typedef struct _RPC_CALL_LOCAL_ADDRESS_V1
{
    unsigned int Version;
    void *Buffer;
    unsigned long BufferSize;
    RpcLocalAddressFormat AddressFormat;
} RPC_CALL_LOCAL_ADDRESS_V1, *PRPC_CALL_LOCAL_ADDRESS_V1;

#define RPC_CALL_ATTRIBUTES_VERSION                         (2)

#define RPC_QUERY_SERVER_PRINCIPAL_NAME                     (0x02)
#define RPC_QUERY_CLIENT_PRINCIPAL_NAME                     (0x04)
#define RPC_QUERY_CALL_LOCAL_ADDRESS                        (0x08)
#define RPC_QUERY_CLIENT_PID                                (0x10)
#define RPC_QUERY_IS_CLIENT_LOCAL                           (0x20)
#define RPC_QUERY_NO_AUTH_REQUIRED                          (0x40)
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#if ( (NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION < NTDDI_VISTA) )
#define RPC_CALL_ATTRIBUTES_VERSION                         (1)
#define RPC_QUERY_SERVER_PRINCIPAL_NAME                     (2)
#define RPC_QUERY_CLIENT_PRINCIPAL_NAME                     (4)
#endif // ( (NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION < NTDDI_VISTA) )

typedef struct tagRPC_CALL_ATTRIBUTES_V1_W
{
    unsigned int Version;
    unsigned long Flags;
    unsigned long ServerPrincipalNameBufferLength;
    unsigned short *ServerPrincipalName;
    unsigned long ClientPrincipalNameBufferLength;
    unsigned short *ClientPrincipalName;
    unsigned long AuthenticationLevel;
    unsigned long AuthenticationService;
    BOOL NullSession;
} RPC_CALL_ATTRIBUTES_V1_W;

typedef struct tagRPC_CALL_ATTRIBUTES_V1_A
{
    unsigned int Version;
    unsigned long Flags;
    unsigned long ServerPrincipalNameBufferLength;
    unsigned char *ServerPrincipalName;
    unsigned long ClientPrincipalNameBufferLength;
    unsigned char *ClientPrincipalName;
    unsigned long AuthenticationLevel;
    unsigned long AuthenticationService;
    BOOL NullSession;
} RPC_CALL_ATTRIBUTES_V1_A;

#if (NTDDI_VERSION >= NTDDI_VISTA)
// CallStatus bit fields
#define RPC_CALL_STATUS_CANCELLED          0x01
#define RPC_CALL_STATUS_DISCONNECTED       0x02

typedef enum tagRpcCallType
{
    rctInvalid = 0,
    rctNormal,
    rctTraining,
    rctGuaranteed
} RpcCallType;

typedef enum tagRpcCallClientLocality
{
    rcclInvalid = 0,
    rcclLocal,
    rcclRemote,
    rcclClientUnknownLocality
} RpcCallClientLocality;


typedef struct tagRPC_CALL_ATTRIBUTES_V2_W
{
    unsigned int Version;
    unsigned long Flags;
    unsigned long ServerPrincipalNameBufferLength;
    unsigned short *ServerPrincipalName;
    unsigned long ClientPrincipalNameBufferLength;
    unsigned short *ClientPrincipalName;
    unsigned long AuthenticationLevel;
    unsigned long AuthenticationService;
    BOOL NullSession;
    BOOL KernelModeCaller;
    unsigned long ProtocolSequence;
    RpcCallClientLocality IsClientLocal;
    HANDLE ClientPID; 
    unsigned long CallStatus;
    RpcCallType CallType;
    RPC_CALL_LOCAL_ADDRESS_V1 *CallLocalAddress;	// one of the CallLocalAddress flavors
    unsigned short OpNum;
    UUID InterfaceUuid;        
} RPC_CALL_ATTRIBUTES_V2_W;
    
typedef struct tagRPC_CALL_ATTRIBUTES_V2_A
{
    unsigned int Version;
    unsigned long Flags;
    unsigned long ServerPrincipalNameBufferLength;
    unsigned char *ServerPrincipalName;
    unsigned long ClientPrincipalNameBufferLength;
    unsigned char *ClientPrincipalName;
    unsigned long AuthenticationLevel;
    unsigned long AuthenticationService;
    BOOL NullSession;
    BOOL KernelModeCaller;
    unsigned long ProtocolSequence;
    unsigned long IsClientLocal;
    HANDLE ClientPID; 
    unsigned long CallStatus;
    RpcCallType CallType;
    RPC_CALL_LOCAL_ADDRESS_V1 *CallLocalAddress;	// one of the CallLocalAddress flavors
    unsigned short OpNum;
    UUID InterfaceUuid;    
} RPC_CALL_ATTRIBUTES_V2_A;
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqCallAttributesW (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __inout void *RpcCallAttributes
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqCallAttributesA (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __inout void *RpcCallAttributes
    );

#ifdef UNICODE
#  define RPC_CALL_ATTRIBUTES_V1 RPC_CALL_ATTRIBUTES_V1_W
#if (NTDDI_VERSION >= NTDDI_VISTA)
#  define RPC_CALL_ATTRIBUTES_V2 RPC_CALL_ATTRIBUTES_V2_W
#endif // (NTDDI_VERSION >= NTDDI_VISTA)
#  define RpcServerInqCallAttributes RpcServerInqCallAttributesW
#else
#  define RPC_CALL_ATTRIBUTES_V1 RPC_CALL_ATTRIBUTES_V1_A
#if (NTDDI_VERSION >= NTDDI_VISTA)
#  define RPC_CALL_ATTRIBUTES_V2 RPC_CALL_ATTRIBUTES_V2_A
#endif // (NTDDI_VERSION >= NTDDI_VISTA)
#  define RpcServerInqCallAttributes RpcServerInqCallAttributesA
#endif // !UNICODE

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef RPC_CALL_ATTRIBUTES_V2 RPC_CALL_ATTRIBUTES;
#else 
typedef RPC_CALL_ATTRIBUTES_V1 RPC_CALL_ATTRIBUTES;
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_VISTA)
// can be used as flags in a bitmask too
typedef enum _RPC_NOTIFICATIONS
{
    RpcNotificationCallNone = 0,
    RpcNotificationClientDisconnect = 1,
    RpcNotificationCallCancel = 2      // internal for Windows
} RPC_NOTIFICATIONS;

#define RpcNotificationCallStatusChange    RpcNotificationClientDisconnect

RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcServerSubscribeForNotification (
    __in_opt RPC_BINDING_HANDLE Binding,
    __in RPC_NOTIFICATIONS Notification,
    __in RPC_NOTIFICATION_TYPES NotificationType,
    __in RPC_ASYNC_NOTIFICATION_INFO *NotificationInfo
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcServerUnsubscribeForNotification (
    __in_opt RPC_BINDING_HANDLE Binding,
    __in RPC_NOTIFICATIONS Notification,
    __out unsigned long *NotificationsQueued
    );

#endif // (NTDDI_VERSION >= NTDDI_VISTA)
#endif // _KRPCENV_
 
#if (NTDDI_VERSION >= NTDDI_VISTA)  
RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcBindingBind (
    __in_opt PRPC_ASYNC_STATE pAsync,
    __in RPC_BINDING_HANDLE Binding,
    __in RPC_IF_HANDLE IfSpec    
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcBindingUnbind (
    __in RPC_BINDING_HANDLE Binding
    );

#if !defined(RPC_NO_WINDOWS_H) || defined(_KRPCENV_) || defined(_WINBASE_)

#define RPC_DE_USE_CURRENT_EEINFO              (1)

RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcDiagnoseError (
    __in RPC_BINDING_HANDLE BindingHandle, 
    __in RPC_IF_HANDLE IfSpec, 
    __in RPC_STATUS RpcStatus, 
    __in_opt RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    __in ULONG Options,
    __in_opt HWND ParentWindow
    );

#endif // !RPC_NO_WINDOWS_H || _KRPCENV_ || _WINBASE_

#endif // (NTDDI_VERSION >= NTDDI_VISTA)
#endif // (NTDDI_VERSION >= NTDDI_WINXP)
//
// Internal APIs
//
RPC_STATUS RPC_ENTRY
I_RpcAsyncSetHandle (
    __in  PRPC_MESSAGE Message,
    __in  PRPC_ASYNC_STATE pAsync
    );

RPC_STATUS RPC_ENTRY
I_RpcAsyncAbortCall (
    __in PRPC_ASYNC_STATE pAsync,
    __in unsigned long ExceptionCode
    ) ;

#if (NTDDI_VERSION >= NTDDI_WXP)
int 
RPC_ENTRY
I_RpcExceptionFilter (
    __in unsigned long ExceptionCode
    );
#endif // (NTDDI_VERSION >= NTDDI_WXP)

#ifdef __cplusplus
}
#endif

#if defined(__RPC_WIN64__)
#include <poppack.h>
#endif

#endif /* __RPCASYNC_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Rpc.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/

#if !defined( RPC_NO_WINDOWS_H ) && !defined( MAC ) && !defined( _MAC ) && !defined(_KRPCENV_)
/*
 * Pull in WINDOWS.H if necessary
 */
#ifndef _INC_WINDOWS
#include <windows.h>
#endif /* _INC_WINDOWS */
#endif // RPC_NO_WINDOWS_H

#ifndef __RPC_H__
#define __RPC_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------------------------
// platform specific defines
//-------------------------------------------------------------

//-------------------  MAC ---------------------------
#if defined( MAC ) || defined( _MAC )

#define __RPC_MAC__
// Set the packing level for RPC structures.

#include <pshpack2.h>

//-------------------  WIN32 ---------------------------
#else // win32 platforms

#include <basetsd.h>

#if defined(_M_IA64) || defined(_M_AMD64)
#define __RPC_WIN64__
#else
#define __RPC_WIN32__
#endif

#endif

#if defined(__RPC_WIN64__)
#include <pshpack8.h>
#endif

#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

typedef void * I_RPC_HANDLE;

// NTSTATUS is also long, so this definition is valid
// for both user mode and kernel mode
typedef long RPC_STATUS;

#if defined(__RPC_WIN32__) || defined(__RPC_WIN64__)
#define RPC_UNICODE_SUPPORTED
#endif

#if !defined(__RPC_MAC__) && ( (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED) )
#	define __RPC_API  __stdcall
#	define __RPC_USER __stdcall
#	define __RPC_STUB __stdcall
#	define  RPC_ENTRY __stdcall
#else // Not Win32/Win64
#	define __RPC_API
#	define __RPC_USER
#	define __RPC_STUB
#	define RPC_ENTRY
#endif

#define __RPC_FAR

// Some RPC platforms don't define DECLSPEC_IMPORT
#if !defined(DECLSPEC_IMPORT)
#if (defined(_M_MRX000) || defined(_M_IX86) || defined(_M_IA64) || defined(_M_AMD64)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif
#endif

#if !defined(_RPCRT4_) && !defined(_KRPCENV_)
#define RPCRTAPI DECLSPEC_IMPORT
#else
#define RPCRTAPI
#endif

#if !defined(_RPCNS4_)
#define RPCNSAPI DECLSPEC_IMPORT
#else
#define RPCNSAPI
#endif

#ifdef __RPC_MAC__

#include <setjmp.h>

#define RPCXCWORD (sizeof(jmp_buf)/sizeof(int))

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable: 4005 )
#include <rpcdce.h>
#include <rpcnsi.h>
#include <rpcerr.h>
#include <rpcmac.h>
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default :  4005 )
#endif

typedef void  (RPC_ENTRY *MACYIELDCALLBACK)(/*OSErr*/ short *) ;
RPC_STATUS RPC_ENTRY
RpcMacSetYieldInfo(
	MACYIELDCALLBACK pfnCallback) ;

#if !defined(UNALIGNED)
#define UNALIGNED
#endif

#include <poppack.h>

#else // __RPC_MAC__

#include <rpcdce.h>
#if !defined(_KRPCENV_)
#include <rpcnsi.h>
#endif // _KRPCENV_
#include <rpcnterr.h>
#include <excpt.h>
#if !defined(_KRPCENV_)
#include <winerror.h>
#endif // _KRPCENV_

#define RpcTryExcept \
    __try \
        {

// trystmts

#define RpcExcept(expr) \
        } \
    __except (expr) \
        {

// exceptstmts

#define RpcEndExcept \
        }

#define RpcTryFinally \
    __try \
        {

// trystmts

#define RpcFinally \
        } \
    __finally \
        {

// finallystmts

#define RpcEndFinally \
        }

#define RpcExceptionCode() GetExceptionCode()
#define RpcAbnormalTermination() AbnormalTermination()

#endif // __RPC_MAC__

// rpcasync.h is now RPC_NO_WINDOWS_H aware, but we can't start including it always
// as it does still require windef.h which could clash with another header.
//
// Parsing of the below test:
// don't include rpcasync.h if either RPC_NO_WINDOWS_H or __RPC_MAC__ is set, except that setting
// RPC_NEED_RPCASYNC_H overrides RPC_NO_WINDOWS_H.
// In any case, if _KRPCENV_ is set, include rpcasync.h regardless of any of the above being set.
#if ((!defined( RPC_NO_WINDOWS_H ) || defined(RPC_NEED_RPCASYNC_H)) && !defined(__RPC_MAC__)) || defined(_KRPCENV_)

#include <rpcasync.h>

#endif // RPC_NO_WINDOWS_H et al.

#if defined(__RPC_WIN64__)
#include <poppack.h>
#endif

#ifdef __cplusplus
}
#endif

#endif // __RPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\ringtonedeviceservice.h ===
/*
 *  RingtoneDeviceService.h
 *
 *  Contains declarations for the Ringtone Device Service
 *
 *  Copyright (c) Microsoft Corporation, All Rights Reserved.
 *
 */

#ifndef _RINGTONEDEVICESERVICE_H_
#define _RINGTONEDEVICESERVICE_H_

#include <DeviceServices.h>
#include <MessageDeviceService.h>


/*****************************************************************************/
/*  Ringtone Service Info                                                    */
/*****************************************************************************/

DEFINE_DEVSVCGUID(SERVICE_Ringtones,
    0xd0eace0e, 0x707d, 0x4106, 0x8d, 0x38, 0x4f, 0x56, 0xe, 0x6a, 0x9f, 0x8e);

#define NAME_RingtonesSvc                   L"Ringtones"
#define TYPE_RingtonesSvc                   DEVSVCTYPE_DEFAULT


/*****************************************************************************/
/*  Ringtone Service Properties                                              */
/*****************************************************************************/

DEFINE_DEVSVCGUID(NAMESPACE_RingtonesSvc,
    0x7d05d925, 0x32e6, 0x4790, 0x92, 0x05, 0x54, 0x76, 0x4b, 0xb3, 0xcb, 0x74);

/*  PKEY_RingtonesSvc_DefaultRingtone
 *
 *  Indicates the objectID of the default ringtone for incoming calls
 *
 *  Type: UInt32
 *  Form: ObjectID
 */

DEFINE_DEVSVCPROPKEY(PKEY_RingtonesSvc_DefaultRingtone,
    0x7d05d925, 0x32e6, 0x4790, 0x92, 0x05, 0x54, 0x76, 0x4b, 0xb3, 0xcb, 0x74,
    2);

#define NAME_RingtonesSvc_DefaultRingtone   L"DefaultRingtone"


/*****************************************************************************/
/*  Ringtone Service Object Properties                                       */
/*****************************************************************************/

DEFINE_DEVSVCGUID(NAMESPACE_RingtonesObj,
    0x8d943c78, 0x2c7d, 0x4c74, 0x94, 0x5a, 0x42, 0xd8, 0x3c, 0xb5, 0x8b, 0x5a);

#endif  /* _RINGTONEDEVICESERVICE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RichOle.h ===
#ifndef _RICHOLE_
#define _RICHOLE_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 *	RICHOLE.H
 *
 *	Purpose:
 *		OLE Extensions to the Rich Text Editor
 *
 *	Copyright (c) 1985-1999, Microsoft Corporation
 */

// Structure passed to GetObject and InsertObject
typedef struct _reobject
{
	DWORD			cbStruct;			// Size of structure
	LONG			cp;					// Character position of object
	CLSID			clsid;				// Class ID of object
	LPOLEOBJECT		poleobj;			// OLE object interface
	LPSTORAGE		pstg;				// Associated storage interface
	LPOLECLIENTSITE	polesite;			// Associated client site interface
	SIZEL			sizel;				// Size of object (may be 0,0)
	DWORD			dvaspect;			// Display aspect to use
	DWORD			dwFlags;			// Object status flags
	DWORD			dwUser;				// Dword for user's use
} REOBJECT;

// Flags to specify which interfaces should be returned in the structure above
#define REO_GETOBJ_NO_INTERFACES	(0x00000000L)
#define REO_GETOBJ_POLEOBJ			(0x00000001L)
#define REO_GETOBJ_PSTG				(0x00000002L)
#define REO_GETOBJ_POLESITE			(0x00000004L)
#define REO_GETOBJ_ALL_INTERFACES	(0x00000007L)

// Place object at selection
#define REO_CP_SELECTION ((ULONG) -1L)

// Use character position to specify object instead of index
#define REO_IOB_SELECTION ((ULONG) -1L)
#define REO_IOB_USE_CP ((ULONG) -2L)

// Object flags
#define REO_NULL			(0x00000000L)	// No flags
#define REO_READWRITEMASK	(0x0000003FL)	// Mask out RO bits
#define REO_DONTNEEDPALETTE	(0x00000020L)	// Object doesn't need palette
#define REO_BLANK			(0x00000010L)	// Object is blank
#define REO_DYNAMICSIZE		(0x00000008L)	// Object defines size always
#define REO_INVERTEDSELECT	(0x00000004L)	// Object drawn all inverted if sel
#define REO_BELOWBASELINE	(0x00000002L)	// Object sits below the baseline
#define REO_RESIZABLE		(0x00000001L)	// Object may be resized
#define REO_LINK			(0x80000000L)	// Object is a link (RO)
#define REO_STATIC			(0x40000000L)	// Object is static (RO)
#define REO_SELECTED		(0x08000000L)	// Object selected (RO)
#define REO_OPEN			(0x04000000L)	// Object open in its server (RO)
#define REO_INPLACEACTIVE	(0x02000000L)	// Object in place active (RO)
#define REO_HILITED			(0x01000000L)	// Object is to be hilited (RO)
#define REO_LINKAVAILABLE	(0x00800000L)	// Link believed available (RO)
#define REO_GETMETAFILE		(0x00400000L)	// Object requires metafile (RO)

// flags for IRichEditOle::GetClipboardData(),
// IRichEditOleCallback::GetClipboardData() and
// IRichEditOleCallback::QueryAcceptData()
#define RECO_PASTE			(0x00000000L)	// paste from clipboard
#define RECO_DROP			(0x00000001L)	// drop
#define RECO_COPY			(0x00000002L)	// copy to the clipboard
#define RECO_CUT			(0x00000003L)	// cut to the clipboard
#define RECO_DRAG			(0x00000004L)	// drag

/*
 *	IRichEditOle
 *
 *	Purpose:
 *		Interface used by the client of RichEdit to perform OLE-related
 *		operations.
 *
 *	//$ REVIEW:
 *		The methods herein may just want to be regular Windows messages.
 */
#undef INTERFACE
#define INTERFACE   IRichEditOle

DECLARE_INTERFACE_(IRichEditOle, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lplpObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRichEditOle methods ***
    STDMETHOD(GetClientSite) (THIS_ LPOLECLIENTSITE FAR * lplpolesite) PURE;
	STDMETHOD_(LONG,GetObjectCount) (THIS) PURE;
	STDMETHOD_(LONG,GetLinkCount) (THIS) PURE;
	STDMETHOD(GetObject) (THIS_ LONG iob, REOBJECT FAR * lpreobject,
						  DWORD dwFlags) PURE;
    STDMETHOD(InsertObject) (THIS_ REOBJECT FAR * lpreobject) PURE;
	STDMETHOD(ConvertObject) (THIS_ LONG iob, REFCLSID rclsidNew,
							  LPCSTR lpstrUserTypeNew) PURE;
	STDMETHOD(ActivateAs) (THIS_ REFCLSID rclsid, REFCLSID rclsidAs) PURE;
	STDMETHOD(SetHostNames) (THIS_ LPCSTR lpstrContainerApp,
							 LPCSTR lpstrContainerObj) PURE;
	STDMETHOD(SetLinkAvailable) (THIS_ LONG iob, BOOL fAvailable) PURE;
	STDMETHOD(SetDvaspect) (THIS_ LONG iob, DWORD dvaspect) PURE;
	STDMETHOD(HandsOffStorage) (THIS_ LONG iob) PURE;
	STDMETHOD(SaveCompleted) (THIS_ LONG iob, LPSTORAGE lpstg) PURE;
	STDMETHOD(InPlaceDeactivate) (THIS) PURE;
	STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
	STDMETHOD(GetClipboardData) (THIS_ CHARRANGE FAR * lpchrg, DWORD reco,
									LPDATAOBJECT FAR * lplpdataobj) PURE;
	STDMETHOD(ImportDataObject) (THIS_ LPDATAOBJECT lpdataobj,
									CLIPFORMAT cf, HGLOBAL hMetaPict) PURE;
};
typedef         IRichEditOle FAR * LPRICHEDITOLE;

/*
 *	IRichEditOleCallback
 *
 *	Purpose:
 *		Interface used by the RichEdit to get OLE-related stuff from the
 *		application using RichEdit.
 */
#undef INTERFACE
#define INTERFACE   IRichEditOleCallback

DECLARE_INTERFACE_(IRichEditOleCallback, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lplpObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRichEditOleCallback methods ***
	STDMETHOD(GetNewStorage) (THIS_ LPSTORAGE FAR * lplpstg) PURE;
    STDMETHOD(GetInPlaceContext) (THIS_ LPOLEINPLACEFRAME FAR * lplpFrame,
								  LPOLEINPLACEUIWINDOW FAR * lplpDoc,
								  LPOLEINPLACEFRAMEINFO lpFrameInfo) PURE;
	STDMETHOD(ShowContainerUI) (THIS_ BOOL fShow) PURE;
	STDMETHOD(QueryInsertObject) (THIS_ LPCLSID lpclsid, LPSTORAGE lpstg,
									LONG cp) PURE;
	STDMETHOD(DeleteObject) (THIS_ LPOLEOBJECT lpoleobj) PURE;
	STDMETHOD(QueryAcceptData) (THIS_ LPDATAOBJECT lpdataobj,
								CLIPFORMAT FAR * lpcfFormat, DWORD reco,
								BOOL fReally, HGLOBAL hMetaPict) PURE;
	STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
	STDMETHOD(GetClipboardData) (THIS_ CHARRANGE FAR * lpchrg, DWORD reco,
									LPDATAOBJECT FAR * lplpdataobj) PURE;
	STDMETHOD(GetDragDropEffect) (THIS_ BOOL fDrag, DWORD grfKeyState,
									LPDWORD pdwEffect) PURE;
	STDMETHOD(GetContextMenu) (THIS_ WORD seltype, LPOLEOBJECT lpoleobj,
									CHARRANGE FAR * lpchrg,
									HMENU FAR * lphmenu) PURE;
};
typedef         IRichEditOleCallback FAR * LPRICHEDITOLECALLBACK;

#ifndef MAC
// RichEdit interface GUIDs
DEFINE_GUID(IID_IRichEditOle,         0x00020D00, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IRichEditOleCallback, 0x00020D03, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
#endif // !MAC

#endif // _RICHOLE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RpcDce.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcdce.h

Abstract:

    This module contains the DCE RPC runtime APIs.

--*/

#ifndef __RPCDCE_H__
#define __RPCDCE_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef DECLSPEC_NORETURN
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NORETURN   __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif

/*typedef char small;*/
/*typedef unsigned char byte;*/
/*typedef unsigned char boolean;*/

#include <specstrings.h>

typedef __nullterminated unsigned char __RPC_FAR * RPC_CSTR;

#if defined(RPC_USE_NATIVE_WCHAR) && defined(_NATIVE_WCHAR_T_DEFINED)
typedef __nullterminated wchar_t __RPC_FAR * RPC_WSTR;
typedef __nullterminated const wchar_t * RPC_CWSTR;
#else
typedef __nullterminated unsigned short __RPC_FAR * RPC_WSTR;
typedef __nullterminated const unsigned short * RPC_CWSTR;
#endif

typedef I_RPC_HANDLE RPC_BINDING_HANDLE;
typedef RPC_BINDING_HANDLE handle_t;
#define rpc_binding_handle_t RPC_BINDING_HANDLE

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif /* GUID_DEFINED */

#ifndef UUID_DEFINED
#define UUID_DEFINED
typedef GUID UUID;
#ifndef uuid_t
#define uuid_t UUID
#endif
#endif

typedef struct _RPC_BINDING_VECTOR
{
    unsigned long Count;
    RPC_BINDING_HANDLE BindingH[1];
} RPC_BINDING_VECTOR;
#ifndef rpc_binding_vector_t
#define rpc_binding_vector_t RPC_BINDING_VECTOR
#endif

typedef struct _UUID_VECTOR
{
  unsigned long Count;
  UUID *Uuid[1];
} UUID_VECTOR;
#ifndef uuid_vector_t
#define uuid_vector_t UUID_VECTOR
#endif

typedef void __RPC_FAR * RPC_IF_HANDLE;

#ifndef IFID_DEFINED
#define IFID_DEFINED
typedef struct _RPC_IF_ID
{
    UUID Uuid;
    unsigned short VersMajor;
    unsigned short VersMinor;
} RPC_IF_ID;
#endif

#define RPC_C_BINDING_INFINITE_TIMEOUT 10
#define RPC_C_BINDING_MIN_TIMEOUT 0
#define RPC_C_BINDING_DEFAULT_TIMEOUT 5
#define RPC_C_BINDING_MAX_TIMEOUT 9

#define RPC_C_CANCEL_INFINITE_TIMEOUT -1

#define RPC_C_LISTEN_MAX_CALLS_DEFAULT 1234
#define RPC_C_PROTSEQ_MAX_REQS_DEFAULT 10

// RPC_POLICY EndpointFlags.
#define RPC_C_BIND_TO_ALL_NICS          1
#define RPC_C_USE_INTERNET_PORT         0x1
#define RPC_C_USE_INTRANET_PORT         0x2
#define RPC_C_DONT_FAIL                 0x4
#define RPC_C_RPCHTTP_USE_LOAD_BALANCE  0x8

#if (NTDDI_VERSION < NTDDI_VISTA)
// RPC_POLICY EndpointFlags specific to the Falcon/RPC transport (deprecated for Vista)
#define RPC_C_MQ_TEMPORARY                  0x0000
#define RPC_C_MQ_PERMANENT                  0x0001
#define RPC_C_MQ_CLEAR_ON_OPEN              0x0002
#define RPC_C_MQ_USE_EXISTING_SECURITY      0x0004
#define RPC_C_MQ_AUTHN_LEVEL_NONE           0x0000
#define RPC_C_MQ_AUTHN_LEVEL_PKT_INTEGRITY  0x0008
#define RPC_C_MQ_AUTHN_LEVEL_PKT_PRIVACY    0x0010

// Falcon/Rpc options are deprecated from Vista
#define RPC_C_MQ_EXPRESS                0  // Client: RPC_C_MQ_DELIVERY.
#define RPC_C_MQ_RECOVERABLE            1

#define RPC_C_MQ_JOURNAL_NONE           0  // Client: RPC_C_MQ_JOURNAL.
#define RPC_C_MQ_JOURNAL_DEADLETTER     1
#define RPC_C_MQ_JOURNAL_ALWAYS         2

// Client: RpcBindingSetOption() values for the Falcon/RPC transport (some are deprecated from Vista)

#define RPC_C_OPT_MQ_DELIVERY            1
#define RPC_C_OPT_MQ_PRIORITY            2
#define RPC_C_OPT_MQ_JOURNAL             3
#define RPC_C_OPT_MQ_ACKNOWLEDGE         4
#define RPC_C_OPT_MQ_AUTHN_SERVICE       5
#define RPC_C_OPT_MQ_AUTHN_LEVEL         6
#define RPC_C_OPT_MQ_TIME_TO_REACH_QUEUE 7
#define RPC_C_OPT_MQ_TIME_TO_BE_RECEIVED 8
#endif // (NTDDI_VERSION < NTDDI_VISTA)

#define RPC_C_OPT_BINDING_NONCAUSAL      9
#define RPC_C_OPT_SECURITY_CALLBACK      10
#define RPC_C_OPT_UNIQUE_BINDING         11

#if (NTDDI_VERSION <= NTDDI_WIN2K)
#define RPC_C_OPT_MAX_OPTIONS            12

#elif (NTDDI_VERSION <= NTDDI_WS03)
#define RPC_C_OPT_CALL_TIMEOUT           12
#define RPC_C_OPT_DONT_LINGER            13
#define RPC_C_OPT_MAX_OPTIONS            14

#else
#define RPC_C_OPT_TRANS_SEND_BUFFER_SIZE 5
#define RPC_C_OPT_CALL_TIMEOUT           12
#define RPC_C_OPT_DONT_LINGER            13
#define RPC_C_OPT_TRUST_PEER             14
#define RPC_C_OPT_ASYNC_BLOCK            15
#define RPC_C_OPT_OPTIMIZE_TIME          16
#define RPC_C_OPT_MAX_OPTIONS            17

#endif // (NTDDI_VERSION <= NTDDI_WIN2K)

// flags for RpcServerInqAuthClientEx
//
#define RPC_C_FULL_CERT_CHAIN 0x0001



#ifdef RPC_UNICODE_SUPPORTED
typedef struct _RPC_PROTSEQ_VECTORA
{
    unsigned int Count;
    unsigned char __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTORA;

typedef struct _RPC_PROTSEQ_VECTORW
{
    unsigned int Count;
    unsigned short __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTORW;

#ifdef UNICODE
#define RPC_PROTSEQ_VECTOR RPC_PROTSEQ_VECTORW
#else /* UNICODE */
#define RPC_PROTSEQ_VECTOR RPC_PROTSEQ_VECTORA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

typedef struct _RPC_PROTSEQ_VECTOR
{
    unsigned int Count;
    unsigned char __RPC_FAR * Protseq[1];
} RPC_PROTSEQ_VECTOR;

#endif /* RPC_UNICODE_SUPPORTED */
typedef struct _RPC_POLICY {
    unsigned int Length ;
    unsigned long EndpointFlags ;
    unsigned long NICFlags ;
    } RPC_POLICY,  __RPC_FAR *PRPC_POLICY ;

typedef void __RPC_USER
RPC_OBJECT_INQ_FN (
    __in UUID __RPC_FAR * ObjectUuid,
    __out UUID __RPC_FAR * TypeUuid,
    __out RPC_STATUS __RPC_FAR * Status
    );

__success(return == 0) /*RPC_S_OK*/
typedef RPC_STATUS RPC_ENTRY
RPC_IF_CALLBACK_FN (
    __in RPC_IF_HANDLE  InterfaceUuid,
    __in void *Context
    ) ;

typedef void RPC_ENTRY
RPC_SECURITY_CALLBACK_FN (
    __in void *Context
    ) ;

#define RPC_MGR_EPV void

typedef struct
{
    unsigned int Count;
    unsigned long Stats[1];
} RPC_STATS_VECTOR;

#define RPC_C_STATS_CALLS_IN 0
#define RPC_C_STATS_CALLS_OUT 1
#define RPC_C_STATS_PKTS_IN 2
#define RPC_C_STATS_PKTS_OUT 3

typedef struct
{
  unsigned long Count;
  RPC_IF_ID __RPC_FAR * IfId[1];
} RPC_IF_ID_VECTOR;

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingCopy (
    __in RPC_BINDING_HANDLE SourceBinding,
    __out RPC_BINDING_HANDLE __RPC_FAR * DestinationBinding
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFree (
    __inout RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetOption ( 
    __in RPC_BINDING_HANDLE hBinding,
    __in unsigned long      option,
    __in ULONG_PTR          optionValue 
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqOption (
    __in  RPC_BINDING_HANDLE hBinding,
    __in  unsigned long      option,
    __out ULONG_PTR         *pOptionValue 
    );

/* client */

#if !defined(_KRPCENV_)

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFromStringBindingA (    
    __in RPC_CSTR StringBinding,
    __out RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFromStringBindingW (
    __in RPC_WSTR StringBinding,        
    __out RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

#ifdef UNICODE
#define RpcBindingFromStringBinding RpcBindingFromStringBindingW
#else /* UNICODE */
#define RpcBindingFromStringBinding RpcBindingFromStringBindingA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingFromStringBinding (
    __in RPC_CSTR StringBinding    
    __out RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

#endif /* RPC_UNICODE_SUPPORTED */

#endif /* _KRPCENV_ */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSsGetContextBinding (
    __in void *ContextHandle,
    __out RPC_BINDING_HANDLE __RPC_FAR * Binding
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqObject (
    __in RPC_BINDING_HANDLE Binding,
    __out UUID __RPC_FAR * ObjectUuid
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingReset (
    __in RPC_BINDING_HANDLE Binding
    );

/* RpcBindingServerFromClient : UNSUPPORTED */
/* RpcBindingSetAuthInfo */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetObject (
    __in RPC_BINDING_HANDLE Binding,
    __in UUID __RPC_FAR * ObjectUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqDefaultProtectLevel (
    __in  unsigned long AuthnSvc,
    __in unsigned long __RPC_FAR *AuthnLevel
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingToStringBindingA (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out RPC_CSTR __RPC_FAR * StringBinding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingToStringBindingW (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out RPC_WSTR __RPC_FAR * StringBinding
    );

#ifdef UNICODE
#define RpcBindingToStringBinding RpcBindingToStringBindingW
#else /* UNICODE */
#define RpcBindingToStringBinding RpcBindingToStringBindingA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingToStringBinding (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out RPC_CSTR __RPC_FAR * StringBinding
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingVectorFree (
    __deref_inout RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVector
    );

/* client/server */

#if !defined(_KRPCENV_)

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingComposeA (
    __in_opt RPC_CSTR ObjUuid,
    __in_opt RPC_CSTR ProtSeq,    
    __in_opt RPC_CSTR NetworkAddr,
    __in_opt RPC_CSTR Endpoint,
    __in_opt RPC_CSTR Options,
    __deref_opt_out RPC_CSTR __RPC_FAR * StringBinding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingComposeW (
    __in_opt RPC_WSTR ObjUuid,
    __in_opt RPC_WSTR ProtSeq,    
    __in_opt RPC_WSTR NetworkAddr,
    __in_opt RPC_WSTR Endpoint,
    __in_opt RPC_WSTR Options,
    __deref_opt_out RPC_WSTR __RPC_FAR * StringBinding
    );

#ifdef UNICODE
#define RpcStringBindingCompose RpcStringBindingComposeW
#else /* UNICODE */
#define RpcStringBindingCompose RpcStringBindingComposeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingCompose (
    __in_opt RPC_CSTR ObjUuid,
    __in_opt RPC_CSTR ProtSeq,    
    __in_opt RPC_CSTR NetworkAddr,
    __in_opt RPC_CSTR Endpoint,
    __in_opt RPC_CSTR Options,
    __deref_opt_out RPC_CSTR __RPC_FAR * StringBinding
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingParseA (
    __in RPC_CSTR StringBinding,    
    __deref_opt_out RPC_CSTR __RPC_FAR * ObjUuid,
    __deref_opt_out RPC_CSTR __RPC_FAR * Protseq,
    __deref_opt_out RPC_CSTR __RPC_FAR * NetworkAddr,
    __deref_opt_out RPC_CSTR __RPC_FAR * Endpoint,
    __deref_opt_out RPC_CSTR __RPC_FAR * NetworkOptions
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingParseW (
    __in RPC_WSTR StringBinding,    
    __deref_opt_out RPC_WSTR __RPC_FAR * ObjUuid,
    __deref_opt_out RPC_WSTR __RPC_FAR * Protseq,
    __deref_opt_out RPC_WSTR __RPC_FAR * NetworkAddr,
    __deref_opt_out RPC_WSTR __RPC_FAR * Endpoint,
    __deref_opt_out RPC_WSTR __RPC_FAR * NetworkOptions
    );

#ifdef UNICODE
#define RpcStringBindingParse RpcStringBindingParseW
#else /* UNICODE */
#define RpcStringBindingParse RpcStringBindingParseA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringBindingParse (
    __in RPC_CSTR StringBinding,    
    __deref_opt_out RPC_CSTR __RPC_FAR * ObjUuid,
    __deref_opt_out RPC_CSTR __RPC_FAR * Protseq,
    __deref_opt_out RPC_CSTR __RPC_FAR * NetworkAddr,
    __deref_opt_out RPC_CSTR __RPC_FAR * Endpoint,
    __deref_opt_out RPC_CSTR __RPC_FAR * NetworkOptions
    );

#endif /* RPC_UNICODE_SUPPORTED */

#endif /* _KRPCENV_ */

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFreeA (
    __inout RPC_CSTR __RPC_FAR * String    
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFreeW (
    __inout RPC_WSTR __RPC_FAR * String
    );

#ifdef UNICODE
#define RpcStringFree RpcStringFreeW
#else /* UNICODE */
#define RpcStringFree RpcStringFreeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcStringFree (
    __deref_inout RPC_CSTR __RPC_FAR * String
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcIfInqId (
    __in RPC_IF_HANDLE RpcIfHandle,
    __out RPC_IF_ID __RPC_FAR * RpcIfId
    );

/* client/server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkIsProtseqValidA (
    __in RPC_CSTR Protseq     
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkIsProtseqValidW (
    __in RPC_WSTR Protseq
    );

#ifdef UNICODE
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidW
#else /* UNICODE */
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkIsProtseqValid (
    __in RPC_CSTR Protseq
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqComTimeout (
    __in RPC_BINDING_HANDLE Binding,
    __out unsigned int __RPC_FAR * Timeout
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetComTimeout (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned int Timeout
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetCancelTimeout(
    __in long Timeout
    );


/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkInqProtseqsA (
    __deref_out RPC_PROTSEQ_VECTORA __RPC_FAR * __RPC_FAR * ProtseqVector    
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkInqProtseqsW (
    __deref_out RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector    
    );

#ifdef UNICODE
#define RpcNetworkInqProtseqs RpcNetworkInqProtseqsW
#else /* UNICODE */
#define RpcNetworkInqProtseqs RpcNetworkInqProtseqsA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNetworkInqProtseqs (
    __deref_out RPC_PROTSEQ_VECTOR __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcObjectInqType (
    __in UUID __RPC_FAR * ObjUuid,
    __out_opt OPTIONAL UUID __RPC_FAR * TypeUuid
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcObjectSetInqFn (
    __in RPC_OBJECT_INQ_FN __RPC_FAR * InquiryFn
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcObjectSetType (
    __in UUID __RPC_FAR * ObjUuid,
    __in_opt OPTIONAL UUID __RPC_FAR * TypeUuid
    );

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcProtseqVectorFreeA (
    __deref_inout RPC_PROTSEQ_VECTORA __RPC_FAR * __RPC_FAR * ProtseqVector
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcProtseqVectorFreeW (
    __deref_inout RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#ifdef UNICODE
#define RpcProtseqVectorFree RpcProtseqVectorFreeW
#else /* UNICODE */
#define RpcProtseqVectorFree RpcProtseqVectorFreeA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcProtseqVectorFree (
    __deref_inout RPC_PROTSEQ_VECTOR __RPC_FAR * __RPC_FAR * ProtseqVector
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqBindings (
    __deref_out RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVector
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqIf (
    __in RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR * MgrTypeUuid,
    __deref_out RPC_MGR_EPV __RPC_FAR * __RPC_FAR * MgrEpv
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerListen (
    __in unsigned int MinimumCallThreads,
    __in unsigned int MaxCalls,
    __in unsigned int DontWait
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterIf (
    __in RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR * MgrTypeUuid,
    __in_opt RPC_MGR_EPV __RPC_FAR * MgrEpv
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterIfEx (
    __in RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR * MgrTypeUuid,
    __in_opt RPC_MGR_EPV __RPC_FAR * MgrEpv,
    __in unsigned int Flags,
    __in unsigned int MaxCalls,
    __in_opt RPC_IF_CALLBACK_FN __RPC_FAR *IfCallback
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterIf2 (
    __in RPC_IF_HANDLE IfSpec,
    __in_opt UUID * MgrTypeUuid,
    __in_opt RPC_MGR_EPV * MgrEpv,
    __in unsigned int Flags,
    __in unsigned int MaxCalls,
    __in unsigned int MaxRpcSize,
    __in_opt RPC_IF_CALLBACK_FN *IfCallbackFn
    );


/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUnregisterIf (
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR * MgrTypeUuid,
    __in unsigned int WaitForCallsToComplete
    );

#if (NTDDI_VERSION >= NTDDI_WINXP)
/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUnregisterIfEx (
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR * MgrTypeUuid,
    __in int RundownContextHandles
    );
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqs (
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqsEx (
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqsIf (
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseAllProtseqsIfEx (
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );


/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqA (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqExA (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqW (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqExW (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

#ifdef UNICODE
#define RpcServerUseProtseq RpcServerUseProtseqW
#define RpcServerUseProtseqEx RpcServerUseProtseqExW
#else /* UNICODE */
#define RpcServerUseProtseq RpcServerUseProtseqA
#define RpcServerUseProtseqEx RpcServerUseProtseqExA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseq (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEx (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpA (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_CSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpExA (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_CSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpW (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_WSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpExW (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_WSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

#ifdef UNICODE
#define RpcServerUseProtseqEp RpcServerUseProtseqEpW
#define RpcServerUseProtseqEpEx RpcServerUseProtseqEpExW
#else /* UNICODE */
#define RpcServerUseProtseqEp RpcServerUseProtseqEpA
#define RpcServerUseProtseqEpEx RpcServerUseProtseqEpExA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEp (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_CSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqEpEx (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_WSTR Endpoint,
    __in void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* server */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfA (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfExA (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfW (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfExW (
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

#ifdef UNICODE
#define RpcServerUseProtseqIf RpcServerUseProtseqIfW
#define RpcServerUseProtseqIfEx RpcServerUseProtseqIfExW
#else /* UNICODE */
#define RpcServerUseProtseqIf RpcServerUseProtseqIfA
#define RpcServerUseProtseqIfEx RpcServerUseProtseqIfExA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIf (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in_opt void __RPC_FAR * SecurityDescriptor
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerUseProtseqIfEx (
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_IF_HANDLE IfSpec,
    __in void __RPC_FAR * SecurityDescriptor,
    __in PRPC_POLICY Policy
    );

#endif /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
void
RPC_ENTRY
RpcServerYield (
    void
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtStatsVectorFree (
    __inout RPC_STATS_VECTOR ** StatsVector
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqStats (
    __in_opt RPC_BINDING_HANDLE Binding,
    __deref_out RPC_STATS_VECTOR ** Statistics
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtIsServerListening (
    __in_opt RPC_BINDING_HANDLE Binding
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtStopServerListening (
    __in_opt RPC_BINDING_HANDLE Binding
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtWaitServerListen (
    void
    );

/* server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetServerStackSize (
    __in unsigned long ThreadStackSize
    );

/* server */
RPCRTAPI
void
RPC_ENTRY
RpcSsDontSerializeContext (
    void
    );

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEnableIdleCleanup (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqIfIds (
    __in_opt RPC_BINDING_HANDLE Binding,
    __deref_out RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcIfIdVectorFree (
    __deref_inout RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqServerPrincNameA (
    __in_opt RPC_BINDING_HANDLE Binding,
    __in unsigned long AuthnSvc,
    __deref_out RPC_CSTR __RPC_FAR * ServerPrincName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqServerPrincNameW (
    __in_opt RPC_BINDING_HANDLE Binding,
    __in unsigned long AuthnSvc,
    __deref_out RPC_WSTR __RPC_FAR * ServerPrincName
    );

#ifdef UNICODE
#define RpcMgmtInqServerPrincName RpcMgmtInqServerPrincNameW
#else /* UNICODE */
#define RpcMgmtInqServerPrincName RpcMgmtInqServerPrincNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtInqServerPrincName (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long AuthnSvc,
    __deref_out RPC_WSTR __RPC_FAR * ServerPrincName
    );

#endif /* RPC_UNICODE_SUPPORTED */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqDefaultPrincNameA (
    __in unsigned long AuthnSvc,
    __deref_out RPC_CSTR __RPC_FAR * PrincName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqDefaultPrincNameW (
    __in unsigned long AuthnSvc,
    __deref_out RPC_WSTR __RPC_FAR * PrincName
    );

#ifdef UNICODE
#define RpcServerInqDefaultPrincName RpcServerInqDefaultPrincNameW
#else /* UNICODE */
#define RpcServerInqDefaultPrincName RpcServerInqDefaultPrincNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqDefaultPrincName (
    __in unsigned long AuthnSvc,
    __deref_out RPC_WSTR __RPC_FAR * PrincName
    );

#endif /* RPC_UNICODE_SUPPORTED */

/* client */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpResolveBinding (
    __in RPC_BINDING_HANDLE Binding,
    __in RPC_IF_HANDLE IfSpec
    );

/* client */

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNsBindingInqEntryNameA (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long EntryNameSyntax,
    __deref_out RPC_CSTR __RPC_FAR * EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNsBindingInqEntryNameW (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long EntryNameSyntax,
    __deref_out RPC_WSTR __RPC_FAR * EntryName
    );

#ifdef UNICODE
#define RpcNsBindingInqEntryName RpcNsBindingInqEntryNameW
#else /* UNICODE */
#define RpcNsBindingInqEntryName RpcNsBindingInqEntryNameA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcNsBindingInqEntryName (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long EntryNameSyntax,
    __deref_out RPC_CSTR __RPC_FAR * EntryName
    );

#endif /* RPC_UNICODE_SUPPORTED */

typedef void __RPC_FAR * RPC_AUTH_IDENTITY_HANDLE;
typedef void __RPC_FAR * RPC_AUTHZ_HANDLE;

#define RPC_C_AUTHN_LEVEL_DEFAULT       0
#define RPC_C_AUTHN_LEVEL_NONE          1
#define RPC_C_AUTHN_LEVEL_CONNECT       2
#define RPC_C_AUTHN_LEVEL_CALL          3
#define RPC_C_AUTHN_LEVEL_PKT           4
#define RPC_C_AUTHN_LEVEL_PKT_INTEGRITY 5
#define RPC_C_AUTHN_LEVEL_PKT_PRIVACY   6

#define RPC_C_IMP_LEVEL_DEFAULT      0
#define RPC_C_IMP_LEVEL_ANONYMOUS    1
#define RPC_C_IMP_LEVEL_IDENTIFY     2
#define RPC_C_IMP_LEVEL_IMPERSONATE  3
#define RPC_C_IMP_LEVEL_DELEGATE     4

#define RPC_C_QOS_IDENTITY_STATIC    0
#define RPC_C_QOS_IDENTITY_DYNAMIC   1

#define RPC_C_QOS_CAPABILITIES_DEFAULT                        0x0
#define RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH                    0x1
#define RPC_C_QOS_CAPABILITIES_MAKE_FULLSIC                   0x2
#define RPC_C_QOS_CAPABILITIES_ANY_AUTHORITY                  0x4

#if (NTDDI_VERSION >= NTDDI_WS03)
#define RPC_C_QOS_CAPABILITIES_IGNORE_DELEGATE_FAILURE        0x8
#define RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT                 0x10
#endif // (NTDDI_VERSION >= NTDDI_WS03)

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_C_QOS_CAPABILITIES_SCHANNEL_FULL_AUTH_IDENTITY   0x20
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define RPC_C_PROTECT_LEVEL_DEFAULT       (RPC_C_AUTHN_LEVEL_DEFAULT)
#define RPC_C_PROTECT_LEVEL_NONE          (RPC_C_AUTHN_LEVEL_NONE)
#define RPC_C_PROTECT_LEVEL_CONNECT       (RPC_C_AUTHN_LEVEL_CONNECT)
#define RPC_C_PROTECT_LEVEL_CALL          (RPC_C_AUTHN_LEVEL_CALL)
#define RPC_C_PROTECT_LEVEL_PKT           (RPC_C_AUTHN_LEVEL_PKT)
#define RPC_C_PROTECT_LEVEL_PKT_INTEGRITY (RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
#define RPC_C_PROTECT_LEVEL_PKT_PRIVACY   (RPC_C_AUTHN_LEVEL_PKT_PRIVACY)

#define RPC_C_AUTHN_NONE          0
#define RPC_C_AUTHN_DCE_PRIVATE   1
#define RPC_C_AUTHN_DCE_PUBLIC    2
#define RPC_C_AUTHN_DEC_PUBLIC    4
#define RPC_C_AUTHN_GSS_NEGOTIATE 9
#define RPC_C_AUTHN_WINNT        10
#define RPC_C_AUTHN_GSS_SCHANNEL 14
#define RPC_C_AUTHN_GSS_KERBEROS 16
#define RPC_C_AUTHN_DPA          17
#define RPC_C_AUTHN_MSN          18
#if (NTDDI_VERSION >= WINXP)
#define RPC_C_AUTHN_DIGEST       21
#endif // (NTDDI_VERSION >= WINXP)
#if (NTDDI_VERSION >= NTDDI_WIN7)
#define RPC_C_AUTHN_KERNEL         20
#endif // (NTDDI_VERSION >= NTDDI_WIN7)

#define RPC_C_AUTHN_NEGO_EXTENDER 30
#define RPC_C_AUTHN_PKU2U         31

#define RPC_C_AUTHN_MQ          100
#define RPC_C_AUTHN_DEFAULT     0xFFFFFFFFL

#define RPC_C_NO_CREDENTIALS ((RPC_AUTH_IDENTITY_HANDLE) MAXUINT_PTR)

#define RPC_C_SECURITY_QOS_VERSION      1L
#define RPC_C_SECURITY_QOS_VERSION_1    1L

typedef struct _RPC_SECURITY_QOS {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
} RPC_SECURITY_QOS, *PRPC_SECURITY_QOS;

#ifndef _AUTH_IDENTITY_DEFINED
#define _AUTH_IDENTITY_DEFINED

#define SEC_WINNT_AUTH_IDENTITY_ANSI    0x1
#define SEC_WINNT_AUTH_IDENTITY_UNICODE 0x2

typedef struct _SEC_WINNT_AUTH_IDENTITY_W {
  __field_bcount((UserLength+1)*sizeof(WCHAR)) unsigned short __RPC_FAR *User;
  unsigned long UserLength;
  __field_bcount((DomainLength+1)*sizeof(WCHAR)) unsigned short __RPC_FAR *Domain;
  unsigned long DomainLength;
  __field_bcount((PasswordLength+1)*sizeof(WCHAR)) unsigned short __RPC_FAR *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_W, *PSEC_WINNT_AUTH_IDENTITY_W;

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define _AUTH_IDENTITY_A_DEFINED
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

typedef struct _SEC_WINNT_AUTH_IDENTITY_A {
  __field_ecount(UserLength+1) unsigned char __RPC_FAR *User;
  unsigned long UserLength;
  __field_ecount(DomainLength+1) unsigned char __RPC_FAR *Domain;
  unsigned long DomainLength;
  __field_ecount(PasswordLength+1) unsigned char __RPC_FAR *Password;
  unsigned long PasswordLength;
  unsigned long Flags;
} SEC_WINNT_AUTH_IDENTITY_A, *PSEC_WINNT_AUTH_IDENTITY_A;

#ifdef UNICODE
#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_W
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_W
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_W
#else // UNICODE
#define SEC_WINNT_AUTH_IDENTITY SEC_WINNT_AUTH_IDENTITY_A
#define PSEC_WINNT_AUTH_IDENTITY PSEC_WINNT_AUTH_IDENTITY_A
#define _SEC_WINNT_AUTH_IDENTITY _SEC_WINNT_AUTH_IDENTITY_A
#endif // UNICODE

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define RPC_C_SECURITY_QOS_VERSION_2 2L

#define RPC_C_AUTHN_INFO_TYPE_HTTP                  1

#define RPC_C_HTTP_AUTHN_TARGET_SERVER              1
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_C_HTTP_AUTHN_TARGET_PROXY               2
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define RPC_C_HTTP_AUTHN_SCHEME_BASIC      0x00000001
#define RPC_C_HTTP_AUTHN_SCHEME_NTLM       0x00000002
#define RPC_C_HTTP_AUTHN_SCHEME_PASSPORT   0x00000004
#define RPC_C_HTTP_AUTHN_SCHEME_DIGEST     0x00000008
#define RPC_C_HTTP_AUTHN_SCHEME_NEGOTIATE  0x00000010
#if (NTDDI_VERSION >= NTDDI_WS03)
#define RPC_C_HTTP_AUTHN_SCHEME_CERT       0x00010000
// 0x00020000 & 0x00040000 are reserved
#endif // (NTDDI_VERSION >= NTDDI_WS03)

#define RPC_C_HTTP_FLAG_USE_SSL                     1
#define RPC_C_HTTP_FLAG_USE_FIRST_AUTH_SCHEME       2
#if (NTDDI_VERSION >= NTDDI_WS03)
#define RPC_C_HTTP_FLAG_IGNORE_CERT_CN_INVALID      8
#endif // (NTDDI_VERSION >= NTDDI_WS03)
#if (NTDDI_VERSION >= NTDDI_VISTASP1)
#define RPC_C_HTTP_FLAG_ENABLE_CERT_REVOCATION_CHECK 16
#endif // (NTDDI_VERSION >= NTDDI_VISTASP1)


typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_W
{
    SEC_WINNT_AUTH_IDENTITY_W *TransportCredentials;
    unsigned long Flags;
    unsigned long AuthenticationTarget;
    unsigned long NumberOfAuthnSchemes;
    unsigned long *AuthnSchemes;
    unsigned short __RPC_FAR *ServerCertificateSubject;
} RPC_HTTP_TRANSPORT_CREDENTIALS_W, *PRPC_HTTP_TRANSPORT_CREDENTIALS_W;

typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_A
{
    SEC_WINNT_AUTH_IDENTITY_A *TransportCredentials;
    unsigned long Flags;
    unsigned long AuthenticationTarget;
    unsigned long NumberOfAuthnSchemes;
    unsigned long *AuthnSchemes;
    unsigned char __RPC_FAR *ServerCertificateSubject;
} RPC_HTTP_TRANSPORT_CREDENTIALS_A, *PRPC_HTTP_TRANSPORT_CREDENTIALS_A;

#if (NTDDI_VERSION >= NTDDI_VISTA)

typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W
{
    SEC_WINNT_AUTH_IDENTITY_W *TransportCredentials;
    unsigned long Flags;
    unsigned long AuthenticationTarget;
    unsigned long NumberOfAuthnSchemes;
    __field_ecount(NumberOfAuthnSchemes) unsigned long *AuthnSchemes;
    unsigned short __RPC_FAR *ServerCertificateSubject;
    SEC_WINNT_AUTH_IDENTITY_W *ProxyCredentials;
    unsigned long NumberOfProxyAuthnSchemes;
    __field_ecount(NumberOfProxyAuthnSchemes) unsigned long *ProxyAuthnSchemes;
} RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W, *PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_W;

typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A
{
    SEC_WINNT_AUTH_IDENTITY_A *TransportCredentials;
    unsigned long Flags;
    unsigned long AuthenticationTarget;
    unsigned long NumberOfAuthnSchemes;
    unsigned long *AuthnSchemes;
    unsigned char __RPC_FAR *ServerCertificateSubject;
    SEC_WINNT_AUTH_IDENTITY_A *ProxyCredentials;
    unsigned long NumberOfProxyAuthnSchemes;
    unsigned long *ProxyAuthnSchemes;
} RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A, *PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_A;

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WIN7)

typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W
{
    RPC_AUTH_IDENTITY_HANDLE TransportCredentials;
    unsigned long Flags;
    unsigned long AuthenticationTarget;
    unsigned long NumberOfAuthnSchemes;
    __field_ecount(NumberOfAuthnSchemes) unsigned long *AuthnSchemes;
    unsigned short __RPC_FAR *ServerCertificateSubject;
    RPC_AUTH_IDENTITY_HANDLE ProxyCredentials;
    unsigned long NumberOfProxyAuthnSchemes;
    __field_ecount(NumberOfProxyAuthnSchemes) unsigned long *ProxyAuthnSchemes;
} RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W, *PRPC_HTTP_TRANSPORT_CREDENTIALS_V3_W;

typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A
{
    RPC_AUTH_IDENTITY_HANDLE TransportCredentials;
    unsigned long Flags;
    unsigned long AuthenticationTarget;
    unsigned long NumberOfAuthnSchemes;
    __field_ecount(NumberOfAuthnSchemes) unsigned long *AuthnSchemes;
    unsigned char __RPC_FAR *ServerCertificateSubject;
    RPC_AUTH_IDENTITY_HANDLE ProxyCredentials;
    unsigned long NumberOfProxyAuthnSchemes;
    __field_ecount(NumberOfProxyAuthnSchemes) unsigned long *ProxyAuthnSchemes;
} RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A, *PRPC_HTTP_TRANSPORT_CREDENTIALS_V3_A;

#endif // (NTDDI_VERSION >= NTDDI_WIN7)

typedef struct _RPC_SECURITY_QOS_V2_W {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials;
      } u;
} RPC_SECURITY_QOS_V2_W, *PRPC_SECURITY_QOS_V2_W;

typedef struct _RPC_SECURITY_QOS_V2_A {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_A *HttpCredentials;
      } u;
} RPC_SECURITY_QOS_V2_A, *PRPC_SECURITY_QOS_V2_A;

#if (NTDDI_VERSION >= NTDDI_WS03)
#define RPC_C_SECURITY_QOS_VERSION_3 3L

typedef struct _RPC_SECURITY_QOS_V3_W {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials;
      } u;
  void *Sid;
} RPC_SECURITY_QOS_V3_W, *PRPC_SECURITY_QOS_V3_W;

typedef struct _RPC_SECURITY_QOS_V3_A {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_A *HttpCredentials;
      } u;
  void *Sid;
} RPC_SECURITY_QOS_V3_A, *PRPC_SECURITY_QOS_V3_A;
#endif // (NTDDI_VERSION >= NTDDI_WS03)

#if (NTDDI_VERSION >= NTDDI_VISTA)

#define RPC_C_SECURITY_QOS_VERSION_4 4L

typedef struct _RPC_SECURITY_QOS_V4_W {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials;
      } u;
  void *Sid;
  unsigned int EffectiveOnly;
} RPC_SECURITY_QOS_V4_W, *PRPC_SECURITY_QOS_V4_W;

typedef struct _RPC_SECURITY_QOS_V4_A {
  unsigned long Version;
  unsigned long Capabilities;
  unsigned long IdentityTracking;
  unsigned long ImpersonationType;
  unsigned long AdditionalSecurityInfoType;
  union 
      {
      RPC_HTTP_TRANSPORT_CREDENTIALS_A *HttpCredentials;
      } u;
  void *Sid;
  unsigned int EffectiveOnly;
} RPC_SECURITY_QOS_V4_A, *PRPC_SECURITY_QOS_V4_A;

#endif // NTDDI_WINXP
#endif // _AUTH_IDENTITY_DEFINED 
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#if (NTDDI_VERSION >= WINXP)

#ifdef UNICODE

#define RPC_SECURITY_QOS_V2 RPC_SECURITY_QOS_V2_W
#define PRPC_SECURITY_QOS_V2 PRPC_SECURITY_QOS_V2_W
#define _RPC_SECURITY_QOS_V2 _RPC_SECURITY_QOS_V2_W

#define RPC_HTTP_TRANSPORT_CREDENTIALS RPC_HTTP_TRANSPORT_CREDENTIALS_W
#define PRPC_HTTP_TRANSPORT_CREDENTIALS PRPC_HTTP_TRANSPORT_CREDENTIALS_W
#define _RPC_HTTP_TRANSPORT_CREDENTIALS _RPC_HTTP_TRANSPORT_CREDENTIALS_W

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_HTTP_TRANSPORT_CREDENTIALS_V2 RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W
#define PRPC_HTTP_TRANSPORT_CREDENTIALS_V2 PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_W
#define _RPC_HTTP_TRANSPORT_CREDENTIALS_V2 _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WIN7)
#define RPC_HTTP_TRANSPORT_CREDENTIALS_V3 RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W
#define PRPC_HTTP_TRANSPORT_CREDENTIALS_V3 PRPC_HTTP_TRANSPORT_CREDENTIALS_V3_W
#define _RPC_HTTP_TRANSPORT_CREDENTIALS_V3 _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W
#endif // (NTDDI_VERSION >= NTDDI_WIN7)

#if (NTDDI_VERSION >= NTDDI_WS03)
#define RPC_SECURITY_QOS_V3 RPC_SECURITY_QOS_V3_W
#define PRPC_SECURITY_QOS_V3 PRPC_SECURITY_QOS_V3_W
#define _RPC_SECURITY_QOS_V3 _RPC_SECURITY_QOS_V3_W
#endif // (NTDDI_VERSION >= NTDDI_WS03)

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_SECURITY_QOS_V4 RPC_SECURITY_QOS_V4_W
#define PRPC_SECURITY_QOS_V4 PRPC_SECURITY_QOS_V4_W
#define _RPC_SECURITY_QOS_V4 _RPC_SECURITY_QOS_V4_W
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#else // UNICODE

#define RPC_SECURITY_QOS_V2 RPC_SECURITY_QOS_V2_A
#define PRPC_SECURITY_QOS_V2 PRPC_SECURITY_QOS_V2_A
#define _RPC_SECURITY_QOS_V2 _RPC_SECURITY_QOS_V2_A

#define RPC_HTTP_TRANSPORT_CREDENTIALS RPC_HTTP_TRANSPORT_CREDENTIALS_A
#define PRPC_HTTP_TRANSPORT_CREDENTIALS PRPC_HTTP_TRANSPORT_CREDENTIALS_A
#define _RPC_HTTP_TRANSPORT_CREDENTIALS _RPC_HTTP_TRANSPORT_CREDENTIALS_A

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_HTTP_TRANSPORT_CREDENTIALS_V2 RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A
#define PRPC_HTTP_TRANSPORT_CREDENTIALS_V2 PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_A
#define _RPC_HTTP_TRANSPORT_CREDENTIALS_V2 _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WIN7)
#define RPC_HTTP_TRANSPORT_CREDENTIALS_V3 RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A
#define PRPC_HTTP_TRANSPORT_CREDENTIALS_V3 PRPC_HTTP_TRANSPORT_CREDENTIALS_V3_A
#define _RPC_HTTP_TRANSPORT_CREDENTIALS_V3 _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A
#endif // (NTDDI_VERSION >= NTDDI_WIN7)

#if (NTDDI_VERSION >= NTDDI_WS03)
#define RPC_SECURITY_QOS_V3 RPC_SECURITY_QOS_V3_A
#define PRPC_SECURITY_QOS_V3 PRPC_SECURITY_QOS_V3_A
#define _RPC_SECURITY_QOS_V3 _RPC_SECURITY_QOS_V3_A
#endif // (NTDDI_VERSION >= NTDDI_WS03)

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_SECURITY_QOS_V4 RPC_SECURITY_QOS_V4_A
#define PRPC_SECURITY_QOS_V4 PRPC_SECURITY_QOS_V4_A
#define _RPC_SECURITY_QOS_V4 _RPC_SECURITY_QOS_V4_A
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#endif // UNICODE

#if (NTDDI_VERSION >= NTDDI_VISTA)

#define RPC_PROTSEQ_TCP                             (0x1)
#define RPC_PROTSEQ_NMP                             (0x2)
#define RPC_PROTSEQ_LRPC                            (0x3)
#define RPC_PROTSEQ_HTTP                            (0x4)

#define RPC_BHT_OBJECT_UUID_VALID                   (0x1)

#define RPC_BHO_NONCAUSAL                           (0x1)
#define RPC_BHO_DONTLINGER                          (0x2)
#define RPC_BHO_EXCLUSIVE_AND_GUARANTEED            (0x4)

typedef struct _RPC_BINDING_HANDLE_TEMPLATE_V1_W {
    unsigned long Version;
    unsigned long Flags;
    unsigned long ProtocolSequence;
    unsigned short *NetworkAddress;
    unsigned short *StringEndpoint;
    union
    {
        unsigned short *Reserved;
    } u1;
    UUID ObjectUuid;
} RPC_BINDING_HANDLE_TEMPLATE_V1_W, *PRPC_BINDING_HANDLE_TEMPLATE_V1_W;

typedef struct _RPC_BINDING_HANDLE_TEMPLATE_V1_A {
    unsigned long Version;
    unsigned long Flags;
    unsigned long ProtocolSequence;
    unsigned char *NetworkAddress;
    unsigned char *StringEndpoint;
    union
    {
        unsigned char *Reserved;
    } u1;
    UUID ObjectUuid;
} RPC_BINDING_HANDLE_TEMPLATE_V1_A, *PRPC_BINDING_HANDLE_TEMPLATE_V1_A;

typedef struct _RPC_BINDING_HANDLE_SECURITY_V1_W {
    unsigned long Version;
    unsigned short *ServerPrincName;
    unsigned long AuthnLevel;
    unsigned long AuthnSvc;
    SEC_WINNT_AUTH_IDENTITY_W *AuthIdentity;
    RPC_SECURITY_QOS *SecurityQos;
} RPC_BINDING_HANDLE_SECURITY_V1_W, *PRPC_BINDING_HANDLE_SECURITY_V1_W;

#ifdef _AUTH_IDENTITY_A_DEFINED

typedef struct _RPC_BINDING_HANDLE_SECURITY_V1_A {
    unsigned long Version;
    unsigned char *ServerPrincName;
    unsigned long AuthnLevel;
    unsigned long AuthnSvc;
    SEC_WINNT_AUTH_IDENTITY_A *AuthIdentity;
    RPC_SECURITY_QOS *SecurityQos;
} RPC_BINDING_HANDLE_SECURITY_V1_A, *PRPC_BINDING_HANDLE_SECURITY_V1_A;

#endif // _AUTH_IDENTITY_A_DEFINED

typedef struct _RPC_BINDING_HANDLE_OPTIONS_V1 {
    unsigned long Version;
    unsigned long Flags;
    unsigned long ComTimeout;
    unsigned long CallTimeout;
} RPC_BINDING_HANDLE_OPTIONS_V1, *PRPC_BINDING_HANDLE_OPTIONS_V1;

#ifdef UNICODE

#define RPC_BINDING_HANDLE_TEMPLATE_V1 RPC_BINDING_HANDLE_TEMPLATE_V1_W
#define PRPC_BINDING_HANDLE_TEMPLATE_V1 PRPC_BINDING_HANDLE_TEMPLATE_V1_W
#define _RPC_BINDING_HANDLE_TEMPLATE_V1 _RPC_BINDING_HANDLE_TEMPLATE_V1_W

#define RPC_BINDING_HANDLE_SECURITY_V1 RPC_BINDING_HANDLE_SECURITY_V1_W
#define PRPC_BINDING_HANDLE_SECURITY_V1 PRPC_BINDING_HANDLE_SECURITY_V1_W
#define _RPC_BINDING_HANDLE_SECURITY_V1 _RPC_BINDING_HANDLE_SECURITY_V1_W

#else

#define RPC_BINDING_HANDLE_TEMPLATE_V1 RPC_BINDING_HANDLE_TEMPLATE_V1_A
#define PRPC_BINDING_HANDLE_TEMPLATE_V1 PRPC_BINDING_HANDLE_TEMPLATE_V1_A
#define _RPC_BINDING_HANDLE_TEMPLATE_V1 _RPC_BINDING_HANDLE_TEMPLATE_V1_A

#define RPC_BINDING_HANDLE_SECURITY_V1 RPC_BINDING_HANDLE_SECURITY_V1_A
#define PRPC_BINDING_HANDLE_SECURITY_V1 PRPC_BINDING_HANDLE_SECURITY_V1_A
#define _RPC_BINDING_HANDLE_SECURITY_V1 _RPC_BINDING_HANDLE_SECURITY_V1_A

#endif // !UNICODE

#ifdef _AUTH_IDENTITY_A_DEFINED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingCreateA (
    __in RPC_BINDING_HANDLE_TEMPLATE_V1_A * Template,
    __in_opt RPC_BINDING_HANDLE_SECURITY_V1_A * Security,
    __in_opt RPC_BINDING_HANDLE_OPTIONS_V1 * Options,
    __out RPC_BINDING_HANDLE * Binding
    );

#endif // _AUTH_IDENTITY_A_DEFINED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingCreateW (
    __in RPC_BINDING_HANDLE_TEMPLATE_V1_W * Template,
    __in_opt RPC_BINDING_HANDLE_SECURITY_V1_W * Security,
    __in_opt RPC_BINDING_HANDLE_OPTIONS_V1 * Options,
    __out RPC_BINDING_HANDLE * Binding
    );

#ifdef UNICODE
#define RpcBindingCreate RpcBindingCreateW
#else /* UNICODE */
#define RpcBindingCreate RpcBindingCreateA
#endif /* UNICODE */

RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcBindingGetTrainingContextHandle (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out void ** ContextHandle
    );

RPCRTAPI
RPC_STATUS 
RPC_ENTRY 
RpcServerInqBindingHandle (
    __out RPC_BINDING_HANDLE * Binding
    );
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WS03)
typedef enum _RPC_HTTP_REDIRECTOR_STAGE
{
    RPCHTTP_RS_REDIRECT = 1,
    RPCHTTP_RS_ACCESS_1,
    RPCHTTP_RS_SESSION,
    RPCHTTP_RS_ACCESS_2,
    RPCHTTP_RS_INTERFACE
} RPC_HTTP_REDIRECTOR_STAGE;
#endif // (NTDDI_VERSION >= NTDDI_WS03)

#if (NTDDI_VERSION >= NTDDI_WS03)
typedef RPC_STATUS
(__RPC_USER * RPC_NEW_HTTP_PROXY_CHANNEL) (
    __in RPC_HTTP_REDIRECTOR_STAGE RedirectorStage,
    __in RPC_WSTR ServerName,
    __in RPC_WSTR ServerPort,
    __in_opt RPC_WSTR RemoteUser,
    __in_opt RPC_WSTR AuthType,
    __inout void __RPC_FAR * ResourceUuid,
    __inout void __RPC_FAR * SessionId,
    __in_opt void __RPC_FAR * Interface,
    __in_opt void __RPC_FAR * Reserved,
    __in unsigned long Flags,
    __deref_opt_out RPC_WSTR __RPC_FAR * NewServerName,
    __deref_opt_out RPC_WSTR __RPC_FAR * NewServerPort
    );
    
#else

typedef RPC_STATUS
(__RPC_USER * RPC_NEW_HTTP_PROXY_CHANNEL) (
    __in unsigned short __RPC_FAR *ServerName,
    __in unsigned short __RPC_FAR *ServerPort,
    __in unsigned char __RPC_FAR *RemoteUser,
    __out unsigned short __RPC_FAR **NewServerName
    );
#endif // (NTDDI_VERSION >= NTDDI_WS03)

typedef void
(__RPC_USER * RPC_HTTP_PROXY_FREE_STRING) (
    __in RPC_WSTR String
    );
#endif // (NTDDI_VERSION >= NTDDI_WINXP) 

#define RPC_C_AUTHZ_NONE    0
#define RPC_C_AUTHZ_NAME    1
#define RPC_C_AUTHZ_DCE     2
#define RPC_C_AUTHZ_DEFAULT 0xffffffff

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcImpersonateClient (
    __in_opt RPC_BINDING_HANDLE BindingHandle
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcRevertToSelfEx (
    __in_opt RPC_BINDING_HANDLE BindingHandle
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcRevertToSelf (
    void
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientA (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    __deref_opt_out RPC_CSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt unsigned long __RPC_FAR * AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientW (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    __deref_opt_out RPC_WSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt unsigned long __RPC_FAR * AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientExA (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    __deref_opt_out RPC_CSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt unsigned long __RPC_FAR * AuthzSvc,
    __in  unsigned long             Flags
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientExW (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    __deref_opt_out RPC_WSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt unsigned long __RPC_FAR * AuthzSvc,
    __in  unsigned long             Flags
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoA (
    __in RPC_BINDING_HANDLE Binding,
    __deref_opt_out RPC_CSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity,
    __out_opt unsigned long __RPC_FAR * AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoW (
    __in RPC_BINDING_HANDLE Binding,
    __deref_opt_out RPC_WSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity,
    __out_opt unsigned long __RPC_FAR * AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoA (
    __in RPC_BINDING_HANDLE Binding,
    __in_opt RPC_CSTR ServerPrincName,
    __in unsigned long AuthnLevel,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    __in unsigned long AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoExA (
    __in RPC_BINDING_HANDLE Binding,
    __in_opt RPC_CSTR ServerPrincName,
    __in unsigned long AuthnLevel,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    __in unsigned long AuthzSvc,
    __in_opt RPC_SECURITY_QOS * SecurityQos
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoW (
    __in RPC_BINDING_HANDLE Binding,
    __in_opt RPC_WSTR ServerPrincName,
    __in unsigned long AuthnLevel,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    __in unsigned long AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfoExW (
    __in RPC_BINDING_HANDLE Binding,
    __in_opt RPC_WSTR ServerPrincName,
    __in unsigned long AuthnLevel,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    __in_opt unsigned long AuthzSvc,
    __in_opt RPC_SECURITY_QOS * SecurityQOS
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoExA (
    __in RPC_BINDING_HANDLE Binding,
    __deref_opt_out RPC_CSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity,
    __out_opt unsigned long __RPC_FAR * AuthzSvc,
    __in  unsigned long RpcQosVersion,
    __out_opt RPC_SECURITY_QOS *SecurityQOS
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfoExW (
    __in RPC_BINDING_HANDLE Binding,
    __deref_opt_out RPC_WSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity,
    __out_opt unsigned long __RPC_FAR * AuthzSvc,
    __in_opt  unsigned long RpcQosVersion,
    __out_opt RPC_SECURITY_QOS * SecurityQOS
    );

typedef void
(__RPC_USER * RPC_AUTH_KEY_RETRIEVAL_FN) (
    __in void __RPC_FAR * Arg,
    __in RPC_WSTR ServerPrincName,
    __in unsigned long KeyVer,
    __deref_out void __RPC_FAR * __RPC_FAR * Key,
    __out RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY 
RpcServerCompleteSecurityCallback(
    __in RPC_BINDING_HANDLE BindingHandle,
    __in RPC_STATUS Status
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterAuthInfoA (
    __in_opt RPC_CSTR ServerPrincName,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn,
    __in_opt void __RPC_FAR * Arg
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterAuthInfoW (
    __in_opt RPC_WSTR ServerPrincName,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn,
    __in_opt void __RPC_FAR * Arg
    );

#ifdef UNICODE
#define RpcBindingInqAuthClient RpcBindingInqAuthClientW
#define RpcBindingInqAuthClientEx RpcBindingInqAuthClientExW
#define RpcBindingInqAuthInfo RpcBindingInqAuthInfoW
#define RpcBindingSetAuthInfo RpcBindingSetAuthInfoW
#define RpcServerRegisterAuthInfo RpcServerRegisterAuthInfoW
#define RpcBindingInqAuthInfoEx RpcBindingInqAuthInfoExW
#define RpcBindingSetAuthInfoEx RpcBindingSetAuthInfoExW
#else /* UNICODE */
#define RpcBindingInqAuthClient RpcBindingInqAuthClientA
#define RpcBindingInqAuthClientEx RpcBindingInqAuthClientExA
#define RpcBindingInqAuthInfo RpcBindingInqAuthInfoA
#define RpcBindingSetAuthInfo RpcBindingSetAuthInfoA
#define RpcServerRegisterAuthInfo RpcServerRegisterAuthInfoA
#define RpcBindingInqAuthInfoEx RpcBindingInqAuthInfoExA
#define RpcBindingSetAuthInfoEx RpcBindingSetAuthInfoExA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClient (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    __deref_opt_out RPC_WSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt unsigned long __RPC_FAR * AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthClientEx (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
    __deref_opt_out RPC_CSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt unsigned long __RPC_FAR * AuthzSvc,
    __in  unsigned long             Flags
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingInqAuthInfo (
    __in RPC_BINDING_HANDLE Binding,
    __deref_opt_out RPC_CSTR __RPC_FAR * ServerPrincName,
    __out_opt unsigned long __RPC_FAR * AuthnLevel,
    __out_opt unsigned long __RPC_FAR * AuthnSvc,
    __out_opt RPC_AUTH_IDENTITY_HANDLE __RPC_FAR * AuthIdentity,
    __out_opt unsigned long __RPC_FAR * AuthzSvc
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingSetAuthInfo (
    __in RPC_BINDING_HANDLE Binding,
    __in RPC_CSTR ServerPrincName,
    __in unsigned long AuthnLevel,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    __in unsigned long AuthzSvc
    );

typedef void
(__RPC_USER * RPC_AUTH_KEY_RETRIEVAL_FN) (
    __in void __RPC_FAR * Arg,
    __in unsigned char __RPC_FAR * ServerPrincName,
    __in unsigned long KeyVer,
    __out void __RPC_FAR * __RPC_FAR * Key,
    __out RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerRegisterAuthInfo (
    __in RPC_CSTR ServerPrincName,
    __in unsigned long AuthnSvc,
    __in_opt RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn,
    __in_opt OPTIONAL void __RPC_FAR * Arg
    );

#endif /* RPC_UNICODE_SUPPORTED */

#if (NTDDI_VERSION >= NTDDI_WINXP)
#if !defined(_M_IA64)
typedef struct {
    unsigned char __RPC_FAR * UserName;
    unsigned char __RPC_FAR * ComputerName;
    unsigned short Privilege;
    unsigned long AuthFlags;
} RPC_CLIENT_INFORMATION1, __RPC_FAR * PRPC_CLIENT_INFORMATION1;
#endif 
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcBindingServerFromClient (
    __in_opt RPC_BINDING_HANDLE ClientBinding,
    __out RPC_BINDING_HANDLE __RPC_FAR * ServerBinding
    );

RPCRTAPI
DECLSPEC_NORETURN
void
RPC_ENTRY
RpcRaiseException (
    __in RPC_STATUS exception
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcTestCancel(
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerTestCancel (
    __in_opt RPC_BINDING_HANDLE BindingHandle
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcCancelThread(
    __in void * Thread
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcCancelThreadEx(
    __in void * Thread,
    __in long Timeout
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidCreate (
    __out UUID __RPC_FAR * Uuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidCreateSequential (
    __out UUID __RPC_FAR * Uuid
    );

#ifdef RPC_UNICODE_SUPPORTED

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidToStringA (
    __in const UUID __RPC_FAR * Uuid,
    __deref_out RPC_CSTR __RPC_FAR * StringUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidFromStringA (
    __in_opt RPC_CSTR StringUuid,
    __out UUID __RPC_FAR * Uuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidToStringW (
    __in const UUID __RPC_FAR * Uuid,
    __deref_out RPC_WSTR __RPC_FAR * StringUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidFromStringW (
    __in_opt RPC_WSTR StringUuid,
    __out UUID __RPC_FAR * Uuid
    );

#ifdef UNICODE
#define UuidFromString UuidFromStringW
#define UuidToString UuidToStringW
#else /* UNICODE */
#define UuidFromString UuidFromStringA
#define UuidToString UuidToStringA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidToString (
    __in const UUID __RPC_FAR * Uuid,
    __deref_out RPC_CSTR __RPC_FAR * StringUuid
    );

/* client/server */
RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidFromString (
    __in_opt RPC_CSTR StringUuid,
    __out UUID __RPC_FAR * Uuid
    );

#endif /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
signed int
RPC_ENTRY
UuidCompare (
    __in UUID __RPC_FAR * Uuid1,
    __in UUID __RPC_FAR * Uuid2,
    __out RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
UuidCreateNil (
    __out UUID __RPC_FAR * NilUuid
    );

RPCRTAPI
int
RPC_ENTRY
UuidEqual (
    __in UUID __RPC_FAR * Uuid1,
    __in UUID __RPC_FAR * Uuid2,
    __out RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
unsigned short
RPC_ENTRY
UuidHash (
    __in UUID __RPC_FAR * Uuid,
    __out RPC_STATUS __RPC_FAR * Status
    );

RPCRTAPI
int
RPC_ENTRY
UuidIsNil (
    __in UUID __RPC_FAR * Uuid,
    __out RPC_STATUS __RPC_FAR * Status
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterNoReplaceA (
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector,
    __in_opt RPC_CSTR Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterNoReplaceW (
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector,
    __in_opt RPC_WSTR Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterA (
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector,
    __in_opt RPC_CSTR Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterW (
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector,
    __in_opt RPC_WSTR Annotation
    );

#ifdef UNICODE
#define RpcEpRegisterNoReplace RpcEpRegisterNoReplaceW
#define RpcEpRegister RpcEpRegisterW
#else /* UNICODE */
#define RpcEpRegisterNoReplace RpcEpRegisterNoReplaceA
#define RpcEpRegister RpcEpRegisterA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegisterNoReplace (
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector,
    __in_opt RPC_CSTR Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpRegister (
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector,
    __in_opt RPC_CSTR Annotation
    );

#endif /* RPC_UNICODE_SUPPORTED */


RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcEpUnregister(
    __in RPC_IF_HANDLE IfSpec,
    __in RPC_BINDING_VECTOR * BindingVector,
    __in_opt UUID_VECTOR * UuidVector
    );

#define DCE_C_ERROR_STRING_LEN 256

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
DceErrorInqTextA (
    __in RPC_STATUS RpcStatus,
    __out_ecount(DCE_C_ERROR_STRING_LEN) RPC_CSTR ErrorText
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
DceErrorInqTextW (
    __in RPC_STATUS RpcStatus,
    __out_ecount(DCE_C_ERROR_STRING_LEN) RPC_WSTR ErrorText
    );

#ifdef UNICODE
#define DceErrorInqText DceErrorInqTextW
#else /* UNICODE */
#define DceErrorInqText DceErrorInqTextA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
DceErrorInqText (
    __in RPC_STATUS RpcStatus,
    __out_ecount(DCE_C_ERROR_STRING_LEN) RPC_CSTR ErrorText
    );

#endif /* RPC_UNICODE_SUPPORTED */

typedef I_RPC_HANDLE * RPC_EP_INQ_HANDLE;

#define  RPC_C_EP_ALL_ELTS        0
#define  RPC_C_EP_MATCH_BY_IF     1
#define  RPC_C_EP_MATCH_BY_OBJ    2
#define  RPC_C_EP_MATCH_BY_BOTH   3

#define  RPC_C_VERS_ALL           1
#define  RPC_C_VERS_COMPATIBLE    2
#define  RPC_C_VERS_EXACT         3
#define  RPC_C_VERS_MAJOR_ONLY    4
#define  RPC_C_VERS_UPTO          5

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqBegin (
    __in OPTIONAL RPC_BINDING_HANDLE EpBinding,
    __in unsigned long InquiryType,
    __in_opt RPC_IF_ID __RPC_FAR * IfId,
    __in_opt unsigned long VersOption,
    __in_opt UUID __RPC_FAR * ObjectUuid,
    __out RPC_EP_INQ_HANDLE __RPC_FAR * InquiryContext
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqDone (
    __inout RPC_EP_INQ_HANDLE __RPC_FAR * InquiryContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqNextA (
    __in RPC_EP_INQ_HANDLE InquiryContext,
    __out RPC_IF_ID __RPC_FAR * IfId,
    __out_opt RPC_BINDING_HANDLE __RPC_FAR * Binding,
    __out_opt UUID __RPC_FAR * ObjectUuid,
    __deref_opt_out RPC_CSTR __RPC_FAR * Annotation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqNextW (
    __in RPC_EP_INQ_HANDLE InquiryContext,
    __out RPC_IF_ID __RPC_FAR * IfId,
    __out_opt RPC_BINDING_HANDLE __RPC_FAR * Binding,
    __out_opt UUID __RPC_FAR * ObjectUuid,
    __deref_opt_out RPC_WSTR __RPC_FAR * Annotation
    );

#ifdef UNICODE
#define RpcMgmtEpEltInqNext RpcMgmtEpEltInqNextW
#else /* UNICODE */
#define RpcMgmtEpEltInqNext RpcMgmtEpEltInqNextA
#endif /* UNICODE */

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpEltInqNext (
    __in RPC_EP_INQ_HANDLE InquiryContext,
    __out RPC_IF_ID __RPC_FAR * IfId,
    __out_opt RPC_BINDING_HANDLE __RPC_FAR * Binding,
    __deref_opt_out RPC_CSTR __RPC_FAR * Annotation
    );

#endif /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtEpUnregister (
    __in_opt RPC_BINDING_HANDLE EpBinding,
    __in RPC_IF_ID __RPC_FAR * IfId,
    __in RPC_BINDING_HANDLE Binding,
    __in_opt UUID __RPC_FAR * ObjectUuid
    );

typedef int
(__RPC_API * RPC_MGMT_AUTHORIZATION_FN) (
    __in RPC_BINDING_HANDLE ClientBinding,
    __in unsigned long RequestedMgmtOperation,
    __out RPC_STATUS __RPC_FAR * Status
    );

#define RPC_C_MGMT_INQ_IF_IDS         0
#define RPC_C_MGMT_INQ_PRINC_NAME     1
#define RPC_C_MGMT_INQ_STATS          2
#define RPC_C_MGMT_IS_SERVER_LISTEN   3
#define RPC_C_MGMT_STOP_SERVER_LISTEN 4

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcMgmtSetAuthorizationFn (
    __in RPC_MGMT_AUTHORIZATION_FN AuthorizationFn
    );

#if (NTDDI_VERSION >= NTDDI_VISTA)
RPCRTAPI
int
RPC_ENTRY
RpcExceptionFilter (
    __in unsigned long ExceptionCode
    );
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define RPC_C_PARM_MAX_PACKET_LENGTH    1
#define RPC_C_PARM_BUFFER_LENGTH        2

#define RPC_IF_AUTOLISTEN                   0x0001
#define RPC_IF_OLE                          0x0002
#define RPC_IF_ALLOW_UNKNOWN_AUTHORITY      0x0004
#define RPC_IF_ALLOW_SECURE_ONLY            0x0008
#define RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH 0x0010
#define RPC_IF_ALLOW_LOCAL_ONLY             0x0020
#define RPC_IF_SEC_NO_CACHE                 0x0040
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_IF_SEC_CACHE_PER_PROC           0x0080
#define RPC_IF_ASYNC_CALLBACK               0x0100
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_FW_IF_FLAG_DCOM                 0x0001
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#include <rpcdcep.h>

#ifdef __cplusplus
}
#endif

#endif /* __RPCDCE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Routprot.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    routprot.h

Abstract:
    Include file for Routing Protocol inteface to Router Managers

--*/


#ifndef _ROUTPROT_H_
#define _ROUTPROT_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include "stm.h"

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#pragma warning(disable:4200)

#include <nldef.h>
#include <in6addr.h>

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Supported functionality flags                                            //
//                                                                          //
// ROUTING 		            Imports Routing Table Manager APIs      //
// SERVICES		            Exports Service Table Manager APIs      //
// DEMAND_UPDATE_ROUTES     IP and IPX RIP support for Autostatic           //
// DEMAND_UPDATE_SERVICES   IPX support for Autostatic                      //
// ADD_ALL_INTERFACES       Adds all interfaces, even if no info is present //
// MULTICAST                Supports multicast                              //
// POWER                    Power Manageable                                //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define RF_ROUTING 		        0x00000001
#define RF_DEMAND_UPDATE_ROUTES 0x00000004
#define RF_ADD_ALL_INTERFACES   0x00000010
#define RF_MULTICAST            0x00000020
#define RF_POWER                0x00000040

#if MPR50
#define MS_ROUTER_VERSION       0x00000500
#else
#error Router version not defined
#endif

typedef enum _ROUTING_PROTOCOL_EVENTS
{
    ROUTER_STOPPED,              // Result is empty
    SAVE_GLOBAL_CONFIG_INFO,     // Result is empty
    SAVE_INTERFACE_CONFIG_INFO,  // Result is interface index
                                 // for which config info is to be saved.
    UPDATE_COMPLETE,             // Result is UPDATE_COMPLETE_MESSAGE structure
}ROUTING_PROTOCOL_EVENTS;


typedef enum _NET_INTERFACE_TYPE
{
    PERMANENT,
    DEMAND_DIAL,
    LOCAL_WORKSTATION_DIAL,
    REMOTE_WORKSTATION_DIAL
} NET_INTERFACE_TYPE;

//
// Interface Receive Types
//

#define IR_PROMISCUOUS                  0
#define IR_PROMISCUOUS_MULTICAST        1

typedef struct _SUPPORT_FUNCTIONS
{
    union
    {
        ULONGLONG   _Align8;

        struct
        {
            DWORD   dwVersion;
            DWORD   dwReserved;
        };
    };

    //
    // Function called by routing protocol to initiate demand dial connection
    //

    OUT DWORD
    (WINAPI *DemandDialRequest)(
        IN      DWORD           ProtocolId,
        IN      DWORD           InterfaceIndex
        ) ;

    //
    // Can be called to set the interface's receive capability
    // See IR_Xxx values above
    //

    OUT DWORD
    (WINAPI *SetInterfaceReceiveType)(
        IN      DWORD           ProtocolId,
        IN      DWORD           InterfaceIndex,
        IN      DWORD           InterfaceReceiveType,
        IN      BOOL            bActivate
        );

    //
    // Must be called by every protocol to set the route preference
    // and perform other validation
    //

    OUT DWORD
    (WINAPI *ValidateRoute)(
        IN      DWORD           ProtocolId,
        IN      PVOID           RouteInfo,
        IN      PVOID           DestAddress OPTIONAL
        );


    //
    // The following entrypoints are provided as a way for getting
    // information that spans components
    //

    OUT DWORD
    (WINAPI *MIBEntryCreate)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwEntrySize,
        IN      LPVOID          lpEntry
        );

    OUT DWORD
    (WINAPI *MIBEntryDelete)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwEntrySize,
        IN      LPVOID          lpEntry
        );

    OUT DWORD
    (WINAPI *MIBEntrySet)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwEntrySize,
        IN      LPVOID          lpEntry
        );

    OUT DWORD
    (WINAPI *MIBEntryGet)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwInEntrySize,
        IN      LPVOID          lpInEntry,
        IN OUT  LPDWORD         lpOutEntrySize,
        OUT     LPVOID          lpOutEntry
        );

    OUT DWORD
    (WINAPI *MIBEntryGetFirst)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwInEntrySize,
        IN      LPVOID          lpInEntry,
        IN OUT  LPDWORD         lpOutEntrySize,
        OUT     LPVOID          lpOutEntry
        );

    OUT DWORD
    (WINAPI *MIBEntryGetNext)(
        IN      DWORD           dwRoutingPid,
        IN      DWORD           dwInEntrySize,
        IN      LPVOID          lpInEntry,
        IN OUT  LPDWORD         lpOutEntrySize,
        OUT     LPVOID          lpOutEntry
        );

    //
    // Can be called to get the router ID value
    //

    OUT DWORD
    (WINAPI *GetRouterId)(VOID);

    OUT BOOL
    (WINAPI *HasMulticastBoundary)(
        IN      DWORD           dwIfIndex,
        IN      DWORD           dwGroupAddress
        );

} SUPPORT_FUNCTIONS, *PSUPPORT_FUNCTIONS ;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// All IP Protocols must use the protocol ids defined in the range below.   //
// Protocols not identified below can use any unassigned number BELOW       //
// 0xffff0000                                                               //
//                                                                          //
// NOTE: These numbers have been chosen to coincide with MIB-II protocol    //
// numbers. Allocation should not be arbitrary.                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//
// See nldef.h for the IANA assigned values of PROTO_IP_*.
//

//
// The multicast protocol IDs
//

#define PROTO_IP_MSDP        9
#define PROTO_IP_IGMP       10
#define PROTO_IP_BGMP       11

//
// The IPRTRMGR_PID is 10000 // 0x00002710
//

#define PROTO_IP_VRRP               112
#define PROTO_IP_BOOTP              9999    // 0x0000270F

//included for DHCPv6 Relay Agent
#define PROTO_IPV6_DHCP 			999	    // 0x000003E7

#define PROTO_IP_NT_AUTOSTATIC      10002   // 0x00002712
#define PROTO_IP_DNS_PROXY          10003   // 0x00002713
#define PROTO_IP_DHCP_ALLOCATOR     10004   // 0x00002714
#define PROTO_IP_NAT                10005   // 0x00002715
#define PROTO_IP_NT_STATIC          10006   // 0x00002716
#define PROTO_IP_NT_STATIC_NON_DOD  10007   // 0x00002717
#define PROTO_IP_DIFFSERV           10008   // 0x00002718
#define PROTO_IP_MGM                10009   // 0x00002719
#define PROTO_IP_ALG                10010   // 0x0000271A
#define PROTO_IP_H323               10011   // 0x0000271B
#define PROTO_IP_FTP                10012   // 0x0000271C
#define PROTO_IP_DTP                10013   // 0x0000271D


// For all future development, the following macro must be used to generate
// Ids
//

//
//  Type            -   2 bits
//  Vendor          -  14 bits
//  ProtocolId      -  16 bits
//

#define PROTOCOL_ID(Type, VendorId, ProtocolId) \
    (((Type & 0x03)<<30)|((VendorId & 0x3FFF)<<16)|(ProtocolId & 0xFFFF))

//
//  |----|----|----|----|----|----|----|----|
//   Ty*** Vendor Id *** StandardProtocolId
//

#define TYPE_FROM_PROTO_ID(X)       (((X) >> 30) & 0x03)
#define VENDOR_FROM_PROTO_ID(X)     (((X) >> 16) & 0x3FFF)
#define PROTO_FROM_PROTO_ID(X)      ((X) & 0xFFFF)

//
// Types MS0 and MS1 are Microsoft Reserved
// A protocol that supports both unicast and multicast should use type
// MCAST
//

#define PROTO_TYPE_UCAST            0
#define PROTO_TYPE_MCAST            1
#define PROTO_TYPE_MS0              2
#define PROTO_TYPE_MS1              3

#define PROTO_VENDOR_MS0            0x0000
#define PROTO_VENDOR_MS1            0x137   // 311
#define PROTO_VENDOR_MS2            0x3FFF


#define MS_IPV6_DHCP                 \
    PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS0, PROTO_IPV6_DHCP)

// included for IPV6 DHCP
#define MS_IP_BOOTP                 \
    PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS0, PROTO_IP_BOOTP)
    
#define MS_IP_RIP                   \
    PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS0, PROTO_IP_RIP)

#define MS_IP_OSPF                  \
    PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS0, PROTO_IP_OSPF)

#define MS_IP_BGP                   \
    PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS1, PROTO_IP_BGP)

#define MS_IP_IGMP                  \
    PROTOCOL_ID(PROTO_TYPE_MCAST, PROTO_VENDOR_MS1, PROTO_IP_IGMP)

#define MS_IP_BGMP                  \
    PROTOCOL_ID(PROTO_TYPE_MCAST, PROTO_VENDOR_MS1, PROTO_IP_BGMP)

#define MS_IP_MSDP                  \
    PROTOCOL_ID(PROTO_TYPE_MCAST, PROTO_VENDOR_MS1, PROTO_IP_MSDP)

#define MS_IP_DNS_PROXY             \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_DNS_PROXY)

#define MS_IP_DHCP_ALLOCATOR        \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_DHCP_ALLOCATOR)

#define MS_IP_NAT                   \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_NAT)

#define MS_IP_DIFFSERV              \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_DIFFSERV)

#define MS_IP_MGM                   \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_MGM)

#define MS_IP_VRRP                  \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_VRRP)

#define MS_IP_DTP                   \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_DTP)

#define MS_IP_H323                  \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_H323)

#define MS_IP_FTP                   \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_FTP)

#define MS_IP_ALG                   \
    PROTOCOL_ID(PROTO_TYPE_MS0, PROTO_VENDOR_MS1, PROTO_IP_ALG)

//
// All IPX Protocols must use the protocol ids defined in the range below.
// Protocols not identified below can use any unassigned number greater than
// IPX_PROTOCOL_BASE.
//

#define IPX_PROTOCOL_BASE   0x0001ffff
#define IPX_PROTOCOL_RIP    IPX_PROTOCOL_BASE + 1



typedef struct _UPDATE_COMPLETE_MESSAGE
{
    ULONG	InterfaceIndex;
    ULONG	UpdateType;	       // DEMAND_UPDATE_ROUTES, DEMAND_UPDATE_SERVICES
    ULONG	UpdateStatus;	   // NO_ERROR if successfull

}   UPDATE_COMPLETE_MESSAGE, *PUPDATE_COMPLETE_MESSAGE;

//
//  Message returned in Result parameter to GET_EVENT_MESSAGE api call.
//  UpdateCompleteMessage   returned for UPDATE_COMPLETE message
//  InterfaceIndex          returned for SAVE_INTERFACE_CONFIG_INFO message
//

typedef union _MESSAGE
{
    UPDATE_COMPLETE_MESSAGE UpdateCompleteMessage;
    DWORD                   InterfaceIndex;

}   MESSAGE, *PMESSAGE;

//
// Routing Interface Status types
//

#define RIS_INTERFACE_ADDRESS_CHANGE            0
#define RIS_INTERFACE_ENABLED                   1
#define RIS_INTERFACE_DISABLED                  2
#define RIS_INTERFACE_MEDIA_PRESENT             3
#define RIS_INTERFACE_MEDIA_ABSENT              4



//
// IP Adapter Binding Info
// This is the information associated with an ADDRESS_ARRIVAL event
// An address arrival may have AddressCount == 0, this implies a unnumbered
// interface
//

typedef struct IP_LOCAL_BINDING
{
    DWORD   Address;
    DWORD   Mask;
}IP_LOCAL_BINDING, *PIP_LOCAL_BINDING;

typedef struct IPV6_LOCAL_BINDING
{
    IN6_ADDR    Address;
    DWORD    PrefixLength;
}IPV6_LOCAL_BINDING, *PIPV6_LOCAL_BINDING;

typedef struct	IP_ADAPTER_BINDING_INFO
{
    ULONG               AddressCount;
    DWORD               RemoteAddress;
    ULONG               Mtu;
    ULONGLONG           Speed;
    __field_ecount(AddressCount) IP_LOCAL_BINDING    Address[0];
}IP_ADAPTER_BINDING_INFO, *PIP_ADAPTER_BINDING_INFO;


#define SIZEOF_IP_BINDING(X)                                \
    (FIELD_OFFSET(IP_ADAPTER_BINDING_INFO,Address[0]) +     \
     ((X) * sizeof(IP_LOCAL_BINDING)))

typedef struct  IPV6_ADAPTER_BINDING_INFO
{
    ULONG                   AddressCount;
    IN6_ADDR                RemoteAddress;
    ULONG                   Mtu;
    ULONGLONG               Speed;
    __field_ecount(AddressCount) IPV6_LOCAL_BINDING      Address[0];
}IPV6_ADAPTER_BINDING_INFO, *PIPV6_ADAPTER_BINDING_INFO;

#define SIZEOF_IPV6_BINDING(X)                                \
    (FIELD_OFFSET(IPV6_ADAPTER_BINDING_INFO,Address[0]) +     \
     ((X) * sizeof(IPV6_LOCAL_BINDING)))


typedef
DWORD
(WINAPI * PSTART_PROTOCOL) (
    IN HANDLE 	            NotificationEvent,
    IN PSUPPORT_FUNCTIONS   SupportFunctions,
    IN LPVOID               GlobalInfo,
    IN ULONG                StructureVersion,
    IN ULONG                StructureSize,
    IN ULONG                StructureCount
    );

typedef
DWORD
(WINAPI * PSTART_COMPLETE) (
    VOID
    );

typedef
DWORD
(WINAPI * PSTOP_PROTOCOL) (
    VOID
    );

typedef
DWORD
(WINAPI * PADD_INTERFACE) (
    IN LPWSTR               InterfaceName,
    IN ULONG	            InterfaceIndex,
    IN NET_INTERFACE_TYPE   InterfaceType,
    IN DWORD                MediaType,
    IN WORD                 AccessType,
    IN WORD                 ConnectionType,
    IN PVOID	            InterfaceInfo,
    IN ULONG                StructureVersion,
    IN ULONG                StructureSize,
    IN ULONG                StructureCount
    );

typedef
DWORD
(WINAPI * PDELETE_INTERFACE) (
    IN ULONG	InterfaceIndex
    );

typedef
DWORD
(WINAPI * PGET_EVENT_MESSAGE) (
    OUT ROUTING_PROTOCOL_EVENTS  *Event,
    OUT MESSAGE                  *Result
    );

typedef
DWORD
(WINAPI * PGET_INTERFACE_INFO) (
    IN      ULONG	InterfaceIndex,
    IN      PVOID   InterfaceInfo,
    IN  OUT PULONG  BufferSize,
    OUT     PULONG	StructureVersion,
    IN      PULONG	StructureSize,
    OUT     PULONG	StructureCount
    );

typedef
DWORD
(WINAPI * PSET_INTERFACE_INFO) (
    IN ULONG	InterfaceIndex,
    IN PVOID	InterfaceInfo,
    IN ULONG    StructureVersion,
    IN ULONG    StructureSize,
    IN ULONG    StructureCount
    );

typedef
DWORD
(WINAPI * PINTERFACE_STATUS) (
    IN ULONG	InterfaceIndex,
    IN BOOL     InterfaceActive,
    IN DWORD    StatusType,
    IN PVOID	StatusInfo
    );

typedef
DWORD
(WINAPI * PQUERY_POWER) (
    IN  DWORD   PowerType
    );

typedef
DWORD
(WINAPI * PSET_POWER) (
    IN  DWORD   PowerType
    );

typedef
DWORD
(WINAPI * PGET_GLOBAL_INFO) (
    IN     PVOID 	GlobalInfo,
    IN OUT PULONG   BufferSize,
    OUT    PULONG	StructureVersion,
    OUT    PULONG   StructureSize,
    OUT    PULONG   StructureCount
    );

typedef
DWORD
(WINAPI * PSET_GLOBAL_INFO) (
    IN  PVOID 	GlobalInfo,
    IN  ULONG	StructureVersion,
    IN  ULONG   StructureSize,
    IN  ULONG   StructureCount
    );

typedef
DWORD
(WINAPI * PDO_UPDATE_ROUTES) (
    IN ULONG	InterfaceIndex
    );

typedef
DWORD
(WINAPI * PMIB_CREATE) (
    IN ULONG 	InputDataSize,
    IN PVOID 	InputData
    );

typedef
DWORD
(WINAPI * PMIB_DELETE) (
    IN ULONG 	InputDataSize,
    IN PVOID 	InputData
    );

typedef
DWORD
(WINAPI * PMIB_GET) (
    IN  ULONG	InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG	OutputDataSize,
    OUT PVOID	OutputData
    );

typedef
DWORD
(WINAPI * PMIB_SET) (
    IN ULONG 	InputDataSize,
    IN PVOID	InputData
    );

typedef
DWORD
(WINAPI * PMIB_GET_FIRST) (
    IN  ULONG	InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG  OutputDataSize,
    OUT PVOID   OutputData
    );

typedef
DWORD
(WINAPI * PMIB_GET_NEXT) (
    IN  ULONG   InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG  OutputDataSize,
    OUT PVOID	OutputData
    );

typedef
DWORD
(WINAPI * PMIB_SET_TRAP_INFO) (
    IN  HANDLE  Event,
    IN  ULONG   InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG	OutputDataSize,
    OUT PVOID	OutputData
    );

typedef
DWORD
(WINAPI * PMIB_GET_TRAP_INFO) (
    IN  ULONG	InputDataSize,
    IN  PVOID	InputData,
    OUT PULONG  OutputDataSize,
    OUT PVOID	OutputData
    );

typedef
DWORD
(WINAPI *PCONNECT_CLIENT) (
    IN ULONG    InterfaceIndex,
    IN PVOID    ClientAddress
    );

typedef
DWORD
(WINAPI *PDISCONNECT_CLIENT) (
    IN ULONG    InterfaceIndex,
    IN PVOID    ClientAddress
    );

//
// InterfaceFlags used with the GetNeighbors() call below
//

#define MRINFO_TUNNEL_FLAG   0x01
#define MRINFO_PIM_FLAG      0x04
#define MRINFO_DOWN_FLAG     0x10
#define MRINFO_DISABLED_FLAG 0x20
#define MRINFO_QUERIER_FLAG  0x40
#define MRINFO_LEAF_FLAG     0x80

typedef
DWORD
(WINAPI *PGET_NEIGHBORS) (
    IN     DWORD  InterfaceIndex,
    IN     PDWORD NeighborList,
    IN OUT PDWORD NeighborListSize,
       OUT PBYTE  InterfaceFlags
    );

//
// StatusCode values used with the GetMfeStatus() call below.
// The protocol should return the highest-valued one that applies.
//

#define MFE_NO_ERROR          0 // none of the below events
#define MFE_REACHED_CORE      1 // this router is an RP/core for the group

//
// StatusCode values set by oif owner only
//

#define MFE_OIF_PRUNED        5 // no downstream receivers exist on oif

//
// StatusCode values set by iif owner only
//

#define MFE_PRUNED_UPSTREAM   4 // a prune was send upstream
#define MFE_OLD_ROUTER       11 // upstream nbr doesn't support mtrace

//
// StatusCode values which are used only by the Router Manager itself:
//

#define MFE_NOT_FORWARDING    2 // not fwding for an unspecified reason
#define MFE_WRONG_IF          3 // mtrace received on iif
#define MFE_BOUNDARY_REACHED  6 // iif or oif is admin scope boundary
#define MFE_NO_MULTICAST      7 // oif is not multicast-enabled
#define MFE_IIF               8 // mtrace arrived on iif
#define MFE_NO_ROUTE          9 // router has no route that matches
#define MFE_NOT_LAST_HOP     10 // router is not the proper last-hop router
#define MFE_PROHIBITED       12 // mtrace is administratively prohibited
#define MFE_NO_SPACE         13 // not enough room in packet

typedef
DWORD
(WINAPI *PGET_MFE_STATUS) (
    IN     DWORD  InterfaceIndex,
    IN     DWORD  GroupAddress,
    IN     DWORD  SourceAddress,
    OUT    PBYTE  StatusCode
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This is the structure passed between the router manager and a protocol   //
// upon registration.                                                       //
//                                                                          //
// IN OUT DWORD dwVersion                                                   //
// This is filled by the router manager to indicate the version it supports.//
// The DLL MUST set this to the version that the protocol will support.     //
//                                                                          //
// IN DWORD dwProtocolId                                                    //
// This the protocol the router manager is expecting the DLL to register.   //
// If the DLL does not support this protocol, it MUST return                //
// ERROR_NOT_SUPPORTED                                                      //
// A DLL will be called once for every protocol it supports                 //
//                                                                          //
// IN OUT DWORD fSupportedFunctionality                                     //
// These are the flags denoting the functionality the router manager        //
// supports. The DLL MUST reset this to the functionality that it supports. //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


typedef struct _MPR50_ROUTING_CHARACTERISTICS
{
    DWORD               dwVersion;
    DWORD               dwProtocolId;
    DWORD               fSupportedFunctionality;

    PSTART_PROTOCOL     pfnStartProtocol;
    PSTART_COMPLETE     pfnStartComplete;
    PSTOP_PROTOCOL      pfnStopProtocol;
    PGET_GLOBAL_INFO    pfnGetGlobalInfo;
    PSET_GLOBAL_INFO    pfnSetGlobalInfo;
    PQUERY_POWER        pfnQueryPower;
    PSET_POWER          pfnSetPower;

    PADD_INTERFACE      pfnAddInterface;
    PDELETE_INTERFACE   pfnDeleteInterface;
    PINTERFACE_STATUS   pfnInterfaceStatus;
    PGET_INTERFACE_INFO pfnGetInterfaceInfo;
    PSET_INTERFACE_INFO pfnSetInterfaceInfo;

    PGET_EVENT_MESSAGE  pfnGetEventMessage;

    PDO_UPDATE_ROUTES   pfnUpdateRoutes;

    PCONNECT_CLIENT     pfnConnectClient;
    PDISCONNECT_CLIENT  pfnDisconnectClient;

    PGET_NEIGHBORS      pfnGetNeighbors;
    PGET_MFE_STATUS     pfnGetMfeStatus;

    PMIB_CREATE         pfnMibCreateEntry;
    PMIB_DELETE         pfnMibDeleteEntry;
    PMIB_GET            pfnMibGetEntry;
    PMIB_SET            pfnMibSetEntry;
    PMIB_GET_FIRST      pfnMibGetFirstEntry;
    PMIB_GET_NEXT       pfnMibGetNextEntry;
    PMIB_SET_TRAP_INFO  pfnMibSetTrapInfo;
    PMIB_GET_TRAP_INFO  pfnMibGetTrapInfo;

}MPR50_ROUTING_CHARACTERISTICS;

#if MPR50
typedef MPR50_ROUTING_CHARACTERISTICS MPR_ROUTING_CHARACTERISTICS;
#endif

typedef MPR_ROUTING_CHARACTERISTICS *PMPR_ROUTING_CHARACTERISTICS;


//
// All routing protocols must export the following entry point.
// The router manager calls this function to allow the routing
// protocol to register
//

#define REGISTER_PROTOCOL_ENTRY_POINT           RegisterProtocol
#define REGISTER_PROTOCOL_ENTRY_POINT_STRING    "RegisterProtocol"

typedef
DWORD
(WINAPI * PREGISTER_PROTOCOL) (
    IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar
    );


#ifdef __cplusplus
}
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4200)
#pragma warning(default:4201)
#endif

#endif      // _ROUTPROT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RpcNdr.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

--*/

// This version of the rpcndr.h file corresponds to MIDL version 5.0.+
// used with Windows 2000/XP build 1700+


#ifndef __RPCNDR_H_VERSION__
#define __RPCNDR_H_VERSION__        ( 500 )
#endif // __RPCNDR_H_VERSION__


#ifndef __RPCNDR_H__
#define __RPCNDR_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __REQUIRED_RPCNDR_H_VERSION__
    #if ( __RPCNDR_H_VERSION__ < __REQUIRED_RPCNDR_H_VERSION__ )
        #error incorrect <rpcndr.h> version. Use the header that matches with the MIDL compiler.
    #endif
#endif


#include <pshpack8.h>
#include <basetsd.h>
#if !defined(_KRPCENV_)
#include <rpcnsip.h>
#endif

#include <rpcsal.h>

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************

     Network Computing Architecture (NCA) definition:

     Network Data Representation: (NDR) Label format:
     An unsigned long (32 bits) with the following layout:

     3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
     1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    +---------------+---------------+---------------+-------+-------+
    |   Reserved    |   Reserved    |Floating point | Int   | Char  |
    |               |               |Representation | Rep.  | Rep.  |
    +---------------+---------------+---------------+-------+-------+

     Where

         Reserved:

             Must be zero (0) for NCA 1.5 and NCA 2.0.

         Floating point Representation is:

             0 - IEEE
             1 - VAX
             2 - Cray
             3 - IBM

         Int Rep. is Integer Representation:

             0 - Big Endian
             1 - Little Endian

         Char Rep. is Character Representation:

             0 - ASCII
             1 - EBCDIC

     The Microsoft Local Data Representation (for all platforms which are
     of interest currently is edefined below:

 ****************************************************************************/

#define NDR_CHAR_REP_MASK               (unsigned long)0X0000000FL
#define NDR_INT_REP_MASK                (unsigned long)0X000000F0L
#define NDR_FLOAT_REP_MASK              (unsigned long)0X0000FF00L

#define NDR_LITTLE_ENDIAN               (unsigned long)0X00000010L
#define NDR_BIG_ENDIAN                  (unsigned long)0X00000000L

#define NDR_IEEE_FLOAT                  (unsigned long)0X00000000L
#define NDR_VAX_FLOAT                   (unsigned long)0X00000100L
#define NDR_IBM_FLOAT                   (unsigned long)0X00000300L

#define NDR_ASCII_CHAR                  (unsigned long)0X00000000L
#define NDR_EBCDIC_CHAR                 (unsigned long)0X00000001L

#if defined(__RPC_MAC__)
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000000L
#define NDR_LOCAL_ENDIAN                NDR_BIG_ENDIAN
#else
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000010L
#define NDR_LOCAL_ENDIAN                NDR_LITTLE_ENDIAN
#endif


/****************************************************************************
 *  Macros for targeted platforms
 ****************************************************************************/

#if (0x601 <= _WIN32_WINNT)
#define TARGET_IS_NT61_OR_LATER                   1
#else
#define TARGET_IS_NT61_OR_LATER                   0
#endif

#if (0x600 <= _WIN32_WINNT)
#define TARGET_IS_NT60_OR_LATER                   1
#else
#define TARGET_IS_NT60_OR_LATER                   0
#endif

#if (0x501 <= _WIN32_WINNT)
#define TARGET_IS_NT51_OR_LATER                   1
#else
#define TARGET_IS_NT51_OR_LATER                   0
#endif

#if (0x500 <= _WIN32_WINNT)
#define TARGET_IS_NT50_OR_LATER                   1
#else
#define TARGET_IS_NT50_OR_LATER                   0
#endif

#if (defined(_WIN32_DCOM) || 0x400 <= _WIN32_WINNT)
#define TARGET_IS_NT40_OR_LATER                   1
#else
#define TARGET_IS_NT40_OR_LATER                   0
#endif

#if (0x400 <= WINVER)
#define TARGET_IS_NT351_OR_WIN95_OR_LATER         1
#else
#define TARGET_IS_NT351_OR_WIN95_OR_LATER         0
#endif

/****************************************************************************
 *  Other MIDL base types / predefined types:
 ****************************************************************************/

#define small char
typedef unsigned char byte;
typedef byte cs_byte;
typedef unsigned char boolean;

#ifndef _HYPER_DEFINED
#define _HYPER_DEFINED

#if (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
#define  hyper           __int64
#define MIDL_uhyper  unsigned __int64
#else
typedef double  hyper;
typedef double MIDL_uhyper;
#endif

#endif // _HYPER_DEFINED

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
#ifdef __RPC_WIN64__
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifdef __RPC_WIN32__
#if   (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define __RPC_CALLEE       __stdcall
#else
#define __RPC_CALLEE
#endif
#endif

#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

__bcount_opt(size)
void  * __RPC_USER MIDL_user_allocate(size_t size);
void             __RPC_USER MIDL_user_free( __inout void  * );

__bcount_opt(size)
void * __RPC_USER I_RpcDefaultAllocate(
         handle_t bh, size_t size, void * (* RealAlloc)(size_t) );

void __RPC_USER I_RpcDefaultFree(
         handle_t bh, void *, void (*RealFree)(void *) );


#define RPC_VAR_ENTRY __cdecl


/* winnt only */
#if defined(_M_IX86) || defined(_M_AMD64) || defined(_M_IA64)
#define __MIDL_DECLSPEC_DLLIMPORT   __declspec(dllimport)
#define __MIDL_DECLSPEC_DLLEXPORT   __declspec(dllexport)
#else
#define __MIDL_DECLSPEC_DLLIMPORT
#define __MIDL_DECLSPEC_DLLEXPORT
#endif




/****************************************************************************
 * Context handle management related definitions:
 *
 * Client and Server Contexts.
 *
 ****************************************************************************/

typedef void  * NDR_CCONTEXT;

typedef struct
    {
    void  * pad[2];
    void  * userContext;
    }  * NDR_SCONTEXT;

#define NDRSContextValue(hContext) (&(hContext)->userContext)

#define cbNDRContext 20         /* size of context on WIRE */

typedef void (__RPC_USER  * NDR_RUNDOWN)(void  * context);

typedef void (__RPC_USER  * NDR_NOTIFY_ROUTINE)(void);
typedef void (__RPC_USER  * NDR_NOTIFY2_ROUTINE)(boolean flag);

typedef struct _SCONTEXT_QUEUE {
    unsigned long   NumberOfObjects;
    NDR_SCONTEXT  * ArrayOfObjects;
    } SCONTEXT_QUEUE,  * PSCONTEXT_QUEUE;

RPCRTAPI
RPC_BINDING_HANDLE
RPC_ENTRY
NDRCContextBinding (
    __in NDR_CCONTEXT     CContext
    );

RPCRTAPI
void
RPC_ENTRY
NDRCContextMarshall (
    __in  NDR_CCONTEXT    CContext,
    __out void  *pBuff
    );

RPCRTAPI
void
RPC_ENTRY
NDRCContextUnmarshall (
    __inout NDR_CCONTEXT        *   pCContext,
    __in  RPC_BINDING_HANDLE      hBinding,
    __in  void                *   pBuff,
    __in  unsigned long           DataRepresentation
    );

RPCRTAPI
void
RPC_ENTRY
NDRCContextUnmarshall2 (
    __inout NDR_CCONTEXT        *   pCContext,
    __in  RPC_BINDING_HANDLE      hBinding,
    __in  void                *   pBuff,
    __in  unsigned long           DataRepresentation
    );

RPCRTAPI
void
RPC_ENTRY
NDRSContextMarshall (
    __in  NDR_SCONTEXT    CContext,
    __out void          * pBuff,
    __in  NDR_RUNDOWN     userRunDownIn
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NDRSContextUnmarshall (
    __in  void          * pBuff,
    __in  unsigned long   DataRepresentation
    );

RPCRTAPI
void
RPC_ENTRY
NDRSContextMarshallEx (
    __in  RPC_BINDING_HANDLE  BindingHandle,
    __in  NDR_SCONTEXT        CContext,
    __out void              * pBuff,
    __in  NDR_RUNDOWN         userRunDownIn
    );

RPCRTAPI
void
RPC_ENTRY
NDRSContextMarshall2 (
    __in  RPC_BINDING_HANDLE  BindingHandle,
    __in  NDR_SCONTEXT        CContext,
    __out void              * pBuff,
    __in  NDR_RUNDOWN         userRunDownIn,
    __in  void              * CtxGuard,
    __in unsigned long        Flags
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NDRSContextUnmarshallEx (
    __in  RPC_BINDING_HANDLE  BindingHandle,
    __in  void              * pBuff,
    __in  unsigned long       DataRepresentation
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NDRSContextUnmarshall2(
    __in  RPC_BINDING_HANDLE  BindingHandle,
    __in  void              * pBuff,
    __in  unsigned long       DataRepresentation,
    __in  void              * CtxGuard,
    __in unsigned long        Flags
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsDestroyClientContext (
    __in void  *  * ContextHandle
    );


/****************************************************************************
    NDR conversion related definitions.
 ****************************************************************************/

#define byte_from_ndr(source, target) \
    { \
    *(target) = *(*(char  *  *)&(source)->Buffer)++; \
    }

#define byte_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char  *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long  *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define boolean_from_ndr(source, target) \
    { \
    *(target) = *(*(char  *  *)&(source)->Buffer)++; \
    }

#define boolean_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char  *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long  *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define small_from_ndr(source, target) \
    { \
    *(target) = *(*(char  *  *)&(source)->Buffer)++; \
    }

#define small_from_ndr_temp(source, target, format) \
    { \
    *(target) = *(*(char  *  *)(source))++; \
    }

#define small_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char  *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long  *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

/****************************************************************************
    Platform specific mapping of c-runtime functions.
 ****************************************************************************/

#if defined(__RPC_WIN32__) || defined(__RPC_WIN64__)
#define MIDL_ascii_strlen(string) \
    strlen(string)
#define MIDL_ascii_strcpy(target,source) \
    strcpy(target,source)
#define MIDL_memset(s,c,n) \
    memset(s,c,n)
#endif

/****************************************************************************
    MIDL 2.0 ndr definitions.
 ****************************************************************************/

typedef unsigned long error_status_t;

#define _midl_ma1( p, cast )    *(*( cast **)&p)++
#define _midl_ma2( p, cast )    *(*( cast **)&p)++
#define _midl_ma4( p, cast )    *(*( cast **)&p)++
#define _midl_ma8( p, cast )    *(*( cast **)&p)++

#define _midl_unma1( p, cast )  *(( cast *)p)++
#define _midl_unma2( p, cast )  *(( cast *)p)++
#define _midl_unma3( p, cast )  *(( cast *)p)++
#define _midl_unma4( p, cast )  *(( cast *)p)++

// Some alignment specific macros.

// RKK64
// these appear to be used in fossils inside MIDL
#define _midl_fa2( p )          (p = (RPC_BUFPTR )((ULONG_PTR)(p+1) & ~0x1))
#define _midl_fa4( p )          (p = (RPC_BUFPTR )((ULONG_PTR)(p+3) & ~0x3))
#define _midl_fa8( p )          (p = (RPC_BUFPTR )((ULONG_PTR)(p+7) & ~0x7))

#define _midl_addp( p, n )      (p += n)

// Marshalling macros

#define _midl_marsh_lhs( p, cast )  *(*( cast **)&p)++
#define _midl_marsh_up( mp, p )     *(*(unsigned long **)&mp)++ = (unsigned long)p
#define _midl_advmp( mp )           *(*(unsigned long **)&mp)++
#define _midl_unmarsh_up( p )       (*(*(unsigned long **)&p)++)


////////////////////////////////////////////////////////////////////////////
// Ndr macros.
////////////////////////////////////////////////////////////////////////////

// RKK64
// these appear to be used in fossils inside MIDL
#define NdrMarshConfStringHdr( p, s, l )    (_midl_ma4( p, unsigned long) = s, \
                                            _midl_ma4( p, unsigned long) = 0, \
                                            _midl_ma4( p, unsigned long) = l)

#define NdrUnMarshConfStringHdr(p, s, l)    ((s=_midl_unma4(p,unsigned long),\
                                            (_midl_addp(p,4)),               \
                                            (l=_midl_unma4(p,unsigned long))

#define NdrMarshCCtxtHdl(pc,p)  (NDRCContextMarshall( (NDR_CCONTEXT)pc, p ),p+20)

#define NdrUnMarshCCtxtHdl(pc,p,h,drep) \
        (NDRCContextUnmarshall((NDR_CONTEXT)pc,h,p,drep), p+20)

#define NdrUnMarshSCtxtHdl(pc, p,drep)  (pc = NdrSContextUnMarshall(p,drep ))


#define NdrMarshSCtxtHdl(pc,p,rd)   (NdrSContextMarshall((NDR_SCONTEXT)pc,p, (NDR_RUNDOWN)rd)


// end of unused

#define NdrFieldOffset(s,f)     (LONG_PTR)(& (((s  *)0)->f))
#define NdrFieldPad(s,f,p,t)    ((unsigned long)(NdrFieldOffset(s,f) - NdrFieldOffset(s,p)) - sizeof(t))

#define NdrFcShort(s)   (unsigned char)(s & 0xff), (unsigned char)(s >> 8)
#define NdrFcLong(s)    (unsigned char)(s & 0xff), (unsigned char)((s & 0x0000ff00) >> 8), \
                        (unsigned char)((s & 0x00ff0000) >> 16), (unsigned char)(s >> 24)

//
// On the server side, the following exceptions are mapped to
// the bad stub data exception if -error stub_data is used.
//

#define RPC_BAD_STUB_DATA_EXCEPTION_FILTER  \
                 ( (RpcExceptionCode() == STATUS_ACCESS_VIOLATION)  || \
                   (RpcExceptionCode() == STATUS_DATATYPE_MISALIGNMENT) || \
                   (RpcExceptionCode() == RPC_X_BAD_STUB_DATA) || \
                   (RpcExceptionCode() == RPC_S_INVALID_BOUND) )

/////////////////////////////////////////////////////////////////////////////
// Some stub helper functions.
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// Stub helper structures.
////////////////////////////////////////////////////////////////////////////

struct _MIDL_STUB_MESSAGE;
struct _MIDL_STUB_DESC;
struct _FULL_PTR_XLAT_TABLES;

typedef unsigned char  *    RPC_BUFPTR;
typedef unsigned long       RPC_LENGTH;

// Expression evaluation callback routine prototype.
typedef void (__RPC_USER  * EXPR_EVAL)( struct _MIDL_STUB_MESSAGE  * );

typedef const unsigned char  * PFORMAT_STRING;

/*
 * Multidimensional conformant/varying array struct.
 */
typedef struct
    {
    long              Dimension;

    /* These fields MUST be (unsigned long *) */
    unsigned long  *  BufferConformanceMark;
    unsigned long  *  BufferVarianceMark;

    /* Count arrays, used for top level arrays in -Os stubs */
    unsigned long  *  MaxCountArray;
    unsigned long  *  OffsetArray;
    unsigned long  *  ActualCountArray;
    } ARRAY_INFO,  *PARRAY_INFO;


typedef struct _NDR_ASYNC_MESSAGE *   PNDR_ASYNC_MESSAGE;
typedef struct _NDR_CORRELATION_INFO *PNDR_CORRELATION_INFO;

/*
 * MIDL Stub Message
 */

typedef const unsigned char  * PFORMAT_STRING;
typedef struct _MIDL_SYNTAX_INFO MIDL_SYNTAX_INFO, *PMIDL_SYNTAX_INFO;

struct NDR_ALLOC_ALL_NODES_CONTEXT;
struct NDR_POINTER_QUEUE_STATE;
struct _NDR_PROC_CONTEXT;

typedef struct _MIDL_STUB_MESSAGE
    {
    /* RPC message structure. */
    PRPC_MESSAGE            RpcMsg;

    /* Pointer into RPC message buffer. */
    unsigned char       *   Buffer;

    /*
     * These are used internally by the Ndr routines to mark the beginning
     * and end of an incoming RPC buffer.
     */
    unsigned char       *   BufferStart;
    unsigned char       *   BufferEnd;

    /*
     * Used internally by the Ndr routines as a place holder in the buffer.
     * On the marshalling side it's used to mark the location where conformance
     * size should be marshalled.
     * On the unmarshalling side it's used to mark the location in the buffer
     * used during pointer unmarshalling to base pointer offsets off of.
     */
    unsigned char       *   BufferMark;

    /* Set by the buffer sizing routines. */
    unsigned long           BufferLength;

    /* Set by the memory sizing routines. */
    unsigned long           MemorySize;

    /* Pointer to user memory. */
    unsigned char       *   Memory;

    /* Is the Ndr routine begin called from a client side stub. */
    unsigned char           IsClient;
    unsigned char           Pad;
    unsigned short          uFlags2;

    /* Can the buffer be re-used for memory on unmarshalling. */
    int                     ReuseBuffer;

    /* Hold the context for allocate all nodes */
    struct NDR_ALLOC_ALL_NODES_CONTEXT *pAllocAllNodesContext;
    struct NDR_POINTER_QUEUE_STATE     *pPointerQueueState;

    /*
     * Stuff needed while handling complex structures
     */

    /* Ignore imbeded pointers while computing buffer or memory sizes. */
    int                     IgnoreEmbeddedPointers;

    /*
     * This marks the location in the buffer where pointees of a complex
     * struct reside.
     */
    unsigned char       *   PointerBufferMark;

    /*
     * Used to catch errors in SendReceive.
     */
    unsigned char           CorrDespIncrement;

    unsigned char           uFlags;
    unsigned short          UniquePtrCount;

    /*
     * Used internally by the Ndr routines.  Holds the max counts for
     * a conformant array.
     */
    ULONG_PTR               MaxCount;

    /*
     * Used internally by the Ndr routines.  Holds the offsets for a varying
     * array.
     */
    unsigned long           Offset;

    /*
     * Used internally by the Ndr routines.  Holds the actual counts for
     * a varying array.
     */
    unsigned long           ActualCount;

    /* Allocation and Free routine to be used by the Ndr routines. */
    void  *             ( __RPC_API * pfnAllocate)( size_t );
    void                    ( __RPC_API * pfnFree)(void  *);

    /*
     * Top of parameter stack.  Used for "single call" stubs during marshalling
     * to hold the beginning of the parameter list on the stack.  Needed to
     * extract parameters which hold attribute values for top level arrays and
     * pointers.
     */
    unsigned char       *   StackTop;

    /*
     *  Fields used for the transmit_as and represent_as objects.
     *  For represent_as the mapping is: presented=local, transmit=named.
     */
    unsigned char       *   pPresentedType;
    unsigned char       *   pTransmitType;

    /*
     * When we first construct a binding on the client side, stick it
     * in the rpcmessage and later call RpcGetBuffer, the handle field
     * in the rpcmessage is changed. That's fine except that we need to
     * have that original handle for use in unmarshalling context handles
     * (the second argument in NDRCContextUnmarshall to be exact). So
     * stash the contructed handle here and extract it when needed.
     */
    handle_t                SavedHandle;

    /*
     * Pointer back to the stub descriptor.  Use this to get all handle info.
     */
    const struct _MIDL_STUB_DESC  * StubDesc;

    /*
     * Full pointer stuff.
     */
    struct _FULL_PTR_XLAT_TABLES  * FullPtrXlatTables;
    unsigned long                   FullPtrRefId;

    unsigned long                   PointerLength;

    int                             fInDontFree       :1;
    int                             fDontCallFreeInst :1;
    int                             fInOnlyParam      :1;
    int                             fHasReturn        :1;
    int                             fHasExtensions    :1;
    int                             fHasNewCorrDesc   :1;
    int                             fIsIn             :1;
    int                             fIsOut            :1;
    int                             fIsOicf           :1;
    int                             fBufferValid      :1;
    int                             fHasMemoryValidateCallback: 1;
    int                             fInFree             :1;
    int                             fNeedMCCP         :1;
    int                             fUnused           :3;
    int                             fUnused2          :16;


    unsigned long                   dwDestContext;
    void  *                         pvDestContext;

    NDR_SCONTEXT *                  SavedContextHandles;

    long                            ParamNumber;

    struct IRpcChannelBuffer    *   pRpcChannelBuffer;

    PARRAY_INFO                     pArrayInfo;
    unsigned long           *       SizePtrCountArray;
    unsigned long           *       SizePtrOffsetArray;
    unsigned long           *       SizePtrLengthArray;

    /*
     * Interpreter argument queue.  Used on server side only.
     */
    void                    *       pArgQueue;

    unsigned long                   dwStubPhase;

    void                    *       LowStackMark;

    /*
     *  Async message pointer, correlation data - NT 5.0 features.
     */
    PNDR_ASYNC_MESSAGE              pAsyncMsg;
    PNDR_CORRELATION_INFO           pCorrInfo;
    unsigned char *                 pCorrMemory;

    void *                          pMemoryList;

    /*
     *  Reserved fields up to this point present since the 3.50 release.
     *  Reserved fields below were introduced for Windows 2000 release.
     *  (but not used).
     */

    /*
     * International character support information - NT 5.1 feature.
     */
#if (NTDDI_VERSION >= NTDDI_WIN2K )

    INT_PTR                         pCSInfo;

    unsigned char *                 ConformanceMark;
    unsigned char *                 VarianceMark;

#if defined(IA64)
    void                   *        BackingStoreLowMark;
#else
    INT_PTR                         Unused;
#endif

    struct _NDR_PROC_CONTEXT *      pContext;

    /*
     *  Reserved fields up to this point present since Windows 2000 release.
     *  Fields added for NT5.1
     *
     *  pUserMarshalList is used to keep a linked list of nodes pointing to 
     *  marshalled data to be freed.  This list can contain (as the name
     *  implies) User Marshalled data, but also can contain Interface Pointer
     *  data.   
     */

    void *                             ContextHandleHash;
    void *                             pUserMarshalList;
    INT_PTR                         Reserved51_3;
    INT_PTR                         Reserved51_4;
    INT_PTR                         Reserved51_5;


    /*
     *  Reserved fields up to this point present since NT5.1 release.
     */
#endif // (NTDDI_VERSION >= NTDDI_WIN2K )
    } MIDL_STUB_MESSAGE,  *PMIDL_STUB_MESSAGE;


typedef  struct _MIDL_STUB_MESSAGE MIDL_STUB_MESSAGE,   *PMIDL_STUB_MESSAGE;

/*
 * Generic handle bind/unbind routine pair.
 */
typedef void  *
        ( __RPC_API * GENERIC_BINDING_ROUTINE)
        (void  *);
typedef void
        ( __RPC_API * GENERIC_UNBIND_ROUTINE)
        (void  *, unsigned char  *);

typedef struct _GENERIC_BINDING_ROUTINE_PAIR
    {
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_ROUTINE_PAIR,  *PGENERIC_BINDING_ROUTINE_PAIR;

typedef struct __GENERIC_BINDING_INFO
    {
    void  *            pObj;
    unsigned int                Size;
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_INFO,  *PGENERIC_BINDING_INFO;

// typedef EXPR_EVAL - see above
// typedefs for xmit_as

#if (defined(_MSC_VER)) && !defined(MIDL_PASS)
// a Microsoft C++ compiler
#define NDR_SHAREABLE __inline
#else
#define NDR_SHAREABLE static
#endif


typedef void ( __RPC_USER * XMIT_HELPER_ROUTINE)
    ( PMIDL_STUB_MESSAGE );

typedef struct _XMIT_ROUTINE_QUINTUPLE
    {
    XMIT_HELPER_ROUTINE     pfnTranslateToXmit;
    XMIT_HELPER_ROUTINE     pfnTranslateFromXmit;
    XMIT_HELPER_ROUTINE     pfnFreeXmit;
    XMIT_HELPER_ROUTINE     pfnFreeInst;
    } XMIT_ROUTINE_QUINTUPLE,  *PXMIT_ROUTINE_QUINTUPLE;

typedef unsigned long
( __RPC_USER * USER_MARSHAL_SIZING_ROUTINE)
    (unsigned long  *,
     unsigned long,
     void  * );

typedef unsigned char  *
( __RPC_USER * USER_MARSHAL_MARSHALLING_ROUTINE)
    (unsigned long  *,
     unsigned char  * ,
     void  * );

typedef unsigned char  *
( __RPC_USER * USER_MARSHAL_UNMARSHALLING_ROUTINE)
    (unsigned long  *,
     unsigned char  *,
     void  * );

typedef void ( __RPC_USER * USER_MARSHAL_FREEING_ROUTINE)
    (unsigned long  *,
     void  * );

typedef struct _USER_MARSHAL_ROUTINE_QUADRUPLE
    {
    USER_MARSHAL_SIZING_ROUTINE          pfnBufferSize;
    USER_MARSHAL_MARSHALLING_ROUTINE     pfnMarshall;
    USER_MARSHAL_UNMARSHALLING_ROUTINE   pfnUnmarshall;
    USER_MARSHAL_FREEING_ROUTINE         pfnFree;
    } USER_MARSHAL_ROUTINE_QUADRUPLE;

#define USER_MARSHAL_CB_SIGNATURE 'USRC'

typedef enum _USER_MARSHAL_CB_TYPE
{
    USER_MARSHAL_CB_BUFFER_SIZE,
    USER_MARSHAL_CB_MARSHALL,
    USER_MARSHAL_CB_UNMARSHALL,
    USER_MARSHAL_CB_FREE
} USER_MARSHAL_CB_TYPE;

typedef struct _USER_MARSHAL_CB
{
    unsigned long           Flags;
    PMIDL_STUB_MESSAGE      pStubMsg;
    PFORMAT_STRING          pReserve;
    unsigned long           Signature;
    USER_MARSHAL_CB_TYPE    CBType;
    PFORMAT_STRING          pFormat;
    PFORMAT_STRING          pTypeFormat;
} USER_MARSHAL_CB;


#define USER_CALL_CTXT_MASK(f)  ((f) & 0x00ff)
#define USER_CALL_AUX_MASK(f)   ((f) & 0xff00)
#define GET_USER_DATA_REP(f)    ((f) >> 16)

#define USER_CALL_IS_ASYNC              0x0100  /* aux flag: in an [async] call */
#define USER_CALL_NEW_CORRELATION_DESC  0x0200

typedef struct _MALLOC_FREE_STRUCT
    {
    void  *     ( __RPC_USER * pfnAllocate)(size_t);
    void        ( __RPC_USER * pfnFree)(void  *);
    } MALLOC_FREE_STRUCT;

typedef struct _COMM_FAULT_OFFSETS
    {
    short       CommOffset;
    short       FaultOffset;
    } COMM_FAULT_OFFSETS;

/*
 * International character support definitions
 */

typedef enum _IDL_CS_CONVERT
    {
    IDL_CS_NO_CONVERT,
    IDL_CS_IN_PLACE_CONVERT,
    IDL_CS_NEW_BUFFER_CONVERT
    } IDL_CS_CONVERT;

typedef void
( __RPC_USER * CS_TYPE_NET_SIZE_ROUTINE)
    (RPC_BINDING_HANDLE     hBinding,
     unsigned long          ulNetworkCodeSet,
     unsigned long          ulLocalBufferSize,
     IDL_CS_CONVERT     *   conversionType,
     unsigned long      *   pulNetworkBufferSize,
     error_status_t     *   pStatus);

typedef void
( __RPC_USER * CS_TYPE_LOCAL_SIZE_ROUTINE)
    (RPC_BINDING_HANDLE     hBinding,
     unsigned long          ulNetworkCodeSet,
     unsigned long          ulNetworkBufferSize,
     IDL_CS_CONVERT     *   conversionType,
     unsigned long      *   pulLocalBufferSize,
     error_status_t     *   pStatus);

typedef void
( __RPC_USER * CS_TYPE_TO_NETCS_ROUTINE)
    (RPC_BINDING_HANDLE     hBinding,
     unsigned long          ulNetworkCodeSet,
     void               *   pLocalData,
     unsigned long          ulLocalDataLength,
     byte               *   pNetworkData,
     unsigned long      *   pulNetworkDataLength,
     error_status_t     *   pStatus);

typedef void
( __RPC_USER * CS_TYPE_FROM_NETCS_ROUTINE)
    (RPC_BINDING_HANDLE     hBinding,
     unsigned long          ulNetworkCodeSet,
     byte               *   pNetworkData,
     unsigned long          ulNetworkDataLength,
     unsigned long          ulLocalBufferSize,
     void               *   pLocalData,
     unsigned long      *   pulLocalDataLength,
     error_status_t     *   pStatus);

typedef void
( __RPC_USER * CS_TAG_GETTING_ROUTINE)
    (RPC_BINDING_HANDLE     hBinding,
     int                    fServerSide,
     unsigned long      *   pulSendingTag,
     unsigned long      *   pulDesiredReceivingTag,
     unsigned long      *   pulReceivingTag,
     error_status_t     *   pStatus);

void __RPC_USER
RpcCsGetTags(
     RPC_BINDING_HANDLE     hBinding,
     int                    fServerSide,
     unsigned long      *   pulSendingTag,
     unsigned long      *   pulDesiredReceivingTag,
     unsigned long      *   pulReceivingTag,
     error_status_t     *   pStatus);

typedef struct _NDR_CS_SIZE_CONVERT_ROUTINES
    {
    CS_TYPE_NET_SIZE_ROUTINE    pfnNetSize;
    CS_TYPE_TO_NETCS_ROUTINE    pfnToNetCs;
    CS_TYPE_LOCAL_SIZE_ROUTINE  pfnLocalSize;
    CS_TYPE_FROM_NETCS_ROUTINE  pfnFromNetCs;
    } NDR_CS_SIZE_CONVERT_ROUTINES;

typedef struct _NDR_CS_ROUTINES
    {
    NDR_CS_SIZE_CONVERT_ROUTINES   *pSizeConvertRoutines;
    CS_TAG_GETTING_ROUTINE         *pTagGettingRoutines;
    } NDR_CS_ROUTINES;

typedef struct _NDR_EXPR_DESC
{
    const unsigned short * pOffset;
    PFORMAT_STRING  pFormatExpr;
} NDR_EXPR_DESC;
/*
 * MIDL Stub Descriptor
 */

typedef struct _MIDL_STUB_DESC
    {
    void  *    RpcInterfaceInformation;

    void  *    ( __RPC_API * pfnAllocate)(size_t);
    void       ( __RPC_API * pfnFree)(void  *);

    union
        {
        handle_t  *             pAutoHandle;
        handle_t  *             pPrimitiveHandle;
        PGENERIC_BINDING_INFO   pGenericBindingInfo;
        } IMPLICIT_HANDLE_INFO;

    const NDR_RUNDOWN  *                    apfnNdrRundownRoutines;
    const GENERIC_BINDING_ROUTINE_PAIR  *   aGenericBindingRoutinePairs;
    const EXPR_EVAL  *                      apfnExprEval;
    const XMIT_ROUTINE_QUINTUPLE  *         aXmitQuintuple;

    const unsigned char  *                  pFormatTypes;

    int                                     fCheckBounds;

    /* Ndr library version. */
    unsigned long                           Version;

    MALLOC_FREE_STRUCT  *                   pMallocFreeStruct;

    long                                    MIDLVersion;

    const COMM_FAULT_OFFSETS  *    CommFaultOffsets;

    // New fields for version 3.0+
    const USER_MARSHAL_ROUTINE_QUADRUPLE  * aUserMarshalQuadruple;

    // Notify routines - added for NT5, MIDL 5.0
    const NDR_NOTIFY_ROUTINE  *             NotifyRoutineTable;

    /*
     * Reserved for future use.
     */

    ULONG_PTR                               mFlags;

    // International support routines - added for 64bit post NT5
    const NDR_CS_ROUTINES *                 CsRoutineTables;

    void *                                  ProxyServerInfo;
    const NDR_EXPR_DESC *               pExprInfo;

    // Fields up to now present in win2000 release.

    } MIDL_STUB_DESC;


typedef const MIDL_STUB_DESC  * PMIDL_STUB_DESC;

typedef void  * PMIDL_XMIT_TYPE;

/*
 * MIDL Stub Format String.  This is a const in the stub.
 */
#if defined(_MSC_EXTENSIONS)
#if !defined( RC_INVOKED )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable:4200 )
#endif
typedef struct _MIDL_FORMAT_STRING
    {
    short               Pad;
    unsigned char       Format[];
    } MIDL_FORMAT_STRING;
#if !defined( RC_INVOKED )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default:4200 )
#endif
#endif
#endif /* _MSC_EXTENSIONS */

/*
 * Stub thunk used for some interpreted server stubs.
 */
typedef void ( __RPC_API * STUB_THUNK)( PMIDL_STUB_MESSAGE );

#ifndef _MANAGED
typedef long ( __RPC_API * SERVER_ROUTINE)();
#else
typedef long ( __RPC_API * SERVER_ROUTINE)(void);
#endif

/*
 * Server Interpreter's information strucuture.
 */
typedef struct  _MIDL_SERVER_INFO_
    {
    PMIDL_STUB_DESC                     pStubDesc;
    const SERVER_ROUTINE     *          DispatchTable;
    PFORMAT_STRING                      ProcString;
    const unsigned short *              FmtStringOffset;
    const STUB_THUNK *                  ThunkTable;
    PRPC_SYNTAX_IDENTIFIER              pTransferSyntax;
    ULONG_PTR                           nCount;
    PMIDL_SYNTAX_INFO                   pSyntaxInfo;
    } MIDL_SERVER_INFO, *PMIDL_SERVER_INFO;

#undef _MIDL_STUBLESS_PROXY_INFO

/*
 * Stubless object proxy information structure.
 */
typedef struct _MIDL_STUBLESS_PROXY_INFO
    {
    PMIDL_STUB_DESC                     pStubDesc;
    PFORMAT_STRING                      ProcFormatString;
    const unsigned short            *   FormatStringOffset;
    PRPC_SYNTAX_IDENTIFIER              pTransferSyntax;
    ULONG_PTR                           nCount;
    PMIDL_SYNTAX_INFO                   pSyntaxInfo;
    } MIDL_STUBLESS_PROXY_INFO;

typedef MIDL_STUBLESS_PROXY_INFO  * PMIDL_STUBLESS_PROXY_INFO;

/*
 *  Multiple transfer syntax information.
 */
typedef struct _MIDL_SYNTAX_INFO
{
RPC_SYNTAX_IDENTIFIER               TransferSyntax;
RPC_DISPATCH_TABLE *                DispatchTable;
PFORMAT_STRING                      ProcString;
const unsigned short *              FmtStringOffset;
PFORMAT_STRING                      TypeString;
const void           *              aUserMarshalQuadruple;
ULONG_PTR                           pReserved1;
ULONG_PTR                           pReserved2;
} MIDL_SYNTAX_INFO, *PMIDL_SYNTAX_INFO;

typedef unsigned short * PARAM_OFFSETTABLE, *PPARAM_OFFSETTABLE;

/*
 * This is the return value from NdrClientCall.
 */
typedef union _CLIENT_CALL_RETURN
    {
    void  *         Pointer;
    LONG_PTR        Simple;
    } CLIENT_CALL_RETURN;

// BUGBUG: can we get rid of this defintion altogether, just leave void * here?
typedef enum
        {
        XLAT_SERVER = 1,
        XLAT_CLIENT
        } XLAT_SIDE;

typedef struct _FULL_PTR_XLAT_TABLES
{
    void * RefIdToPointer;
    void * PointerToRefId;
    unsigned long           NextRefId;   
    XLAT_SIDE               XlatSide;
} FULL_PTR_XLAT_TABLES, *PFULL_PTR_XLAT_TABLES;

/***************************************************************************
 ** New MIDL 2.0 Ndr routine templates
 ***************************************************************************/

RPC_STATUS RPC_ENTRY
NdrClientGetSupportedSyntaxes(
    __in RPC_CLIENT_INTERFACE * pInf,
    __out unsigned long       * pCount,
    __out MIDL_SYNTAX_INFO   ** pArr );


RPC_STATUS RPC_ENTRY
NdrServerGetSupportedSyntaxes(
    __in RPC_SERVER_INTERFACE * pInf,
    __out unsigned long       * pCount,
    __out MIDL_SYNTAX_INFO   ** pArr,
    __out unsigned long       * pPreferSyntaxIndex);

/*
 * Marshall routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleTypeMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    unsigned char           FormatChar
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrPointerMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrCsArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrCsTagMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Structures */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrSimpleStructMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantStructMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantVaryingStructMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrComplexStructMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Arrays */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrFixedArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrComplexArrayMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Strings */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNonConformantStringMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantStringMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Unions */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrEncapsulatedUnionMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNonEncapsulatedUnionMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Byte count pointer */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrByteCountPointerMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrXmitOrRepAsMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* User_marshal */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrUserMarshalMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Interface pointer */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrInterfacePointerMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Context handles */

RPCRTAPI
void
RPC_ENTRY
NdrClientContextMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    NDR_CCONTEXT            ContextHandle,
    int                     fCheck
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerContextMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    NDR_SCONTEXT            ContextHandle,
    NDR_RUNDOWN             RundownRoutine
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerContextNewMarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    NDR_SCONTEXT            ContextHandle,
    NDR_RUNDOWN             RundownRoutine,
    PFORMAT_STRING          pFormat
    );

/*
 * Unmarshall routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleTypeUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    unsigned char           FormatChar
    );

RPCRTAPI
unsigned char * RPC_ENTRY
RPC_ENTRY
NdrCsArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char **        ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char * RPC_ENTRY
RPC_ENTRY
NdrCsTagUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char **        ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char * RPC_ENTRY
NdrRangeUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char **        ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
void
RPC_ENTRY
NdrCorrelationInitialize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    void  *                 pMemory,
    unsigned long           CacheSize,
    unsigned long           flags
    );

RPCRTAPI
void
RPC_ENTRY
NdrCorrelationPass(
    PMIDL_STUB_MESSAGE      pStubMsg
    );

RPCRTAPI
void
RPC_ENTRY
NdrCorrelationFree(
    PMIDL_STUB_MESSAGE      pStubMsg
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrPointerUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Structures */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrSimpleStructUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantStructUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantVaryingStructUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrComplexStructUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Arrays */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrFixedArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrComplexArrayUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Strings */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNonConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Unions */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrEncapsulatedUnionUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNonEncapsulatedUnionUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Byte count pointer */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrByteCountPointerUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrXmitOrRepAsUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* User_marshal */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrUserMarshalUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Interface pointer */

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrInterfacePointerUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *  *     ppMemory,
    PFORMAT_STRING          pFormat,
    unsigned char           fMustAlloc
    );

/* Context handles */

RPCRTAPI
void
RPC_ENTRY
NdrClientContextUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg,
    NDR_CCONTEXT        *   pContextHandle,
    RPC_BINDING_HANDLE      BindHandle
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NdrServerContextUnmarshall(
    PMIDL_STUB_MESSAGE      pStubMsg
    );

/* New context handle flavors */

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NdrContextHandleInitialize(
    __in  PMIDL_STUB_MESSAGE  pStubMsg,
    __in  PFORMAT_STRING      pFormat
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NdrServerContextNewUnmarshall(
    __in  PMIDL_STUB_MESSAGE  pStubMsg,
    __in  PFORMAT_STRING      pFormat
    );

/*
 * Buffer sizing routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrPointerBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrCsArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrCsTagBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Structures */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleStructBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantStructBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingStructBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexStructBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Arrays */

RPCRTAPI
void
RPC_ENTRY
NdrFixedArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrVaryingArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexArrayBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Strings */

RPCRTAPI
void
RPC_ENTRY
NdrConformantStringBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonConformantStringBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Unions */

RPCRTAPI
void
RPC_ENTRY
NdrEncapsulatedUnionBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonEncapsulatedUnionBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Byte count pointer */

RPCRTAPI
void
RPC_ENTRY
NdrByteCountPointerBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
void
RPC_ENTRY
NdrXmitOrRepAsBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* User_marshal */

RPCRTAPI
void
RPC_ENTRY
NdrUserMarshalBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Interface pointer */

RPCRTAPI
void
RPC_ENTRY
NdrInterfacePointerBufferSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

// Context Handle size
//
RPCRTAPI
void
RPC_ENTRY
NdrContextHandleSize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/*
 * Memory sizing routines
 */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrPointerMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrContextHandleMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );


/* cs_char things */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrCsArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrCsTagMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Structures */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrSimpleStructMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantStructMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantVaryingStructMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrComplexStructMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Arrays */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrFixedArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrComplexArrayMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Strings */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantStringMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrNonConformantStringMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Unions */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrNonEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned long
RPC_ENTRY
NdrXmitOrRepAsMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* User_marshal */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrUserMarshalMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/* Interface pointer */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrInterfacePointerMemorySize(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

/*
 * Freeing routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrPointerFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrCsArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Structures */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleStructFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantStructFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingStructFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexStructFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Arrays */

RPCRTAPI
void
RPC_ENTRY
NdrFixedArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrVaryingArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexArrayFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Unions */

RPCRTAPI
void
RPC_ENTRY
NdrEncapsulatedUnionFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonEncapsulatedUnionFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Byte count */

RPCRTAPI
void
RPC_ENTRY
NdrByteCountPointerFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
void
RPC_ENTRY
NdrXmitOrRepAsFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* User_marshal */

RPCRTAPI
void
RPC_ENTRY
NdrUserMarshalFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/* Interface pointer */

RPCRTAPI
void
RPC_ENTRY
NdrInterfacePointerFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pMemory,
    PFORMAT_STRING          pFormat
    );

/*
 * Endian conversion routine.
 */

RPCRTAPI
void
RPC_ENTRY
NdrConvert2(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat,
    long                    NumberParams
    );

RPCRTAPI
void
RPC_ENTRY
NdrConvert(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat
    );

#define USER_MARSHAL_FC_BYTE         1
#define USER_MARSHAL_FC_CHAR         2
#define USER_MARSHAL_FC_SMALL        3
#define USER_MARSHAL_FC_USMALL       4
#define USER_MARSHAL_FC_WCHAR        5
#define USER_MARSHAL_FC_SHORT        6
#define USER_MARSHAL_FC_USHORT       7
#define USER_MARSHAL_FC_LONG         8
#define USER_MARSHAL_FC_ULONG        9
#define USER_MARSHAL_FC_FLOAT       10
#define USER_MARSHAL_FC_HYPER       11
#define USER_MARSHAL_FC_DOUBLE      12

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrUserMarshalSimpleTypeConvert(
    unsigned long *         pFlags,
    unsigned char *         pBuffer,
    unsigned char           FormatChar
    );

/*
 * Auxilary routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrClientInitializeNew(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    unsigned int            ProcNum
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrServerInitializeNew(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerInitializePartial(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    unsigned long           RequestedBufferSize
    );

RPCRTAPI
void
RPC_ENTRY
NdrClientInitialize(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    unsigned int            ProcNum
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrServerInitialize(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrServerInitializeUnmarshall (
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    PRPC_MESSAGE            pRpcMsg
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerInitializeMarshall (
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrGetBuffer(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned long           BufferLength,
    RPC_BINDING_HANDLE      Handle
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNsGetBuffer(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned long           BufferLength,
    RPC_BINDING_HANDLE      Handle
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrSendReceive(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char *         pBufferEnd
    );

RPCRTAPI
unsigned char  *
RPC_ENTRY
NdrNsSendReceive(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned char  *        pBufferEnd,
    RPC_BINDING_HANDLE  *   pAutoHandle
    );

RPCRTAPI
void
RPC_ENTRY
NdrFreeBuffer(
    PMIDL_STUB_MESSAGE      pStubMsg
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
NdrGetDcomProtocolVersion(
    PMIDL_STUB_MESSAGE      pStubMsg,
    RPC_VERSION *           pVersion );


/*
 * Interpreter calls.
 */

/* client */

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall2(
    PMIDL_STUB_DESC         pStubDescriptor,
    PFORMAT_STRING          pFormat,
    ...
    );


CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall(
    PMIDL_STUB_DESC         pStubDescriptor,
    PFORMAT_STRING          pFormat,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrAsyncClientCall(
    PMIDL_STUB_DESC         pStubDescriptor,
    PFORMAT_STRING          pFormat,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrDcomAsyncClientCall(
    PMIDL_STUB_DESC         pStubDescriptor,
    PFORMAT_STRING          pFormat,
    ...
    );

/* server */
typedef enum {
    STUB_UNMARSHAL,
    STUB_CALL_SERVER,
    STUB_MARSHAL,
    STUB_CALL_SERVER_NO_HRESULT
}STUB_PHASE;

typedef enum {
    PROXY_CALCSIZE,
    PROXY_GETBUFFER,
    PROXY_MARSHAL,
    PROXY_SENDRECEIVE,
    PROXY_UNMARSHAL
}PROXY_PHASE;

struct IRpcStubBuffer;      // Forward declaration

// Raw RPC only
RPCRTAPI
void
RPC_ENTRY
NdrAsyncServerCall(
    PRPC_MESSAGE                pRpcMsg
    );

// old dcom async scheme
RPCRTAPI
long
RPC_ENTRY
NdrAsyncStubCall(
    struct IRpcStubBuffer *     pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    unsigned long *             pdwStubPhase
    );

// async uuid
RPCRTAPI
long
RPC_ENTRY
NdrDcomAsyncStubCall(
    struct IRpcStubBuffer    *  pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    unsigned long            *  pdwStubPhase
    );

RPCRTAPI
long
RPC_ENTRY
NdrStubCall2(
    void  *    pThis, // struct IRpcStubBuffer
    void  * pChannel, // struct IRpcChannelBuffer
    PRPC_MESSAGE                pRpcMsg,
    unsigned long  *            pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCall2(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
long
RPC_ENTRY
NdrStubCall (
    void  *    pThis, // struct IRpcStubBuffer
    void  * pChannel, // struct IRpcChannelBuffer
    PRPC_MESSAGE                pRpcMsg,
    unsigned long  *            pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCall(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
int
RPC_ENTRY
NdrServerUnmarshall(
    void  * pChannel, // Converted to struct IRpcChannelBuffer
    PRPC_MESSAGE                pRpcMsg,
    PMIDL_STUB_MESSAGE          pStubMsg,
    PMIDL_STUB_DESC             pStubDescriptor,
    PFORMAT_STRING              pFormat,
    void  *                     pParamList
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerMarshall(
    void  *    pThis, //Converted to struct IRpcStubBuffer
    void  * pChannel, // Converted to struct IRpcChannelBuffer
    PMIDL_STUB_MESSAGE          pStubMsg,
    PFORMAT_STRING              pFormat
    );

/* Comm and Fault status */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
NdrMapCommAndFaultStatus(
    PMIDL_STUB_MESSAGE          pStubMsg,
    unsigned long  *            pCommStatus,
    unsigned long  *            pFaultStatus,
    RPC_STATUS                  Status
    );



/****************************************************************************
    MIDL 2.0 memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

typedef void  * RPC_SS_THREAD_HANDLE;

typedef void  * __RPC_API
RPC_CLIENT_ALLOC (
    __in size_t Size
    );

typedef void __RPC_API
RPC_CLIENT_FREE (
    __in void  * Ptr
    );

/*++
     RpcSs* package
--*/

RPCRTAPI
void  *
RPC_ENTRY
RpcSsAllocate (
    __in size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsDisableAllocate (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsEnableAllocate (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsFree (
    __in void  * NodeToFree
    );

RPCRTAPI
RPC_SS_THREAD_HANDLE
RPC_ENTRY
RpcSsGetThreadHandle (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSetClientAllocFree (
    __in RPC_CLIENT_ALLOC  * ClientAlloc,
    __in RPC_CLIENT_FREE   * ClientFree
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSetThreadHandle (
    __in RPC_SS_THREAD_HANDLE Id
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSwapClientAllocFree (
    __in RPC_CLIENT_ALLOC     * ClientAlloc,
    __in RPC_CLIENT_FREE      * ClientFree,
    __out RPC_CLIENT_ALLOC *  * OldClientAlloc,
    __out RPC_CLIENT_FREE  *  * OldClientFree
    );

/*++
     RpcSm* package
--*/

RPCRTAPI
void  *
RPC_ENTRY
RpcSmAllocate (
    __in  size_t          Size,
    __out RPC_STATUS  *   pStatus
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmClientFree (
    __in  void        *   pNodeToFree
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmDestroyClientContext (
    __in void         * * ContextHandle
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmDisableAllocate (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmEnableAllocate (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmFree (
    __in void         *   NodeToFree
    );

RPCRTAPI
RPC_SS_THREAD_HANDLE
RPC_ENTRY
RpcSmGetThreadHandle (
    __out RPC_STATUS  *   pStatus
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSetClientAllocFree (
    __in RPC_CLIENT_ALLOC * ClientAlloc,
    __in RPC_CLIENT_FREE  * ClientFree
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSetThreadHandle (
    __in RPC_SS_THREAD_HANDLE Id
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSwapClientAllocFree (
    __in RPC_CLIENT_ALLOC     *   ClientAlloc,
    __in RPC_CLIENT_FREE      *   ClientFree,
    __out RPC_CLIENT_ALLOC    * * OldClientAlloc,
    __out RPC_CLIENT_FREE     * * OldClientFree
    );

/*++
     Ndr stub entry points
--*/

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsEnableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsDisableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSmSetClientToOsf(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void  *
RPC_ENTRY
NdrRpcSmClientAllocate (
    __in size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSmClientFree (
    __in void  * NodeToFree
    );

RPCRTAPI
void  *
RPC_ENTRY
NdrRpcSsDefaultAllocate (
    __in size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsDefaultFree (
    __in void  * NodeToFree
    );

/****************************************************************************
    end of memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

/****************************************************************************
 * Full Pointer APIs
 ****************************************************************************/

RPCRTAPI
PFULL_PTR_XLAT_TABLES
RPC_ENTRY
NdrFullPointerXlatInit(
    unsigned long           NumberOfPointers,
    XLAT_SIDE               XlatSide
    );

RPCRTAPI
void
RPC_ENTRY
NdrFullPointerXlatFree(
    PFULL_PTR_XLAT_TABLES   pXlatTables
    );


RPCRTAPI
void  *
RPC_ENTRY
NdrAllocate(
    PMIDL_STUB_MESSAGE      pStubMsg,
    size_t                  Len
    );

RPCRTAPI
void
RPC_ENTRY
NdrClearOutParameters(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat,
    void  *                 ArgAddr
    );


/****************************************************************************
 * Proxy APIs
 ****************************************************************************/

RPCRTAPI
void  *
RPC_ENTRY
NdrOleAllocate (
    __in size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrOleFree (
    __in void  * NodeToFree
    );

#ifdef CONST_VTABLE
#define CONST_VTBL const
#else
#define CONST_VTBL
#endif

/****************************************************************************
 * VC COM support 
 ****************************************************************************/

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef DECLSPEC_NOVTABLE
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_NOVTABLE __declspec(novtable)
#else
#define DECLSPEC_NOVTABLE
#endif
#endif

#ifndef DECLSPEC_UUID
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_UUID(x) __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#define MIDL_INTERFACE(x)   struct DECLSPEC_UUID(x) DECLSPEC_NOVTABLE

#if _MSC_VER >= 1100
#define EXTERN_GUID(itf,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8)  \
  EXTERN_C const IID DECLSPEC_SELECTANY itf = {l1,s1,s2,{c1,c2,c3,c4,c5,c6,c7,c8}}
#else
#define EXTERN_GUID(itf,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8) EXTERN_C const IID itf
#endif

/****************************************************************************
 * UserMarshal information
 ****************************************************************************/

typedef struct _NDR_USER_MARSHAL_INFO_LEVEL1
{
    void *                      Buffer;
    unsigned long               BufferSize;
    void *(__RPC_API * pfnAllocate)(size_t);
    void (__RPC_API * pfnFree)(void *);
    struct IRpcChannelBuffer *  pRpcChannelBuffer;
    ULONG_PTR                   Reserved[5];
} NDR_USER_MARSHAL_INFO_LEVEL1;

#if !defined( RC_INVOKED )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#endif

typedef struct _NDR_USER_MARSHAL_INFO
{
    unsigned long InformationLevel;
    union {
        NDR_USER_MARSHAL_INFO_LEVEL1 Level1;
    } DUMMYUNIONNAME;
} NDR_USER_MARSHAL_INFO;

#if !defined( RC_INVOKED )
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif
#endif

RPC_STATUS
RPC_ENTRY
NdrGetUserMarshalInfo (
    __in unsigned long        *   pFlags,
    __in unsigned long            InformationLevel,
    __out NDR_USER_MARSHAL_INFO * pMarshalInfo
    );

/****************************************************************************
 * 64bit APIs
 ****************************************************************************/
RPC_STATUS RPC_ENTRY
NdrCreateServerInterfaceFromStub(
            __in struct IRpcStubBuffer* pStub,
            __inout RPC_SERVER_INTERFACE *pServerIf );

/*
 * Interpreter calls
 */
CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall3(
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    unsigned long               nProcNum,
    void *                      pReturnValue,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
Ndr64AsyncClientCall(
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    unsigned long               nProcNum,
    void *                      pReturnValue,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
Ndr64DcomAsyncClientCall(
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    unsigned long               nProcNum,
    void *                      pReturnValue,
    ...
    );

struct IRpcStubBuffer;      // Forward declaration

RPCRTAPI
void
RPC_ENTRY
Ndr64AsyncServerCall(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
void
RPC_ENTRY
Ndr64AsyncServerCall64(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
void
RPC_ENTRY
Ndr64AsyncServerCallAll(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
long
RPC_ENTRY
Ndr64AsyncStubCall(
    struct IRpcStubBuffer *     pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    unsigned long *             pdwStubPhase
    );

/* async uuid */
RPCRTAPI
long
RPC_ENTRY
Ndr64DcomAsyncStubCall(
    struct IRpcStubBuffer    *  pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    unsigned long            *  pdwStubPhase
    );

RPCRTAPI
long
RPC_ENTRY
NdrStubCall3 (
    void  *    pThis, // struct IRpcStubBuffer
    void  * pChannel, // struct IRpcChannelBuffer
    PRPC_MESSAGE                pRpcMsg,
    unsigned long  *            pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCallAll(
    PRPC_MESSAGE                pRpcMsg
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCallNdr64(
    PRPC_MESSAGE                pRpcMsg
    );


RPCRTAPI
void
RPC_ENTRY
NdrServerCall3(
    PRPC_MESSAGE                pRpcMsg
    );


/* [partial_ignore] functions*/
RPCRTAPI
void
RPC_ENTRY
NdrPartialIgnoreClientMarshall(
    PMIDL_STUB_MESSAGE          pStubMsg,
    void *                      pMemory
    );

RPCRTAPI
void
RPC_ENTRY
NdrPartialIgnoreServerUnmarshall(
    PMIDL_STUB_MESSAGE          pStubMsg,
    void **                     ppMemory
    );

RPCRTAPI
void
RPC_ENTRY
NdrPartialIgnoreClientBufferSize(
    PMIDL_STUB_MESSAGE          pStubMsg,
    void *                      pMemory
    );

RPCRTAPI
void
RPC_ENTRY
NdrPartialIgnoreServerInitialize(
    PMIDL_STUB_MESSAGE          pStubMsg,
    void **                     ppMemory,
    PFORMAT_STRING              pFormat
    );


void RPC_ENTRY
RpcUserFree( handle_t AsyncHandle, void * pBuffer );

#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif /* __RPCNDR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RpcNsi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcnsi.h

Abstract:

    This file contains the types and function definitions to use the
    Name Service Independent APIs.

--*/

#ifndef __RPCNSI_H__
#define __RPCNSI_H__

#if _MSC_VER > 1000
#pragma once
#endif

typedef void __RPC_FAR * RPC_NS_HANDLE;

#define RPC_C_NS_SYNTAX_DEFAULT 0
#define RPC_C_NS_SYNTAX_DCE 3

#define RPC_C_PROFILE_DEFAULT_ELT 0
#define RPC_C_PROFILE_ALL_ELT 1
#define RPC_C_PROFILE_ALL_ELTS RPC_C_PROFILE_ALL_ELT
#define RPC_C_PROFILE_MATCH_BY_IF 2
#define RPC_C_PROFILE_MATCH_BY_MBR 3
#define RPC_C_PROFILE_MATCH_BY_BOTH 4

#define RPC_C_NS_DEFAULT_EXP_AGE -1

/* Server APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingExportA(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_CSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt RPC_BINDING_VECTOR __RPC_FAR *BindingVec,
    __in_opt UUID_VECTOR __RPC_FAR *ObjectUuidVec
    );


RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportA(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_CSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID_VECTOR __RPC_FAR *ObjectUuidVec
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingExportW(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_WSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt RPC_BINDING_VECTOR __RPC_FAR *BindingVec,
    __in_opt UUID_VECTOR __RPC_FAR *ObjectUuidVec
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportW(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_WSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID_VECTOR __RPC_FAR *ObjectUuidVec
    );

#endif

/* Server PnP APIs */

RPC_STATUS RPC_ENTRY
RpcNsBindingExportPnPA(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_CSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID_VECTOR *ObjectVector
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportPnPA(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_CSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID_VECTOR *ObjectVector
    );

#ifdef RPC_UNICODE_SUPPORTED

RPC_STATUS RPC_ENTRY
RpcNsBindingExportPnPW(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_WSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID_VECTOR *ObjectVector
    );

RPC_STATUS RPC_ENTRY
RpcNsBindingUnexportPnPW(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_WSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID_VECTOR *ObjectVector
    );

#endif

/* Client APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingLookupBeginA(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_CSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR *ObjUuid,
    __in unsigned long BindingMaxCount,
    __out RPC_NS_HANDLE __RPC_FAR *LookupContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingLookupBeginW(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_WSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR *ObjUuid,
    __in unsigned long BindingMaxCount,
    __out RPC_NS_HANDLE __RPC_FAR *LookupContext
    );
#endif

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingLookupNext(
    IN  RPC_NS_HANDLE LookupContext,
    OUT RPC_BINDING_VECTOR __RPC_FAR * __RPC_FAR * BindingVec
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingLookupDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * LookupContext
    );

/* Group APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupDeleteA(
    __in unsigned long GroupNameSyntax,
    __in_opt RPC_CSTR GroupName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrAddA(
    __in unsigned long GroupNameSyntax,
    __in RPC_CSTR GroupName,
    __in unsigned long MemberNameSyntax,
    __in RPC_CSTR MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrRemoveA(
    __in unsigned long GroupNameSyntax,
    __in RPC_CSTR GroupName,
    __in unsigned long MemberNameSyntax,
    __in RPC_CSTR MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqBeginA(
    __in unsigned long GroupNameSyntax,
    __in RPC_CSTR GroupName,
    __in unsigned long MemberNameSyntax,
    __out RPC_NS_HANDLE __RPC_FAR *InquiryContext
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqNextA(
    __inout RPC_NS_HANDLE InquiryContext,
    __deref_out RPC_CSTR __RPC_FAR *MemberName
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupDeleteW(
    __in unsigned long GroupNameSyntax,
    __in_opt RPC_WSTR GroupName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrAddW(
    __in unsigned long GroupNameSyntax,
    __in RPC_WSTR GroupName,
    __in unsigned long MemberNameSyntax,
    __in RPC_WSTR MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrRemoveW(
    __in unsigned long GroupNameSyntax,
    __in RPC_WSTR GroupName,
    __in unsigned long MemberNameSyntax,
    __in RPC_WSTR MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqBeginW(
    __in unsigned long GroupNameSyntax,
    __in RPC_WSTR GroupName,
    __in unsigned long MemberNameSyntax,
    __out RPC_NS_HANDLE __RPC_FAR *InquiryContext
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqNextW(
    __inout RPC_NS_HANDLE InquiryContext,
    __deref_out RPC_WSTR __RPC_FAR *MemberName
    );

#endif

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsGroupMbrInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Profile APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileDeleteA(
    __in unsigned long ProfileNameSyntax,
    __in RPC_CSTR ProfileName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltAddA(
    __in unsigned long ProfileNameSyntax,
    __in RPC_CSTR ProfileName,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long MemberNameSyntax,
    __in RPC_CSTR MemberName,
    __in unsigned long Priority,
    __in_opt RPC_CSTR Annotation
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltRemoveA(
    __in unsigned long ProfileNameSyntax,
    __in RPC_CSTR ProfileName,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long MemberNameSyntax,
    __in RPC_CSTR MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqBeginA(
    __in unsigned long ProfileNameSyntax,
    __in RPC_CSTR ProfileName,
    __in unsigned long InquiryType,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long VersOption,
    __in unsigned long MemberNameSyntax,
    __in_opt RPC_CSTR MemberName,
    __out RPC_NS_HANDLE __RPC_FAR *InquiryContext
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqNextA(
    __in RPC_NS_HANDLE InquiryContext,
    __out_opt RPC_IF_ID __RPC_FAR *IfId,
    __out RPC_CSTR __RPC_FAR *MemberName,
    __out unsigned long __RPC_FAR *Priority,
    __out RPC_CSTR __RPC_FAR *Annotation
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileDeleteW(
    __in unsigned long ProfileNameSyntax,
    __in RPC_WSTR ProfileName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltAddW(
    __in unsigned long ProfileNameSyntax,
    __in RPC_WSTR ProfileName,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long MemberNameSyntax,
    __in RPC_WSTR MemberName,
    __in unsigned long Priority,
    __in_opt RPC_WSTR Annotation
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltRemoveW(
    __in unsigned long ProfileNameSyntax,
    __in RPC_WSTR ProfileName,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long MemberNameSyntax,
    __in RPC_WSTR MemberName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqBeginW(
    __in unsigned long ProfileNameSyntax,
    __in RPC_WSTR ProfileName,
    __in unsigned long InquiryType,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long VersOption,
    __in unsigned long MemberNameSyntax,
    __in_opt RPC_WSTR MemberName,
    __out RPC_NS_HANDLE __RPC_FAR *InquiryContext
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqNextW(
    __in RPC_NS_HANDLE InquiryContext,
    __out_opt RPC_IF_ID __RPC_FAR *IfId,
    __out RPC_WSTR __RPC_FAR *MemberName,
    __out unsigned long __RPC_FAR *Priority,
    __out RPC_WSTR __RPC_FAR *Annotation
    );

#endif

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsProfileEltInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Entry object APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqBeginA(
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName,
    __out RPC_NS_HANDLE __RPC_FAR *InquiryContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqBeginW(
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName,
    __out RPC_NS_HANDLE __RPC_FAR *InquiryContext
    );

#endif

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqNext(
    IN  RPC_NS_HANDLE InquiryContext,
    OUT UUID __RPC_FAR * ObjUuid
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryObjectInqDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * InquiryContext
    );

/* Management and MISC APIs */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryExpandNameA(
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName,
    __out RPC_CSTR __RPC_FAR *ExpandedName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtBindingUnexportA(
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long VersOption,
    __in_opt UUID_VECTOR __RPC_FAR *ObjectUuidVec
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryCreateA(
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryDeleteA(
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryInqIfIdsA(
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName,
    __out RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR *IfIdVec
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtHandleSetExpAge(
    IN RPC_NS_HANDLE NsHandle,
    IN unsigned long ExpirationAge
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtInqExpAge(
    OUT unsigned long __RPC_FAR * ExpirationAge
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtSetExpAge(
    IN unsigned long ExpirationAge
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsEntryExpandNameW(
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName,
    __out RPC_WSTR __RPC_FAR *ExpandedName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtBindingUnexportW(
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName,
    __in_opt RPC_IF_ID __RPC_FAR *IfId,
    __in unsigned long VersOption,
    __in_opt UUID_VECTOR __RPC_FAR *ObjectUuidVec
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryCreateW(
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryDeleteW(
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsMgmtEntryInqIfIdsW(
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName,
    __out RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR *IfIdVec
    );

#endif

/* Client API's implemented in wrappers. */

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingImportBeginA(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_CSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR *ObjUuid,
    __out RPC_NS_HANDLE __RPC_FAR *ImportContext
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingImportBeginW(
    __in unsigned long EntryNameSyntax,
    __in_opt RPC_WSTR EntryName,
    __in_opt RPC_IF_HANDLE IfSpec,
    __in_opt UUID __RPC_FAR *ObjUuid,
    __out RPC_NS_HANDLE __RPC_FAR *ImportContext
    );

#endif

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingImportNext(
    IN RPC_NS_HANDLE ImportContext,
    OUT RPC_BINDING_HANDLE  __RPC_FAR * Binding
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingImportDone(
    IN OUT RPC_NS_HANDLE __RPC_FAR * ImportContext
    );

RPCNSAPI RPC_STATUS RPC_ENTRY
RpcNsBindingSelect(
    IN OUT RPC_BINDING_VECTOR __RPC_FAR * BindingVec,
    OUT RPC_BINDING_HANDLE  __RPC_FAR * Binding
    );

#ifdef UNICODE

#define RpcNsBindingLookupBegin RpcNsBindingLookupBeginW
#define RpcNsBindingImportBegin RpcNsBindingImportBeginW
#define RpcNsBindingExport RpcNsBindingExportW
#define RpcNsBindingUnexport RpcNsBindingUnexportW
#define RpcNsGroupDelete RpcNsGroupDeleteW
#define RpcNsGroupMbrAdd RpcNsGroupMbrAddW
#define RpcNsGroupMbrRemove RpcNsGroupMbrRemoveW
#define RpcNsGroupMbrInqBegin RpcNsGroupMbrInqBeginW
#define RpcNsGroupMbrInqNext RpcNsGroupMbrInqNextW
#define RpcNsEntryExpandName RpcNsEntryExpandNameW
#define RpcNsEntryObjectInqBegin RpcNsEntryObjectInqBeginW
#define RpcNsMgmtBindingUnexport RpcNsMgmtBindingUnexportW
#define RpcNsMgmtEntryCreate RpcNsMgmtEntryCreateW
#define RpcNsMgmtEntryDelete RpcNsMgmtEntryDeleteW
#define RpcNsMgmtEntryInqIfIds RpcNsMgmtEntryInqIfIdsW
#define RpcNsProfileDelete RpcNsProfileDeleteW
#define RpcNsProfileEltAdd RpcNsProfileEltAddW
#define RpcNsProfileEltRemove RpcNsProfileEltRemoveW
#define RpcNsProfileEltInqBegin RpcNsProfileEltInqBeginW
#define RpcNsProfileEltInqNext RpcNsProfileEltInqNextW
#define RpcNsBindingExportPnP RpcNsBindingExportPnPW
#define RpcNsBindingUnexportPnP RpcNsBindingUnexportPnPW

#else

#define RpcNsBindingLookupBegin RpcNsBindingLookupBeginA
#define RpcNsBindingImportBegin RpcNsBindingImportBeginA
#define RpcNsBindingExport RpcNsBindingExportA
#define RpcNsBindingUnexport RpcNsBindingUnexportA
#define RpcNsGroupDelete RpcNsGroupDeleteA
#define RpcNsGroupMbrAdd RpcNsGroupMbrAddA
#define RpcNsGroupMbrRemove RpcNsGroupMbrRemoveA
#define RpcNsGroupMbrInqBegin RpcNsGroupMbrInqBeginA
#define RpcNsGroupMbrInqNext RpcNsGroupMbrInqNextA
#define RpcNsEntryExpandName RpcNsEntryExpandNameA
#define RpcNsEntryObjectInqBegin RpcNsEntryObjectInqBeginA
#define RpcNsMgmtBindingUnexport RpcNsMgmtBindingUnexportA
#define RpcNsMgmtEntryCreate RpcNsMgmtEntryCreateA
#define RpcNsMgmtEntryDelete RpcNsMgmtEntryDeleteA
#define RpcNsMgmtEntryInqIfIds RpcNsMgmtEntryInqIfIdsA
#define RpcNsProfileDelete RpcNsProfileDeleteA
#define RpcNsProfileEltAdd RpcNsProfileEltAddA
#define RpcNsProfileEltRemove RpcNsProfileEltRemoveA
#define RpcNsProfileEltInqBegin RpcNsProfileEltInqBeginA
#define RpcNsProfileEltInqNext RpcNsProfileEltInqNextA
#define RpcNsBindingExportPnP RpcNsBindingExportPnPA
#define RpcNsBindingUnexportPnP RpcNsBindingUnexportPnPA
#endif /* UNICODE */

#endif /* __RPCNSI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RpcDceP.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcdcep.h

Abstract:

    This module contains the private RPC runtime APIs for use by the
    stubs and by support libraries.  Applications must not call these
    routines.

--*/

#ifndef __RPCDCEP_H__
#define __RPCDCEP_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _RPC_VERSION {
    unsigned short MajorVersion;
    unsigned short MinorVersion;
} RPC_VERSION;

typedef struct _RPC_SYNTAX_IDENTIFIER {
    GUID SyntaxGUID;
    RPC_VERSION SyntaxVersion;
} RPC_SYNTAX_IDENTIFIER, __RPC_FAR * PRPC_SYNTAX_IDENTIFIER;

typedef struct _RPC_MESSAGE
{
    RPC_BINDING_HANDLE Handle;
    unsigned long DataRepresentation;
    void __RPC_FAR * Buffer;
    unsigned int BufferLength;
    unsigned int ProcNum;
    PRPC_SYNTAX_IDENTIFIER TransferSyntax;
    void __RPC_FAR * RpcInterfaceInformation;
    void __RPC_FAR * ReservedForRuntime;
    RPC_MGR_EPV __RPC_FAR * ManagerEpv;
    void __RPC_FAR * ImportContext;
    unsigned long RpcFlags;
} RPC_MESSAGE, __RPC_FAR * PRPC_MESSAGE;


typedef RPC_STATUS
RPC_ENTRY RPC_FORWARD_FUNCTION(
                       IN UUID             __RPC_FAR * InterfaceId,
                       IN RPC_VERSION      __RPC_FAR * InterfaceVersion,
                       IN UUID             __RPC_FAR * ObjectId,
                       IN unsigned char         __RPC_FAR * Rpcpro,
                       IN void __RPC_FAR * __RPC_FAR * ppDestEndpoint);

enum RPC_ADDRESS_CHANGE_TYPE
{
    PROTOCOL_NOT_LOADED = 1,
    PROTOCOL_LOADED,
    PROTOCOL_ADDRESS_CHANGE
};

typedef void
RPC_ENTRY RPC_ADDRESS_CHANGE_FN(
                        IN void * arg
                        );

/*
*  New context handle flavors.
*/
#define RPC_CONTEXT_HANDLE_DEFAULT_GUARD    ((void *)(ULONG_PTR)0xFFFFF00D)

#define RPC_CONTEXT_HANDLE_DEFAULT_FLAGS    0x00000000UL
#define RPC_CONTEXT_HANDLE_FLAGS            0x30000000UL
#define RPC_CONTEXT_HANDLE_SERIALIZE        0x10000000UL
#define RPC_CONTEXT_HANDLE_DONT_SERIALIZE   0x20000000UL
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_TYPE_STRICT_CONTEXT_HANDLE      0x40000000UL
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

/*
 * Types of function calls for datagram rpc
 */

#define RPC_NCA_FLAGS_DEFAULT       0x00000000  /* 0b000...000 */
#define RPC_NCA_FLAGS_IDEMPOTENT    0x00000001  /* 0b000...001 */
#define RPC_NCA_FLAGS_BROADCAST     0x00000002  /* 0b000...010 */
#define RPC_NCA_FLAGS_MAYBE         0x00000004  /* 0b000...100 */

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPCFLG_HAS_GUARANTEE        0x00000010UL
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define RPC_BUFFER_COMPLETE         0x00001000 /* used by pipes */
#define RPC_BUFFER_PARTIAL          0x00002000 /* used by pipes */
#define RPC_BUFFER_EXTRA            0x00004000 /* used by pipes */
#define RPC_BUFFER_ASYNC            0x00008000 /* used by async rpc */
#define RPC_BUFFER_NONOTIFY         0x00010000 /* used by async pipes */


#define RPCFLG_MESSAGE              0x01000000UL
#define RPCFLG_AUTO_COMPLETE        0x08000000UL
#define RPCFLG_LOCAL_CALL           0x10000000UL
#define RPCFLG_INPUT_SYNCHRONOUS    0x20000000UL
#define RPCFLG_ASYNCHRONOUS         0x40000000UL
#define RPCFLG_NON_NDR              0x80000000UL

#if (NTDDI_VERSION >= NTDDI_WINXP)
#define RPCFLG_HAS_MULTI_SYNTAXES   0x02000000UL
#define RPCFLG_HAS_CALLBACK         0x04000000UL
#endif // (NTDDI_VERSION >= NTDDI_WXP)

#if (NTDDI_VERSION >= NTDDI_VISTA)
// These two bits will hold the combination of 
// anonymous/admin/authenticate/mixed mode
#define RPCFLG_ACCESSIBILITY_BIT1   0x00100000UL
#define RPCFLG_ACCESSIBILITY_BIT2   0x00200000UL
#define RPCFLG_ACCESS_LOCAL         0x00400000UL

// This goes to MIDL_STUB_DESC only
#define NDR_CUSTOM_OR_DEFAULT_ALLOCATOR 0x10000000UL
#define NDR_DEFAULT_ALLOCATOR           0x20000000UL
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define RPC_FLAGS_VALID_BIT 0x00008000

typedef
void
(__RPC_STUB __RPC_FAR * RPC_DISPATCH_FUNCTION) (
    IN OUT PRPC_MESSAGE Message
    );

typedef struct {
    unsigned int DispatchTableCount;
    RPC_DISPATCH_FUNCTION __RPC_FAR * DispatchTable;
    LONG_PTR                          Reserved;
} RPC_DISPATCH_TABLE, __RPC_FAR * PRPC_DISPATCH_TABLE;

typedef struct _RPC_PROTSEQ_ENDPOINT
{
    unsigned char __RPC_FAR * RpcProtocolSequence;
    unsigned char __RPC_FAR * Endpoint;
} RPC_PROTSEQ_ENDPOINT, __RPC_FAR * PRPC_PROTSEQ_ENDPOINT;

/*
Both of these types MUST start with the InterfaceId and TransferSyntax.
Look at RpcIfInqId and I_RpcIfInqTransferSyntaxes to see why.
*/
#define NT351_INTERFACE_SIZE 0x40
#define RPC_INTERFACE_HAS_PIPES           0x0001

typedef struct _RPC_SERVER_INTERFACE
{
    unsigned int Length;
    RPC_SYNTAX_IDENTIFIER InterfaceId;
    RPC_SYNTAX_IDENTIFIER TransferSyntax;
    PRPC_DISPATCH_TABLE DispatchTable;
    unsigned int RpcProtseqEndpointCount;
    PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
    RPC_MGR_EPV __RPC_FAR *DefaultManagerEpv;
    void const __RPC_FAR *InterpreterInfo;
    unsigned int Flags ;
} RPC_SERVER_INTERFACE, __RPC_FAR * PRPC_SERVER_INTERFACE;

typedef struct _RPC_CLIENT_INTERFACE
{
    unsigned int Length;
    RPC_SYNTAX_IDENTIFIER   InterfaceId;
    RPC_SYNTAX_IDENTIFIER   TransferSyntax;
    PRPC_DISPATCH_TABLE     DispatchTable;
    unsigned int            RpcProtseqEndpointCount;
    PRPC_PROTSEQ_ENDPOINT   RpcProtseqEndpoint;
    ULONG_PTR               Reserved;
    void const __RPC_FAR *  InterpreterInfo;
    unsigned int Flags ;
} RPC_CLIENT_INTERFACE, __RPC_FAR * PRPC_CLIENT_INTERFACE;

#if (NTDDI_VERSION >= NTDDI_WINXP)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNegotiateTransferSyntax (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcGetBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcGetBufferWithObject (
    IN OUT RPC_MESSAGE __RPC_FAR * Message,
    IN UUID * ObjectUuid
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcSendReceive (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcFreeBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcSend (
    IN OUT PRPC_MESSAGE Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcReceive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcFreePipeBuffer (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcReallocPipeBuffer (
    __in PRPC_MESSAGE Message,
    __in_bound unsigned int NewSize
    );

typedef void * I_RPC_MUTEX;

RPCRTAPI
void
RPC_ENTRY
I_RpcRequestMutex (
    IN OUT I_RPC_MUTEX * Mutex
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcClearMutex (
    IN I_RPC_MUTEX Mutex
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcDeleteMutex (
    IN I_RPC_MUTEX Mutex
    );

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
I_RpcAllocate (
    IN unsigned int Size
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcFree (
    IN void __RPC_FAR * Object
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcPauseExecution (
    IN unsigned long Milliseconds
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcGetExtendedError (
    void
    );

typedef
void
(__RPC_USER __RPC_FAR * PRPC_RUNDOWN) (
    void __RPC_FAR * AssociationContext
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcMonitorAssociation (
    IN RPC_BINDING_HANDLE Handle,
    IN PRPC_RUNDOWN RundownRoutine,
    IN void * Context
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcStopMonitorAssociation (
    IN RPC_BINDING_HANDLE Handle
    );

RPCRTAPI
RPC_BINDING_HANDLE
RPC_ENTRY
I_RpcGetCurrentCallHandle(
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcGetAssociationContext (
    IN RPC_BINDING_HANDLE BindingHandle,
    OUT void __RPC_FAR * __RPC_FAR * AssociationContext
    );

RPCRTAPI
void *
RPC_ENTRY
I_RpcGetServerContextList (
    IN RPC_BINDING_HANDLE BindingHandle
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcSetServerContextList (
    IN RPC_BINDING_HANDLE BindingHandle,
    OUT void * ServerContextList
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsInterfaceExported (
    IN unsigned long EntryNameSyntax,
    IN unsigned short *EntryName,
    IN RPC_SERVER_INTERFACE * RpcInterfaceInformation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsInterfaceUnexported (
    IN unsigned long EntryNameSyntax,
    IN unsigned short *EntryName,
    IN RPC_SERVER_INTERFACE * RpcInterfaceInformation
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingToStaticStringBindingW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short **StringBinding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqSecurityContext (
    IN RPC_BINDING_HANDLE Binding,
    OUT void **SecurityContextHandle
    );

#if (NTDDI_VERSION >= NTDDI_VISTA)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqSecurityContextKeyInfo (
    __in_opt RPC_BINDING_HANDLE Binding,
    __inout void *KeyInfo
    );
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqWireIdForSnego (
    __in RPC_BINDING_HANDLE Binding,
    __out RPC_CSTR WireId
    );

#if (NTDDI_VERSION >= NTDDI_WS03)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqMarshalledTargetInfo (
    __in RPC_BINDING_HANDLE Binding,
    __out unsigned long * MarshalledTargetInfoSize,
    __deref_out_bcount(* MarshalledTargetInfoSize) RPC_CSTR * MarshalledTargetInfo
    );
#endif // (NTDDI_VERSION >= NTDDI_WS03)

#if (NTDDI_VERSION >= WINXP)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqLocalClientPID (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned long *Pid
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingHandleToAsyncHandle (
    IN RPC_BINDING_HANDLE Binding,
    OUT void **AsyncHandle
    );
#endif // (NTDDI_VERSION >= WINXP)

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsBindingSetEntryNameW (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long EntryNameSyntax,
    __in RPC_WSTR EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsBindingSetEntryNameA (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseqEp2A (
    __in_opt RPC_CSTR NetworkAddress,
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_CSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in void * Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseqEp2W (
    __in_opt RPC_WSTR NetworkAddress,
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_WSTR Endpoint,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in void * Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseq2W (
    __in_opt RPC_WSTR NetworkAddress,
    __in RPC_WSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in void * Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseq2A (
    __in_opt RPC_CSTR NetworkAddress,
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in_opt void __RPC_FAR * SecurityDescriptor,
    __in void * Policy
    );


#ifdef UNICODE
#define I_RpcNsBindingSetEntryName I_RpcNsBindingSetEntryNameW
#define I_RpcServerUseProtseqEp2 I_RpcServerUseProtseqEp2W
#define I_RpcServerUseProtseq2 I_RpcServerUseProtseq2W
#else
#define I_RpcNsBindingSetEntryName I_RpcNsBindingSetEntryNameA
#define I_RpcServerUseProtseqEp2 I_RpcServerUseProtseqEp2A
#define I_RpcServerUseProtseq2 I_RpcServerUseProtseq2A
#endif

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsBindingSetEntryName (
    __in RPC_BINDING_HANDLE Binding,
    __in unsigned long EntryNameSyntax,
    __in RPC_CSTR EntryName
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseq2 (
    __in RPC_CSTR NetworkAddress,
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in void __RPC_FAR * SecurityDescriptor,
    __in void * Policy
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUseProtseqEp2 (
    __in RPC_CSTR NetworkAddress,
    __in RPC_CSTR Protseq,
    __in unsigned int MaxCalls,
    __in RPC_CSTR Endpoint,
    __in void __RPC_FAR *SecurityDescriptor,
    __in void *Policy
    );
#endif

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerStartService (
    __in RPC_WSTR Protseq,
    __in RPC_WSTR Endpoint,
    __in RPC_IF_HANDLE IfSpec
    );

#ifdef RPC_UNICODE_SUPPORTED

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqDynamicEndpointW (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out_opt RPC_WSTR __RPC_FAR *DynamicEndpoint
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqDynamicEndpointA (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out_opt RPC_CSTR __RPC_FAR *DynamicEndpoint
    );

#ifdef UNICODE
#define I_RpcBindingInqDynamicEndpoint I_RpcBindingInqDynamicEndpointW
#else
#define I_RpcBindingInqDynamicEndpoint I_RpcBindingInqDynamicEndpointA
#endif

#else

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqDynamicEndpoint (
    __in RPC_BINDING_HANDLE Binding,
    __deref_out_opt RPC_CSTR __RPC_FAR *DynamicEndpoint
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerCheckClientRestriction (
    IN RPC_BINDING_HANDLE Context
    );
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#define TRANSPORT_TYPE_CN        0x01
#define TRANSPORT_TYPE_DG        0x02
#define TRANSPORT_TYPE_LPC       0x04
#define TRANSPORT_TYPE_WMSG      0x08

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqTransportType (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned int __RPC_FAR * Type
    );

typedef struct _RPC_TRANSFER_SYNTAX
{
    UUID Uuid;
    unsigned short VersMajor;
    unsigned short VersMinor;
} RPC_TRANSFER_SYNTAX;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcIfInqTransferSyntaxes (
    IN RPC_IF_HANDLE RpcIfHandle,
    OUT RPC_TRANSFER_SYNTAX __RPC_FAR * TransferSyntaxes,
    IN unsigned int TransferSyntaxSize,
    OUT unsigned int __RPC_FAR * TransferSyntaxCount
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_UuidCreate (
    OUT UUID __RPC_FAR * Uuid
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingCopy (
    IN RPC_BINDING_HANDLE SourceBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * DestinationBinding
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingIsClientLocal (
    IN OPTIONAL RPC_BINDING_HANDLE BindingHandle,
    OUT unsigned int __RPC_FAR * ClientLocalFlag
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqConnId (
    IN RPC_BINDING_HANDLE Binding,
    OUT void **ConnId,
    OUT int *pfFirstCall
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingCreateNP (
    __in RPC_WSTR ServerName,
    __in RPC_WSTR ServiceName,
    __in RPC_WSTR NetworkOptions,
    __out RPC_BINDING_HANDLE *Binding
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcSsDontSerializeContext (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcLaunchDatagramReceiveThread(
    void __RPC_FAR * pAddress
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerRegisterForwardFunction (
    IN RPC_FORWARD_FUNCTION  * pForwardFunction
    );

RPC_ADDRESS_CHANGE_FN * RPC_ENTRY
I_RpcServerInqAddressChangeFn(
    void
    );

RPC_STATUS RPC_ENTRY
I_RpcServerSetAddressChangeFn(
    IN RPC_ADDRESS_CHANGE_FN * pAddressChangeFn
    );

#if (NTDDI_VERSION >= WINXP)
/* The return buffer will contain SOCKADDR_IN for IPv4 */
#define RPC_P_ADDR_FORMAT_TCP_IPV4      1

/* The return buffer will contain SOCKADDR_STORAGE for IPv6 */
#define RPC_P_ADDR_FORMAT_TCP_IPV6      2

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerInqLocalConnAddress (
    IN RPC_BINDING_HANDLE Binding,
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerInqRemoteConnAddress (
    IN RPC_BINDING_HANDLE Binding,
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcSessionStrictContextHandle (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcTurnOnEEInfoPropagation (
    void
    );
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcConnectionInqSockBuffSize(
  OUT unsigned long __RPC_FAR * RecvBuffSize,
  OUT unsigned long __RPC_FAR * SendBuffSize
  );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcConnectionSetSockBuffSize(
   IN unsigned long RecvBuffSize,
   IN unsigned long SendBuffSize
   );

typedef
void
(*RPCLT_PDU_FILTER_FUNC) (
    IN void *Buffer,
    IN unsigned int BufferLength,
    IN int fDatagram
    );

typedef
void
(__cdecl *RPC_SETFILTER_FUNC) (
    IN RPCLT_PDU_FILTER_FUNC pfnFilter
    );

#ifndef WINNT
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerStartListening(
    void * hWnd
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerStopListening(
    void
    );

typedef RPC_STATUS (*RPC_BLOCKING_FN) (
    IN void * hWnd,
    IN void * Context,
    IN OPTIONAL void * hSyncEvent
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingSetAsync(
    IN RPC_BINDING_HANDLE Binding,
    IN RPC_BLOCKING_FN BlockingFn,
    IN unsigned long ServerTid
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcSetThreadParams(
    IN int fClientFree,
    IN OPTIONAL void *Context,
    IN OPTIONAL void * hWndClient
    );

RPCRTAPI
unsigned int
RPC_ENTRY
I_RpcWindowProc(
    IN void * hWnd,
    IN unsigned int Message,
    IN unsigned int wParam,
    IN unsigned long lParam
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUnregisterEndpointA (
    __in RPC_CSTR Protseq,
    __in RPC_CSTR Endpoint
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerUnregisterEndpointW (
    __in RPC_WSTR Protseq,
    __in RPC_WSTR Endpoint
    );

#ifdef UNICODE
#define I_RpcServerUnregisterEndpoint I_RpcServerUnregisterEndpointW
#else
#define I_RpcServerUnregisterEndpoint I_RpcServerUnregisterEndpointA
#endif
#endif // WINNT

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcServerInqTransportType(
    OUT unsigned int __RPC_FAR * Type
    );

RPCRTAPI
long
RPC_ENTRY
I_RpcMapWin32Status (
    IN RPC_STATUS Status
    );

#if (NTDDI_VERSION >= NTDDI_WS03)

#define RPC_C_OPT_SESSION_ID                (6)
#define RPC_C_OPT_COOKIE_AUTH                  (7)
#define RPC_C_OPT_RESOURCE_TYPE_UUID        (8)

typedef struct _RPC_C_OPT_COOKIE_AUTH_DESCRIPTOR
{
    unsigned long BufferSize;   // Length of the buffer in bytes
    __field_bcount(BufferSize) char *Buffer;               // Zero-terminated string
} RPC_C_OPT_COOKIE_AUTH_DESCRIPTOR;

typedef struct _RDR_CALLOUT_STATE
{
    // LastError is used for debugging only - don't use it for processing
    RPC_STATUS LastError;
    void *LastEEInfo;

    RPC_HTTP_REDIRECTOR_STAGE LastCalledStage;

    // the information accumulated throughout the stages
    unsigned short *ServerName;   // Allocated with MemAllocate
    unsigned short *ServerPort;   // Allocated with MemAllocate
    unsigned short *RemoteUser;   // Allocated with MemAllocate
    unsigned short *AuthType;     // Allocated with MemAllocate
    unsigned char ResourceTypePresent;
    unsigned char SessionIdPresent;
    unsigned char InterfacePresent;
    UUID ResourceType;
    UUID SessionId;
    RPC_SYNTAX_IDENTIFIER Interface;
    void *CertContext;            // Contains PCCERT_CONTEXT if cert is used for authentication. 
                                  // NULL otherwise. If allocated, CertFreeCertificateContext 
                                  // needs to be called on it when done
} RDR_CALLOUT_STATE;
#endif // (NTDDI_VERSION >= NTDDI_WS03)

#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef RPC_STATUS
(RPC_ENTRY *I_RpcProxyIsValidMachineFn)
        (
        __in RPC_WSTR Machine,
        __in RPC_WSTR DotMachine,
        __in unsigned long PortNumber        
        );

typedef RPC_STATUS
(RPC_ENTRY *I_RpcProxyGetClientAddressFn)
        (
        IN void *Context,
        OUT char *Buffer,
        OUT unsigned long *BufferLength
        );

typedef RPC_STATUS
(RPC_ENTRY *I_RpcProxyGetConnectionTimeoutFn)
        (
        OUT unsigned long *ConnectionTimeout
        );

#if (NTDDI_VERSION >= NTDDI_WS03)
typedef RPC_STATUS
(RPC_ENTRY *I_RpcPerformCalloutFn) 
    (
    IN void *Context,
    IN RDR_CALLOUT_STATE *CallOutState,
    IN RPC_HTTP_REDIRECTOR_STAGE Stage
    );

typedef void
(RPC_ENTRY *I_RpcFreeCalloutStateFn)
    (
    IN RDR_CALLOUT_STATE *CallOutState
    );

typedef RPC_STATUS
(RPC_ENTRY *I_RpcProxyGetClientSessionAndResourceUUID)
        (
        __in void *Context,
        __out_opt int *SessionIdPresent,
        __out_opt UUID *SessionId,
        __out int *ResourceIdPresent,
        __out UUID *ResourceId
        );

#endif // (NTDDI_VERSION >= NTDDI_WS03)

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef RPC_STATUS
(RPC_ENTRY *I_RpcProxyFilterIfFn) 
    (
    __in void *Context,
    __in UUID *IfUuid,
    __in unsigned short IfMajorVersion,
    __out int *fAllow
    );

typedef enum RpcProxyPerfCounters
{
    RpcCurrentUniqueUser = 1,    //Current Number of Unique Users
    RpcBackEndConnectionAttempts, // Number of Back-End Connection Attempts per Second
    RpcBackEndConnectionFailed, // Number of Failed Back-End Connection Attempts per Second
    RpcRequestsPerSecond, //RPC/HTTP Requests per Second
    RpcIncomingConnections, //Current Number of Incoming RPC over HTTP Connections
    RpcIncomingBandwidth, // Total Incoming Bandwidth from Back-End Servers
    RpcOutgoingBandwidth, // Total Outgoing Bandwidth to Back-End Servers
    RpcAttemptedLbsDecisions, // Attempted RPC Load Balancing Decisions per Second
    RpcFailedLbsDecisions, // Failed RPC Load Balancing Decisions per Second
    RpcAttemptedLbsMessages, //Attempted RPC Load Balancing Broker Requests per Second
    RpcFailedLbsMessages, // Failed RPC Load Balancing Broker Requests per Second
    RpcLastCounter 
} RpcPerfCounters;

typedef void
(RPC_ENTRY *I_RpcProxyUpdatePerfCounterFn)
    (
    __in RpcPerfCounters Counter,
    __in int ModifyTrend,
    __in unsigned long Size
    );

 typedef void
(RPC_ENTRY *I_RpcProxyUpdatePerfCounterBackendServerFn)
    (
    __in unsigned short* MachineName,
    __in int IsConnectEvent
    );

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define RPC_PROXY_CONNECTION_TYPE_IN_PROXY    0
#define RPC_PROXY_CONNECTION_TYPE_OUT_PROXY   1

#if (NTDDI_VERSION >= NTDDI_WS03)
typedef struct tagI_RpcProxyCallbackInterface
{
    I_RpcProxyIsValidMachineFn IsValidMachineFn;
    I_RpcProxyGetClientAddressFn GetClientAddressFn;
    I_RpcProxyGetConnectionTimeoutFn GetConnectionTimeoutFn;
    I_RpcPerformCalloutFn PerformCalloutFn;
    I_RpcFreeCalloutStateFn FreeCalloutStateFn;
    I_RpcProxyGetClientSessionAndResourceUUID GetClientSessionAndResourceUUIDFn;
#if (NTDDI_VERSION >= NTDDI_VISTA)
    I_RpcProxyFilterIfFn ProxyFilterIfFn;
    I_RpcProxyUpdatePerfCounterFn RpcProxyUpdatePerfCounterFn;
    I_RpcProxyUpdatePerfCounterBackendServerFn RpcProxyUpdatePerfCounterBackendServerFn;
#endif // (NTDDI_VERSION >= NTDDI_VISTA)
} I_RpcProxyCallbackInterface;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcProxyNewConnection (
    IN unsigned long ConnectionType,
    IN unsigned short *ServerAddress,
    IN unsigned short *ServerPort,
    IN unsigned short *MinConnTimeout,
    IN void *ConnectionParameter,
    IN OPTIONAL RDR_CALLOUT_STATE *CallOutState, 
    IN I_RpcProxyCallbackInterface *ProxyCallbackInterface
    );
    
#else

typedef struct tagI_RpcProxyCallbackInterface
{
    I_RpcProxyIsValidMachineFn IsValidMachineFn;
    I_RpcProxyGetClientAddressFn GetClientAddressFn;
    I_RpcProxyGetConnectionTimeoutFn GetConnectionTimeoutFn;
} I_RpcProxyCallbackInterface;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcProxyNewConnection (
    IN unsigned long ConnectionType,
    IN unsigned short *ServerAddress,
    IN unsigned short *ServerPort,
    IN void *ConnectionParameter,
    IN I_RpcProxyCallbackInterface *ProxyCallbackInterface
    );
#endif // (NTDDI_VERSION >= NTDDI_WS03)
        
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#if (NTDDI_VERSION >= NTDDI_WS03)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcReplyToClientWithStatus (
    IN void *ConnectionParameter,
    IN RPC_STATUS RpcStatus
    );

RPCRTAPI
void
RPC_ENTRY
I_RpcRecordCalloutFailure (
    IN RPC_STATUS RpcStatus,
    IN RDR_CALLOUT_STATE *CallOutState,
    IN unsigned short *DllName
    );
#endif // (NTDDI_VERSION >= NTDDI_WS03)

#if (NTDDI_VERSION >= NTDDI_WIN7)
RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcMgmtEnableDedicatedThreadPool (
    );
#endif // (NTDDI_VERSION >= NTDDI_WIN7)

#ifdef __cplusplus
}
#endif

#endif /* __RPCDCEP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\rpcssl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       rpcssl.h
//
//  Contents:   prototypes for RemoteProcedure Call API functions
//              that use types from wincrypt.h
//
//----------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifdef RPC_UNICODE_SUPPORTED

#ifdef UNICODE
#define RpcCertGeneratePrincipalName RpcCertGeneratePrincipalNameW
#else /* UNICODE */
#define RpcCertGeneratePrincipalName RpcCertGeneratePrincipalNameA
#endif /* UNICODE */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcCertGeneratePrincipalNameW(
    __in PCCERT_CONTEXT Context,
    __in DWORD Flags,
    __deref_out RPC_WSTR *pBuffer
    );


RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcCertGeneratePrincipalNameA(
    __in PCCERT_CONTEXT       Context,
    __in DWORD                Flags,
    __deref_out RPC_CSTR *    pBuffer
    );

#else /* RPC_UNICODE_SUPPORTED */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcCertGeneratePrincipalName(
    __in PCCERT_CONTEXT Context,
    __in DWORD Flags,
    __deref_out RPC_CSTR *pBuffer
    );

#endif /* RPC_UNICODE_SUPPORTED */

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Rpcsal.h ===
/****************************************************************\
*                                                                *
* rpcsal.h - markers for documenting the semantics of RPC APIs   *
*                                                                *
* Version 1.0                                                    *
*                                                                *
* Copyright (c) 2004 Microsoft Corporation. All rights reserved. *
*                                                                *
\****************************************************************/

// -------------------------------------------------------------------------------
// Introduction
//
// rpcsal.h provides a set of annotations to describe how RPC functions use their
// parameters - the assumptions it makes about them, adn the guarantees it makes 
// upon finishing.  These annotations are similar to those found in specstrings.h,
// but are designed to be used by the MIDL compiler when it generates annotations
// enabled header files.
//
// IDL authors do not need to annotate their functions declarations.  The MIDL compiler
// will interpret the IDL directives and use one of the annotations contained 
// in this header.  This documentation is intended to help those trying to  understand 
// the MIDL-generated header files or those who maintain their own copies of these files.
//
// -------------------------------------------------------------------------------
// Differences between rpcsal.h and specstrings.h
// 
// There are a few important differences between the annotations found in rpcsal.h and
// those in specstrings.h:
// 
// 1. [in] parameters are not marked as read-only.  They may be used for scratch space 
// at the server and changes will not affect the client.
// 2. String versions of each macro alleviates the need for a special type definition
//
// -------------------------------------------------------------------------------
// Interpreting RPC Annotations
//
// These annotations are interpreted precisely in the same way as those in specstrings.h.  
// Please refer to that header for information related to general usage in annotations. 
//
// To construct an RPC annotation, concatenate the appropriate value from each category
// along with a leading __RPC_.  A typical annotation looks like "__RPC__in_string".
//
// |----------------------------------------------------------------------------------|
// | RPC Annotations                                                                  |
// |------------|------------|---------|--------|----------|----------|---------------|
// |   Level    |   Usage    |  Size   | Output | Optional |  String  |  Parameters   |
// |------------|------------|---------|--------|----------|----------|---------------|
// | <>         | <>         | <>      | <>     | <>       | <>       | <>            |
// | _deref     | _in        | _ecount | _full  | _opt     | _string  | (size)        |
// | _deref_opt | _out       | _bcount | _part  |          |          | (size,length) |
// |            | _inout     |         |        |          |          |               |
// |            |            |         |        |          |          |               |
// |------------|------------|---------|--------|----------|----------|---------------|
//
// Level: Describes the buffer pointer's level of indirection from the parameter or
//          return value 'p'.
//
// <>         : p is the buffer pointer.
// _deref     : *p is the buffer pointer. p must not be NULL.
// _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the rest of
//                the annotation is ignored.
//
// Usage: Describes how the function uses the buffer.
//
// <>     : The buffer is not accessed. If used on the return value or with _deref, the
//            function will provide the buffer, and it will be uninitialized at exit.
//            Otherwise, the caller must provide the buffer. This should only be used
//            for alloc and free functions.
// _in    : The function will only read from the buffer. The caller must provide the
//            buffer and initialize it. Cannot be used with _deref.
// _out   : The function will only write to the buffer. If used on the return value or
//            with _deref, the function will provide the buffer and initialize it.
//            Otherwise, the caller must provide the buffer, and the function will
//            initialize it.
// _inout : The function may freely read from and write to the buffer. The caller must
//            provide the buffer and initialize it. If used with _deref, the buffer may
//            be reallocated by the function.
//
// Size: Describes the total size of the buffer. This may be less than the space actually
//         allocated for the buffer, in which case it describes the accessible amount.
//
// <>      : No buffer size is given. If the type specifies the buffer size (such as
//             with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is one
//             element long. Must be used with _in, _out, or _inout.
// _ecount : The buffer size is an explicit element count.
// _bcount : The buffer size is an explicit byte count.
//
// Output: Describes how much of the buffer will be initialized by the function. For
//           _inout buffers, this also describes how much is initialized at entry. Omit this
//           category for _in buffers; they must be fully initialized by the caller.
//
// <>    : The type specifies how much is initialized. For instance, a function initializing
//           an LPWSTR must NULL-terminate the string.
// _full : The function initializes the entire buffer.
// _part : The function initializes part of the buffer, and explicitly indicates how much.
//
// Optional: Describes if the buffer itself is optional.
//
// <>   : The pointer to the buffer must not be NULL.
// _opt : The pointer to the buffer might be NULL. It will be checked before being dereferenced.
//
// String: Describes if the buffer is NULL terminated
//
// <>      : The buffer is not assumed to be NULL terminated
// _string : The buffer is assumed to be NULL terminated once it has been initialized
//
// Parameters: Gives explicit counts for the size and length of the buffer.
//
// <>            : There is no explicit count. Use when neither _ecount nor _bcount is used.
// (size)        : Only the buffer's total size is given. Use with _ecount or _bcount but not _part.
// (size,length) : The buffer's total size and initialized length are given. Use with _ecount_part
//                   and _bcount_part.
//
// Notes:
//
// 1. Specifying two buffer annotations on a single parameter results in unspecified behavior
//    (e.g. __RPC__in_bcount(5) __RPC__out_bcount(6)
// 
// 2. The size of the buffer and the amount that has been initialized are separate concepts.  
//    Specify the size using _ecount or _bcount.  Specify the amount that is initialized using 
//    _full, _part, or _string.  As a special case, a single element buffer does not need 
//    _ecount, _bcount, _full, or _part
// 
// 3. The count may be less than the total size of the buffer in which case it describes the 
//    accessible portion. 
// 
// 4. "__RPC__opt" and "__RPC_deref" are not valid annotations.
// 
// 5. The placement of _opt when using _deref is important:
//      __RPC__deref_opt_...      : Input may be NULL
//      __RPC__deref_..._opt      : Output may be NULL
//      __RPC__deref_opt_..._opt  : Both input and output may be NULL
//

#pragma once

#include <specstrings.h>

#ifndef __RPCSAL_H_VERSION__
#define __RPCSAL_H_VERSION__        ( 100 )
#endif // __RPCSAL_H_VERSION__

#ifdef __REQUIRED_RPCSAL_H_VERSION__
    #if ( __RPCSAL_H_VERSION__ < __REQUIRED_RPCSAL_H_VERSION__ )
        #error incorrect <rpcsal.h> version. Use the header that matches with the MIDL compiler.
    #endif
#endif


#ifdef  __cplusplus
extern "C" {
#endif  // #ifdef __cplusplus

#if (_MSC_VER >= 1000) && !defined(__midl) && defined(_PREFAST_)


// [in]
#define __RPC__in                                   __pre __valid
#define __RPC__in_string                            __RPC__in   __pre __nullterminated
#define __RPC__in_ecount(size)                      __RPC__in __pre __elem_readableTo(size)
#define __RPC__in_ecount_full(size)                 __RPC__in_ecount(size)
#define __RPC__in_ecount_full_string(size)          __RPC__in_ecount_full(size) __pre __nullterminated
#define __RPC__in_ecount_part(size, length)         __RPC__in_ecount(length) __pre __elem_writableTo(size)
#define __RPC__in_ecount_full_opt(size)             __RPC__in_ecount_full(size) __pre __exceptthat  __maybenull
#define __RPC__in_ecount_full_opt_string(size)      __RPC__in_ecount_full_opt(size) __pre __nullterminated
#define __RPC__in_ecount_part_opt(size, length)     __RPC__in_ecount_part(size, length) __pre __exceptthat __maybenull
#define __RPC__in_xcount(size)                      __RPC__in __pre __elem_readableTo(size)
#define __RPC__in_xcount_full(size)                 __RPC__in_ecount(size)
#define __RPC__in_xcount_full_string(size)          __RPC__in_ecount_full(size) __pre __nullterminated
#define __RPC__in_xcount_part(size, length)         __RPC__in_ecount(length) __pre __elem_writableTo(size)
#define __RPC__in_xcount_full_opt(size)             __RPC__in_ecount_full(size) __pre __exceptthat  __maybenull
#define __RPC__in_xcount_full_opt_string(size)      __RPC__in_ecount_full_opt(size) __pre __nullterminated
#define __RPC__in_xcount_part_opt(size, length)     __RPC__in_ecount_part(size, length) __pre __exceptthat __maybenull


#define __RPC__deref_in                             __RPC__in __deref __notnull 
#define __RPC__deref_in_string                      __RPC__in   __pre __deref __nullterminated
#define __RPC__deref_in_opt                         __RPC__deref_in __deref __exceptthat __maybenull
#define __RPC__deref_in_opt_string                  __RPC__deref_in_opt __pre __deref __nullterminated
#define __RPC__deref_opt_in                         __RPC__in __exceptthat __maybenull 
#define __RPC__deref_opt_in_string                  __RPC__deref_opt_in __pre __deref __nullterminated 
#define __RPC__deref_opt_in_opt                     __RPC__deref_opt_in  __pre __deref __exceptthat __maybenull
#define __RPC__deref_opt_in_opt_string              __RPC__deref_opt_in_opt  __pre __deref __nullterminated
#define __RPC__deref_in_ecount(size)                __RPC__in __pre __deref __elem_readableTo(size)
#define __RPC__deref_in_ecount_part(size, length)   __RPC__deref_in_ecount(size)  __pre __deref __elem_readableTo(length)
#define __RPC__deref_in_ecount_full(size)           __RPC__deref_in_ecount_part(size, size)
#define __RPC__deref_in_ecount_full_opt(size)       __RPC__deref_in_ecount_full(size) __pre __deref __exceptthat __maybenull
#define __RPC__deref_in_ecount_full_opt_string(size) __RPC__deref_in_ecount_full_opt(size) __pre __deref __nullterminated
#define __RPC__deref_in_ecount_full_string(size)    __RPC__deref_in_ecount_full(size) __pre __deref __nullterminated
#define __RPC__deref_in_ecount_opt(size)            __RPC__deref_in_ecount(size) __pre __deref __exceptthat __maybenull
#define __RPC__deref_in_ecount_opt_string(size)     __RPC__deref_in_ecount_opt(size) __pre __deref __nullterminated
#define __RPC__deref_in_ecount_part_opt(size, length) __RPC__deref_in_ecount_opt(size) __pre __deref __elem_readableTo(length)
#define __RPC__deref_in_xcount(size)                __RPC__in __pre __deref __elem_readableTo(size)
#define __RPC__deref_in_xcount_part(size, length)   __RPC__deref_in_ecount(size)  __pre __deref __elem_readableTo(length)
#define __RPC__deref_in_xcount_full(size)           __RPC__deref_in_ecount_part(size, size)
#define __RPC__deref_in_xcount_full_opt(size)       __RPC__deref_in_ecount_full(size) __pre __deref __exceptthat __maybenull
#define __RPC__deref_in_xcount_full_opt_string(size) __RPC__deref_in_ecount_full_opt(size) __pre __deref __nullterminated
#define __RPC__deref_in_xcount_full_string(size)    __RPC__deref_in_ecount_full(size) __pre __deref __nullterminated
#define __RPC__deref_in_xcount_opt(size)            __RPC__deref_in_ecount(size) __pre __deref __exceptthat __maybenull
#define __RPC__deref_in_xcount_opt_string(size)     __RPC__deref_in_ecount_opt(size) __pre __deref __nullterminated
#define __RPC__deref_in_xcount_part_opt(size, length) __RPC__deref_in_ecount_opt(size) __pre __deref __elem_readableTo(length)

// [out]
#define __RPC__out                                  __out
#define __RPC__out_ecount(size)                     __out_ecount(size)  __post  __elem_writableTo(size)
#define __RPC__out_ecount_string(size)              __RPC__out_ecount(size) __post __nullterminated
#define __RPC__out_ecount_part(size, length)        __RPC__out_ecount(size)  __post  __elem_readableTo(length)
#define __RPC__out_ecount_full(size)                __RPC__out_ecount_part(size, size)
#define __RPC__out_ecount_full_string(size)         __RPC__out_ecount_full(size) __post  __nullterminated
#define __RPC__out_xcount(size)                     __out
#define __RPC__out_xcount_string(size)              __RPC__out __post __nullterminated
#define __RPC__out_xcount_part(size, length)        __RPC__out
#define __RPC__out_xcount_full(size)                __RPC__out
#define __RPC__out_xcount_full_string(size)         __RPC__out __post __nullterminated

// [in,out] 
#define __RPC__inout                                __inout
#define __RPC__inout_string                         __RPC__inout  __pre __nullterminated __post __nullterminated
#define __RPC__inout_ecount(size)                   __inout_ecount(size)
#define __RPC__inout_ecount_part(size, length)      __inout_ecount_part(size, length)
#define __RPC__inout_ecount_full(size)              __RPC__inout_ecount_part(size, size)
#define __RPC__inout_ecount_full_string(size)       __RPC__inout_ecount_full(size) __pre __nullterminated __post __nullterminated
#define __RPC__inout_xcount(size)                   __inout
#define __RPC__inout_xcount_part(size, length)      __inout
#define __RPC__inout_xcount_full(size)              __RPC__inout
#define __RPC__inout_xcount_full_string(size)       __RPC__inout __pre __nullterminated __post __nullterminated

// [in,unique] 
#define __RPC__in_opt                               __RPC__in __pre __exceptthat __maybenull
#define __RPC__in_opt_string                        __RPC__in_opt   __pre __nullterminated
#define __RPC__in_ecount_opt(size)                  __RPC__in_ecount(size) __pre __exceptthat __maybenull
#define __RPC__in_ecount_opt_string(size)           __RPC__in_ecount_opt(size) __pre __nullterminated
#define __RPC__in_xcount_opt(size)                  __RPC__in_ecount(size) __pre __exceptthat __maybenull
#define __RPC__in_xcount_opt_string(size)           __RPC__in_ecount_opt(size) __pre __nullterminated

// [in,out,unique] 
#define __RPC__inout_opt                            __inout_opt
#define __RPC__inout_opt_string                     __RPC__inout_opt  __pre __nullterminated
#define __RPC__inout_ecount_opt(size)               __inout_ecount_opt(size)
#define __RPC__inout_ecount_part_opt(size, length)  __inout_ecount_part_opt(size, length)
#define __RPC__inout_ecount_full_opt(size)          __RPC__inout_ecount_part_opt(size, size)
#define __RPC__inout_ecount_full_opt_string(size)   __RPC__inout_ecount_full_opt(size)  __pre __nullterminated __post __nullterminated
#define __RPC__inout_xcount_opt(size)               __inout_opt
#define __RPC__inout_xcount_part_opt(size, length)  __inout_opt
#define __RPC__inout_xcount_full_opt(size)          __RPC__inout_opt
#define __RPC__inout_xcount_full_opt_string(size)   __RPC__inout_opt __pre __nullterminated __post __nullterminated

// [out] **
#define __RPC__deref_out                            __deref_out
#define __RPC__deref_out_string                     __RPC__deref_out    __post __deref __nullterminated
// Removed "__post __deref __exceptthat __maybenull" so return values from QueryInterface and the like can be trusted without an explicit NULL check.
// This is a temporary fix until midl.exe can be rev'd to produce more accurate annotations.
#define __RPC__deref_out_opt                        __RPC__deref_out
#define __RPC__deref_out_opt_string                 __RPC__deref_out_opt  __post __deref __nullterminated __pre __deref __null
#define __RPC__deref_out_ecount(size)               __deref_out_ecount(size) __post __deref __elem_writableTo(size)
#define __RPC__deref_out_ecount_part(size, length)  __RPC__deref_out_ecount(size) __post __deref __elem_readableTo(length)
#define __RPC__deref_out_ecount_full(size)          __RPC__deref_out_ecount_part(size,size)
#define __RPC__deref_out_ecount_full_string(size)   __RPC__deref_out_ecount_full(size) __post __deref __nullterminated
#define __RPC__deref_out_xcount(size)               __deref_out __post __deref
#define __RPC__deref_out_xcount_part(size, length)  __RPC__deref_out __post __deref
#define __RPC__deref_out_xcount_full(size)          __RPC__deref_out
#define __RPC__deref_out_xcount_full_string(size)   __RPC__deref_out __post __deref __nullterminated

// [in,out] **, second pointer decoration. 
#define __RPC__deref_inout                          __deref_inout
#define __RPC__deref_inout_string                   __RPC__deref_inout __pre __deref __nullterminated __post __deref __nullterminated
#define __RPC__deref_inout_opt                      __deref_inout_opt
#define __RPC__deref_inout_opt_string               __RPC__deref_inout_opt __deref __nullterminated 
#define __RPC__deref_inout_ecount_opt(size)         __deref_inout_ecount_opt(size)
#define __RPC__deref_inout_ecount_part_opt(size, length) __deref_inout_ecount_part_opt(size , length)
#define __RPC__deref_inout_ecount_full_opt(size)    __RPC__deref_inout_ecount_part_opt(size, size)
#define __RPC__deref_inout_ecount_full(size)        __deref_inout_ecount_full(size)
#define __RPC__deref_inout_ecount_full_string(size) __RPC__deref_inout_ecount_full(size) __post __deref __nullterminated
#define __RPC__deref_inout_ecount_full_opt_string(size) __RPC__deref_inout_ecount_full_opt(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __RPC__deref_inout_xcount_opt(size)         __deref_inout_opt
#define __RPC__deref_inout_xcount_part_opt(size, length) __deref_inout_opt
#define __RPC__deref_inout_xcount_full_opt(size)    __RPC__deref_inout_opt
#define __RPC__deref_inout_xcount_full(size)        __deref_inout
#define __RPC__deref_inout_xcount_full_string(size) __RPC__deref_inout __post __deref __nullterminated
#define __RPC__deref_inout_xcount_full_opt_string(size) __RPC__deref_inout_opt __pre __deref __nullterminated __post __deref __nullterminated


// #define __RPC_out_opt    out_opt is not allowed in rpc

// [in,out,unique] 
#define __RPC__deref_opt_inout                          __deref_opt_inout
#define __RPC__deref_opt_inout_ecount(size)             __deref_opt_inout_ecount(size)
#define __RPC__deref_opt_inout_string                   __RPC__deref_opt_inout __pre __deref __nullterminated __post __deref __nullterminated
#define __RPC__deref_opt_inout_ecount_part(size, length) __deref_opt_inout_ecount_part(size, length)
#define __RPC__deref_opt_inout_ecount_full(size)        __deref_opt_inout_ecount_full(size)
#define __RPC__deref_opt_inout_ecount_full_string(size)  __RPC__deref_opt_inout_ecount_full(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __RPC__deref_opt_inout_xcount_part(size, length) __deref_opt_inout
#define __RPC__deref_opt_inout_xcount_full(size)        __deref_opt_inout
#define __RPC__deref_opt_inout_xcount_full_string(size)  __RPC__deref_opt_inout __pre __deref __nullterminated __post __deref __nullterminated


// We don't need to specify __pre __deref __exceptthat __maybenull : this is default behavior. While this might not hold in SAL 1.1 syntax, SAL team 
// believes it's OK. We can revisit if SAL 1.1 can survive. 
#define __RPC__deref_out_ecount_opt(size)               __RPC__out_ecount(size) __post __deref __exceptthat __maybenull __pre __deref __null 
#define __RPC__deref_out_ecount_part_opt(size, length)  __RPC__deref_out_ecount_part(size, length) __post __deref __exceptthat __maybenull __pre __deref __null
#define __RPC__deref_out_ecount_full_opt(size)          __RPC__deref_out_ecount_part_opt(size, size) __pre __deref __null
#define __RPC__deref_out_ecount_full_opt_string(size)   __RPC__deref_out_ecount_part_opt(size, size) __post __deref __nullterminated __pre __deref __null
#define __RPC__deref_out_xcount_opt(size)               __RPC__out __post __deref __exceptthat __maybenull __pre __deref __null 
#define __RPC__deref_out_xcount_part_opt(size, length)  __RPC__deref_out __post __deref __exceptthat __maybenull __pre __deref __null
#define __RPC__deref_out_xcount_full_opt(size)          __RPC__deref_out_opt __pre __deref __null
#define __RPC__deref_out_xcount_full_opt_string(size)   __RPC__deref_out_opt __post __deref __nullterminated __pre __deref __null

#define __RPC__deref_opt_inout_opt                      __deref_opt_inout_opt
#define __RPC__deref_opt_inout_opt_string               __RPC__deref_opt_inout_opt __pre __deref __nullterminated  __post __deref __nullterminated
#define __RPC__deref_opt_inout_ecount_opt(size)         __deref_opt_inout_ecount_opt(size)  
#define __RPC__deref_opt_inout_ecount_part_opt(size, length) __deref_opt_inout_ecount_part_opt(size, length)
#define __RPC__deref_opt_inout_ecount_full_opt(size)    __RPC__deref_opt_inout_ecount_part_opt(size, size)
#define __RPC__deref_opt_inout_ecount_full_opt_string(size)  __RPC__deref_opt_inout_ecount_full_opt(size) __pre __deref __nullterminated __post __deref __nullterminated
#define __RPC__deref_opt_inout_xcount_opt(size)         __deref_opt_inout_opt  
#define __RPC__deref_opt_inout_xcount_part_opt(size, length) __deref_opt_inout_opt
#define __RPC__deref_opt_inout_xcount_full_opt(size)    __RPC__deref_opt_inout_opt
#define __RPC__deref_opt_inout_xcount_full_opt_string(size)  __RPC__deref_opt_inout_opt __pre __deref __nullterminated __post __deref __nullterminated

#define __RPC_full_pointer                              __maybenull 
#define __RPC_unique_pointer                            __maybenull
#define __RPC_ref_pointer                               __notnull
#define __RPC_string                                    __nullterminated

#define __RPC__range(min,max)                           __range(min,max)
#define __RPC__in_range(min,max)                        __in_range(min,max)

#else   // not prefast

#define __RPC__range(min,max)
#define __RPC__in_range(min,max)

#define __RPC__in           
#define __RPC__in_string
#define __RPC__in_opt_string
#define __RPC__in_ecount(size) 
#define __RPC__in_ecount_full(size)
#define __RPC__in_ecount_full_string(size)
#define __RPC__in_ecount_part(size, length)
#define __RPC__in_ecount_full_opt(size)
#define __RPC__in_ecount_full_opt_string(size)
#define __RPC__inout_ecount_full_opt_string(size)
#define __RPC__in_ecount_part_opt(size, length)
#define __RPC__in_xcount(size) 
#define __RPC__in_xcount_full(size)
#define __RPC__in_xcount_full_string(size)
#define __RPC__in_xcount_part(size, length)
#define __RPC__in_xcount_full_opt(size)
#define __RPC__in_xcount_full_opt_string(size)
#define __RPC__inout_xcount_full_opt_string(size)
#define __RPC__in_xcount_part_opt(size, length)

#define __RPC__deref_in 
#define __RPC__deref_in_string
#define __RPC__deref_in_opt
#define __RPC__deref_in_opt_string
#define __RPC__deref_opt_in
#define __RPC__deref_opt_in_string
#define __RPC__deref_opt_in_opt
#define __RPC__deref_opt_in_opt_string
#define __RPC__deref_in_ecount(size) 
#define __RPC__deref_in_ecount_part(size, length) 
#define __RPC__deref_in_ecount_full(size) 
#define __RPC__deref_in_ecount_full_opt(size)
#define __RPC__deref_in_ecount_full_string(size)
#define __RPC__deref_in_ecount_full_opt_string(size)
#define __RPC__deref_in_ecount_opt(size) 
#define __RPC__deref_in_ecount_opt_string(size)
#define __RPC__deref_in_ecount_part_opt(size, length) 
#define __RPC__deref_in_xcount(size) 
#define __RPC__deref_in_xcount_part(size, length) 
#define __RPC__deref_in_xcount_full(size) 
#define __RPC__deref_in_xcount_full_opt(size)
#define __RPC__deref_in_xcount_full_string(size)
#define __RPC__deref_in_xcount_full_opt_string(size)
#define __RPC__deref_in_xcount_opt(size) 
#define __RPC__deref_in_xcount_opt_string(size)
#define __RPC__deref_in_xcount_part_opt(size, length) 

// [out]
#define __RPC__out     
#define __RPC__out_ecount(size) 
#define __RPC__out_ecount_part(size, length) 
#define __RPC__out_ecount_full(size)
#define __RPC__out_ecount_full_string(size)
#define __RPC__out_xcount(size) 
#define __RPC__out_xcount_part(size, length) 
#define __RPC__out_xcount_full(size)
#define __RPC__out_xcount_full_string(size)

// [in,out] 
#define __RPC__inout                                   
#define __RPC__inout_string
#define __RPC__opt_inout
#define __RPC__inout_ecount(size)                     
#define __RPC__inout_ecount_part(size, length)    
#define __RPC__inout_ecount_full(size)          
#define __RPC__inout_ecount_full_string(size)          
#define __RPC__inout_xcount(size)                     
#define __RPC__inout_xcount_part(size, length)    
#define __RPC__inout_xcount_full(size)          
#define __RPC__inout_xcount_full_string(size)          

// [in,unique] 
#define __RPC__in_opt       
#define __RPC__in_ecount_opt(size)   
#define __RPC__in_xcount_opt(size)   


// [in,out,unique] 
#define __RPC__inout_opt    
#define __RPC__inout_opt_string    
#define __RPC__inout_ecount_opt(size)  
#define __RPC__inout_ecount_part_opt(size, length) 
#define __RPC__inout_ecount_full_opt(size)     
#define __RPC__inout_ecount_full_string(size)
#define __RPC__inout_xcount_opt(size)  
#define __RPC__inout_xcount_part_opt(size, length) 
#define __RPC__inout_xcount_full_opt(size)     
#define __RPC__inout_xcount_full_string(size)

// [out] **
#define __RPC__deref_out   
#define __RPC__deref_out_string
#define __RPC__deref_out_opt 
#define __RPC__deref_out_opt_string
#define __RPC__deref_out_ecount(size) 
#define __RPC__deref_out_ecount_part(size, length) 
#define __RPC__deref_out_ecount_full(size)  
#define __RPC__deref_out_ecount_full_string(size)
#define __RPC__deref_out_xcount(size) 
#define __RPC__deref_out_xcount_part(size, length) 
#define __RPC__deref_out_xcount_full(size)  
#define __RPC__deref_out_xcount_full_string(size)


// [in,out] **, second pointer decoration. 
#define __RPC__deref_inout    
#define __RPC__deref_inout_string
#define __RPC__deref_inout_opt 
#define __RPC__deref_inout_opt_string
#define __RPC__deref_inout_ecount_full(size)
#define __RPC__deref_inout_ecount_full_string(size)
#define __RPC__deref_inout_ecount_opt(size) 
#define __RPC__deref_inout_ecount_part_opt(size, length) 
#define __RPC__deref_inout_ecount_full_opt(size) 
#define __RPC__deref_inout_ecount_full_opt_string(size) 
#define __RPC__deref_inout_xcount_full(size)
#define __RPC__deref_inout_xcount_full_string(size)
#define __RPC__deref_inout_xcount_opt(size) 
#define __RPC__deref_inout_xcount_part_opt(size, length) 
#define __RPC__deref_inout_xcount_full_opt(size) 
#define __RPC__deref_inout_xcount_full_opt_string(size) 

// #define __RPC_out_opt    out_opt is not allowed in rpc

// [in,out,unique] 
#define __RPC__deref_opt_inout  
#define __RPC__deref_opt_inout_string
#define __RPC__deref_opt_inout_ecount(size)     
#define __RPC__deref_opt_inout_ecount_part(size, length) 
#define __RPC__deref_opt_inout_ecount_full(size) 
#define __RPC__deref_opt_inout_ecount_full_string(size)
#define __RPC__deref_opt_inout_xcount(size)     
#define __RPC__deref_opt_inout_xcount_part(size, length) 
#define __RPC__deref_opt_inout_xcount_full(size) 
#define __RPC__deref_opt_inout_xcount_full_string(size)

#define __RPC__deref_out_ecount_opt(size) 
#define __RPC__deref_out_ecount_part_opt(size, length) 
#define __RPC__deref_out_ecount_full_opt(size) 
#define __RPC__deref_out_ecount_full_opt_string(size)
#define __RPC__deref_out_xcount_opt(size) 
#define __RPC__deref_out_xcount_part_opt(size, length) 
#define __RPC__deref_out_xcount_full_opt(size) 
#define __RPC__deref_out_xcount_full_opt_string(size)

#define __RPC__deref_opt_inout_opt      
#define __RPC__deref_opt_inout_opt_string
#define __RPC__deref_opt_inout_ecount_opt(size)   
#define __RPC__deref_opt_inout_ecount_part_opt(size, length) 
#define __RPC__deref_opt_inout_ecount_full_opt(size) 
#define __RPC__deref_opt_inout_ecount_full_opt_string(size) 
#define __RPC__deref_opt_inout_xcount_opt(size)   
#define __RPC__deref_opt_inout_xcount_part_opt(size, length) 
#define __RPC__deref_opt_inout_xcount_full_opt(size) 
#define __RPC__deref_opt_inout_xcount_full_opt_string(size) 

#define __RPC_full_pointer  
#define __RPC_unique_pointer
#define __RPC_ref_pointer
#define __RPC_string                               


#endif

#ifdef  __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RpcNtErr.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcnterr.h

Abstract:

    Rpc Error Codes from the compiler and runtime

--*/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __RPCNTERR_H__
#define __RPCNTERR_H__

#if !defined(_KRPCENV_)

#define RPC_S_OK                          ERROR_SUCCESS
#define RPC_S_INVALID_ARG                 ERROR_INVALID_PARAMETER
#define RPC_S_OUT_OF_MEMORY               ERROR_OUTOFMEMORY
#define RPC_S_OUT_OF_THREADS              ERROR_MAX_THRDS_REACHED
#define RPC_S_INVALID_LEVEL               ERROR_INVALID_PARAMETER
#define RPC_S_BUFFER_TOO_SMALL            ERROR_INSUFFICIENT_BUFFER
#define RPC_S_INVALID_SECURITY_DESC       ERROR_INVALID_SECURITY_DESCR
#define RPC_S_ACCESS_DENIED               ERROR_ACCESS_DENIED
#define RPC_S_SERVER_OUT_OF_MEMORY        ERROR_NOT_ENOUGH_SERVER_MEMORY
#define RPC_S_ASYNC_CALL_PENDING          ERROR_IO_PENDING
#define RPC_S_UNKNOWN_PRINCIPAL           ERROR_NONE_MAPPED
#define RPC_S_TIMEOUT                     ERROR_TIMEOUT
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define RPC_S_NOT_ENOUGH_QUOTA            ERROR_NOT_ENOUGH_QUOTA
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define RPC_X_NO_MEMORY                   RPC_S_OUT_OF_MEMORY
#define RPC_X_INVALID_BOUND               RPC_S_INVALID_BOUND
#define RPC_X_INVALID_TAG                 RPC_S_INVALID_TAG
#define RPC_X_ENUM_VALUE_TOO_LARGE        RPC_X_ENUM_VALUE_OUT_OF_RANGE
#define RPC_X_SS_CONTEXT_MISMATCH         ERROR_INVALID_HANDLE
#define RPC_X_INVALID_BUFFER              ERROR_INVALID_USER_BUFFER
#define RPC_X_PIPE_APP_MEMORY             ERROR_OUTOFMEMORY
#define RPC_X_INVALID_PIPE_OPERATION      RPC_X_WRONG_PIPE_ORDER

#else   // _KRPCENV_

#define RPC_S_OK                            STATUS_SUCCESS

#if defined(RPC_S_INVALID_STRING_BINDING)
#undef RPC_S_INVALID_STRING_BINDING
#endif
#define RPC_S_INVALID_STRING_BINDING        RPC_NT_INVALID_STRING_BINDING

#if defined(RPC_S_WRONG_KIND_OF_BINDING)
#undef RPC_S_WRONG_KIND_OF_BINDING
#endif
#define RPC_S_WRONG_KIND_OF_BINDING         RPC_NT_WRONG_KIND_OF_BINDING

#if defined(RPC_S_INVALID_BINDING)
#undef RPC_S_INVALID_BINDING
#endif
#define RPC_S_INVALID_BINDING               RPC_NT_INVALID_BINDING

#if defined(RPC_S_PROTSEQ_NOT_SUPPORTED)
#undef RPC_S_PROTSEQ_NOT_SUPPORTED
#endif
#define RPC_S_PROTSEQ_NOT_SUPPORTED         RPC_NT_PROTSEQ_NOT_SUPPORTED

#if defined(RPC_S_INVALID_RPC_PROTSEQ)
#undef RPC_S_INVALID_RPC_PROTSEQ
#endif
#define RPC_S_INVALID_RPC_PROTSEQ           RPC_NT_INVALID_RPC_PROTSEQ

#if defined(RPC_S_INVALID_STRING_UUID)
#undef RPC_S_INVALID_STRING_UUID
#endif
#define RPC_S_INVALID_STRING_UUID           RPC_NT_INVALID_STRING_UUID

#if defined(RPC_S_INVALID_ENDPOINT_FORMAT)
#undef RPC_S_INVALID_ENDPOINT_FORMAT
#endif
#define RPC_S_INVALID_ENDPOINT_FORMAT       RPC_NT_INVALID_ENDPOINT_FORMAT

#if defined(RPC_S_INVALID_NET_ADDR)
#undef RPC_S_INVALID_NET_ADDR
#endif
#define RPC_S_INVALID_NET_ADDR              RPC_NT_INVALID_NET_ADDR

#if defined(RPC_S_NO_ENDPOINT_FOUND)
#undef RPC_S_NO_ENDPOINT_FOUND
#endif
#define RPC_S_NO_ENDPOINT_FOUND             RPC_NT_NO_ENDPOINT_FOUND

#if defined(RPC_S_INVALID_TIMEOUT)
#undef RPC_S_INVALID_TIMEOUT
#endif
#define RPC_S_INVALID_TIMEOUT               RPC_NT_INVALID_TIMEOUT

#if defined(RPC_S_OBJECT_NOT_FOUND)
#undef RPC_S_OBJECT_NOT_FOUND
#endif
#define RPC_S_OBJECT_NOT_FOUND              RPC_NT_OBJECT_NOT_FOUND

#if defined(RPC_S_ALREADY_REGISTERED)
#undef RPC_S_ALREADY_REGISTERED
#endif
#define RPC_S_ALREADY_REGISTERED            RPC_NT_ALREADY_REGISTERED

#if defined(RPC_S_TYPE_ALREADY_REGISTERED)
#undef RPC_S_TYPE_ALREADY_REGISTERED
#endif
#define RPC_S_TYPE_ALREADY_REGISTERED       RPC_NT_TYPE_ALREADY_REGISTERED

#if defined(RPC_S_ALREADY_LISTENING)
#undef RPC_S_ALREADY_LISTENING
#endif
#define RPC_S_ALREADY_LISTENING             RPC_NT_ALREADY_LISTENING

#if defined(RPC_S_NO_PROTSEQS_REGISTERED)
#undef RPC_S_NO_PROTSEQS_REGISTERED
#endif
#define RPC_S_NO_PROTSEQS_REGISTERED        RPC_NT_NO_PROTSEQS_REGISTERED

#if defined(RPC_S_NOT_LISTENING)
#undef RPC_S_NOT_LISTENING
#endif
#define RPC_S_NOT_LISTENING                 RPC_NT_NOT_LISTENING

#if defined(RPC_S_UNKNOWN_MGR_TYPE)
#undef RPC_S_UNKNOWN_MGR_TYPE
#endif
#define RPC_S_UNKNOWN_MGR_TYPE              RPC_NT_UNKNOWN_MGR_TYPE

#if defined(RPC_S_UNKNOWN_IF)
#undef RPC_S_UNKNOWN_IF
#endif
#define RPC_S_UNKNOWN_IF                    RPC_NT_UNKNOWN_IF

#if defined(RPC_S_NO_BINDINGS)
#undef RPC_S_NO_BINDINGS
#endif
#define RPC_S_NO_BINDINGS                   RPC_NT_NO_BINDINGS

#if defined(RPC_S_NO_MORE_BINDINGS)
#undef RPC_S_NO_MORE_BINDINGS
#endif
#define RPC_S_NO_MORE_BINDINGS              RPC_NT_NO_MORE_BINDINGS

#if defined(RPC_S_NO_PROTSEQS)
#undef RPC_S_NO_PROTSEQS
#endif
#define RPC_S_NO_PROTSEQS                   RPC_NT_NO_PROTSEQS

#if defined(RPC_S_CANT_CREATE_ENDPOINT)
#undef RPC_S_CANT_CREATE_ENDPOINT
#endif
#define RPC_S_CANT_CREATE_ENDPOINT          RPC_NT_CANT_CREATE_ENDPOINT

#if defined(RPC_S_OUT_OF_RESOURCES)
#undef RPC_S_OUT_OF_RESOURCES
#endif
#define RPC_S_OUT_OF_RESOURCES              RPC_NT_OUT_OF_RESOURCES

#if defined(RPC_S_SERVER_UNAVAILABLE)
#undef RPC_S_SERVER_UNAVAILABLE
#endif
#define RPC_S_SERVER_UNAVAILABLE            RPC_NT_SERVER_UNAVAILABLE

#if defined(RPC_S_SERVER_TOO_BUSY)
#undef RPC_S_SERVER_TOO_BUSY
#endif
#define RPC_S_SERVER_TOO_BUSY               RPC_NT_SERVER_TOO_BUSY

#if defined(RPC_S_INVALID_NETWORK_OPTIONS)
#undef RPC_S_INVALID_NETWORK_OPTIONS
#endif
#define RPC_S_INVALID_NETWORK_OPTIONS       RPC_NT_INVALID_NETWORK_OPTIONS

#if defined(RPC_S_NO_CALL_ACTIVE)
#undef RPC_S_NO_CALL_ACTIVE
#endif
#define RPC_S_NO_CALL_ACTIVE                RPC_NT_NO_CALL_ACTIVE

#if defined(RPC_S_CALL_FAILED)
#undef RPC_S_CALL_FAILED
#endif
#define RPC_S_CALL_FAILED                   RPC_NT_CALL_FAILED

#if defined(RPC_S_CALL_CANCELLED)
#undef RPC_S_CALL_CANCELLED
#endif
#define RPC_S_CALL_CANCELLED                RPC_NT_CALL_CANCELLED

#if defined(RPC_S_CALL_FAILED_DNE)
#undef RPC_S_CALL_FAILED_DNE
#endif
#define RPC_S_CALL_FAILED_DNE               RPC_NT_CALL_FAILED_DNE

#if defined(RPC_S_PROTOCOL_ERROR)
#undef RPC_S_PROTOCOL_ERROR
#endif
#define RPC_S_PROTOCOL_ERROR                RPC_NT_PROTOCOL_ERROR

#if defined(RPC_S_UNSUPPORTED_TRANS_SYN)
#undef RPC_S_UNSUPPORTED_TRANS_SYN
#endif
#define RPC_S_UNSUPPORTED_TRANS_SYN         RPC_NT_UNSUPPORTED_TRANS_SYN

#if defined(RPC_S_SERVER_OUT_OF_MEMORY)
#undef RPC_S_SERVER_OUT_OF_MEMORY
#endif
#define RPC_S_SERVER_OUT_OF_MEMORY          STATUS_INSUFF_SERVER_RESOURCES

#if defined(RPC_S_UNSUPPORTED_TYPE)
#undef RPC_S_UNSUPPORTED_TYPE
#endif
#define RPC_S_UNSUPPORTED_TYPE              RPC_NT_UNSUPPORTED_TYPE

#if defined(RPC_S_INVALID_TAG)
#undef RPC_S_INVALID_TAG
#endif
#define RPC_S_INVALID_TAG                   RPC_NT_INVALID_TAG

#if defined(RPC_S_INVALID_BOUND)
#undef RPC_S_INVALID_BOUND
#endif
#define RPC_S_INVALID_BOUND                 RPC_NT_INVALID_BOUND

#if defined(RPC_S_NO_ENTRY_NAME)
#undef RPC_S_NO_ENTRY_NAME
#endif
#define RPC_S_NO_ENTRY_NAME                 RPC_NT_NO_ENTRY_NAME

#if defined(RPC_S_INVALID_NAME_SYNTAX)
#undef RPC_S_INVALID_NAME_SYNTAX
#endif
#define RPC_S_INVALID_NAME_SYNTAX           RPC_NT_INVALID_NAME_SYNTAX

#if defined(RPC_S_UNSUPPORTED_NAME_SYNTAX)
#undef RPC_S_UNSUPPORTED_NAME_SYNTAX
#endif
#define RPC_S_UNSUPPORTED_NAME_SYNTAX       RPC_NT_UNSUPPORTED_NAME_SYNTAX

#if defined(RPC_S_UUID_NO_ADDRESS)
#undef RPC_S_UUID_NO_ADDRESS
#endif
#define RPC_S_UUID_NO_ADDRESS               RPC_NT_UUID_NO_ADDRESS

#if defined(RPC_S_DUPLICATE_ENDPOINT)
#undef RPC_S_DUPLICATE_ENDPOINT
#endif
#define RPC_S_DUPLICATE_ENDPOINT            RPC_NT_DUPLICATE_ENDPOINT

#if defined(RPC_S_UNKNOWN_AUTHN_TYPE)
#undef RPC_S_UNKNOWN_AUTHN_TYPE
#endif
#define RPC_S_UNKNOWN_AUTHN_TYPE            RPC_NT_UNKNOWN_AUTHN_TYPE

#if defined(RPC_S_MAX_CALLS_TOO_SMALL)
#undef RPC_S_MAX_CALLS_TOO_SMALL
#endif
#define RPC_S_MAX_CALLS_TOO_SMALL           RPC_NT_MAX_CALLS_TOO_SMALL

#if defined(RPC_S_STRING_TOO_LONG)
#undef RPC_S_STRING_TOO_LONG
#endif
#define RPC_S_STRING_TOO_LONG               RPC_NT_STRING_TOO_LONG

#if defined(RPC_S_PROTSEQ_NOT_FOUND)
#undef RPC_S_PROTSEQ_NOT_FOUND
#endif
#define RPC_S_PROTSEQ_NOT_FOUND             RPC_NT_PROTSEQ_NOT_FOUND

#if defined(RPC_S_PROCNUM_OUT_OF_RANGE)
#undef RPC_S_PROCNUM_OUT_OF_RANGE
#endif
#define RPC_S_PROCNUM_OUT_OF_RANGE          RPC_NT_PROCNUM_OUT_OF_RANGE

#if defined(RPC_S_BINDING_HAS_NO_AUTH)
#undef RPC_S_BINDING_HAS_NO_AUTH
#endif
#define RPC_S_BINDING_HAS_NO_AUTH           RPC_NT_BINDING_HAS_NO_AUTH

#if defined(RPC_S_UNKNOWN_AUTHN_SERVICE)
#undef RPC_S_UNKNOWN_AUTHN_SERVICE
#endif
#define RPC_S_UNKNOWN_AUTHN_SERVICE         RPC_NT_UNKNOWN_AUTHN_SERVICE

#if defined(RPC_S_UNKNOWN_AUTHN_LEVEL)
#undef RPC_S_UNKNOWN_AUTHN_LEVEL
#endif
#define RPC_S_UNKNOWN_AUTHN_LEVEL           RPC_NT_UNKNOWN_AUTHN_LEVEL

#if defined(RPC_S_INVALID_AUTH_IDENTITY)
#undef RPC_S_INVALID_AUTH_IDENTITY
#endif
#define RPC_S_INVALID_AUTH_IDENTITY         RPC_NT_INVALID_AUTH_IDENTITY

#if defined(RPC_S_UNKNOWN_AUTHZ_SERVICE)
#undef RPC_S_UNKNOWN_AUTHZ_SERVICE
#endif
#define RPC_S_UNKNOWN_AUTHZ_SERVICE         RPC_NT_UNKNOWN_AUTHZ_SERVICE

#if defined(EPT_S_INVALID_ENTRY)
#undef EPT_S_INVALID_ENTRY
#endif
#define EPT_S_INVALID_ENTRY                 EPT_NT_INVALID_ENTRY

#if defined(EPT_S_CANT_PERFORM_OP)
#undef EPT_S_CANT_PERFORM_OP
#endif
#define EPT_S_CANT_PERFORM_OP               EPT_NT_CANT_PERFORM_OP

#if defined(EPT_S_NOT_REGISTERED)
#undef EPT_S_NOT_REGISTERED
#endif
#define EPT_S_NOT_REGISTERED                EPT_NT_NOT_REGISTERED

#if defined(RPC_S_NOTHING_TO_EXPORT)
#undef RPC_S_NOTHING_TO_EXPORT
#endif
#define RPC_S_NOTHING_TO_EXPORT             RPC_NT_NOTHING_TO_EXPORT

#if defined(RPC_S_INCOMPLETE_NAME)
#undef RPC_S_INCOMPLETE_NAME
#endif
#define RPC_S_INCOMPLETE_NAME               RPC_NT_INCOMPLETE_NAME

#if defined(RPC_S_INVALID_VERS_OPTION)
#undef RPC_S_INVALID_VERS_OPTION
#endif
#define RPC_S_INVALID_VERS_OPTION           RPC_NT_INVALID_VERS_OPTION

#if defined(RPC_S_NO_MORE_MEMBERS)
#undef RPC_S_NO_MORE_MEMBERS
#endif
#define RPC_S_NO_MORE_MEMBERS               RPC_NT_NO_MORE_MEMBERS

#if defined(RPC_S_NOT_ALL_OBJS_UNEXPORTED)
#undef RPC_S_NOT_ALL_OBJS_UNEXPORTED
#endif
#define RPC_S_NOT_ALL_OBJS_UNEXPORTED       RPC_NT_NOT_ALL_OBJS_UNEXPORTED

#if defined(RPC_S_INTERFACE_NOT_FOUND)
#undef RPC_S_INTERFACE_NOT_FOUND
#endif
#define RPC_S_INTERFACE_NOT_FOUND           RPC_NT_INTERFACE_NOT_FOUND

#if defined(RPC_S_ENTRY_ALREADY_EXISTS)
#undef RPC_S_ENTRY_ALREADY_EXISTS
#endif
#define RPC_S_ENTRY_ALREADY_EXISTS          RPC_NT_ENTRY_ALREADY_EXISTS

#if defined(RPC_S_ENTRY_NOT_FOUND)
#undef RPC_S_ENTRY_NOT_FOUND
#endif
#define RPC_S_ENTRY_NOT_FOUND               RPC_NT_ENTRY_NOT_FOUND

#if defined(RPC_S_NAME_SERVICE_UNAVAILABLE)
#undef RPC_S_NAME_SERVICE_UNAVAILABLE
#endif
#define RPC_S_NAME_SERVICE_UNAVAILABLE      RPC_NT_NAME_SERVICE_UNAVAILABLE

#if defined(RPC_S_INVALID_NAF_ID)
#undef RPC_S_INVALID_NAF_ID
#endif
#define RPC_S_INVALID_NAF_ID                RPC_NT_INVALID_NAF_ID

#if defined(RPC_S_CANNOT_SUPPORT)
#undef RPC_S_CANNOT_SUPPORT
#endif
#define RPC_S_CANNOT_SUPPORT                RPC_NT_CANNOT_SUPPORT

#if defined(RPC_S_NO_CONTEXT_AVAILABLE)
#undef RPC_S_NO_CONTEXT_AVAILABLE
#endif
#define RPC_S_NO_CONTEXT_AVAILABLE          RPC_NT_NO_CONTEXT_AVAILABLE

#if defined(RPC_S_INTERNAL_ERROR)
#undef RPC_S_INTERNAL_ERROR
#endif
#define RPC_S_INTERNAL_ERROR                RPC_NT_INTERNAL_ERROR

#if defined(RPC_S_ZERO_DIVIDE)
#undef RPC_S_ZERO_DIVIDE
#endif
#define RPC_S_ZERO_DIVIDE                   RPC_NT_ZERO_DIVIDE

#if defined(RPC_S_ADDRESS_ERROR)
#undef RPC_S_ADDRESS_ERROR
#endif
#define RPC_S_ADDRESS_ERROR                 RPC_NT_ADDRESS_ERROR

#if defined(RPC_S_FP_DIV_ZERO)
#undef RPC_S_FP_DIV_ZERO
#endif
#define RPC_S_FP_DIV_ZERO                   RPC_NT_FP_DIV_ZERO

#if defined(RPC_S_FP_UNDERFLOW)
#undef RPC_S_FP_UNDERFLOW
#endif
#define RPC_S_FP_UNDERFLOW                  RPC_NT_FP_UNDERFLOW

#if defined(RPC_S_FP_OVERFLOW)
#undef RPC_S_FP_OVERFLOW
#endif
#define RPC_S_FP_OVERFLOW                   RPC_NT_FP_OVERFLOW

#if defined(RPC_S_PROXY_ACCESS_DENIED)
#undef RPC_S_PROXY_ACCESS_DENIED
#endif
#define RPC_S_PROXY_ACCESS_DENIED           RPC_NT_PROXY_ACCESS_DENIED

#if defined(RPC_X_NO_MORE_ENTRIES)
#undef RPC_X_NO_MORE_ENTRIES
#endif
#define RPC_X_NO_MORE_ENTRIES               RPC_NT_NO_MORE_ENTRIES

#if defined(RPC_X_SS_CHAR_TRANS_OPEN_FAIL)
#undef RPC_X_SS_CHAR_TRANS_OPEN_FAIL
#endif
#define RPC_X_SS_CHAR_TRANS_OPEN_FAIL       RPC_NT_SS_CHAR_TRANS_OPEN_FAIL

#if defined(RPC_X_SS_CHAR_TRANS_SHORT_FILE)
#undef RPC_X_SS_CHAR_TRANS_SHORT_FILE
#endif
#define RPC_X_SS_CHAR_TRANS_SHORT_FILE      RPC_NT_SS_CHAR_TRANS_SHORT_FILE

#if defined(RPC_X_SS_IN_NULL_CONTEXT)
#undef RPC_X_SS_IN_NULL_CONTEXT
#endif
#define RPC_X_SS_IN_NULL_CONTEXT            RPC_NT_SS_IN_NULL_CONTEXT

#if defined(RPC_X_SS_CONTEXT_MISMATCH)
#undef RPC_X_SS_CONTEXT_MISMATCH
#endif
#define RPC_X_SS_CONTEXT_MISMATCH           RPC_NT_SS_CONTEXT_MISMATCH

#if defined(RPC_X_SS_CONTEXT_DAMAGED)
#undef RPC_X_SS_CONTEXT_DAMAGED
#endif
#define RPC_X_SS_CONTEXT_DAMAGED            RPC_NT_SS_CONTEXT_DAMAGED

#if defined(RPC_X_SS_HANDLES_MISMATCH)
#undef RPC_X_SS_HANDLES_MISMATCH
#endif
#define RPC_X_SS_HANDLES_MISMATCH           RPC_NT_SS_HANDLES_MISMATCH

#if defined(RPC_X_SS_CANNOT_GET_CALL_HANDLE)
#undef RPC_X_SS_CANNOT_GET_CALL_HANDLE
#endif
#define RPC_X_SS_CANNOT_GET_CALL_HANDLE     RPC_NT_SS_CANNOT_GET_CALL_HANDLE

#if defined(RPC_X_NULL_REF_POINTER)
#undef RPC_X_NULL_REF_POINTER
#endif
#define RPC_X_NULL_REF_POINTER              RPC_NT_NULL_REF_POINTER

#if defined(RPC_X_ENUM_VALUE_OUT_OF_RANGE)
#undef RPC_X_ENUM_VALUE_OUT_OF_RANGE
#endif
#define RPC_X_ENUM_VALUE_OUT_OF_RANGE       RPC_NT_ENUM_VALUE_OUT_OF_RANGE

#if defined(RPC_X_BYTE_COUNT_TOO_SMALL)
#undef RPC_X_BYTE_COUNT_TOO_SMALL
#endif
#define RPC_X_BYTE_COUNT_TOO_SMALL          RPC_NT_BYTE_COUNT_TOO_SMALL

#if defined(RPC_X_BAD_STUB_DATA)
#undef RPC_X_BAD_STUB_DATA
#endif
#define RPC_X_BAD_STUB_DATA                 RPC_NT_BAD_STUB_DATA

#if defined(RPC_S_CALL_IN_PROGRESS)
#undef RPC_S_CALL_IN_PROGRESS
#endif
#define RPC_S_CALL_IN_PROGRESS              RPC_NT_CALL_IN_PROGRESS

#if defined(RPC_S_GROUP_MEMBER_NOT_FOUND)
#undef RPC_S_GROUP_MEMBER_NOT_FOUND
#endif
#define RPC_S_GROUP_MEMBER_NOT_FOUND        RPC_NT_GROUP_MEMBER_NOT_FOUND

#if defined(EPT_S_CANT_CREATE)
#undef EPT_S_CANT_CREATE
#endif
#define EPT_S_CANT_CREATE                   EPT_NT_CANT_CREATE

#if defined(RPC_S_INVALID_OBJECT)
#undef RPC_S_INVALID_OBJECT
#endif
#define RPC_S_INVALID_OBJECT                RPC_NT_INVALID_OBJECT

#if defined(RPC_S_INVALID_ASYNC_HANDLE)
#undef RPC_S_INVALID_ASYNC_HANDLE
#endif
#define RPC_S_INVALID_ASYNC_HANDLE          RPC_NT_INVALID_ASYNC_HANDLE

#if defined(RPC_S_INVALID_ASYNC_CALL)
#undef RPC_S_INVALID_ASYNC_CALL
#endif
#define RPC_S_INVALID_ASYNC_CALL            RPC_NT_INVALID_ASYNC_CALL

#if defined(RPC_X_PIPE_CLOSED)
#undef RPC_X_PIPE_CLOSED
#endif
#define RPC_X_PIPE_CLOSED                   RPC_NT_PIPE_CLOSED

#if defined(RPC_X_PIPE_EMPTY)
#undef RPC_X_PIPE_EMPTY
#endif
#define RPC_X_PIPE_EMPTY                    RPC_NT_PIPE_EMPTY

#if defined(RPC_X_PIPE_DISCIPLINE_ERROR)
#undef RPC_X_PIPE_DISCIPLINE_ERROR
#endif
#define RPC_X_PIPE_DISCIPLINE_ERROR         RPC_NT_PIPE_DISCIPLINE_ERROR

#define RPC_S_INVALID_ARG                   STATUS_INVALID_PARAMETER
#define RPC_S_OUT_OF_MEMORY                 STATUS_NO_MEMORY
#define RPC_S_OUT_OF_THREADS                STATUS_NO_MEMORY
#define RPC_S_INVALID_LEVEL                 STATUS_INVALID_PARAMETER
#define RPC_S_BUFFER_TOO_SMALL              STATUS_BUFFER_TOO_SMALL
#define RPC_S_INVALID_SECURITY_DESC         STATUS_INVALID_SECURITY_DESCR
#define RPC_S_ACCESS_DENIED                 STATUS_ACCESS_DENIED
#define RPC_S_ASYNC_CALL_PENDING            STATUS_PENDING
#define RPC_S_UNKNOWN_PRINCIPAL             STATUS_NONE_MAPPED
#define RPC_S_NOT_ENOUGH_QUOTA              STATUS_QUOTA_EXCEEDED
#define RPC_X_NO_MEMORY                     STATUS_NO_MEMORY
#define RPC_X_INVALID_BOUND                 RPC_NT_INVALID_BOUND
#define RPC_X_INVALID_TAG                   RPC_NT_INVALID_TAG
#define RPC_X_ENUM_VALUE_TOO_LARGE          RPC_NT_ENUM_VALUE_OUT_OF_RANGE
#define RPC_X_SS_CONTEXT_MISMATCH           RPC_NT_SS_CONTEXT_MISMATCH
#define RPC_X_INVALID_BUFFER                STATUS_INVALID_BUFFER_SIZE
#define RPC_X_PIPE_APP_MEMORY               STATUS_NO_MEMORY

#endif  // _KRPCENV_

#endif /* __RPCNTERR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RpcNsip.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcnsip.h

Abstract:

    This file contains the types and function definitions to use the
    to implement the autohandle features of the runtime.

--*/

#ifndef __RPCNSIP_H__
#define __RPCNSIP_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct
{
   RPC_NS_HANDLE        LookupContext;
   RPC_BINDING_HANDLE   ProposedHandle;
   RPC_BINDING_VECTOR * Bindings;

} RPC_IMPORT_CONTEXT_P, * PRPC_IMPORT_CONTEXT_P;


/* Stub Auto Binding routines. */

RPCNSAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsGetBuffer(
    IN PRPC_MESSAGE Message
    );

RPCNSAPI
RPC_STATUS
RPC_ENTRY
I_RpcNsSendReceive(
    IN PRPC_MESSAGE Message,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Handle
    );

RPCNSAPI
void
RPC_ENTRY
I_RpcNsRaiseException(
    IN PRPC_MESSAGE Message,
    IN RPC_STATUS Status
    );

RPCNSAPI
RPC_STATUS
RPC_ENTRY
I_RpcReBindBuffer(
    IN PRPC_MESSAGE Message
    );

RPCNSAPI
RPC_STATUS
RPC_ENTRY
I_NsServerBindSearch(
    void
    );

RPCNSAPI
RPC_STATUS
RPC_ENTRY
I_NsClientBindSearch(
    void
    );

RPCNSAPI
void
RPC_ENTRY
I_NsClientBindDone(
    void
    );

#ifdef __cplusplus
}
#endif

#endif /* __RPCNSIP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RpcProxy.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rpcproxy.h

Abstract:

    Definitions for rpc proxy  stubs.

Compiler switches:

    -DREGISTER_PROXY_DLL
        Generates DllMain, DllRegisterServer, and DllUnregisterServer functions
        for automatically registering a proxy DLL.

    -DPROXY_CLSID=clsid
        Specifies a class ID to be used by the proxy DLL.

    -DPROXY_CLSID_IS={0x6f11fe5c,0x2fc5,0x101b,{0x9e,0x45,0x00,0x00,0x0b,0x65,0xc7,0xef}}
        Specifies the value of the class ID to be used by the proxy DLL.

    -DENTRY_PREFIX=<prefix>
        String to be prepended on all the DllGetClassObject etc routines
        in dlldata.c.  This includes: DllGetClassObject, DllCanUnloadNow
        and DllMain, DllRegisterServer, and DllUnregisterServer.

    -DNT35_STRICT
        Specifies that the target platform is Windows NT 3.5. This switch disables
        the new functions added after the Windows NT 3.5 release.

--*/

// This version of the rpcndr.h file corresponds to MIDL version 5.0.+
// used with NT5 beta1+ env from build #1700 on.

#ifndef __RPCPROXY_H_VERSION__
#define __RPCPROXY_H_VERSION__      ( 475 )
#endif // __RPCPROXY_H_VERSION__

#if !defined(_KRPCENV_)

#ifndef __RPCPROXY_H__
#define __RPCPROXY_H__
#if _MSC_VER > 1000
#pragma once
#endif

#define __midl_proxy

#ifdef __REQUIRED_RPCPROXY_H_VERSION__
    #if ( __RPCPROXY_H_VERSION__ < __REQUIRED_RPCPROXY_H_VERSION__ )
        #error incorrect <rpcproxy.h> version. Use the header that matches with the MIDL compiler.
    #endif
#endif

// If this is the first file included __RPC_WIN64__ is not defined yet.
#if defined(_M_IA64) || defined(_M_AMD64)
#include <pshpack8.h>
#endif

#include <basetsd.h>

#ifndef INC_OLE2
#define INC_OLE2
#endif

#if defined(WIN32) || defined(_M_AMD64)

//We need to define REFIID, REFCLSID, REFGUID, & REFFMTID here so that the
//proxy code won't get the const GUID *const definition.
#ifndef GUID_DEFINED
#include <guiddef.h>
#endif /* GUID_DEFINED */

#if defined(__cplusplus)
extern "C"
{
#endif

// forward declarations
struct tagCInterfaceStubVtbl;
struct tagCInterfaceProxyVtbl;

typedef struct tagCInterfaceStubVtbl *  PCInterfaceStubVtblList;
typedef struct tagCInterfaceProxyVtbl *  PCInterfaceProxyVtblList;
typedef const char *                    PCInterfaceName;
typedef int __stdcall IIDLookupRtn( const IID * pIID, int * pIndex );
typedef IIDLookupRtn * PIIDLookup;

#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4610) // struct can never be instantiated - user defined constructor required
#pragma warning(disable:4510) // default constructor could not be generated
#pragma warning(disable:4512) // assignment operator could not be generated
#endif

// pointers to arrays of CInterfaceProxyVtbl's and CInterfaceStubVtbls
typedef struct tagProxyFileInfo
{
    const PCInterfaceProxyVtblList *pProxyVtblList;
    const PCInterfaceStubVtblList  *pStubVtblList;
    const PCInterfaceName *         pNamesArray;
    const IID **                    pDelegatedIIDs;
    const PIIDLookup                pIIDLookupRtn;
    unsigned short                  TableSize;
    unsigned short                  TableVersion;
    const IID **                    pAsyncIIDLookup;
    LONG_PTR                        Filler2;
    LONG_PTR                        Filler3;
    LONG_PTR                        Filler4;
}ProxyFileInfo;

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

// extended info with list of interface names
typedef ProxyFileInfo ExtendedProxyFileInfo;

#include <rpc.h>
#include <rpcndr.h>
#include <string.h>
#include <memory.h>

typedef struct tagCInterfaceProxyHeader
{
    //
    // New fields should be added here, at the beginning of the structure.
    //
#ifdef USE_STUBLESS_PROXY
    const void *    pStublessProxyInfo;
#endif
    const IID *     piid;
} CInterfaceProxyHeader;

// Macro used for ANSI compatible stubs.

#define CINTERFACE_PROXY_VTABLE( n )  \
struct \
{                                     \
    CInterfaceProxyHeader header;     \
    void *Vtbl[ n ];                  \
}

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable:4200 )
typedef struct tagCInterfaceProxyVtbl
{
    CInterfaceProxyHeader header;
#if defined( _MSC_VER )
    void *Vtbl[];
#else
    void *Vtbl[1];
#endif
} CInterfaceProxyVtbl;
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default:4200 )
#endif

typedef
void
(__RPC_STUB * PRPC_STUB_FUNCTION) (
    IRpcStubBuffer          *   This,
    IRpcChannelBuffer       *   _pRpcChannelBuffer,
    PRPC_MESSAGE                _pRpcMessage,
    DWORD *pdwStubPhase);

typedef struct tagCInterfaceStubHeader
{
    //New fields should be added here, at the beginning of the structure.
    const IID               *   piid;
    const MIDL_SERVER_INFO  *   pServerInfo;
    unsigned long               DispatchTableCount;
    const PRPC_STUB_FUNCTION *  pDispatchTable;
} CInterfaceStubHeader;

typedef struct tagCInterfaceStubVtbl
{
    CInterfaceStubHeader        header;
    IRpcStubBufferVtbl          Vtbl;
} CInterfaceStubVtbl;

typedef struct tagCStdStubBuffer
{
    const struct IRpcStubBufferVtbl *   lpVtbl; //Points to Vtbl field in CInterfaceStubVtbl.
    long                                RefCount;
    struct IUnknown *                   pvServerObject;

    const struct ICallFactoryVtbl *     pCallFactoryVtbl;
    const IID *                         pAsyncIID;
    struct IPSFactoryBuffer *           pPSFactory;
    const struct IReleaseMarshalBuffersVtbl *     pRMBVtbl;
} CStdStubBuffer;

typedef struct tagCStdPSFactoryBuffer
{
    const IPSFactoryBufferVtbl  *   lpVtbl;
    long                            RefCount;
    const ProxyFileInfo **          pProxyFileList;
    long                            Filler1;  //Reserved for future use.
} CStdPSFactoryBuffer;

RPCRTAPI
void
RPC_ENTRY
NdrProxyInitialize(
    void *              This,
    PRPC_MESSAGE        pRpcMsg,
    PMIDL_STUB_MESSAGE  pStubMsg,
    PMIDL_STUB_DESC     pStubDescriptor,
    unsigned int        ProcNum );

RPCRTAPI
void
RPC_ENTRY
NdrProxyGetBuffer(
    void *              This,
    PMIDL_STUB_MESSAGE pStubMsg);

RPCRTAPI
void
RPC_ENTRY
NdrProxySendReceive(
    void                *This,
    MIDL_STUB_MESSAGE   *pStubMsg);

RPCRTAPI
void
RPC_ENTRY
NdrProxyFreeBuffer(
    void                *This,
    MIDL_STUB_MESSAGE   *pStubMsg);

RPCRTAPI
HRESULT
RPC_ENTRY
NdrProxyErrorHandler(
    DWORD dwExceptionCode);

RPCRTAPI
void
RPC_ENTRY
NdrStubInitialize(
    PRPC_MESSAGE        pRpcMsg,
    PMIDL_STUB_MESSAGE  pStubMsg,
    PMIDL_STUB_DESC     pStubDescriptor,
    IRpcChannelBuffer * pRpcChannelBuffer);

RPCRTAPI
void
RPC_ENTRY
NdrStubInitializePartial(
    PRPC_MESSAGE        pRpcMsg,
    PMIDL_STUB_MESSAGE  pStubMsg,
    PMIDL_STUB_DESC     pStubDescriptor,
    IRpcChannelBuffer * pRpcChannelBuffer,
    unsigned long       RequestedBufferSize);

void __RPC_STUB NdrStubForwardingFunction(
    IN  IRpcStubBuffer *    This,
    IN  IRpcChannelBuffer * pChannel,
    IN  PRPC_MESSAGE        pmsg,
    OUT DWORD             * pdwStubPhase);

RPCRTAPI
void
RPC_ENTRY
NdrStubGetBuffer(
    IRpcStubBuffer *    This,
    IRpcChannelBuffer * pRpcChannelBuffer,
    PMIDL_STUB_MESSAGE  pStubMsg);

RPCRTAPI
HRESULT
RPC_ENTRY
NdrStubErrorHandler(
    DWORD               dwExceptionCode);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_QueryInterface(
    IRpcStubBuffer  *   This,
    REFIID              riid,
    void            **  ppvObject);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_AddRef(
    IRpcStubBuffer *    This);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_Release(
    IRpcStubBuffer *    This);

ULONG STDMETHODCALLTYPE
NdrCStdStubBuffer_Release(
    IRpcStubBuffer *    This,
    IPSFactoryBuffer *  pPSF);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Connect(
    IRpcStubBuffer *    This,
    IUnknown *          pUnkServer);

void STDMETHODCALLTYPE
CStdStubBuffer_Disconnect(
    IRpcStubBuffer *    This);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Invoke(
    IRpcStubBuffer  *   This,
    RPCOLEMESSAGE   *   pRpcMsg,
    IRpcChannelBuffer * pRpcChannelBuffer);

IRpcStubBuffer * STDMETHODCALLTYPE
CStdStubBuffer_IsIIDSupported(
    IRpcStubBuffer  *   This,
    REFIID riid);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_CountRefs(
    IRpcStubBuffer  *   This);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_DebugServerQueryInterface(
    IRpcStubBuffer  *   This,
    void **ppv);

void STDMETHODCALLTYPE
CStdStubBuffer_DebugServerRelease(
    IRpcStubBuffer  *   This,
    void *pv);

void ObjectStublessClient3(void);
void ObjectStublessClient4(void);
void ObjectStublessClient5(void);
void ObjectStublessClient6(void);
void ObjectStublessClient7(void);
void ObjectStublessClient8(void);
void ObjectStublessClient9(void);
void ObjectStublessClient10(void);
void ObjectStublessClient11(void);
void ObjectStublessClient12(void);
void ObjectStublessClient13(void);
void ObjectStublessClient14(void);
void ObjectStublessClient15(void);
void ObjectStublessClient16(void);
void ObjectStublessClient17(void);
void ObjectStublessClient18(void);
void ObjectStublessClient19(void);
void ObjectStublessClient20(void);
void ObjectStublessClient21(void);
void ObjectStublessClient22(void);
void ObjectStublessClient23(void);
void ObjectStublessClient24(void);
void ObjectStublessClient25(void);
void ObjectStublessClient26(void);
void ObjectStublessClient27(void);
void ObjectStublessClient28(void);
void ObjectStublessClient29(void);
void ObjectStublessClient30(void);
void ObjectStublessClient31(void);
void ObjectStublessClient32(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction3(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction4(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction5(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction6(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction7(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction8(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction9(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction10(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction11(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction12(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction13(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction14(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction15(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction16(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction17(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction18(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction19(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction20(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction21(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction22(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction23(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction24(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction25(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction26(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction27(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction28(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction29(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction30(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction31(void);

void STDMETHODCALLTYPE
NdrProxyForwardingFunction32(void);

#define CStdStubBuffer_METHODS \
    CStdStubBuffer_QueryInterface,\
    CStdStubBuffer_AddRef, \
    CStdStubBuffer_Release, \
    CStdStubBuffer_Connect, \
    CStdStubBuffer_Disconnect, \
    CStdStubBuffer_Invoke, \
    CStdStubBuffer_IsIIDSupported, \
    CStdStubBuffer_CountRefs, \
    CStdStubBuffer_DebugServerQueryInterface, \
    CStdStubBuffer_DebugServerRelease

#define CStdAsyncStubBuffer_METHODS              0,0,0,0,0,0,0,0,0,0
#define CStdAsyncStubBuffer_DELEGATING_METHODS   0,0,0,0,0,0,0,0,0,0

//+-------------------------------------------------------------------------
//
//  Macro definitions for the proxy file
//
//--------------------------------------------------------------------------

#define IID_GENERIC_CHECK_IID(name,pIID,index) memcmp( pIID, name##_ProxyVtblList[ index ]->header.piid, 16 )

#define IID_BS_LOOKUP_SETUP     int result, low=-1;

#define IID_BS_LOOKUP_INITIAL_TEST(name, sz, split)   \
    result = name##_CHECK_IID( split );               \
    if ( result > 0 )                                 \
        { low = sz - split; }                         \
    else if ( !result )                               \
        { low = split; goto found_label; }

#define IID_BS_LOOKUP_NEXT_TEST(name, split )      \
        result = name##_CHECK_IID( low + split );  \
        if ( result >= 0 )                         \
        { low = low + split; if ( !result ) goto found_label; }

#define IID_BS_LOOKUP_RETURN_RESULT(name, sz, index )  \
    low = low + 1;                                     \
    if (low >= sz)                                     \
        goto not_found_label;                          \
    result = name##_CHECK_IID( low );                  \
    if (result)                                        \
        goto not_found_label;                          \
    found_label: (index) = low; return 1;              \
    not_found_label: return 0;

//+-------------------------------------------------------------------------
//
//  Macro and routine definitions for the dlldata file
//
//--------------------------------------------------------------------------

/****************************************************************************
 * Proxy Dll APIs
 ****************************************************************************/

RPCRTAPI
HRESULT
RPC_ENTRY
NdrDllGetClassObject (
    IN  REFCLSID                rclsid,
    IN  REFIID                  riid,
    OUT void **                 ppv,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid,
    IN CStdPSFactoryBuffer *    pPSFactoryBuffer);

RPCRTAPI
HRESULT
RPC_ENTRY
NdrDllCanUnloadNow(
    IN CStdPSFactoryBuffer *    pPSFactoryBuffer);

// if the user specified a routine prefix, pick it up...
//     if not, add nothing

#ifndef ENTRY_PREFIX

#ifndef DllMain
#define DISABLE_THREAD_LIBRARY_CALLS(x) DisableThreadLibraryCalls(x)
#endif

#define ENTRY_PREFIX
#define DLLREGISTERSERVER_ENTRY DllRegisterServer
#define DLLUNREGISTERSERVER_ENTRY DllUnregisterServer
#define DLLMAIN_ENTRY DllMain

#define DLLGETCLASSOBJECT_ENTRY DllGetClassObject
#define DLLCANUNLOADNOW_ENTRY DllCanUnloadNow

#else   // ENTRY_PREFIX

#define __rpc_macro_expand2(a, b) a##b
#define __rpc_macro_expand(a, b) __rpc_macro_expand2(a,b)
#define DLLREGISTERSERVER_ENTRY __rpc_macro_expand(ENTRY_PREFIX, DllRegisterServer)
#define DLLUNREGISTERSERVER_ENTRY __rpc_macro_expand(ENTRY_PREFIX, DllUnregisterServer)
#define DLLMAIN_ENTRY __rpc_macro_expand(ENTRY_PREFIX, DllMain)

#define DLLGETCLASSOBJECT_ENTRY __rpc_macro_expand(ENTRY_PREFIX, DllGetClassObject)
#define DLLCANUNLOADNOW_ENTRY __rpc_macro_expand(ENTRY_PREFIX, DllCanUnloadNow)

#endif  // ENTRY_PREFIX

#ifndef DISABLE_THREAD_LIBRARY_CALLS
#define DISABLE_THREAD_LIBRARY_CALLS(x)
#endif

/*************************************************************************
The following new functions were added after the Windows NT 3.5 release.
*************************************************************************/

RPCRTAPI
HRESULT
RPC_ENTRY
NdrDllRegisterProxy(
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid);

RPCRTAPI
HRESULT
RPC_ENTRY
NdrDllUnregisterProxy(
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList,
    IN const CLSID *            pclsid);

#define REGISTER_PROXY_DLL_ROUTINES(pProxyFileList, pClsID) \
    \
    HINSTANCE hProxyDll = 0; \
    \
    /*DllMain saves the DLL module handle for later use by DllRegisterServer */ \
    BOOL WINAPI DLLMAIN_ENTRY( \
        HINSTANCE  hinstDLL, \
        DWORD  fdwReason, \
        LPVOID  lpvReserved) \
    { \
        UNREFERENCED_PARAMETER(lpvReserved); \
        if(fdwReason == DLL_PROCESS_ATTACH) \
            { \
            hProxyDll = hinstDLL; \
            DISABLE_THREAD_LIBRARY_CALLS(hinstDLL); \
            } \
        return TRUE; \
    } \
    \
    /* DllRegisterServer registers the interfaces contained in the proxy DLL. */ \
    HRESULT STDAPICALLTYPE DLLREGISTERSERVER_ENTRY() \
    { \
        return NdrDllRegisterProxy(hProxyDll, pProxyFileList, pClsID); \
    }  \
    \
    /* DllUnregisterServer unregisters the interfaces contained in the proxy DLL. */ \
    HRESULT STDAPICALLTYPE DLLUNREGISTERSERVER_ENTRY() \
    { \
        return NdrDllUnregisterProxy(hProxyDll, pProxyFileList, pClsID); \
    }

//Delegation support.
#define STUB_FORWARDING_FUNCTION        NdrStubForwardingFunction

ULONG STDMETHODCALLTYPE
CStdStubBuffer2_Release(IRpcStubBuffer *This);

ULONG STDMETHODCALLTYPE
NdrCStdStubBuffer2_Release(IRpcStubBuffer *This,IPSFactoryBuffer * pPSF);

#define CStdStubBuffer_DELEGATING_METHODS 0, 0, CStdStubBuffer2_Release, 0, 0, 0, 0, 0, 0, 0

/*************************************************************************
End of new functions.
*************************************************************************/

// PROXY_CLSID has precedence over PROXY_CLSID_IS

#ifdef PROXY_CLSID

#define CLSID_PSFACTORYBUFFER extern CLSID PROXY_CLSID;

#else // PROXY_CLSID

#ifdef PROXY_CLSID_IS
#define CLSID_PSFACTORYBUFFER const CLSID CLSID_PSFactoryBuffer = PROXY_CLSID_IS;
#define PROXY_CLSID     CLSID_PSFactoryBuffer
#else // PROXY_CLSID_IS
#define CLSID_PSFACTORYBUFFER
#endif //PROXY_CLSID_IS

#endif //PROXY_CLSID

// if the user specified an override for the class id, it is
// PROXY_CLSID at this point

#ifndef PROXY_CLSID
#define GET_DLL_CLSID   \
    ( aProxyFileList[0]->pStubVtblList[0] != 0 ? \
    aProxyFileList[0]->pStubVtblList[0]->header.piid : 0)
#else  //PROXY_CLSID
#define GET_DLL_CLSID   &PROXY_CLSID
#endif //PROXY_CLSID



#define EXTERN_PROXY_FILE(name) \
    EXTERN_C const ProxyFileInfo name##_ProxyFileInfo;

#define PROXYFILE_LIST_START    \
    const ProxyFileInfo  *  aProxyFileList[]    = {

#define REFERENCE_PROXY_FILE(name)  \
    & name##_ProxyFileInfo

#define PROXYFILE_LIST_END      \
    0 };

// return pointers to the class information

#define DLLDATA_GETPROXYDLLINFO(pPFList,pClsid) \
    void RPC_ENTRY GetProxyDllInfo( const ProxyFileInfo*** pInfo, const CLSID ** pId )  \
        {   \
        *pInfo  = pPFList;  \
        *pId    = pClsid;   \
        };

// ole entry points:
#define DLLGETCLASSOBJECTROUTINE(pPFlist, pClsid,pFactory)    \
 HRESULT STDAPICALLTYPE DLLGETCLASSOBJECT_ENTRY ( \
     __in REFCLSID rclsid, \
     __in REFIID riid, \
     __deref_out void ** ppv ) \
        { \
        return  \
            NdrDllGetClassObject(rclsid,riid,ppv,pPFlist,pClsid,pFactory ); \
        }

#define DLLCANUNLOADNOW(pFactory)   \
 HRESULT STDAPICALLTYPE DLLCANUNLOADNOW_ENTRY()    \
    {   \
    return NdrDllCanUnloadNow( pFactory );    \
    }


#define DLLDUMMYPURECALL    \
    void __cdecl _purecall(void)    \
        {   \
        }

#define CSTDSTUBBUFFERRELEASE(pFactory)   \
ULONG STDMETHODCALLTYPE CStdStubBuffer_Release(IRpcStubBuffer *This) \
    {   \
    return NdrCStdStubBuffer_Release(This,(IPSFactoryBuffer *)pFactory);   \
    }   \

#ifdef PROXY_DELEGATION
#define CSTDSTUBBUFFER2RELEASE(pFactory)   \
ULONG STDMETHODCALLTYPE CStdStubBuffer2_Release(IRpcStubBuffer *This) \
    {   \
    return NdrCStdStubBuffer2_Release(This,(IPSFactoryBuffer *)pFactory);   \
    }
#else
#define CSTDSTUBBUFFER2RELEASE(pFactory)
#endif //PROXY_DELEGATION


#ifdef REGISTER_PROXY_DLL
#define DLLREGISTRY_ROUTINES(pProxyFileList,pClsID ) REGISTER_PROXY_DLL_ROUTINES(pProxyFileList,pClsID )
#else
#define DLLREGISTRY_ROUTINES(pProxyFileList,pClsID )
#endif //REGISTER_PROXY_DLL


// the dll entry points that must be defined
#define DLLDATA_ROUTINES(pProxyFileList,pClsID )    \
    \
    CLSID_PSFACTORYBUFFER \
    \
    CStdPSFactoryBuffer       gPFactory = {0,0,0,0};  \
    \
    DLLDATA_GETPROXYDLLINFO(pProxyFileList,pClsID) \
    \
    DLLGETCLASSOBJECTROUTINE(pProxyFileList,pClsID,&gPFactory)    \
    \
    DLLCANUNLOADNOW(&gPFactory)   \
    \
    CSTDSTUBBUFFERRELEASE(&gPFactory)   \
    \
    CSTDSTUBBUFFER2RELEASE(&gPFactory) \
    \
    DLLDUMMYPURECALL    \
    \
    DLLREGISTRY_ROUTINES(pProxyFileList, pClsID) \
    \

    // more code goes here...


#define DLLDATA_STANDARD_ROUTINES   \
    DLLDATA_ROUTINES( (const ProxyFileInfo**) pProxyFileList, &CLSID_PSFactoryBuffer )  \

#if defined(__cplusplus)
} // extern "C"
#endif

#endif // WIN32 or _WIN64_

#if defined(_M_IA64) || defined(_M_AMD64)
#include <poppack.h>
#endif

#endif // __RPCPROXY_H__

#endif // _KRPCENV_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RrasCfg.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0221 */
/* at Fri Nov 20 18:57:15 1998
 */
/* Compiler settings for rrascfg.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rrascfg_h__
#define __rrascfg_h__

/* Forward Declarations */ 

#ifndef __IRouterProtocolConfig_FWD_DEFINED__
#define __IRouterProtocolConfig_FWD_DEFINED__
typedef interface IRouterProtocolConfig IRouterProtocolConfig;
#endif 	/* __IRouterProtocolConfig_FWD_DEFINED__ */


#ifndef __IAuthenticationProviderConfig_FWD_DEFINED__
#define __IAuthenticationProviderConfig_FWD_DEFINED__
typedef interface IAuthenticationProviderConfig IAuthenticationProviderConfig;
#endif 	/* __IAuthenticationProviderConfig_FWD_DEFINED__ */


#ifndef __IAccountingProviderConfig_FWD_DEFINED__
#define __IAccountingProviderConfig_FWD_DEFINED__
typedef interface IAccountingProviderConfig IAccountingProviderConfig;
#endif 	/* __IAccountingProviderConfig_FWD_DEFINED__ */


#ifndef __IEAPProviderConfig_FWD_DEFINED__
#define __IEAPProviderConfig_FWD_DEFINED__
typedef interface IEAPProviderConfig IEAPProviderConfig;
#endif 	/* __IEAPProviderConfig_FWD_DEFINED__ */


/* header files for imported files */
#include "basetsd.h"
#include "wtypes.h"
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_rrascfg_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// RRasCfg.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
 
typedef BYTE __RPC_FAR *PBYTE;



extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0000_v0_0_s_ifspec;

#ifndef __IRouterProtocolConfig_INTERFACE_DEFINED__
#define __IRouterProtocolConfig_INTERFACE_DEFINED__

/* interface IRouterProtocolConfig */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IRouterProtocolConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB16-D706-11D0-A37B-00C04FC9DA04")
    IRouterProtocolConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddProtocol( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwTransportId,
            /* [in] */ DWORD dwProtocolId,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *pRouter,
            /* [in] */ ULONG_PTR uReserved1) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProtocol( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwTransportId,
            /* [in] */ DWORD dwProtocolId,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *pRouter,
            /* [in] */ ULONG_PTR uReserved1) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRouterProtocolConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRouterProtocolConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRouterProtocolConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRouterProtocolConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddProtocol )( 
            IRouterProtocolConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwTransportId,
            /* [in] */ DWORD dwProtocolId,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *pRouter,
            /* [in] */ ULONG_PTR uReserved1);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveProtocol )( 
            IRouterProtocolConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwTransportId,
            /* [in] */ DWORD dwProtocolId,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *pRouter,
            /* [in] */ ULONG_PTR uReserved1);
        
        END_INTERFACE
    } IRouterProtocolConfigVtbl;

    interface IRouterProtocolConfig
    {
        CONST_VTBL struct IRouterProtocolConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRouterProtocolConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRouterProtocolConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRouterProtocolConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRouterProtocolConfig_AddProtocol(This,pszMachineName,dwTransportId,dwProtocolId,hWnd,dwFlags,pRouter,uReserved1)	\
    (This)->lpVtbl -> AddProtocol(This,pszMachineName,dwTransportId,dwProtocolId,hWnd,dwFlags,pRouter,uReserved1)

#define IRouterProtocolConfig_RemoveProtocol(This,pszMachineName,dwTransportId,dwProtocolId,hWnd,dwFlags,pRouter,uReserved1)	\
    (This)->lpVtbl -> RemoveProtocol(This,pszMachineName,dwTransportId,dwProtocolId,hWnd,dwFlags,pRouter,uReserved1)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRouterProtocolConfig_AddProtocol_Proxy( 
    IRouterProtocolConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [in] */ DWORD dwTransportId,
    /* [in] */ DWORD dwProtocolId,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IUnknown __RPC_FAR *pRouter,
    /* [in] */ ULONG_PTR uReserved1);


void __RPC_STUB IRouterProtocolConfig_AddProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRouterProtocolConfig_RemoveProtocol_Proxy( 
    IRouterProtocolConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [in] */ DWORD dwTransportId,
    /* [in] */ DWORD dwProtocolId,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IUnknown __RPC_FAR *pRouter,
    /* [in] */ ULONG_PTR uReserved1);


void __RPC_STUB IRouterProtocolConfig_RemoveProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRouterProtocolConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rrascfg_0011 */
/* [local] */ 

#define DeclareIRouterProtocolConfigMembers(IPURE) \
	STDMETHOD(AddProtocol)(THIS_ LPCOLESTR pszMachineName,\
					   DWORD dwTransportId,\
					   DWORD dwProtocolId,\
					   HWND hWnd,\
					   DWORD dwFlags,\
					   IUnknown *pRouter,\
					   ULONG_PTR uReserved1) IPURE;\
	STDMETHOD(RemoveProtocol)(THIS_ LPCOLESTR pszMachineName,\
						 DWORD dwTransportId,\
						 DWORD dwProtocolId,\
						 HWND hWnd,\
						 DWORD dwFlags,\
						 IUnknown *pRouter,\
						 ULONG_PTR uReserved2) IPURE;\
 


extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0011_v0_0_s_ifspec;

#ifndef __IAuthenticationProviderConfig_INTERFACE_DEFINED__
#define __IAuthenticationProviderConfig_INTERFACE_DEFINED__

/* interface IAuthenticationProviderConfig */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IAuthenticationProviderConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB17-D706-11D0-A37B-00C04FC9DA04")
    IAuthenticationProviderConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Uninitialize( 
            /* [in] */ ULONG_PTR uConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAuthenticationProviderConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAuthenticationProviderConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAuthenticationProviderConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Uninitialize )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Configure )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IAuthenticationProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        END_INTERFACE
    } IAuthenticationProviderConfigVtbl;

    interface IAuthenticationProviderConfig
    {
        CONST_VTBL struct IAuthenticationProviderConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAuthenticationProviderConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAuthenticationProviderConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAuthenticationProviderConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAuthenticationProviderConfig_Initialize(This,pszMachineName,puConnectionParam)	\
    (This)->lpVtbl -> Initialize(This,pszMachineName,puConnectionParam)

#define IAuthenticationProviderConfig_Uninitialize(This,uConnectionParam)	\
    (This)->lpVtbl -> Uninitialize(This,uConnectionParam)

#define IAuthenticationProviderConfig_Configure(This,uConnectionParam,hWnd,dwFlags,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Configure(This,uConnectionParam,hWnd,dwFlags,uReserved1,uReserved2)

#define IAuthenticationProviderConfig_Activate(This,uConnectionParam,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Activate(This,uConnectionParam,uReserved1,uReserved2)

#define IAuthenticationProviderConfig_Deactivate(This,uConnectionParam,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Deactivate(This,uConnectionParam,uReserved1,uReserved2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Initialize_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);


void __RPC_STUB IAuthenticationProviderConfig_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Uninitialize_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam);


void __RPC_STUB IAuthenticationProviderConfig_Uninitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Configure_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAuthenticationProviderConfig_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Activate_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAuthenticationProviderConfig_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAuthenticationProviderConfig_Deactivate_Proxy( 
    IAuthenticationProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAuthenticationProviderConfig_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAuthenticationProviderConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rrascfg_0013 */
/* [local] */ 

#define DeclareIAuthenticationProviderConfigMembers(IPURE) \
	STDMETHOD(Initialize)(THIS_ \
							LPCOLESTR pszMachineName, \
							ULONG_PTR *puConnectionParam) IPURE; \
	STDMETHOD(Uninitialize)(THIS_ \
							ULONG_PTR uConnectionParam) IPURE; \
	 \
	STDMETHOD(Configure)(THIS_ \
							ULONG_PTR uConnectionParam, \
							HWND hWnd, \
						  DWORD dwFlags, \
						  ULONG_PTR uReserved1, \
						  ULONG_PTR uReserved2) IPURE; \
 \
	STDMETHOD(Activate)(THIS_ \
						ULONG_PTR uConnectionParam, \
						 ULONG_PTR uReserved1, \
						 ULONG_PTR uReserved2) IPURE; \
 \
	STDMETHOD(Deactivate)(THIS_ \
						ULONG_PTR uConnectionParam, \
						   ULONG_PTR uReserved1, \
						   ULONG_PTR uReserved2) IPURE; \
 


extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0013_v0_0_s_ifspec;

#ifndef __IAccountingProviderConfig_INTERFACE_DEFINED__
#define __IAccountingProviderConfig_INTERFACE_DEFINED__

/* interface IAccountingProviderConfig */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IAccountingProviderConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB18-D706-11D0-A37B-00C04FC9DA04")
    IAccountingProviderConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Uninitialize( 
            /* [in] */ ULONG_PTR uConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( 
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAccountingProviderConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAccountingProviderConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAccountingProviderConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Uninitialize )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Configure )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IAccountingProviderConfig __RPC_FAR * This,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        END_INTERFACE
    } IAccountingProviderConfigVtbl;

    interface IAccountingProviderConfig
    {
        CONST_VTBL struct IAccountingProviderConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAccountingProviderConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAccountingProviderConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAccountingProviderConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAccountingProviderConfig_Initialize(This,pszMachineName,puConnectionParam)	\
    (This)->lpVtbl -> Initialize(This,pszMachineName,puConnectionParam)

#define IAccountingProviderConfig_Uninitialize(This,uConnectionParam)	\
    (This)->lpVtbl -> Uninitialize(This,uConnectionParam)

#define IAccountingProviderConfig_Configure(This,uConnectionParam,hWnd,dwFlags,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Configure(This,uConnectionParam,hWnd,dwFlags,uReserved1,uReserved2)

#define IAccountingProviderConfig_Activate(This,uConnectionParam,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Activate(This,uConnectionParam,uReserved1,uReserved2)

#define IAccountingProviderConfig_Deactivate(This,uConnectionParam,uReserved1,uReserved2)	\
    (This)->lpVtbl -> Deactivate(This,uConnectionParam,uReserved1,uReserved2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Initialize_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);


void __RPC_STUB IAccountingProviderConfig_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Uninitialize_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam);


void __RPC_STUB IAccountingProviderConfig_Uninitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Configure_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAccountingProviderConfig_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Activate_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAccountingProviderConfig_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAccountingProviderConfig_Deactivate_Proxy( 
    IAccountingProviderConfig __RPC_FAR * This,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IAccountingProviderConfig_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAccountingProviderConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rrascfg_0015 */
/* [local] */ 

#define DeclareIAccountingProviderConfigMembers(IPURE) \
	STDMETHOD(Initialize)(THIS_ \
							LPCOLESTR pszMachineName, \
							ULONG_PTR *puConnectionParam) IPURE; \
	STDMETHOD(Uninitialize)(THIS_ \
							ULONG_PTR uConnectionParam) IPURE; \
	STDMETHOD(Configure)(THIS_ \
						ULONG_PTR uConnectionParam, \
						HWND hWnd, \
						  DWORD dwFlags, \
						  ULONG_PTR uReserved1, \
						  ULONG_PTR uReserved2) IPURE; \
 \
	STDMETHOD(Activate)(THIS_ \
						ULONG_PTR uConnectionParam, \
						 ULONG_PTR uReserved1, \
						 ULONG_PTR uReserved2) IPURE; \
 \
	STDMETHOD(Deactivate)(THIS_ \
						ULONG_PTR uConnectionParam, \
						   ULONG_PTR uReserved1, \
						   ULONG_PTR uReserved2) IPURE; \
 


extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0015_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0015_v0_0_s_ifspec;

#ifndef __IEAPProviderConfig_INTERFACE_DEFINED__
#define __IEAPProviderConfig_INTERFACE_DEFINED__

/* interface IEAPProviderConfig */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IEAPProviderConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB19-D706-11D0-A37B-00C04FC9DA04")
    IEAPProviderConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwEapTypeId,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Uninitialize( 
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ServerInvokeConfigUI( 
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RouterInvokeConfigUI( 
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
            /* [in] */ DWORD dwSizeOfConnectionDataIn,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppConnectionDataOut,
            /* [out] */ DWORD __RPC_FAR *pdwSizeOfConnectionDataOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RouterInvokeCredentialsUI( 
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
            /* [in] */ DWORD dwSizeOfConnectionDataIn,
            /* [size_is][in] */ BYTE __RPC_FAR *pUserDataIn,
            /* [in] */ DWORD dwSizeOfUserDataIn,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppUserDataOut,
            /* [out] */ DWORD __RPC_FAR *pdwSizeOfUserDataOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEAPProviderConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEAPProviderConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEAPProviderConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszMachineName,
            /* [in] */ DWORD dwEapTypeId,
            /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Uninitialize )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ServerInvokeConfigUI )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hWnd,
            /* [in] */ ULONG_PTR uReserved1,
            /* [in] */ ULONG_PTR uReserved2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RouterInvokeConfigUI )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
            /* [in] */ DWORD dwSizeOfConnectionDataIn,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppConnectionDataOut,
            /* [out] */ DWORD __RPC_FAR *pdwSizeOfConnectionDataOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RouterInvokeCredentialsUI )( 
            IEAPProviderConfig __RPC_FAR * This,
            /* [in] */ DWORD dwEapTypeId,
            /* [in] */ ULONG_PTR uConnectionParam,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags,
            /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
            /* [in] */ DWORD dwSizeOfConnectionDataIn,
            /* [size_is][in] */ BYTE __RPC_FAR *pUserDataIn,
            /* [in] */ DWORD dwSizeOfUserDataIn,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppUserDataOut,
            /* [out] */ DWORD __RPC_FAR *pdwSizeOfUserDataOut);
        
        END_INTERFACE
    } IEAPProviderConfigVtbl;

    interface IEAPProviderConfig
    {
        CONST_VTBL struct IEAPProviderConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEAPProviderConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEAPProviderConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEAPProviderConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEAPProviderConfig_Initialize(This,pszMachineName,dwEapTypeId,puConnectionParam)	\
    (This)->lpVtbl -> Initialize(This,pszMachineName,dwEapTypeId,puConnectionParam)

#define IEAPProviderConfig_Uninitialize(This,dwEapTypeId,uConnectionParam)	\
    (This)->lpVtbl -> Uninitialize(This,dwEapTypeId,uConnectionParam)

#define IEAPProviderConfig_ServerInvokeConfigUI(This,dwEapTypeId,uConnectionParam,hWnd,uReserved1,uReserved2)	\
    (This)->lpVtbl -> ServerInvokeConfigUI(This,dwEapTypeId,uConnectionParam,hWnd,uReserved1,uReserved2)

#define IEAPProviderConfig_RouterInvokeConfigUI(This,dwEapTypeId,uConnectionParam,hwndParent,dwFlags,pConnectionDataIn,dwSizeOfConnectionDataIn,ppConnectionDataOut,pdwSizeOfConnectionDataOut)	\
    (This)->lpVtbl -> RouterInvokeConfigUI(This,dwEapTypeId,uConnectionParam,hwndParent,dwFlags,pConnectionDataIn,dwSizeOfConnectionDataIn,ppConnectionDataOut,pdwSizeOfConnectionDataOut)

#define IEAPProviderConfig_RouterInvokeCredentialsUI(This,dwEapTypeId,uConnectionParam,hwndParent,dwFlags,pConnectionDataIn,dwSizeOfConnectionDataIn,pUserDataIn,dwSizeOfUserDataIn,ppUserDataOut,pdwSizeOfUserDataOut)	\
    (This)->lpVtbl -> RouterInvokeCredentialsUI(This,dwEapTypeId,uConnectionParam,hwndParent,dwFlags,pConnectionDataIn,dwSizeOfConnectionDataIn,pUserDataIn,dwSizeOfUserDataIn,ppUserDataOut,pdwSizeOfUserDataOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEAPProviderConfig_Initialize_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszMachineName,
    /* [in] */ DWORD dwEapTypeId,
    /* [out] */ ULONG_PTR __RPC_FAR *puConnectionParam);


void __RPC_STUB IEAPProviderConfig_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEAPProviderConfig_Uninitialize_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwEapTypeId,
    /* [in] */ ULONG_PTR uConnectionParam);


void __RPC_STUB IEAPProviderConfig_Uninitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEAPProviderConfig_ServerInvokeConfigUI_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwEapTypeId,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ HWND hWnd,
    /* [in] */ ULONG_PTR uReserved1,
    /* [in] */ ULONG_PTR uReserved2);


void __RPC_STUB IEAPProviderConfig_ServerInvokeConfigUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEAPProviderConfig_RouterInvokeConfigUI_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwEapTypeId,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ HWND hwndParent,
    /* [in] */ DWORD dwFlags,
    /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
    /* [in] */ DWORD dwSizeOfConnectionDataIn,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppConnectionDataOut,
    /* [out] */ DWORD __RPC_FAR *pdwSizeOfConnectionDataOut);


void __RPC_STUB IEAPProviderConfig_RouterInvokeConfigUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEAPProviderConfig_RouterInvokeCredentialsUI_Proxy( 
    IEAPProviderConfig __RPC_FAR * This,
    /* [in] */ DWORD dwEapTypeId,
    /* [in] */ ULONG_PTR uConnectionParam,
    /* [in] */ HWND hwndParent,
    /* [in] */ DWORD dwFlags,
    /* [size_is][in] */ BYTE __RPC_FAR *pConnectionDataIn,
    /* [in] */ DWORD dwSizeOfConnectionDataIn,
    /* [size_is][in] */ BYTE __RPC_FAR *pUserDataIn,
    /* [in] */ DWORD dwSizeOfUserDataIn,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppUserDataOut,
    /* [out] */ DWORD __RPC_FAR *pdwSizeOfUserDataOut);


void __RPC_STUB IEAPProviderConfig_RouterInvokeCredentialsUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEAPProviderConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rrascfg_0017 */
/* [local] */ 

#define DeclareIEAPProviderConfigMembers(IPURE) \
	STDMETHOD(Initialize)(THIS_ \
		LPCOLESTR 	pszMachineName, \
 	DWORD       dwEapTypeId, \
		ULONG_PTR*	puConnectionParam) IPURE; \
	STDMETHOD(Uninitialize)(THIS_ \
 	DWORD       dwEapTypeId, \
		ULONG_PTR 	uConnectionParam) IPURE; \
	STDMETHOD(ServerInvokeConfigUI)(THIS_ \
 	DWORD       dwEapTypeId, \
		ULONG_PTR 	uConnectionParam, \
		HWND 		hWnd, \
		ULONG_PTR 	dwRes1, \
		ULONG_PTR 	dwRes2) IPURE; \
 STDMETHOD(RouterInvokeConfigUI)(THIS_ \
 	DWORD       dwEapTypeId, \
		ULONG_PTR 	uConnectionParam, \
 	HWND        hwndParent, \
 	DWORD       dwFlags, \
 	BYTE* 		pConnectionDataIn, \
 	DWORD		dwSizeOfConnectionDataIn, \
 	BYTE**		ppConnectionDataOut, \
 	DWORD*		pdwSizeOfConnectionDataOut) IPURE; \
 STDMETHOD(RouterInvokeCredentialsUI)(THIS_  \
 	DWORD   	dwEapTypeId, \
		ULONG_PTR 	uConnectionParam, \
 	HWND    	hwndParent, \
 	DWORD   	dwFlags, \
 	BYTE*   	pConnectionDataIn, \
 	DWORD   	dwSizeOfConnectionDataIn, \
 	BYTE*   	pUserDataIn, \
 	DWORD   	dwSizeOfUserDataIn, \
 	BYTE**  	ppUserDataOut, \
 	DWORD*  	pdwSizeOfUserDataOut) IPURE; \
 


extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0017_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rrascfg_0017_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\rtcerr.h ===
/*****************************************************************************
*
* Copyright (c) Microsoft Corporation.  All rights reserved.
*
* Module Name:
*
*    rtcerr.mc
*
* Abstract:
*
*    Error Messages for RTC Core API
*
*****************************************************************************/
// Possible error codes from SIP interfaces
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SIP_STATUS_CODE         0xEF
#define FACILITY_RTC_INTERFACE           0xEE
#define FACILITY_PINT_STATUS_CODE        0xF0


//
// Define the severity codes
//
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_RTC_ERROR        0x2


//
// MessageId: RTC_E_SIP_CODECS_DO_NOT_MATCH
//
// MessageText:
//
// No matching codecs with peer
//
#define RTC_E_SIP_CODECS_DO_NOT_MATCH    ((HRESULT)0x80EE0000L)

//
// MessageId: RTC_E_SIP_STREAM_PRESENT
//
// MessageText:
//
// Parsing SIP failed
// The stream to be started is already present
//
#define RTC_E_SIP_STREAM_PRESENT         ((HRESULT)0x80EE0001L)

//
// MessageId: RTC_E_SIP_STREAM_NOT_PRESENT
//
// MessageText:
//
// The stream to be stopped is not present
//
#define RTC_E_SIP_STREAM_NOT_PRESENT     ((HRESULT)0x80EE0002L)

//
// MessageId: RTC_E_SIP_NO_STREAM
//
// MessageText:
//
// No stream is active
//
#define RTC_E_SIP_NO_STREAM              ((HRESULT)0x80EE0003L)

//
// MessageId: RTC_E_SIP_PARSE_FAILED
//
// MessageText:
//
// Parsing SIP failed
//
#define RTC_E_SIP_PARSE_FAILED           ((HRESULT)0x80EE0004L)

//
// MessageId: RTC_E_SIP_HEADER_NOT_PRESENT
//
// MessageText:
//
// The SIP header is not present in the message
//
#define RTC_E_SIP_HEADER_NOT_PRESENT     ((HRESULT)0x80EE0005L)

//
// MessageId: RTC_E_SDP_NOT_PRESENT
//
// MessageText:
//
// SDP is not present in the SIP message
//
#define RTC_E_SDP_NOT_PRESENT            ((HRESULT)0x80EE0006L)

//
// MessageId: RTC_E_SDP_PARSE_FAILED
//
// MessageText:
//
// Parsing SDP failed
//
#define RTC_E_SDP_PARSE_FAILED           ((HRESULT)0x80EE0007L)

//
// MessageId: RTC_E_SDP_UPDATE_FAILED
//
// MessageText:
//
// SDP does not match the previous one
//
#define RTC_E_SDP_UPDATE_FAILED          ((HRESULT)0x80EE0008L)

//
// MessageId: RTC_E_SDP_MULTICAST
//
// MessageText:
//
// Multicast is not supported
//
#define RTC_E_SDP_MULTICAST              ((HRESULT)0x80EE0009L)

//
// MessageId: RTC_E_SDP_CONNECTION_ADDR
//
// MessageText:
//
// Media does not contain connection address
//
#define RTC_E_SDP_CONNECTION_ADDR        ((HRESULT)0x80EE000AL)

//
// MessageId: RTC_E_SDP_NO_MEDIA
//
// MessageText:
//
// No media is available for the session
//
#define RTC_E_SDP_NO_MEDIA               ((HRESULT)0x80EE000BL)

//
// MessageId: RTC_E_SIP_TIMEOUT
//
// MessageText:
//
// SIP Transaction timed out
//
#define RTC_E_SIP_TIMEOUT                ((HRESULT)0x80EE000CL)

//
// MessageId: RTC_E_SDP_FAILED_TO_BUILD
//
// MessageText:
//
// Failed to build SDP blob
//
#define RTC_E_SDP_FAILED_TO_BUILD        ((HRESULT)0x80EE000DL)

//
// MessageId: RTC_E_SIP_INVITE_TRANSACTION_PENDING
//
// MessageText:
//
// Currently processing another INVITE transaction
//
#define RTC_E_SIP_INVITE_TRANSACTION_PENDING ((HRESULT)0x80EE000EL)

//
// MessageId: RTC_E_SIP_AUTH_HEADER_SENT
//
// MessageText:
//
// Authorization header was sent in a previous request
//
#define RTC_E_SIP_AUTH_HEADER_SENT       ((HRESULT)0x80EE000FL)

//
// MessageId: RTC_E_SIP_AUTH_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// The Authentication type requested is not supported
//
#define RTC_E_SIP_AUTH_TYPE_NOT_SUPPORTED ((HRESULT)0x80EE0010L)

//
// MessageId: RTC_E_SIP_AUTH_FAILED
//
// MessageText:
//
// Authentication Failed
//
#define RTC_E_SIP_AUTH_FAILED            ((HRESULT)0x80EE0011L)

//
// MessageId: RTC_E_INVALID_SIP_URL
//
// MessageText:
//
// The SIP URL is not valid
//
#define RTC_E_INVALID_SIP_URL            ((HRESULT)0x80EE0012L)

//
// MessageId: RTC_E_DESTINATION_ADDRESS_LOCAL
//
// MessageText:
//
// The Destination Address belongs to the local machine
//
#define RTC_E_DESTINATION_ADDRESS_LOCAL  ((HRESULT)0x80EE0013L)

//
// MessageId: RTC_E_INVALID_ADDRESS_LOCAL
//
// MessageText:
//
// The Local Address is invalid, check the profile
//
#define RTC_E_INVALID_ADDRESS_LOCAL      ((HRESULT)0x80EE0014L)

//
// MessageId: RTC_E_DESTINATION_ADDRESS_MULTICAST
//
// MessageText:
//
// The Destination Address is a multicast address
//
#define RTC_E_DESTINATION_ADDRESS_MULTICAST ((HRESULT)0x80EE0015L)

//
// MessageId: RTC_E_INVALID_PROXY_ADDRESS
//
// MessageText:
//
// The Proxy Address is not valid
//
#define RTC_E_INVALID_PROXY_ADDRESS      ((HRESULT)0x80EE0016L)

//
// MessageId: RTC_E_SIP_TRANSPORT_NOT_SUPPORTED
//
// MessageText:
//
// The Transport specified is not supported
//
#define RTC_E_SIP_TRANSPORT_NOT_SUPPORTED ((HRESULT)0x80EE0017L)

// SIP internal error codes
//
// MessageId: RTC_E_SIP_NEED_MORE_DATA
//
// MessageText:
//
// Need more data for parsing a whole SIP message
//
#define RTC_E_SIP_NEED_MORE_DATA         ((HRESULT)0x80EE0018L)

//
// MessageId: RTC_E_SIP_CALL_DISCONNECTED
//
// MessageText:
//
// The Call has been disconnected
//
#define RTC_E_SIP_CALL_DISCONNECTED      ((HRESULT)0x80EE0019L)

//
// MessageId: RTC_E_SIP_REQUEST_DESTINATION_ADDR_NOT_PRESENT
//
// MessageText:
//
// The Request destination address is not known
//
#define RTC_E_SIP_REQUEST_DESTINATION_ADDR_NOT_PRESENT ((HRESULT)0x80EE001AL)

//
// MessageId: RTC_E_SIP_UDP_SIZE_EXCEEDED
//
// MessageText:
//
// The sip message size is greater than the UDP message size allowed
//
#define RTC_E_SIP_UDP_SIZE_EXCEEDED      ((HRESULT)0x80EE001BL)

//
// MessageId: RTC_E_SIP_SSL_TUNNEL_FAILED
//
// MessageText:
//
// Cannot establish SSL tunnel to Http proxy
//
#define RTC_E_SIP_SSL_TUNNEL_FAILED      ((HRESULT)0x80EE001CL)

//
// MessageId: RTC_E_SIP_SSL_NEGOTIATION_TIMEOUT
//
// MessageText:
//
// Timeout during SSL Negotiation
//
#define RTC_E_SIP_SSL_NEGOTIATION_TIMEOUT ((HRESULT)0x80EE001DL)

//
// MessageId: RTC_E_SIP_STACK_SHUTDOWN
//
// MessageText:
//
// Sip Stack is already shutdown
//
#define RTC_E_SIP_STACK_SHUTDOWN         ((HRESULT)0x80EE001EL)

// media error codes
//
// MessageId: RTC_E_MEDIA_CONTROLLER_STATE
//
// MessageText:
//
// Operation not allowed in current media controller state
//
#define RTC_E_MEDIA_CONTROLLER_STATE     ((HRESULT)0x80EE001FL)

//
// MessageId: RTC_E_MEDIA_NEED_TERMINAL
//
// MessageText:
//
// Can not find device
//
#define RTC_E_MEDIA_NEED_TERMINAL        ((HRESULT)0x80EE0020L)

//
// MessageId: RTC_E_MEDIA_AUDIO_DEVICE_NOT_AVAILABLE
//
// MessageText:
//
// Audio device is not available
//
#define RTC_E_MEDIA_AUDIO_DEVICE_NOT_AVAILABLE ((HRESULT)0x80EE0021L)

//
// MessageId: RTC_E_MEDIA_VIDEO_DEVICE_NOT_AVAILABLE
//
// MessageText:
//
// Video device is not available
//
#define RTC_E_MEDIA_VIDEO_DEVICE_NOT_AVAILABLE ((HRESULT)0x80EE0022L)

//
// MessageId: RTC_E_START_STREAM
//
// MessageText:
//
// Can not start stream
//
#define RTC_E_START_STREAM               ((HRESULT)0x80EE0023L)

//
// MessageId: RTC_E_MEDIA_AEC
//
// MessageText:
//
// Failed to enable acoustic echo cancellation
//
#define RTC_E_MEDIA_AEC                  ((HRESULT)0x80EE0024L)

// Core error codes
//
// MessageId: RTC_E_CLIENT_NOT_INITIALIZED
//
// MessageText:
//
// Client not initialized
//
#define RTC_E_CLIENT_NOT_INITIALIZED     ((HRESULT)0x80EE0025L)

//
// MessageId: RTC_E_CLIENT_ALREADY_INITIALIZED
//
// MessageText:
//
// Client already initialized
//
#define RTC_E_CLIENT_ALREADY_INITIALIZED ((HRESULT)0x80EE0026L)

//
// MessageId: RTC_E_CLIENT_ALREADY_SHUT_DOWN
//
// MessageText:
//
// Client already shut down
//
#define RTC_E_CLIENT_ALREADY_SHUT_DOWN   ((HRESULT)0x80EE0027L)

//
// MessageId: RTC_E_PRESENCE_NOT_ENABLED
//
// MessageText:
//
// Presence not enabled
//
#define RTC_E_PRESENCE_NOT_ENABLED       ((HRESULT)0x80EE0028L)

//
// MessageId: RTC_E_INVALID_SESSION_TYPE
//
// MessageText:
//
// Invalid session type
//
#define RTC_E_INVALID_SESSION_TYPE       ((HRESULT)0x80EE0029L)

//
// MessageId: RTC_E_INVALID_SESSION_STATE
//
// MessageText:
//
// Invalid session state
//
#define RTC_E_INVALID_SESSION_STATE      ((HRESULT)0x80EE002AL)

//
// MessageId: RTC_E_NO_PROFILE
//
// MessageText:
//
// No valid profile for this operation
//
#define RTC_E_NO_PROFILE                 ((HRESULT)0x80EE002BL)

//
// MessageId: RTC_E_LOCAL_PHONE_NEEDED
//
// MessageText:
//
// A local phone number is needed
//
#define RTC_E_LOCAL_PHONE_NEEDED         ((HRESULT)0x80EE002CL)

//
// MessageId: RTC_E_NO_DEVICE
//
// MessageText:
//
// No preferred device
//
#define RTC_E_NO_DEVICE                  ((HRESULT)0x80EE002DL)

//
// MessageId: RTC_E_INVALID_PROFILE
//
// MessageText:
//
// Invalid profile
//
#define RTC_E_INVALID_PROFILE            ((HRESULT)0x80EE002EL)

//
// MessageId: RTC_E_PROFILE_NO_PROVISION
//
// MessageText:
//
// No provision tag in profile
//
#define RTC_E_PROFILE_NO_PROVISION       ((HRESULT)0x80EE002FL)

//
// MessageId: RTC_E_PROFILE_NO_KEY
//
// MessageText:
//
// No profile key
//
#define RTC_E_PROFILE_NO_KEY             ((HRESULT)0x80EE0030L)

//
// MessageId: RTC_E_PROFILE_NO_NAME
//
// MessageText:
//
// No profile name
//
#define RTC_E_PROFILE_NO_NAME            ((HRESULT)0x80EE0031L)

//
// MessageId: RTC_E_PROFILE_NO_USER
//
// MessageText:
//
// No user tag in profile
//
#define RTC_E_PROFILE_NO_USER            ((HRESULT)0x80EE0032L)

//
// MessageId: RTC_E_PROFILE_NO_USER_URI
//
// MessageText:
//
// No user URI in profile
//
#define RTC_E_PROFILE_NO_USER_URI        ((HRESULT)0x80EE0033L)

//
// MessageId: RTC_E_PROFILE_NO_SERVER
//
// MessageText:
//
// No server tag in profile
//
#define RTC_E_PROFILE_NO_SERVER          ((HRESULT)0x80EE0034L)

//
// MessageId: RTC_E_PROFILE_NO_SERVER_ADDRESS
//
// MessageText:
//
// Server tag missing address in profile
//
#define RTC_E_PROFILE_NO_SERVER_ADDRESS  ((HRESULT)0x80EE0035L)

//
// MessageId: RTC_E_PROFILE_NO_SERVER_PROTOCOL
//
// MessageText:
//
// Server tag missing protocol in profile
//
#define RTC_E_PROFILE_NO_SERVER_PROTOCOL ((HRESULT)0x80EE0036L)

//
// MessageId: RTC_E_PROFILE_INVALID_SERVER_PROTOCOL
//
// MessageText:
//
// Invalid server protocol in profile
//
#define RTC_E_PROFILE_INVALID_SERVER_PROTOCOL ((HRESULT)0x80EE0037L)

//
// MessageId: RTC_E_PROFILE_INVALID_SERVER_AUTHMETHOD
//
// MessageText:
//
// Invalid server authentication method in profile
//
#define RTC_E_PROFILE_INVALID_SERVER_AUTHMETHOD ((HRESULT)0x80EE0038L)

//
// MessageId: RTC_E_PROFILE_INVALID_SERVER_ROLE
//
// MessageText:
//
// Invalid server role in profile
//
#define RTC_E_PROFILE_INVALID_SERVER_ROLE ((HRESULT)0x80EE0039L)

//
// MessageId: RTC_E_PROFILE_MULTIPLE_REGISTRARS
//
// MessageText:
//
// Multiple registrar servers in profile
//
#define RTC_E_PROFILE_MULTIPLE_REGISTRARS ((HRESULT)0x80EE003AL)

//
// MessageId: RTC_E_PROFILE_INVALID_SESSION
//
// MessageText:
//
// Invalid session tag in profile
//
#define RTC_E_PROFILE_INVALID_SESSION    ((HRESULT)0x80EE003BL)

//
// MessageId: RTC_E_PROFILE_INVALID_SESSION_PARTY
//
// MessageText:
//
// Invalid session party in profile
//
#define RTC_E_PROFILE_INVALID_SESSION_PARTY ((HRESULT)0x80EE003CL)

//
// MessageId: RTC_E_PROFILE_INVALID_SESSION_TYPE
//
// MessageText:
//
// Invalid session type in profile
//
#define RTC_E_PROFILE_INVALID_SESSION_TYPE ((HRESULT)0x80EE003DL)

//
// MessageId: RTC_E_OPERATION_WITH_TOO_MANY_PARTICIPANTS
//
// MessageText:
//
// The operation failed because of too many participants in the session
//
#define RTC_E_OPERATION_WITH_TOO_MANY_PARTICIPANTS ((HRESULT)0x80EE003EL)

//
// MessageId: RTC_E_BASIC_AUTH_SET_TLS
//
// MessageText:
//
// Must set transport to TLS if Basic Auth is allowed
//
#define RTC_E_BASIC_AUTH_SET_TLS         ((HRESULT)0x80EE003FL)

//
// MessageId: RTC_E_SIP_HIGH_SECURITY_SET_TLS
//
// MessageText:
//
// Must set transport to TLS if high security mode is needed
//
#define RTC_E_SIP_HIGH_SECURITY_SET_TLS  ((HRESULT)0x80EE0040L)

//
// MessageId: RTC_S_ROAMING_NOT_SUPPORTED
//
// MessageText:
//
// Server does not support this type of roaming
//
#define RTC_S_ROAMING_NOT_SUPPORTED      ((HRESULT)0x00EE0041L)

//
// MessageId: RTC_E_PROFILE_SERVER_UNAUTHORIZED
//
// MessageText:
//
// Server address does not match an authorized domain in profile
//
#define RTC_E_PROFILE_SERVER_UNAUTHORIZED ((HRESULT)0x80EE0042L)

//
// MessageId: RTC_E_DUPLICATE_REALM
//
// MessageText:
//
// Duplicate realm exists in an enabled profile
//
#define RTC_E_DUPLICATE_REALM            ((HRESULT)0x80EE0043L)

//
// MessageId: RTC_E_POLICY_NOT_ALLOW
//
// MessageText:
//
// Current policy settings do not allow this action
//
#define RTC_E_POLICY_NOT_ALLOW           ((HRESULT)0x80EE0044L)

//
// MessageId: RTC_E_PORT_MAPPING_UNAVAILABLE
//
// MessageText:
//
// Port mapping can not be obtained from the port manager
//
#define RTC_E_PORT_MAPPING_UNAVAILABLE   ((HRESULT)0x80EE0045L)

//
// MessageId: RTC_E_PORT_MAPPING_FAILED
//
// MessageText:
//
// Port mapping failure returned from the port manager
//
#define RTC_E_PORT_MAPPING_FAILED        ((HRESULT)0x80EE0046L)

//
// MessageId: RTC_E_SECURITY_LEVEL_NOT_COMPATIBLE
//
// MessageText:
//
// The local and remote security levels are not compatible.
//
#define RTC_E_SECURITY_LEVEL_NOT_COMPATIBLE ((HRESULT)0x80EE0047L)

//
// MessageId: RTC_E_SECURITY_LEVEL_NOT_DEFINED
//
// MessageText:
//
// The security level is not defined
//
#define RTC_E_SECURITY_LEVEL_NOT_DEFINED ((HRESULT)0x80EE0048L)

//
// MessageId: RTC_E_SECURITY_LEVEL_NOT_SUPPORTED_BY_PARTICIPANT
//
// MessageText:
//
// Participant could not support the requested security level
//
#define RTC_E_SECURITY_LEVEL_NOT_SUPPORTED_BY_PARTICIPANT ((HRESULT)0x80EE0049L)

//
// MessageId: RTC_E_DUPLICATE_BUDDY
//
// MessageText:
//
// Buddy already exists
//
#define RTC_E_DUPLICATE_BUDDY            ((HRESULT)0x80EE004AL)

//
// MessageId: RTC_E_DUPLICATE_WATCHER
//
// MessageText:
//
// Watcher already exists
//
#define RTC_E_DUPLICATE_WATCHER          ((HRESULT)0x80EE004BL)

//
// MessageId: RTC_E_MALFORMED_XML
//
// MessageText:
//
// Malformed XML
//
#define RTC_E_MALFORMED_XML              ((HRESULT)0x80EE004CL)

//
// MessageId: RTC_E_ROAMING_OPERATION_INTERRUPTED
//
// MessageText:
//
// Roaming operation interrupted. It may succeed or fail.
//
#define RTC_E_ROAMING_OPERATION_INTERRUPTED ((HRESULT)0x80EE004DL)

//
// MessageId: RTC_E_ROAMING_FAILED
//
// MessageText:
//
// Roaming session failed
//
#define RTC_E_ROAMING_FAILED             ((HRESULT)0x80EE004EL)

//
// MessageId: RTC_E_INVALID_BUDDY_LIST
//
// MessageText:
//
// Buddy list is invalid
//
#define RTC_E_INVALID_BUDDY_LIST         ((HRESULT)0x80EE004FL)

//
// MessageId: RTC_E_INVALID_ACL_LIST
//
// MessageText:
//
// ACL list is invalid
//
#define RTC_E_INVALID_ACL_LIST           ((HRESULT)0x80EE0050L)

//
// MessageId: RTC_E_NO_GROUP
//
// MessageText:
//
// Group does not exist
//
#define RTC_E_NO_GROUP                   ((HRESULT)0x80EE0051L)

//
// MessageId: RTC_E_DUPLICATE_GROUP
//
// MessageText:
//
// Group already exists
//
#define RTC_E_DUPLICATE_GROUP            ((HRESULT)0x80EE0052L)

//
// MessageId: RTC_E_TOO_MANY_GROUPS
//
// MessageText:
//
// Max number of groups has been reached
//
#define RTC_E_TOO_MANY_GROUPS            ((HRESULT)0x80EE0053L)

//
// MessageId: RTC_E_NO_BUDDY
//
// MessageText:
//
// Buddy does not exist
//
#define RTC_E_NO_BUDDY                   ((HRESULT)0x80EE0054L)

//
// MessageId: RTC_E_NO_WATCHER
//
// MessageText:
//
// Watcher does not exist
//
#define RTC_E_NO_WATCHER                 ((HRESULT)0x80EE0055L)

//
// MessageId: RTC_E_NO_REALM
//
// MessageText:
//
// No realm is set
//
#define RTC_E_NO_REALM                   ((HRESULT)0x80EE0056L)

//
// MessageId: RTC_E_NO_TRANSPORT
//
// MessageText:
//
// Server can not be specified without a transport protocol
//
#define RTC_E_NO_TRANSPORT               ((HRESULT)0x80EE0057L)

//
// MessageId: RTC_E_NOT_EXIST
//
// MessageText:
//
// The required item does not exist
//
#define RTC_E_NOT_EXIST                  ((HRESULT)0x80EE0058L)

//
// MessageId: RTC_E_INVALID_PREFERENCE_LIST
//
// MessageText:
//
// Preference list is invalid
//
#define RTC_E_INVALID_PREFERENCE_LIST    ((HRESULT)0x80EE0059L)

//
// MessageId: RTC_E_MAX_PENDING_OPERATIONS
//
// MessageText:
//
// Maximum number of pending operations reached
//
#define RTC_E_MAX_PENDING_OPERATIONS     ((HRESULT)0x80EE005AL)

//
// MessageId: RTC_E_TOO_MANY_RETRIES
//
// MessageText:
//
// Too many attempts to resend a request
//
#define RTC_E_TOO_MANY_RETRIES           ((HRESULT)0x80EE005BL)

//
// MessageId: RTC_E_INVALID_PORTRANGE
//
// MessageText:
//
// Invalid port range
//
#define RTC_E_INVALID_PORTRANGE          ((HRESULT)0x80EE005CL)

//
// MessageId: RTC_E_SIP_CALL_CONNECTION_NOT_ESTABLISHED
//
// MessageText:
//
// Call connection has not been established
//
#define RTC_E_SIP_CALL_CONNECTION_NOT_ESTABLISHED ((HRESULT)0x80EE005DL)

//
// MessageId: RTC_E_SIP_ADDITIONAL_PARTY_IN_TWO_PARTY_SESSION
//
// MessageText:
//
// Adding additional parties to two party session failed
//
#define RTC_E_SIP_ADDITIONAL_PARTY_IN_TWO_PARTY_SESSION ((HRESULT)0x80EE005EL)

//
// MessageId: RTC_E_SIP_PARTY_ALREADY_IN_SESSION
//
// MessageText:
//
// Party already exists in session
//
#define RTC_E_SIP_PARTY_ALREADY_IN_SESSION ((HRESULT)0x80EE005FL)

//
// MessageId: RTC_E_SIP_OTHER_PARTY_JOIN_IN_PROGRESS
//
// MessageText:
//
// Join operation is in progress for another party
//
#define RTC_E_SIP_OTHER_PARTY_JOIN_IN_PROGRESS ((HRESULT)0x80EE0060L)

//
// MessageId: RTC_E_INVALID_OBJECT_STATE
//
// MessageText:
//
// Object state does not allow to perform this operation
//
#define RTC_E_INVALID_OBJECT_STATE       ((HRESULT)0x80EE0061L)

//
// MessageId: RTC_E_PRESENCE_ENABLED
//
// MessageText:
//
// Presence is enabled
//
#define RTC_E_PRESENCE_ENABLED           ((HRESULT)0x80EE0062L)

//
// MessageId: RTC_E_ROAMING_ENABLED
//
// MessageText:
//
// Roaming is enabled
//
#define RTC_E_ROAMING_ENABLED            ((HRESULT)0x80EE0063L)

//
// MessageId: RTC_E_SIP_TLS_INCOMPATIBLE_ENCRYPTION
//
// MessageText:
//
// Incompatible TLS encryption
//
#define RTC_E_SIP_TLS_INCOMPATIBLE_ENCRYPTION ((HRESULT)0x80EE0064L)

//
// MessageId: RTC_E_SIP_INVALID_CERTIFICATE
//
// MessageText:
//
// Invalid certificate
//
#define RTC_E_SIP_INVALID_CERTIFICATE    ((HRESULT)0x80EE0065L)

//
// MessageId: RTC_E_SIP_DNS_FAIL
//
// MessageText:
//
// DNS lookup fails
//
#define RTC_E_SIP_DNS_FAIL               ((HRESULT)0x80EE0066L)

//
// MessageId: RTC_E_SIP_TCP_FAIL
//
// MessageText:
//
// Fails to make a TCP connection
//
#define RTC_E_SIP_TCP_FAIL               ((HRESULT)0x80EE0067L)

//
// MessageId: RTC_E_TOO_SMALL_EXPIRES_VALUE
//
// MessageText:
//
// Expires value received from the server is too small
//
#define RTC_E_TOO_SMALL_EXPIRES_VALUE    ((HRESULT)0x80EE0068L)

//
// MessageId: RTC_E_SIP_TLS_FAIL
//
// MessageText:
//
// Fails to make a TLS connection
//
#define RTC_E_SIP_TLS_FAIL               ((HRESULT)0x80EE0069L)

//
// MessageId: RTC_E_NOT_PRESENCE_PROFILE
//
// MessageText:
//
// A presence profile must be used
//
#define RTC_E_NOT_PRESENCE_PROFILE       ((HRESULT)0x80EE006AL)

//
// MessageId: RTC_E_SIP_INVITEE_PARTY_TIMEOUT
//
// MessageText:
//
// Invitee connection fails
//
#define RTC_E_SIP_INVITEE_PARTY_TIMEOUT  ((HRESULT)0x80EE006BL)

//
// MessageId: RTC_E_SIP_AUTH_TIME_SKEW
//
// MessageText:
//
// Authentication failure because of time skew between client and server
//
#define RTC_E_SIP_AUTH_TIME_SKEW         ((HRESULT)0x80EE006CL)

//
// MessageId: RTC_E_INVALID_REGISTRATION_STATE
//
// MessageText:
//
// Invalid registration state
//
#define RTC_E_INVALID_REGISTRATION_STATE ((HRESULT)0x80EE006DL)

//
// MessageId: RTC_E_MEDIA_DISABLED
//
// MessageText:
//
// Media is disabled
//
#define RTC_E_MEDIA_DISABLED             ((HRESULT)0x80EE006EL)

//
// MessageId: RTC_E_MEDIA_ENABLED
//
// MessageText:
//
// Media is enabled
//
#define RTC_E_MEDIA_ENABLED              ((HRESULT)0x80EE006FL)

//
// MessageId: RTC_E_REFER_NOT_ACCEPTED
//
// MessageText:
//
// Refer has not been accepted
//
#define RTC_E_REFER_NOT_ACCEPTED         ((HRESULT)0x80EE0070L)

//
// MessageId: RTC_E_REFER_NOT_ALLOWED
//
// MessageText:
//
// Refer operation is not allowed in this session
//
#define RTC_E_REFER_NOT_ALLOWED          ((HRESULT)0x80EE0071L)

//
// MessageId: RTC_E_REFER_NOT_EXIST
//
// MessageText:
//
// Refer session does not exist or has finished
//
#define RTC_E_REFER_NOT_EXIST            ((HRESULT)0x80EE0072L)

//
// MessageId: RTC_E_SIP_HOLD_OPERATION_PENDING
//
// MessageText:
//
// Currently an hold operation is pending
//
#define RTC_E_SIP_HOLD_OPERATION_PENDING ((HRESULT)0x80EE0073L)

//
// MessageId: RTC_E_SIP_UNHOLD_OPERATION_PENDING
//
// MessageText:
//
// Currently an unhold operation is pending
//
#define RTC_E_SIP_UNHOLD_OPERATION_PENDING ((HRESULT)0x80EE0074L)

//
// MessageId: RTC_E_MEDIA_SESSION_NOT_EXIST
//
// MessageText:
//
// Media session does not exist
//
#define RTC_E_MEDIA_SESSION_NOT_EXIST    ((HRESULT)0x80EE0075L)

//
// MessageId: RTC_E_MEDIA_SESSION_IN_HOLD
//
// MessageText:
//
// Media session is in hold
//
#define RTC_E_MEDIA_SESSION_IN_HOLD      ((HRESULT)0x80EE0076L)

//
// MessageId: RTC_E_ANOTHER_MEDIA_SESSION_ACTIVE
//
// MessageText:
//
// Another media session is active
//
#define RTC_E_ANOTHER_MEDIA_SESSION_ACTIVE ((HRESULT)0x80EE0077L)

//
// MessageId: RTC_E_MAX_REDIRECTS
//
// MessageText:
//
// Too many redirects
//
#define RTC_E_MAX_REDIRECTS              ((HRESULT)0x80EE0078L)

//
// MessageId: RTC_E_REDIRECT_PROCESSING_FAILED
//
// MessageText:
//
// Processing redirect failed
//
#define RTC_E_REDIRECT_PROCESSING_FAILED ((HRESULT)0x80EE0079L)

//
// MessageId: RTC_E_LISTENING_SOCKET_NOT_EXIST
//
// MessageText:
//
// Listening socket does not exist
//
#define RTC_E_LISTENING_SOCKET_NOT_EXIST ((HRESULT)0x80EE007AL)

//
// MessageId: RTC_E_INVALID_LISTEN_SOCKET
//
// MessageText:
//
// Specified address and port is invalid
//
#define RTC_E_INVALID_LISTEN_SOCKET      ((HRESULT)0x80EE007BL)

//
// MessageId: RTC_E_PORT_MANAGER_ALREADY_SET
//
// MessageText:
//
// Port manager already set
//
#define RTC_E_PORT_MANAGER_ALREADY_SET   ((HRESULT)0x80EE007CL)

//
// MessageId: RTC_E_SECURITY_LEVEL_ALREADY_SET
//
// MessageText:
//
// The security level has already been set for this Media type can and can not be changed
//
#define RTC_E_SECURITY_LEVEL_ALREADY_SET ((HRESULT)0x80EE007DL)

//
// MessageId: RTC_E_UDP_NOT_SUPPORTED
//
// MessageText:
//
// This feature is not supported when one of the server in profile has UDP transport
//
#define RTC_E_UDP_NOT_SUPPORTED          ((HRESULT)0x80EE007EL)

//
// MessageId: RTC_E_SIP_REFER_OPERATION_PENDING
//
// MessageText:
//
// Currently a refer operation is pending
//
#define RTC_E_SIP_REFER_OPERATION_PENDING ((HRESULT)0x80EE007FL)

//
// MessageId: RTC_E_PLATFORM_NOT_SUPPORTED
//
// MessageText:
//
// This operation is not supported on this Windows Platform.
//
#define RTC_E_PLATFORM_NOT_SUPPORTED     ((HRESULT)0x80EE0080L)

//
// MessageId: RTC_E_SIP_PEER_PARTICIPANT_IN_MULTIPARTY_SESSION
//
// MessageText:
//
// A peer participant cannot be added to a multiparty session
//
#define RTC_E_SIP_PEER_PARTICIPANT_IN_MULTIPARTY_SESSION ((HRESULT)0x80EE0081L)

//
// MessageId: RTC_E_NOT_ALLOWED
//
// MessageText:
//
// This action is not allowed
//
#define RTC_E_NOT_ALLOWED                ((HRESULT)0x80EE0082L)

//
// MessageId: RTC_E_REGISTRATION_DEACTIVATED
//
// MessageText:
//
// The user is being moved
//
#define RTC_E_REGISTRATION_DEACTIVATED   ((HRESULT)0x80EE0083L)

//
// MessageId: RTC_E_REGISTRATION_REJECTED
//
// MessageText:
//
// The user's account was disabled or deleted or the SIP URI changed
//
#define RTC_E_REGISTRATION_REJECTED      ((HRESULT)0x80EE0084L)

//
// MessageId: RTC_E_REGISTRATION_UNREGISTERED
//
// MessageText:
//
// The user was logged out because the user logged in elsewhere
//
#define RTC_E_REGISTRATION_UNREGISTERED  ((HRESULT)0x80EE0085L)

// Error codes from SIP status codes
//
// MessageId: RTC_E_STATUS_INFO_TRYING
//
// MessageText:
//
// Trying
//
#define RTC_E_STATUS_INFO_TRYING         ((HRESULT)0x00EF0064L)

//
// MessageId: RTC_E_STATUS_INFO_RINGING
//
// MessageText:
//
// Ringing
//
#define RTC_E_STATUS_INFO_RINGING        ((HRESULT)0x00EF00B4L)

//
// MessageId: RTC_E_STATUS_INFO_CALL_FORWARDING
//
// MessageText:
//
// Call Is Being Forwarded
//
#define RTC_E_STATUS_INFO_CALL_FORWARDING ((HRESULT)0x00EF00B5L)

//
// MessageId: RTC_E_STATUS_INFO_QUEUED
//
// MessageText:
//
// Queued
//
#define RTC_E_STATUS_INFO_QUEUED         ((HRESULT)0x00EF00B6L)

//
// MessageId: RTC_E_STATUS_SESSION_PROGRESS
//
// MessageText:
//
// Session Progress
//
#define RTC_E_STATUS_SESSION_PROGRESS    ((HRESULT)0x00EF00B7L)

//
// MessageId: RTC_E_STATUS_SUCCESS
//
// MessageText:
//
// OK
//
#define RTC_E_STATUS_SUCCESS             ((HRESULT)0x00EF00C8L)

//
// MessageId: RTC_E_STATUS_REDIRECT_MULTIPLE_CHOICES
//
// MessageText:
//
// Multiple Choices
//
#define RTC_E_STATUS_REDIRECT_MULTIPLE_CHOICES ((HRESULT)0x80EF012CL)

//
// MessageId: RTC_E_STATUS_REDIRECT_MOVED_PERMANENTLY
//
// MessageText:
//
// Moved Permanently
//
#define RTC_E_STATUS_REDIRECT_MOVED_PERMANENTLY ((HRESULT)0x80EF012DL)

//
// MessageId: RTC_E_STATUS_REDIRECT_MOVED_TEMPORARILY
//
// MessageText:
//
// Moved Temporarily
//
#define RTC_E_STATUS_REDIRECT_MOVED_TEMPORARILY ((HRESULT)0x80EF012EL)

//
// MessageId: RTC_E_STATUS_REDIRECT_SEE_OTHER
//
// MessageText:
//
// See Other
//
#define RTC_E_STATUS_REDIRECT_SEE_OTHER  ((HRESULT)0x80EF012FL)

//
// MessageId: RTC_E_STATUS_REDIRECT_USE_PROXY
//
// MessageText:
//
// Use Proxy
//
#define RTC_E_STATUS_REDIRECT_USE_PROXY  ((HRESULT)0x80EF0131L)

//
// MessageId: RTC_E_STATUS_REDIRECT_ALTERNATIVE_SERVICE
//
// MessageText:
//
// Alternative Service
//
#define RTC_E_STATUS_REDIRECT_ALTERNATIVE_SERVICE ((HRESULT)0x80EF017CL)

//
// MessageId: RTC_E_STATUS_CLIENT_BAD_REQUEST
//
// MessageText:
//
// Bad Request
//
#define RTC_E_STATUS_CLIENT_BAD_REQUEST  ((HRESULT)0x80EF0190L)

//
// MessageId: RTC_E_STATUS_CLIENT_UNAUTHORIZED
//
// MessageText:
//
// Unauthorized
//
#define RTC_E_STATUS_CLIENT_UNAUTHORIZED ((HRESULT)0x80EF0191L)

//
// MessageId: RTC_E_STATUS_CLIENT_PAYMENT_REQUIRED
//
// MessageText:
//
// Payment Required
//
#define RTC_E_STATUS_CLIENT_PAYMENT_REQUIRED ((HRESULT)0x80EF0192L)

//
// MessageId: RTC_E_STATUS_CLIENT_FORBIDDEN
//
// MessageText:
//
// Forbidden
//
#define RTC_E_STATUS_CLIENT_FORBIDDEN    ((HRESULT)0x80EF0193L)

//
// MessageId: RTC_E_STATUS_CLIENT_NOT_FOUND
//
// MessageText:
//
// Not Found
//
#define RTC_E_STATUS_CLIENT_NOT_FOUND    ((HRESULT)0x80EF0194L)

//
// MessageId: RTC_E_STATUS_CLIENT_METHOD_NOT_ALLOWED
//
// MessageText:
//
// Method Not Allowed
//
#define RTC_E_STATUS_CLIENT_METHOD_NOT_ALLOWED ((HRESULT)0x80EF0195L)

//
// MessageId: RTC_E_STATUS_CLIENT_NOT_ACCEPTABLE
//
// MessageText:
//
// Not Acceptable
//
#define RTC_E_STATUS_CLIENT_NOT_ACCEPTABLE ((HRESULT)0x80EF0196L)

//
// MessageId: RTC_E_STATUS_CLIENT_PROXY_AUTHENTICATION_REQUIRED
//
// MessageText:
//
// Proxy Authentication Required
//
#define RTC_E_STATUS_CLIENT_PROXY_AUTHENTICATION_REQUIRED ((HRESULT)0x80EF0197L)

//
// MessageId: RTC_E_STATUS_CLIENT_REQUEST_TIMEOUT
//
// MessageText:
//
// Request Timeout
//
#define RTC_E_STATUS_CLIENT_REQUEST_TIMEOUT ((HRESULT)0x80EF0198L)

//
// MessageId: RTC_E_STATUS_CLIENT_CONFLICT
//
// MessageText:
//
// Conflict
//
#define RTC_E_STATUS_CLIENT_CONFLICT     ((HRESULT)0x80EF0199L)

//
// MessageId: RTC_E_STATUS_CLIENT_GONE
//
// MessageText:
//
// Gone
//
#define RTC_E_STATUS_CLIENT_GONE         ((HRESULT)0x80EF019AL)

//
// MessageId: RTC_E_STATUS_CLIENT_LENGTH_REQUIRED
//
// MessageText:
//
// Length Required
//
#define RTC_E_STATUS_CLIENT_LENGTH_REQUIRED ((HRESULT)0x80EF019BL)

//
// MessageId: RTC_E_STATUS_CLIENT_REQUEST_ENTITY_TOO_LARGE
//
// MessageText:
//
// Request Entity Too Large
//
#define RTC_E_STATUS_CLIENT_REQUEST_ENTITY_TOO_LARGE ((HRESULT)0x80EF019DL)

//
// MessageId: RTC_E_STATUS_CLIENT_REQUEST_URI_TOO_LARGE
//
// MessageText:
//
// Request-URI Too Long
//
#define RTC_E_STATUS_CLIENT_REQUEST_URI_TOO_LARGE ((HRESULT)0x80EF019EL)

//
// MessageId: RTC_E_STATUS_CLIENT_UNSUPPORTED_MEDIA_TYPE
//
// MessageText:
//
// Unsupported Media Type
//
#define RTC_E_STATUS_CLIENT_UNSUPPORTED_MEDIA_TYPE ((HRESULT)0x80EF019FL)

//
// MessageId: RTC_E_STATUS_CLIENT_BAD_EXTENSION
//
// MessageText:
//
// Bad Extension
//
#define RTC_E_STATUS_CLIENT_BAD_EXTENSION ((HRESULT)0x80EF01A4L)

//
// MessageId: RTC_E_STATUS_CLIENT_TEMPORARILY_NOT_AVAILABLE
//
// MessageText:
//
// Temporarily Unavailable
//
#define RTC_E_STATUS_CLIENT_TEMPORARILY_NOT_AVAILABLE ((HRESULT)0x80EF01E0L)

//
// MessageId: RTC_E_STATUS_CLIENT_TRANSACTION_DOES_NOT_EXIST
//
// MessageText:
//
// Call Leg/Transaction Does Not Exist
//
#define RTC_E_STATUS_CLIENT_TRANSACTION_DOES_NOT_EXIST ((HRESULT)0x80EF01E1L)

//
// MessageId: RTC_E_STATUS_CLIENT_LOOP_DETECTED
//
// MessageText:
//
// Loop Detected
//
#define RTC_E_STATUS_CLIENT_LOOP_DETECTED ((HRESULT)0x80EF01E2L)

//
// MessageId: RTC_E_STATUS_CLIENT_TOO_MANY_HOPS
//
// MessageText:
//
// Too Many Hops
//
#define RTC_E_STATUS_CLIENT_TOO_MANY_HOPS ((HRESULT)0x80EF01E3L)

//
// MessageId: RTC_E_STATUS_CLIENT_ADDRESS_INCOMPLETE
//
// MessageText:
//
// Address Incomplete
//
#define RTC_E_STATUS_CLIENT_ADDRESS_INCOMPLETE ((HRESULT)0x80EF01E4L)

//
// MessageId: RTC_E_STATUS_CLIENT_AMBIGUOUS
//
// MessageText:
//
// Ambiguous
//
#define RTC_E_STATUS_CLIENT_AMBIGUOUS    ((HRESULT)0x80EF01E5L)

//
// MessageId: RTC_E_STATUS_CLIENT_BUSY_HERE
//
// MessageText:
//
// Busy Here
//
#define RTC_E_STATUS_CLIENT_BUSY_HERE    ((HRESULT)0x80EF01E6L)

//
// MessageId: RTC_E_STATUS_REQUEST_TERMINATED
//
// MessageText:
//
// Request Terminated
//
#define RTC_E_STATUS_REQUEST_TERMINATED  ((HRESULT)0x80EF01E7L)

//
// MessageId: RTC_E_STATUS_NOT_ACCEPTABLE_HERE
//
// MessageText:
//
// Not Acceptable Here
//
#define RTC_E_STATUS_NOT_ACCEPTABLE_HERE ((HRESULT)0x80EF01E8L)

//
// MessageId: RTC_E_STATUS_SERVER_INTERNAL_ERROR
//
// MessageText:
//
// Server Internal Error
//
#define RTC_E_STATUS_SERVER_INTERNAL_ERROR ((HRESULT)0x80EF01F4L)

//
// MessageId: RTC_E_STATUS_SERVER_NOT_IMPLEMENTED
//
// MessageText:
//
// Not Implemented
//
#define RTC_E_STATUS_SERVER_NOT_IMPLEMENTED ((HRESULT)0x80EF01F5L)

//
// MessageId: RTC_E_STATUS_SERVER_BAD_GATEWAY
//
// MessageText:
//
// Bad Gateway
//
#define RTC_E_STATUS_SERVER_BAD_GATEWAY  ((HRESULT)0x80EF01F6L)

//
// MessageId: RTC_E_STATUS_SERVER_SERVICE_UNAVAILABLE
//
// MessageText:
//
// Service Unavailable
//
#define RTC_E_STATUS_SERVER_SERVICE_UNAVAILABLE ((HRESULT)0x80EF01F7L)

//
// MessageId: RTC_E_STATUS_SERVER_SERVER_TIMEOUT
//
// MessageText:
//
// Server Time-out
//
#define RTC_E_STATUS_SERVER_SERVER_TIMEOUT ((HRESULT)0x80EF01F8L)

//
// MessageId: RTC_E_STATUS_SERVER_VERSION_NOT_SUPPORTED
//
// MessageText:
//
// Version Not Supported
//
#define RTC_E_STATUS_SERVER_VERSION_NOT_SUPPORTED ((HRESULT)0x80EF01F9L)

//
// MessageId: RTC_E_STATUS_GLOBAL_BUSY_EVERYWHERE
//
// MessageText:
//
// Busy Everywhere
//
#define RTC_E_STATUS_GLOBAL_BUSY_EVERYWHERE ((HRESULT)0x80EF0258L)

//
// MessageId: RTC_E_STATUS_GLOBAL_DECLINE
//
// MessageText:
//
// Decline
//
#define RTC_E_STATUS_GLOBAL_DECLINE      ((HRESULT)0x80EF025BL)

//
// MessageId: RTC_E_STATUS_GLOBAL_DOES_NOT_EXIST_ANYWHERE
//
// MessageText:
//
// Does Not Exist Anywhere
//
#define RTC_E_STATUS_GLOBAL_DOES_NOT_EXIST_ANYWHERE ((HRESULT)0x80EF025CL)

//
// MessageId: RTC_E_STATUS_GLOBAL_NOT_ACCEPTABLE
//
// MessageText:
//
// Not Acceptable
//
#define RTC_E_STATUS_GLOBAL_NOT_ACCEPTABLE ((HRESULT)0x80EF025EL)

// Error codes from PINT status codes
//
// MessageId: RTC_E_PINT_STATUS_REJECTED_BUSY
//
// MessageText:
//
// Busy
//
#define RTC_E_PINT_STATUS_REJECTED_BUSY  ((HRESULT)0x80F00005L)

//
// MessageId: RTC_E_PINT_STATUS_REJECTED_NO_ANSWER
//
// MessageText:
//
// No Answer
//
#define RTC_E_PINT_STATUS_REJECTED_NO_ANSWER ((HRESULT)0x80F00006L)

//
// MessageId: RTC_E_PINT_STATUS_REJECTED_ALL_BUSY
//
// MessageText:
//
// All Busy
//
#define RTC_E_PINT_STATUS_REJECTED_ALL_BUSY ((HRESULT)0x80F00007L)

//
// MessageId: RTC_E_PINT_STATUS_REJECTED_PL_FAILED
//
// MessageText:
//
// Primary Leg Failed
//
#define RTC_E_PINT_STATUS_REJECTED_PL_FAILED ((HRESULT)0x80F00008L)

//
// MessageId: RTC_E_PINT_STATUS_REJECTED_SW_FAILED
//
// MessageText:
//
// Switch Failed
//
#define RTC_E_PINT_STATUS_REJECTED_SW_FAILED ((HRESULT)0x80F00009L)

//
// MessageId: RTC_E_PINT_STATUS_REJECTED_CANCELLED
//
// MessageText:
//
// Cancelled
//
#define RTC_E_PINT_STATUS_REJECTED_CANCELLED ((HRESULT)0x80F0000AL)

//
// MessageId: RTC_E_PINT_STATUS_REJECTED_BADNUMBER
//
// MessageText:
//
// Bad Number
//
#define RTC_E_PINT_STATUS_REJECTED_BADNUMBER ((HRESULT)0x80F0000BL)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RtmV2.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rtmv2.h

Abstract:
    Interface for Routing Table Manager v2 DLL

Author:
    Chaitanya Kodeboyina (chaitk)  01-Jun-1998

Revision History:

--*/

#ifndef __ROUTING_RTMv2_H__
#define __ROUTING_RTMv2_H__

#pragma once

#include <in6addr.h>

#ifdef __cplusplus
extern "C"
{
#endif

//
// General Constants defined by the API
//

// Max addr size for an address family
#define RTM_MAX_ADDRESS_SIZE         16

//
// Supported Route Table Views
//
#define RTM_MAX_VIEWS                 32

#define RTM_VIEW_ID_UCAST              0
#define RTM_VIEW_ID_MCAST              1

#define RTM_VIEW_MASK_SIZE          0x20

#define RTM_VIEW_MASK_NONE    0x00000000
#define RTM_VIEW_MASK_ANY     0x00000000

#define RTM_VIEW_MASK_UCAST   0x00000001
#define RTM_VIEW_MASK_MCAST   0x00000002

#define RTM_VIEW_MASK_ALL     0xFFFFFFFF

// Identifies a particular view
typedef INT   RTM_VIEW_ID, *PRTM_VIEW_ID;

// Set of views expressed as a mask
typedef DWORD RTM_VIEW_SET, *PRTM_VIEW_SET;


//
// Profile returned during registration
//
typedef struct _RTM_REGN_PROFILE
{
    UINT            MaxNextHopsInRoute; // Max. number of equal cost nexthops
                                        // in a route, & Max. number of local
                                        // nexthops in any one remote nexthop

    UINT            MaxHandlesInEnum;   // Max. handles returned in one call to
                                        // RtmGetEnumDests, RtmGetChangedDests,
                                        // RtmGetEnumRoutes,RtmGetRoutesInElist

    RTM_VIEW_SET    ViewsSupported;     // Views supported by this addr family

    UINT            NumberOfViews;      // Number of views (# 1s in above mask)
}
RTM_REGN_PROFILE, *PRTM_REGN_PROFILE;


//
// Handles pointing to RTMv2 blocks
//
typedef HANDLE      RTM_ENTITY_HANDLE,
                   *PRTM_ENTITY_HANDLE,
                    RTM_DEST_HANDLE,
                   *PRTM_DEST_HANDLE,
                    RTM_ROUTE_HANDLE,
                   *PRTM_ROUTE_HANDLE,
                    RTM_NEXTHOP_HANDLE,
                   *PRTM_NEXTHOP_HANDLE,
                    RTM_ENUM_HANDLE,
                   *PRTM_ENUM_HANDLE,
                    RTM_ROUTE_LIST_HANDLE,
                   *PRTM_ROUTE_LIST_HANDLE,
                    RTM_NOTIFY_HANDLE,
                   *PRTM_NOTIFY_HANDLE;

//
// Network Address struct for any
// address family that works with
// only contiguous address masks
//
typedef struct _RTM_NET_ADDRESS
{
    USHORT AddressFamily;                  // Type of this net address (IPv4..)

    USHORT NumBits;                        // Number of leading bits in prefix

    UCHAR  AddrBits[RTM_MAX_ADDRESS_SIZE]; // Array of bits that form prefix
}
RTM_NET_ADDRESS, *PRTM_NET_ADDRESS;


//
// IPv4 macros to work on addresses
//

#define RTM_IPV4_MAKE_NET_ADDRESS(NetAddress, Addr, Len)           \
        RTM_IPV4_SET_ADDR_AND_LEN(NetAddress, Addr, Len)


#define RTM_CHECK_NTH_BIT(Value, N, Len)                           \
        if ((Value) & (1 << (N)))                                  \
        {                                                          \
            (Len) += (N); (Value) <<= (N);                         \
        }                                                          \

#define RTM_IPV4_LEN_FROM_MASK(Len, Mask)                          \
        {                                                          \
            ULONG _Temp_ = ntohl(Mask);                            \
                                                                   \
            (Len) = 0;                                             \
                                                                   \
            RTM_CHECK_NTH_BIT(_Temp_, 16, (Len));                  \
            RTM_CHECK_NTH_BIT(_Temp_,  8, (Len));                  \
            RTM_CHECK_NTH_BIT(_Temp_,  4, (Len));                  \
                                                                   \
            while (_Temp_)                                         \
            {                                                      \
                (Len) +=  1; _Temp_ <<=  1;                        \
            }                                                      \
        }                                                          \

#define RTM_IPV4_MASK_FROM_LEN(Len)                                \
        ((Len) ? htonl(~0 << (32 - (Len))): 0);                    \


#define RTM_IPV4_SET_ADDR_AND_LEN(NetAddress, Addr, Len)           \
        (NetAddress)->AddressFamily = AF_INET;                     \
        (NetAddress)->NumBits  = (USHORT) (Len);                   \
        (* (ULONG *) ((NetAddress)->AddrBits)) = (Addr);           \

#define RTM_IPV4_GET_ADDR_AND_LEN(Addr, Len, NetAddress)           \
        (Len) = (NetAddress)->NumBits;                             \
        (Addr) = (* (ULONG *) ((NetAddress)->AddrBits));           \


#define RTM_IPV4_SET_ADDR_AND_MASK(NetAddress, Addr, Mask)         \
        (NetAddress)->AddressFamily = AF_INET;                     \
        (* (ULONG *) ((NetAddress)->AddrBits)) = (Addr);           \
        RTM_IPV4_LEN_FROM_MASK((NetAddress)->NumBits, Mask)

#define RTM_IPV4_GET_ADDR_AND_MASK(Addr, Mask, NetAddress)         \
        (Addr) = (* (ULONG *) ((NetAddress)->AddrBits));           \
        (Mask) = RTM_IPV4_MASK_FROM_LEN((NetAddress)->NumBits);    \

//
// IPv6 Helper functions on addresss
//

DWORD
RtmConvertNetAddressToIpv6AddressAndLength(
    IN  PRTM_NET_ADDRESS         pNetAddress,
    OUT PIN6_ADDR                pAddress,
    OUT PDWORD                   pLength,
    IN  DWORD                    dwAddressSize
    );

DWORD
RtmConvertIpv6AddressAndLengthToNetAddress(
    OUT  PRTM_NET_ADDRESS         pNetAddress,
    IN   IN6_ADDR                 Address,
    IN   DWORD                    dwLength,
    IN   DWORD                    dwAddressSize
    );

//
// IPv6 macros to work on addresses
//
#define IPV6_ADDRESS_LEN_IN_BYTES     16

#define RTM_IPV6_MAKE_NET_ADDRESS(NetAddress, Addr, Len)           \
        RTM_IPV6_SET_ADDR_AND_LEN(NetAddress, Addr, Len)

#define RTM_IPV6_SET_ADDR_AND_LEN(NetAddress, Addr, Len)           \
        (NetAddress)->AddressFamily = AF_INET6;                    \
        (RtmConvertIpv6AddressAndLengthToNetAddress(NetAddress, Addr, Len, IPV6_ADDRESS_LEN_IN_BYTES)) \

#define RTM_IPV6_GET_ADDR_AND_LEN(Addr, Len, NetAddress)           \
        (RtmConvertNetAddressToIpv6AddressAndLength(NetAddress, Addr, Len, IPV6_ADDRESS_LEN_IN_BYTES)) \

//
// This structure encapsulates info
// used in comparing any two routes
// [Preference is impt than metric]
//
typedef struct _RTM_PREF_INFO
{
    ULONG               Metric;         // Routing protocol specific metric
    ULONG               Preference;     // Determined by the router policy
}
RTM_PREF_INFO, *PRTM_PREF_INFO;


//
// List of nexthops used for equal
// cost path in a route or nexthop
//
typedef struct _RTM_NEXTHOP_LIST
{
    USHORT              NumNextHops;    // Num of equal cost next hops in list
    RTM_NEXTHOP_HANDLE  NextHops[1];    // NumNextHops num of next hop handles
}
RTM_NEXTHOP_LIST, *PRTM_NEXTHOP_LIST;


//
// Structure used to exchange dest
// information with RTM entities
//
typedef struct _RTM_DEST_INFO
{
    RTM_DEST_HANDLE     DestHandle;       // Handle to the destination

    RTM_NET_ADDRESS     DestAddress;      // Destination network Address

    FILETIME            LastChanged;      // Last time dest was modified

    RTM_VIEW_SET        BelongsToViews;   // View that dest belongs too

    UINT                NumberOfViews;    // Number of view info slots
    struct
    {
        RTM_VIEW_ID         ViewId;       // View ID for this view info block
        UINT                NumRoutes;    // Number of routes,
        RTM_ROUTE_HANDLE    Route;        // Best route with matching criteria
        RTM_ENTITY_HANDLE   Owner;        // Best Route's Owner,
        DWORD               DestFlags;    // Best Route's Flags, and
        RTM_ROUTE_HANDLE    HoldRoute;    // Holddown route,
    }                   ViewInfo[1];      // in each one of the supported views
}
RTM_DEST_INFO, *PRTM_DEST_INFO;

//
// Macros useful in working on dests
//
#define RTM_BASIC_DEST_INFO_SIZE                                         \
    FIELD_OFFSET(RTM_DEST_INFO, ViewInfo)

#define RTM_DEST_VIEW_INFO_SIZE                                          \
    (sizeof(RTM_DEST_INFO) - RTM_BASIC_DEST_INFO_SIZE)

#define RTM_SIZE_OF_DEST_INFO(NumViews)                                  \
    (RTM_BASIC_DEST_INFO_SIZE + (NumViews) * RTM_DEST_VIEW_INFO_SIZE)

//
// Destination Flags
//
#define RTM_DEST_FLAG_NATURAL_NET   0x01
#define RTM_DEST_FLAG_FWD_ENGIN_ADD 0x02
#define RTM_DEST_FLAG_DONT_FORWARD  0x04

//
// Structure used to exchange route
// information with RTM entities
//
typedef struct _RTM_ROUTE_INFO
{
    //
    // Information that the owner can
    // directly access for read only
    //

    RTM_DEST_HANDLE     DestHandle;       // Handle to owning destination

    RTM_ENTITY_HANDLE   RouteOwner;       // Entity the owns this route

    RTM_NEXTHOP_HANDLE  Neighbour;        // Neighbour we learnt route from

    UCHAR               State;            // See RTM_ROUTE_STATE_* below

    //
    // Information that the owner can
    // directly access for read/write
    //

    UCHAR               Flags1;           // RTM v1 compatibility flags (temp)

    USHORT              Flags;            // See RTM_ROUTE_FLAGS_* below

    RTM_PREF_INFO       PrefInfo;         // Preference and metric for route

    RTM_VIEW_SET        BelongsToViews;   // Views that route belongs to

    PVOID               EntitySpecificInfo; // Owning Entity's private info

    RTM_NEXTHOP_LIST    NextHopsList;     // List of equal cost next-hops
}
RTM_ROUTE_INFO, *PRTM_ROUTE_INFO;

//
// Macros useful in working on routes
//
#define RTM_BASIC_ROUTE_INFO_SIZE                                        \
    FIELD_OFFSET(RTM_ROUTE_INFO, NextHopsList.NumNextHops)

#define RTM_SIZE_OF_ROUTE_INFO(NumHops)                                  \
    (RTM_BASIC_ROUTE_INFO_SIZE + (NumHops) * sizeof(RTM_NEXTHOP_HANDLE))

//
// State of the Route
//
#define RTM_ROUTE_STATE_CREATED        0
#define RTM_ROUTE_STATE_DELETING       1
#define RTM_ROUTE_STATE_DELETED        2


//
// Route Information Flags
//

// Forwarding Flags

#define RTM_ROUTE_FLAGS_MARTIAN        0x0001
#define RTM_ROUTE_FLAGS_BLACKHOLE      0x0002
#define RTM_ROUTE_FLAGS_DISCARD        0x0004
#define RTM_ROUTE_FLAGS_INACTIVE       0x0008

// Unicast Flags

#define RTM_ROUTE_FLAGS_LOCAL          0x0010
#define RTM_ROUTE_FLAGS_REMOTE         0x0020
#define RTM_ROUTE_FLAGS_MYSELF         0x0040

#define RTM_ROUTE_FLAGS_LOOPBACK       0x0080

// Bcast, Mcast Flags

#define RTM_ROUTE_FLAGS_MCAST          0x0100
#define RTM_ROUTE_FLAGS_LOCAL_MCAST    0x0200

#define RTM_ROUTE_FLAGS_LIMITED_BC     0x0400

#define RTM_ROUTE_FLAGS_ZEROS_NETBC    0x1000
#define RTM_ROUTE_FLAGS_ZEROS_SUBNETBC 0x2000
#define RTM_ROUTE_FLAGS_ONES_NETBC     0x4000
#define RTM_ROUTE_FLAGS_ONES_SUBNETBC  0x8000

// Grouping of Flags

#define RTM_ROUTE_FLAGS_FORWARDING        \
        (RTM_ROUTE_FLAGS_MARTIAN        | \
         RTM_ROUTE_FLAGS_BLACKHOLE      | \
         RTM_ROUTE_FLAGS_DISCARD        | \
         RTM_ROUTE_FLAGS_INACTIVE)

#define RTM_ROUTE_FLAGS_ANY_UNICAST       \
        (RTM_ROUTE_FLAGS_LOCAL          | \
         RTM_ROUTE_FLAGS_REMOTE         | \
         RTM_ROUTE_FLAGS_MYSELF)

#define RTM_ROUTE_FLAGS_ANY_MCAST         \
        (RTM_ROUTE_FLAGS_MCAST          | \
         RTM_ROUTE_FLAGS_LOCAL_MCAST)

#define RTM_ROUTE_FLAGS_SUBNET_BCAST      \
        (RTM_ROUTE_FLAGS_ONES_SUBNET_BC | \
         RTM_ROUTE_FLAGS_ZEROS_SUBNETBC)

#define RTM_ROUTE_FLAGS_NET_BCAST         \
        (RTM_ROUTE_FLAGS_ONES_NETBC     | \
         RTM_ROUTE_FLAGS_ZEROS_NETBC)

#define RTM_ROUTE_FLAGS_ANY_BCAST         \
        (RTM_ROUTE_FLAGS_LIMITED_BC     | \
         RTM_ROUTE_FLAGS_ONES_NETBC     | \
         RTM_ROUTE_FLAGS_ONES_SUBNET_BC | \
         RTM_ROUTE_FLAGS_ZEROS_NETBC    | \
         RTM_ROUTE_FLAGS_ZEROS_SUBNETBC)

//
// Structure used to exchange next-hop
// information with RTM entities
//
typedef struct _RTM_NEXTHOP_INFO
{
    //
    // Information that the owner can
    // directly access for read only
    //

    RTM_NET_ADDRESS     NextHopAddress;   // Net Address for this next hop

    RTM_ENTITY_HANDLE   NextHopOwner;     // Entity that owns this next hop

    ULONG               InterfaceIndex;   // Outgoing interface index
                                          // '0' for a remote nexthop

    USHORT              State;            // See RTM_NEXTHOP_STATE_* below

    //
    // Information that the owner can
    // directly access for read/write
    //

    USHORT              Flags;            // See RTM_NEXTHOP_FLAGS_* below

    PVOID               EntitySpecificInfo; // Owning Entity's private info

    RTM_DEST_HANDLE     RemoteNextHop;    // Handle to dest with nexthop addr
                                          // [ Not used for a local nexthop ]
}
RTM_NEXTHOP_INFO, *PRTM_NEXTHOP_INFO;

//
// Next Hop State
//

#define RTM_NEXTHOP_STATE_CREATED      0
#define RTM_NEXTHOP_STATE_DELETED      1

//
// Next Hop Flags
//

#define RTM_NEXTHOP_FLAGS_REMOTE  0x0001
#define RTM_NEXTHOP_FLAGS_DOWN    0x0002


//
// Entity Registration Related Defns
//

//
// Info that uniquely identifies an entity
//

// Disable warnings for unnamed structs
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable : 4201)

typedef struct _RTM_ENTITY_ID
{
    union
    {
        struct
        {
            ULONG    EntityProtocolId;  // Entity's Protocol ID (RIP,OSPF...)
            ULONG    EntityInstanceId;  // Entity's Protocol Instance
        };

        ULONGLONG    EntityId;          // Protocol ID and Instance
    };
}
RTM_ENTITY_ID, *PRTM_ENTITY_ID;

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default : 4201)
#endif

//
// Structure used to exchange entity
// information with RTM entities
//
typedef struct _RTM_ENTITY_INFO
{
    USHORT         RtmInstanceId;       // RTM Instance that it registered with
    USHORT         AddressFamily;       // Entity's Address Family

    RTM_ENTITY_ID  EntityId;            // Uniquely identifies an entity
}
RTM_ENTITY_INFO, *PRTM_ENTITY_INFO;


//
// Event in the RTM involving an entity
//
typedef enum _RTM_EVENT_TYPE
{
    RTM_ENTITY_REGISTERED,
    RTM_ENTITY_DEREGISTERED,
    RTM_ROUTE_EXPIRED,
    RTM_CHANGE_NOTIFICATION
}
RTM_EVENT_TYPE, *PRTM_EVENT_TYPE;

//
// Entity event inform callback
//
// Used to inform entities of
// new entities registering,
// or entities deregistering
//
typedef
DWORD
(WINAPI * _EVENT_CALLBACK) (
     IN  RTM_ENTITY_HANDLE    RtmRegHandle,  // Callee's Registration Handle
     IN  RTM_EVENT_TYPE       EventType,
     IN  PVOID                Context1,
     IN  PVOID                Context2
     );

typedef _EVENT_CALLBACK RTM_EVENT_CALLBACK,
                      *PRTM_EVENT_CALLBACK;


//
// Methods exported by a registered entity
//

#define METHOD_TYPE_ALL_METHODS      0xFFFFFFFF

#define METHOD_RIP2_NEIGHBOUR_ADDR   0x00000001
#define METHOD_RIP2_OUTBOUND_INTF    0x00000002
#define METHOD_RIP2_ROUTE_TAG        0x00000004
#define METHOD_RIP2_ROUTE_TIMESTAMP  0x00000008

#define METHOD_BGP4_AS_PATH          0x00000001
#define METHOD_BGP4_PEER_ID          0x00000002
#define METHOD_BGP4_PA_ORIGIN        0x00000004
#define METHOD_BGP4_NEXTHOP_ATTR     0x00000008

typedef DWORD      RTM_ENTITY_METHOD_TYPE,
                 *PRTM_ENTITY_METHOD_TYPE;


//
// Generic Input Structure for entity methods
//
typedef struct _RTM_ENTITY_METHOD_INPUT
{
    RTM_ENTITY_METHOD_TYPE MethodType;    // Type identifying the method
    UINT                   InputSize;     // Input Data Size
    UCHAR                  InputData[1];  // Input Data Buffer
}
RTM_ENTITY_METHOD_INPUT, *PRTM_ENTITY_METHOD_INPUT;

//
// Generic Output Structure for entity methods
//
typedef struct _RTM_ENTITY_METHOD_OUTPUT
{
    RTM_ENTITY_METHOD_TYPE MethodType;    // Type identifying the method
    DWORD                  MethodStatus;  // Return Status of method
    UINT                   OutputSize;    // Output Data Size
    UCHAR                  OutputData[1]; // Output Data Buffer
}
RTM_ENTITY_METHOD_OUTPUT, *PRTM_ENTITY_METHOD_OUTPUT;

//
// Common prototype for entity methods
//
typedef
VOID
(WINAPI * _ENTITY_METHOD) (
    IN  RTM_ENTITY_HANDLE         CallerHandle,
    IN  RTM_ENTITY_HANDLE         CalleeHandle,
    IN  RTM_ENTITY_METHOD_INPUT  *Input,
    OUT RTM_ENTITY_METHOD_OUTPUT *Output
    );

typedef _ENTITY_METHOD RTM_ENTITY_EXPORT_METHOD,
                     *PRTM_ENTITY_EXPORT_METHOD;

//
// Set of exported entity methods
//
typedef struct _RTM_ENTITY_EXPORT_METHODS
{
    UINT                     NumMethods;
    RTM_ENTITY_EXPORT_METHOD Methods[1];
}
RTM_ENTITY_EXPORT_METHODS, *PRTM_ENTITY_EXPORT_METHODS;

//
// To toggle method blocking on dests, routes and nexthops
//
#define RTM_RESUME_METHODS             0
#define RTM_BLOCK_METHODS              1


//
// I/O Flags when route is added/updated
//
typedef DWORD    RTM_ROUTE_CHANGE_FLAGS,
               *PRTM_ROUTE_CHANGE_FLAGS;

#define RTM_ROUTE_CHANGE_FIRST      0x01
#define RTM_ROUTE_CHANGE_NEW        0x02
#define RTM_ROUTE_CHANGE_BEST 0x00010000

//
// Output flags when nexthop is added
//
typedef DWORD  RTM_NEXTHOP_CHANGE_FLAGS,
             *PRTM_NEXTHOP_CHANGE_FLAGS;

#define RTM_NEXTHOP_CHANGE_NEW      0x01


//
// Definitions relating to RIB queries
//

//
// Flags used to matching routes in RIB
//
typedef DWORD           RTM_MATCH_FLAGS,
                      *PRTM_MATCH_FLAGS;

#define RTM_MATCH_NONE        0x00000000
#define RTM_MATCH_OWNER       0x00000001
#define RTM_MATCH_NEIGHBOUR   0x00000002
#define RTM_MATCH_PREF        0x00000004
#define RTM_MATCH_NEXTHOP     0x00000008
#define RTM_MATCH_INTERFACE   0x00000010
#define RTM_MATCH_FULL        0x0000FFFF

//
// Flags to specify route being queried
//
#define RTM_BEST_PROTOCOL    (ULONG)   0
#define RTM_THIS_PROTOCOL    (ULONG)  ~0


//
// Definitions relating to enumerations
//

typedef DWORD            RTM_ENUM_FLAGS,
                       *PRTM_ENUM_FLAGS;

// Enumeration Flags

#define RTM_ENUM_START        0x00000000
#define RTM_ENUM_NEXT         0x00000001
#define RTM_ENUM_RANGE        0x00000002

#define RTM_ENUM_ALL_DESTS    0x00000000
#define RTM_ENUM_OWN_DESTS    0x01000000

#define RTM_ENUM_ALL_ROUTES   0x00000000
#define RTM_ENUM_OWN_ROUTES   0x00010000


//
// Definitions relating to notifications
//

// Notify Flags is composed as follows -
// (Change Types | Dests) interested in.

typedef DWORD          RTM_NOTIFY_FLAGS,
                     *PRTM_NOTIFY_FLAGS;

// Change Types to notify about

#define RTM_NUM_CHANGE_TYPES            3

#define RTM_CHANGE_TYPE_ALL        0x0001
#define RTM_CHANGE_TYPE_BEST       0x0002
#define RTM_CHANGE_TYPE_FORWARDING 0x0004

// Dests whose changes to notify

#define RTM_NOTIFY_ONLY_MARKED_DESTS 0x00010000


//
// Registration API Prototypes
//

DWORD
WINAPI
RtmRegisterEntity (
    IN      PRTM_ENTITY_INFO                RtmEntityInfo,
    IN      PRTM_ENTITY_EXPORT_METHODS      ExportMethods OPTIONAL,
    IN      RTM_EVENT_CALLBACK              EventCallback,
    IN      BOOL                            ReserveOpaquePointer,
    OUT     PRTM_REGN_PROFILE               RtmRegProfile,
    OUT     PRTM_ENTITY_HANDLE              RtmRegHandle
    );

DWORD
WINAPI
RtmDeregisterEntity (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle
    );

DWORD
WINAPI
RtmGetRegisteredEntities (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN OUT  PUINT                           NumEntities,
    OUT     PRTM_ENTITY_HANDLE              EntityHandles,
    OUT     PRTM_ENTITY_INFO                EntityInfos OPTIONAL
    );

DWORD
WINAPI
RtmReleaseEntities (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumEntities,
    IN      PRTM_ENTITY_HANDLE              EntityHandles
    );

//
// Opaque Ptr APIs
//

DWORD
WINAPI
RtmLockDestination(
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    IN      BOOL                            Exclusive,
    IN      BOOL                            LockDest
    );

DWORD
WINAPI
RtmGetOpaqueInformationPointer (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    OUT     PVOID                          *OpaqueInfoPointer
    );

//
// Export Method API Prototypes
//

DWORD
WINAPI
RtmGetEntityMethods (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENTITY_HANDLE               EntityHandle,
    IN OUT  PUINT                           NumMethods,
    OUT     PRTM_ENTITY_EXPORT_METHOD       ExptMethods
    );

DWORD
WINAPI
RtmInvokeMethod (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENTITY_HANDLE               EntityHandle,
    IN      PRTM_ENTITY_METHOD_INPUT        Input,
    IN OUT  PUINT                           OutputSize,
    OUT     PRTM_ENTITY_METHOD_OUTPUT       Output
    );

DWORD
WINAPI
RtmBlockMethods (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      HANDLE                          TargetHandle OPTIONAL,
    IN      UCHAR                           TargetType   OPTIONAL,
    IN      DWORD                           BlockingFlag
    );

//
// Handle to Info Structures
//

DWORD
WINAPI
RtmGetEntityInfo (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENTITY_HANDLE               EntityHandle,
    OUT     PRTM_ENTITY_INFO                EntityInfo
    );

DWORD
WINAPI
RtmGetDestInfo (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    IN      ULONG                           ProtocolId,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_DEST_INFO                  DestInfo
    );

DWORD
WINAPI
RtmGetRouteInfo (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    OUT     PRTM_ROUTE_INFO                 RouteInfo   OPTIONAL,
    OUT     PRTM_NET_ADDRESS                DestAddress OPTIONAL
    );

DWORD
WINAPI
RtmGetNextHopInfo (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NEXTHOP_HANDLE              NextHopHandle,
    OUT     PRTM_NEXTHOP_INFO               NextHopInfo
    );

DWORD
WINAPI
RtmReleaseEntityInfo (
    IN      RTM_ENTITY_HANDLE              RtmRegHandle,
    IN      PRTM_ENTITY_INFO               EntityInfo
    );

DWORD
WINAPI
RtmReleaseDestInfo (
    IN      RTM_ENTITY_HANDLE              RtmRegHandle,
    IN      PRTM_DEST_INFO                 DestInfo
    );

DWORD
WINAPI
RtmReleaseRouteInfo (
    IN      RTM_ENTITY_HANDLE              RtmRegHandle,
    IN      PRTM_ROUTE_INFO                RouteInfo
    );

DWORD
WINAPI
RtmReleaseNextHopInfo (
    IN      RTM_ENTITY_HANDLE              RtmRegHandle,
    IN      PRTM_NEXTHOP_INFO              NextHopInfo
    );


//
// RIB Insert/Delete API Prototypes
//

DWORD
WINAPI
RtmAddRouteToDest (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN OUT  PRTM_ROUTE_HANDLE               RouteHandle     OPTIONAL,
    IN      PRTM_NET_ADDRESS                DestAddress,
    IN      PRTM_ROUTE_INFO                 RouteInfo,
    IN      ULONG                           TimeToLive,
    IN      RTM_ROUTE_LIST_HANDLE           RouteListHandle OPTIONAL,
    IN      RTM_NOTIFY_FLAGS                NotifyType,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle    OPTIONAL,
    IN OUT  PRTM_ROUTE_CHANGE_FLAGS         ChangeFlags
    );

DWORD
WINAPI
RtmDeleteRouteToDest (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    OUT     PRTM_ROUTE_CHANGE_FLAGS         ChangeFlags
    );

DWORD
WINAPI
RtmHoldDestination (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    IN      RTM_VIEW_SET                    TargetViews,
    IN      ULONG                           HoldTime
    );

DWORD
WINAPI
RtmGetRoutePointer (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    OUT     PRTM_ROUTE_INFO                *RoutePointer
    );

DWORD
WINAPI
RtmLockRoute(
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    IN      BOOL                            Exclusive,
    IN      BOOL                            LockRoute,
    OUT     PRTM_ROUTE_INFO                *RoutePointer OPTIONAL
    );

DWORD
WINAPI
RtmUpdateAndUnlockRoute(
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    IN      ULONG                           TimeToLive,
    IN      RTM_ROUTE_LIST_HANDLE           RouteListHandle OPTIONAL,
    IN      RTM_NOTIFY_FLAGS                NotifyType,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle    OPTIONAL,
    OUT     PRTM_ROUTE_CHANGE_FLAGS         ChangeFlags
    );

//
// RIB Query API Prototypes
//

DWORD
WINAPI
RtmGetExactMatchDestination (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      PRTM_NET_ADDRESS                DestAddress,
    IN      ULONG                           ProtocolId,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_DEST_INFO                  DestInfo
    );

DWORD
WINAPI
RtmGetMostSpecificDestination (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      PRTM_NET_ADDRESS                DestAddress,
    IN      ULONG                           ProtocolId,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_DEST_INFO                  DestInfo
    );

DWORD
WINAPI
RtmGetLessSpecificDestination (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    IN      ULONG                           ProtocolId,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_DEST_INFO                  DestInfo
    );

DWORD
WINAPI
RtmGetExactMatchRoute (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      PRTM_NET_ADDRESS                DestAddress,
    IN      RTM_MATCH_FLAGS                 MatchingFlags,
    IN OUT  PRTM_ROUTE_INFO                 RouteInfo,
    IN      ULONG                           InterfaceIndex,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_ROUTE_HANDLE               RouteHandle
    );

DWORD
WINAPI
RtmIsBestRoute (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    OUT     PRTM_VIEW_SET                   BestInViews
    );

//
// NextHop Object API Prototypes
//

DWORD
WINAPI
RtmAddNextHop (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo,
    IN OUT  PRTM_NEXTHOP_HANDLE             NextHopHandle OPTIONAL,
    OUT     PRTM_NEXTHOP_CHANGE_FLAGS       ChangeFlags
    );

DWORD
WINAPI
RtmFindNextHop (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo,
    OUT     PRTM_NEXTHOP_HANDLE             NextHopHandle,
    OUT     PRTM_NEXTHOP_INFO              *NextHopPointer OPTIONAL
    );

DWORD
WINAPI
RtmDeleteNextHop (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NEXTHOP_HANDLE              NextHopHandle  OPTIONAL,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo
    );

DWORD
WINAPI
RtmGetNextHopPointer (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NEXTHOP_HANDLE              NextHopHandle,
    OUT     PRTM_NEXTHOP_INFO              *NextHopPointer
    );

DWORD
WINAPI
RtmLockNextHop(
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NEXTHOP_HANDLE              NextHopHandle,
    IN      BOOL                            Exclusive,
    IN      BOOL                            LockNextHop,
    OUT     PRTM_NEXTHOP_INFO              *NextHopPointer OPTIONAL
    );


//
// Enumeration API Prototypes
//

DWORD
WINAPI
RtmCreateDestEnum (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_VIEW_SET                    TargetViews,
    IN      RTM_ENUM_FLAGS                  EnumFlags,
    IN      PRTM_NET_ADDRESS                NetAddress,
    IN      ULONG                           ProtocolId,
    OUT     PRTM_ENUM_HANDLE                RtmEnumHandle
    );

DWORD
WINAPI
RtmGetEnumDests (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_HANDLE                 EnumHandle,
    IN OUT  PUINT                           NumDests,
    OUT     PRTM_DEST_INFO                  DestInfos
    );

DWORD
WINAPI
RtmReleaseDests (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumDests,
    IN      PRTM_DEST_INFO                  DestInfos
    );

DWORD
WINAPI
RtmCreateRouteEnum (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle        OPTIONAL,
    IN      RTM_VIEW_SET                    TargetViews,
    IN      RTM_ENUM_FLAGS                  EnumFlags,
    IN      PRTM_NET_ADDRESS                StartDest         OPTIONAL,
    IN      RTM_MATCH_FLAGS                 MatchingFlags,
    IN      PRTM_ROUTE_INFO                 CriteriaRoute     OPTIONAL,
    IN      ULONG                           CriteriaInterface OPTIONAL,
    OUT     PRTM_ENUM_HANDLE                RtmEnumHandle
    );

DWORD
WINAPI
RtmGetEnumRoutes (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_HANDLE                 EnumHandle,
    IN OUT  PUINT                           NumRoutes,
    OUT     PRTM_ROUTE_HANDLE               RouteHandles
    );

DWORD
WINAPI
RtmReleaseRoutes (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumRoutes,
    IN      PRTM_ROUTE_HANDLE               RouteHandles
    );

DWORD
WINAPI
RtmCreateNextHopEnum (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_FLAGS                  EnumFlags,
    IN      PRTM_NET_ADDRESS                NetAddress,
    OUT     PRTM_ENUM_HANDLE                RtmEnumHandle
    );

DWORD
WINAPI
RtmGetEnumNextHops (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_HANDLE                 EnumHandle,
    IN OUT  PUINT                           NumNextHops,
    OUT     PRTM_NEXTHOP_HANDLE             NextHopHandles
    );

DWORD
WINAPI
RtmReleaseNextHops (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumNextHops,
    IN      PRTM_NEXTHOP_HANDLE             NextHopHandles
    );

DWORD
WINAPI
RtmDeleteEnumHandle (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_HANDLE                 EnumHandle
    );


//
// Change Notification APIs
//

DWORD
WINAPI
RtmRegisterForChangeNotification (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_VIEW_SET                    TargetViews,
    IN      RTM_NOTIFY_FLAGS                NotifyFlags,
    IN      PVOID                           NotifyContext,
    OUT     PRTM_NOTIFY_HANDLE              NotifyHandle
    );

DWORD
WINAPI
RtmGetChangedDests (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN OUT  PUINT                           NumDests,
    OUT     PRTM_DEST_INFO                  ChangedDests
    );

DWORD
WINAPI
RtmReleaseChangedDests (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN      UINT                            NumDests,
    IN      PRTM_DEST_INFO                  ChangedDests
    );

DWORD
WINAPI
RtmIgnoreChangedDests (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN      UINT                            NumDests,
    IN      PRTM_DEST_HANDLE                ChangedDests
    );

DWORD
WINAPI
RtmGetChangeStatus (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    OUT     PBOOL                           ChangeStatus
    );

DWORD
WINAPI
RtmMarkDestForChangeNotification (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    IN      BOOL                            MarkDest
    );

DWORD
WINAPI
RtmIsMarkedForChangeNotification (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    OUT     PBOOL                           DestMarked
    );

DWORD
WINAPI
RtmDeregisterFromChangeNotification (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle
    );


//
// Entity Specific List APIs
//

DWORD
WINAPI
RtmCreateRouteList (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    OUT     PRTM_ROUTE_LIST_HANDLE          RouteListHandle
    );

DWORD
WINAPI
RtmInsertInRouteList (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_LIST_HANDLE           RouteListHandle OPTIONAL,
    IN      UINT                            NumRoutes,
    IN      PRTM_ROUTE_HANDLE               RouteHandles
    );

DWORD
WINAPI
RtmCreateRouteListEnum (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_LIST_HANDLE           RouteListHandle,
    OUT     PRTM_ENUM_HANDLE                RtmEnumHandle
    );

DWORD
WINAPI
RtmGetListEnumRoutes (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_HANDLE                 EnumHandle,
    IN OUT  PUINT                           NumRoutes,
    __out_ecount(*NumRoutes) OUT     PRTM_ROUTE_HANDLE               RouteHandles
    );

DWORD
WINAPI
RtmDeleteRouteList (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_LIST_HANDLE           RouteListHandle
    );

//
// Handle Management APIs
//

DWORD
WINAPI
RtmReferenceHandles (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumHandles,
    IN      HANDLE                         *RtmHandles
    );

#ifdef __cplusplus
}
#endif

#endif //__ROUTING_RTMv2_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RTInfo.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rtinfo.h

Abstract:
	Definitions of information block structuers used to exchange
	information in router API

--*/

#ifndef __ROUTING_RTINFO_H__
#define __ROUTING_RTINFO_H__

#if _MSC_VER > 1000
#pragma once
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Information is passed to and from the Router Managers using a set of     //
// RTR_TOC_ENTRY structures. These structures are encapsulated by an        //
// RTR_INFO_BLOCK_HEADER.                                                   //
// The general structure of this is:                                        //
//                                                                          //
//           ---    |-----------------------|   ---                         //
//            |     |                       |    |                          //
//            |     | RTR_INFO_BLOCK_HEADER |    |                          //
//            |     |                       |    |                          //
//            |     | TocEntriesCount = N   |    |                          //
//            |     |-----------------------|    |                          //
//            |     |      TocEntry[0]      |    |                          //
//            |     |                       |    |                          //
//            |     |      Offset of        |    |                          //
//            |<------  Associated Data     |    |                          //
//            |     |                       |    |                          //
//            |     |-----------------------|    |                          //
//            |     Z                       Z    |                          //
//            |     |                       |    |                          //
//            |     |-----------------------|    |                          //
//            |     |      TocEntry[N-1]    |    |                          //
//            |     |                       |    |                          //
//            |     |      Offset of        |    |                          //
//            |     |   Associated Data  ------->|                          //
//            |     |                       |    |                          //
//           ---    |-----------------------|    |                          //
//                  |  Data for TocEntry[0] |    |                          //
//                  |-----------------------|    |                          //
//                  Z                       Z    |                          //
//                  |-----------------------|   ---                         //
//                  | Data for TocEntry[N-1]|                               //
//                  |-----------------------|                               //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Each of the blocks of data must begin at a quadword aligned boundary. To //
// get QUADWORD alignment, use the following macros.                        //
//                                                                          //
// The block of data pointed to by an InfoBlock MUST be aligned.            //
// Use the alignment macro when writing the data portion  into an infobase. //
// This implies that for each ALIGN_POINTER operation done on a chunk       //
// of memory, the requested allocation must be ALIGN_SIZE greater           //
// than what is actually required (to be on the safe side)                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define ALIGN_SIZE      0x00000008
#define ALIGN_SHIFT     (ALIGN_SIZE - 0x00000001)       // 0x00000007
#define ALIGN_MASK_POINTER  (~(UINT_PTR)ALIGN_SHIFT)    // 0xfffffff8
#define ALIGN_MASK_LENGTH   (~ALIGN_SHIFT)              // 0xfffffff8
#define ALIGN_MASK          (~ALIGN_SHIFT)              // 0xfffffff8


#define ALIGN_POINTER(ptr) {                                    \
    (ptr) = (PVOID)((DWORD_PTR)(ptr) + ALIGN_SHIFT);            \
    (ptr) = (PVOID)((DWORD_PTR)(ptr) & ALIGN_MASK_POINTER);     \
}

#define ALIGN_LENGTH(length) {                                  \
    (length) = (DWORD)((length) + ALIGN_SHIFT);                 \
    (length) = (DWORD)((length) & ALIGN_MASK_LENGTH);           \
}


#define IS_ALIGNED(ptr)  (((UINT_PTR)(ptr) & ALIGN_SHIFT) == 0x00000000)

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//   			            Table of Contents Entry 	                    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Each entry describes a structure type, location within the information   //
// block and number of entries of the same type.                            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef struct _RTR_TOC_ENTRY
{
    ULONG	    InfoType;	// Info structure type
    ULONG	    InfoSize;	// Size of the info structure
    ULONG	    Count;		// How many info structures of this type
    ULONG	    Offset;		// Offset of the first structure, from the start
							// of the info block header.
}RTR_TOC_ENTRY, *PRTR_TOC_ENTRY;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//   			            Info Block Header        	                    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// All Router information blocks start with this header                     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define RTR_INFO_BLOCK_VERSION	1

typedef struct _RTR_INFO_BLOCK_HEADER
{
    ULONG			Version;	    // Version of the structure
    ULONG			Size;		    // size of the whole block, including version
    ULONG			TocEntriesCount;// Number of entries
    __field_ecount(TocEntriesCount) RTR_TOC_ENTRY   TocEntry[1];    // Table of content followed by the actual
                                    // information blocks
} RTR_INFO_BLOCK_HEADER, *PRTR_INFO_BLOCK_HEADER;

//
// PVOID
// GetInfoFromTocEntry(
//                     IN PRTR_INFO_BLOCK_HEADER pInfoHdr,
//                     IN PRTR_TOC_ENTRY         pToc
//                     )
//

#define GetInfoFromTocEntry(hdr,toc)            \
    (((toc)->Offset < (hdr)->Size) ? ((PVOID)(((PBYTE)(hdr)) + (toc)->Offset)) : NULL)

#endif //__ROUTING_RTINFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RTSCOM_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for rtscom.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_TPCRTSLib,0xA76A6D34,0xA06D,0x43e1,0x8C,0x05,0x0C,0x56,0xD3,0x6F,0x46,0x2E);


MIDL_DEFINE_GUID(IID, IID_IRealTimeStylus,0xA8BB5D22,0x3144,0x4a7b,0x93,0xCD,0xF3,0x4A,0x16,0xBE,0x51,0x3A);


MIDL_DEFINE_GUID(IID, IID_IRealTimeStylus2,0xB5F2A6CD,0x3179,0x4a3e,0xB9,0xC4,0xBB,0x58,0x65,0x96,0x2B,0xE2);


MIDL_DEFINE_GUID(IID, IID_IRealTimeStylus3,0xD70230A3,0x6986,0x4051,0xB5,0x7A,0x1C,0xF6,0x9F,0x4D,0x9D,0xB5);


MIDL_DEFINE_GUID(IID, IID_IRealTimeStylusSynchronization,0xAA87EAB8,0xAB4A,0x4cea,0xB5,0xCB,0x46,0xD8,0x4C,0x6A,0x25,0x09);


MIDL_DEFINE_GUID(IID, IID_IStrokeBuilder,0xA5FD4E2D,0xC44B,0x4092,0x91,0x77,0x26,0x09,0x05,0xEB,0x67,0x2B);


MIDL_DEFINE_GUID(IID, IID_IStylusPlugin,0xA81436D8,0x4757,0x4fd1,0xA1,0x85,0x13,0x3F,0x97,0xC6,0xC5,0x45);


MIDL_DEFINE_GUID(IID, IID_IStylusSyncPlugin,0xA157B174,0x482F,0x4d71,0xA3,0xF6,0x3A,0x41,0xDD,0xD1,0x1B,0xE9);


MIDL_DEFINE_GUID(IID, IID_IStylusAsyncPlugin,0xA7CCA85A,0x31BC,0x4cd2,0xAA,0xDC,0x32,0x89,0xA3,0xAF,0x11,0xC8);


MIDL_DEFINE_GUID(IID, IID_IDynamicRenderer,0xA079468E,0x7165,0x46f9,0xB7,0xAF,0x98,0xAD,0x01,0xA9,0x30,0x09);


MIDL_DEFINE_GUID(IID, IID_IGestureRecognizer,0xAE9EF86B,0x7054,0x45e3,0xAE,0x22,0x31,0x74,0xDC,0x88,0x11,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_RealTimeStylus,0xE26B366D,0xF998,0x43ce,0x83,0x6F,0xCB,0x6D,0x90,0x44,0x32,0xB0);


MIDL_DEFINE_GUID(CLSID, CLSID_DynamicRenderer,0xECD32AEA,0x746F,0x4dcb,0xBF,0x68,0x08,0x27,0x57,0xFA,0xFF,0x18);


MIDL_DEFINE_GUID(CLSID, CLSID_GestureRecognizer,0xEA30C654,0xC62C,0x441f,0xAC,0x00,0x95,0xF9,0xA1,0x96,0x78,0x2C);


MIDL_DEFINE_GUID(CLSID, CLSID_StrokeBuilder,0xE810CEE7,0x6E51,0x4cb0,0xAA,0x3A,0x0B,0x98,0x5B,0x70,0xDA,0xF7);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\RTSCOM.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for rtscom.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __rtscom_h__
#define __rtscom_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IRealTimeStylus_FWD_DEFINED__
#define __IRealTimeStylus_FWD_DEFINED__
typedef interface IRealTimeStylus IRealTimeStylus;
#endif 	/* __IRealTimeStylus_FWD_DEFINED__ */


#ifndef __IRealTimeStylus2_FWD_DEFINED__
#define __IRealTimeStylus2_FWD_DEFINED__
typedef interface IRealTimeStylus2 IRealTimeStylus2;
#endif 	/* __IRealTimeStylus2_FWD_DEFINED__ */


#ifndef __IRealTimeStylus3_FWD_DEFINED__
#define __IRealTimeStylus3_FWD_DEFINED__
typedef interface IRealTimeStylus3 IRealTimeStylus3;
#endif 	/* __IRealTimeStylus3_FWD_DEFINED__ */


#ifndef __IRealTimeStylusSynchronization_FWD_DEFINED__
#define __IRealTimeStylusSynchronization_FWD_DEFINED__
typedef interface IRealTimeStylusSynchronization IRealTimeStylusSynchronization;
#endif 	/* __IRealTimeStylusSynchronization_FWD_DEFINED__ */


#ifndef __IStrokeBuilder_FWD_DEFINED__
#define __IStrokeBuilder_FWD_DEFINED__
typedef interface IStrokeBuilder IStrokeBuilder;
#endif 	/* __IStrokeBuilder_FWD_DEFINED__ */


#ifndef __IStylusPlugin_FWD_DEFINED__
#define __IStylusPlugin_FWD_DEFINED__
typedef interface IStylusPlugin IStylusPlugin;
#endif 	/* __IStylusPlugin_FWD_DEFINED__ */


#ifndef __IStylusSyncPlugin_FWD_DEFINED__
#define __IStylusSyncPlugin_FWD_DEFINED__
typedef interface IStylusSyncPlugin IStylusSyncPlugin;
#endif 	/* __IStylusSyncPlugin_FWD_DEFINED__ */


#ifndef __IStylusAsyncPlugin_FWD_DEFINED__
#define __IStylusAsyncPlugin_FWD_DEFINED__
typedef interface IStylusAsyncPlugin IStylusAsyncPlugin;
#endif 	/* __IStylusAsyncPlugin_FWD_DEFINED__ */


#ifndef __IDynamicRenderer_FWD_DEFINED__
#define __IDynamicRenderer_FWD_DEFINED__
typedef interface IDynamicRenderer IDynamicRenderer;
#endif 	/* __IDynamicRenderer_FWD_DEFINED__ */


#ifndef __IGestureRecognizer_FWD_DEFINED__
#define __IGestureRecognizer_FWD_DEFINED__
typedef interface IGestureRecognizer IGestureRecognizer;
#endif 	/* __IGestureRecognizer_FWD_DEFINED__ */


#ifndef __RealTimeStylus_FWD_DEFINED__
#define __RealTimeStylus_FWD_DEFINED__

#ifdef __cplusplus
typedef class RealTimeStylus RealTimeStylus;
#else
typedef struct RealTimeStylus RealTimeStylus;
#endif /* __cplusplus */

#endif 	/* __RealTimeStylus_FWD_DEFINED__ */


#ifndef __DynamicRenderer_FWD_DEFINED__
#define __DynamicRenderer_FWD_DEFINED__

#ifdef __cplusplus
typedef class DynamicRenderer DynamicRenderer;
#else
typedef struct DynamicRenderer DynamicRenderer;
#endif /* __cplusplus */

#endif 	/* __DynamicRenderer_FWD_DEFINED__ */


#ifndef __GestureRecognizer_FWD_DEFINED__
#define __GestureRecognizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class GestureRecognizer GestureRecognizer;
#else
typedef struct GestureRecognizer GestureRecognizer;
#endif /* __cplusplus */

#endif 	/* __GestureRecognizer_FWD_DEFINED__ */


#ifndef __StrokeBuilder_FWD_DEFINED__
#define __StrokeBuilder_FWD_DEFINED__

#ifdef __cplusplus
typedef class StrokeBuilder StrokeBuilder;
#else
typedef struct StrokeBuilder StrokeBuilder;
#endif /* __cplusplus */

#endif 	/* __StrokeBuilder_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "tpcshrd.h"
#include "msinkaut.h"
#include "manipulations.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_rtscom_0000_0000 */
/* [local] */ 









typedef 
enum RealTimeStylusDataInterest
    {	RTSDI_AllData	= 0xffffffff,
	RTSDI_None	= 0,
	RTSDI_Error	= 0x1,
	RTSDI_RealTimeStylusEnabled	= 0x2,
	RTSDI_RealTimeStylusDisabled	= 0x4,
	RTSDI_StylusNew	= 0x8,
	RTSDI_StylusInRange	= 0x10,
	RTSDI_InAirPackets	= 0x20,
	RTSDI_StylusOutOfRange	= 0x40,
	RTSDI_StylusDown	= 0x80,
	RTSDI_Packets	= 0x100,
	RTSDI_StylusUp	= 0x200,
	RTSDI_StylusButtonUp	= 0x400,
	RTSDI_StylusButtonDown	= 0x800,
	RTSDI_SystemEvents	= 0x1000,
	RTSDI_TabletAdded	= 0x2000,
	RTSDI_TabletRemoved	= 0x4000,
	RTSDI_CustomStylusDataAdded	= 0x8000,
	RTSDI_UpdateMapping	= 0x10000,
	RTSDI_DefaultEvents	= ( ( ( ( ( ( RTSDI_RealTimeStylusEnabled | RTSDI_RealTimeStylusDisabled )  | RTSDI_StylusDown )  | RTSDI_Packets )  | RTSDI_StylusUp )  | RTSDI_SystemEvents )  | RTSDI_CustomStylusDataAdded ) 
    } 	RealTimeStylusDataInterest;

typedef CURSOR_ID STYLUS_ID;

typedef struct StylusInfo
    {
    TABLET_CONTEXT_ID tcid;
    STYLUS_ID cid;
    BOOL bIsInvertedCursor;
    } 	StylusInfo;

typedef 
enum StylusQueue
    {	SyncStylusQueue	= 0x1,
	AsyncStylusQueueImmediate	= 0x2,
	AsyncStylusQueue	= 0x3
    } 	StylusQueue;

typedef 
enum RealTimeStylusLockType
    {	RTSLT_ObjLock	= 0x1,
	RTSLT_SyncEventLock	= 0x2,
	RTSLT_AsyncEventLock	= 0x4,
	RTSLT_ExcludeCallback	= 0x8,
	RTSLT_SyncObjLock	= 0xb,
	RTSLT_AsyncObjLock	= 0xd
    } 	RealTimeStylusLockType;

typedef struct GESTURE_DATA
    {
    int gestureId;
    int recoConfidence;
    int strokeCount;
    } 	GESTURE_DATA;

typedef struct DYNAMIC_RENDERER_CACHED_DATA
    {
    LONG strokeId;
    IDynamicRenderer *dynamicRenderer;
    } 	DYNAMIC_RENDERER_CACHED_DATA;

#if defined(__cplusplus)
const GUID GUID_GESTURE_DATA = {0x41E4EC0F, 0x26AA, 0x455A, {0x9A, 0xA5, 0x2C, 0xD3, 0x6C, 0xF6, 0x3F, 0xB9}};
const GUID GUID_DYNAMIC_RENDERER_CACHED_DATA = {0xBF531B92, 0x25BF, 0x4A95, {0x89, 0xAD, 0x0E, 0x47, 0x6B, 0x34, 0xB4, 0xF5}};
#endif // of if defined(__cplusplus)


extern RPC_IF_HANDLE __MIDL_itf_rtscom_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rtscom_0000_0000_v0_0_s_ifspec;


#ifndef __TPCRTSLib_LIBRARY_DEFINED__
#define __TPCRTSLib_LIBRARY_DEFINED__

/* library TPCRTSLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_TPCRTSLib;

#ifndef __IRealTimeStylus_INTERFACE_DEFINED__
#define __IRealTimeStylus_INTERFACE_DEFINED__

/* interface IRealTimeStylus */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRealTimeStylus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A8BB5D22-3144-4a7b-93CD-F34A16BE513A")
    IRealTimeStylus : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out BOOL *pfEnable) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ BOOL fEnable) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HWND( 
            /* [retval][out] */ __RPC__out HANDLE_PTR *phwnd) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HWND( 
            /* [in] */ HANDLE_PTR hwnd) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WindowInputRectangle( 
            /* [retval][out] */ __RPC__out RECT *prcWndInputRect) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_WindowInputRectangle( 
            /* [in] */ __RPC__in const RECT *prcWndInputRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStylusSyncPlugin( 
            /* [in] */ ULONG iIndex,
            /* [in] */ __RPC__in_opt IStylusSyncPlugin *piPlugin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStylusSyncPlugin( 
            /* [in] */ ULONG iIndex,
            /* [out][in] */ __RPC__deref_inout_opt IStylusSyncPlugin **ppiPlugin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllStylusSyncPlugins( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStylusSyncPlugin( 
            /* [in] */ ULONG iIndex,
            /* [out] */ __RPC__deref_out_opt IStylusSyncPlugin **ppiPlugin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStylusSyncPluginCount( 
            /* [out] */ __RPC__out ULONG *pcPlugins) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStylusAsyncPlugin( 
            /* [in] */ ULONG iIndex,
            /* [in] */ __RPC__in_opt IStylusAsyncPlugin *piPlugin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStylusAsyncPlugin( 
            /* [in] */ ULONG iIndex,
            /* [out][in] */ __RPC__deref_inout_opt IStylusAsyncPlugin **ppiPlugin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllStylusAsyncPlugins( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStylusAsyncPlugin( 
            /* [in] */ ULONG iIndex,
            /* [out] */ __RPC__deref_out_opt IStylusAsyncPlugin **ppiPlugin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStylusAsyncPluginCount( 
            /* [out] */ __RPC__out ULONG *pcPlugins) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ChildRealTimeStylusPlugin( 
            /* [retval][out] */ __RPC__deref_out_opt IRealTimeStylus **ppiRTS) = 0;
        
        virtual /* [propputref] */ HRESULT STDMETHODCALLTYPE putref_ChildRealTimeStylusPlugin( 
            /* [unique][in] */ __RPC__in_opt IRealTimeStylus *piRTS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddCustomStylusDataToQueue( 
            /* [in] */ StylusQueue sq,
            /* [in] */ __RPC__in const GUID *pGuidId,
            /* [range][in] */ __RPC__in_range(0,0x7fff) ULONG cbData,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cbData) BYTE *pbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearStylusQueues( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllTabletsMode( 
            /* [in] */ BOOL fUseMouseForInput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSingleTabletMode( 
            /* [in] */ __RPC__in_opt IInkTablet *piTablet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTablet( 
            /* [retval][out] */ __RPC__deref_out_opt IInkTablet **ppiSingleTablet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTabletContextIdFromTablet( 
            /* [in] */ __RPC__in_opt IInkTablet *piTablet,
            /* [retval][out] */ __RPC__out TABLET_CONTEXT_ID *ptcid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTabletFromTabletContextId( 
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [retval][out] */ __RPC__deref_out_opt IInkTablet **ppiTablet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllTabletContextIds( 
            /* [out][in] */ __RPC__inout ULONG *pcTcidCount,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcTcidCount) TABLET_CONTEXT_ID **ppTcids) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStyluses( 
            /* [retval][out] */ __RPC__deref_out_opt IInkCursors **ppiInkCursors) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStylusForId( 
            /* [in] */ STYLUS_ID sid,
            /* [retval][out] */ __RPC__deref_out_opt IInkCursor **ppiInkCursor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDesiredPacketDescription( 
            /* [range][in] */ __RPC__in_range(0,32) ULONG cProperties,
            /* [size_is][in] */ __RPC__in_ecount_full(cProperties) const GUID *pPropertyGuids) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDesiredPacketDescription( 
            /* [out][in] */ __RPC__inout ULONG *pcProperties,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcProperties) GUID **ppPropertyGuids) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPacketDescriptionData( 
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [unique][out][in] */ __RPC__inout_opt FLOAT *pfInkToDeviceScaleX,
            /* [unique][out][in] */ __RPC__inout_opt FLOAT *pfInkToDeviceScaleY,
            /* [out][in] */ __RPC__inout ULONG *pcPacketProperties,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcPacketProperties) PACKET_PROPERTY **ppPacketProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRealTimeStylusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRealTimeStylus * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRealTimeStylus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRealTimeStylus * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            __RPC__in IRealTimeStylus * This,
            /* [retval][out] */ __RPC__out BOOL *pfEnable);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            __RPC__in IRealTimeStylus * This,
            /* [in] */ BOOL fEnable);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HWND )( 
            __RPC__in IRealTimeStylus * This,
            /* [retval][out] */ __RPC__out HANDLE_PTR *phwnd);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HWND )( 
            __RPC__in IRealTimeStylus * This,
            /* [in] */ HANDLE_PTR hwnd);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WindowInputRectangle )( 
            __RPC__in IRealTimeStylus * This,
            /* [retval][out] */ __RPC__out RECT *prcWndInputRect);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_WindowInputRectangle )( 
            __RPC__in IRealTimeStylus * This,
            /* [in] */ __RPC__in const RECT *prcWndInputRect);
        
        HRESULT ( STDMETHODCALLTYPE *AddStylusSyncPlugin )( 
            __RPC__in IRealTimeStylus * This,
            /* [in] */ ULONG iIndex,
            /* [in] */ __RPC__in_opt IStylusSyncPlugin *piPlugin);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStylusSyncPlugin )( 
            __RPC__in IRealTimeStylus * This,
            /* [in] */ ULONG iIndex,
            /* [out][in] */ __RPC__deref_inout_opt IStylusSyncPlugin **ppiPlugin);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAllStylusSyncPlugins )( 
            __RPC__in IRealTimeStylus * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStylusSyncPlugin )( 
            __RPC__in IRealTimeStylus * This,
            /* [in] */ ULONG iIndex,
            /* [out] */ __RPC__deref_out_opt IStylusSyncPlugin **ppiPlugin);
        
        HRESULT ( STDMETHODCALLTYPE *GetStylusSyncPluginCount )( 
            __RPC__in IRealTimeStylus * This,
            /* [out] */ __RPC__out ULONG *pcPlugins);
        
        HRESULT ( STDMETHODCALLTYPE *AddStylusAsyncPlugin )( 
            __RPC__in IRealTimeStylus * This,
            /* [in] */ ULONG iIndex,
            /* [in] */ __RPC__in_opt IStylusAsyncPlugin *piPlugin);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStylusAsyncPlugin )( 
            __RPC__in IRealTimeStylus * This,
            /* [in] */ ULONG iIndex,
            /* [out][in] */ __RPC__deref_inout_opt IStylusAsyncPlugin **ppiPlugin);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAllStylusAsyncPlugins )( 
            __RPC__in IRealTimeStylus * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStylusAsyncPlugin )( 
            __RPC__in IRealTimeStylus * This,
            /* [in] */ ULONG iIndex,
            /* [out] */ __RPC__deref_out_opt IStylusAsyncPlugin **ppiPlugin);
        
        HRESULT ( STDMETHODCALLTYPE *GetStylusAsyncPluginCount )( 
            __RPC__in IRealTimeStylus * This,
            /* [out] */ __RPC__out ULONG *pcPlugins);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ChildRealTimeStylusPlugin )( 
            __RPC__in IRealTimeStylus * This,
            /* [retval][out] */ __RPC__deref_out_opt IRealTimeStylus **ppiRTS);
        
        /* [propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_ChildRealTimeStylusPlugin )( 
            __RPC__in IRealTimeStylus * This,
            /* [unique][in] */ __RPC__in_opt IRealTimeStylus *piRTS);
        
        HRESULT ( STDMETHODCALLTYPE *AddCustomStylusDataToQueue )( 
            __RPC__in IRealTimeStylus * This,
            /* [in] */ StylusQueue sq,
            /* [in] */ __RPC__in const GUID *pGuidId,
            /* [range][in] */ __RPC__in_range(0,0x7fff) ULONG cbData,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cbData) BYTE *pbData);
        
        HRESULT ( STDMETHODCALLTYPE *ClearStylusQueues )( 
            __RPC__in IRealTimeStylus * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllTabletsMode )( 
            __RPC__in IRealTimeStylus * This,
            /* [in] */ BOOL fUseMouseForInput);
        
        HRESULT ( STDMETHODCALLTYPE *SetSingleTabletMode )( 
            __RPC__in IRealTimeStylus * This,
            /* [in] */ __RPC__in_opt IInkTablet *piTablet);
        
        HRESULT ( STDMETHODCALLTYPE *GetTablet )( 
            __RPC__in IRealTimeStylus * This,
            /* [retval][out] */ __RPC__deref_out_opt IInkTablet **ppiSingleTablet);
        
        HRESULT ( STDMETHODCALLTYPE *GetTabletContextIdFromTablet )( 
            __RPC__in IRealTimeStylus * This,
            /* [in] */ __RPC__in_opt IInkTablet *piTablet,
            /* [retval][out] */ __RPC__out TABLET_CONTEXT_ID *ptcid);
        
        HRESULT ( STDMETHODCALLTYPE *GetTabletFromTabletContextId )( 
            __RPC__in IRealTimeStylus * This,
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [retval][out] */ __RPC__deref_out_opt IInkTablet **ppiTablet);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllTabletContextIds )( 
            __RPC__in IRealTimeStylus * This,
            /* [out][in] */ __RPC__inout ULONG *pcTcidCount,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcTcidCount) TABLET_CONTEXT_ID **ppTcids);
        
        HRESULT ( STDMETHODCALLTYPE *GetStyluses )( 
            __RPC__in IRealTimeStylus * This,
            /* [retval][out] */ __RPC__deref_out_opt IInkCursors **ppiInkCursors);
        
        HRESULT ( STDMETHODCALLTYPE *GetStylusForId )( 
            __RPC__in IRealTimeStylus * This,
            /* [in] */ STYLUS_ID sid,
            /* [retval][out] */ __RPC__deref_out_opt IInkCursor **ppiInkCursor);
        
        HRESULT ( STDMETHODCALLTYPE *SetDesiredPacketDescription )( 
            __RPC__in IRealTimeStylus * This,
            /* [range][in] */ __RPC__in_range(0,32) ULONG cProperties,
            /* [size_is][in] */ __RPC__in_ecount_full(cProperties) const GUID *pPropertyGuids);
        
        HRESULT ( STDMETHODCALLTYPE *GetDesiredPacketDescription )( 
            __RPC__in IRealTimeStylus * This,
            /* [out][in] */ __RPC__inout ULONG *pcProperties,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcProperties) GUID **ppPropertyGuids);
        
        HRESULT ( STDMETHODCALLTYPE *GetPacketDescriptionData )( 
            __RPC__in IRealTimeStylus * This,
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [unique][out][in] */ __RPC__inout_opt FLOAT *pfInkToDeviceScaleX,
            /* [unique][out][in] */ __RPC__inout_opt FLOAT *pfInkToDeviceScaleY,
            /* [out][in] */ __RPC__inout ULONG *pcPacketProperties,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcPacketProperties) PACKET_PROPERTY **ppPacketProperties);
        
        END_INTERFACE
    } IRealTimeStylusVtbl;

    interface IRealTimeStylus
    {
        CONST_VTBL struct IRealTimeStylusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRealTimeStylus_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRealTimeStylus_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRealTimeStylus_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRealTimeStylus_get_Enabled(This,pfEnable)	\
    ( (This)->lpVtbl -> get_Enabled(This,pfEnable) ) 

#define IRealTimeStylus_put_Enabled(This,fEnable)	\
    ( (This)->lpVtbl -> put_Enabled(This,fEnable) ) 

#define IRealTimeStylus_get_HWND(This,phwnd)	\
    ( (This)->lpVtbl -> get_HWND(This,phwnd) ) 

#define IRealTimeStylus_put_HWND(This,hwnd)	\
    ( (This)->lpVtbl -> put_HWND(This,hwnd) ) 

#define IRealTimeStylus_get_WindowInputRectangle(This,prcWndInputRect)	\
    ( (This)->lpVtbl -> get_WindowInputRectangle(This,prcWndInputRect) ) 

#define IRealTimeStylus_put_WindowInputRectangle(This,prcWndInputRect)	\
    ( (This)->lpVtbl -> put_WindowInputRectangle(This,prcWndInputRect) ) 

#define IRealTimeStylus_AddStylusSyncPlugin(This,iIndex,piPlugin)	\
    ( (This)->lpVtbl -> AddStylusSyncPlugin(This,iIndex,piPlugin) ) 

#define IRealTimeStylus_RemoveStylusSyncPlugin(This,iIndex,ppiPlugin)	\
    ( (This)->lpVtbl -> RemoveStylusSyncPlugin(This,iIndex,ppiPlugin) ) 

#define IRealTimeStylus_RemoveAllStylusSyncPlugins(This)	\
    ( (This)->lpVtbl -> RemoveAllStylusSyncPlugins(This) ) 

#define IRealTimeStylus_GetStylusSyncPlugin(This,iIndex,ppiPlugin)	\
    ( (This)->lpVtbl -> GetStylusSyncPlugin(This,iIndex,ppiPlugin) ) 

#define IRealTimeStylus_GetStylusSyncPluginCount(This,pcPlugins)	\
    ( (This)->lpVtbl -> GetStylusSyncPluginCount(This,pcPlugins) ) 

#define IRealTimeStylus_AddStylusAsyncPlugin(This,iIndex,piPlugin)	\
    ( (This)->lpVtbl -> AddStylusAsyncPlugin(This,iIndex,piPlugin) ) 

#define IRealTimeStylus_RemoveStylusAsyncPlugin(This,iIndex,ppiPlugin)	\
    ( (This)->lpVtbl -> RemoveStylusAsyncPlugin(This,iIndex,ppiPlugin) ) 

#define IRealTimeStylus_RemoveAllStylusAsyncPlugins(This)	\
    ( (This)->lpVtbl -> RemoveAllStylusAsyncPlugins(This) ) 

#define IRealTimeStylus_GetStylusAsyncPlugin(This,iIndex,ppiPlugin)	\
    ( (This)->lpVtbl -> GetStylusAsyncPlugin(This,iIndex,ppiPlugin) ) 

#define IRealTimeStylus_GetStylusAsyncPluginCount(This,pcPlugins)	\
    ( (This)->lpVtbl -> GetStylusAsyncPluginCount(This,pcPlugins) ) 

#define IRealTimeStylus_get_ChildRealTimeStylusPlugin(This,ppiRTS)	\
    ( (This)->lpVtbl -> get_ChildRealTimeStylusPlugin(This,ppiRTS) ) 

#define IRealTimeStylus_putref_ChildRealTimeStylusPlugin(This,piRTS)	\
    ( (This)->lpVtbl -> putref_ChildRealTimeStylusPlugin(This,piRTS) ) 

#define IRealTimeStylus_AddCustomStylusDataToQueue(This,sq,pGuidId,cbData,pbData)	\
    ( (This)->lpVtbl -> AddCustomStylusDataToQueue(This,sq,pGuidId,cbData,pbData) ) 

#define IRealTimeStylus_ClearStylusQueues(This)	\
    ( (This)->lpVtbl -> ClearStylusQueues(This) ) 

#define IRealTimeStylus_SetAllTabletsMode(This,fUseMouseForInput)	\
    ( (This)->lpVtbl -> SetAllTabletsMode(This,fUseMouseForInput) ) 

#define IRealTimeStylus_SetSingleTabletMode(This,piTablet)	\
    ( (This)->lpVtbl -> SetSingleTabletMode(This,piTablet) ) 

#define IRealTimeStylus_GetTablet(This,ppiSingleTablet)	\
    ( (This)->lpVtbl -> GetTablet(This,ppiSingleTablet) ) 

#define IRealTimeStylus_GetTabletContextIdFromTablet(This,piTablet,ptcid)	\
    ( (This)->lpVtbl -> GetTabletContextIdFromTablet(This,piTablet,ptcid) ) 

#define IRealTimeStylus_GetTabletFromTabletContextId(This,tcid,ppiTablet)	\
    ( (This)->lpVtbl -> GetTabletFromTabletContextId(This,tcid,ppiTablet) ) 

#define IRealTimeStylus_GetAllTabletContextIds(This,pcTcidCount,ppTcids)	\
    ( (This)->lpVtbl -> GetAllTabletContextIds(This,pcTcidCount,ppTcids) ) 

#define IRealTimeStylus_GetStyluses(This,ppiInkCursors)	\
    ( (This)->lpVtbl -> GetStyluses(This,ppiInkCursors) ) 

#define IRealTimeStylus_GetStylusForId(This,sid,ppiInkCursor)	\
    ( (This)->lpVtbl -> GetStylusForId(This,sid,ppiInkCursor) ) 

#define IRealTimeStylus_SetDesiredPacketDescription(This,cProperties,pPropertyGuids)	\
    ( (This)->lpVtbl -> SetDesiredPacketDescription(This,cProperties,pPropertyGuids) ) 

#define IRealTimeStylus_GetDesiredPacketDescription(This,pcProperties,ppPropertyGuids)	\
    ( (This)->lpVtbl -> GetDesiredPacketDescription(This,pcProperties,ppPropertyGuids) ) 

#define IRealTimeStylus_GetPacketDescriptionData(This,tcid,pfInkToDeviceScaleX,pfInkToDeviceScaleY,pcPacketProperties,ppPacketProperties)	\
    ( (This)->lpVtbl -> GetPacketDescriptionData(This,tcid,pfInkToDeviceScaleX,pfInkToDeviceScaleY,pcPacketProperties,ppPacketProperties) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRealTimeStylus_INTERFACE_DEFINED__ */


#ifndef __IRealTimeStylus2_INTERFACE_DEFINED__
#define __IRealTimeStylus2_INTERFACE_DEFINED__

/* interface IRealTimeStylus2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRealTimeStylus2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B5F2A6CD-3179-4a3e-B9C4-BB5865962BE2")
    IRealTimeStylus2 : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FlicksEnabled( 
            /* [retval][out] */ __RPC__out BOOL *pfEnable) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_FlicksEnabled( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRealTimeStylus2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRealTimeStylus2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRealTimeStylus2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRealTimeStylus2 * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FlicksEnabled )( 
            __RPC__in IRealTimeStylus2 * This,
            /* [retval][out] */ __RPC__out BOOL *pfEnable);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_FlicksEnabled )( 
            __RPC__in IRealTimeStylus2 * This,
            /* [in] */ BOOL fEnable);
        
        END_INTERFACE
    } IRealTimeStylus2Vtbl;

    interface IRealTimeStylus2
    {
        CONST_VTBL struct IRealTimeStylus2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRealTimeStylus2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRealTimeStylus2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRealTimeStylus2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRealTimeStylus2_get_FlicksEnabled(This,pfEnable)	\
    ( (This)->lpVtbl -> get_FlicksEnabled(This,pfEnable) ) 

#define IRealTimeStylus2_put_FlicksEnabled(This,fEnable)	\
    ( (This)->lpVtbl -> put_FlicksEnabled(This,fEnable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRealTimeStylus2_INTERFACE_DEFINED__ */


#ifndef __IRealTimeStylus3_INTERFACE_DEFINED__
#define __IRealTimeStylus3_INTERFACE_DEFINED__

/* interface IRealTimeStylus3 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRealTimeStylus3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D70230A3-6986-4051-B57A-1CF69F4D9DB5")
    IRealTimeStylus3 : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MultiTouchEnabled( 
            /* [retval][out] */ __RPC__out BOOL *pfEnable) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MultiTouchEnabled( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRealTimeStylus3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRealTimeStylus3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRealTimeStylus3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRealTimeStylus3 * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MultiTouchEnabled )( 
            __RPC__in IRealTimeStylus3 * This,
            /* [retval][out] */ __RPC__out BOOL *pfEnable);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MultiTouchEnabled )( 
            __RPC__in IRealTimeStylus3 * This,
            /* [in] */ BOOL fEnable);
        
        END_INTERFACE
    } IRealTimeStylus3Vtbl;

    interface IRealTimeStylus3
    {
        CONST_VTBL struct IRealTimeStylus3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRealTimeStylus3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRealTimeStylus3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRealTimeStylus3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRealTimeStylus3_get_MultiTouchEnabled(This,pfEnable)	\
    ( (This)->lpVtbl -> get_MultiTouchEnabled(This,pfEnable) ) 

#define IRealTimeStylus3_put_MultiTouchEnabled(This,fEnable)	\
    ( (This)->lpVtbl -> put_MultiTouchEnabled(This,fEnable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRealTimeStylus3_INTERFACE_DEFINED__ */


#ifndef __IRealTimeStylusSynchronization_INTERFACE_DEFINED__
#define __IRealTimeStylusSynchronization_INTERFACE_DEFINED__

/* interface IRealTimeStylusSynchronization */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRealTimeStylusSynchronization;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA87EAB8-AB4A-4cea-B5CB-46D84C6A2509")
    IRealTimeStylusSynchronization : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AcquireLock( 
            /* [in] */ RealTimeStylusLockType lock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseLock( 
            /* [in] */ RealTimeStylusLockType lock) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRealTimeStylusSynchronizationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRealTimeStylusSynchronization * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRealTimeStylusSynchronization * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRealTimeStylusSynchronization * This);
        
        HRESULT ( STDMETHODCALLTYPE *AcquireLock )( 
            __RPC__in IRealTimeStylusSynchronization * This,
            /* [in] */ RealTimeStylusLockType lock);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseLock )( 
            __RPC__in IRealTimeStylusSynchronization * This,
            /* [in] */ RealTimeStylusLockType lock);
        
        END_INTERFACE
    } IRealTimeStylusSynchronizationVtbl;

    interface IRealTimeStylusSynchronization
    {
        CONST_VTBL struct IRealTimeStylusSynchronizationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRealTimeStylusSynchronization_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRealTimeStylusSynchronization_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRealTimeStylusSynchronization_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRealTimeStylusSynchronization_AcquireLock(This,lock)	\
    ( (This)->lpVtbl -> AcquireLock(This,lock) ) 

#define IRealTimeStylusSynchronization_ReleaseLock(This,lock)	\
    ( (This)->lpVtbl -> ReleaseLock(This,lock) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRealTimeStylusSynchronization_INTERFACE_DEFINED__ */


#ifndef __IStrokeBuilder_INTERFACE_DEFINED__
#define __IStrokeBuilder_INTERFACE_DEFINED__

/* interface IStrokeBuilder */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IStrokeBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A5FD4E2D-C44B-4092-9177-260905EB672B")
    IStrokeBuilder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateStroke( 
            /* [range][in] */ __RPC__in_range(0,0xfffff) ULONG cPktBuffLength,
            /* [size_is][in] */ __RPC__in_ecount_full(cPktBuffLength) const LONG *pPackets,
            /* [range][in] */ __RPC__in_range(0,32) ULONG cPacketProperties,
            /* [size_is][in] */ __RPC__in_ecount_full(cPacketProperties) const PACKET_PROPERTY *pPacketProperties,
            /* [in] */ FLOAT fInkToDeviceScaleX,
            /* [in] */ FLOAT fInkToDeviceScaleY,
            /* [out][in] */ __RPC__deref_inout_opt IInkStrokeDisp **ppIInkStroke) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginStroke( 
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [in] */ STYLUS_ID sid,
            /* [in] */ __RPC__in const LONG *pPacket,
            /* [range][in] */ __RPC__in_range(0,32) ULONG cPacketProperties,
            /* [size_is][in] */ __RPC__in_ecount_full(cPacketProperties) PACKET_PROPERTY *pPacketProperties,
            /* [in] */ FLOAT fInkToDeviceScaleX,
            /* [in] */ FLOAT fInkToDeviceScaleY,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt IInkStrokeDisp **ppIInkStroke) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppendPackets( 
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [in] */ STYLUS_ID sid,
            /* [range][in] */ __RPC__in_range(0,0x7fff) ULONG cPktBuffLength,
            /* [size_is][in] */ __RPC__in_ecount_full(cPktBuffLength) const LONG *pPackets) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndStroke( 
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [in] */ STYLUS_ID sid,
            /* [out][in] */ __RPC__deref_inout_opt IInkStrokeDisp **ppIInkStroke,
            /* [out][in] */ __RPC__inout RECT *pDirtyRect) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Ink( 
            /* [retval][out] */ __RPC__deref_out_opt IInkDisp **ppiInkObj) = 0;
        
        virtual /* [propputref] */ HRESULT STDMETHODCALLTYPE putref_Ink( 
            /* [in] */ __RPC__in_opt IInkDisp *piInkObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStrokeBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStrokeBuilder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStrokeBuilder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStrokeBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStroke )( 
            __RPC__in IStrokeBuilder * This,
            /* [range][in] */ __RPC__in_range(0,0xfffff) ULONG cPktBuffLength,
            /* [size_is][in] */ __RPC__in_ecount_full(cPktBuffLength) const LONG *pPackets,
            /* [range][in] */ __RPC__in_range(0,32) ULONG cPacketProperties,
            /* [size_is][in] */ __RPC__in_ecount_full(cPacketProperties) const PACKET_PROPERTY *pPacketProperties,
            /* [in] */ FLOAT fInkToDeviceScaleX,
            /* [in] */ FLOAT fInkToDeviceScaleY,
            /* [out][in] */ __RPC__deref_inout_opt IInkStrokeDisp **ppIInkStroke);
        
        HRESULT ( STDMETHODCALLTYPE *BeginStroke )( 
            __RPC__in IStrokeBuilder * This,
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [in] */ STYLUS_ID sid,
            /* [in] */ __RPC__in const LONG *pPacket,
            /* [range][in] */ __RPC__in_range(0,32) ULONG cPacketProperties,
            /* [size_is][in] */ __RPC__in_ecount_full(cPacketProperties) PACKET_PROPERTY *pPacketProperties,
            /* [in] */ FLOAT fInkToDeviceScaleX,
            /* [in] */ FLOAT fInkToDeviceScaleY,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt IInkStrokeDisp **ppIInkStroke);
        
        HRESULT ( STDMETHODCALLTYPE *AppendPackets )( 
            __RPC__in IStrokeBuilder * This,
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [in] */ STYLUS_ID sid,
            /* [range][in] */ __RPC__in_range(0,0x7fff) ULONG cPktBuffLength,
            /* [size_is][in] */ __RPC__in_ecount_full(cPktBuffLength) const LONG *pPackets);
        
        HRESULT ( STDMETHODCALLTYPE *EndStroke )( 
            __RPC__in IStrokeBuilder * This,
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [in] */ STYLUS_ID sid,
            /* [out][in] */ __RPC__deref_inout_opt IInkStrokeDisp **ppIInkStroke,
            /* [out][in] */ __RPC__inout RECT *pDirtyRect);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Ink )( 
            __RPC__in IStrokeBuilder * This,
            /* [retval][out] */ __RPC__deref_out_opt IInkDisp **ppiInkObj);
        
        /* [propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_Ink )( 
            __RPC__in IStrokeBuilder * This,
            /* [in] */ __RPC__in_opt IInkDisp *piInkObj);
        
        END_INTERFACE
    } IStrokeBuilderVtbl;

    interface IStrokeBuilder
    {
        CONST_VTBL struct IStrokeBuilderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStrokeBuilder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStrokeBuilder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStrokeBuilder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStrokeBuilder_CreateStroke(This,cPktBuffLength,pPackets,cPacketProperties,pPacketProperties,fInkToDeviceScaleX,fInkToDeviceScaleY,ppIInkStroke)	\
    ( (This)->lpVtbl -> CreateStroke(This,cPktBuffLength,pPackets,cPacketProperties,pPacketProperties,fInkToDeviceScaleX,fInkToDeviceScaleY,ppIInkStroke) ) 

#define IStrokeBuilder_BeginStroke(This,tcid,sid,pPacket,cPacketProperties,pPacketProperties,fInkToDeviceScaleX,fInkToDeviceScaleY,ppIInkStroke)	\
    ( (This)->lpVtbl -> BeginStroke(This,tcid,sid,pPacket,cPacketProperties,pPacketProperties,fInkToDeviceScaleX,fInkToDeviceScaleY,ppIInkStroke) ) 

#define IStrokeBuilder_AppendPackets(This,tcid,sid,cPktBuffLength,pPackets)	\
    ( (This)->lpVtbl -> AppendPackets(This,tcid,sid,cPktBuffLength,pPackets) ) 

#define IStrokeBuilder_EndStroke(This,tcid,sid,ppIInkStroke,pDirtyRect)	\
    ( (This)->lpVtbl -> EndStroke(This,tcid,sid,ppIInkStroke,pDirtyRect) ) 

#define IStrokeBuilder_get_Ink(This,ppiInkObj)	\
    ( (This)->lpVtbl -> get_Ink(This,ppiInkObj) ) 

#define IStrokeBuilder_putref_Ink(This,piInkObj)	\
    ( (This)->lpVtbl -> putref_Ink(This,piInkObj) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStrokeBuilder_INTERFACE_DEFINED__ */


#ifndef __IStylusPlugin_INTERFACE_DEFINED__
#define __IStylusPlugin_INTERFACE_DEFINED__

/* interface IStylusPlugin */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IStylusPlugin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A81436D8-4757-4fd1-A185-133F97C6C545")
    IStylusPlugin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RealTimeStylusEnabled( 
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [range][in] */ __RPC__in_range(0,8) ULONG cTcidCount,
            /* [size_is][in] */ __RPC__in_ecount_full(cTcidCount) const TABLET_CONTEXT_ID *pTcids) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RealTimeStylusDisabled( 
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [range][in] */ __RPC__in_range(0,8) ULONG cTcidCount,
            /* [size_is][in] */ __RPC__in_ecount_full(cTcidCount) const TABLET_CONTEXT_ID *pTcids) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StylusInRange( 
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [in] */ STYLUS_ID sid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StylusOutOfRange( 
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [in] */ STYLUS_ID sid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StylusDown( 
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in const StylusInfo *pStylusInfo,
            /* [range][in] */ __RPC__in_range(0,32) ULONG cPropCountPerPkt,
            /* [size_is][in] */ __RPC__in_ecount_full(cPropCountPerPkt) LONG *pPacket,
            /* [out][in] */ __RPC__deref_inout_opt LONG **ppInOutPkt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StylusUp( 
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in const StylusInfo *pStylusInfo,
            /* [range][in] */ __RPC__in_range(0,32) ULONG cPropCountPerPkt,
            /* [size_is][in] */ __RPC__in_ecount_full(cPropCountPerPkt) LONG *pPacket,
            /* [out][in] */ __RPC__deref_inout_opt LONG **ppInOutPkt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StylusButtonDown( 
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ STYLUS_ID sid,
            /* [in] */ __RPC__in const GUID *pGuidStylusButton,
            /* [out][in] */ __RPC__inout POINT *pStylusPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StylusButtonUp( 
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ STYLUS_ID sid,
            /* [in] */ __RPC__in const GUID *pGuidStylusButton,
            /* [out][in] */ __RPC__inout POINT *pStylusPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InAirPackets( 
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in const StylusInfo *pStylusInfo,
            /* [in] */ ULONG cPktCount,
            /* [range][in] */ __RPC__in_range(0,0x7fff) ULONG cPktBuffLength,
            /* [size_is][in] */ __RPC__in_ecount_full(cPktBuffLength) LONG *pPackets,
            /* [out][in] */ __RPC__inout ULONG *pcInOutPkts,
            /* [out][in] */ __RPC__deref_inout_opt LONG **ppInOutPkts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Packets( 
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in const StylusInfo *pStylusInfo,
            /* [in] */ ULONG cPktCount,
            /* [range][in] */ __RPC__in_range(0,0x7fff) ULONG cPktBuffLength,
            /* [size_is][in] */ __RPC__in_ecount_full(cPktBuffLength) LONG *pPackets,
            /* [out][in] */ __RPC__inout ULONG *pcInOutPkts,
            /* [out][in] */ __RPC__deref_inout_opt LONG **ppInOutPkts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CustomStylusDataAdded( 
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in const GUID *pGuidId,
            /* [range][in] */ __RPC__in_range(0,0x7fff) ULONG cbData,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cbData) const BYTE *pbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SystemEvent( 
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [in] */ STYLUS_ID sid,
            /* [in] */ SYSTEM_EVENT event,
            /* [in] */ SYSTEM_EVENT_DATA eventdata) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TabletAdded( 
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in_opt IInkTablet *piTablet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TabletRemoved( 
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ LONG iTabletIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Error( 
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in_opt IStylusPlugin *piPlugin,
            /* [in] */ RealTimeStylusDataInterest dataInterest,
            /* [in] */ HRESULT hrErrorCode,
            /* [out][in] */ __RPC__inout LONG_PTR *lptrKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateMapping( 
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DataInterest( 
            /* [retval][out] */ __RPC__out RealTimeStylusDataInterest *pDataInterest) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStylusPluginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStylusPlugin * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStylusPlugin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStylusPlugin * This);
        
        HRESULT ( STDMETHODCALLTYPE *RealTimeStylusEnabled )( 
            __RPC__in IStylusPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [range][in] */ __RPC__in_range(0,8) ULONG cTcidCount,
            /* [size_is][in] */ __RPC__in_ecount_full(cTcidCount) const TABLET_CONTEXT_ID *pTcids);
        
        HRESULT ( STDMETHODCALLTYPE *RealTimeStylusDisabled )( 
            __RPC__in IStylusPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [range][in] */ __RPC__in_range(0,8) ULONG cTcidCount,
            /* [size_is][in] */ __RPC__in_ecount_full(cTcidCount) const TABLET_CONTEXT_ID *pTcids);
        
        HRESULT ( STDMETHODCALLTYPE *StylusInRange )( 
            __RPC__in IStylusPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [in] */ STYLUS_ID sid);
        
        HRESULT ( STDMETHODCALLTYPE *StylusOutOfRange )( 
            __RPC__in IStylusPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [in] */ STYLUS_ID sid);
        
        HRESULT ( STDMETHODCALLTYPE *StylusDown )( 
            __RPC__in IStylusPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in const StylusInfo *pStylusInfo,
            /* [range][in] */ __RPC__in_range(0,32) ULONG cPropCountPerPkt,
            /* [size_is][in] */ __RPC__in_ecount_full(cPropCountPerPkt) LONG *pPacket,
            /* [out][in] */ __RPC__deref_inout_opt LONG **ppInOutPkt);
        
        HRESULT ( STDMETHODCALLTYPE *StylusUp )( 
            __RPC__in IStylusPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in const StylusInfo *pStylusInfo,
            /* [range][in] */ __RPC__in_range(0,32) ULONG cPropCountPerPkt,
            /* [size_is][in] */ __RPC__in_ecount_full(cPropCountPerPkt) LONG *pPacket,
            /* [out][in] */ __RPC__deref_inout_opt LONG **ppInOutPkt);
        
        HRESULT ( STDMETHODCALLTYPE *StylusButtonDown )( 
            __RPC__in IStylusPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ STYLUS_ID sid,
            /* [in] */ __RPC__in const GUID *pGuidStylusButton,
            /* [out][in] */ __RPC__inout POINT *pStylusPos);
        
        HRESULT ( STDMETHODCALLTYPE *StylusButtonUp )( 
            __RPC__in IStylusPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ STYLUS_ID sid,
            /* [in] */ __RPC__in const GUID *pGuidStylusButton,
            /* [out][in] */ __RPC__inout POINT *pStylusPos);
        
        HRESULT ( STDMETHODCALLTYPE *InAirPackets )( 
            __RPC__in IStylusPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in const StylusInfo *pStylusInfo,
            /* [in] */ ULONG cPktCount,
            /* [range][in] */ __RPC__in_range(0,0x7fff) ULONG cPktBuffLength,
            /* [size_is][in] */ __RPC__in_ecount_full(cPktBuffLength) LONG *pPackets,
            /* [out][in] */ __RPC__inout ULONG *pcInOutPkts,
            /* [out][in] */ __RPC__deref_inout_opt LONG **ppInOutPkts);
        
        HRESULT ( STDMETHODCALLTYPE *Packets )( 
            __RPC__in IStylusPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in const StylusInfo *pStylusInfo,
            /* [in] */ ULONG cPktCount,
            /* [range][in] */ __RPC__in_range(0,0x7fff) ULONG cPktBuffLength,
            /* [size_is][in] */ __RPC__in_ecount_full(cPktBuffLength) LONG *pPackets,
            /* [out][in] */ __RPC__inout ULONG *pcInOutPkts,
            /* [out][in] */ __RPC__deref_inout_opt LONG **ppInOutPkts);
        
        HRESULT ( STDMETHODCALLTYPE *CustomStylusDataAdded )( 
            __RPC__in IStylusPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in const GUID *pGuidId,
            /* [range][in] */ __RPC__in_range(0,0x7fff) ULONG cbData,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cbData) const BYTE *pbData);
        
        HRESULT ( STDMETHODCALLTYPE *SystemEvent )( 
            __RPC__in IStylusPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [in] */ STYLUS_ID sid,
            /* [in] */ SYSTEM_EVENT event,
            /* [in] */ SYSTEM_EVENT_DATA eventdata);
        
        HRESULT ( STDMETHODCALLTYPE *TabletAdded )( 
            __RPC__in IStylusPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in_opt IInkTablet *piTablet);
        
        HRESULT ( STDMETHODCALLTYPE *TabletRemoved )( 
            __RPC__in IStylusPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ LONG iTabletIndex);
        
        HRESULT ( STDMETHODCALLTYPE *Error )( 
            __RPC__in IStylusPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in_opt IStylusPlugin *piPlugin,
            /* [in] */ RealTimeStylusDataInterest dataInterest,
            /* [in] */ HRESULT hrErrorCode,
            /* [out][in] */ __RPC__inout LONG_PTR *lptrKey);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateMapping )( 
            __RPC__in IStylusPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc);
        
        HRESULT ( STDMETHODCALLTYPE *DataInterest )( 
            __RPC__in IStylusPlugin * This,
            /* [retval][out] */ __RPC__out RealTimeStylusDataInterest *pDataInterest);
        
        END_INTERFACE
    } IStylusPluginVtbl;

    interface IStylusPlugin
    {
        CONST_VTBL struct IStylusPluginVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStylusPlugin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStylusPlugin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStylusPlugin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStylusPlugin_RealTimeStylusEnabled(This,piRtsSrc,cTcidCount,pTcids)	\
    ( (This)->lpVtbl -> RealTimeStylusEnabled(This,piRtsSrc,cTcidCount,pTcids) ) 

#define IStylusPlugin_RealTimeStylusDisabled(This,piRtsSrc,cTcidCount,pTcids)	\
    ( (This)->lpVtbl -> RealTimeStylusDisabled(This,piRtsSrc,cTcidCount,pTcids) ) 

#define IStylusPlugin_StylusInRange(This,piRtsSrc,tcid,sid)	\
    ( (This)->lpVtbl -> StylusInRange(This,piRtsSrc,tcid,sid) ) 

#define IStylusPlugin_StylusOutOfRange(This,piRtsSrc,tcid,sid)	\
    ( (This)->lpVtbl -> StylusOutOfRange(This,piRtsSrc,tcid,sid) ) 

#define IStylusPlugin_StylusDown(This,piRtsSrc,pStylusInfo,cPropCountPerPkt,pPacket,ppInOutPkt)	\
    ( (This)->lpVtbl -> StylusDown(This,piRtsSrc,pStylusInfo,cPropCountPerPkt,pPacket,ppInOutPkt) ) 

#define IStylusPlugin_StylusUp(This,piRtsSrc,pStylusInfo,cPropCountPerPkt,pPacket,ppInOutPkt)	\
    ( (This)->lpVtbl -> StylusUp(This,piRtsSrc,pStylusInfo,cPropCountPerPkt,pPacket,ppInOutPkt) ) 

#define IStylusPlugin_StylusButtonDown(This,piRtsSrc,sid,pGuidStylusButton,pStylusPos)	\
    ( (This)->lpVtbl -> StylusButtonDown(This,piRtsSrc,sid,pGuidStylusButton,pStylusPos) ) 

#define IStylusPlugin_StylusButtonUp(This,piRtsSrc,sid,pGuidStylusButton,pStylusPos)	\
    ( (This)->lpVtbl -> StylusButtonUp(This,piRtsSrc,sid,pGuidStylusButton,pStylusPos) ) 

#define IStylusPlugin_InAirPackets(This,piRtsSrc,pStylusInfo,cPktCount,cPktBuffLength,pPackets,pcInOutPkts,ppInOutPkts)	\
    ( (This)->lpVtbl -> InAirPackets(This,piRtsSrc,pStylusInfo,cPktCount,cPktBuffLength,pPackets,pcInOutPkts,ppInOutPkts) ) 

#define IStylusPlugin_Packets(This,piRtsSrc,pStylusInfo,cPktCount,cPktBuffLength,pPackets,pcInOutPkts,ppInOutPkts)	\
    ( (This)->lpVtbl -> Packets(This,piRtsSrc,pStylusInfo,cPktCount,cPktBuffLength,pPackets,pcInOutPkts,ppInOutPkts) ) 

#define IStylusPlugin_CustomStylusDataAdded(This,piRtsSrc,pGuidId,cbData,pbData)	\
    ( (This)->lpVtbl -> CustomStylusDataAdded(This,piRtsSrc,pGuidId,cbData,pbData) ) 

#define IStylusPlugin_SystemEvent(This,piRtsSrc,tcid,sid,event,eventdata)	\
    ( (This)->lpVtbl -> SystemEvent(This,piRtsSrc,tcid,sid,event,eventdata) ) 

#define IStylusPlugin_TabletAdded(This,piRtsSrc,piTablet)	\
    ( (This)->lpVtbl -> TabletAdded(This,piRtsSrc,piTablet) ) 

#define IStylusPlugin_TabletRemoved(This,piRtsSrc,iTabletIndex)	\
    ( (This)->lpVtbl -> TabletRemoved(This,piRtsSrc,iTabletIndex) ) 

#define IStylusPlugin_Error(This,piRtsSrc,piPlugin,dataInterest,hrErrorCode,lptrKey)	\
    ( (This)->lpVtbl -> Error(This,piRtsSrc,piPlugin,dataInterest,hrErrorCode,lptrKey) ) 

#define IStylusPlugin_UpdateMapping(This,piRtsSrc)	\
    ( (This)->lpVtbl -> UpdateMapping(This,piRtsSrc) ) 

#define IStylusPlugin_DataInterest(This,pDataInterest)	\
    ( (This)->lpVtbl -> DataInterest(This,pDataInterest) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStylusPlugin_INTERFACE_DEFINED__ */


#ifndef __IStylusSyncPlugin_INTERFACE_DEFINED__
#define __IStylusSyncPlugin_INTERFACE_DEFINED__

/* interface IStylusSyncPlugin */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IStylusSyncPlugin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A157B174-482F-4d71-A3F6-3A41DDD11BE9")
    IStylusSyncPlugin : public IStylusPlugin
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IStylusSyncPluginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStylusSyncPlugin * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStylusSyncPlugin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStylusSyncPlugin * This);
        
        HRESULT ( STDMETHODCALLTYPE *RealTimeStylusEnabled )( 
            __RPC__in IStylusSyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [range][in] */ __RPC__in_range(0,8) ULONG cTcidCount,
            /* [size_is][in] */ __RPC__in_ecount_full(cTcidCount) const TABLET_CONTEXT_ID *pTcids);
        
        HRESULT ( STDMETHODCALLTYPE *RealTimeStylusDisabled )( 
            __RPC__in IStylusSyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [range][in] */ __RPC__in_range(0,8) ULONG cTcidCount,
            /* [size_is][in] */ __RPC__in_ecount_full(cTcidCount) const TABLET_CONTEXT_ID *pTcids);
        
        HRESULT ( STDMETHODCALLTYPE *StylusInRange )( 
            __RPC__in IStylusSyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [in] */ STYLUS_ID sid);
        
        HRESULT ( STDMETHODCALLTYPE *StylusOutOfRange )( 
            __RPC__in IStylusSyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [in] */ STYLUS_ID sid);
        
        HRESULT ( STDMETHODCALLTYPE *StylusDown )( 
            __RPC__in IStylusSyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in const StylusInfo *pStylusInfo,
            /* [range][in] */ __RPC__in_range(0,32) ULONG cPropCountPerPkt,
            /* [size_is][in] */ __RPC__in_ecount_full(cPropCountPerPkt) LONG *pPacket,
            /* [out][in] */ __RPC__deref_inout_opt LONG **ppInOutPkt);
        
        HRESULT ( STDMETHODCALLTYPE *StylusUp )( 
            __RPC__in IStylusSyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in const StylusInfo *pStylusInfo,
            /* [range][in] */ __RPC__in_range(0,32) ULONG cPropCountPerPkt,
            /* [size_is][in] */ __RPC__in_ecount_full(cPropCountPerPkt) LONG *pPacket,
            /* [out][in] */ __RPC__deref_inout_opt LONG **ppInOutPkt);
        
        HRESULT ( STDMETHODCALLTYPE *StylusButtonDown )( 
            __RPC__in IStylusSyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ STYLUS_ID sid,
            /* [in] */ __RPC__in const GUID *pGuidStylusButton,
            /* [out][in] */ __RPC__inout POINT *pStylusPos);
        
        HRESULT ( STDMETHODCALLTYPE *StylusButtonUp )( 
            __RPC__in IStylusSyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ STYLUS_ID sid,
            /* [in] */ __RPC__in const GUID *pGuidStylusButton,
            /* [out][in] */ __RPC__inout POINT *pStylusPos);
        
        HRESULT ( STDMETHODCALLTYPE *InAirPackets )( 
            __RPC__in IStylusSyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in const StylusInfo *pStylusInfo,
            /* [in] */ ULONG cPktCount,
            /* [range][in] */ __RPC__in_range(0,0x7fff) ULONG cPktBuffLength,
            /* [size_is][in] */ __RPC__in_ecount_full(cPktBuffLength) LONG *pPackets,
            /* [out][in] */ __RPC__inout ULONG *pcInOutPkts,
            /* [out][in] */ __RPC__deref_inout_opt LONG **ppInOutPkts);
        
        HRESULT ( STDMETHODCALLTYPE *Packets )( 
            __RPC__in IStylusSyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in const StylusInfo *pStylusInfo,
            /* [in] */ ULONG cPktCount,
            /* [range][in] */ __RPC__in_range(0,0x7fff) ULONG cPktBuffLength,
            /* [size_is][in] */ __RPC__in_ecount_full(cPktBuffLength) LONG *pPackets,
            /* [out][in] */ __RPC__inout ULONG *pcInOutPkts,
            /* [out][in] */ __RPC__deref_inout_opt LONG **ppInOutPkts);
        
        HRESULT ( STDMETHODCALLTYPE *CustomStylusDataAdded )( 
            __RPC__in IStylusSyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in const GUID *pGuidId,
            /* [range][in] */ __RPC__in_range(0,0x7fff) ULONG cbData,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cbData) const BYTE *pbData);
        
        HRESULT ( STDMETHODCALLTYPE *SystemEvent )( 
            __RPC__in IStylusSyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [in] */ STYLUS_ID sid,
            /* [in] */ SYSTEM_EVENT event,
            /* [in] */ SYSTEM_EVENT_DATA eventdata);
        
        HRESULT ( STDMETHODCALLTYPE *TabletAdded )( 
            __RPC__in IStylusSyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in_opt IInkTablet *piTablet);
        
        HRESULT ( STDMETHODCALLTYPE *TabletRemoved )( 
            __RPC__in IStylusSyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ LONG iTabletIndex);
        
        HRESULT ( STDMETHODCALLTYPE *Error )( 
            __RPC__in IStylusSyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in_opt IStylusPlugin *piPlugin,
            /* [in] */ RealTimeStylusDataInterest dataInterest,
            /* [in] */ HRESULT hrErrorCode,
            /* [out][in] */ __RPC__inout LONG_PTR *lptrKey);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateMapping )( 
            __RPC__in IStylusSyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc);
        
        HRESULT ( STDMETHODCALLTYPE *DataInterest )( 
            __RPC__in IStylusSyncPlugin * This,
            /* [retval][out] */ __RPC__out RealTimeStylusDataInterest *pDataInterest);
        
        END_INTERFACE
    } IStylusSyncPluginVtbl;

    interface IStylusSyncPlugin
    {
        CONST_VTBL struct IStylusSyncPluginVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStylusSyncPlugin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStylusSyncPlugin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStylusSyncPlugin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStylusSyncPlugin_RealTimeStylusEnabled(This,piRtsSrc,cTcidCount,pTcids)	\
    ( (This)->lpVtbl -> RealTimeStylusEnabled(This,piRtsSrc,cTcidCount,pTcids) ) 

#define IStylusSyncPlugin_RealTimeStylusDisabled(This,piRtsSrc,cTcidCount,pTcids)	\
    ( (This)->lpVtbl -> RealTimeStylusDisabled(This,piRtsSrc,cTcidCount,pTcids) ) 

#define IStylusSyncPlugin_StylusInRange(This,piRtsSrc,tcid,sid)	\
    ( (This)->lpVtbl -> StylusInRange(This,piRtsSrc,tcid,sid) ) 

#define IStylusSyncPlugin_StylusOutOfRange(This,piRtsSrc,tcid,sid)	\
    ( (This)->lpVtbl -> StylusOutOfRange(This,piRtsSrc,tcid,sid) ) 

#define IStylusSyncPlugin_StylusDown(This,piRtsSrc,pStylusInfo,cPropCountPerPkt,pPacket,ppInOutPkt)	\
    ( (This)->lpVtbl -> StylusDown(This,piRtsSrc,pStylusInfo,cPropCountPerPkt,pPacket,ppInOutPkt) ) 

#define IStylusSyncPlugin_StylusUp(This,piRtsSrc,pStylusInfo,cPropCountPerPkt,pPacket,ppInOutPkt)	\
    ( (This)->lpVtbl -> StylusUp(This,piRtsSrc,pStylusInfo,cPropCountPerPkt,pPacket,ppInOutPkt) ) 

#define IStylusSyncPlugin_StylusButtonDown(This,piRtsSrc,sid,pGuidStylusButton,pStylusPos)	\
    ( (This)->lpVtbl -> StylusButtonDown(This,piRtsSrc,sid,pGuidStylusButton,pStylusPos) ) 

#define IStylusSyncPlugin_StylusButtonUp(This,piRtsSrc,sid,pGuidStylusButton,pStylusPos)	\
    ( (This)->lpVtbl -> StylusButtonUp(This,piRtsSrc,sid,pGuidStylusButton,pStylusPos) ) 

#define IStylusSyncPlugin_InAirPackets(This,piRtsSrc,pStylusInfo,cPktCount,cPktBuffLength,pPackets,pcInOutPkts,ppInOutPkts)	\
    ( (This)->lpVtbl -> InAirPackets(This,piRtsSrc,pStylusInfo,cPktCount,cPktBuffLength,pPackets,pcInOutPkts,ppInOutPkts) ) 

#define IStylusSyncPlugin_Packets(This,piRtsSrc,pStylusInfo,cPktCount,cPktBuffLength,pPackets,pcInOutPkts,ppInOutPkts)	\
    ( (This)->lpVtbl -> Packets(This,piRtsSrc,pStylusInfo,cPktCount,cPktBuffLength,pPackets,pcInOutPkts,ppInOutPkts) ) 

#define IStylusSyncPlugin_CustomStylusDataAdded(This,piRtsSrc,pGuidId,cbData,pbData)	\
    ( (This)->lpVtbl -> CustomStylusDataAdded(This,piRtsSrc,pGuidId,cbData,pbData) ) 

#define IStylusSyncPlugin_SystemEvent(This,piRtsSrc,tcid,sid,event,eventdata)	\
    ( (This)->lpVtbl -> SystemEvent(This,piRtsSrc,tcid,sid,event,eventdata) ) 

#define IStylusSyncPlugin_TabletAdded(This,piRtsSrc,piTablet)	\
    ( (This)->lpVtbl -> TabletAdded(This,piRtsSrc,piTablet) ) 

#define IStylusSyncPlugin_TabletRemoved(This,piRtsSrc,iTabletIndex)	\
    ( (This)->lpVtbl -> TabletRemoved(This,piRtsSrc,iTabletIndex) ) 

#define IStylusSyncPlugin_Error(This,piRtsSrc,piPlugin,dataInterest,hrErrorCode,lptrKey)	\
    ( (This)->lpVtbl -> Error(This,piRtsSrc,piPlugin,dataInterest,hrErrorCode,lptrKey) ) 

#define IStylusSyncPlugin_UpdateMapping(This,piRtsSrc)	\
    ( (This)->lpVtbl -> UpdateMapping(This,piRtsSrc) ) 

#define IStylusSyncPlugin_DataInterest(This,pDataInterest)	\
    ( (This)->lpVtbl -> DataInterest(This,pDataInterest) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStylusSyncPlugin_INTERFACE_DEFINED__ */


#ifndef __IStylusAsyncPlugin_INTERFACE_DEFINED__
#define __IStylusAsyncPlugin_INTERFACE_DEFINED__

/* interface IStylusAsyncPlugin */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IStylusAsyncPlugin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A7CCA85A-31BC-4cd2-AADC-3289A3AF11C8")
    IStylusAsyncPlugin : public IStylusPlugin
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IStylusAsyncPluginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStylusAsyncPlugin * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStylusAsyncPlugin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStylusAsyncPlugin * This);
        
        HRESULT ( STDMETHODCALLTYPE *RealTimeStylusEnabled )( 
            __RPC__in IStylusAsyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [range][in] */ __RPC__in_range(0,8) ULONG cTcidCount,
            /* [size_is][in] */ __RPC__in_ecount_full(cTcidCount) const TABLET_CONTEXT_ID *pTcids);
        
        HRESULT ( STDMETHODCALLTYPE *RealTimeStylusDisabled )( 
            __RPC__in IStylusAsyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [range][in] */ __RPC__in_range(0,8) ULONG cTcidCount,
            /* [size_is][in] */ __RPC__in_ecount_full(cTcidCount) const TABLET_CONTEXT_ID *pTcids);
        
        HRESULT ( STDMETHODCALLTYPE *StylusInRange )( 
            __RPC__in IStylusAsyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [in] */ STYLUS_ID sid);
        
        HRESULT ( STDMETHODCALLTYPE *StylusOutOfRange )( 
            __RPC__in IStylusAsyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [in] */ STYLUS_ID sid);
        
        HRESULT ( STDMETHODCALLTYPE *StylusDown )( 
            __RPC__in IStylusAsyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in const StylusInfo *pStylusInfo,
            /* [range][in] */ __RPC__in_range(0,32) ULONG cPropCountPerPkt,
            /* [size_is][in] */ __RPC__in_ecount_full(cPropCountPerPkt) LONG *pPacket,
            /* [out][in] */ __RPC__deref_inout_opt LONG **ppInOutPkt);
        
        HRESULT ( STDMETHODCALLTYPE *StylusUp )( 
            __RPC__in IStylusAsyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in const StylusInfo *pStylusInfo,
            /* [range][in] */ __RPC__in_range(0,32) ULONG cPropCountPerPkt,
            /* [size_is][in] */ __RPC__in_ecount_full(cPropCountPerPkt) LONG *pPacket,
            /* [out][in] */ __RPC__deref_inout_opt LONG **ppInOutPkt);
        
        HRESULT ( STDMETHODCALLTYPE *StylusButtonDown )( 
            __RPC__in IStylusAsyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ STYLUS_ID sid,
            /* [in] */ __RPC__in const GUID *pGuidStylusButton,
            /* [out][in] */ __RPC__inout POINT *pStylusPos);
        
        HRESULT ( STDMETHODCALLTYPE *StylusButtonUp )( 
            __RPC__in IStylusAsyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ STYLUS_ID sid,
            /* [in] */ __RPC__in const GUID *pGuidStylusButton,
            /* [out][in] */ __RPC__inout POINT *pStylusPos);
        
        HRESULT ( STDMETHODCALLTYPE *InAirPackets )( 
            __RPC__in IStylusAsyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in const StylusInfo *pStylusInfo,
            /* [in] */ ULONG cPktCount,
            /* [range][in] */ __RPC__in_range(0,0x7fff) ULONG cPktBuffLength,
            /* [size_is][in] */ __RPC__in_ecount_full(cPktBuffLength) LONG *pPackets,
            /* [out][in] */ __RPC__inout ULONG *pcInOutPkts,
            /* [out][in] */ __RPC__deref_inout_opt LONG **ppInOutPkts);
        
        HRESULT ( STDMETHODCALLTYPE *Packets )( 
            __RPC__in IStylusAsyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in const StylusInfo *pStylusInfo,
            /* [in] */ ULONG cPktCount,
            /* [range][in] */ __RPC__in_range(0,0x7fff) ULONG cPktBuffLength,
            /* [size_is][in] */ __RPC__in_ecount_full(cPktBuffLength) LONG *pPackets,
            /* [out][in] */ __RPC__inout ULONG *pcInOutPkts,
            /* [out][in] */ __RPC__deref_inout_opt LONG **ppInOutPkts);
        
        HRESULT ( STDMETHODCALLTYPE *CustomStylusDataAdded )( 
            __RPC__in IStylusAsyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in const GUID *pGuidId,
            /* [range][in] */ __RPC__in_range(0,0x7fff) ULONG cbData,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(cbData) const BYTE *pbData);
        
        HRESULT ( STDMETHODCALLTYPE *SystemEvent )( 
            __RPC__in IStylusAsyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ TABLET_CONTEXT_ID tcid,
            /* [in] */ STYLUS_ID sid,
            /* [in] */ SYSTEM_EVENT event,
            /* [in] */ SYSTEM_EVENT_DATA eventdata);
        
        HRESULT ( STDMETHODCALLTYPE *TabletAdded )( 
            __RPC__in IStylusAsyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in_opt IInkTablet *piTablet);
        
        HRESULT ( STDMETHODCALLTYPE *TabletRemoved )( 
            __RPC__in IStylusAsyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ LONG iTabletIndex);
        
        HRESULT ( STDMETHODCALLTYPE *Error )( 
            __RPC__in IStylusAsyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc,
            /* [in] */ __RPC__in_opt IStylusPlugin *piPlugin,
            /* [in] */ RealTimeStylusDataInterest dataInterest,
            /* [in] */ HRESULT hrErrorCode,
            /* [out][in] */ __RPC__inout LONG_PTR *lptrKey);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateMapping )( 
            __RPC__in IStylusAsyncPlugin * This,
            /* [in] */ __RPC__in_opt IRealTimeStylus *piRtsSrc);
        
        HRESULT ( STDMETHODCALLTYPE *DataInterest )( 
            __RPC__in IStylusAsyncPlugin * This,
            /* [retval][out] */ __RPC__out RealTimeStylusDataInterest *pDataInterest);
        
        END_INTERFACE
    } IStylusAsyncPluginVtbl;

    interface IStylusAsyncPlugin
    {
        CONST_VTBL struct IStylusAsyncPluginVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStylusAsyncPlugin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStylusAsyncPlugin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStylusAsyncPlugin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStylusAsyncPlugin_RealTimeStylusEnabled(This,piRtsSrc,cTcidCount,pTcids)	\
    ( (This)->lpVtbl -> RealTimeStylusEnabled(This,piRtsSrc,cTcidCount,pTcids) ) 

#define IStylusAsyncPlugin_RealTimeStylusDisabled(This,piRtsSrc,cTcidCount,pTcids)	\
    ( (This)->lpVtbl -> RealTimeStylusDisabled(This,piRtsSrc,cTcidCount,pTcids) ) 

#define IStylusAsyncPlugin_StylusInRange(This,piRtsSrc,tcid,sid)	\
    ( (This)->lpVtbl -> StylusInRange(This,piRtsSrc,tcid,sid) ) 

#define IStylusAsyncPlugin_StylusOutOfRange(This,piRtsSrc,tcid,sid)	\
    ( (This)->lpVtbl -> StylusOutOfRange(This,piRtsSrc,tcid,sid) ) 

#define IStylusAsyncPlugin_StylusDown(This,piRtsSrc,pStylusInfo,cPropCountPerPkt,pPacket,ppInOutPkt)	\
    ( (This)->lpVtbl -> StylusDown(This,piRtsSrc,pStylusInfo,cPropCountPerPkt,pPacket,ppInOutPkt) ) 

#define IStylusAsyncPlugin_StylusUp(This,piRtsSrc,pStylusInfo,cPropCountPerPkt,pPacket,ppInOutPkt)	\
    ( (This)->lpVtbl -> StylusUp(This,piRtsSrc,pStylusInfo,cPropCountPerPkt,pPacket,ppInOutPkt) ) 

#define IStylusAsyncPlugin_StylusButtonDown(This,piRtsSrc,sid,pGuidStylusButton,pStylusPos)	\
    ( (This)->lpVtbl -> StylusButtonDown(This,piRtsSrc,sid,pGuidStylusButton,pStylusPos) ) 

#define IStylusAsyncPlugin_StylusButtonUp(This,piRtsSrc,sid,pGuidStylusButton,pStylusPos)	\
    ( (This)->lpVtbl -> StylusButtonUp(This,piRtsSrc,sid,pGuidStylusButton,pStylusPos) ) 

#define IStylusAsyncPlugin_InAirPackets(This,piRtsSrc,pStylusInfo,cPktCount,cPktBuffLength,pPackets,pcInOutPkts,ppInOutPkts)	\
    ( (This)->lpVtbl -> InAirPackets(This,piRtsSrc,pStylusInfo,cPktCount,cPktBuffLength,pPackets,pcInOutPkts,ppInOutPkts) ) 

#define IStylusAsyncPlugin_Packets(This,piRtsSrc,pStylusInfo,cPktCount,cPktBuffLength,pPackets,pcInOutPkts,ppInOutPkts)	\
    ( (This)->lpVtbl -> Packets(This,piRtsSrc,pStylusInfo,cPktCount,cPktBuffLength,pPackets,pcInOutPkts,ppInOutPkts) ) 

#define IStylusAsyncPlugin_CustomStylusDataAdded(This,piRtsSrc,pGuidId,cbData,pbData)	\
    ( (This)->lpVtbl -> CustomStylusDataAdded(This,piRtsSrc,pGuidId,cbData,pbData) ) 

#define IStylusAsyncPlugin_SystemEvent(This,piRtsSrc,tcid,sid,event,eventdata)	\
    ( (This)->lpVtbl -> SystemEvent(This,piRtsSrc,tcid,sid,event,eventdata) ) 

#define IStylusAsyncPlugin_TabletAdded(This,piRtsSrc,piTablet)	\
    ( (This)->lpVtbl -> TabletAdded(This,piRtsSrc,piTablet) ) 

#define IStylusAsyncPlugin_TabletRemoved(This,piRtsSrc,iTabletIndex)	\
    ( (This)->lpVtbl -> TabletRemoved(This,piRtsSrc,iTabletIndex) ) 

#define IStylusAsyncPlugin_Error(This,piRtsSrc,piPlugin,dataInterest,hrErrorCode,lptrKey)	\
    ( (This)->lpVtbl -> Error(This,piRtsSrc,piPlugin,dataInterest,hrErrorCode,lptrKey) ) 

#define IStylusAsyncPlugin_UpdateMapping(This,piRtsSrc)	\
    ( (This)->lpVtbl -> UpdateMapping(This,piRtsSrc) ) 

#define IStylusAsyncPlugin_DataInterest(This,pDataInterest)	\
    ( (This)->lpVtbl -> DataInterest(This,pDataInterest) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStylusAsyncPlugin_INTERFACE_DEFINED__ */


#ifndef __IDynamicRenderer_INTERFACE_DEFINED__
#define __IDynamicRenderer_INTERFACE_DEFINED__

/* interface IDynamicRenderer */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDynamicRenderer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A079468E-7165-46f9-B7AF-98AD01A93009")
    IDynamicRenderer : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out BOOL *bEnabled) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ BOOL bEnabled) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HWND( 
            /* [retval][out] */ __RPC__out HANDLE_PTR *hwnd) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_HWND( 
            /* [in] */ HANDLE_PTR hwnd) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ClipRectangle( 
            /* [retval][out] */ __RPC__out RECT *prcClipRect) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ClipRectangle( 
            /* [in] */ __RPC__in const RECT *prcClipRect) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ClipRegion( 
            /* [retval][out] */ __RPC__out HANDLE_PTR *phClipRgn) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ClipRegion( 
            /* [in] */ HANDLE_PTR hClipRgn) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DrawingAttributes( 
            /* [retval][out] */ __RPC__deref_out_opt IInkDrawingAttributes **ppiDA) = 0;
        
        virtual /* [propputref] */ HRESULT STDMETHODCALLTYPE putref_DrawingAttributes( 
            /* [in] */ __RPC__in_opt IInkDrawingAttributes *piDA) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DataCacheEnabled( 
            /* [retval][out] */ __RPC__out BOOL *pfCacheData) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DataCacheEnabled( 
            /* [in] */ BOOL fCacheData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseCachedData( 
            ULONG strokeId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Draw( 
            /* [in] */ HANDLE_PTR hDC) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDynamicRendererVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDynamicRenderer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDynamicRenderer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDynamicRenderer * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            __RPC__in IDynamicRenderer * This,
            /* [retval][out] */ __RPC__out BOOL *bEnabled);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            __RPC__in IDynamicRenderer * This,
            /* [in] */ BOOL bEnabled);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HWND )( 
            __RPC__in IDynamicRenderer * This,
            /* [retval][out] */ __RPC__out HANDLE_PTR *hwnd);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_HWND )( 
            __RPC__in IDynamicRenderer * This,
            /* [in] */ HANDLE_PTR hwnd);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClipRectangle )( 
            __RPC__in IDynamicRenderer * This,
            /* [retval][out] */ __RPC__out RECT *prcClipRect);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClipRectangle )( 
            __RPC__in IDynamicRenderer * This,
            /* [in] */ __RPC__in const RECT *prcClipRect);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClipRegion )( 
            __RPC__in IDynamicRenderer * This,
            /* [retval][out] */ __RPC__out HANDLE_PTR *phClipRgn);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClipRegion )( 
            __RPC__in IDynamicRenderer * This,
            /* [in] */ HANDLE_PTR hClipRgn);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DrawingAttributes )( 
            __RPC__in IDynamicRenderer * This,
            /* [retval][out] */ __RPC__deref_out_opt IInkDrawingAttributes **ppiDA);
        
        /* [propputref] */ HRESULT ( STDMETHODCALLTYPE *putref_DrawingAttributes )( 
            __RPC__in IDynamicRenderer * This,
            /* [in] */ __RPC__in_opt IInkDrawingAttributes *piDA);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataCacheEnabled )( 
            __RPC__in IDynamicRenderer * This,
            /* [retval][out] */ __RPC__out BOOL *pfCacheData);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_DataCacheEnabled )( 
            __RPC__in IDynamicRenderer * This,
            /* [in] */ BOOL fCacheData);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseCachedData )( 
            __RPC__in IDynamicRenderer * This,
            ULONG strokeId);
        
        HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            __RPC__in IDynamicRenderer * This);
        
        HRESULT ( STDMETHODCALLTYPE *Draw )( 
            __RPC__in IDynamicRenderer * This,
            /* [in] */ HANDLE_PTR hDC);
        
        END_INTERFACE
    } IDynamicRendererVtbl;

    interface IDynamicRenderer
    {
        CONST_VTBL struct IDynamicRendererVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDynamicRenderer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDynamicRenderer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDynamicRenderer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDynamicRenderer_get_Enabled(This,bEnabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,bEnabled) ) 

#define IDynamicRenderer_put_Enabled(This,bEnabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,bEnabled) ) 

#define IDynamicRenderer_get_HWND(This,hwnd)	\
    ( (This)->lpVtbl -> get_HWND(This,hwnd) ) 

#define IDynamicRenderer_put_HWND(This,hwnd)	\
    ( (This)->lpVtbl -> put_HWND(This,hwnd) ) 

#define IDynamicRenderer_get_ClipRectangle(This,prcClipRect)	\
    ( (This)->lpVtbl -> get_ClipRectangle(This,prcClipRect) ) 

#define IDynamicRenderer_put_ClipRectangle(This,prcClipRect)	\
    ( (This)->lpVtbl -> put_ClipRectangle(This,prcClipRect) ) 

#define IDynamicRenderer_get_ClipRegion(This,phClipRgn)	\
    ( (This)->lpVtbl -> get_ClipRegion(This,phClipRgn) ) 

#define IDynamicRenderer_put_ClipRegion(This,hClipRgn)	\
    ( (This)->lpVtbl -> put_ClipRegion(This,hClipRgn) ) 

#define IDynamicRenderer_get_DrawingAttributes(This,ppiDA)	\
    ( (This)->lpVtbl -> get_DrawingAttributes(This,ppiDA) ) 

#define IDynamicRenderer_putref_DrawingAttributes(This,piDA)	\
    ( (This)->lpVtbl -> putref_DrawingAttributes(This,piDA) ) 

#define IDynamicRenderer_get_DataCacheEnabled(This,pfCacheData)	\
    ( (This)->lpVtbl -> get_DataCacheEnabled(This,pfCacheData) ) 

#define IDynamicRenderer_put_DataCacheEnabled(This,fCacheData)	\
    ( (This)->lpVtbl -> put_DataCacheEnabled(This,fCacheData) ) 

#define IDynamicRenderer_ReleaseCachedData(This,strokeId)	\
    ( (This)->lpVtbl -> ReleaseCachedData(This,strokeId) ) 

#define IDynamicRenderer_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IDynamicRenderer_Draw(This,hDC)	\
    ( (This)->lpVtbl -> Draw(This,hDC) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDynamicRenderer_INTERFACE_DEFINED__ */


#ifndef __IGestureRecognizer_INTERFACE_DEFINED__
#define __IGestureRecognizer_INTERFACE_DEFINED__

/* interface IGestureRecognizer */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IGestureRecognizer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE9EF86B-7054-45e3-AE22-3174DC8811B7")
    IGestureRecognizer : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out BOOL *pfEnabled) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ BOOL fEnabled) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MaxStrokeCount( 
            /* [retval][out] */ __RPC__out long *pcStrokes) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_MaxStrokeCount( 
            /* [in] */ long cStrokes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableGestures( 
            /* [range][in] */ __RPC__in_range(0,64) ULONG cGestures,
            /* [size_is][in] */ __RPC__in_ecount_full(cGestures) const int *pGestures) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGestureRecognizerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IGestureRecognizer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IGestureRecognizer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IGestureRecognizer * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            __RPC__in IGestureRecognizer * This,
            /* [retval][out] */ __RPC__out BOOL *pfEnabled);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            __RPC__in IGestureRecognizer * This,
            /* [in] */ BOOL fEnabled);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxStrokeCount )( 
            __RPC__in IGestureRecognizer * This,
            /* [retval][out] */ __RPC__out long *pcStrokes);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxStrokeCount )( 
            __RPC__in IGestureRecognizer * This,
            /* [in] */ long cStrokes);
        
        HRESULT ( STDMETHODCALLTYPE *EnableGestures )( 
            __RPC__in IGestureRecognizer * This,
            /* [range][in] */ __RPC__in_range(0,64) ULONG cGestures,
            /* [size_is][in] */ __RPC__in_ecount_full(cGestures) const int *pGestures);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IGestureRecognizer * This);
        
        END_INTERFACE
    } IGestureRecognizerVtbl;

    interface IGestureRecognizer
    {
        CONST_VTBL struct IGestureRecognizerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGestureRecognizer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGestureRecognizer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGestureRecognizer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGestureRecognizer_get_Enabled(This,pfEnabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,pfEnabled) ) 

#define IGestureRecognizer_put_Enabled(This,fEnabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,fEnabled) ) 

#define IGestureRecognizer_get_MaxStrokeCount(This,pcStrokes)	\
    ( (This)->lpVtbl -> get_MaxStrokeCount(This,pcStrokes) ) 

#define IGestureRecognizer_put_MaxStrokeCount(This,cStrokes)	\
    ( (This)->lpVtbl -> put_MaxStrokeCount(This,cStrokes) ) 

#define IGestureRecognizer_EnableGestures(This,cGestures,pGestures)	\
    ( (This)->lpVtbl -> EnableGestures(This,cGestures,pGestures) ) 

#define IGestureRecognizer_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGestureRecognizer_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_RealTimeStylus;

#ifdef __cplusplus

class DECLSPEC_UUID("E26B366D-F998-43ce-836F-CB6D904432B0")
RealTimeStylus;
#endif

EXTERN_C const CLSID CLSID_DynamicRenderer;

#ifdef __cplusplus

class DECLSPEC_UUID("ECD32AEA-746F-4dcb-BF68-082757FAFF18")
DynamicRenderer;
#endif

EXTERN_C const CLSID CLSID_GestureRecognizer;

#ifdef __cplusplus

class DECLSPEC_UUID("EA30C654-C62C-441f-AC00-95F9A196782C")
GestureRecognizer;
#endif

EXTERN_C const CLSID CLSID_StrokeBuilder;

#ifdef __cplusplus

class DECLSPEC_UUID("E810CEE7-6E51-4cb0-AA3A-0B985B70DAF7")
StrokeBuilder;
#endif
#endif /* __TPCRTSLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Rtutils.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rtutils.h

Abstract:
     Public declarations for the Router process  utility functions.

--*/

#ifndef __ROUTING_RTUTILS_H__
#define __ROUTING_RTUTILS_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// TRACING FUNCTION PROTOTYPES                                              //
//                                                                          //
// See DOCUMENT for more information                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Definitions for flags and constants                                      //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define TRACE_USE_FILE      0x00000001
#define TRACE_USE_CONSOLE   0x00000002
#define TRACE_NO_SYNCH      0x00000004 //this flag is deprecated

#define TRACE_NO_STDINFO    0x00000001
#define TRACE_USE_MASK      0x00000002
#define TRACE_USE_MSEC      0x00000004
#define TRACE_USE_DATE      0x00000008

#define INVALID_TRACEID     0xFFFFFFFF


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// ANSI entry-points                                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
APIENTRY
TraceRegisterExA(
    IN  LPCSTR      lpszCallerName,
    IN  DWORD       dwFlags
    );

DWORD
APIENTRY
TraceDeregisterA(
    IN  DWORD       dwTraceID
    );

DWORD
APIENTRY
TraceDeregisterExA(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags
    );

DWORD
APIENTRY
TraceGetConsoleA(
    IN  DWORD       dwTraceID,
    OUT LPHANDLE    lphConsole
    );

DWORD
__cdecl
TracePrintfA(
    IN  DWORD       dwTraceID,
    IN  LPCSTR      lpszFormat,
    IN  ...         OPTIONAL
    );

DWORD
__cdecl
TracePrintfExA(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCSTR      lpszFormat,
    IN  ...         OPTIONAL
    );

DWORD
APIENTRY
TraceVprintfExA(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCSTR      lpszFormat,
    IN  va_list     arglist
    );

DWORD
APIENTRY
TracePutsExA(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCSTR      lpszString
    );

DWORD
APIENTRY
TraceDumpExA(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPBYTE      lpbBytes,
    IN  DWORD       dwByteCount,
    IN  DWORD       dwGroupSize,
    IN  BOOL        bAddressPrefix,
    IN  LPCSTR      lpszPrefix
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// ANSI entry-points macros                                                 //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define TraceRegisterA(a)               TraceRegisterExA(a,0)
#define TraceVprintfA(a,b,c)            TraceVprintfExA(a,0,b,c)
#define TracePutsA(a,b)                 TracePutsExA(a,0,b)
#define TraceDumpA(a,b,c,d,e,f)         TraceDumpExA(a,0,b,c,d,e,f)



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Unicode entry-points                                                     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
APIENTRY
TraceRegisterExW(
    IN  LPCWSTR     lpszCallerName,
    IN  DWORD       dwFlags
    );

DWORD
APIENTRY
TraceDeregisterW(
    IN  DWORD       dwTraceID
    );

DWORD
APIENTRY
TraceDeregisterExW(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags
    );

DWORD
APIENTRY
TraceGetConsoleW(
    IN  DWORD       dwTraceID,
    OUT LPHANDLE    lphConsole
    );

DWORD
__cdecl
TracePrintfW(
    IN  DWORD       dwTraceID,
    IN  LPCWSTR     lpszFormat,
    IN  ...         OPTIONAL
    );

DWORD
__cdecl
TracePrintfExW(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCWSTR     lpszFormat,
    IN  ...         OPTIONAL
    );

DWORD
APIENTRY
TraceVprintfExW(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCWSTR     lpszFormat,
    IN  va_list     arglist
    );

DWORD
APIENTRY
TracePutsExW(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPCWSTR     lpszString
    );

DWORD
APIENTRY
TraceDumpExW(
    IN  DWORD       dwTraceID,
    IN  DWORD       dwFlags,
    IN  LPBYTE      lpbBytes,
    IN  DWORD       dwByteCount,
    IN  DWORD       dwGroupSize,
    IN  BOOL        bAddressPrefix,
    IN  LPCWSTR     lpszPrefix
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Unicode entry-points macros                                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define TraceRegisterW(a)               TraceRegisterExW(a,0)
#define TraceVprintfW(a,b,c)            TraceVprintfExW(a,0,b,c)
#define TracePutsW(a,b)                 TracePutsExW(a,0,b)
#define TraceDumpW(a,b,c,d,e,f)         TraceDumpExW(a,0,b,c,d,e,f)



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Code-page dependent entry-point macros                                   //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#ifdef UNICODE
#define TraceRegister           TraceRegisterW
#define TraceDeregister         TraceDeregisterW
#define TraceDeregisterEx       TraceDeregisterExW
#define TraceGetConsole         TraceGetConsoleW
#define TracePrintf             TracePrintfW
#define TraceVprintf            TraceVprintfW
#define TracePuts               TracePutsW
#define TraceDump               TraceDumpW
#define TraceRegisterEx         TraceRegisterExW
#define TracePrintfEx           TracePrintfExW
#define TraceVprintfEx          TraceVprintfExW
#define TracePutsEx             TracePutsExW
#define TraceDumpEx             TraceDumpExW
#else
#define TraceRegister           TraceRegisterA
#define TraceDeregister         TraceDeregisterA
#define TraceDeregisterEx       TraceDeregisterExA
#define TraceGetConsole         TraceGetConsoleA
#define TracePrintf             TracePrintfA
#define TraceVprintf            TraceVprintfA
#define TracePuts               TracePutsA
#define TraceDump               TraceDumpA
#define TraceRegisterEx         TraceRegisterExA
#define TracePrintfEx           TracePrintfExA
#define TraceVprintfEx          TraceVprintfExA
#define TracePutsEx             TracePutsExA
#define TraceDumpEx             TraceDumpExA
#endif



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// EVENT LOGGING FUNCTION PROTOTYPES                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// ANSI prototypes                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


VOID
APIENTRY
LogErrorA(
    IN DWORD    dwMessageId,
    IN DWORD    cNumberOfSubStrings,
    __in_ecount(cNumberOfSubStrings) IN LPSTR   *plpwsSubStrings,
    IN DWORD    dwErrorCode
);

VOID
APIENTRY
LogEventA(
    IN DWORD   wEventType,
    IN DWORD   dwMessageId,
    IN DWORD   cNumberOfSubStrings,
    __in_ecount(cNumberOfSubStrings) IN LPSTR  *plpwsSubStrings
);


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Unicode prototypes                                                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

VOID
LogErrorW(
    IN DWORD    dwMessageId,
    IN DWORD    cNumberOfSubStrings,
    __in_ecount(cNumberOfSubStrings) IN LPWSTR  *plpwsSubStrings,
    IN DWORD    dwErrorCode
);

VOID
LogEventW(
    IN DWORD   wEventType,
    IN DWORD   dwMessageId,
    IN DWORD   cNumberOfSubStrings,
    __in_ecount(cNumberOfSubStrings) IN LPWSTR *plpwsSubStrings
);


#ifdef UNICODE
#define LogError                LogErrorW
#define LogEvent                LogEventW
#else
#define LogError                LogErrorA
#define LogEvent                LogEventA
#endif


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The following functions allow the caller to specify the event source.    //
//                                                                          //
// Call RouterLogRegister with the strings which would be passed to         //
// RegisterEventSource; this returns a handle which can be passed           //
// to the functions RouterLogEvent and RouterLogEventData.                  //
//                                                                          //
// Call RouterLogDeregister to close the handle.                            //
//                                                                          //
// Macros are provided for the different kinds of event log entrys:         //
//  RouterLogError          logs an error (EVENTLOG_ERROR_TYPE)             //
//  RouterLogWarning        logs a warning (EVENTLOG_WARNING_TYPE)          //
//  RouterLogInformation    logs information (EVENTLOG_INFORMATION_TYPE)    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// ANSI prototypes                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

HANDLE
RouterLogRegisterA(
    LPCSTR lpszSource
    );

VOID
RouterLogDeregisterA(
    HANDLE hLogHandle
    );

VOID
RouterLogEventA(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    IN __in_ecount_opt(dwSubStringCount) LPSTR *plpszSubStringArray,
    IN DWORD dwErrorCode
    );

VOID
RouterLogEventDataA(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    __in_ecount_opt(dwSubStringCount) IN LPSTR *plpszSubStringArray,
    IN DWORD dwDataBytes,
    IN LPBYTE lpDataBytes
    );

VOID
RouterLogEventStringA(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    __in_ecount(dwSubStringCount) IN LPSTR *plpszSubStringArray,
    IN DWORD dwErrorCode,
    IN DWORD dwErrorIndex
    );

VOID
__cdecl
RouterLogEventExA(
    IN HANDLE   hLogHandle,
    IN DWORD    dwEventType,
    IN DWORD    dwErrorCode,
    IN DWORD    dwMessageId,
    IN LPCSTR   ptszFormat,
    ...
    );

VOID
RouterLogEventValistExA(
    IN HANDLE   hLogHandle,
    IN DWORD    dwEventType,
    IN DWORD    dwErrorCode,
    IN DWORD    dwMessageId,
    IN LPCSTR   ptszFormat,
    IN va_list  arglist
    );

DWORD
RouterGetErrorStringA(
    IN  DWORD   dwErrorCode,
    __out OUT LPSTR * lplpszErrorString
    );

#define RouterLogErrorA(h,msg,count,array,err) \
        RouterLogEventA(h,EVENTLOG_ERROR_TYPE,msg,count,array,err)
#define RouterLogWarningA(h,msg,count,array,err) \
        RouterLogEventA(h,EVENTLOG_WARNING_TYPE,msg,count,array,err)
#define RouterLogInformationA(h,msg,count,array,err) \
        RouterLogEventA(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,err)

#define RouterLogErrorDataA(h,msg,count,array,c,buf) \
        RouterLogEventDataA(h,EVENTLOG_ERROR_TYPE,msg,count,array,c,buf)
#define RouterLogWarningDataA(h,msg,count,array,c,buf) \
        RouterLogEventDataA(h,EVENTLOG_WARNING_TYPE,msg,count,array,c,buf)
#define RouterLogInformationDataA(h,msg,count,array,c,buf) \
        RouterLogEventDataA(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,c,buf)

#define RouterLogErrorStringA(h,msg,count,array,err,index) \
        RouterLogEventStringA(h,EVENTLOG_ERROR_TYPE,msg,count,array, err,index)
#define RouterLogWarningStringA(h,msg,count,array,err,index) \
        RouterLogEventStringA(h,EVENTLOG_WARNING_TYPE,msg,count,array,err,index)
#define RouterLogInformationStringA(h,msg,count,array, err,index) \
        RouterLogEventStringA(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,err,\
                              index)


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Unicode prototypes                                                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

HANDLE
RouterLogRegisterW(
    LPCWSTR lpszSource
    );

VOID
RouterLogDeregisterW(
    HANDLE hLogHandle
    );

VOID
RouterLogEventW(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    IN __in_ecount_opt(dwSubStringCount) LPWSTR *plpszSubStringArray,
    IN DWORD dwErrorCode
    );

VOID
RouterLogEventDataW(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    __in_ecount_opt(dwSubStringCount) IN LPWSTR *plpszSubStringArray,
    IN DWORD dwDataBytes,
    IN LPBYTE lpDataBytes
    );

VOID
RouterLogEventStringW(
    IN HANDLE hLogHandle,
    IN DWORD dwEventType,
    IN DWORD dwMessageId,
    IN DWORD dwSubStringCount,
    __in_ecount(dwSubStringCount) IN LPWSTR *plpszSubStringArray,
    IN DWORD dwErrorCode,
    IN DWORD dwErrorIndex
    );

VOID
__cdecl
RouterLogEventExW(
    IN HANDLE   hLogHandle,
    IN DWORD    dwEventType,
    IN DWORD    dwErrorCode,
    IN DWORD    dwMessageId,
    IN LPCWSTR  ptszFormat,
    ...
    );

VOID
RouterLogEventValistExW(
    IN HANDLE   hLogHandle,
    IN DWORD    dwEventType,
    IN DWORD    dwErrorCode,
    IN DWORD    dwMessageId,
    IN LPCWSTR  ptszFormat,
    IN va_list  arglist
    );

DWORD
RouterGetErrorStringW(
    IN  DWORD    dwErrorCode,
    __out OUT LPWSTR * lplpwszErrorString
    );


#define RouterLogErrorW(h,msg,count,array,err) \
        RouterLogEventW(h,EVENTLOG_ERROR_TYPE,msg,count,array,err)
#define RouterLogWarningW(h,msg,count,array,err) \
        RouterLogEventW(h,EVENTLOG_WARNING_TYPE,msg,count,array,err)
#define RouterLogInformationW(h,msg,count,array,err) \
        RouterLogEventW(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,err)

#define RouterLogErrorDataW(h,msg,count,array,c,buf) \
        RouterLogEventDataW(h,EVENTLOG_ERROR_TYPE,msg,count,array,c,buf)
#define RouterLogWarningDataW(h,msg,count,array,c,buf) \
        RouterLogEventDataW(h,EVENTLOG_WARNING_TYPE,msg,count,array,c,buf)
#define RouterLogInformationDataW(h,msg,count,array,c,buf) \
        RouterLogEventDataW(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,c,buf)

#define RouterLogErrorStringW(h,msg,count,array,err,index) \
        RouterLogEventStringW(h,EVENTLOG_ERROR_TYPE,msg,count,array,err,index)
#define RouterLogWarningStringW(h,msg,count,array,err,index) \
        RouterLogEventStringW(h,EVENTLOG_WARNING_TYPE,msg,count,array,err,index)
#define RouterLogInformationStringW(h,msg,count,array,err,index) \
        RouterLogEventStringW(h,EVENTLOG_INFORMATION_TYPE,msg,count,array,err,\
                              index)


#ifdef UNICODE
#define RouterLogRegister           RouterLogRegisterW
#define RouterLogDeregister         RouterLogDeregisterW
#define RouterLogEvent              RouterLogEventW
#define RouterLogError              RouterLogErrorW
#define RouterLogWarning            RouterLogWarningW
#define RouterLogInformation        RouterLogInformationW
#define RouterLogEventData          RouterLogEventDataW
#define RouterLogErrorData          RouterLogErrorDataW
#define RouterLogWarningData        RouterLogWarningDataW
#define RouterLogInformationData    RouterLogInformationDataW
#define RouterLogEventString        RouterLogEventStringW
#define RouterLogEventEx            RouterLogEventExW
#define RouterLogEventValistEx      RouterLogEventValistExW
#define RouterLogErrorString        RouterLogErrorStringW
#define RouterLogWarningString      RouterLogWarningStringW
#define RouterLogInformationString  RouterLogInformationStringW
#define RouterGetErrorString        RouterGetErrorStringW
#
#else
#define RouterLogRegister           RouterLogRegisterA
#define RouterLogDeregister         RouterLogDeregisterA
#define RouterLogEvent              RouterLogEventA
#define RouterLogError              RouterLogErrorA
#define RouterLogWarning            RouterLogWarningA
#define RouterLogInformation        RouterLogInformationA
#define RouterLogEventData          RouterLogEventDataA
#define RouterLogErrorData          RouterLogErrorDataA
#define RouterLogWarningData        RouterLogWarningDataA
#define RouterLogInformationData    RouterLogInformationDataA
#define RouterLogEventString        RouterLogEventStringA
#define RouterLogEventEx            RouterLogEventExA
#define RouterLogEventValistEx      RouterLogEventValistExA
#define RouterLogErrorString        RouterLogErrorStringA
#define RouterLogWarningString      RouterLogWarningStringA
#define RouterLogInformationString  RouterLogInformationStringA
#define RouterGetErrorString        RouterGetErrorStringA
#endif


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// WORKER THREAD POOL FUNCTIONS                                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// definition of worker function passed in QueueWorkItem API                //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef VOID (APIENTRY * WORKERFUNCTION)(PVOID);


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// ROUTER ASSERT DECLARATION                                                //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

VOID
RouterAssert(
    __in IN PSTR pszFailedAssertion,
    __in IN PSTR pszFileName,
    __in IN DWORD dwLineNumber,
    __in IN PSTR pszMessage OPTIONAL
    );


#if DBG
#define RTASSERT(exp) \
        if (!(exp)) \
            RouterAssert(#exp, __FILE__, __LINE__, NULL)
#define RTASSERTMSG(msg, exp) \
        if (!(exp)) \
            RouterAssert(#exp, __FILE__, __LINE__, msg)
#else
#define RTASSERT(exp)
#define RTASSERTMSG(msg, exp)
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// REGISTRY CONFIGURATION FUNCTIONS                                         //
//                                                                          //
// The following definitions are used to read configuration information     //
// about installed protocols.                                               //
//                                                                          //
// Call 'MprSetupProtocolEnum' to enumerate the routing-protocols           //
// for transport 'dwTransportId'. This fills an array with entries          //
// of type 'MPR_PROTOCOL_0'.                                                //
//                                                                          //
// The array loaded can be destroyed by calling 'MprSetupProtocolFree'.     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define RTUTILS_MAX_PROTOCOL_NAME_LEN	                40
#define RTUTILS_MAX_PROTOCOL_DLL_LEN                    48

//
// the below two names should not be used
//

#ifndef MAX_PROTOCOL_NAME_LEN
#define MAX_PROTOCOL_NAME_LEN RTUTILS_MAX_PROTOCOL_NAME_LEN
#else
#undef MAX_PROTOCOL_NAME_LEN
#endif
#define MAX_PROTOCOL_DLL_LEN  RTUTILS_MAX_PROTOCOL_DLL_LEN



typedef struct _MPR_PROTOCOL_0 {

    DWORD       dwProtocolId;                           // e.g. IP_RIP
    WCHAR       wszProtocol[RTUTILS_MAX_PROTOCOL_NAME_LEN+1];   // e.g. "IPRIP"
    WCHAR       wszDLLName[RTUTILS_MAX_PROTOCOL_DLL_LEN+1];     // e.g. "iprip2.dll"

} MPR_PROTOCOL_0;


DWORD APIENTRY
MprSetupProtocolEnum(
    IN      DWORD                   dwTransportId,
    OUT     LPBYTE*                 lplpBuffer,         // MPR_PROTOCOL_0
    OUT     LPDWORD                 lpdwEntriesRead
    );


DWORD APIENTRY
MprSetupProtocolFree(
    IN      LPVOID                  lpBuffer
    );


//////////////////////////////////////////////////////////////////////////////
// Extensions to Rtutils to improve worker thread utilization.				//
// 																			//
//////////////////////////////////////////////////////////////////////////////

#define ROUTING_RESERVED
#define OPT1_1
#define OPT1_2
#define OPT2_1
#define OPT2_2
#define OPT3_1
#define OPT3_2


#ifdef __cplusplus
}
#endif

#endif // ___ROUTING_RTUTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\sac.h ===
#ifndef __SAC_H__
#define __SAC_H__

typedef DWORD HMAC;

#define RSA_KEY_LEN 64
#define SAC_SESSION_KEYLEN 8

#define SAC_PROTOCOL_WMDM 1
#define SAC_PROTOCOL_V1 2

#define SAC_CERT_X509 1
#define SAC_CERT_V1 2

typedef struct __MACINFO
{
	BOOL fUsed;
	BYTE abMacState[36];
} MACINFO;

#endif //__SAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\rtccore.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for rtccore.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rtccore_h__
#define __rtccore_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IRTCClient_FWD_DEFINED__
#define __IRTCClient_FWD_DEFINED__
typedef interface IRTCClient IRTCClient;
#endif 	/* __IRTCClient_FWD_DEFINED__ */


#ifndef __IRTCClient2_FWD_DEFINED__
#define __IRTCClient2_FWD_DEFINED__
typedef interface IRTCClient2 IRTCClient2;
#endif 	/* __IRTCClient2_FWD_DEFINED__ */


#ifndef __IRTCClientPresence_FWD_DEFINED__
#define __IRTCClientPresence_FWD_DEFINED__
typedef interface IRTCClientPresence IRTCClientPresence;
#endif 	/* __IRTCClientPresence_FWD_DEFINED__ */


#ifndef __IRTCClientPresence2_FWD_DEFINED__
#define __IRTCClientPresence2_FWD_DEFINED__
typedef interface IRTCClientPresence2 IRTCClientPresence2;
#endif 	/* __IRTCClientPresence2_FWD_DEFINED__ */


#ifndef __IRTCClientProvisioning_FWD_DEFINED__
#define __IRTCClientProvisioning_FWD_DEFINED__
typedef interface IRTCClientProvisioning IRTCClientProvisioning;
#endif 	/* __IRTCClientProvisioning_FWD_DEFINED__ */


#ifndef __IRTCClientProvisioning2_FWD_DEFINED__
#define __IRTCClientProvisioning2_FWD_DEFINED__
typedef interface IRTCClientProvisioning2 IRTCClientProvisioning2;
#endif 	/* __IRTCClientProvisioning2_FWD_DEFINED__ */


#ifndef __IRTCProfile_FWD_DEFINED__
#define __IRTCProfile_FWD_DEFINED__
typedef interface IRTCProfile IRTCProfile;
#endif 	/* __IRTCProfile_FWD_DEFINED__ */


#ifndef __IRTCProfile2_FWD_DEFINED__
#define __IRTCProfile2_FWD_DEFINED__
typedef interface IRTCProfile2 IRTCProfile2;
#endif 	/* __IRTCProfile2_FWD_DEFINED__ */


#ifndef __IRTCSession_FWD_DEFINED__
#define __IRTCSession_FWD_DEFINED__
typedef interface IRTCSession IRTCSession;
#endif 	/* __IRTCSession_FWD_DEFINED__ */


#ifndef __IRTCSession2_FWD_DEFINED__
#define __IRTCSession2_FWD_DEFINED__
typedef interface IRTCSession2 IRTCSession2;
#endif 	/* __IRTCSession2_FWD_DEFINED__ */


#ifndef __IRTCSessionCallControl_FWD_DEFINED__
#define __IRTCSessionCallControl_FWD_DEFINED__
typedef interface IRTCSessionCallControl IRTCSessionCallControl;
#endif 	/* __IRTCSessionCallControl_FWD_DEFINED__ */


#ifndef __IRTCParticipant_FWD_DEFINED__
#define __IRTCParticipant_FWD_DEFINED__
typedef interface IRTCParticipant IRTCParticipant;
#endif 	/* __IRTCParticipant_FWD_DEFINED__ */


#ifndef __IRTCRoamingEvent_FWD_DEFINED__
#define __IRTCRoamingEvent_FWD_DEFINED__
typedef interface IRTCRoamingEvent IRTCRoamingEvent;
#endif 	/* __IRTCRoamingEvent_FWD_DEFINED__ */


#ifndef __IRTCProfileEvent_FWD_DEFINED__
#define __IRTCProfileEvent_FWD_DEFINED__
typedef interface IRTCProfileEvent IRTCProfileEvent;
#endif 	/* __IRTCProfileEvent_FWD_DEFINED__ */


#ifndef __IRTCProfileEvent2_FWD_DEFINED__
#define __IRTCProfileEvent2_FWD_DEFINED__
typedef interface IRTCProfileEvent2 IRTCProfileEvent2;
#endif 	/* __IRTCProfileEvent2_FWD_DEFINED__ */


#ifndef __IRTCClientEvent_FWD_DEFINED__
#define __IRTCClientEvent_FWD_DEFINED__
typedef interface IRTCClientEvent IRTCClientEvent;
#endif 	/* __IRTCClientEvent_FWD_DEFINED__ */


#ifndef __IRTCRegistrationStateChangeEvent_FWD_DEFINED__
#define __IRTCRegistrationStateChangeEvent_FWD_DEFINED__
typedef interface IRTCRegistrationStateChangeEvent IRTCRegistrationStateChangeEvent;
#endif 	/* __IRTCRegistrationStateChangeEvent_FWD_DEFINED__ */


#ifndef __IRTCSessionStateChangeEvent_FWD_DEFINED__
#define __IRTCSessionStateChangeEvent_FWD_DEFINED__
typedef interface IRTCSessionStateChangeEvent IRTCSessionStateChangeEvent;
#endif 	/* __IRTCSessionStateChangeEvent_FWD_DEFINED__ */


#ifndef __IRTCSessionStateChangeEvent2_FWD_DEFINED__
#define __IRTCSessionStateChangeEvent2_FWD_DEFINED__
typedef interface IRTCSessionStateChangeEvent2 IRTCSessionStateChangeEvent2;
#endif 	/* __IRTCSessionStateChangeEvent2_FWD_DEFINED__ */


#ifndef __IRTCSessionOperationCompleteEvent_FWD_DEFINED__
#define __IRTCSessionOperationCompleteEvent_FWD_DEFINED__
typedef interface IRTCSessionOperationCompleteEvent IRTCSessionOperationCompleteEvent;
#endif 	/* __IRTCSessionOperationCompleteEvent_FWD_DEFINED__ */


#ifndef __IRTCSessionOperationCompleteEvent2_FWD_DEFINED__
#define __IRTCSessionOperationCompleteEvent2_FWD_DEFINED__
typedef interface IRTCSessionOperationCompleteEvent2 IRTCSessionOperationCompleteEvent2;
#endif 	/* __IRTCSessionOperationCompleteEvent2_FWD_DEFINED__ */


#ifndef __IRTCParticipantStateChangeEvent_FWD_DEFINED__
#define __IRTCParticipantStateChangeEvent_FWD_DEFINED__
typedef interface IRTCParticipantStateChangeEvent IRTCParticipantStateChangeEvent;
#endif 	/* __IRTCParticipantStateChangeEvent_FWD_DEFINED__ */


#ifndef __IRTCMediaEvent_FWD_DEFINED__
#define __IRTCMediaEvent_FWD_DEFINED__
typedef interface IRTCMediaEvent IRTCMediaEvent;
#endif 	/* __IRTCMediaEvent_FWD_DEFINED__ */


#ifndef __IRTCIntensityEvent_FWD_DEFINED__
#define __IRTCIntensityEvent_FWD_DEFINED__
typedef interface IRTCIntensityEvent IRTCIntensityEvent;
#endif 	/* __IRTCIntensityEvent_FWD_DEFINED__ */


#ifndef __IRTCMessagingEvent_FWD_DEFINED__
#define __IRTCMessagingEvent_FWD_DEFINED__
typedef interface IRTCMessagingEvent IRTCMessagingEvent;
#endif 	/* __IRTCMessagingEvent_FWD_DEFINED__ */


#ifndef __IRTCBuddyEvent_FWD_DEFINED__
#define __IRTCBuddyEvent_FWD_DEFINED__
typedef interface IRTCBuddyEvent IRTCBuddyEvent;
#endif 	/* __IRTCBuddyEvent_FWD_DEFINED__ */


#ifndef __IRTCBuddyEvent2_FWD_DEFINED__
#define __IRTCBuddyEvent2_FWD_DEFINED__
typedef interface IRTCBuddyEvent2 IRTCBuddyEvent2;
#endif 	/* __IRTCBuddyEvent2_FWD_DEFINED__ */


#ifndef __IRTCWatcherEvent_FWD_DEFINED__
#define __IRTCWatcherEvent_FWD_DEFINED__
typedef interface IRTCWatcherEvent IRTCWatcherEvent;
#endif 	/* __IRTCWatcherEvent_FWD_DEFINED__ */


#ifndef __IRTCWatcherEvent2_FWD_DEFINED__
#define __IRTCWatcherEvent2_FWD_DEFINED__
typedef interface IRTCWatcherEvent2 IRTCWatcherEvent2;
#endif 	/* __IRTCWatcherEvent2_FWD_DEFINED__ */


#ifndef __IRTCBuddyGroupEvent_FWD_DEFINED__
#define __IRTCBuddyGroupEvent_FWD_DEFINED__
typedef interface IRTCBuddyGroupEvent IRTCBuddyGroupEvent;
#endif 	/* __IRTCBuddyGroupEvent_FWD_DEFINED__ */


#ifndef __IRTCInfoEvent_FWD_DEFINED__
#define __IRTCInfoEvent_FWD_DEFINED__
typedef interface IRTCInfoEvent IRTCInfoEvent;
#endif 	/* __IRTCInfoEvent_FWD_DEFINED__ */


#ifndef __IRTCMediaRequestEvent_FWD_DEFINED__
#define __IRTCMediaRequestEvent_FWD_DEFINED__
typedef interface IRTCMediaRequestEvent IRTCMediaRequestEvent;
#endif 	/* __IRTCMediaRequestEvent_FWD_DEFINED__ */


#ifndef __IRTCReInviteEvent_FWD_DEFINED__
#define __IRTCReInviteEvent_FWD_DEFINED__
typedef interface IRTCReInviteEvent IRTCReInviteEvent;
#endif 	/* __IRTCReInviteEvent_FWD_DEFINED__ */


#ifndef __IRTCPresencePropertyEvent_FWD_DEFINED__
#define __IRTCPresencePropertyEvent_FWD_DEFINED__
typedef interface IRTCPresencePropertyEvent IRTCPresencePropertyEvent;
#endif 	/* __IRTCPresencePropertyEvent_FWD_DEFINED__ */


#ifndef __IRTCPresenceDataEvent_FWD_DEFINED__
#define __IRTCPresenceDataEvent_FWD_DEFINED__
typedef interface IRTCPresenceDataEvent IRTCPresenceDataEvent;
#endif 	/* __IRTCPresenceDataEvent_FWD_DEFINED__ */


#ifndef __IRTCPresenceStatusEvent_FWD_DEFINED__
#define __IRTCPresenceStatusEvent_FWD_DEFINED__
typedef interface IRTCPresenceStatusEvent IRTCPresenceStatusEvent;
#endif 	/* __IRTCPresenceStatusEvent_FWD_DEFINED__ */


#ifndef __IRTCCollection_FWD_DEFINED__
#define __IRTCCollection_FWD_DEFINED__
typedef interface IRTCCollection IRTCCollection;
#endif 	/* __IRTCCollection_FWD_DEFINED__ */


#ifndef __IRTCEnumParticipants_FWD_DEFINED__
#define __IRTCEnumParticipants_FWD_DEFINED__
typedef interface IRTCEnumParticipants IRTCEnumParticipants;
#endif 	/* __IRTCEnumParticipants_FWD_DEFINED__ */


#ifndef __IRTCEnumProfiles_FWD_DEFINED__
#define __IRTCEnumProfiles_FWD_DEFINED__
typedef interface IRTCEnumProfiles IRTCEnumProfiles;
#endif 	/* __IRTCEnumProfiles_FWD_DEFINED__ */


#ifndef __IRTCEnumBuddies_FWD_DEFINED__
#define __IRTCEnumBuddies_FWD_DEFINED__
typedef interface IRTCEnumBuddies IRTCEnumBuddies;
#endif 	/* __IRTCEnumBuddies_FWD_DEFINED__ */


#ifndef __IRTCEnumWatchers_FWD_DEFINED__
#define __IRTCEnumWatchers_FWD_DEFINED__
typedef interface IRTCEnumWatchers IRTCEnumWatchers;
#endif 	/* __IRTCEnumWatchers_FWD_DEFINED__ */


#ifndef __IRTCEnumGroups_FWD_DEFINED__
#define __IRTCEnumGroups_FWD_DEFINED__
typedef interface IRTCEnumGroups IRTCEnumGroups;
#endif 	/* __IRTCEnumGroups_FWD_DEFINED__ */


#ifndef __IRTCPresenceContact_FWD_DEFINED__
#define __IRTCPresenceContact_FWD_DEFINED__
typedef interface IRTCPresenceContact IRTCPresenceContact;
#endif 	/* __IRTCPresenceContact_FWD_DEFINED__ */


#ifndef __IRTCBuddy_FWD_DEFINED__
#define __IRTCBuddy_FWD_DEFINED__
typedef interface IRTCBuddy IRTCBuddy;
#endif 	/* __IRTCBuddy_FWD_DEFINED__ */


#ifndef __IRTCBuddy2_FWD_DEFINED__
#define __IRTCBuddy2_FWD_DEFINED__
typedef interface IRTCBuddy2 IRTCBuddy2;
#endif 	/* __IRTCBuddy2_FWD_DEFINED__ */


#ifndef __IRTCWatcher_FWD_DEFINED__
#define __IRTCWatcher_FWD_DEFINED__
typedef interface IRTCWatcher IRTCWatcher;
#endif 	/* __IRTCWatcher_FWD_DEFINED__ */


#ifndef __IRTCWatcher2_FWD_DEFINED__
#define __IRTCWatcher2_FWD_DEFINED__
typedef interface IRTCWatcher2 IRTCWatcher2;
#endif 	/* __IRTCWatcher2_FWD_DEFINED__ */


#ifndef __IRTCBuddyGroup_FWD_DEFINED__
#define __IRTCBuddyGroup_FWD_DEFINED__
typedef interface IRTCBuddyGroup IRTCBuddyGroup;
#endif 	/* __IRTCBuddyGroup_FWD_DEFINED__ */


#ifndef __IRTCEventNotification_FWD_DEFINED__
#define __IRTCEventNotification_FWD_DEFINED__
typedef interface IRTCEventNotification IRTCEventNotification;
#endif 	/* __IRTCEventNotification_FWD_DEFINED__ */


#ifndef __IRTCDispatchEventNotification_FWD_DEFINED__
#define __IRTCDispatchEventNotification_FWD_DEFINED__
typedef interface IRTCDispatchEventNotification IRTCDispatchEventNotification;
#endif 	/* __IRTCDispatchEventNotification_FWD_DEFINED__ */


#ifndef __IRTCPortManager_FWD_DEFINED__
#define __IRTCPortManager_FWD_DEFINED__
typedef interface IRTCPortManager IRTCPortManager;
#endif 	/* __IRTCPortManager_FWD_DEFINED__ */


#ifndef __IRTCSessionPortManagement_FWD_DEFINED__
#define __IRTCSessionPortManagement_FWD_DEFINED__
typedef interface IRTCSessionPortManagement IRTCSessionPortManagement;
#endif 	/* __IRTCSessionPortManagement_FWD_DEFINED__ */


#ifndef __IRTCClientPortManagement_FWD_DEFINED__
#define __IRTCClientPortManagement_FWD_DEFINED__
typedef interface IRTCClientPortManagement IRTCClientPortManagement;
#endif 	/* __IRTCClientPortManagement_FWD_DEFINED__ */


#ifndef __IRTCUserSearch_FWD_DEFINED__
#define __IRTCUserSearch_FWD_DEFINED__
typedef interface IRTCUserSearch IRTCUserSearch;
#endif 	/* __IRTCUserSearch_FWD_DEFINED__ */


#ifndef __IRTCUserSearchQuery_FWD_DEFINED__
#define __IRTCUserSearchQuery_FWD_DEFINED__
typedef interface IRTCUserSearchQuery IRTCUserSearchQuery;
#endif 	/* __IRTCUserSearchQuery_FWD_DEFINED__ */


#ifndef __IRTCUserSearchResult_FWD_DEFINED__
#define __IRTCUserSearchResult_FWD_DEFINED__
typedef interface IRTCUserSearchResult IRTCUserSearchResult;
#endif 	/* __IRTCUserSearchResult_FWD_DEFINED__ */


#ifndef __IRTCEnumUserSearchResults_FWD_DEFINED__
#define __IRTCEnumUserSearchResults_FWD_DEFINED__
typedef interface IRTCEnumUserSearchResults IRTCEnumUserSearchResults;
#endif 	/* __IRTCEnumUserSearchResults_FWD_DEFINED__ */


#ifndef __IRTCUserSearchResultsEvent_FWD_DEFINED__
#define __IRTCUserSearchResultsEvent_FWD_DEFINED__
typedef interface IRTCUserSearchResultsEvent IRTCUserSearchResultsEvent;
#endif 	/* __IRTCUserSearchResultsEvent_FWD_DEFINED__ */


#ifndef __IRTCSessionReferStatusEvent_FWD_DEFINED__
#define __IRTCSessionReferStatusEvent_FWD_DEFINED__
typedef interface IRTCSessionReferStatusEvent IRTCSessionReferStatusEvent;
#endif 	/* __IRTCSessionReferStatusEvent_FWD_DEFINED__ */


#ifndef __IRTCSessionReferredEvent_FWD_DEFINED__
#define __IRTCSessionReferredEvent_FWD_DEFINED__
typedef interface IRTCSessionReferredEvent IRTCSessionReferredEvent;
#endif 	/* __IRTCSessionReferredEvent_FWD_DEFINED__ */


#ifndef __IRTCSessionDescriptionManager_FWD_DEFINED__
#define __IRTCSessionDescriptionManager_FWD_DEFINED__
typedef interface IRTCSessionDescriptionManager IRTCSessionDescriptionManager;
#endif 	/* __IRTCSessionDescriptionManager_FWD_DEFINED__ */


#ifndef __IRTCEnumPresenceDevices_FWD_DEFINED__
#define __IRTCEnumPresenceDevices_FWD_DEFINED__
typedef interface IRTCEnumPresenceDevices IRTCEnumPresenceDevices;
#endif 	/* __IRTCEnumPresenceDevices_FWD_DEFINED__ */


#ifndef __IRTCPresenceDevice_FWD_DEFINED__
#define __IRTCPresenceDevice_FWD_DEFINED__
typedef interface IRTCPresenceDevice IRTCPresenceDevice;
#endif 	/* __IRTCPresenceDevice_FWD_DEFINED__ */


#ifndef __IRTCProfile_FWD_DEFINED__
#define __IRTCProfile_FWD_DEFINED__
typedef interface IRTCProfile IRTCProfile;
#endif 	/* __IRTCProfile_FWD_DEFINED__ */


#ifndef __IRTCProfile2_FWD_DEFINED__
#define __IRTCProfile2_FWD_DEFINED__
typedef interface IRTCProfile2 IRTCProfile2;
#endif 	/* __IRTCProfile2_FWD_DEFINED__ */


#ifndef __IRTCEnumProfiles_FWD_DEFINED__
#define __IRTCEnumProfiles_FWD_DEFINED__
typedef interface IRTCEnumProfiles IRTCEnumProfiles;
#endif 	/* __IRTCEnumProfiles_FWD_DEFINED__ */


#ifndef __IRTCSession_FWD_DEFINED__
#define __IRTCSession_FWD_DEFINED__
typedef interface IRTCSession IRTCSession;
#endif 	/* __IRTCSession_FWD_DEFINED__ */


#ifndef __IRTCSession2_FWD_DEFINED__
#define __IRTCSession2_FWD_DEFINED__
typedef interface IRTCSession2 IRTCSession2;
#endif 	/* __IRTCSession2_FWD_DEFINED__ */


#ifndef __IRTCSessionCallControl_FWD_DEFINED__
#define __IRTCSessionCallControl_FWD_DEFINED__
typedef interface IRTCSessionCallControl IRTCSessionCallControl;
#endif 	/* __IRTCSessionCallControl_FWD_DEFINED__ */


#ifndef __IRTCParticipant_FWD_DEFINED__
#define __IRTCParticipant_FWD_DEFINED__
typedef interface IRTCParticipant IRTCParticipant;
#endif 	/* __IRTCParticipant_FWD_DEFINED__ */


#ifndef __IRTCEnumParticipants_FWD_DEFINED__
#define __IRTCEnumParticipants_FWD_DEFINED__
typedef interface IRTCEnumParticipants IRTCEnumParticipants;
#endif 	/* __IRTCEnumParticipants_FWD_DEFINED__ */


#ifndef __IRTCCollection_FWD_DEFINED__
#define __IRTCCollection_FWD_DEFINED__
typedef interface IRTCCollection IRTCCollection;
#endif 	/* __IRTCCollection_FWD_DEFINED__ */


#ifndef __IRTCPresenceContact_FWD_DEFINED__
#define __IRTCPresenceContact_FWD_DEFINED__
typedef interface IRTCPresenceContact IRTCPresenceContact;
#endif 	/* __IRTCPresenceContact_FWD_DEFINED__ */


#ifndef __IRTCBuddy_FWD_DEFINED__
#define __IRTCBuddy_FWD_DEFINED__
typedef interface IRTCBuddy IRTCBuddy;
#endif 	/* __IRTCBuddy_FWD_DEFINED__ */


#ifndef __IRTCBuddy2_FWD_DEFINED__
#define __IRTCBuddy2_FWD_DEFINED__
typedef interface IRTCBuddy2 IRTCBuddy2;
#endif 	/* __IRTCBuddy2_FWD_DEFINED__ */


#ifndef __IRTCEnumBuddies_FWD_DEFINED__
#define __IRTCEnumBuddies_FWD_DEFINED__
typedef interface IRTCEnumBuddies IRTCEnumBuddies;
#endif 	/* __IRTCEnumBuddies_FWD_DEFINED__ */


#ifndef __IRTCWatcher_FWD_DEFINED__
#define __IRTCWatcher_FWD_DEFINED__
typedef interface IRTCWatcher IRTCWatcher;
#endif 	/* __IRTCWatcher_FWD_DEFINED__ */


#ifndef __IRTCWatcher2_FWD_DEFINED__
#define __IRTCWatcher2_FWD_DEFINED__
typedef interface IRTCWatcher2 IRTCWatcher2;
#endif 	/* __IRTCWatcher2_FWD_DEFINED__ */


#ifndef __IRTCEnumWatchers_FWD_DEFINED__
#define __IRTCEnumWatchers_FWD_DEFINED__
typedef interface IRTCEnumWatchers IRTCEnumWatchers;
#endif 	/* __IRTCEnumWatchers_FWD_DEFINED__ */


#ifndef __IRTCBuddyGroup_FWD_DEFINED__
#define __IRTCBuddyGroup_FWD_DEFINED__
typedef interface IRTCBuddyGroup IRTCBuddyGroup;
#endif 	/* __IRTCBuddyGroup_FWD_DEFINED__ */


#ifndef __IRTCEnumGroups_FWD_DEFINED__
#define __IRTCEnumGroups_FWD_DEFINED__
typedef interface IRTCEnumGroups IRTCEnumGroups;
#endif 	/* __IRTCEnumGroups_FWD_DEFINED__ */


#ifndef __IRTCUserSearchQuery_FWD_DEFINED__
#define __IRTCUserSearchQuery_FWD_DEFINED__
typedef interface IRTCUserSearchQuery IRTCUserSearchQuery;
#endif 	/* __IRTCUserSearchQuery_FWD_DEFINED__ */


#ifndef __IRTCUserSearchResult_FWD_DEFINED__
#define __IRTCUserSearchResult_FWD_DEFINED__
typedef interface IRTCUserSearchResult IRTCUserSearchResult;
#endif 	/* __IRTCUserSearchResult_FWD_DEFINED__ */


#ifndef __IRTCEnumUserSearchResults_FWD_DEFINED__
#define __IRTCEnumUserSearchResults_FWD_DEFINED__
typedef interface IRTCEnumUserSearchResults IRTCEnumUserSearchResults;
#endif 	/* __IRTCEnumUserSearchResults_FWD_DEFINED__ */


#ifndef __IRTCEventNotification_FWD_DEFINED__
#define __IRTCEventNotification_FWD_DEFINED__
typedef interface IRTCEventNotification IRTCEventNotification;
#endif 	/* __IRTCEventNotification_FWD_DEFINED__ */


#ifndef __IRTCClientEvent_FWD_DEFINED__
#define __IRTCClientEvent_FWD_DEFINED__
typedef interface IRTCClientEvent IRTCClientEvent;
#endif 	/* __IRTCClientEvent_FWD_DEFINED__ */


#ifndef __IRTCRegistrationStateChangeEvent_FWD_DEFINED__
#define __IRTCRegistrationStateChangeEvent_FWD_DEFINED__
typedef interface IRTCRegistrationStateChangeEvent IRTCRegistrationStateChangeEvent;
#endif 	/* __IRTCRegistrationStateChangeEvent_FWD_DEFINED__ */


#ifndef __IRTCSessionStateChangeEvent_FWD_DEFINED__
#define __IRTCSessionStateChangeEvent_FWD_DEFINED__
typedef interface IRTCSessionStateChangeEvent IRTCSessionStateChangeEvent;
#endif 	/* __IRTCSessionStateChangeEvent_FWD_DEFINED__ */


#ifndef __IRTCSessionStateChangeEvent2_FWD_DEFINED__
#define __IRTCSessionStateChangeEvent2_FWD_DEFINED__
typedef interface IRTCSessionStateChangeEvent2 IRTCSessionStateChangeEvent2;
#endif 	/* __IRTCSessionStateChangeEvent2_FWD_DEFINED__ */


#ifndef __IRTCSessionOperationCompleteEvent_FWD_DEFINED__
#define __IRTCSessionOperationCompleteEvent_FWD_DEFINED__
typedef interface IRTCSessionOperationCompleteEvent IRTCSessionOperationCompleteEvent;
#endif 	/* __IRTCSessionOperationCompleteEvent_FWD_DEFINED__ */


#ifndef __IRTCSessionOperationCompleteEvent2_FWD_DEFINED__
#define __IRTCSessionOperationCompleteEvent2_FWD_DEFINED__
typedef interface IRTCSessionOperationCompleteEvent2 IRTCSessionOperationCompleteEvent2;
#endif 	/* __IRTCSessionOperationCompleteEvent2_FWD_DEFINED__ */


#ifndef __IRTCParticipantStateChangeEvent_FWD_DEFINED__
#define __IRTCParticipantStateChangeEvent_FWD_DEFINED__
typedef interface IRTCParticipantStateChangeEvent IRTCParticipantStateChangeEvent;
#endif 	/* __IRTCParticipantStateChangeEvent_FWD_DEFINED__ */


#ifndef __IRTCMediaEvent_FWD_DEFINED__
#define __IRTCMediaEvent_FWD_DEFINED__
typedef interface IRTCMediaEvent IRTCMediaEvent;
#endif 	/* __IRTCMediaEvent_FWD_DEFINED__ */


#ifndef __IRTCIntensityEvent_FWD_DEFINED__
#define __IRTCIntensityEvent_FWD_DEFINED__
typedef interface IRTCIntensityEvent IRTCIntensityEvent;
#endif 	/* __IRTCIntensityEvent_FWD_DEFINED__ */


#ifndef __IRTCMessagingEvent_FWD_DEFINED__
#define __IRTCMessagingEvent_FWD_DEFINED__
typedef interface IRTCMessagingEvent IRTCMessagingEvent;
#endif 	/* __IRTCMessagingEvent_FWD_DEFINED__ */


#ifndef __IRTCBuddyEvent_FWD_DEFINED__
#define __IRTCBuddyEvent_FWD_DEFINED__
typedef interface IRTCBuddyEvent IRTCBuddyEvent;
#endif 	/* __IRTCBuddyEvent_FWD_DEFINED__ */


#ifndef __IRTCBuddyEvent2_FWD_DEFINED__
#define __IRTCBuddyEvent2_FWD_DEFINED__
typedef interface IRTCBuddyEvent2 IRTCBuddyEvent2;
#endif 	/* __IRTCBuddyEvent2_FWD_DEFINED__ */


#ifndef __IRTCWatcherEvent_FWD_DEFINED__
#define __IRTCWatcherEvent_FWD_DEFINED__
typedef interface IRTCWatcherEvent IRTCWatcherEvent;
#endif 	/* __IRTCWatcherEvent_FWD_DEFINED__ */


#ifndef __IRTCPortManager_FWD_DEFINED__
#define __IRTCPortManager_FWD_DEFINED__
typedef interface IRTCPortManager IRTCPortManager;
#endif 	/* __IRTCPortManager_FWD_DEFINED__ */


#ifndef __IRTCSessionPortManagement_FWD_DEFINED__
#define __IRTCSessionPortManagement_FWD_DEFINED__
typedef interface IRTCSessionPortManagement IRTCSessionPortManagement;
#endif 	/* __IRTCSessionPortManagement_FWD_DEFINED__ */


#ifndef __IRTCClientPortManagement_FWD_DEFINED__
#define __IRTCClientPortManagement_FWD_DEFINED__
typedef interface IRTCClientPortManagement IRTCClientPortManagement;
#endif 	/* __IRTCClientPortManagement_FWD_DEFINED__ */


#ifndef __IRTCWatcherEvent2_FWD_DEFINED__
#define __IRTCWatcherEvent2_FWD_DEFINED__
typedef interface IRTCWatcherEvent2 IRTCWatcherEvent2;
#endif 	/* __IRTCWatcherEvent2_FWD_DEFINED__ */


#ifndef __IRTCBuddyGroupEvent_FWD_DEFINED__
#define __IRTCBuddyGroupEvent_FWD_DEFINED__
typedef interface IRTCBuddyGroupEvent IRTCBuddyGroupEvent;
#endif 	/* __IRTCBuddyGroupEvent_FWD_DEFINED__ */


#ifndef __IRTCProfileEvent_FWD_DEFINED__
#define __IRTCProfileEvent_FWD_DEFINED__
typedef interface IRTCProfileEvent IRTCProfileEvent;
#endif 	/* __IRTCProfileEvent_FWD_DEFINED__ */


#ifndef __IRTCProfileEvent2_FWD_DEFINED__
#define __IRTCProfileEvent2_FWD_DEFINED__
typedef interface IRTCProfileEvent2 IRTCProfileEvent2;
#endif 	/* __IRTCProfileEvent2_FWD_DEFINED__ */


#ifndef __IRTCUserSearchResultsEvent_FWD_DEFINED__
#define __IRTCUserSearchResultsEvent_FWD_DEFINED__
typedef interface IRTCUserSearchResultsEvent IRTCUserSearchResultsEvent;
#endif 	/* __IRTCUserSearchResultsEvent_FWD_DEFINED__ */


#ifndef __IRTCInfoEvent_FWD_DEFINED__
#define __IRTCInfoEvent_FWD_DEFINED__
typedef interface IRTCInfoEvent IRTCInfoEvent;
#endif 	/* __IRTCInfoEvent_FWD_DEFINED__ */


#ifndef __IRTCRoamingEvent_FWD_DEFINED__
#define __IRTCRoamingEvent_FWD_DEFINED__
typedef interface IRTCRoamingEvent IRTCRoamingEvent;
#endif 	/* __IRTCRoamingEvent_FWD_DEFINED__ */


#ifndef __IRTCMediaRequestEvent_FWD_DEFINED__
#define __IRTCMediaRequestEvent_FWD_DEFINED__
typedef interface IRTCMediaRequestEvent IRTCMediaRequestEvent;
#endif 	/* __IRTCMediaRequestEvent_FWD_DEFINED__ */


#ifndef __IRTCReInviteEvent_FWD_DEFINED__
#define __IRTCReInviteEvent_FWD_DEFINED__
typedef interface IRTCReInviteEvent IRTCReInviteEvent;
#endif 	/* __IRTCReInviteEvent_FWD_DEFINED__ */


#ifndef __IRTCPresencePropertyEvent_FWD_DEFINED__
#define __IRTCPresencePropertyEvent_FWD_DEFINED__
typedef interface IRTCPresencePropertyEvent IRTCPresencePropertyEvent;
#endif 	/* __IRTCPresencePropertyEvent_FWD_DEFINED__ */


#ifndef __IRTCPresenceDataEvent_FWD_DEFINED__
#define __IRTCPresenceDataEvent_FWD_DEFINED__
typedef interface IRTCPresenceDataEvent IRTCPresenceDataEvent;
#endif 	/* __IRTCPresenceDataEvent_FWD_DEFINED__ */


#ifndef __IRTCPresenceStatusEvent_FWD_DEFINED__
#define __IRTCPresenceStatusEvent_FWD_DEFINED__
typedef interface IRTCPresenceStatusEvent IRTCPresenceStatusEvent;
#endif 	/* __IRTCPresenceStatusEvent_FWD_DEFINED__ */


#ifndef __IRTCSessionReferStatusEvent_FWD_DEFINED__
#define __IRTCSessionReferStatusEvent_FWD_DEFINED__
typedef interface IRTCSessionReferStatusEvent IRTCSessionReferStatusEvent;
#endif 	/* __IRTCSessionReferStatusEvent_FWD_DEFINED__ */


#ifndef __IRTCSessionReferredEvent_FWD_DEFINED__
#define __IRTCSessionReferredEvent_FWD_DEFINED__
typedef interface IRTCSessionReferredEvent IRTCSessionReferredEvent;
#endif 	/* __IRTCSessionReferredEvent_FWD_DEFINED__ */


#ifndef __IRTCSessionDescriptionManager_FWD_DEFINED__
#define __IRTCSessionDescriptionManager_FWD_DEFINED__
typedef interface IRTCSessionDescriptionManager IRTCSessionDescriptionManager;
#endif 	/* __IRTCSessionDescriptionManager_FWD_DEFINED__ */


#ifndef __IRTCEnumPresenceDevices_FWD_DEFINED__
#define __IRTCEnumPresenceDevices_FWD_DEFINED__
typedef interface IRTCEnumPresenceDevices IRTCEnumPresenceDevices;
#endif 	/* __IRTCEnumPresenceDevices_FWD_DEFINED__ */


#ifndef __IRTCPresenceDevice_FWD_DEFINED__
#define __IRTCPresenceDevice_FWD_DEFINED__
typedef interface IRTCPresenceDevice IRTCPresenceDevice;
#endif 	/* __IRTCPresenceDevice_FWD_DEFINED__ */


#ifndef __IRTCDispatchEventNotification_FWD_DEFINED__
#define __IRTCDispatchEventNotification_FWD_DEFINED__
typedef interface IRTCDispatchEventNotification IRTCDispatchEventNotification;
#endif 	/* __IRTCDispatchEventNotification_FWD_DEFINED__ */


#ifndef __RTCClient_FWD_DEFINED__
#define __RTCClient_FWD_DEFINED__

#ifdef __cplusplus
typedef class RTCClient RTCClient;
#else
typedef struct RTCClient RTCClient;
#endif /* __cplusplus */

#endif 	/* __RTCClient_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "control.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_rtccore_0000_0000 */
/* [local] */ 

//  Copyright (c) Microsoft Corporation.  All rights reserved.
typedef 
enum RTC_AUDIO_DEVICE
    {	RTCAD_SPEAKER	= 0,
	RTCAD_MICROPHONE	= ( RTCAD_SPEAKER + 1 ) 
    } 	RTC_AUDIO_DEVICE;

typedef 
enum RTC_VIDEO_DEVICE
    {	RTCVD_RECEIVE	= 0,
	RTCVD_PREVIEW	= ( RTCVD_RECEIVE + 1 ) 
    } 	RTC_VIDEO_DEVICE;

typedef 
enum RTC_EVENT
    {	RTCE_CLIENT	= 0,
	RTCE_REGISTRATION_STATE_CHANGE	= ( RTCE_CLIENT + 1 ) ,
	RTCE_SESSION_STATE_CHANGE	= ( RTCE_REGISTRATION_STATE_CHANGE + 1 ) ,
	RTCE_SESSION_OPERATION_COMPLETE	= ( RTCE_SESSION_STATE_CHANGE + 1 ) ,
	RTCE_PARTICIPANT_STATE_CHANGE	= ( RTCE_SESSION_OPERATION_COMPLETE + 1 ) ,
	RTCE_MEDIA	= ( RTCE_PARTICIPANT_STATE_CHANGE + 1 ) ,
	RTCE_INTENSITY	= ( RTCE_MEDIA + 1 ) ,
	RTCE_MESSAGING	= ( RTCE_INTENSITY + 1 ) ,
	RTCE_BUDDY	= ( RTCE_MESSAGING + 1 ) ,
	RTCE_WATCHER	= ( RTCE_BUDDY + 1 ) ,
	RTCE_PROFILE	= ( RTCE_WATCHER + 1 ) ,
	RTCE_USERSEARCH	= ( RTCE_PROFILE + 1 ) ,
	RTCE_INFO	= ( RTCE_USERSEARCH + 1 ) ,
	RTCE_GROUP	= ( RTCE_INFO + 1 ) ,
	RTCE_MEDIA_REQUEST	= ( RTCE_GROUP + 1 ) ,
	RTCE_ROAMING	= ( RTCE_MEDIA_REQUEST + 1 ) ,
	RTCE_PRESENCE_PROPERTY	= ( RTCE_ROAMING + 1 ) ,
	RTCE_PRESENCE_DATA	= ( RTCE_PRESENCE_PROPERTY + 1 ) ,
	RTCE_PRESENCE_STATUS	= ( RTCE_PRESENCE_DATA + 1 ) ,
	RTCE_SESSION_REFER_STATUS	= ( RTCE_PRESENCE_STATUS + 1 ) ,
	RTCE_SESSION_REFERRED	= ( RTCE_SESSION_REFER_STATUS + 1 ) ,
	RTCE_REINVITE	= ( RTCE_SESSION_REFERRED + 1 ) 
    } 	RTC_EVENT;

typedef 
enum RTC_LISTEN_MODE
    {	RTCLM_NONE	= 0,
	RTCLM_DYNAMIC	= ( RTCLM_NONE + 1 ) ,
	RTCLM_BOTH	= ( RTCLM_DYNAMIC + 1 ) 
    } 	RTC_LISTEN_MODE;

typedef 
enum RTC_CLIENT_EVENT_TYPE
    {	RTCCET_VOLUME_CHANGE	= 0,
	RTCCET_DEVICE_CHANGE	= ( RTCCET_VOLUME_CHANGE + 1 ) ,
	RTCCET_NETWORK_QUALITY_CHANGE	= ( RTCCET_DEVICE_CHANGE + 1 ) ,
	RTCCET_ASYNC_CLEANUP_DONE	= ( RTCCET_NETWORK_QUALITY_CHANGE + 1 ) 
    } 	RTC_CLIENT_EVENT_TYPE;

typedef 
enum RTC_BUDDY_EVENT_TYPE
    {	RTCBET_BUDDY_ADD	= 0,
	RTCBET_BUDDY_REMOVE	= ( RTCBET_BUDDY_ADD + 1 ) ,
	RTCBET_BUDDY_UPDATE	= ( RTCBET_BUDDY_REMOVE + 1 ) ,
	RTCBET_BUDDY_STATE_CHANGE	= ( RTCBET_BUDDY_UPDATE + 1 ) ,
	RTCBET_BUDDY_ROAMED	= ( RTCBET_BUDDY_STATE_CHANGE + 1 ) ,
	RTCBET_BUDDY_SUBSCRIBED	= ( RTCBET_BUDDY_ROAMED + 1 ) 
    } 	RTC_BUDDY_EVENT_TYPE;

typedef 
enum RTC_WATCHER_EVENT_TYPE
    {	RTCWET_WATCHER_ADD	= 0,
	RTCWET_WATCHER_REMOVE	= ( RTCWET_WATCHER_ADD + 1 ) ,
	RTCWET_WATCHER_UPDATE	= ( RTCWET_WATCHER_REMOVE + 1 ) ,
	RTCWET_WATCHER_OFFERING	= ( RTCWET_WATCHER_UPDATE + 1 ) ,
	RTCWET_WATCHER_ROAMED	= ( RTCWET_WATCHER_OFFERING + 1 ) 
    } 	RTC_WATCHER_EVENT_TYPE;

typedef 
enum RTC_GROUP_EVENT_TYPE
    {	RTCGET_GROUP_ADD	= 0,
	RTCGET_GROUP_REMOVE	= ( RTCGET_GROUP_ADD + 1 ) ,
	RTCGET_GROUP_UPDATE	= ( RTCGET_GROUP_REMOVE + 1 ) ,
	RTCGET_GROUP_BUDDY_ADD	= ( RTCGET_GROUP_UPDATE + 1 ) ,
	RTCGET_GROUP_BUDDY_REMOVE	= ( RTCGET_GROUP_BUDDY_ADD + 1 ) ,
	RTCGET_GROUP_ROAMED	= ( RTCGET_GROUP_BUDDY_REMOVE + 1 ) 
    } 	RTC_GROUP_EVENT_TYPE;

typedef 
enum RTC_TERMINATE_REASON
    {	RTCTR_NORMAL	= 0,
	RTCTR_DND	= ( RTCTR_NORMAL + 1 ) ,
	RTCTR_BUSY	= ( RTCTR_DND + 1 ) ,
	RTCTR_REJECT	= ( RTCTR_BUSY + 1 ) ,
	RTCTR_TIMEOUT	= ( RTCTR_REJECT + 1 ) ,
	RTCTR_SHUTDOWN	= ( RTCTR_TIMEOUT + 1 ) ,
	RTCTR_INSUFFICIENT_SECURITY_LEVEL	= ( RTCTR_SHUTDOWN + 1 ) ,
	RTCTR_NOT_SUPPORTED	= ( RTCTR_INSUFFICIENT_SECURITY_LEVEL + 1 ) 
    } 	RTC_TERMINATE_REASON;

typedef 
enum RTC_REGISTRATION_STATE
    {	RTCRS_NOT_REGISTERED	= 0,
	RTCRS_REGISTERING	= ( RTCRS_NOT_REGISTERED + 1 ) ,
	RTCRS_REGISTERED	= ( RTCRS_REGISTERING + 1 ) ,
	RTCRS_REJECTED	= ( RTCRS_REGISTERED + 1 ) ,
	RTCRS_UNREGISTERING	= ( RTCRS_REJECTED + 1 ) ,
	RTCRS_ERROR	= ( RTCRS_UNREGISTERING + 1 ) ,
	RTCRS_LOGGED_OFF	= ( RTCRS_ERROR + 1 ) ,
	RTCRS_LOCAL_PA_LOGGED_OFF	= ( RTCRS_LOGGED_OFF + 1 ) ,
	RTCRS_REMOTE_PA_LOGGED_OFF	= ( RTCRS_LOCAL_PA_LOGGED_OFF + 1 ) 
    } 	RTC_REGISTRATION_STATE;

typedef 
enum RTC_SESSION_STATE
    {	RTCSS_IDLE	= 0,
	RTCSS_INCOMING	= ( RTCSS_IDLE + 1 ) ,
	RTCSS_ANSWERING	= ( RTCSS_INCOMING + 1 ) ,
	RTCSS_INPROGRESS	= ( RTCSS_ANSWERING + 1 ) ,
	RTCSS_CONNECTED	= ( RTCSS_INPROGRESS + 1 ) ,
	RTCSS_DISCONNECTED	= ( RTCSS_CONNECTED + 1 ) ,
	RTCSS_HOLD	= ( RTCSS_DISCONNECTED + 1 ) ,
	RTCSS_REFER	= ( RTCSS_HOLD + 1 ) 
    } 	RTC_SESSION_STATE;

typedef 
enum RTC_PARTICIPANT_STATE
    {	RTCPS_IDLE	= 0,
	RTCPS_PENDING	= ( RTCPS_IDLE + 1 ) ,
	RTCPS_INCOMING	= ( RTCPS_PENDING + 1 ) ,
	RTCPS_ANSWERING	= ( RTCPS_INCOMING + 1 ) ,
	RTCPS_INPROGRESS	= ( RTCPS_ANSWERING + 1 ) ,
	RTCPS_ALERTING	= ( RTCPS_INPROGRESS + 1 ) ,
	RTCPS_CONNECTED	= ( RTCPS_ALERTING + 1 ) ,
	RTCPS_DISCONNECTING	= ( RTCPS_CONNECTED + 1 ) ,
	RTCPS_DISCONNECTED	= ( RTCPS_DISCONNECTING + 1 ) 
    } 	RTC_PARTICIPANT_STATE;

typedef 
enum RTC_WATCHER_STATE
    {	RTCWS_UNKNOWN	= 0,
	RTCWS_OFFERING	= ( RTCWS_UNKNOWN + 1 ) ,
	RTCWS_ALLOWED	= ( RTCWS_OFFERING + 1 ) ,
	RTCWS_BLOCKED	= ( RTCWS_ALLOWED + 1 ) ,
	RTCWS_DENIED	= ( RTCWS_BLOCKED + 1 ) ,
	RTCWS_PROMPT	= ( RTCWS_DENIED + 1 ) 
    } 	RTC_WATCHER_STATE;

typedef 
enum RTC_ACE_SCOPE
    {	RTCAS_SCOPE_USER	= 0,
	RTCAS_SCOPE_DOMAIN	= ( RTCAS_SCOPE_USER + 1 ) ,
	RTCAS_SCOPE_ALL	= ( RTCAS_SCOPE_DOMAIN + 1 ) 
    } 	RTC_ACE_SCOPE;

typedef 
enum RTC_OFFER_WATCHER_MODE
    {	RTCOWM_OFFER_WATCHER_EVENT	= 0,
	RTCOWM_AUTOMATICALLY_ADD_WATCHER	= ( RTCOWM_OFFER_WATCHER_EVENT + 1 ) 
    } 	RTC_OFFER_WATCHER_MODE;

typedef 
enum RTC_WATCHER_MATCH_MODE
    {	RTCWMM_EXACT_MATCH	= 0,
	RTCWMM_BEST_ACE_MATCH	= ( RTCWMM_EXACT_MATCH + 1 ) 
    } 	RTC_WATCHER_MATCH_MODE;

typedef 
enum RTC_PRIVACY_MODE
    {	RTCPM_BLOCK_LIST_EXCLUDED	= 0,
	RTCPM_ALLOW_LIST_ONLY	= ( RTCPM_BLOCK_LIST_EXCLUDED + 1 ) 
    } 	RTC_PRIVACY_MODE;

typedef 
enum RTC_SESSION_TYPE
    {	RTCST_PC_TO_PC	= 0,
	RTCST_PC_TO_PHONE	= ( RTCST_PC_TO_PC + 1 ) ,
	RTCST_PHONE_TO_PHONE	= ( RTCST_PC_TO_PHONE + 1 ) ,
	RTCST_IM	= ( RTCST_PHONE_TO_PHONE + 1 ) ,
	RTCST_MULTIPARTY_IM	= ( RTCST_IM + 1 ) ,
	RTCST_APPLICATION	= ( RTCST_MULTIPARTY_IM + 1 ) 
    } 	RTC_SESSION_TYPE;

typedef 
enum RTC_PRESENCE_STATUS
    {	RTCXS_PRESENCE_OFFLINE	= 0,
	RTCXS_PRESENCE_ONLINE	= ( RTCXS_PRESENCE_OFFLINE + 1 ) ,
	RTCXS_PRESENCE_AWAY	= ( RTCXS_PRESENCE_ONLINE + 1 ) ,
	RTCXS_PRESENCE_IDLE	= ( RTCXS_PRESENCE_AWAY + 1 ) ,
	RTCXS_PRESENCE_BUSY	= ( RTCXS_PRESENCE_IDLE + 1 ) ,
	RTCXS_PRESENCE_BE_RIGHT_BACK	= ( RTCXS_PRESENCE_BUSY + 1 ) ,
	RTCXS_PRESENCE_ON_THE_PHONE	= ( RTCXS_PRESENCE_BE_RIGHT_BACK + 1 ) ,
	RTCXS_PRESENCE_OUT_TO_LUNCH	= ( RTCXS_PRESENCE_ON_THE_PHONE + 1 ) 
    } 	RTC_PRESENCE_STATUS;

typedef 
enum RTC_BUDDY_SUBSCRIPTION_TYPE
    {	RTCBT_SUBSCRIBED	= 0,
	RTCBT_ALWAYS_OFFLINE	= ( RTCBT_SUBSCRIBED + 1 ) ,
	RTCBT_ALWAYS_ONLINE	= ( RTCBT_ALWAYS_OFFLINE + 1 ) ,
	RTCBT_POLL	= ( RTCBT_ALWAYS_ONLINE + 1 ) 
    } 	RTC_BUDDY_SUBSCRIPTION_TYPE;

typedef 
enum RTC_MEDIA_EVENT_TYPE
    {	RTCMET_STOPPED	= 0,
	RTCMET_STARTED	= ( RTCMET_STOPPED + 1 ) ,
	RTCMET_FAILED	= ( RTCMET_STARTED + 1 ) 
    } 	RTC_MEDIA_EVENT_TYPE;

typedef 
enum RTC_MEDIA_EVENT_REASON
    {	RTCMER_NORMAL	= 0,
	RTCMER_HOLD	= ( RTCMER_NORMAL + 1 ) ,
	RTCMER_TIMEOUT	= ( RTCMER_HOLD + 1 ) ,
	RTCMER_BAD_DEVICE	= ( RTCMER_TIMEOUT + 1 ) ,
	RTCMER_NO_PORT	= ( RTCMER_BAD_DEVICE + 1 ) ,
	RTCMER_PORT_MAPPING_FAILED	= ( RTCMER_NO_PORT + 1 ) ,
	RTCMER_REMOTE_REQUEST	= ( RTCMER_PORT_MAPPING_FAILED + 1 ) 
    } 	RTC_MEDIA_EVENT_REASON;

typedef 
enum RTC_MESSAGING_EVENT_TYPE
    {	RTCMSET_MESSAGE	= 0,
	RTCMSET_STATUS	= ( RTCMSET_MESSAGE + 1 ) 
    } 	RTC_MESSAGING_EVENT_TYPE;

typedef 
enum RTC_MESSAGING_USER_STATUS
    {	RTCMUS_IDLE	= 0,
	RTCMUS_TYPING	= ( RTCMUS_IDLE + 1 ) 
    } 	RTC_MESSAGING_USER_STATUS;

typedef 
enum RTC_DTMF
    {	RTC_DTMF_0	= 0,
	RTC_DTMF_1	= ( RTC_DTMF_0 + 1 ) ,
	RTC_DTMF_2	= ( RTC_DTMF_1 + 1 ) ,
	RTC_DTMF_3	= ( RTC_DTMF_2 + 1 ) ,
	RTC_DTMF_4	= ( RTC_DTMF_3 + 1 ) ,
	RTC_DTMF_5	= ( RTC_DTMF_4 + 1 ) ,
	RTC_DTMF_6	= ( RTC_DTMF_5 + 1 ) ,
	RTC_DTMF_7	= ( RTC_DTMF_6 + 1 ) ,
	RTC_DTMF_8	= ( RTC_DTMF_7 + 1 ) ,
	RTC_DTMF_9	= ( RTC_DTMF_8 + 1 ) ,
	RTC_DTMF_STAR	= ( RTC_DTMF_9 + 1 ) ,
	RTC_DTMF_POUND	= ( RTC_DTMF_STAR + 1 ) ,
	RTC_DTMF_A	= ( RTC_DTMF_POUND + 1 ) ,
	RTC_DTMF_B	= ( RTC_DTMF_A + 1 ) ,
	RTC_DTMF_C	= ( RTC_DTMF_B + 1 ) ,
	RTC_DTMF_D	= ( RTC_DTMF_C + 1 ) ,
	RTC_DTMF_FLASH	= ( RTC_DTMF_D + 1 ) 
    } 	RTC_DTMF;

typedef 
enum RTC_PROVIDER_URI
    {	RTCPU_URIHOMEPAGE	= 0,
	RTCPU_URIHELPDESK	= ( RTCPU_URIHOMEPAGE + 1 ) ,
	RTCPU_URIPERSONALACCOUNT	= ( RTCPU_URIHELPDESK + 1 ) ,
	RTCPU_URIDISPLAYDURINGCALL	= ( RTCPU_URIPERSONALACCOUNT + 1 ) ,
	RTCPU_URIDISPLAYDURINGIDLE	= ( RTCPU_URIDISPLAYDURINGCALL + 1 ) 
    } 	RTC_PROVIDER_URI;

typedef 
enum RTC_RING_TYPE
    {	RTCRT_PHONE	= 0,
	RTCRT_MESSAGE	= ( RTCRT_PHONE + 1 ) ,
	RTCRT_RINGBACK	= ( RTCRT_MESSAGE + 1 ) 
    } 	RTC_RING_TYPE;

typedef 
enum RTC_T120_APPLET
    {	RTCTA_WHITEBOARD	= 0,
	RTCTA_APPSHARING	= ( RTCTA_WHITEBOARD + 1 ) 
    } 	RTC_T120_APPLET;

typedef 
enum RTC_PORT_TYPE
    {	RTCPT_AUDIO_RTP	= 0,
	RTCPT_AUDIO_RTCP	= ( RTCPT_AUDIO_RTP + 1 ) ,
	RTCPT_VIDEO_RTP	= ( RTCPT_AUDIO_RTCP + 1 ) ,
	RTCPT_VIDEO_RTCP	= ( RTCPT_VIDEO_RTP + 1 ) ,
	RTCPT_SIP	= ( RTCPT_VIDEO_RTCP + 1 ) 
    } 	RTC_PORT_TYPE;

typedef 
enum RTC_USER_SEARCH_COLUMN
    {	RTCUSC_URI	= 0,
	RTCUSC_DISPLAYNAME	= ( RTCUSC_URI + 1 ) ,
	RTCUSC_TITLE	= ( RTCUSC_DISPLAYNAME + 1 ) ,
	RTCUSC_OFFICE	= ( RTCUSC_TITLE + 1 ) ,
	RTCUSC_PHONE	= ( RTCUSC_OFFICE + 1 ) ,
	RTCUSC_COMPANY	= ( RTCUSC_PHONE + 1 ) ,
	RTCUSC_CITY	= ( RTCUSC_COMPANY + 1 ) ,
	RTCUSC_STATE	= ( RTCUSC_CITY + 1 ) ,
	RTCUSC_COUNTRY	= ( RTCUSC_STATE + 1 ) ,
	RTCUSC_EMAIL	= ( RTCUSC_COUNTRY + 1 ) 
    } 	RTC_USER_SEARCH_COLUMN;

typedef 
enum RTC_USER_SEARCH_PREFERENCE
    {	RTCUSP_MAX_MATCHES	= 0,
	RTCUSP_TIME_LIMIT	= ( RTCUSP_MAX_MATCHES + 1 ) 
    } 	RTC_USER_SEARCH_PREFERENCE;

typedef 
enum RTC_ROAMING_EVENT_TYPE
    {	RTCRET_BUDDY_ROAMING	= 0,
	RTCRET_WATCHER_ROAMING	= ( RTCRET_BUDDY_ROAMING + 1 ) ,
	RTCRET_PRESENCE_ROAMING	= ( RTCRET_WATCHER_ROAMING + 1 ) ,
	RTCRET_PROFILE_ROAMING	= ( RTCRET_PRESENCE_ROAMING + 1 ) ,
	RTCRET_WPENDING_ROAMING	= ( RTCRET_PROFILE_ROAMING + 1 ) 
    } 	RTC_ROAMING_EVENT_TYPE;

typedef 
enum RTC_PROFILE_EVENT_TYPE
    {	RTCPFET_PROFILE_GET	= 0,
	RTCPFET_PROFILE_UPDATE	= ( RTCPFET_PROFILE_GET + 1 ) 
    } 	RTC_PROFILE_EVENT_TYPE;

typedef 
enum RTC_ANSWER_MODE
    {	RTCAM_OFFER_SESSION_EVENT	= 0,
	RTCAM_AUTOMATICALLY_ACCEPT	= ( RTCAM_OFFER_SESSION_EVENT + 1 ) ,
	RTCAM_AUTOMATICALLY_REJECT	= ( RTCAM_AUTOMATICALLY_ACCEPT + 1 ) ,
	RTCAM_NOT_SUPPORTED	= ( RTCAM_AUTOMATICALLY_REJECT + 1 ) 
    } 	RTC_ANSWER_MODE;

typedef 
enum RTC_SESSION_REFER_STATUS
    {	RTCSRS_REFERRING	= 0,
	RTCSRS_ACCEPTED	= ( RTCSRS_REFERRING + 1 ) ,
	RTCSRS_ERROR	= ( RTCSRS_ACCEPTED + 1 ) ,
	RTCSRS_REJECTED	= ( RTCSRS_ERROR + 1 ) ,
	RTCSRS_DROPPED	= ( RTCSRS_REJECTED + 1 ) ,
	RTCSRS_DONE	= ( RTCSRS_DROPPED + 1 ) 
    } 	RTC_SESSION_REFER_STATUS;

typedef 
enum RTC_PRESENCE_PROPERTY
    {	RTCPP_PHONENUMBER	= 0,
	RTCPP_DISPLAYNAME	= ( RTCPP_PHONENUMBER + 1 ) ,
	RTCPP_EMAIL	= ( RTCPP_DISPLAYNAME + 1 ) ,
	RTCPP_DEVICE_NAME	= ( RTCPP_EMAIL + 1 ) ,
	RTCPP_MULTIPLE	= ( RTCPP_DEVICE_NAME + 1 ) 
    } 	RTC_PRESENCE_PROPERTY;

typedef 
enum RTC_SECURITY_TYPE
    {	RTCSECT_AUDIO_VIDEO_MEDIA_ENCRYPTION	= 0,
	RTCSECT_T120_MEDIA_ENCRYPTION	= ( RTCSECT_AUDIO_VIDEO_MEDIA_ENCRYPTION + 1 ) 
    } 	RTC_SECURITY_TYPE;

typedef 
enum RTC_SECURITY_LEVEL
    {	RTCSECL_UNSUPPORTED	= 1,
	RTCSECL_SUPPORTED	= ( RTCSECL_UNSUPPORTED + 1 ) ,
	RTCSECL_REQUIRED	= ( RTCSECL_SUPPORTED + 1 ) 
    } 	RTC_SECURITY_LEVEL;

typedef 
enum RTC_REINVITE_STATE
    {	RTCRIN_INCOMING	= 0,
	RTCRIN_SUCCEEDED	= ( RTCRIN_INCOMING + 1 ) ,
	RTCRIN_FAIL	= ( RTCRIN_SUCCEEDED + 1 ) 
    } 	RTC_REINVITE_STATE;

#define RTCCS_FORCE_PROFILE          0x00000001
#define RTCCS_FAIL_ON_REDIRECT       0x00000002
#define RTCMT_AUDIO_SEND     0x00000001
#define RTCMT_AUDIO_RECEIVE  0x00000002
#define RTCMT_VIDEO_SEND     0x00000004
#define RTCMT_VIDEO_RECEIVE  0x00000008
#define RTCMT_T120_SENDRECV  0x00000010
#define RTCMT_ALL_RTP   (       \
         RTCMT_AUDIO_SEND    |  \
         RTCMT_AUDIO_RECEIVE  | \
         RTCMT_VIDEO_SEND  |    \
         RTCMT_VIDEO_RECEIVE )    
#define RTCMT_ALL       (       \
         RTCMT_ALL_RTP    |     \
         RTCMT_T120_SENDRECV  )   
#define RTCSI_PC_TO_PC       0x00000001
#define RTCSI_PC_TO_PHONE    0x00000002
#define RTCSI_PHONE_TO_PHONE 0x00000004
#define RTCSI_IM             0x00000008
#define RTCSI_MULTIPARTY_IM  0x00000010
#define RTCSI_APPLICATION	0x00000020
#define RTCTR_UDP            0x00000001
#define RTCTR_TCP            0x00000002
#define RTCTR_TLS            0x00000004
#define RTCAU_BASIC                  0x00000001
#define RTCAU_DIGEST                 0x00000002
#define RTCAU_NTLM                   0x00000004
#define RTCAU_KERBEROS               0x00000008
#define RTCAU_USE_LOGON_CRED         0x00010000
#define RTCRF_REGISTER_INVITE_SESSIONS   0x00000001
#define RTCRF_REGISTER_MESSAGE_SESSIONS  0x00000002
#define RTCRF_REGISTER_PRESENCE          0x00000004
#define RTCRF_REGISTER_NOTIFY            0x00000008
#define RTCRF_REGISTER_ALL               0x0000000F
#define RTCRMF_BUDDY_ROAMING              0x00000001
#define RTCRMF_WATCHER_ROAMING            0x00000002
#define RTCRMF_PRESENCE_ROAMING           0x00000004
#define RTCRMF_PROFILE_ROAMING            0x00000008
#define RTCRMF_ALL_ROAMING                0x0000000F
#define RTCEF_CLIENT                     0x00000001
#define RTCEF_REGISTRATION_STATE_CHANGE  0x00000002
#define RTCEF_SESSION_STATE_CHANGE       0x00000004
#define RTCEF_SESSION_OPERATION_COMPLETE 0x00000008
#define RTCEF_PARTICIPANT_STATE_CHANGE   0x00000010
#define RTCEF_MEDIA                      0x00000020
#define RTCEF_INTENSITY                  0x00000040
#define RTCEF_MESSAGING                  0x00000080
#define RTCEF_BUDDY                      0x00000100
#define RTCEF_WATCHER                    0x00000200
#define RTCEF_PROFILE                    0x00000400
#define RTCEF_USERSEARCH                 0x00000800
#define RTCEF_INFO                       0x00001000
#define RTCEF_GROUP                      0x00002000
#define RTCEF_MEDIA_REQUEST              0x00004000
#define RTCEF_ROAMING                    0x00010000
#define RTCEF_PRESENCE_PROPERTY          0x00020000
#define RTCEF_BUDDY2                     0x00040000
#define RTCEF_WATCHER2                   0x00080000
#define RTCEF_SESSION_REFER_STATUS       0x00100000
#define RTCEF_SESSION_REFERRED           0x00200000
#define RTCEF_REINVITE                   0x00400000
#define RTCEF_PRESENCE_DATA              0x00800000
#define RTCEF_PRESENCE_STATUS            0x01000000
#define RTCEF_ALL                        0x01FFFFFF
#define RTCIF_DISABLE_MEDIA                          0x00000001
#define RTCIF_DISABLE_UPNP                           0x00000002
#define RTCIF_ENABLE_SERVER_CLASS                    0x00000004
#define RTCIF_DISABLE_STRICT_DNS                     0x00000008




































extern RPC_IF_HANDLE __MIDL_itf_rtccore_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rtccore_0000_0000_v0_0_s_ifspec;

#ifndef __IRTCClient_INTERFACE_DEFINED__
#define __IRTCClient_INTERFACE_DEFINED__

/* interface IRTCClient */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCClient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("07829e45-9a34-408e-a011-bddf13487cd1")
    IRTCClient : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PrepareForShutdown( void) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_EventFilter( 
            /* [in] */ long lFilter) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_EventFilter( 
            /* [retval][out] */ __RPC__out long *plFilter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPreferredMediaTypes( 
            /* [in] */ long lMediaTypes,
            /* [in] */ VARIANT_BOOL fPersistent) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PreferredMediaTypes( 
            /* [retval][out] */ __RPC__out long *plMediaTypes) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MediaCapabilities( 
            /* [retval][out] */ __RPC__out long *plMediaTypes) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateSession( 
            /* [in] */ RTC_SESSION_TYPE enType,
            /* [in] */ __RPC__in BSTR bstrLocalPhoneURI,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lFlags,
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession **ppSession) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ListenForIncomingSessions( 
            /* [in] */ RTC_LISTEN_MODE enListen) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ListenForIncomingSessions( 
            /* [retval][out] */ __RPC__out RTC_LISTEN_MODE *penListen) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_NetworkAddresses( 
            /* [in] */ VARIANT_BOOL fTCP,
            /* [in] */ VARIANT_BOOL fExternal,
            /* [retval][out] */ __RPC__out VARIANT *pvAddresses) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Volume( 
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [in] */ long lVolume) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Volume( 
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [retval][out] */ __RPC__out long *plVolume) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AudioMuted( 
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [in] */ VARIANT_BOOL fMuted) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AudioMuted( 
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfMuted) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IVideoWindow( 
            /* [in] */ RTC_VIDEO_DEVICE enDevice,
            /* [retval][out] */ __RPC__deref_out_opt IVideoWindow **ppIVideoWindow) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_PreferredAudioDevice( 
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [in] */ __RPC__in BSTR bstrDeviceName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PreferredAudioDevice( 
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceName) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_PreferredVolume( 
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [in] */ long lVolume) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PreferredVolume( 
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [retval][out] */ __RPC__out long *plVolume) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_PreferredAEC( 
            /* [in] */ VARIANT_BOOL bEnable) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PreferredAEC( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_PreferredVideoDevice( 
            /* [in] */ __RPC__in BSTR bstrDeviceName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PreferredVideoDevice( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ActiveMedia( 
            /* [retval][out] */ __RPC__out long *plMediaType) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_MaxBitrate( 
            /* [in] */ long lMaxBitrate) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_MaxBitrate( 
            /* [retval][out] */ __RPC__out long *plMaxBitrate) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_TemporalSpatialTradeOff( 
            /* [in] */ long lValue) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_TemporalSpatialTradeOff( 
            /* [retval][out] */ __RPC__out long *plValue) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_NetworkQuality( 
            /* [retval][out] */ __RPC__out long *plNetworkQuality) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StartT120Applet( 
            /* [in] */ RTC_T120_APPLET enApplet) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StopT120Applets( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsT120AppletRunning( 
            /* [in] */ RTC_T120_APPLET enApplet,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfRunning) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LocalUserURI( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserURI) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_LocalUserURI( 
            /* [in] */ __RPC__in BSTR bstrUserURI) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LocalUserName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserName) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_LocalUserName( 
            /* [in] */ __RPC__in BSTR bstrUserName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PlayRing( 
            /* [in] */ RTC_RING_TYPE enType,
            /* [in] */ VARIANT_BOOL bPlay) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendDTMF( 
            /* [in] */ RTC_DTMF enDTMF) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InvokeTuningWizard( 
            /* [in] */ OAHWND hwndParent) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsTuned( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfTuned) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCClientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCClient * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCClient * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCClient * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IRTCClient * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            __RPC__in IRTCClient * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PrepareForShutdown )( 
            __RPC__in IRTCClient * This);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EventFilter )( 
            __RPC__in IRTCClient * This,
            /* [in] */ long lFilter);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventFilter )( 
            __RPC__in IRTCClient * This,
            /* [retval][out] */ __RPC__out long *plFilter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPreferredMediaTypes )( 
            __RPC__in IRTCClient * This,
            /* [in] */ long lMediaTypes,
            /* [in] */ VARIANT_BOOL fPersistent);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreferredMediaTypes )( 
            __RPC__in IRTCClient * This,
            /* [retval][out] */ __RPC__out long *plMediaTypes);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaCapabilities )( 
            __RPC__in IRTCClient * This,
            /* [retval][out] */ __RPC__out long *plMediaTypes);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateSession )( 
            __RPC__in IRTCClient * This,
            /* [in] */ RTC_SESSION_TYPE enType,
            /* [in] */ __RPC__in BSTR bstrLocalPhoneURI,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lFlags,
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession **ppSession);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ListenForIncomingSessions )( 
            __RPC__in IRTCClient * This,
            /* [in] */ RTC_LISTEN_MODE enListen);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ListenForIncomingSessions )( 
            __RPC__in IRTCClient * This,
            /* [retval][out] */ __RPC__out RTC_LISTEN_MODE *penListen);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkAddresses )( 
            __RPC__in IRTCClient * This,
            /* [in] */ VARIANT_BOOL fTCP,
            /* [in] */ VARIANT_BOOL fExternal,
            /* [retval][out] */ __RPC__out VARIANT *pvAddresses);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Volume )( 
            __RPC__in IRTCClient * This,
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [in] */ long lVolume);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Volume )( 
            __RPC__in IRTCClient * This,
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [retval][out] */ __RPC__out long *plVolume);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AudioMuted )( 
            __RPC__in IRTCClient * This,
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [in] */ VARIANT_BOOL fMuted);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AudioMuted )( 
            __RPC__in IRTCClient * This,
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfMuted);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IVideoWindow )( 
            __RPC__in IRTCClient * This,
            /* [in] */ RTC_VIDEO_DEVICE enDevice,
            /* [retval][out] */ __RPC__deref_out_opt IVideoWindow **ppIVideoWindow);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PreferredAudioDevice )( 
            __RPC__in IRTCClient * This,
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [in] */ __RPC__in BSTR bstrDeviceName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreferredAudioDevice )( 
            __RPC__in IRTCClient * This,
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceName);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PreferredVolume )( 
            __RPC__in IRTCClient * This,
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [in] */ long lVolume);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreferredVolume )( 
            __RPC__in IRTCClient * This,
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [retval][out] */ __RPC__out long *plVolume);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PreferredAEC )( 
            __RPC__in IRTCClient * This,
            /* [in] */ VARIANT_BOOL bEnable);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreferredAEC )( 
            __RPC__in IRTCClient * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbEnabled);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PreferredVideoDevice )( 
            __RPC__in IRTCClient * This,
            /* [in] */ __RPC__in BSTR bstrDeviceName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreferredVideoDevice )( 
            __RPC__in IRTCClient * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ActiveMedia )( 
            __RPC__in IRTCClient * This,
            /* [retval][out] */ __RPC__out long *plMediaType);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxBitrate )( 
            __RPC__in IRTCClient * This,
            /* [in] */ long lMaxBitrate);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxBitrate )( 
            __RPC__in IRTCClient * This,
            /* [retval][out] */ __RPC__out long *plMaxBitrate);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TemporalSpatialTradeOff )( 
            __RPC__in IRTCClient * This,
            /* [in] */ long lValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TemporalSpatialTradeOff )( 
            __RPC__in IRTCClient * This,
            /* [retval][out] */ __RPC__out long *plValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkQuality )( 
            __RPC__in IRTCClient * This,
            /* [retval][out] */ __RPC__out long *plNetworkQuality);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *StartT120Applet )( 
            __RPC__in IRTCClient * This,
            /* [in] */ RTC_T120_APPLET enApplet);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *StopT120Applets )( 
            __RPC__in IRTCClient * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsT120AppletRunning )( 
            __RPC__in IRTCClient * This,
            /* [in] */ RTC_T120_APPLET enApplet,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfRunning);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocalUserURI )( 
            __RPC__in IRTCClient * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserURI);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LocalUserURI )( 
            __RPC__in IRTCClient * This,
            /* [in] */ __RPC__in BSTR bstrUserURI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocalUserName )( 
            __RPC__in IRTCClient * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserName);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LocalUserName )( 
            __RPC__in IRTCClient * This,
            /* [in] */ __RPC__in BSTR bstrUserName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PlayRing )( 
            __RPC__in IRTCClient * This,
            /* [in] */ RTC_RING_TYPE enType,
            /* [in] */ VARIANT_BOOL bPlay);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendDTMF )( 
            __RPC__in IRTCClient * This,
            /* [in] */ RTC_DTMF enDTMF);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InvokeTuningWizard )( 
            __RPC__in IRTCClient * This,
            /* [in] */ OAHWND hwndParent);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsTuned )( 
            __RPC__in IRTCClient * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfTuned);
        
        END_INTERFACE
    } IRTCClientVtbl;

    interface IRTCClient
    {
        CONST_VTBL struct IRTCClientVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCClient_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCClient_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCClient_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCClient_Initialize(This)	\
    ( (This)->lpVtbl -> Initialize(This) ) 

#define IRTCClient_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#define IRTCClient_PrepareForShutdown(This)	\
    ( (This)->lpVtbl -> PrepareForShutdown(This) ) 

#define IRTCClient_put_EventFilter(This,lFilter)	\
    ( (This)->lpVtbl -> put_EventFilter(This,lFilter) ) 

#define IRTCClient_get_EventFilter(This,plFilter)	\
    ( (This)->lpVtbl -> get_EventFilter(This,plFilter) ) 

#define IRTCClient_SetPreferredMediaTypes(This,lMediaTypes,fPersistent)	\
    ( (This)->lpVtbl -> SetPreferredMediaTypes(This,lMediaTypes,fPersistent) ) 

#define IRTCClient_get_PreferredMediaTypes(This,plMediaTypes)	\
    ( (This)->lpVtbl -> get_PreferredMediaTypes(This,plMediaTypes) ) 

#define IRTCClient_get_MediaCapabilities(This,plMediaTypes)	\
    ( (This)->lpVtbl -> get_MediaCapabilities(This,plMediaTypes) ) 

#define IRTCClient_CreateSession(This,enType,bstrLocalPhoneURI,pProfile,lFlags,ppSession)	\
    ( (This)->lpVtbl -> CreateSession(This,enType,bstrLocalPhoneURI,pProfile,lFlags,ppSession) ) 

#define IRTCClient_put_ListenForIncomingSessions(This,enListen)	\
    ( (This)->lpVtbl -> put_ListenForIncomingSessions(This,enListen) ) 

#define IRTCClient_get_ListenForIncomingSessions(This,penListen)	\
    ( (This)->lpVtbl -> get_ListenForIncomingSessions(This,penListen) ) 

#define IRTCClient_get_NetworkAddresses(This,fTCP,fExternal,pvAddresses)	\
    ( (This)->lpVtbl -> get_NetworkAddresses(This,fTCP,fExternal,pvAddresses) ) 

#define IRTCClient_put_Volume(This,enDevice,lVolume)	\
    ( (This)->lpVtbl -> put_Volume(This,enDevice,lVolume) ) 

#define IRTCClient_get_Volume(This,enDevice,plVolume)	\
    ( (This)->lpVtbl -> get_Volume(This,enDevice,plVolume) ) 

#define IRTCClient_put_AudioMuted(This,enDevice,fMuted)	\
    ( (This)->lpVtbl -> put_AudioMuted(This,enDevice,fMuted) ) 

#define IRTCClient_get_AudioMuted(This,enDevice,pfMuted)	\
    ( (This)->lpVtbl -> get_AudioMuted(This,enDevice,pfMuted) ) 

#define IRTCClient_get_IVideoWindow(This,enDevice,ppIVideoWindow)	\
    ( (This)->lpVtbl -> get_IVideoWindow(This,enDevice,ppIVideoWindow) ) 

#define IRTCClient_put_PreferredAudioDevice(This,enDevice,bstrDeviceName)	\
    ( (This)->lpVtbl -> put_PreferredAudioDevice(This,enDevice,bstrDeviceName) ) 

#define IRTCClient_get_PreferredAudioDevice(This,enDevice,pbstrDeviceName)	\
    ( (This)->lpVtbl -> get_PreferredAudioDevice(This,enDevice,pbstrDeviceName) ) 

#define IRTCClient_put_PreferredVolume(This,enDevice,lVolume)	\
    ( (This)->lpVtbl -> put_PreferredVolume(This,enDevice,lVolume) ) 

#define IRTCClient_get_PreferredVolume(This,enDevice,plVolume)	\
    ( (This)->lpVtbl -> get_PreferredVolume(This,enDevice,plVolume) ) 

#define IRTCClient_put_PreferredAEC(This,bEnable)	\
    ( (This)->lpVtbl -> put_PreferredAEC(This,bEnable) ) 

#define IRTCClient_get_PreferredAEC(This,pbEnabled)	\
    ( (This)->lpVtbl -> get_PreferredAEC(This,pbEnabled) ) 

#define IRTCClient_put_PreferredVideoDevice(This,bstrDeviceName)	\
    ( (This)->lpVtbl -> put_PreferredVideoDevice(This,bstrDeviceName) ) 

#define IRTCClient_get_PreferredVideoDevice(This,pbstrDeviceName)	\
    ( (This)->lpVtbl -> get_PreferredVideoDevice(This,pbstrDeviceName) ) 

#define IRTCClient_get_ActiveMedia(This,plMediaType)	\
    ( (This)->lpVtbl -> get_ActiveMedia(This,plMediaType) ) 

#define IRTCClient_put_MaxBitrate(This,lMaxBitrate)	\
    ( (This)->lpVtbl -> put_MaxBitrate(This,lMaxBitrate) ) 

#define IRTCClient_get_MaxBitrate(This,plMaxBitrate)	\
    ( (This)->lpVtbl -> get_MaxBitrate(This,plMaxBitrate) ) 

#define IRTCClient_put_TemporalSpatialTradeOff(This,lValue)	\
    ( (This)->lpVtbl -> put_TemporalSpatialTradeOff(This,lValue) ) 

#define IRTCClient_get_TemporalSpatialTradeOff(This,plValue)	\
    ( (This)->lpVtbl -> get_TemporalSpatialTradeOff(This,plValue) ) 

#define IRTCClient_get_NetworkQuality(This,plNetworkQuality)	\
    ( (This)->lpVtbl -> get_NetworkQuality(This,plNetworkQuality) ) 

#define IRTCClient_StartT120Applet(This,enApplet)	\
    ( (This)->lpVtbl -> StartT120Applet(This,enApplet) ) 

#define IRTCClient_StopT120Applets(This)	\
    ( (This)->lpVtbl -> StopT120Applets(This) ) 

#define IRTCClient_get_IsT120AppletRunning(This,enApplet,pfRunning)	\
    ( (This)->lpVtbl -> get_IsT120AppletRunning(This,enApplet,pfRunning) ) 

#define IRTCClient_get_LocalUserURI(This,pbstrUserURI)	\
    ( (This)->lpVtbl -> get_LocalUserURI(This,pbstrUserURI) ) 

#define IRTCClient_put_LocalUserURI(This,bstrUserURI)	\
    ( (This)->lpVtbl -> put_LocalUserURI(This,bstrUserURI) ) 

#define IRTCClient_get_LocalUserName(This,pbstrUserName)	\
    ( (This)->lpVtbl -> get_LocalUserName(This,pbstrUserName) ) 

#define IRTCClient_put_LocalUserName(This,bstrUserName)	\
    ( (This)->lpVtbl -> put_LocalUserName(This,bstrUserName) ) 

#define IRTCClient_PlayRing(This,enType,bPlay)	\
    ( (This)->lpVtbl -> PlayRing(This,enType,bPlay) ) 

#define IRTCClient_SendDTMF(This,enDTMF)	\
    ( (This)->lpVtbl -> SendDTMF(This,enDTMF) ) 

#define IRTCClient_InvokeTuningWizard(This,hwndParent)	\
    ( (This)->lpVtbl -> InvokeTuningWizard(This,hwndParent) ) 

#define IRTCClient_get_IsTuned(This,pfTuned)	\
    ( (This)->lpVtbl -> get_IsTuned(This,pfTuned) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCClient_INTERFACE_DEFINED__ */


#ifndef __IRTCClient2_INTERFACE_DEFINED__
#define __IRTCClient2_INTERFACE_DEFINED__

/* interface IRTCClient2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCClient2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0C91D71D-1064-42da-BFA5-572BEB8EEA84")
    IRTCClient2 : public IRTCClient
    {
    public:
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AnswerMode( 
            /* [in] */ RTC_SESSION_TYPE enType,
            /* [in] */ RTC_ANSWER_MODE enMode) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AnswerMode( 
            /* [in] */ RTC_SESSION_TYPE enType,
            /* [retval][out] */ __RPC__out RTC_ANSWER_MODE *penMode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InvokeTuningWizardEx( 
            /* [in] */ OAHWND hwndParent,
            /* [in] */ VARIANT_BOOL fAllowAudio,
            /* [in] */ VARIANT_BOOL fAllowVideo) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ __RPC__out long *plVersion) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ClientName( 
            /* [in] */ __RPC__in BSTR bstrClientName) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ClientCurVer( 
            /* [in] */ __RPC__in BSTR bstrClientCurVer) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InitializeEx( 
            /* [in] */ long lFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateSessionWithDescription( 
            /* [in] */ __RPC__in BSTR bstrContentType,
            /* [in] */ __RPC__in BSTR bstrSessionDescription,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lFlags,
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession2 **ppSession2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSessionDescriptionManager( 
            /* [in] */ __RPC__in_opt IRTCSessionDescriptionManager *pSessionDescriptionManager) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_PreferredSecurityLevel( 
            /* [in] */ RTC_SECURITY_TYPE enSecurityType,
            /* [in] */ RTC_SECURITY_LEVEL enSecurityLevel) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PreferredSecurityLevel( 
            /* [in] */ RTC_SECURITY_TYPE enSecurityType,
            /* [retval][out] */ __RPC__out RTC_SECURITY_LEVEL *penSecurityLevel) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AllowedPorts( 
            /* [in] */ long lTransport,
            /* [in] */ RTC_LISTEN_MODE enListenMode) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AllowedPorts( 
            /* [in] */ long lTransport,
            /* [retval][out] */ __RPC__out RTC_LISTEN_MODE *penListenMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCClient2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCClient2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCClient2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IRTCClient2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            __RPC__in IRTCClient2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PrepareForShutdown )( 
            __RPC__in IRTCClient2 * This);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EventFilter )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ long lFilter);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventFilter )( 
            __RPC__in IRTCClient2 * This,
            /* [retval][out] */ __RPC__out long *plFilter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPreferredMediaTypes )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ long lMediaTypes,
            /* [in] */ VARIANT_BOOL fPersistent);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreferredMediaTypes )( 
            __RPC__in IRTCClient2 * This,
            /* [retval][out] */ __RPC__out long *plMediaTypes);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaCapabilities )( 
            __RPC__in IRTCClient2 * This,
            /* [retval][out] */ __RPC__out long *plMediaTypes);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateSession )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ RTC_SESSION_TYPE enType,
            /* [in] */ __RPC__in BSTR bstrLocalPhoneURI,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lFlags,
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession **ppSession);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ListenForIncomingSessions )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ RTC_LISTEN_MODE enListen);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ListenForIncomingSessions )( 
            __RPC__in IRTCClient2 * This,
            /* [retval][out] */ __RPC__out RTC_LISTEN_MODE *penListen);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkAddresses )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ VARIANT_BOOL fTCP,
            /* [in] */ VARIANT_BOOL fExternal,
            /* [retval][out] */ __RPC__out VARIANT *pvAddresses);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Volume )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [in] */ long lVolume);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Volume )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [retval][out] */ __RPC__out long *plVolume);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AudioMuted )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [in] */ VARIANT_BOOL fMuted);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AudioMuted )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfMuted);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IVideoWindow )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ RTC_VIDEO_DEVICE enDevice,
            /* [retval][out] */ __RPC__deref_out_opt IVideoWindow **ppIVideoWindow);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PreferredAudioDevice )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [in] */ __RPC__in BSTR bstrDeviceName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreferredAudioDevice )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceName);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PreferredVolume )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [in] */ long lVolume);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreferredVolume )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ RTC_AUDIO_DEVICE enDevice,
            /* [retval][out] */ __RPC__out long *plVolume);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PreferredAEC )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ VARIANT_BOOL bEnable);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreferredAEC )( 
            __RPC__in IRTCClient2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbEnabled);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PreferredVideoDevice )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ __RPC__in BSTR bstrDeviceName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreferredVideoDevice )( 
            __RPC__in IRTCClient2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ActiveMedia )( 
            __RPC__in IRTCClient2 * This,
            /* [retval][out] */ __RPC__out long *plMediaType);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxBitrate )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ long lMaxBitrate);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxBitrate )( 
            __RPC__in IRTCClient2 * This,
            /* [retval][out] */ __RPC__out long *plMaxBitrate);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TemporalSpatialTradeOff )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ long lValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TemporalSpatialTradeOff )( 
            __RPC__in IRTCClient2 * This,
            /* [retval][out] */ __RPC__out long *plValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NetworkQuality )( 
            __RPC__in IRTCClient2 * This,
            /* [retval][out] */ __RPC__out long *plNetworkQuality);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *StartT120Applet )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ RTC_T120_APPLET enApplet);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *StopT120Applets )( 
            __RPC__in IRTCClient2 * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsT120AppletRunning )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ RTC_T120_APPLET enApplet,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfRunning);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocalUserURI )( 
            __RPC__in IRTCClient2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserURI);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LocalUserURI )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ __RPC__in BSTR bstrUserURI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocalUserName )( 
            __RPC__in IRTCClient2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserName);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LocalUserName )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ __RPC__in BSTR bstrUserName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PlayRing )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ RTC_RING_TYPE enType,
            /* [in] */ VARIANT_BOOL bPlay);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendDTMF )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ RTC_DTMF enDTMF);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InvokeTuningWizard )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ OAHWND hwndParent);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsTuned )( 
            __RPC__in IRTCClient2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfTuned);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AnswerMode )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ RTC_SESSION_TYPE enType,
            /* [in] */ RTC_ANSWER_MODE enMode);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AnswerMode )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ RTC_SESSION_TYPE enType,
            /* [retval][out] */ __RPC__out RTC_ANSWER_MODE *penMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InvokeTuningWizardEx )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ OAHWND hwndParent,
            /* [in] */ VARIANT_BOOL fAllowAudio,
            /* [in] */ VARIANT_BOOL fAllowVideo);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Version )( 
            __RPC__in IRTCClient2 * This,
            /* [retval][out] */ __RPC__out long *plVersion);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientName )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ __RPC__in BSTR bstrClientName);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientCurVer )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ __RPC__in BSTR bstrClientCurVer);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InitializeEx )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ long lFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateSessionWithDescription )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ __RPC__in BSTR bstrContentType,
            /* [in] */ __RPC__in BSTR bstrSessionDescription,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lFlags,
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession2 **ppSession2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSessionDescriptionManager )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ __RPC__in_opt IRTCSessionDescriptionManager *pSessionDescriptionManager);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PreferredSecurityLevel )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ RTC_SECURITY_TYPE enSecurityType,
            /* [in] */ RTC_SECURITY_LEVEL enSecurityLevel);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreferredSecurityLevel )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ RTC_SECURITY_TYPE enSecurityType,
            /* [retval][out] */ __RPC__out RTC_SECURITY_LEVEL *penSecurityLevel);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowedPorts )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ long lTransport,
            /* [in] */ RTC_LISTEN_MODE enListenMode);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowedPorts )( 
            __RPC__in IRTCClient2 * This,
            /* [in] */ long lTransport,
            /* [retval][out] */ __RPC__out RTC_LISTEN_MODE *penListenMode);
        
        END_INTERFACE
    } IRTCClient2Vtbl;

    interface IRTCClient2
    {
        CONST_VTBL struct IRTCClient2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCClient2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCClient2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCClient2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCClient2_Initialize(This)	\
    ( (This)->lpVtbl -> Initialize(This) ) 

#define IRTCClient2_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#define IRTCClient2_PrepareForShutdown(This)	\
    ( (This)->lpVtbl -> PrepareForShutdown(This) ) 

#define IRTCClient2_put_EventFilter(This,lFilter)	\
    ( (This)->lpVtbl -> put_EventFilter(This,lFilter) ) 

#define IRTCClient2_get_EventFilter(This,plFilter)	\
    ( (This)->lpVtbl -> get_EventFilter(This,plFilter) ) 

#define IRTCClient2_SetPreferredMediaTypes(This,lMediaTypes,fPersistent)	\
    ( (This)->lpVtbl -> SetPreferredMediaTypes(This,lMediaTypes,fPersistent) ) 

#define IRTCClient2_get_PreferredMediaTypes(This,plMediaTypes)	\
    ( (This)->lpVtbl -> get_PreferredMediaTypes(This,plMediaTypes) ) 

#define IRTCClient2_get_MediaCapabilities(This,plMediaTypes)	\
    ( (This)->lpVtbl -> get_MediaCapabilities(This,plMediaTypes) ) 

#define IRTCClient2_CreateSession(This,enType,bstrLocalPhoneURI,pProfile,lFlags,ppSession)	\
    ( (This)->lpVtbl -> CreateSession(This,enType,bstrLocalPhoneURI,pProfile,lFlags,ppSession) ) 

#define IRTCClient2_put_ListenForIncomingSessions(This,enListen)	\
    ( (This)->lpVtbl -> put_ListenForIncomingSessions(This,enListen) ) 

#define IRTCClient2_get_ListenForIncomingSessions(This,penListen)	\
    ( (This)->lpVtbl -> get_ListenForIncomingSessions(This,penListen) ) 

#define IRTCClient2_get_NetworkAddresses(This,fTCP,fExternal,pvAddresses)	\
    ( (This)->lpVtbl -> get_NetworkAddresses(This,fTCP,fExternal,pvAddresses) ) 

#define IRTCClient2_put_Volume(This,enDevice,lVolume)	\
    ( (This)->lpVtbl -> put_Volume(This,enDevice,lVolume) ) 

#define IRTCClient2_get_Volume(This,enDevice,plVolume)	\
    ( (This)->lpVtbl -> get_Volume(This,enDevice,plVolume) ) 

#define IRTCClient2_put_AudioMuted(This,enDevice,fMuted)	\
    ( (This)->lpVtbl -> put_AudioMuted(This,enDevice,fMuted) ) 

#define IRTCClient2_get_AudioMuted(This,enDevice,pfMuted)	\
    ( (This)->lpVtbl -> get_AudioMuted(This,enDevice,pfMuted) ) 

#define IRTCClient2_get_IVideoWindow(This,enDevice,ppIVideoWindow)	\
    ( (This)->lpVtbl -> get_IVideoWindow(This,enDevice,ppIVideoWindow) ) 

#define IRTCClient2_put_PreferredAudioDevice(This,enDevice,bstrDeviceName)	\
    ( (This)->lpVtbl -> put_PreferredAudioDevice(This,enDevice,bstrDeviceName) ) 

#define IRTCClient2_get_PreferredAudioDevice(This,enDevice,pbstrDeviceName)	\
    ( (This)->lpVtbl -> get_PreferredAudioDevice(This,enDevice,pbstrDeviceName) ) 

#define IRTCClient2_put_PreferredVolume(This,enDevice,lVolume)	\
    ( (This)->lpVtbl -> put_PreferredVolume(This,enDevice,lVolume) ) 

#define IRTCClient2_get_PreferredVolume(This,enDevice,plVolume)	\
    ( (This)->lpVtbl -> get_PreferredVolume(This,enDevice,plVolume) ) 

#define IRTCClient2_put_PreferredAEC(This,bEnable)	\
    ( (This)->lpVtbl -> put_PreferredAEC(This,bEnable) ) 

#define IRTCClient2_get_PreferredAEC(This,pbEnabled)	\
    ( (This)->lpVtbl -> get_PreferredAEC(This,pbEnabled) ) 

#define IRTCClient2_put_PreferredVideoDevice(This,bstrDeviceName)	\
    ( (This)->lpVtbl -> put_PreferredVideoDevice(This,bstrDeviceName) ) 

#define IRTCClient2_get_PreferredVideoDevice(This,pbstrDeviceName)	\
    ( (This)->lpVtbl -> get_PreferredVideoDevice(This,pbstrDeviceName) ) 

#define IRTCClient2_get_ActiveMedia(This,plMediaType)	\
    ( (This)->lpVtbl -> get_ActiveMedia(This,plMediaType) ) 

#define IRTCClient2_put_MaxBitrate(This,lMaxBitrate)	\
    ( (This)->lpVtbl -> put_MaxBitrate(This,lMaxBitrate) ) 

#define IRTCClient2_get_MaxBitrate(This,plMaxBitrate)	\
    ( (This)->lpVtbl -> get_MaxBitrate(This,plMaxBitrate) ) 

#define IRTCClient2_put_TemporalSpatialTradeOff(This,lValue)	\
    ( (This)->lpVtbl -> put_TemporalSpatialTradeOff(This,lValue) ) 

#define IRTCClient2_get_TemporalSpatialTradeOff(This,plValue)	\
    ( (This)->lpVtbl -> get_TemporalSpatialTradeOff(This,plValue) ) 

#define IRTCClient2_get_NetworkQuality(This,plNetworkQuality)	\
    ( (This)->lpVtbl -> get_NetworkQuality(This,plNetworkQuality) ) 

#define IRTCClient2_StartT120Applet(This,enApplet)	\
    ( (This)->lpVtbl -> StartT120Applet(This,enApplet) ) 

#define IRTCClient2_StopT120Applets(This)	\
    ( (This)->lpVtbl -> StopT120Applets(This) ) 

#define IRTCClient2_get_IsT120AppletRunning(This,enApplet,pfRunning)	\
    ( (This)->lpVtbl -> get_IsT120AppletRunning(This,enApplet,pfRunning) ) 

#define IRTCClient2_get_LocalUserURI(This,pbstrUserURI)	\
    ( (This)->lpVtbl -> get_LocalUserURI(This,pbstrUserURI) ) 

#define IRTCClient2_put_LocalUserURI(This,bstrUserURI)	\
    ( (This)->lpVtbl -> put_LocalUserURI(This,bstrUserURI) ) 

#define IRTCClient2_get_LocalUserName(This,pbstrUserName)	\
    ( (This)->lpVtbl -> get_LocalUserName(This,pbstrUserName) ) 

#define IRTCClient2_put_LocalUserName(This,bstrUserName)	\
    ( (This)->lpVtbl -> put_LocalUserName(This,bstrUserName) ) 

#define IRTCClient2_PlayRing(This,enType,bPlay)	\
    ( (This)->lpVtbl -> PlayRing(This,enType,bPlay) ) 

#define IRTCClient2_SendDTMF(This,enDTMF)	\
    ( (This)->lpVtbl -> SendDTMF(This,enDTMF) ) 

#define IRTCClient2_InvokeTuningWizard(This,hwndParent)	\
    ( (This)->lpVtbl -> InvokeTuningWizard(This,hwndParent) ) 

#define IRTCClient2_get_IsTuned(This,pfTuned)	\
    ( (This)->lpVtbl -> get_IsTuned(This,pfTuned) ) 


#define IRTCClient2_put_AnswerMode(This,enType,enMode)	\
    ( (This)->lpVtbl -> put_AnswerMode(This,enType,enMode) ) 

#define IRTCClient2_get_AnswerMode(This,enType,penMode)	\
    ( (This)->lpVtbl -> get_AnswerMode(This,enType,penMode) ) 

#define IRTCClient2_InvokeTuningWizardEx(This,hwndParent,fAllowAudio,fAllowVideo)	\
    ( (This)->lpVtbl -> InvokeTuningWizardEx(This,hwndParent,fAllowAudio,fAllowVideo) ) 

#define IRTCClient2_get_Version(This,plVersion)	\
    ( (This)->lpVtbl -> get_Version(This,plVersion) ) 

#define IRTCClient2_put_ClientName(This,bstrClientName)	\
    ( (This)->lpVtbl -> put_ClientName(This,bstrClientName) ) 

#define IRTCClient2_put_ClientCurVer(This,bstrClientCurVer)	\
    ( (This)->lpVtbl -> put_ClientCurVer(This,bstrClientCurVer) ) 

#define IRTCClient2_InitializeEx(This,lFlags)	\
    ( (This)->lpVtbl -> InitializeEx(This,lFlags) ) 

#define IRTCClient2_CreateSessionWithDescription(This,bstrContentType,bstrSessionDescription,pProfile,lFlags,ppSession2)	\
    ( (This)->lpVtbl -> CreateSessionWithDescription(This,bstrContentType,bstrSessionDescription,pProfile,lFlags,ppSession2) ) 

#define IRTCClient2_SetSessionDescriptionManager(This,pSessionDescriptionManager)	\
    ( (This)->lpVtbl -> SetSessionDescriptionManager(This,pSessionDescriptionManager) ) 

#define IRTCClient2_put_PreferredSecurityLevel(This,enSecurityType,enSecurityLevel)	\
    ( (This)->lpVtbl -> put_PreferredSecurityLevel(This,enSecurityType,enSecurityLevel) ) 

#define IRTCClient2_get_PreferredSecurityLevel(This,enSecurityType,penSecurityLevel)	\
    ( (This)->lpVtbl -> get_PreferredSecurityLevel(This,enSecurityType,penSecurityLevel) ) 

#define IRTCClient2_put_AllowedPorts(This,lTransport,enListenMode)	\
    ( (This)->lpVtbl -> put_AllowedPorts(This,lTransport,enListenMode) ) 

#define IRTCClient2_get_AllowedPorts(This,lTransport,penListenMode)	\
    ( (This)->lpVtbl -> get_AllowedPorts(This,lTransport,penListenMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCClient2_INTERFACE_DEFINED__ */


#ifndef __IRTCClientPresence_INTERFACE_DEFINED__
#define __IRTCClientPresence_INTERFACE_DEFINED__

/* interface IRTCClientPresence */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCClientPresence;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("11c3cbcc-0744-42d1-968a-51aa1bb274c6")
    IRTCClientPresence : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnablePresence( 
            /* [in] */ VARIANT_BOOL fUseStorage,
            /* [in] */ VARIANT varStorage) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Export( 
            /* [in] */ VARIANT varStorage) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Import( 
            /* [in] */ VARIANT varStorage,
            /* [in] */ VARIANT_BOOL fReplaceAll) = 0;
        
        virtual /* [helpstring][hidden] */ HRESULT STDMETHODCALLTYPE EnumerateBuddies( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumBuddies **ppEnum) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Buddies( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppCollection) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Buddy( 
            /* [in] */ __RPC__in BSTR bstrPresentityURI,
            /* [retval][out] */ __RPC__deref_out_opt IRTCBuddy **ppBuddy) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddBuddy( 
            /* [in] */ __RPC__in BSTR bstrPresentityURI,
            /* [in] */ __RPC__in BSTR bstrUserName,
            /* [in] */ __RPC__in BSTR bstrData,
            /* [in] */ VARIANT_BOOL fPersistent,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lFlags,
            /* [retval][out] */ __RPC__deref_out_opt IRTCBuddy **ppBuddy) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveBuddy( 
            /* [in] */ __RPC__in_opt IRTCBuddy *pBuddy) = 0;
        
        virtual /* [helpstring][hidden] */ HRESULT STDMETHODCALLTYPE EnumerateWatchers( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumWatchers **ppEnum) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Watchers( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppCollection) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Watcher( 
            /* [in] */ __RPC__in BSTR bstrPresentityURI,
            /* [retval][out] */ __RPC__deref_out_opt IRTCWatcher **ppWatcher) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddWatcher( 
            /* [in] */ __RPC__in BSTR bstrPresentityURI,
            /* [in] */ __RPC__in BSTR bstrUserName,
            /* [in] */ __RPC__in BSTR bstrData,
            /* [in] */ VARIANT_BOOL fBlocked,
            /* [in] */ VARIANT_BOOL fPersistent,
            /* [retval][out] */ __RPC__deref_out_opt IRTCWatcher **ppWatcher) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveWatcher( 
            /* [in] */ __RPC__in_opt IRTCWatcher *pWatcher) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetLocalPresenceInfo( 
            /* [in] */ RTC_PRESENCE_STATUS enStatus,
            /* [in] */ __RPC__in BSTR bstrNotes) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_OfferWatcherMode( 
            /* [retval][out] */ __RPC__out RTC_OFFER_WATCHER_MODE *penMode) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_OfferWatcherMode( 
            /* [in] */ RTC_OFFER_WATCHER_MODE enMode) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PrivacyMode( 
            /* [retval][out] */ __RPC__out RTC_PRIVACY_MODE *penMode) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_PrivacyMode( 
            /* [in] */ RTC_PRIVACY_MODE enMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCClientPresenceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCClientPresence * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCClientPresence * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCClientPresence * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnablePresence )( 
            __RPC__in IRTCClientPresence * This,
            /* [in] */ VARIANT_BOOL fUseStorage,
            /* [in] */ VARIANT varStorage);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Export )( 
            __RPC__in IRTCClientPresence * This,
            /* [in] */ VARIANT varStorage);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Import )( 
            __RPC__in IRTCClientPresence * This,
            /* [in] */ VARIANT varStorage,
            /* [in] */ VARIANT_BOOL fReplaceAll);
        
        /* [helpstring][hidden] */ HRESULT ( STDMETHODCALLTYPE *EnumerateBuddies )( 
            __RPC__in IRTCClientPresence * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumBuddies **ppEnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Buddies )( 
            __RPC__in IRTCClientPresence * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppCollection);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Buddy )( 
            __RPC__in IRTCClientPresence * This,
            /* [in] */ __RPC__in BSTR bstrPresentityURI,
            /* [retval][out] */ __RPC__deref_out_opt IRTCBuddy **ppBuddy);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddBuddy )( 
            __RPC__in IRTCClientPresence * This,
            /* [in] */ __RPC__in BSTR bstrPresentityURI,
            /* [in] */ __RPC__in BSTR bstrUserName,
            /* [in] */ __RPC__in BSTR bstrData,
            /* [in] */ VARIANT_BOOL fPersistent,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lFlags,
            /* [retval][out] */ __RPC__deref_out_opt IRTCBuddy **ppBuddy);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveBuddy )( 
            __RPC__in IRTCClientPresence * This,
            /* [in] */ __RPC__in_opt IRTCBuddy *pBuddy);
        
        /* [helpstring][hidden] */ HRESULT ( STDMETHODCALLTYPE *EnumerateWatchers )( 
            __RPC__in IRTCClientPresence * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumWatchers **ppEnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Watchers )( 
            __RPC__in IRTCClientPresence * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppCollection);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Watcher )( 
            __RPC__in IRTCClientPresence * This,
            /* [in] */ __RPC__in BSTR bstrPresentityURI,
            /* [retval][out] */ __RPC__deref_out_opt IRTCWatcher **ppWatcher);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddWatcher )( 
            __RPC__in IRTCClientPresence * This,
            /* [in] */ __RPC__in BSTR bstrPresentityURI,
            /* [in] */ __RPC__in BSTR bstrUserName,
            /* [in] */ __RPC__in BSTR bstrData,
            /* [in] */ VARIANT_BOOL fBlocked,
            /* [in] */ VARIANT_BOOL fPersistent,
            /* [retval][out] */ __RPC__deref_out_opt IRTCWatcher **ppWatcher);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveWatcher )( 
            __RPC__in IRTCClientPresence * This,
            /* [in] */ __RPC__in_opt IRTCWatcher *pWatcher);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetLocalPresenceInfo )( 
            __RPC__in IRTCClientPresence * This,
            /* [in] */ RTC_PRESENCE_STATUS enStatus,
            /* [in] */ __RPC__in BSTR bstrNotes);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OfferWatcherMode )( 
            __RPC__in IRTCClientPresence * This,
            /* [retval][out] */ __RPC__out RTC_OFFER_WATCHER_MODE *penMode);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OfferWatcherMode )( 
            __RPC__in IRTCClientPresence * This,
            /* [in] */ RTC_OFFER_WATCHER_MODE enMode);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrivacyMode )( 
            __RPC__in IRTCClientPresence * This,
            /* [retval][out] */ __RPC__out RTC_PRIVACY_MODE *penMode);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrivacyMode )( 
            __RPC__in IRTCClientPresence * This,
            /* [in] */ RTC_PRIVACY_MODE enMode);
        
        END_INTERFACE
    } IRTCClientPresenceVtbl;

    interface IRTCClientPresence
    {
        CONST_VTBL struct IRTCClientPresenceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCClientPresence_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCClientPresence_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCClientPresence_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCClientPresence_EnablePresence(This,fUseStorage,varStorage)	\
    ( (This)->lpVtbl -> EnablePresence(This,fUseStorage,varStorage) ) 

#define IRTCClientPresence_Export(This,varStorage)	\
    ( (This)->lpVtbl -> Export(This,varStorage) ) 

#define IRTCClientPresence_Import(This,varStorage,fReplaceAll)	\
    ( (This)->lpVtbl -> Import(This,varStorage,fReplaceAll) ) 

#define IRTCClientPresence_EnumerateBuddies(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumerateBuddies(This,ppEnum) ) 

#define IRTCClientPresence_get_Buddies(This,ppCollection)	\
    ( (This)->lpVtbl -> get_Buddies(This,ppCollection) ) 

#define IRTCClientPresence_get_Buddy(This,bstrPresentityURI,ppBuddy)	\
    ( (This)->lpVtbl -> get_Buddy(This,bstrPresentityURI,ppBuddy) ) 

#define IRTCClientPresence_AddBuddy(This,bstrPresentityURI,bstrUserName,bstrData,fPersistent,pProfile,lFlags,ppBuddy)	\
    ( (This)->lpVtbl -> AddBuddy(This,bstrPresentityURI,bstrUserName,bstrData,fPersistent,pProfile,lFlags,ppBuddy) ) 

#define IRTCClientPresence_RemoveBuddy(This,pBuddy)	\
    ( (This)->lpVtbl -> RemoveBuddy(This,pBuddy) ) 

#define IRTCClientPresence_EnumerateWatchers(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumerateWatchers(This,ppEnum) ) 

#define IRTCClientPresence_get_Watchers(This,ppCollection)	\
    ( (This)->lpVtbl -> get_Watchers(This,ppCollection) ) 

#define IRTCClientPresence_get_Watcher(This,bstrPresentityURI,ppWatcher)	\
    ( (This)->lpVtbl -> get_Watcher(This,bstrPresentityURI,ppWatcher) ) 

#define IRTCClientPresence_AddWatcher(This,bstrPresentityURI,bstrUserName,bstrData,fBlocked,fPersistent,ppWatcher)	\
    ( (This)->lpVtbl -> AddWatcher(This,bstrPresentityURI,bstrUserName,bstrData,fBlocked,fPersistent,ppWatcher) ) 

#define IRTCClientPresence_RemoveWatcher(This,pWatcher)	\
    ( (This)->lpVtbl -> RemoveWatcher(This,pWatcher) ) 

#define IRTCClientPresence_SetLocalPresenceInfo(This,enStatus,bstrNotes)	\
    ( (This)->lpVtbl -> SetLocalPresenceInfo(This,enStatus,bstrNotes) ) 

#define IRTCClientPresence_get_OfferWatcherMode(This,penMode)	\
    ( (This)->lpVtbl -> get_OfferWatcherMode(This,penMode) ) 

#define IRTCClientPresence_put_OfferWatcherMode(This,enMode)	\
    ( (This)->lpVtbl -> put_OfferWatcherMode(This,enMode) ) 

#define IRTCClientPresence_get_PrivacyMode(This,penMode)	\
    ( (This)->lpVtbl -> get_PrivacyMode(This,penMode) ) 

#define IRTCClientPresence_put_PrivacyMode(This,enMode)	\
    ( (This)->lpVtbl -> put_PrivacyMode(This,enMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCClientPresence_INTERFACE_DEFINED__ */


#ifndef __IRTCClientPresence2_INTERFACE_DEFINED__
#define __IRTCClientPresence2_INTERFACE_DEFINED__

/* interface IRTCClientPresence2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCClientPresence2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AD1809E8-62F7-4783-909A-29C9D2CB1D34")
    IRTCClientPresence2 : public IRTCClientPresence
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnablePresenceEx( 
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ VARIANT varStorage,
            /* [in] */ long lFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DisablePresence( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddGroup( 
            /* [in] */ __RPC__in BSTR bstrGroupName,
            /* [in] */ __RPC__in BSTR bstrData,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lFlags,
            /* [retval][out] */ __RPC__deref_out_opt IRTCBuddyGroup **ppGroup) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveGroup( 
            /* [in] */ __RPC__in_opt IRTCBuddyGroup *pGroup) = 0;
        
        virtual /* [helpstring][hidden] */ HRESULT STDMETHODCALLTYPE EnumerateGroups( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumGroups **ppEnum) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Groups( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppCollection) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Group( 
            /* [in] */ __RPC__in BSTR bstrGroupName,
            /* [retval][out] */ __RPC__deref_out_opt IRTCBuddyGroup **ppGroup) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddWatcherEx( 
            /* [in] */ __RPC__in BSTR bstrPresentityURI,
            /* [in] */ __RPC__in BSTR bstrUserName,
            /* [in] */ __RPC__in BSTR bstrData,
            /* [in] */ RTC_WATCHER_STATE enState,
            /* [in] */ VARIANT_BOOL fPersistent,
            /* [in] */ RTC_ACE_SCOPE enScope,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lFlags,
            /* [retval][out] */ __RPC__deref_out_opt IRTCWatcher2 **ppWatcher) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_WatcherEx( 
            /* [in] */ RTC_WATCHER_MATCH_MODE enMode,
            /* [in] */ __RPC__in BSTR bstrPresentityURI,
            /* [retval][out] */ __RPC__deref_out_opt IRTCWatcher2 **ppWatcher) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_PresenceProperty( 
            /* [in] */ RTC_PRESENCE_PROPERTY enProperty,
            /* [in] */ __RPC__in BSTR bstrProperty) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PresenceProperty( 
            /* [in] */ RTC_PRESENCE_PROPERTY enProperty,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProperty) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPresenceData( 
            /* [in] */ __RPC__in BSTR bstrNamespace,
            /* [in] */ __RPC__in BSTR bstrData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPresenceData( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrNamespace,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLocalPresenceInfo( 
            /* [out] */ __RPC__out RTC_PRESENCE_STATUS *penStatus,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrNotes) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddBuddyEx( 
            /* [in] */ __RPC__in BSTR bstrPresentityURI,
            /* [in] */ __RPC__in BSTR bstrUserName,
            /* [in] */ __RPC__in BSTR bstrData,
            /* [in] */ VARIANT_BOOL fPersistent,
            /* [in] */ RTC_BUDDY_SUBSCRIPTION_TYPE enSubscriptionType,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lFlags,
            /* [retval][out] */ __RPC__deref_out_opt IRTCBuddy2 **ppBuddy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCClientPresence2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCClientPresence2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCClientPresence2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnablePresence )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ VARIANT_BOOL fUseStorage,
            /* [in] */ VARIANT varStorage);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Export )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ VARIANT varStorage);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Import )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ VARIANT varStorage,
            /* [in] */ VARIANT_BOOL fReplaceAll);
        
        /* [helpstring][hidden] */ HRESULT ( STDMETHODCALLTYPE *EnumerateBuddies )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumBuddies **ppEnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Buddies )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppCollection);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Buddy )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ __RPC__in BSTR bstrPresentityURI,
            /* [retval][out] */ __RPC__deref_out_opt IRTCBuddy **ppBuddy);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddBuddy )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ __RPC__in BSTR bstrPresentityURI,
            /* [in] */ __RPC__in BSTR bstrUserName,
            /* [in] */ __RPC__in BSTR bstrData,
            /* [in] */ VARIANT_BOOL fPersistent,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lFlags,
            /* [retval][out] */ __RPC__deref_out_opt IRTCBuddy **ppBuddy);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveBuddy )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ __RPC__in_opt IRTCBuddy *pBuddy);
        
        /* [helpstring][hidden] */ HRESULT ( STDMETHODCALLTYPE *EnumerateWatchers )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumWatchers **ppEnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Watchers )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppCollection);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Watcher )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ __RPC__in BSTR bstrPresentityURI,
            /* [retval][out] */ __RPC__deref_out_opt IRTCWatcher **ppWatcher);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddWatcher )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ __RPC__in BSTR bstrPresentityURI,
            /* [in] */ __RPC__in BSTR bstrUserName,
            /* [in] */ __RPC__in BSTR bstrData,
            /* [in] */ VARIANT_BOOL fBlocked,
            /* [in] */ VARIANT_BOOL fPersistent,
            /* [retval][out] */ __RPC__deref_out_opt IRTCWatcher **ppWatcher);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveWatcher )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ __RPC__in_opt IRTCWatcher *pWatcher);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetLocalPresenceInfo )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ RTC_PRESENCE_STATUS enStatus,
            /* [in] */ __RPC__in BSTR bstrNotes);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OfferWatcherMode )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [retval][out] */ __RPC__out RTC_OFFER_WATCHER_MODE *penMode);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OfferWatcherMode )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ RTC_OFFER_WATCHER_MODE enMode);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrivacyMode )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [retval][out] */ __RPC__out RTC_PRIVACY_MODE *penMode);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PrivacyMode )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ RTC_PRIVACY_MODE enMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnablePresenceEx )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ VARIANT varStorage,
            /* [in] */ long lFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DisablePresence )( 
            __RPC__in IRTCClientPresence2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddGroup )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ __RPC__in BSTR bstrGroupName,
            /* [in] */ __RPC__in BSTR bstrData,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lFlags,
            /* [retval][out] */ __RPC__deref_out_opt IRTCBuddyGroup **ppGroup);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveGroup )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ __RPC__in_opt IRTCBuddyGroup *pGroup);
        
        /* [helpstring][hidden] */ HRESULT ( STDMETHODCALLTYPE *EnumerateGroups )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumGroups **ppEnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Groups )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppCollection);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Group )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ __RPC__in BSTR bstrGroupName,
            /* [retval][out] */ __RPC__deref_out_opt IRTCBuddyGroup **ppGroup);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddWatcherEx )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ __RPC__in BSTR bstrPresentityURI,
            /* [in] */ __RPC__in BSTR bstrUserName,
            /* [in] */ __RPC__in BSTR bstrData,
            /* [in] */ RTC_WATCHER_STATE enState,
            /* [in] */ VARIANT_BOOL fPersistent,
            /* [in] */ RTC_ACE_SCOPE enScope,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lFlags,
            /* [retval][out] */ __RPC__deref_out_opt IRTCWatcher2 **ppWatcher);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WatcherEx )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ RTC_WATCHER_MATCH_MODE enMode,
            /* [in] */ __RPC__in BSTR bstrPresentityURI,
            /* [retval][out] */ __RPC__deref_out_opt IRTCWatcher2 **ppWatcher);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PresenceProperty )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ RTC_PRESENCE_PROPERTY enProperty,
            /* [in] */ __RPC__in BSTR bstrProperty);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PresenceProperty )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ RTC_PRESENCE_PROPERTY enProperty,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProperty);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPresenceData )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ __RPC__in BSTR bstrNamespace,
            /* [in] */ __RPC__in BSTR bstrData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPresenceData )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrNamespace,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLocalPresenceInfo )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [out] */ __RPC__out RTC_PRESENCE_STATUS *penStatus,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrNotes);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddBuddyEx )( 
            __RPC__in IRTCClientPresence2 * This,
            /* [in] */ __RPC__in BSTR bstrPresentityURI,
            /* [in] */ __RPC__in BSTR bstrUserName,
            /* [in] */ __RPC__in BSTR bstrData,
            /* [in] */ VARIANT_BOOL fPersistent,
            /* [in] */ RTC_BUDDY_SUBSCRIPTION_TYPE enSubscriptionType,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lFlags,
            /* [retval][out] */ __RPC__deref_out_opt IRTCBuddy2 **ppBuddy);
        
        END_INTERFACE
    } IRTCClientPresence2Vtbl;

    interface IRTCClientPresence2
    {
        CONST_VTBL struct IRTCClientPresence2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCClientPresence2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCClientPresence2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCClientPresence2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCClientPresence2_EnablePresence(This,fUseStorage,varStorage)	\
    ( (This)->lpVtbl -> EnablePresence(This,fUseStorage,varStorage) ) 

#define IRTCClientPresence2_Export(This,varStorage)	\
    ( (This)->lpVtbl -> Export(This,varStorage) ) 

#define IRTCClientPresence2_Import(This,varStorage,fReplaceAll)	\
    ( (This)->lpVtbl -> Import(This,varStorage,fReplaceAll) ) 

#define IRTCClientPresence2_EnumerateBuddies(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumerateBuddies(This,ppEnum) ) 

#define IRTCClientPresence2_get_Buddies(This,ppCollection)	\
    ( (This)->lpVtbl -> get_Buddies(This,ppCollection) ) 

#define IRTCClientPresence2_get_Buddy(This,bstrPresentityURI,ppBuddy)	\
    ( (This)->lpVtbl -> get_Buddy(This,bstrPresentityURI,ppBuddy) ) 

#define IRTCClientPresence2_AddBuddy(This,bstrPresentityURI,bstrUserName,bstrData,fPersistent,pProfile,lFlags,ppBuddy)	\
    ( (This)->lpVtbl -> AddBuddy(This,bstrPresentityURI,bstrUserName,bstrData,fPersistent,pProfile,lFlags,ppBuddy) ) 

#define IRTCClientPresence2_RemoveBuddy(This,pBuddy)	\
    ( (This)->lpVtbl -> RemoveBuddy(This,pBuddy) ) 

#define IRTCClientPresence2_EnumerateWatchers(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumerateWatchers(This,ppEnum) ) 

#define IRTCClientPresence2_get_Watchers(This,ppCollection)	\
    ( (This)->lpVtbl -> get_Watchers(This,ppCollection) ) 

#define IRTCClientPresence2_get_Watcher(This,bstrPresentityURI,ppWatcher)	\
    ( (This)->lpVtbl -> get_Watcher(This,bstrPresentityURI,ppWatcher) ) 

#define IRTCClientPresence2_AddWatcher(This,bstrPresentityURI,bstrUserName,bstrData,fBlocked,fPersistent,ppWatcher)	\
    ( (This)->lpVtbl -> AddWatcher(This,bstrPresentityURI,bstrUserName,bstrData,fBlocked,fPersistent,ppWatcher) ) 

#define IRTCClientPresence2_RemoveWatcher(This,pWatcher)	\
    ( (This)->lpVtbl -> RemoveWatcher(This,pWatcher) ) 

#define IRTCClientPresence2_SetLocalPresenceInfo(This,enStatus,bstrNotes)	\
    ( (This)->lpVtbl -> SetLocalPresenceInfo(This,enStatus,bstrNotes) ) 

#define IRTCClientPresence2_get_OfferWatcherMode(This,penMode)	\
    ( (This)->lpVtbl -> get_OfferWatcherMode(This,penMode) ) 

#define IRTCClientPresence2_put_OfferWatcherMode(This,enMode)	\
    ( (This)->lpVtbl -> put_OfferWatcherMode(This,enMode) ) 

#define IRTCClientPresence2_get_PrivacyMode(This,penMode)	\
    ( (This)->lpVtbl -> get_PrivacyMode(This,penMode) ) 

#define IRTCClientPresence2_put_PrivacyMode(This,enMode)	\
    ( (This)->lpVtbl -> put_PrivacyMode(This,enMode) ) 


#define IRTCClientPresence2_EnablePresenceEx(This,pProfile,varStorage,lFlags)	\
    ( (This)->lpVtbl -> EnablePresenceEx(This,pProfile,varStorage,lFlags) ) 

#define IRTCClientPresence2_DisablePresence(This)	\
    ( (This)->lpVtbl -> DisablePresence(This) ) 

#define IRTCClientPresence2_AddGroup(This,bstrGroupName,bstrData,pProfile,lFlags,ppGroup)	\
    ( (This)->lpVtbl -> AddGroup(This,bstrGroupName,bstrData,pProfile,lFlags,ppGroup) ) 

#define IRTCClientPresence2_RemoveGroup(This,pGroup)	\
    ( (This)->lpVtbl -> RemoveGroup(This,pGroup) ) 

#define IRTCClientPresence2_EnumerateGroups(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumerateGroups(This,ppEnum) ) 

#define IRTCClientPresence2_get_Groups(This,ppCollection)	\
    ( (This)->lpVtbl -> get_Groups(This,ppCollection) ) 

#define IRTCClientPresence2_get_Group(This,bstrGroupName,ppGroup)	\
    ( (This)->lpVtbl -> get_Group(This,bstrGroupName,ppGroup) ) 

#define IRTCClientPresence2_AddWatcherEx(This,bstrPresentityURI,bstrUserName,bstrData,enState,fPersistent,enScope,pProfile,lFlags,ppWatcher)	\
    ( (This)->lpVtbl -> AddWatcherEx(This,bstrPresentityURI,bstrUserName,bstrData,enState,fPersistent,enScope,pProfile,lFlags,ppWatcher) ) 

#define IRTCClientPresence2_get_WatcherEx(This,enMode,bstrPresentityURI,ppWatcher)	\
    ( (This)->lpVtbl -> get_WatcherEx(This,enMode,bstrPresentityURI,ppWatcher) ) 

#define IRTCClientPresence2_put_PresenceProperty(This,enProperty,bstrProperty)	\
    ( (This)->lpVtbl -> put_PresenceProperty(This,enProperty,bstrProperty) ) 

#define IRTCClientPresence2_get_PresenceProperty(This,enProperty,pbstrProperty)	\
    ( (This)->lpVtbl -> get_PresenceProperty(This,enProperty,pbstrProperty) ) 

#define IRTCClientPresence2_SetPresenceData(This,bstrNamespace,bstrData)	\
    ( (This)->lpVtbl -> SetPresenceData(This,bstrNamespace,bstrData) ) 

#define IRTCClientPresence2_GetPresenceData(This,pbstrNamespace,pbstrData)	\
    ( (This)->lpVtbl -> GetPresenceData(This,pbstrNamespace,pbstrData) ) 

#define IRTCClientPresence2_GetLocalPresenceInfo(This,penStatus,pbstrNotes)	\
    ( (This)->lpVtbl -> GetLocalPresenceInfo(This,penStatus,pbstrNotes) ) 

#define IRTCClientPresence2_AddBuddyEx(This,bstrPresentityURI,bstrUserName,bstrData,fPersistent,enSubscriptionType,pProfile,lFlags,ppBuddy)	\
    ( (This)->lpVtbl -> AddBuddyEx(This,bstrPresentityURI,bstrUserName,bstrData,fPersistent,enSubscriptionType,pProfile,lFlags,ppBuddy) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCClientPresence2_INTERFACE_DEFINED__ */


#ifndef __IRTCClientProvisioning_INTERFACE_DEFINED__
#define __IRTCClientProvisioning_INTERFACE_DEFINED__

/* interface IRTCClientProvisioning */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCClientProvisioning;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B9F5CF06-65B9-4a80-A0E6-73CAE3EF3822")
    IRTCClientProvisioning : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateProfile( 
            /* [in] */ __RPC__in BSTR bstrProfileXML,
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile **ppProfile) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnableProfile( 
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lRegisterFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DisableProfile( 
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile) = 0;
        
        virtual /* [helpstring][hidden] */ HRESULT STDMETHODCALLTYPE EnumerateProfiles( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumProfiles **ppEnum) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Profiles( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppCollection) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProfile( 
            /* [in] */ __RPC__in BSTR bstrUserAccount,
            /* [in] */ __RPC__in BSTR bstrUserPassword,
            /* [in] */ __RPC__in BSTR bstrUserURI,
            /* [in] */ __RPC__in BSTR bstrServer,
            /* [in] */ long lTransport,
            /* [in] */ LONG_PTR lCookie) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SessionCapabilities( 
            /* [retval][out] */ __RPC__out long *plSupportedSessions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCClientProvisioningVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCClientProvisioning * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCClientProvisioning * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCClientProvisioning * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateProfile )( 
            __RPC__in IRTCClientProvisioning * This,
            /* [in] */ __RPC__in BSTR bstrProfileXML,
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile **ppProfile);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnableProfile )( 
            __RPC__in IRTCClientProvisioning * This,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lRegisterFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DisableProfile )( 
            __RPC__in IRTCClientProvisioning * This,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile);
        
        /* [helpstring][hidden] */ HRESULT ( STDMETHODCALLTYPE *EnumerateProfiles )( 
            __RPC__in IRTCClientProvisioning * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumProfiles **ppEnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Profiles )( 
            __RPC__in IRTCClientProvisioning * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppCollection);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProfile )( 
            __RPC__in IRTCClientProvisioning * This,
            /* [in] */ __RPC__in BSTR bstrUserAccount,
            /* [in] */ __RPC__in BSTR bstrUserPassword,
            /* [in] */ __RPC__in BSTR bstrUserURI,
            /* [in] */ __RPC__in BSTR bstrServer,
            /* [in] */ long lTransport,
            /* [in] */ LONG_PTR lCookie);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SessionCapabilities )( 
            __RPC__in IRTCClientProvisioning * This,
            /* [retval][out] */ __RPC__out long *plSupportedSessions);
        
        END_INTERFACE
    } IRTCClientProvisioningVtbl;

    interface IRTCClientProvisioning
    {
        CONST_VTBL struct IRTCClientProvisioningVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCClientProvisioning_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCClientProvisioning_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCClientProvisioning_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCClientProvisioning_CreateProfile(This,bstrProfileXML,ppProfile)	\
    ( (This)->lpVtbl -> CreateProfile(This,bstrProfileXML,ppProfile) ) 

#define IRTCClientProvisioning_EnableProfile(This,pProfile,lRegisterFlags)	\
    ( (This)->lpVtbl -> EnableProfile(This,pProfile,lRegisterFlags) ) 

#define IRTCClientProvisioning_DisableProfile(This,pProfile)	\
    ( (This)->lpVtbl -> DisableProfile(This,pProfile) ) 

#define IRTCClientProvisioning_EnumerateProfiles(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumerateProfiles(This,ppEnum) ) 

#define IRTCClientProvisioning_get_Profiles(This,ppCollection)	\
    ( (This)->lpVtbl -> get_Profiles(This,ppCollection) ) 

#define IRTCClientProvisioning_GetProfile(This,bstrUserAccount,bstrUserPassword,bstrUserURI,bstrServer,lTransport,lCookie)	\
    ( (This)->lpVtbl -> GetProfile(This,bstrUserAccount,bstrUserPassword,bstrUserURI,bstrServer,lTransport,lCookie) ) 

#define IRTCClientProvisioning_get_SessionCapabilities(This,plSupportedSessions)	\
    ( (This)->lpVtbl -> get_SessionCapabilities(This,plSupportedSessions) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCClientProvisioning_INTERFACE_DEFINED__ */


#ifndef __IRTCClientProvisioning2_INTERFACE_DEFINED__
#define __IRTCClientProvisioning2_INTERFACE_DEFINED__

/* interface IRTCClientProvisioning2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCClientProvisioning2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A70909B5-F40E-4587-BB75-E6BC0845023E")
    IRTCClientProvisioning2 : public IRTCClientProvisioning
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnableProfileEx( 
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lRegisterFlags,
            /* [in] */ long lRoamingFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCClientProvisioning2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCClientProvisioning2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCClientProvisioning2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCClientProvisioning2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateProfile )( 
            __RPC__in IRTCClientProvisioning2 * This,
            /* [in] */ __RPC__in BSTR bstrProfileXML,
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile **ppProfile);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnableProfile )( 
            __RPC__in IRTCClientProvisioning2 * This,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lRegisterFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DisableProfile )( 
            __RPC__in IRTCClientProvisioning2 * This,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile);
        
        /* [helpstring][hidden] */ HRESULT ( STDMETHODCALLTYPE *EnumerateProfiles )( 
            __RPC__in IRTCClientProvisioning2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumProfiles **ppEnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Profiles )( 
            __RPC__in IRTCClientProvisioning2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppCollection);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProfile )( 
            __RPC__in IRTCClientProvisioning2 * This,
            /* [in] */ __RPC__in BSTR bstrUserAccount,
            /* [in] */ __RPC__in BSTR bstrUserPassword,
            /* [in] */ __RPC__in BSTR bstrUserURI,
            /* [in] */ __RPC__in BSTR bstrServer,
            /* [in] */ long lTransport,
            /* [in] */ LONG_PTR lCookie);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SessionCapabilities )( 
            __RPC__in IRTCClientProvisioning2 * This,
            /* [retval][out] */ __RPC__out long *plSupportedSessions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnableProfileEx )( 
            __RPC__in IRTCClientProvisioning2 * This,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lRegisterFlags,
            /* [in] */ long lRoamingFlags);
        
        END_INTERFACE
    } IRTCClientProvisioning2Vtbl;

    interface IRTCClientProvisioning2
    {
        CONST_VTBL struct IRTCClientProvisioning2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCClientProvisioning2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCClientProvisioning2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCClientProvisioning2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCClientProvisioning2_CreateProfile(This,bstrProfileXML,ppProfile)	\
    ( (This)->lpVtbl -> CreateProfile(This,bstrProfileXML,ppProfile) ) 

#define IRTCClientProvisioning2_EnableProfile(This,pProfile,lRegisterFlags)	\
    ( (This)->lpVtbl -> EnableProfile(This,pProfile,lRegisterFlags) ) 

#define IRTCClientProvisioning2_DisableProfile(This,pProfile)	\
    ( (This)->lpVtbl -> DisableProfile(This,pProfile) ) 

#define IRTCClientProvisioning2_EnumerateProfiles(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumerateProfiles(This,ppEnum) ) 

#define IRTCClientProvisioning2_get_Profiles(This,ppCollection)	\
    ( (This)->lpVtbl -> get_Profiles(This,ppCollection) ) 

#define IRTCClientProvisioning2_GetProfile(This,bstrUserAccount,bstrUserPassword,bstrUserURI,bstrServer,lTransport,lCookie)	\
    ( (This)->lpVtbl -> GetProfile(This,bstrUserAccount,bstrUserPassword,bstrUserURI,bstrServer,lTransport,lCookie) ) 

#define IRTCClientProvisioning2_get_SessionCapabilities(This,plSupportedSessions)	\
    ( (This)->lpVtbl -> get_SessionCapabilities(This,plSupportedSessions) ) 


#define IRTCClientProvisioning2_EnableProfileEx(This,pProfile,lRegisterFlags,lRoamingFlags)	\
    ( (This)->lpVtbl -> EnableProfileEx(This,pProfile,lRegisterFlags,lRoamingFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCClientProvisioning2_INTERFACE_DEFINED__ */


#ifndef __IRTCProfile_INTERFACE_DEFINED__
#define __IRTCProfile_INTERFACE_DEFINED__

/* interface IRTCProfile */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCProfile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d07eca9e-4062-4dd4-9e7d-722a49ba7303")
    IRTCProfile : public IUnknown
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrKey) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_XML( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrXML) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ProviderName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ProviderURI( 
            /* [in] */ RTC_PROVIDER_URI enURI,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrURI) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ProviderData( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrData) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ClientName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ClientBanner( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfBanner) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ClientMinVer( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrMinVer) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ClientCurVer( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCurVer) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ClientUpdateURI( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUpdateURI) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ClientData( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrData) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UserURI( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserURI) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UserName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UserAccount( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserAccount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetCredentials( 
            /* [in] */ __RPC__in BSTR bstrUserURI,
            /* [in] */ __RPC__in BSTR bstrUserAccount,
            /* [in] */ __RPC__in BSTR bstrPassword) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SessionCapabilities( 
            /* [retval][out] */ __RPC__out long *plSupportedSessions) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out RTC_REGISTRATION_STATE *penState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCProfileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCProfile * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCProfile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCProfile * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Key )( 
            __RPC__in IRTCProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrKey);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IRTCProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_XML )( 
            __RPC__in IRTCProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrXML);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderName )( 
            __RPC__in IRTCProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderURI )( 
            __RPC__in IRTCProfile * This,
            /* [in] */ RTC_PROVIDER_URI enURI,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrURI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderData )( 
            __RPC__in IRTCProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrData);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientName )( 
            __RPC__in IRTCProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientBanner )( 
            __RPC__in IRTCProfile * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfBanner);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientMinVer )( 
            __RPC__in IRTCProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrMinVer);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientCurVer )( 
            __RPC__in IRTCProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCurVer);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientUpdateURI )( 
            __RPC__in IRTCProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUpdateURI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientData )( 
            __RPC__in IRTCProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrData);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserURI )( 
            __RPC__in IRTCProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserURI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserName )( 
            __RPC__in IRTCProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserAccount )( 
            __RPC__in IRTCProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserAccount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetCredentials )( 
            __RPC__in IRTCProfile * This,
            /* [in] */ __RPC__in BSTR bstrUserURI,
            /* [in] */ __RPC__in BSTR bstrUserAccount,
            /* [in] */ __RPC__in BSTR bstrPassword);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SessionCapabilities )( 
            __RPC__in IRTCProfile * This,
            /* [retval][out] */ __RPC__out long *plSupportedSessions);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            __RPC__in IRTCProfile * This,
            /* [retval][out] */ __RPC__out RTC_REGISTRATION_STATE *penState);
        
        END_INTERFACE
    } IRTCProfileVtbl;

    interface IRTCProfile
    {
        CONST_VTBL struct IRTCProfileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCProfile_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCProfile_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCProfile_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCProfile_get_Key(This,pbstrKey)	\
    ( (This)->lpVtbl -> get_Key(This,pbstrKey) ) 

#define IRTCProfile_get_Name(This,pbstrName)	\
    ( (This)->lpVtbl -> get_Name(This,pbstrName) ) 

#define IRTCProfile_get_XML(This,pbstrXML)	\
    ( (This)->lpVtbl -> get_XML(This,pbstrXML) ) 

#define IRTCProfile_get_ProviderName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_ProviderName(This,pbstrName) ) 

#define IRTCProfile_get_ProviderURI(This,enURI,pbstrURI)	\
    ( (This)->lpVtbl -> get_ProviderURI(This,enURI,pbstrURI) ) 

#define IRTCProfile_get_ProviderData(This,pbstrData)	\
    ( (This)->lpVtbl -> get_ProviderData(This,pbstrData) ) 

#define IRTCProfile_get_ClientName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_ClientName(This,pbstrName) ) 

#define IRTCProfile_get_ClientBanner(This,pfBanner)	\
    ( (This)->lpVtbl -> get_ClientBanner(This,pfBanner) ) 

#define IRTCProfile_get_ClientMinVer(This,pbstrMinVer)	\
    ( (This)->lpVtbl -> get_ClientMinVer(This,pbstrMinVer) ) 

#define IRTCProfile_get_ClientCurVer(This,pbstrCurVer)	\
    ( (This)->lpVtbl -> get_ClientCurVer(This,pbstrCurVer) ) 

#define IRTCProfile_get_ClientUpdateURI(This,pbstrUpdateURI)	\
    ( (This)->lpVtbl -> get_ClientUpdateURI(This,pbstrUpdateURI) ) 

#define IRTCProfile_get_ClientData(This,pbstrData)	\
    ( (This)->lpVtbl -> get_ClientData(This,pbstrData) ) 

#define IRTCProfile_get_UserURI(This,pbstrUserURI)	\
    ( (This)->lpVtbl -> get_UserURI(This,pbstrUserURI) ) 

#define IRTCProfile_get_UserName(This,pbstrUserName)	\
    ( (This)->lpVtbl -> get_UserName(This,pbstrUserName) ) 

#define IRTCProfile_get_UserAccount(This,pbstrUserAccount)	\
    ( (This)->lpVtbl -> get_UserAccount(This,pbstrUserAccount) ) 

#define IRTCProfile_SetCredentials(This,bstrUserURI,bstrUserAccount,bstrPassword)	\
    ( (This)->lpVtbl -> SetCredentials(This,bstrUserURI,bstrUserAccount,bstrPassword) ) 

#define IRTCProfile_get_SessionCapabilities(This,plSupportedSessions)	\
    ( (This)->lpVtbl -> get_SessionCapabilities(This,plSupportedSessions) ) 

#define IRTCProfile_get_State(This,penState)	\
    ( (This)->lpVtbl -> get_State(This,penState) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCProfile_INTERFACE_DEFINED__ */


#ifndef __IRTCProfile2_INTERFACE_DEFINED__
#define __IRTCProfile2_INTERFACE_DEFINED__

/* interface IRTCProfile2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCProfile2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4B81F84E-BDC7-4184-9154-3CB2DD7917FB")
    IRTCProfile2 : public IRTCProfile
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Realm( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrRealm) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Realm( 
            /* [in] */ __RPC__in BSTR bstrRealm) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_AllowedAuth( 
            /* [retval][out] */ __RPC__out long *plAllowedAuth) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_AllowedAuth( 
            /* [in] */ long lAllowedAuth) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCProfile2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCProfile2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCProfile2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCProfile2 * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Key )( 
            __RPC__in IRTCProfile2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrKey);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IRTCProfile2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_XML )( 
            __RPC__in IRTCProfile2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrXML);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderName )( 
            __RPC__in IRTCProfile2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderURI )( 
            __RPC__in IRTCProfile2 * This,
            /* [in] */ RTC_PROVIDER_URI enURI,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrURI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderData )( 
            __RPC__in IRTCProfile2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrData);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientName )( 
            __RPC__in IRTCProfile2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientBanner )( 
            __RPC__in IRTCProfile2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfBanner);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientMinVer )( 
            __RPC__in IRTCProfile2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrMinVer);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientCurVer )( 
            __RPC__in IRTCProfile2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCurVer);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientUpdateURI )( 
            __RPC__in IRTCProfile2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUpdateURI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientData )( 
            __RPC__in IRTCProfile2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrData);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserURI )( 
            __RPC__in IRTCProfile2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserURI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserName )( 
            __RPC__in IRTCProfile2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserAccount )( 
            __RPC__in IRTCProfile2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserAccount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetCredentials )( 
            __RPC__in IRTCProfile2 * This,
            /* [in] */ __RPC__in BSTR bstrUserURI,
            /* [in] */ __RPC__in BSTR bstrUserAccount,
            /* [in] */ __RPC__in BSTR bstrPassword);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SessionCapabilities )( 
            __RPC__in IRTCProfile2 * This,
            /* [retval][out] */ __RPC__out long *plSupportedSessions);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            __RPC__in IRTCProfile2 * This,
            /* [retval][out] */ __RPC__out RTC_REGISTRATION_STATE *penState);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Realm )( 
            __RPC__in IRTCProfile2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrRealm);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Realm )( 
            __RPC__in IRTCProfile2 * This,
            /* [in] */ __RPC__in BSTR bstrRealm);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowedAuth )( 
            __RPC__in IRTCProfile2 * This,
            /* [retval][out] */ __RPC__out long *plAllowedAuth);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowedAuth )( 
            __RPC__in IRTCProfile2 * This,
            /* [in] */ long lAllowedAuth);
        
        END_INTERFACE
    } IRTCProfile2Vtbl;

    interface IRTCProfile2
    {
        CONST_VTBL struct IRTCProfile2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCProfile2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCProfile2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCProfile2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCProfile2_get_Key(This,pbstrKey)	\
    ( (This)->lpVtbl -> get_Key(This,pbstrKey) ) 

#define IRTCProfile2_get_Name(This,pbstrName)	\
    ( (This)->lpVtbl -> get_Name(This,pbstrName) ) 

#define IRTCProfile2_get_XML(This,pbstrXML)	\
    ( (This)->lpVtbl -> get_XML(This,pbstrXML) ) 

#define IRTCProfile2_get_ProviderName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_ProviderName(This,pbstrName) ) 

#define IRTCProfile2_get_ProviderURI(This,enURI,pbstrURI)	\
    ( (This)->lpVtbl -> get_ProviderURI(This,enURI,pbstrURI) ) 

#define IRTCProfile2_get_ProviderData(This,pbstrData)	\
    ( (This)->lpVtbl -> get_ProviderData(This,pbstrData) ) 

#define IRTCProfile2_get_ClientName(This,pbstrName)	\
    ( (This)->lpVtbl -> get_ClientName(This,pbstrName) ) 

#define IRTCProfile2_get_ClientBanner(This,pfBanner)	\
    ( (This)->lpVtbl -> get_ClientBanner(This,pfBanner) ) 

#define IRTCProfile2_get_ClientMinVer(This,pbstrMinVer)	\
    ( (This)->lpVtbl -> get_ClientMinVer(This,pbstrMinVer) ) 

#define IRTCProfile2_get_ClientCurVer(This,pbstrCurVer)	\
    ( (This)->lpVtbl -> get_ClientCurVer(This,pbstrCurVer) ) 

#define IRTCProfile2_get_ClientUpdateURI(This,pbstrUpdateURI)	\
    ( (This)->lpVtbl -> get_ClientUpdateURI(This,pbstrUpdateURI) ) 

#define IRTCProfile2_get_ClientData(This,pbstrData)	\
    ( (This)->lpVtbl -> get_ClientData(This,pbstrData) ) 

#define IRTCProfile2_get_UserURI(This,pbstrUserURI)	\
    ( (This)->lpVtbl -> get_UserURI(This,pbstrUserURI) ) 

#define IRTCProfile2_get_UserName(This,pbstrUserName)	\
    ( (This)->lpVtbl -> get_UserName(This,pbstrUserName) ) 

#define IRTCProfile2_get_UserAccount(This,pbstrUserAccount)	\
    ( (This)->lpVtbl -> get_UserAccount(This,pbstrUserAccount) ) 

#define IRTCProfile2_SetCredentials(This,bstrUserURI,bstrUserAccount,bstrPassword)	\
    ( (This)->lpVtbl -> SetCredentials(This,bstrUserURI,bstrUserAccount,bstrPassword) ) 

#define IRTCProfile2_get_SessionCapabilities(This,plSupportedSessions)	\
    ( (This)->lpVtbl -> get_SessionCapabilities(This,plSupportedSessions) ) 

#define IRTCProfile2_get_State(This,penState)	\
    ( (This)->lpVtbl -> get_State(This,penState) ) 


#define IRTCProfile2_get_Realm(This,pbstrRealm)	\
    ( (This)->lpVtbl -> get_Realm(This,pbstrRealm) ) 

#define IRTCProfile2_put_Realm(This,bstrRealm)	\
    ( (This)->lpVtbl -> put_Realm(This,bstrRealm) ) 

#define IRTCProfile2_get_AllowedAuth(This,plAllowedAuth)	\
    ( (This)->lpVtbl -> get_AllowedAuth(This,plAllowedAuth) ) 

#define IRTCProfile2_put_AllowedAuth(This,lAllowedAuth)	\
    ( (This)->lpVtbl -> put_AllowedAuth(This,lAllowedAuth) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCProfile2_INTERFACE_DEFINED__ */


#ifndef __IRTCSession_INTERFACE_DEFINED__
#define __IRTCSession_INTERFACE_DEFINED__

/* interface IRTCSession */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("387c8086-99be-42fb-9973-7c0fc0ca9fa8")
    IRTCSession : public IUnknown
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Client( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCClient **ppClient) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out RTC_SESSION_STATE *penState) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ __RPC__out RTC_SESSION_TYPE *penType) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Profile( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile **ppProfile) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Participants( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppCollection) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Answer( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Terminate( 
            /* [in] */ RTC_TERMINATE_REASON enReason) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Redirect( 
            /* [in] */ RTC_SESSION_TYPE enType,
            /* [in] */ __RPC__in BSTR bstrLocalPhoneURI,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddParticipant( 
            /* [in] */ __RPC__in BSTR bstrAddress,
            /* [in] */ __RPC__in BSTR bstrName,
            /* [retval][out] */ __RPC__deref_out_opt IRTCParticipant **ppParticipant) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveParticipant( 
            /* [in] */ __RPC__in_opt IRTCParticipant *pParticipant) = 0;
        
        virtual /* [helpstring][hidden] */ HRESULT STDMETHODCALLTYPE EnumerateParticipants( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumParticipants **ppEnum) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CanAddParticipants( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfCanAdd) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_RedirectedUserURI( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserURI) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_RedirectedUserName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NextRedirectedUser( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendMessage( 
            /* [in] */ __RPC__in BSTR bstrMessageHeader,
            /* [in] */ __RPC__in BSTR bstrMessage,
            /* [in] */ LONG_PTR lCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendMessageStatus( 
            /* [in] */ RTC_MESSAGING_USER_STATUS enUserStatus,
            /* [in] */ LONG_PTR lCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddStream( 
            /* [in] */ long lMediaType,
            /* [in] */ LONG_PTR lCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveStream( 
            /* [in] */ long lMediaType,
            /* [in] */ LONG_PTR lCookie) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_EncryptionKey( 
            /* [in] */ long lMediaType,
            /* [in] */ __RPC__in BSTR EncryptionKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCSession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCSession * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Client )( 
            __RPC__in IRTCSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCClient **ppClient);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            __RPC__in IRTCSession * This,
            /* [retval][out] */ __RPC__out RTC_SESSION_STATE *penState);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            __RPC__in IRTCSession * This,
            /* [retval][out] */ __RPC__out RTC_SESSION_TYPE *penType);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Profile )( 
            __RPC__in IRTCSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile **ppProfile);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Participants )( 
            __RPC__in IRTCSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppCollection);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Answer )( 
            __RPC__in IRTCSession * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            __RPC__in IRTCSession * This,
            /* [in] */ RTC_TERMINATE_REASON enReason);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Redirect )( 
            __RPC__in IRTCSession * This,
            /* [in] */ RTC_SESSION_TYPE enType,
            /* [in] */ __RPC__in BSTR bstrLocalPhoneURI,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddParticipant )( 
            __RPC__in IRTCSession * This,
            /* [in] */ __RPC__in BSTR bstrAddress,
            /* [in] */ __RPC__in BSTR bstrName,
            /* [retval][out] */ __RPC__deref_out_opt IRTCParticipant **ppParticipant);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveParticipant )( 
            __RPC__in IRTCSession * This,
            /* [in] */ __RPC__in_opt IRTCParticipant *pParticipant);
        
        /* [helpstring][hidden] */ HRESULT ( STDMETHODCALLTYPE *EnumerateParticipants )( 
            __RPC__in IRTCSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumParticipants **ppEnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanAddParticipants )( 
            __RPC__in IRTCSession * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfCanAdd);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RedirectedUserURI )( 
            __RPC__in IRTCSession * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserURI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RedirectedUserName )( 
            __RPC__in IRTCSession * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NextRedirectedUser )( 
            __RPC__in IRTCSession * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendMessage )( 
            __RPC__in IRTCSession * This,
            /* [in] */ __RPC__in BSTR bstrMessageHeader,
            /* [in] */ __RPC__in BSTR bstrMessage,
            /* [in] */ LONG_PTR lCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendMessageStatus )( 
            __RPC__in IRTCSession * This,
            /* [in] */ RTC_MESSAGING_USER_STATUS enUserStatus,
            /* [in] */ LONG_PTR lCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddStream )( 
            __RPC__in IRTCSession * This,
            /* [in] */ long lMediaType,
            /* [in] */ LONG_PTR lCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveStream )( 
            __RPC__in IRTCSession * This,
            /* [in] */ long lMediaType,
            /* [in] */ LONG_PTR lCookie);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EncryptionKey )( 
            __RPC__in IRTCSession * This,
            /* [in] */ long lMediaType,
            /* [in] */ __RPC__in BSTR EncryptionKey);
        
        END_INTERFACE
    } IRTCSessionVtbl;

    interface IRTCSession
    {
        CONST_VTBL struct IRTCSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCSession_get_Client(This,ppClient)	\
    ( (This)->lpVtbl -> get_Client(This,ppClient) ) 

#define IRTCSession_get_State(This,penState)	\
    ( (This)->lpVtbl -> get_State(This,penState) ) 

#define IRTCSession_get_Type(This,penType)	\
    ( (This)->lpVtbl -> get_Type(This,penType) ) 

#define IRTCSession_get_Profile(This,ppProfile)	\
    ( (This)->lpVtbl -> get_Profile(This,ppProfile) ) 

#define IRTCSession_get_Participants(This,ppCollection)	\
    ( (This)->lpVtbl -> get_Participants(This,ppCollection) ) 

#define IRTCSession_Answer(This)	\
    ( (This)->lpVtbl -> Answer(This) ) 

#define IRTCSession_Terminate(This,enReason)	\
    ( (This)->lpVtbl -> Terminate(This,enReason) ) 

#define IRTCSession_Redirect(This,enType,bstrLocalPhoneURI,pProfile,lFlags)	\
    ( (This)->lpVtbl -> Redirect(This,enType,bstrLocalPhoneURI,pProfile,lFlags) ) 

#define IRTCSession_AddParticipant(This,bstrAddress,bstrName,ppParticipant)	\
    ( (This)->lpVtbl -> AddParticipant(This,bstrAddress,bstrName,ppParticipant) ) 

#define IRTCSession_RemoveParticipant(This,pParticipant)	\
    ( (This)->lpVtbl -> RemoveParticipant(This,pParticipant) ) 

#define IRTCSession_EnumerateParticipants(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumerateParticipants(This,ppEnum) ) 

#define IRTCSession_get_CanAddParticipants(This,pfCanAdd)	\
    ( (This)->lpVtbl -> get_CanAddParticipants(This,pfCanAdd) ) 

#define IRTCSession_get_RedirectedUserURI(This,pbstrUserURI)	\
    ( (This)->lpVtbl -> get_RedirectedUserURI(This,pbstrUserURI) ) 

#define IRTCSession_get_RedirectedUserName(This,pbstrUserName)	\
    ( (This)->lpVtbl -> get_RedirectedUserName(This,pbstrUserName) ) 

#define IRTCSession_NextRedirectedUser(This)	\
    ( (This)->lpVtbl -> NextRedirectedUser(This) ) 

#define IRTCSession_SendMessage(This,bstrMessageHeader,bstrMessage,lCookie)	\
    ( (This)->lpVtbl -> SendMessage(This,bstrMessageHeader,bstrMessage,lCookie) ) 

#define IRTCSession_SendMessageStatus(This,enUserStatus,lCookie)	\
    ( (This)->lpVtbl -> SendMessageStatus(This,enUserStatus,lCookie) ) 

#define IRTCSession_AddStream(This,lMediaType,lCookie)	\
    ( (This)->lpVtbl -> AddStream(This,lMediaType,lCookie) ) 

#define IRTCSession_RemoveStream(This,lMediaType,lCookie)	\
    ( (This)->lpVtbl -> RemoveStream(This,lMediaType,lCookie) ) 

#define IRTCSession_put_EncryptionKey(This,lMediaType,EncryptionKey)	\
    ( (This)->lpVtbl -> put_EncryptionKey(This,lMediaType,EncryptionKey) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCSession_INTERFACE_DEFINED__ */


#ifndef __IRTCSession2_INTERFACE_DEFINED__
#define __IRTCSession2_INTERFACE_DEFINED__

/* interface IRTCSession2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCSession2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17D7CDFC-B007-484c-99D2-86A8A820991D")
    IRTCSession2 : public IRTCSession
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendInfo( 
            /* [in] */ __RPC__in BSTR bstrInfoHeader,
            /* [in] */ __RPC__in BSTR bstrInfo,
            /* [in] */ LONG_PTR lCookie) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_PreferredSecurityLevel( 
            /* [in] */ RTC_SECURITY_TYPE enSecurityType,
            /* [in] */ RTC_SECURITY_LEVEL enSecurityLevel) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PreferredSecurityLevel( 
            /* [in] */ RTC_SECURITY_TYPE enSecurityType,
            /* [retval][out] */ __RPC__out RTC_SECURITY_LEVEL *penSecurityLevel) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsSecurityEnabled( 
            /* [in] */ RTC_SECURITY_TYPE enSecurityType,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfSecurityEnabled) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AnswerWithSessionDescription( 
            /* [in] */ __RPC__in BSTR bstrContentType,
            /* [in] */ __RPC__in BSTR bstrSessionDescription) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReInviteWithSessionDescription( 
            /* [in] */ __RPC__in BSTR bstrContentType,
            /* [in] */ __RPC__in BSTR bstrSessionDescription,
            /* [in] */ LONG_PTR lCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCSession2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCSession2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCSession2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCSession2 * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Client )( 
            __RPC__in IRTCSession2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCClient **ppClient);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            __RPC__in IRTCSession2 * This,
            /* [retval][out] */ __RPC__out RTC_SESSION_STATE *penState);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            __RPC__in IRTCSession2 * This,
            /* [retval][out] */ __RPC__out RTC_SESSION_TYPE *penType);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Profile )( 
            __RPC__in IRTCSession2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile **ppProfile);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Participants )( 
            __RPC__in IRTCSession2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppCollection);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Answer )( 
            __RPC__in IRTCSession2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            __RPC__in IRTCSession2 * This,
            /* [in] */ RTC_TERMINATE_REASON enReason);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Redirect )( 
            __RPC__in IRTCSession2 * This,
            /* [in] */ RTC_SESSION_TYPE enType,
            /* [in] */ __RPC__in BSTR bstrLocalPhoneURI,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ long lFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddParticipant )( 
            __RPC__in IRTCSession2 * This,
            /* [in] */ __RPC__in BSTR bstrAddress,
            /* [in] */ __RPC__in BSTR bstrName,
            /* [retval][out] */ __RPC__deref_out_opt IRTCParticipant **ppParticipant);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveParticipant )( 
            __RPC__in IRTCSession2 * This,
            /* [in] */ __RPC__in_opt IRTCParticipant *pParticipant);
        
        /* [helpstring][hidden] */ HRESULT ( STDMETHODCALLTYPE *EnumerateParticipants )( 
            __RPC__in IRTCSession2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumParticipants **ppEnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanAddParticipants )( 
            __RPC__in IRTCSession2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfCanAdd);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RedirectedUserURI )( 
            __RPC__in IRTCSession2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserURI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RedirectedUserName )( 
            __RPC__in IRTCSession2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NextRedirectedUser )( 
            __RPC__in IRTCSession2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendMessage )( 
            __RPC__in IRTCSession2 * This,
            /* [in] */ __RPC__in BSTR bstrMessageHeader,
            /* [in] */ __RPC__in BSTR bstrMessage,
            /* [in] */ LONG_PTR lCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendMessageStatus )( 
            __RPC__in IRTCSession2 * This,
            /* [in] */ RTC_MESSAGING_USER_STATUS enUserStatus,
            /* [in] */ LONG_PTR lCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddStream )( 
            __RPC__in IRTCSession2 * This,
            /* [in] */ long lMediaType,
            /* [in] */ LONG_PTR lCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveStream )( 
            __RPC__in IRTCSession2 * This,
            /* [in] */ long lMediaType,
            /* [in] */ LONG_PTR lCookie);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EncryptionKey )( 
            __RPC__in IRTCSession2 * This,
            /* [in] */ long lMediaType,
            /* [in] */ __RPC__in BSTR EncryptionKey);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendInfo )( 
            __RPC__in IRTCSession2 * This,
            /* [in] */ __RPC__in BSTR bstrInfoHeader,
            /* [in] */ __RPC__in BSTR bstrInfo,
            /* [in] */ LONG_PTR lCookie);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PreferredSecurityLevel )( 
            __RPC__in IRTCSession2 * This,
            /* [in] */ RTC_SECURITY_TYPE enSecurityType,
            /* [in] */ RTC_SECURITY_LEVEL enSecurityLevel);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreferredSecurityLevel )( 
            __RPC__in IRTCSession2 * This,
            /* [in] */ RTC_SECURITY_TYPE enSecurityType,
            /* [retval][out] */ __RPC__out RTC_SECURITY_LEVEL *penSecurityLevel);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsSecurityEnabled )( 
            __RPC__in IRTCSession2 * This,
            /* [in] */ RTC_SECURITY_TYPE enSecurityType,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfSecurityEnabled);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AnswerWithSessionDescription )( 
            __RPC__in IRTCSession2 * This,
            /* [in] */ __RPC__in BSTR bstrContentType,
            /* [in] */ __RPC__in BSTR bstrSessionDescription);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReInviteWithSessionDescription )( 
            __RPC__in IRTCSession2 * This,
            /* [in] */ __RPC__in BSTR bstrContentType,
            /* [in] */ __RPC__in BSTR bstrSessionDescription,
            /* [in] */ LONG_PTR lCookie);
        
        END_INTERFACE
    } IRTCSession2Vtbl;

    interface IRTCSession2
    {
        CONST_VTBL struct IRTCSession2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCSession2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCSession2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCSession2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCSession2_get_Client(This,ppClient)	\
    ( (This)->lpVtbl -> get_Client(This,ppClient) ) 

#define IRTCSession2_get_State(This,penState)	\
    ( (This)->lpVtbl -> get_State(This,penState) ) 

#define IRTCSession2_get_Type(This,penType)	\
    ( (This)->lpVtbl -> get_Type(This,penType) ) 

#define IRTCSession2_get_Profile(This,ppProfile)	\
    ( (This)->lpVtbl -> get_Profile(This,ppProfile) ) 

#define IRTCSession2_get_Participants(This,ppCollection)	\
    ( (This)->lpVtbl -> get_Participants(This,ppCollection) ) 

#define IRTCSession2_Answer(This)	\
    ( (This)->lpVtbl -> Answer(This) ) 

#define IRTCSession2_Terminate(This,enReason)	\
    ( (This)->lpVtbl -> Terminate(This,enReason) ) 

#define IRTCSession2_Redirect(This,enType,bstrLocalPhoneURI,pProfile,lFlags)	\
    ( (This)->lpVtbl -> Redirect(This,enType,bstrLocalPhoneURI,pProfile,lFlags) ) 

#define IRTCSession2_AddParticipant(This,bstrAddress,bstrName,ppParticipant)	\
    ( (This)->lpVtbl -> AddParticipant(This,bstrAddress,bstrName,ppParticipant) ) 

#define IRTCSession2_RemoveParticipant(This,pParticipant)	\
    ( (This)->lpVtbl -> RemoveParticipant(This,pParticipant) ) 

#define IRTCSession2_EnumerateParticipants(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumerateParticipants(This,ppEnum) ) 

#define IRTCSession2_get_CanAddParticipants(This,pfCanAdd)	\
    ( (This)->lpVtbl -> get_CanAddParticipants(This,pfCanAdd) ) 

#define IRTCSession2_get_RedirectedUserURI(This,pbstrUserURI)	\
    ( (This)->lpVtbl -> get_RedirectedUserURI(This,pbstrUserURI) ) 

#define IRTCSession2_get_RedirectedUserName(This,pbstrUserName)	\
    ( (This)->lpVtbl -> get_RedirectedUserName(This,pbstrUserName) ) 

#define IRTCSession2_NextRedirectedUser(This)	\
    ( (This)->lpVtbl -> NextRedirectedUser(This) ) 

#define IRTCSession2_SendMessage(This,bstrMessageHeader,bstrMessage,lCookie)	\
    ( (This)->lpVtbl -> SendMessage(This,bstrMessageHeader,bstrMessage,lCookie) ) 

#define IRTCSession2_SendMessageStatus(This,enUserStatus,lCookie)	\
    ( (This)->lpVtbl -> SendMessageStatus(This,enUserStatus,lCookie) ) 

#define IRTCSession2_AddStream(This,lMediaType,lCookie)	\
    ( (This)->lpVtbl -> AddStream(This,lMediaType,lCookie) ) 

#define IRTCSession2_RemoveStream(This,lMediaType,lCookie)	\
    ( (This)->lpVtbl -> RemoveStream(This,lMediaType,lCookie) ) 

#define IRTCSession2_put_EncryptionKey(This,lMediaType,EncryptionKey)	\
    ( (This)->lpVtbl -> put_EncryptionKey(This,lMediaType,EncryptionKey) ) 


#define IRTCSession2_SendInfo(This,bstrInfoHeader,bstrInfo,lCookie)	\
    ( (This)->lpVtbl -> SendInfo(This,bstrInfoHeader,bstrInfo,lCookie) ) 

#define IRTCSession2_put_PreferredSecurityLevel(This,enSecurityType,enSecurityLevel)	\
    ( (This)->lpVtbl -> put_PreferredSecurityLevel(This,enSecurityType,enSecurityLevel) ) 

#define IRTCSession2_get_PreferredSecurityLevel(This,enSecurityType,penSecurityLevel)	\
    ( (This)->lpVtbl -> get_PreferredSecurityLevel(This,enSecurityType,penSecurityLevel) ) 

#define IRTCSession2_IsSecurityEnabled(This,enSecurityType,pfSecurityEnabled)	\
    ( (This)->lpVtbl -> IsSecurityEnabled(This,enSecurityType,pfSecurityEnabled) ) 

#define IRTCSession2_AnswerWithSessionDescription(This,bstrContentType,bstrSessionDescription)	\
    ( (This)->lpVtbl -> AnswerWithSessionDescription(This,bstrContentType,bstrSessionDescription) ) 

#define IRTCSession2_ReInviteWithSessionDescription(This,bstrContentType,bstrSessionDescription,lCookie)	\
    ( (This)->lpVtbl -> ReInviteWithSessionDescription(This,bstrContentType,bstrSessionDescription,lCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCSession2_INTERFACE_DEFINED__ */


#ifndef __IRTCSessionCallControl_INTERFACE_DEFINED__
#define __IRTCSessionCallControl_INTERFACE_DEFINED__

/* interface IRTCSessionCallControl */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCSessionCallControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E9A50D94-190B-4F82-9530-3B8EBF60758A")
    IRTCSessionCallControl : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Hold( 
            /* [in] */ LONG_PTR lCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnHold( 
            /* [in] */ LONG_PTR lCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Forward( 
            /* [in] */ __RPC__in BSTR bstrForwardToURI) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Refer( 
            /* [in] */ __RPC__in BSTR bstrReferToURI,
            /* [in] */ __RPC__in BSTR bstrReferCookie) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ReferredByURI( 
            /* [in] */ __RPC__in BSTR bstrReferredByURI) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ReferredByURI( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrReferredByURI) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ReferCookie( 
            /* [in] */ __RPC__in BSTR bstrReferCookie) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ReferCookie( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrReferCookie) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_IsReferred( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfIsReferred) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCSessionCallControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCSessionCallControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCSessionCallControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCSessionCallControl * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Hold )( 
            __RPC__in IRTCSessionCallControl * This,
            /* [in] */ LONG_PTR lCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnHold )( 
            __RPC__in IRTCSessionCallControl * This,
            /* [in] */ LONG_PTR lCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Forward )( 
            __RPC__in IRTCSessionCallControl * This,
            /* [in] */ __RPC__in BSTR bstrForwardToURI);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Refer )( 
            __RPC__in IRTCSessionCallControl * This,
            /* [in] */ __RPC__in BSTR bstrReferToURI,
            /* [in] */ __RPC__in BSTR bstrReferCookie);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReferredByURI )( 
            __RPC__in IRTCSessionCallControl * This,
            /* [in] */ __RPC__in BSTR bstrReferredByURI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReferredByURI )( 
            __RPC__in IRTCSessionCallControl * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrReferredByURI);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReferCookie )( 
            __RPC__in IRTCSessionCallControl * This,
            /* [in] */ __RPC__in BSTR bstrReferCookie);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReferCookie )( 
            __RPC__in IRTCSessionCallControl * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrReferCookie);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsReferred )( 
            __RPC__in IRTCSessionCallControl * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfIsReferred);
        
        END_INTERFACE
    } IRTCSessionCallControlVtbl;

    interface IRTCSessionCallControl
    {
        CONST_VTBL struct IRTCSessionCallControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCSessionCallControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCSessionCallControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCSessionCallControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCSessionCallControl_Hold(This,lCookie)	\
    ( (This)->lpVtbl -> Hold(This,lCookie) ) 

#define IRTCSessionCallControl_UnHold(This,lCookie)	\
    ( (This)->lpVtbl -> UnHold(This,lCookie) ) 

#define IRTCSessionCallControl_Forward(This,bstrForwardToURI)	\
    ( (This)->lpVtbl -> Forward(This,bstrForwardToURI) ) 

#define IRTCSessionCallControl_Refer(This,bstrReferToURI,bstrReferCookie)	\
    ( (This)->lpVtbl -> Refer(This,bstrReferToURI,bstrReferCookie) ) 

#define IRTCSessionCallControl_put_ReferredByURI(This,bstrReferredByURI)	\
    ( (This)->lpVtbl -> put_ReferredByURI(This,bstrReferredByURI) ) 

#define IRTCSessionCallControl_get_ReferredByURI(This,pbstrReferredByURI)	\
    ( (This)->lpVtbl -> get_ReferredByURI(This,pbstrReferredByURI) ) 

#define IRTCSessionCallControl_put_ReferCookie(This,bstrReferCookie)	\
    ( (This)->lpVtbl -> put_ReferCookie(This,bstrReferCookie) ) 

#define IRTCSessionCallControl_get_ReferCookie(This,pbstrReferCookie)	\
    ( (This)->lpVtbl -> get_ReferCookie(This,pbstrReferCookie) ) 

#define IRTCSessionCallControl_get_IsReferred(This,pfIsReferred)	\
    ( (This)->lpVtbl -> get_IsReferred(This,pfIsReferred) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCSessionCallControl_INTERFACE_DEFINED__ */


#ifndef __IRTCParticipant_INTERFACE_DEFINED__
#define __IRTCParticipant_INTERFACE_DEFINED__

/* interface IRTCParticipant */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCParticipant;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ae86add5-26b1-4414-af1d-b94cd938d739")
    IRTCParticipant : public IUnknown
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_UserURI( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserURI) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Removable( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfRemovable) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out RTC_PARTICIPANT_STATE *penState) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession **ppSession) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCParticipantVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCParticipant * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCParticipant * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCParticipant * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserURI )( 
            __RPC__in IRTCParticipant * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUserURI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IRTCParticipant * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Removable )( 
            __RPC__in IRTCParticipant * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfRemovable);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            __RPC__in IRTCParticipant * This,
            /* [retval][out] */ __RPC__out RTC_PARTICIPANT_STATE *penState);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Session )( 
            __RPC__in IRTCParticipant * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession **ppSession);
        
        END_INTERFACE
    } IRTCParticipantVtbl;

    interface IRTCParticipant
    {
        CONST_VTBL struct IRTCParticipantVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCParticipant_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCParticipant_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCParticipant_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCParticipant_get_UserURI(This,pbstrUserURI)	\
    ( (This)->lpVtbl -> get_UserURI(This,pbstrUserURI) ) 

#define IRTCParticipant_get_Name(This,pbstrName)	\
    ( (This)->lpVtbl -> get_Name(This,pbstrName) ) 

#define IRTCParticipant_get_Removable(This,pfRemovable)	\
    ( (This)->lpVtbl -> get_Removable(This,pfRemovable) ) 

#define IRTCParticipant_get_State(This,penState)	\
    ( (This)->lpVtbl -> get_State(This,penState) ) 

#define IRTCParticipant_get_Session(This,ppSession)	\
    ( (This)->lpVtbl -> get_Session(This,ppSession) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCParticipant_INTERFACE_DEFINED__ */


#ifndef __IRTCRoamingEvent_INTERFACE_DEFINED__
#define __IRTCRoamingEvent_INTERFACE_DEFINED__

/* interface IRTCRoamingEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCRoamingEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79960a6b-0cb1-4dc8-a805-7318e99902e8")
    IRTCRoamingEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventType( 
            /* [retval][out] */ __RPC__out RTC_ROAMING_EVENT_TYPE *pEventType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Profile( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile2 **ppProfile) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusCode( 
            /* [retval][out] */ __RPC__out long *plStatusCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusText( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatusText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCRoamingEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCRoamingEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCRoamingEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCRoamingEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCRoamingEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCRoamingEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCRoamingEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCRoamingEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventType )( 
            __RPC__in IRTCRoamingEvent * This,
            /* [retval][out] */ __RPC__out RTC_ROAMING_EVENT_TYPE *pEventType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Profile )( 
            __RPC__in IRTCRoamingEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile2 **ppProfile);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusCode )( 
            __RPC__in IRTCRoamingEvent * This,
            /* [retval][out] */ __RPC__out long *plStatusCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusText )( 
            __RPC__in IRTCRoamingEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatusText);
        
        END_INTERFACE
    } IRTCRoamingEventVtbl;

    interface IRTCRoamingEvent
    {
        CONST_VTBL struct IRTCRoamingEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCRoamingEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCRoamingEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCRoamingEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCRoamingEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCRoamingEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCRoamingEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCRoamingEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCRoamingEvent_get_EventType(This,pEventType)	\
    ( (This)->lpVtbl -> get_EventType(This,pEventType) ) 

#define IRTCRoamingEvent_get_Profile(This,ppProfile)	\
    ( (This)->lpVtbl -> get_Profile(This,ppProfile) ) 

#define IRTCRoamingEvent_get_StatusCode(This,plStatusCode)	\
    ( (This)->lpVtbl -> get_StatusCode(This,plStatusCode) ) 

#define IRTCRoamingEvent_get_StatusText(This,pbstrStatusText)	\
    ( (This)->lpVtbl -> get_StatusText(This,pbstrStatusText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCRoamingEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCProfileEvent_INTERFACE_DEFINED__
#define __IRTCProfileEvent_INTERFACE_DEFINED__

/* interface IRTCProfileEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCProfileEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D6D5AB3B-770E-43e8-800A-79B062395FCA")
    IRTCProfileEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Profile( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile **ppProfile) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Cookie( 
            /* [retval][out] */ __RPC__out LONG_PTR *plCookie) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusCode( 
            /* [retval][out] */ __RPC__out long *plStatusCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCProfileEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCProfileEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCProfileEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCProfileEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCProfileEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCProfileEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCProfileEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCProfileEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Profile )( 
            __RPC__in IRTCProfileEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile **ppProfile);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Cookie )( 
            __RPC__in IRTCProfileEvent * This,
            /* [retval][out] */ __RPC__out LONG_PTR *plCookie);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusCode )( 
            __RPC__in IRTCProfileEvent * This,
            /* [retval][out] */ __RPC__out long *plStatusCode);
        
        END_INTERFACE
    } IRTCProfileEventVtbl;

    interface IRTCProfileEvent
    {
        CONST_VTBL struct IRTCProfileEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCProfileEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCProfileEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCProfileEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCProfileEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCProfileEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCProfileEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCProfileEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCProfileEvent_get_Profile(This,ppProfile)	\
    ( (This)->lpVtbl -> get_Profile(This,ppProfile) ) 

#define IRTCProfileEvent_get_Cookie(This,plCookie)	\
    ( (This)->lpVtbl -> get_Cookie(This,plCookie) ) 

#define IRTCProfileEvent_get_StatusCode(This,plStatusCode)	\
    ( (This)->lpVtbl -> get_StatusCode(This,plStatusCode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCProfileEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCProfileEvent2_INTERFACE_DEFINED__
#define __IRTCProfileEvent2_INTERFACE_DEFINED__

/* interface IRTCProfileEvent2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCProfileEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("62E56EDC-03FA-4121-94FB-23493FD0AE64")
    IRTCProfileEvent2 : public IRTCProfileEvent
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventType( 
            /* [retval][out] */ __RPC__out RTC_PROFILE_EVENT_TYPE *pEventType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCProfileEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCProfileEvent2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCProfileEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCProfileEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCProfileEvent2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCProfileEvent2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCProfileEvent2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCProfileEvent2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Profile )( 
            __RPC__in IRTCProfileEvent2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile **ppProfile);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Cookie )( 
            __RPC__in IRTCProfileEvent2 * This,
            /* [retval][out] */ __RPC__out LONG_PTR *plCookie);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusCode )( 
            __RPC__in IRTCProfileEvent2 * This,
            /* [retval][out] */ __RPC__out long *plStatusCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventType )( 
            __RPC__in IRTCProfileEvent2 * This,
            /* [retval][out] */ __RPC__out RTC_PROFILE_EVENT_TYPE *pEventType);
        
        END_INTERFACE
    } IRTCProfileEvent2Vtbl;

    interface IRTCProfileEvent2
    {
        CONST_VTBL struct IRTCProfileEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCProfileEvent2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCProfileEvent2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCProfileEvent2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCProfileEvent2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCProfileEvent2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCProfileEvent2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCProfileEvent2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCProfileEvent2_get_Profile(This,ppProfile)	\
    ( (This)->lpVtbl -> get_Profile(This,ppProfile) ) 

#define IRTCProfileEvent2_get_Cookie(This,plCookie)	\
    ( (This)->lpVtbl -> get_Cookie(This,plCookie) ) 

#define IRTCProfileEvent2_get_StatusCode(This,plStatusCode)	\
    ( (This)->lpVtbl -> get_StatusCode(This,plStatusCode) ) 


#define IRTCProfileEvent2_get_EventType(This,pEventType)	\
    ( (This)->lpVtbl -> get_EventType(This,pEventType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCProfileEvent2_INTERFACE_DEFINED__ */


#ifndef __IRTCClientEvent_INTERFACE_DEFINED__
#define __IRTCClientEvent_INTERFACE_DEFINED__

/* interface IRTCClientEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCClientEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2b493b7a-3cba-4170-9c8b-76a9dacdd644")
    IRTCClientEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventType( 
            /* [retval][out] */ __RPC__out RTC_CLIENT_EVENT_TYPE *penEventType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Client( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCClient **ppClient) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCClientEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCClientEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCClientEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCClientEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCClientEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCClientEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCClientEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCClientEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventType )( 
            __RPC__in IRTCClientEvent * This,
            /* [retval][out] */ __RPC__out RTC_CLIENT_EVENT_TYPE *penEventType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Client )( 
            __RPC__in IRTCClientEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCClient **ppClient);
        
        END_INTERFACE
    } IRTCClientEventVtbl;

    interface IRTCClientEvent
    {
        CONST_VTBL struct IRTCClientEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCClientEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCClientEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCClientEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCClientEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCClientEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCClientEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCClientEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCClientEvent_get_EventType(This,penEventType)	\
    ( (This)->lpVtbl -> get_EventType(This,penEventType) ) 

#define IRTCClientEvent_get_Client(This,ppClient)	\
    ( (This)->lpVtbl -> get_Client(This,ppClient) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCClientEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCRegistrationStateChangeEvent_INTERFACE_DEFINED__
#define __IRTCRegistrationStateChangeEvent_INTERFACE_DEFINED__

/* interface IRTCRegistrationStateChangeEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCRegistrationStateChangeEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("62d0991b-50ab-4f02-b948-ca94f26f8f95")
    IRTCRegistrationStateChangeEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Profile( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile **ppProfile) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out RTC_REGISTRATION_STATE *penState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusCode( 
            /* [retval][out] */ __RPC__out long *plStatusCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusText( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatusText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCRegistrationStateChangeEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCRegistrationStateChangeEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCRegistrationStateChangeEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCRegistrationStateChangeEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCRegistrationStateChangeEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCRegistrationStateChangeEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCRegistrationStateChangeEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCRegistrationStateChangeEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Profile )( 
            __RPC__in IRTCRegistrationStateChangeEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile **ppProfile);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            __RPC__in IRTCRegistrationStateChangeEvent * This,
            /* [retval][out] */ __RPC__out RTC_REGISTRATION_STATE *penState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusCode )( 
            __RPC__in IRTCRegistrationStateChangeEvent * This,
            /* [retval][out] */ __RPC__out long *plStatusCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusText )( 
            __RPC__in IRTCRegistrationStateChangeEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatusText);
        
        END_INTERFACE
    } IRTCRegistrationStateChangeEventVtbl;

    interface IRTCRegistrationStateChangeEvent
    {
        CONST_VTBL struct IRTCRegistrationStateChangeEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCRegistrationStateChangeEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCRegistrationStateChangeEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCRegistrationStateChangeEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCRegistrationStateChangeEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCRegistrationStateChangeEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCRegistrationStateChangeEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCRegistrationStateChangeEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCRegistrationStateChangeEvent_get_Profile(This,ppProfile)	\
    ( (This)->lpVtbl -> get_Profile(This,ppProfile) ) 

#define IRTCRegistrationStateChangeEvent_get_State(This,penState)	\
    ( (This)->lpVtbl -> get_State(This,penState) ) 

#define IRTCRegistrationStateChangeEvent_get_StatusCode(This,plStatusCode)	\
    ( (This)->lpVtbl -> get_StatusCode(This,plStatusCode) ) 

#define IRTCRegistrationStateChangeEvent_get_StatusText(This,pbstrStatusText)	\
    ( (This)->lpVtbl -> get_StatusText(This,pbstrStatusText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCRegistrationStateChangeEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCSessionStateChangeEvent_INTERFACE_DEFINED__
#define __IRTCSessionStateChangeEvent_INTERFACE_DEFINED__

/* interface IRTCSessionStateChangeEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCSessionStateChangeEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b5bad703-5952-48b3-9321-7f4500521506")
    IRTCSessionStateChangeEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession **ppSession) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out RTC_SESSION_STATE *penState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusCode( 
            /* [retval][out] */ __RPC__out long *plStatusCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusText( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatusText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCSessionStateChangeEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCSessionStateChangeEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCSessionStateChangeEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCSessionStateChangeEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCSessionStateChangeEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCSessionStateChangeEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCSessionStateChangeEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCSessionStateChangeEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Session )( 
            __RPC__in IRTCSessionStateChangeEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession **ppSession);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            __RPC__in IRTCSessionStateChangeEvent * This,
            /* [retval][out] */ __RPC__out RTC_SESSION_STATE *penState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusCode )( 
            __RPC__in IRTCSessionStateChangeEvent * This,
            /* [retval][out] */ __RPC__out long *plStatusCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusText )( 
            __RPC__in IRTCSessionStateChangeEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatusText);
        
        END_INTERFACE
    } IRTCSessionStateChangeEventVtbl;

    interface IRTCSessionStateChangeEvent
    {
        CONST_VTBL struct IRTCSessionStateChangeEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCSessionStateChangeEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCSessionStateChangeEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCSessionStateChangeEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCSessionStateChangeEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCSessionStateChangeEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCSessionStateChangeEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCSessionStateChangeEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCSessionStateChangeEvent_get_Session(This,ppSession)	\
    ( (This)->lpVtbl -> get_Session(This,ppSession) ) 

#define IRTCSessionStateChangeEvent_get_State(This,penState)	\
    ( (This)->lpVtbl -> get_State(This,penState) ) 

#define IRTCSessionStateChangeEvent_get_StatusCode(This,plStatusCode)	\
    ( (This)->lpVtbl -> get_StatusCode(This,plStatusCode) ) 

#define IRTCSessionStateChangeEvent_get_StatusText(This,pbstrStatusText)	\
    ( (This)->lpVtbl -> get_StatusText(This,pbstrStatusText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCSessionStateChangeEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCSessionStateChangeEvent2_INTERFACE_DEFINED__
#define __IRTCSessionStateChangeEvent2_INTERFACE_DEFINED__

/* interface IRTCSessionStateChangeEvent2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCSessionStateChangeEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F933171-6F95-4880-80D9-2EC8D495D261")
    IRTCSessionStateChangeEvent2 : public IRTCSessionStateChangeEvent
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaTypes( 
            /* [retval][out] */ __RPC__out long *pMediaTypes) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RemotePreferredSecurityLevel( 
            /* [in] */ RTC_SECURITY_TYPE enSecurityType,
            /* [retval][out] */ __RPC__out RTC_SECURITY_LEVEL *penSecurityLevel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsForked( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfIsForked) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetRemoteSessionDescription( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrContentType,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSessionDescription) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCSessionStateChangeEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCSessionStateChangeEvent2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCSessionStateChangeEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCSessionStateChangeEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCSessionStateChangeEvent2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCSessionStateChangeEvent2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCSessionStateChangeEvent2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCSessionStateChangeEvent2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Session )( 
            __RPC__in IRTCSessionStateChangeEvent2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession **ppSession);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            __RPC__in IRTCSessionStateChangeEvent2 * This,
            /* [retval][out] */ __RPC__out RTC_SESSION_STATE *penState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusCode )( 
            __RPC__in IRTCSessionStateChangeEvent2 * This,
            /* [retval][out] */ __RPC__out long *plStatusCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusText )( 
            __RPC__in IRTCSessionStateChangeEvent2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatusText);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaTypes )( 
            __RPC__in IRTCSessionStateChangeEvent2 * This,
            /* [retval][out] */ __RPC__out long *pMediaTypes);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RemotePreferredSecurityLevel )( 
            __RPC__in IRTCSessionStateChangeEvent2 * This,
            /* [in] */ RTC_SECURITY_TYPE enSecurityType,
            /* [retval][out] */ __RPC__out RTC_SECURITY_LEVEL *penSecurityLevel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsForked )( 
            __RPC__in IRTCSessionStateChangeEvent2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfIsForked);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetRemoteSessionDescription )( 
            __RPC__in IRTCSessionStateChangeEvent2 * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrContentType,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSessionDescription);
        
        END_INTERFACE
    } IRTCSessionStateChangeEvent2Vtbl;

    interface IRTCSessionStateChangeEvent2
    {
        CONST_VTBL struct IRTCSessionStateChangeEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCSessionStateChangeEvent2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCSessionStateChangeEvent2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCSessionStateChangeEvent2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCSessionStateChangeEvent2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCSessionStateChangeEvent2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCSessionStateChangeEvent2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCSessionStateChangeEvent2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCSessionStateChangeEvent2_get_Session(This,ppSession)	\
    ( (This)->lpVtbl -> get_Session(This,ppSession) ) 

#define IRTCSessionStateChangeEvent2_get_State(This,penState)	\
    ( (This)->lpVtbl -> get_State(This,penState) ) 

#define IRTCSessionStateChangeEvent2_get_StatusCode(This,plStatusCode)	\
    ( (This)->lpVtbl -> get_StatusCode(This,plStatusCode) ) 

#define IRTCSessionStateChangeEvent2_get_StatusText(This,pbstrStatusText)	\
    ( (This)->lpVtbl -> get_StatusText(This,pbstrStatusText) ) 


#define IRTCSessionStateChangeEvent2_get_MediaTypes(This,pMediaTypes)	\
    ( (This)->lpVtbl -> get_MediaTypes(This,pMediaTypes) ) 

#define IRTCSessionStateChangeEvent2_get_RemotePreferredSecurityLevel(This,enSecurityType,penSecurityLevel)	\
    ( (This)->lpVtbl -> get_RemotePreferredSecurityLevel(This,enSecurityType,penSecurityLevel) ) 

#define IRTCSessionStateChangeEvent2_get_IsForked(This,pfIsForked)	\
    ( (This)->lpVtbl -> get_IsForked(This,pfIsForked) ) 

#define IRTCSessionStateChangeEvent2_GetRemoteSessionDescription(This,pbstrContentType,pbstrSessionDescription)	\
    ( (This)->lpVtbl -> GetRemoteSessionDescription(This,pbstrContentType,pbstrSessionDescription) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCSessionStateChangeEvent2_INTERFACE_DEFINED__ */


#ifndef __IRTCSessionOperationCompleteEvent_INTERFACE_DEFINED__
#define __IRTCSessionOperationCompleteEvent_INTERFACE_DEFINED__

/* interface IRTCSessionOperationCompleteEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCSessionOperationCompleteEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a6bff4c0-f7c8-4d3c-9a41-3550f78a95b0")
    IRTCSessionOperationCompleteEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession **ppSession) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Cookie( 
            /* [retval][out] */ __RPC__out LONG_PTR *plCookie) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusCode( 
            /* [retval][out] */ __RPC__out long *plStatusCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusText( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatusText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCSessionOperationCompleteEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCSessionOperationCompleteEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCSessionOperationCompleteEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCSessionOperationCompleteEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCSessionOperationCompleteEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCSessionOperationCompleteEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCSessionOperationCompleteEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCSessionOperationCompleteEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Session )( 
            __RPC__in IRTCSessionOperationCompleteEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession **ppSession);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Cookie )( 
            __RPC__in IRTCSessionOperationCompleteEvent * This,
            /* [retval][out] */ __RPC__out LONG_PTR *plCookie);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusCode )( 
            __RPC__in IRTCSessionOperationCompleteEvent * This,
            /* [retval][out] */ __RPC__out long *plStatusCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusText )( 
            __RPC__in IRTCSessionOperationCompleteEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatusText);
        
        END_INTERFACE
    } IRTCSessionOperationCompleteEventVtbl;

    interface IRTCSessionOperationCompleteEvent
    {
        CONST_VTBL struct IRTCSessionOperationCompleteEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCSessionOperationCompleteEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCSessionOperationCompleteEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCSessionOperationCompleteEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCSessionOperationCompleteEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCSessionOperationCompleteEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCSessionOperationCompleteEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCSessionOperationCompleteEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCSessionOperationCompleteEvent_get_Session(This,ppSession)	\
    ( (This)->lpVtbl -> get_Session(This,ppSession) ) 

#define IRTCSessionOperationCompleteEvent_get_Cookie(This,plCookie)	\
    ( (This)->lpVtbl -> get_Cookie(This,plCookie) ) 

#define IRTCSessionOperationCompleteEvent_get_StatusCode(This,plStatusCode)	\
    ( (This)->lpVtbl -> get_StatusCode(This,plStatusCode) ) 

#define IRTCSessionOperationCompleteEvent_get_StatusText(This,pbstrStatusText)	\
    ( (This)->lpVtbl -> get_StatusText(This,pbstrStatusText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCSessionOperationCompleteEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCSessionOperationCompleteEvent2_INTERFACE_DEFINED__
#define __IRTCSessionOperationCompleteEvent2_INTERFACE_DEFINED__

/* interface IRTCSessionOperationCompleteEvent2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCSessionOperationCompleteEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f6fc2a9b-d5bc-4241-b436-1b8460c13832")
    IRTCSessionOperationCompleteEvent2 : public IRTCSessionOperationCompleteEvent
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Participant( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCParticipant **ppParticipant) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetRemoteSessionDescription( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrContentType,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSessionDescription) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCSessionOperationCompleteEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCSessionOperationCompleteEvent2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCSessionOperationCompleteEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCSessionOperationCompleteEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCSessionOperationCompleteEvent2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCSessionOperationCompleteEvent2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCSessionOperationCompleteEvent2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCSessionOperationCompleteEvent2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Session )( 
            __RPC__in IRTCSessionOperationCompleteEvent2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession **ppSession);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Cookie )( 
            __RPC__in IRTCSessionOperationCompleteEvent2 * This,
            /* [retval][out] */ __RPC__out LONG_PTR *plCookie);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusCode )( 
            __RPC__in IRTCSessionOperationCompleteEvent2 * This,
            /* [retval][out] */ __RPC__out long *plStatusCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusText )( 
            __RPC__in IRTCSessionOperationCompleteEvent2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatusText);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Participant )( 
            __RPC__in IRTCSessionOperationCompleteEvent2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCParticipant **ppParticipant);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetRemoteSessionDescription )( 
            __RPC__in IRTCSessionOperationCompleteEvent2 * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrContentType,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSessionDescription);
        
        END_INTERFACE
    } IRTCSessionOperationCompleteEvent2Vtbl;

    interface IRTCSessionOperationCompleteEvent2
    {
        CONST_VTBL struct IRTCSessionOperationCompleteEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCSessionOperationCompleteEvent2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCSessionOperationCompleteEvent2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCSessionOperationCompleteEvent2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCSessionOperationCompleteEvent2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCSessionOperationCompleteEvent2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCSessionOperationCompleteEvent2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCSessionOperationCompleteEvent2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCSessionOperationCompleteEvent2_get_Session(This,ppSession)	\
    ( (This)->lpVtbl -> get_Session(This,ppSession) ) 

#define IRTCSessionOperationCompleteEvent2_get_Cookie(This,plCookie)	\
    ( (This)->lpVtbl -> get_Cookie(This,plCookie) ) 

#define IRTCSessionOperationCompleteEvent2_get_StatusCode(This,plStatusCode)	\
    ( (This)->lpVtbl -> get_StatusCode(This,plStatusCode) ) 

#define IRTCSessionOperationCompleteEvent2_get_StatusText(This,pbstrStatusText)	\
    ( (This)->lpVtbl -> get_StatusText(This,pbstrStatusText) ) 


#define IRTCSessionOperationCompleteEvent2_get_Participant(This,ppParticipant)	\
    ( (This)->lpVtbl -> get_Participant(This,ppParticipant) ) 

#define IRTCSessionOperationCompleteEvent2_GetRemoteSessionDescription(This,pbstrContentType,pbstrSessionDescription)	\
    ( (This)->lpVtbl -> GetRemoteSessionDescription(This,pbstrContentType,pbstrSessionDescription) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCSessionOperationCompleteEvent2_INTERFACE_DEFINED__ */


#ifndef __IRTCParticipantStateChangeEvent_INTERFACE_DEFINED__
#define __IRTCParticipantStateChangeEvent_INTERFACE_DEFINED__

/* interface IRTCParticipantStateChangeEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCParticipantStateChangeEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09bcb597-f0fa-48f9-b420-468cea7fde04")
    IRTCParticipantStateChangeEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Participant( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCParticipant **ppParticipant) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out RTC_PARTICIPANT_STATE *penState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusCode( 
            /* [retval][out] */ __RPC__out long *plStatusCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCParticipantStateChangeEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCParticipantStateChangeEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCParticipantStateChangeEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCParticipantStateChangeEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCParticipantStateChangeEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCParticipantStateChangeEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCParticipantStateChangeEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCParticipantStateChangeEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Participant )( 
            __RPC__in IRTCParticipantStateChangeEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCParticipant **ppParticipant);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            __RPC__in IRTCParticipantStateChangeEvent * This,
            /* [retval][out] */ __RPC__out RTC_PARTICIPANT_STATE *penState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusCode )( 
            __RPC__in IRTCParticipantStateChangeEvent * This,
            /* [retval][out] */ __RPC__out long *plStatusCode);
        
        END_INTERFACE
    } IRTCParticipantStateChangeEventVtbl;

    interface IRTCParticipantStateChangeEvent
    {
        CONST_VTBL struct IRTCParticipantStateChangeEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCParticipantStateChangeEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCParticipantStateChangeEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCParticipantStateChangeEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCParticipantStateChangeEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCParticipantStateChangeEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCParticipantStateChangeEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCParticipantStateChangeEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCParticipantStateChangeEvent_get_Participant(This,ppParticipant)	\
    ( (This)->lpVtbl -> get_Participant(This,ppParticipant) ) 

#define IRTCParticipantStateChangeEvent_get_State(This,penState)	\
    ( (This)->lpVtbl -> get_State(This,penState) ) 

#define IRTCParticipantStateChangeEvent_get_StatusCode(This,plStatusCode)	\
    ( (This)->lpVtbl -> get_StatusCode(This,plStatusCode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCParticipantStateChangeEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCMediaEvent_INTERFACE_DEFINED__
#define __IRTCMediaEvent_INTERFACE_DEFINED__

/* interface IRTCMediaEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCMediaEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("099944fb-bcda-453e-8c41-e13da2adf7f3")
    IRTCMediaEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaType( 
            /* [retval][out] */ __RPC__out long *pMediaType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventType( 
            /* [retval][out] */ __RPC__out RTC_MEDIA_EVENT_TYPE *penEventType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventReason( 
            /* [retval][out] */ __RPC__out RTC_MEDIA_EVENT_REASON *penEventReason) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCMediaEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCMediaEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCMediaEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCMediaEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCMediaEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCMediaEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCMediaEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCMediaEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaType )( 
            __RPC__in IRTCMediaEvent * This,
            /* [retval][out] */ __RPC__out long *pMediaType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventType )( 
            __RPC__in IRTCMediaEvent * This,
            /* [retval][out] */ __RPC__out RTC_MEDIA_EVENT_TYPE *penEventType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventReason )( 
            __RPC__in IRTCMediaEvent * This,
            /* [retval][out] */ __RPC__out RTC_MEDIA_EVENT_REASON *penEventReason);
        
        END_INTERFACE
    } IRTCMediaEventVtbl;

    interface IRTCMediaEvent
    {
        CONST_VTBL struct IRTCMediaEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCMediaEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCMediaEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCMediaEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCMediaEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCMediaEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCMediaEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCMediaEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCMediaEvent_get_MediaType(This,pMediaType)	\
    ( (This)->lpVtbl -> get_MediaType(This,pMediaType) ) 

#define IRTCMediaEvent_get_EventType(This,penEventType)	\
    ( (This)->lpVtbl -> get_EventType(This,penEventType) ) 

#define IRTCMediaEvent_get_EventReason(This,penEventReason)	\
    ( (This)->lpVtbl -> get_EventReason(This,penEventReason) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCMediaEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCIntensityEvent_INTERFACE_DEFINED__
#define __IRTCIntensityEvent_INTERFACE_DEFINED__

/* interface IRTCIntensityEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCIntensityEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4c23bf51-390c-4992-a41d-41eec05b2a4b")
    IRTCIntensityEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Level( 
            /* [retval][out] */ __RPC__out long *plLevel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Min( 
            /* [retval][out] */ __RPC__out long *plMin) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Max( 
            /* [retval][out] */ __RPC__out long *plMax) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ __RPC__out RTC_AUDIO_DEVICE *penDirection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCIntensityEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCIntensityEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCIntensityEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCIntensityEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCIntensityEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCIntensityEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCIntensityEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCIntensityEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Level )( 
            __RPC__in IRTCIntensityEvent * This,
            /* [retval][out] */ __RPC__out long *plLevel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Min )( 
            __RPC__in IRTCIntensityEvent * This,
            /* [retval][out] */ __RPC__out long *plMin);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Max )( 
            __RPC__in IRTCIntensityEvent * This,
            /* [retval][out] */ __RPC__out long *plMax);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Direction )( 
            __RPC__in IRTCIntensityEvent * This,
            /* [retval][out] */ __RPC__out RTC_AUDIO_DEVICE *penDirection);
        
        END_INTERFACE
    } IRTCIntensityEventVtbl;

    interface IRTCIntensityEvent
    {
        CONST_VTBL struct IRTCIntensityEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCIntensityEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCIntensityEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCIntensityEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCIntensityEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCIntensityEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCIntensityEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCIntensityEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCIntensityEvent_get_Level(This,plLevel)	\
    ( (This)->lpVtbl -> get_Level(This,plLevel) ) 

#define IRTCIntensityEvent_get_Min(This,plMin)	\
    ( (This)->lpVtbl -> get_Min(This,plMin) ) 

#define IRTCIntensityEvent_get_Max(This,plMax)	\
    ( (This)->lpVtbl -> get_Max(This,plMax) ) 

#define IRTCIntensityEvent_get_Direction(This,penDirection)	\
    ( (This)->lpVtbl -> get_Direction(This,penDirection) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCIntensityEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCMessagingEvent_INTERFACE_DEFINED__
#define __IRTCMessagingEvent_INTERFACE_DEFINED__

/* interface IRTCMessagingEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCMessagingEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d3609541-1b29-4de5-a4ad-5aebaf319512")
    IRTCMessagingEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession **ppSession) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Participant( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCParticipant **ppParticipant) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventType( 
            /* [retval][out] */ __RPC__out RTC_MESSAGING_EVENT_TYPE *penEventType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Message( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrMessage) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MessageHeader( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrMessageHeader) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UserStatus( 
            /* [retval][out] */ __RPC__out RTC_MESSAGING_USER_STATUS *penUserStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCMessagingEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCMessagingEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCMessagingEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCMessagingEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCMessagingEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCMessagingEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCMessagingEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCMessagingEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Session )( 
            __RPC__in IRTCMessagingEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession **ppSession);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Participant )( 
            __RPC__in IRTCMessagingEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCParticipant **ppParticipant);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventType )( 
            __RPC__in IRTCMessagingEvent * This,
            /* [retval][out] */ __RPC__out RTC_MESSAGING_EVENT_TYPE *penEventType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Message )( 
            __RPC__in IRTCMessagingEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrMessage);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MessageHeader )( 
            __RPC__in IRTCMessagingEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrMessageHeader);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserStatus )( 
            __RPC__in IRTCMessagingEvent * This,
            /* [retval][out] */ __RPC__out RTC_MESSAGING_USER_STATUS *penUserStatus);
        
        END_INTERFACE
    } IRTCMessagingEventVtbl;

    interface IRTCMessagingEvent
    {
        CONST_VTBL struct IRTCMessagingEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCMessagingEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCMessagingEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCMessagingEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCMessagingEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCMessagingEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCMessagingEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCMessagingEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCMessagingEvent_get_Session(This,ppSession)	\
    ( (This)->lpVtbl -> get_Session(This,ppSession) ) 

#define IRTCMessagingEvent_get_Participant(This,ppParticipant)	\
    ( (This)->lpVtbl -> get_Participant(This,ppParticipant) ) 

#define IRTCMessagingEvent_get_EventType(This,penEventType)	\
    ( (This)->lpVtbl -> get_EventType(This,penEventType) ) 

#define IRTCMessagingEvent_get_Message(This,pbstrMessage)	\
    ( (This)->lpVtbl -> get_Message(This,pbstrMessage) ) 

#define IRTCMessagingEvent_get_MessageHeader(This,pbstrMessageHeader)	\
    ( (This)->lpVtbl -> get_MessageHeader(This,pbstrMessageHeader) ) 

#define IRTCMessagingEvent_get_UserStatus(This,penUserStatus)	\
    ( (This)->lpVtbl -> get_UserStatus(This,penUserStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCMessagingEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCBuddyEvent_INTERFACE_DEFINED__
#define __IRTCBuddyEvent_INTERFACE_DEFINED__

/* interface IRTCBuddyEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCBuddyEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f36d755d-17e6-404e-954f-0fc07574c78d")
    IRTCBuddyEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Buddy( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCBuddy **ppBuddy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCBuddyEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCBuddyEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCBuddyEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCBuddyEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCBuddyEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCBuddyEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCBuddyEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCBuddyEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Buddy )( 
            __RPC__in IRTCBuddyEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCBuddy **ppBuddy);
        
        END_INTERFACE
    } IRTCBuddyEventVtbl;

    interface IRTCBuddyEvent
    {
        CONST_VTBL struct IRTCBuddyEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCBuddyEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCBuddyEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCBuddyEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCBuddyEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCBuddyEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCBuddyEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCBuddyEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCBuddyEvent_get_Buddy(This,ppBuddy)	\
    ( (This)->lpVtbl -> get_Buddy(This,ppBuddy) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCBuddyEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCBuddyEvent2_INTERFACE_DEFINED__
#define __IRTCBuddyEvent2_INTERFACE_DEFINED__

/* interface IRTCBuddyEvent2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCBuddyEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("484A7F1E-73F0-4990-BFC2-60BC3978A720")
    IRTCBuddyEvent2 : public IRTCBuddyEvent
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventType( 
            /* [retval][out] */ __RPC__out RTC_BUDDY_EVENT_TYPE *pEventType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusCode( 
            /* [retval][out] */ __RPC__out long *plStatusCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusText( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatusText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCBuddyEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCBuddyEvent2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCBuddyEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCBuddyEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCBuddyEvent2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCBuddyEvent2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCBuddyEvent2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCBuddyEvent2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Buddy )( 
            __RPC__in IRTCBuddyEvent2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCBuddy **ppBuddy);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventType )( 
            __RPC__in IRTCBuddyEvent2 * This,
            /* [retval][out] */ __RPC__out RTC_BUDDY_EVENT_TYPE *pEventType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusCode )( 
            __RPC__in IRTCBuddyEvent2 * This,
            /* [retval][out] */ __RPC__out long *plStatusCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusText )( 
            __RPC__in IRTCBuddyEvent2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatusText);
        
        END_INTERFACE
    } IRTCBuddyEvent2Vtbl;

    interface IRTCBuddyEvent2
    {
        CONST_VTBL struct IRTCBuddyEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCBuddyEvent2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCBuddyEvent2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCBuddyEvent2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCBuddyEvent2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCBuddyEvent2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCBuddyEvent2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCBuddyEvent2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCBuddyEvent2_get_Buddy(This,ppBuddy)	\
    ( (This)->lpVtbl -> get_Buddy(This,ppBuddy) ) 


#define IRTCBuddyEvent2_get_EventType(This,pEventType)	\
    ( (This)->lpVtbl -> get_EventType(This,pEventType) ) 

#define IRTCBuddyEvent2_get_StatusCode(This,plStatusCode)	\
    ( (This)->lpVtbl -> get_StatusCode(This,plStatusCode) ) 

#define IRTCBuddyEvent2_get_StatusText(This,pbstrStatusText)	\
    ( (This)->lpVtbl -> get_StatusText(This,pbstrStatusText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCBuddyEvent2_INTERFACE_DEFINED__ */


#ifndef __IRTCWatcherEvent_INTERFACE_DEFINED__
#define __IRTCWatcherEvent_INTERFACE_DEFINED__

/* interface IRTCWatcherEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCWatcherEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f30d7261-587a-424f-822c-312788f43548")
    IRTCWatcherEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Watcher( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCWatcher **ppWatcher) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCWatcherEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCWatcherEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCWatcherEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCWatcherEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCWatcherEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCWatcherEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCWatcherEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCWatcherEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Watcher )( 
            __RPC__in IRTCWatcherEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCWatcher **ppWatcher);
        
        END_INTERFACE
    } IRTCWatcherEventVtbl;

    interface IRTCWatcherEvent
    {
        CONST_VTBL struct IRTCWatcherEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCWatcherEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCWatcherEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCWatcherEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCWatcherEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCWatcherEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCWatcherEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCWatcherEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCWatcherEvent_get_Watcher(This,ppWatcher)	\
    ( (This)->lpVtbl -> get_Watcher(This,ppWatcher) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCWatcherEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCWatcherEvent2_INTERFACE_DEFINED__
#define __IRTCWatcherEvent2_INTERFACE_DEFINED__

/* interface IRTCWatcherEvent2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCWatcherEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E52891E8-188C-49AF-B005-98ED13F83F9C")
    IRTCWatcherEvent2 : public IRTCWatcherEvent
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventType( 
            /* [retval][out] */ __RPC__out RTC_WATCHER_EVENT_TYPE *pEventType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusCode( 
            /* [retval][out] */ __RPC__out long *plStatusCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCWatcherEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCWatcherEvent2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCWatcherEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCWatcherEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCWatcherEvent2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCWatcherEvent2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCWatcherEvent2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCWatcherEvent2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Watcher )( 
            __RPC__in IRTCWatcherEvent2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCWatcher **ppWatcher);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventType )( 
            __RPC__in IRTCWatcherEvent2 * This,
            /* [retval][out] */ __RPC__out RTC_WATCHER_EVENT_TYPE *pEventType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusCode )( 
            __RPC__in IRTCWatcherEvent2 * This,
            /* [retval][out] */ __RPC__out long *plStatusCode);
        
        END_INTERFACE
    } IRTCWatcherEvent2Vtbl;

    interface IRTCWatcherEvent2
    {
        CONST_VTBL struct IRTCWatcherEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCWatcherEvent2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCWatcherEvent2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCWatcherEvent2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCWatcherEvent2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCWatcherEvent2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCWatcherEvent2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCWatcherEvent2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCWatcherEvent2_get_Watcher(This,ppWatcher)	\
    ( (This)->lpVtbl -> get_Watcher(This,ppWatcher) ) 


#define IRTCWatcherEvent2_get_EventType(This,pEventType)	\
    ( (This)->lpVtbl -> get_EventType(This,pEventType) ) 

#define IRTCWatcherEvent2_get_StatusCode(This,plStatusCode)	\
    ( (This)->lpVtbl -> get_StatusCode(This,plStatusCode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCWatcherEvent2_INTERFACE_DEFINED__ */


#ifndef __IRTCBuddyGroupEvent_INTERFACE_DEFINED__
#define __IRTCBuddyGroupEvent_INTERFACE_DEFINED__

/* interface IRTCBuddyGroupEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCBuddyGroupEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3A79E1D1-B736-4414-96F8-BBC7F08863E4")
    IRTCBuddyGroupEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventType( 
            /* [retval][out] */ __RPC__out RTC_GROUP_EVENT_TYPE *pEventType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Group( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCBuddyGroup **ppGroup) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Buddy( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCBuddy2 **ppBuddy) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusCode( 
            /* [retval][out] */ __RPC__out long *plStatusCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCBuddyGroupEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCBuddyGroupEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCBuddyGroupEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCBuddyGroupEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCBuddyGroupEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCBuddyGroupEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCBuddyGroupEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCBuddyGroupEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventType )( 
            __RPC__in IRTCBuddyGroupEvent * This,
            /* [retval][out] */ __RPC__out RTC_GROUP_EVENT_TYPE *pEventType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Group )( 
            __RPC__in IRTCBuddyGroupEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCBuddyGroup **ppGroup);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Buddy )( 
            __RPC__in IRTCBuddyGroupEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCBuddy2 **ppBuddy);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusCode )( 
            __RPC__in IRTCBuddyGroupEvent * This,
            /* [retval][out] */ __RPC__out long *plStatusCode);
        
        END_INTERFACE
    } IRTCBuddyGroupEventVtbl;

    interface IRTCBuddyGroupEvent
    {
        CONST_VTBL struct IRTCBuddyGroupEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCBuddyGroupEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCBuddyGroupEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCBuddyGroupEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCBuddyGroupEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCBuddyGroupEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCBuddyGroupEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCBuddyGroupEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCBuddyGroupEvent_get_EventType(This,pEventType)	\
    ( (This)->lpVtbl -> get_EventType(This,pEventType) ) 

#define IRTCBuddyGroupEvent_get_Group(This,ppGroup)	\
    ( (This)->lpVtbl -> get_Group(This,ppGroup) ) 

#define IRTCBuddyGroupEvent_get_Buddy(This,ppBuddy)	\
    ( (This)->lpVtbl -> get_Buddy(This,ppBuddy) ) 

#define IRTCBuddyGroupEvent_get_StatusCode(This,plStatusCode)	\
    ( (This)->lpVtbl -> get_StatusCode(This,plStatusCode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCBuddyGroupEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCInfoEvent_INTERFACE_DEFINED__
#define __IRTCInfoEvent_INTERFACE_DEFINED__

/* interface IRTCInfoEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCInfoEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4E1D68AE-1912-4f49-B2C3-594FADFD425F")
    IRTCInfoEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession2 **ppSession) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Participant( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCParticipant **ppParticipant) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Info( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrInfo) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InfoHeader( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrInfoHeader) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCInfoEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCInfoEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCInfoEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCInfoEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCInfoEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCInfoEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCInfoEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCInfoEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Session )( 
            __RPC__in IRTCInfoEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession2 **ppSession);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Participant )( 
            __RPC__in IRTCInfoEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCParticipant **ppParticipant);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Info )( 
            __RPC__in IRTCInfoEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrInfo);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InfoHeader )( 
            __RPC__in IRTCInfoEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrInfoHeader);
        
        END_INTERFACE
    } IRTCInfoEventVtbl;

    interface IRTCInfoEvent
    {
        CONST_VTBL struct IRTCInfoEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCInfoEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCInfoEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCInfoEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCInfoEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCInfoEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCInfoEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCInfoEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCInfoEvent_get_Session(This,ppSession)	\
    ( (This)->lpVtbl -> get_Session(This,ppSession) ) 

#define IRTCInfoEvent_get_Participant(This,ppParticipant)	\
    ( (This)->lpVtbl -> get_Participant(This,ppParticipant) ) 

#define IRTCInfoEvent_get_Info(This,pbstrInfo)	\
    ( (This)->lpVtbl -> get_Info(This,pbstrInfo) ) 

#define IRTCInfoEvent_get_InfoHeader(This,pbstrInfoHeader)	\
    ( (This)->lpVtbl -> get_InfoHeader(This,pbstrInfoHeader) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCInfoEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCMediaRequestEvent_INTERFACE_DEFINED__
#define __IRTCMediaRequestEvent_INTERFACE_DEFINED__

/* interface IRTCMediaRequestEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCMediaRequestEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("52572D15-148C-4d97-A36C-2DA55C289D63")
    IRTCMediaRequestEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession2 **ppSession) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProposedMedia( 
            /* [retval][out] */ __RPC__out long *plMediaTypes) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentMedia( 
            /* [retval][out] */ __RPC__out long *plMediaTypes) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Accept( 
            /* [in] */ long lMediaTypes) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RemotePreferredSecurityLevel( 
            /* [in] */ RTC_SECURITY_TYPE enSecurityType,
            /* [retval][out] */ __RPC__out RTC_SECURITY_LEVEL *penSecurityLevel) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reject( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out RTC_REINVITE_STATE *pState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCMediaRequestEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCMediaRequestEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCMediaRequestEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCMediaRequestEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCMediaRequestEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCMediaRequestEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCMediaRequestEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCMediaRequestEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Session )( 
            __RPC__in IRTCMediaRequestEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession2 **ppSession);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProposedMedia )( 
            __RPC__in IRTCMediaRequestEvent * This,
            /* [retval][out] */ __RPC__out long *plMediaTypes);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentMedia )( 
            __RPC__in IRTCMediaRequestEvent * This,
            /* [retval][out] */ __RPC__out long *plMediaTypes);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Accept )( 
            __RPC__in IRTCMediaRequestEvent * This,
            /* [in] */ long lMediaTypes);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RemotePreferredSecurityLevel )( 
            __RPC__in IRTCMediaRequestEvent * This,
            /* [in] */ RTC_SECURITY_TYPE enSecurityType,
            /* [retval][out] */ __RPC__out RTC_SECURITY_LEVEL *penSecurityLevel);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reject )( 
            __RPC__in IRTCMediaRequestEvent * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            __RPC__in IRTCMediaRequestEvent * This,
            /* [retval][out] */ __RPC__out RTC_REINVITE_STATE *pState);
        
        END_INTERFACE
    } IRTCMediaRequestEventVtbl;

    interface IRTCMediaRequestEvent
    {
        CONST_VTBL struct IRTCMediaRequestEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCMediaRequestEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCMediaRequestEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCMediaRequestEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCMediaRequestEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCMediaRequestEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCMediaRequestEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCMediaRequestEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCMediaRequestEvent_get_Session(This,ppSession)	\
    ( (This)->lpVtbl -> get_Session(This,ppSession) ) 

#define IRTCMediaRequestEvent_get_ProposedMedia(This,plMediaTypes)	\
    ( (This)->lpVtbl -> get_ProposedMedia(This,plMediaTypes) ) 

#define IRTCMediaRequestEvent_get_CurrentMedia(This,plMediaTypes)	\
    ( (This)->lpVtbl -> get_CurrentMedia(This,plMediaTypes) ) 

#define IRTCMediaRequestEvent_Accept(This,lMediaTypes)	\
    ( (This)->lpVtbl -> Accept(This,lMediaTypes) ) 

#define IRTCMediaRequestEvent_get_RemotePreferredSecurityLevel(This,enSecurityType,penSecurityLevel)	\
    ( (This)->lpVtbl -> get_RemotePreferredSecurityLevel(This,enSecurityType,penSecurityLevel) ) 

#define IRTCMediaRequestEvent_Reject(This)	\
    ( (This)->lpVtbl -> Reject(This) ) 

#define IRTCMediaRequestEvent_get_State(This,pState)	\
    ( (This)->lpVtbl -> get_State(This,pState) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCMediaRequestEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCReInviteEvent_INTERFACE_DEFINED__
#define __IRTCReInviteEvent_INTERFACE_DEFINED__

/* interface IRTCReInviteEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCReInviteEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("11558D84-204C-43e7-99B0-2034E9417F7D")
    IRTCReInviteEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession2 **ppSession2) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Accept( 
            /* [in] */ __RPC__in BSTR bstrContentType,
            /* [in] */ __RPC__in BSTR bstrSessionDescription) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reject( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out RTC_REINVITE_STATE *pState) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetRemoteSessionDescription( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrContentType,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSessionDescription) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCReInviteEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCReInviteEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCReInviteEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCReInviteEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCReInviteEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCReInviteEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCReInviteEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCReInviteEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Session )( 
            __RPC__in IRTCReInviteEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession2 **ppSession2);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Accept )( 
            __RPC__in IRTCReInviteEvent * This,
            /* [in] */ __RPC__in BSTR bstrContentType,
            /* [in] */ __RPC__in BSTR bstrSessionDescription);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reject )( 
            __RPC__in IRTCReInviteEvent * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            __RPC__in IRTCReInviteEvent * This,
            /* [retval][out] */ __RPC__out RTC_REINVITE_STATE *pState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetRemoteSessionDescription )( 
            __RPC__in IRTCReInviteEvent * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrContentType,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSessionDescription);
        
        END_INTERFACE
    } IRTCReInviteEventVtbl;

    interface IRTCReInviteEvent
    {
        CONST_VTBL struct IRTCReInviteEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCReInviteEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCReInviteEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCReInviteEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCReInviteEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCReInviteEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCReInviteEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCReInviteEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCReInviteEvent_get_Session(This,ppSession2)	\
    ( (This)->lpVtbl -> get_Session(This,ppSession2) ) 

#define IRTCReInviteEvent_Accept(This,bstrContentType,bstrSessionDescription)	\
    ( (This)->lpVtbl -> Accept(This,bstrContentType,bstrSessionDescription) ) 

#define IRTCReInviteEvent_Reject(This)	\
    ( (This)->lpVtbl -> Reject(This) ) 

#define IRTCReInviteEvent_get_State(This,pState)	\
    ( (This)->lpVtbl -> get_State(This,pState) ) 

#define IRTCReInviteEvent_GetRemoteSessionDescription(This,pbstrContentType,pbstrSessionDescription)	\
    ( (This)->lpVtbl -> GetRemoteSessionDescription(This,pbstrContentType,pbstrSessionDescription) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCReInviteEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCPresencePropertyEvent_INTERFACE_DEFINED__
#define __IRTCPresencePropertyEvent_INTERFACE_DEFINED__

/* interface IRTCPresencePropertyEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCPresencePropertyEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F777F570-A820-49d5-86BD-E099493F1518")
    IRTCPresencePropertyEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusCode( 
            /* [retval][out] */ __RPC__out long *plStatusCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusText( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatusText) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PresenceProperty( 
            /* [retval][out] */ __RPC__out RTC_PRESENCE_PROPERTY *penPresProp) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCPresencePropertyEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCPresencePropertyEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCPresencePropertyEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCPresencePropertyEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCPresencePropertyEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCPresencePropertyEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCPresencePropertyEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCPresencePropertyEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusCode )( 
            __RPC__in IRTCPresencePropertyEvent * This,
            /* [retval][out] */ __RPC__out long *plStatusCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusText )( 
            __RPC__in IRTCPresencePropertyEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatusText);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PresenceProperty )( 
            __RPC__in IRTCPresencePropertyEvent * This,
            /* [retval][out] */ __RPC__out RTC_PRESENCE_PROPERTY *penPresProp);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            __RPC__in IRTCPresencePropertyEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrValue);
        
        END_INTERFACE
    } IRTCPresencePropertyEventVtbl;

    interface IRTCPresencePropertyEvent
    {
        CONST_VTBL struct IRTCPresencePropertyEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCPresencePropertyEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCPresencePropertyEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCPresencePropertyEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCPresencePropertyEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCPresencePropertyEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCPresencePropertyEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCPresencePropertyEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCPresencePropertyEvent_get_StatusCode(This,plStatusCode)	\
    ( (This)->lpVtbl -> get_StatusCode(This,plStatusCode) ) 

#define IRTCPresencePropertyEvent_get_StatusText(This,pbstrStatusText)	\
    ( (This)->lpVtbl -> get_StatusText(This,pbstrStatusText) ) 

#define IRTCPresencePropertyEvent_get_PresenceProperty(This,penPresProp)	\
    ( (This)->lpVtbl -> get_PresenceProperty(This,penPresProp) ) 

#define IRTCPresencePropertyEvent_get_Value(This,pbstrValue)	\
    ( (This)->lpVtbl -> get_Value(This,pbstrValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCPresencePropertyEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCPresenceDataEvent_INTERFACE_DEFINED__
#define __IRTCPresenceDataEvent_INTERFACE_DEFINED__

/* interface IRTCPresenceDataEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCPresenceDataEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("38F0E78C-8B87-4c04-A82D-AEDD83C909BB")
    IRTCPresenceDataEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusCode( 
            /* [retval][out] */ __RPC__out long *plStatusCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusText( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatusText) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPresenceData( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrNamespace,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCPresenceDataEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCPresenceDataEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCPresenceDataEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCPresenceDataEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCPresenceDataEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCPresenceDataEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCPresenceDataEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCPresenceDataEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusCode )( 
            __RPC__in IRTCPresenceDataEvent * This,
            /* [retval][out] */ __RPC__out long *plStatusCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusText )( 
            __RPC__in IRTCPresenceDataEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatusText);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPresenceData )( 
            __RPC__in IRTCPresenceDataEvent * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrNamespace,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrData);
        
        END_INTERFACE
    } IRTCPresenceDataEventVtbl;

    interface IRTCPresenceDataEvent
    {
        CONST_VTBL struct IRTCPresenceDataEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCPresenceDataEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCPresenceDataEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCPresenceDataEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCPresenceDataEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCPresenceDataEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCPresenceDataEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCPresenceDataEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCPresenceDataEvent_get_StatusCode(This,plStatusCode)	\
    ( (This)->lpVtbl -> get_StatusCode(This,plStatusCode) ) 

#define IRTCPresenceDataEvent_get_StatusText(This,pbstrStatusText)	\
    ( (This)->lpVtbl -> get_StatusText(This,pbstrStatusText) ) 

#define IRTCPresenceDataEvent_GetPresenceData(This,pbstrNamespace,pbstrData)	\
    ( (This)->lpVtbl -> GetPresenceData(This,pbstrNamespace,pbstrData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCPresenceDataEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCPresenceStatusEvent_INTERFACE_DEFINED__
#define __IRTCPresenceStatusEvent_INTERFACE_DEFINED__

/* interface IRTCPresenceStatusEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCPresenceStatusEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("78673F32-4A0F-462c-89AA-EE7706707678")
    IRTCPresenceStatusEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusCode( 
            /* [retval][out] */ __RPC__out long *plStatusCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusText( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatusText) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLocalPresenceInfo( 
            /* [out] */ __RPC__out RTC_PRESENCE_STATUS *penStatus,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrNotes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCPresenceStatusEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCPresenceStatusEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCPresenceStatusEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCPresenceStatusEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCPresenceStatusEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCPresenceStatusEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCPresenceStatusEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCPresenceStatusEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusCode )( 
            __RPC__in IRTCPresenceStatusEvent * This,
            /* [retval][out] */ __RPC__out long *plStatusCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusText )( 
            __RPC__in IRTCPresenceStatusEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatusText);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLocalPresenceInfo )( 
            __RPC__in IRTCPresenceStatusEvent * This,
            /* [out] */ __RPC__out RTC_PRESENCE_STATUS *penStatus,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrNotes);
        
        END_INTERFACE
    } IRTCPresenceStatusEventVtbl;

    interface IRTCPresenceStatusEvent
    {
        CONST_VTBL struct IRTCPresenceStatusEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCPresenceStatusEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCPresenceStatusEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCPresenceStatusEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCPresenceStatusEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCPresenceStatusEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCPresenceStatusEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCPresenceStatusEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCPresenceStatusEvent_get_StatusCode(This,plStatusCode)	\
    ( (This)->lpVtbl -> get_StatusCode(This,plStatusCode) ) 

#define IRTCPresenceStatusEvent_get_StatusText(This,pbstrStatusText)	\
    ( (This)->lpVtbl -> get_StatusText(This,pbstrStatusText) ) 

#define IRTCPresenceStatusEvent_GetLocalPresenceInfo(This,penStatus,pbstrNotes)	\
    ( (This)->lpVtbl -> GetLocalPresenceInfo(This,penStatus,pbstrNotes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCPresenceStatusEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCCollection_INTERFACE_DEFINED__
#define __IRTCCollection_INTERFACE_DEFINED__

/* interface IRTCCollection */
/* [dual][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EC7C8096-B918-4044-94F1-E4FBA0361D5C")
    IRTCCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *lCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long Index,
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppNewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IRTCCollection * This,
            /* [retval][out] */ __RPC__out long *lCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IRTCCollection * This,
            /* [in] */ long Index,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IRTCCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppNewEnum);
        
        END_INTERFACE
    } IRTCCollectionVtbl;

    interface IRTCCollection
    {
        CONST_VTBL struct IRTCCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCCollection_get_Count(This,lCount)	\
    ( (This)->lpVtbl -> get_Count(This,lCount) ) 

#define IRTCCollection_get_Item(This,Index,pVariant)	\
    ( (This)->lpVtbl -> get_Item(This,Index,pVariant) ) 

#define IRTCCollection_get__NewEnum(This,ppNewEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppNewEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCCollection_INTERFACE_DEFINED__ */


#ifndef __IRTCEnumParticipants_INTERFACE_DEFINED__
#define __IRTCEnumParticipants_INTERFACE_DEFINED__

/* interface IRTCEnumParticipants */
/* [unique][helpstring][hidden][uuid][object] */ 


EXTERN_C const IID IID_IRTCEnumParticipants;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fcd56f29-4a4f-41b2-ba5c-f5bccc060bf6")
    IRTCEnumParticipants : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) IRTCParticipant **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumParticipants **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCEnumParticipantsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCEnumParticipants * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCEnumParticipants * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCEnumParticipants * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IRTCEnumParticipants * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) IRTCParticipant **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IRTCEnumParticipants * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IRTCEnumParticipants * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IRTCEnumParticipants * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumParticipants **ppEnum);
        
        END_INTERFACE
    } IRTCEnumParticipantsVtbl;

    interface IRTCEnumParticipants
    {
        CONST_VTBL struct IRTCEnumParticipantsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCEnumParticipants_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCEnumParticipants_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCEnumParticipants_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCEnumParticipants_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IRTCEnumParticipants_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IRTCEnumParticipants_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IRTCEnumParticipants_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCEnumParticipants_INTERFACE_DEFINED__ */


#ifndef __IRTCEnumProfiles_INTERFACE_DEFINED__
#define __IRTCEnumProfiles_INTERFACE_DEFINED__

/* interface IRTCEnumProfiles */
/* [unique][helpstring][hidden][uuid][object] */ 


EXTERN_C const IID IID_IRTCEnumProfiles;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("29b7c41c-ed82-4bca-84ad-39d5101b58e3")
    IRTCEnumProfiles : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) IRTCProfile **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumProfiles **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCEnumProfilesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCEnumProfiles * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCEnumProfiles * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCEnumProfiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IRTCEnumProfiles * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) IRTCProfile **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IRTCEnumProfiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IRTCEnumProfiles * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IRTCEnumProfiles * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumProfiles **ppEnum);
        
        END_INTERFACE
    } IRTCEnumProfilesVtbl;

    interface IRTCEnumProfiles
    {
        CONST_VTBL struct IRTCEnumProfilesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCEnumProfiles_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCEnumProfiles_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCEnumProfiles_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCEnumProfiles_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IRTCEnumProfiles_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IRTCEnumProfiles_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IRTCEnumProfiles_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCEnumProfiles_INTERFACE_DEFINED__ */


#ifndef __IRTCEnumBuddies_INTERFACE_DEFINED__
#define __IRTCEnumBuddies_INTERFACE_DEFINED__

/* interface IRTCEnumBuddies */
/* [unique][helpstring][hidden][uuid][object] */ 


EXTERN_C const IID IID_IRTCEnumBuddies;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f7296917-5569-4b3b-b3af-98d1144b2b87")
    IRTCEnumBuddies : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) IRTCBuddy **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumBuddies **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCEnumBuddiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCEnumBuddies * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCEnumBuddies * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCEnumBuddies * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IRTCEnumBuddies * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) IRTCBuddy **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IRTCEnumBuddies * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IRTCEnumBuddies * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IRTCEnumBuddies * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumBuddies **ppEnum);
        
        END_INTERFACE
    } IRTCEnumBuddiesVtbl;

    interface IRTCEnumBuddies
    {
        CONST_VTBL struct IRTCEnumBuddiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCEnumBuddies_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCEnumBuddies_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCEnumBuddies_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCEnumBuddies_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IRTCEnumBuddies_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IRTCEnumBuddies_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IRTCEnumBuddies_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCEnumBuddies_INTERFACE_DEFINED__ */


#ifndef __IRTCEnumWatchers_INTERFACE_DEFINED__
#define __IRTCEnumWatchers_INTERFACE_DEFINED__

/* interface IRTCEnumWatchers */
/* [unique][helpstring][hidden][uuid][object] */ 


EXTERN_C const IID IID_IRTCEnumWatchers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a87d55d7-db74-4ed1-9ca4-77a0e41b413e")
    IRTCEnumWatchers : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) IRTCWatcher **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumWatchers **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCEnumWatchersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCEnumWatchers * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCEnumWatchers * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCEnumWatchers * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IRTCEnumWatchers * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) IRTCWatcher **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IRTCEnumWatchers * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IRTCEnumWatchers * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IRTCEnumWatchers * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumWatchers **ppEnum);
        
        END_INTERFACE
    } IRTCEnumWatchersVtbl;

    interface IRTCEnumWatchers
    {
        CONST_VTBL struct IRTCEnumWatchersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCEnumWatchers_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCEnumWatchers_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCEnumWatchers_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCEnumWatchers_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IRTCEnumWatchers_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IRTCEnumWatchers_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IRTCEnumWatchers_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCEnumWatchers_INTERFACE_DEFINED__ */


#ifndef __IRTCEnumGroups_INTERFACE_DEFINED__
#define __IRTCEnumGroups_INTERFACE_DEFINED__

/* interface IRTCEnumGroups */
/* [unique][helpstring][hidden][uuid][object] */ 


EXTERN_C const IID IID_IRTCEnumGroups;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("742378D6-A141-4415-8F27-35D99076CF5D")
    IRTCEnumGroups : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) IRTCBuddyGroup **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumGroups **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCEnumGroupsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCEnumGroups * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCEnumGroups * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCEnumGroups * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IRTCEnumGroups * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) IRTCBuddyGroup **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IRTCEnumGroups * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IRTCEnumGroups * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IRTCEnumGroups * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumGroups **ppEnum);
        
        END_INTERFACE
    } IRTCEnumGroupsVtbl;

    interface IRTCEnumGroups
    {
        CONST_VTBL struct IRTCEnumGroupsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCEnumGroups_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCEnumGroups_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCEnumGroups_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCEnumGroups_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IRTCEnumGroups_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IRTCEnumGroups_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IRTCEnumGroups_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCEnumGroups_INTERFACE_DEFINED__ */


#ifndef __IRTCPresenceContact_INTERFACE_DEFINED__
#define __IRTCPresenceContact_INTERFACE_DEFINED__

/* interface IRTCPresenceContact */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCPresenceContact;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8b22f92c-cd90-42db-a733-212205c3e3df")
    IRTCPresenceContact : public IUnknown
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PresentityURI( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPresentityURI) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_PresentityURI( 
            /* [in] */ __RPC__in BSTR bstrPresentityURI) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ __RPC__in BSTR bstrName) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Data( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Data( 
            /* [in] */ __RPC__in BSTR bstrData) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Persistent( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfPersistent) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Persistent( 
            /* [in] */ VARIANT_BOOL fPersistent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCPresenceContactVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCPresenceContact * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCPresenceContact * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCPresenceContact * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PresentityURI )( 
            __RPC__in IRTCPresenceContact * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPresentityURI);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PresentityURI )( 
            __RPC__in IRTCPresenceContact * This,
            /* [in] */ __RPC__in BSTR bstrPresentityURI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IRTCPresenceContact * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            __RPC__in IRTCPresenceContact * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Data )( 
            __RPC__in IRTCPresenceContact * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Data )( 
            __RPC__in IRTCPresenceContact * This,
            /* [in] */ __RPC__in BSTR bstrData);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Persistent )( 
            __RPC__in IRTCPresenceContact * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfPersistent);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Persistent )( 
            __RPC__in IRTCPresenceContact * This,
            /* [in] */ VARIANT_BOOL fPersistent);
        
        END_INTERFACE
    } IRTCPresenceContactVtbl;

    interface IRTCPresenceContact
    {
        CONST_VTBL struct IRTCPresenceContactVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCPresenceContact_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCPresenceContact_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCPresenceContact_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCPresenceContact_get_PresentityURI(This,pbstrPresentityURI)	\
    ( (This)->lpVtbl -> get_PresentityURI(This,pbstrPresentityURI) ) 

#define IRTCPresenceContact_put_PresentityURI(This,bstrPresentityURI)	\
    ( (This)->lpVtbl -> put_PresentityURI(This,bstrPresentityURI) ) 

#define IRTCPresenceContact_get_Name(This,pbstrName)	\
    ( (This)->lpVtbl -> get_Name(This,pbstrName) ) 

#define IRTCPresenceContact_put_Name(This,bstrName)	\
    ( (This)->lpVtbl -> put_Name(This,bstrName) ) 

#define IRTCPresenceContact_get_Data(This,pbstrData)	\
    ( (This)->lpVtbl -> get_Data(This,pbstrData) ) 

#define IRTCPresenceContact_put_Data(This,bstrData)	\
    ( (This)->lpVtbl -> put_Data(This,bstrData) ) 

#define IRTCPresenceContact_get_Persistent(This,pfPersistent)	\
    ( (This)->lpVtbl -> get_Persistent(This,pfPersistent) ) 

#define IRTCPresenceContact_put_Persistent(This,fPersistent)	\
    ( (This)->lpVtbl -> put_Persistent(This,fPersistent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCPresenceContact_INTERFACE_DEFINED__ */


#ifndef __IRTCBuddy_INTERFACE_DEFINED__
#define __IRTCBuddy_INTERFACE_DEFINED__

/* interface IRTCBuddy */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCBuddy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fcb136c8-7b90-4e0c-befe-56edf0ba6f1c")
    IRTCBuddy : public IRTCPresenceContact
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ __RPC__out RTC_PRESENCE_STATUS *penStatus) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Notes( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrNotes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCBuddyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCBuddy * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCBuddy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCBuddy * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PresentityURI )( 
            __RPC__in IRTCBuddy * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPresentityURI);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PresentityURI )( 
            __RPC__in IRTCBuddy * This,
            /* [in] */ __RPC__in BSTR bstrPresentityURI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IRTCBuddy * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            __RPC__in IRTCBuddy * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Data )( 
            __RPC__in IRTCBuddy * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Data )( 
            __RPC__in IRTCBuddy * This,
            /* [in] */ __RPC__in BSTR bstrData);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Persistent )( 
            __RPC__in IRTCBuddy * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfPersistent);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Persistent )( 
            __RPC__in IRTCBuddy * This,
            /* [in] */ VARIANT_BOOL fPersistent);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            __RPC__in IRTCBuddy * This,
            /* [retval][out] */ __RPC__out RTC_PRESENCE_STATUS *penStatus);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Notes )( 
            __RPC__in IRTCBuddy * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrNotes);
        
        END_INTERFACE
    } IRTCBuddyVtbl;

    interface IRTCBuddy
    {
        CONST_VTBL struct IRTCBuddyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCBuddy_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCBuddy_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCBuddy_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCBuddy_get_PresentityURI(This,pbstrPresentityURI)	\
    ( (This)->lpVtbl -> get_PresentityURI(This,pbstrPresentityURI) ) 

#define IRTCBuddy_put_PresentityURI(This,bstrPresentityURI)	\
    ( (This)->lpVtbl -> put_PresentityURI(This,bstrPresentityURI) ) 

#define IRTCBuddy_get_Name(This,pbstrName)	\
    ( (This)->lpVtbl -> get_Name(This,pbstrName) ) 

#define IRTCBuddy_put_Name(This,bstrName)	\
    ( (This)->lpVtbl -> put_Name(This,bstrName) ) 

#define IRTCBuddy_get_Data(This,pbstrData)	\
    ( (This)->lpVtbl -> get_Data(This,pbstrData) ) 

#define IRTCBuddy_put_Data(This,bstrData)	\
    ( (This)->lpVtbl -> put_Data(This,bstrData) ) 

#define IRTCBuddy_get_Persistent(This,pfPersistent)	\
    ( (This)->lpVtbl -> get_Persistent(This,pfPersistent) ) 

#define IRTCBuddy_put_Persistent(This,fPersistent)	\
    ( (This)->lpVtbl -> put_Persistent(This,fPersistent) ) 


#define IRTCBuddy_get_Status(This,penStatus)	\
    ( (This)->lpVtbl -> get_Status(This,penStatus) ) 

#define IRTCBuddy_get_Notes(This,pbstrNotes)	\
    ( (This)->lpVtbl -> get_Notes(This,pbstrNotes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCBuddy_INTERFACE_DEFINED__ */


#ifndef __IRTCBuddy2_INTERFACE_DEFINED__
#define __IRTCBuddy2_INTERFACE_DEFINED__

/* interface IRTCBuddy2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCBuddy2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("102F9588-23E7-40e3-954D-CD7A1D5C0361")
    IRTCBuddy2 : public IRTCBuddy
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Profile( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile2 **ppProfile) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring][hidden] */ HRESULT STDMETHODCALLTYPE EnumerateGroups( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumGroups **ppEnum) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Groups( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppCollection) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PresenceProperty( 
            /* [in] */ RTC_PRESENCE_PROPERTY enProperty,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProperty) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumeratePresenceDevices( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumPresenceDevices **ppEnumDevices) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PresenceDevices( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppDevicesCollection) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SubscriptionType( 
            /* [retval][out] */ __RPC__out RTC_BUDDY_SUBSCRIPTION_TYPE *penSubscriptionType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCBuddy2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCBuddy2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCBuddy2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCBuddy2 * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PresentityURI )( 
            __RPC__in IRTCBuddy2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPresentityURI);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PresentityURI )( 
            __RPC__in IRTCBuddy2 * This,
            /* [in] */ __RPC__in BSTR bstrPresentityURI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IRTCBuddy2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            __RPC__in IRTCBuddy2 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Data )( 
            __RPC__in IRTCBuddy2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Data )( 
            __RPC__in IRTCBuddy2 * This,
            /* [in] */ __RPC__in BSTR bstrData);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Persistent )( 
            __RPC__in IRTCBuddy2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfPersistent);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Persistent )( 
            __RPC__in IRTCBuddy2 * This,
            /* [in] */ VARIANT_BOOL fPersistent);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            __RPC__in IRTCBuddy2 * This,
            /* [retval][out] */ __RPC__out RTC_PRESENCE_STATUS *penStatus);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Notes )( 
            __RPC__in IRTCBuddy2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrNotes);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Profile )( 
            __RPC__in IRTCBuddy2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile2 **ppProfile);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            __RPC__in IRTCBuddy2 * This);
        
        /* [helpstring][hidden] */ HRESULT ( STDMETHODCALLTYPE *EnumerateGroups )( 
            __RPC__in IRTCBuddy2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumGroups **ppEnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Groups )( 
            __RPC__in IRTCBuddy2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppCollection);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PresenceProperty )( 
            __RPC__in IRTCBuddy2 * This,
            /* [in] */ RTC_PRESENCE_PROPERTY enProperty,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProperty);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumeratePresenceDevices )( 
            __RPC__in IRTCBuddy2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumPresenceDevices **ppEnumDevices);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PresenceDevices )( 
            __RPC__in IRTCBuddy2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppDevicesCollection);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubscriptionType )( 
            __RPC__in IRTCBuddy2 * This,
            /* [retval][out] */ __RPC__out RTC_BUDDY_SUBSCRIPTION_TYPE *penSubscriptionType);
        
        END_INTERFACE
    } IRTCBuddy2Vtbl;

    interface IRTCBuddy2
    {
        CONST_VTBL struct IRTCBuddy2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCBuddy2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCBuddy2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCBuddy2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCBuddy2_get_PresentityURI(This,pbstrPresentityURI)	\
    ( (This)->lpVtbl -> get_PresentityURI(This,pbstrPresentityURI) ) 

#define IRTCBuddy2_put_PresentityURI(This,bstrPresentityURI)	\
    ( (This)->lpVtbl -> put_PresentityURI(This,bstrPresentityURI) ) 

#define IRTCBuddy2_get_Name(This,pbstrName)	\
    ( (This)->lpVtbl -> get_Name(This,pbstrName) ) 

#define IRTCBuddy2_put_Name(This,bstrName)	\
    ( (This)->lpVtbl -> put_Name(This,bstrName) ) 

#define IRTCBuddy2_get_Data(This,pbstrData)	\
    ( (This)->lpVtbl -> get_Data(This,pbstrData) ) 

#define IRTCBuddy2_put_Data(This,bstrData)	\
    ( (This)->lpVtbl -> put_Data(This,bstrData) ) 

#define IRTCBuddy2_get_Persistent(This,pfPersistent)	\
    ( (This)->lpVtbl -> get_Persistent(This,pfPersistent) ) 

#define IRTCBuddy2_put_Persistent(This,fPersistent)	\
    ( (This)->lpVtbl -> put_Persistent(This,fPersistent) ) 


#define IRTCBuddy2_get_Status(This,penStatus)	\
    ( (This)->lpVtbl -> get_Status(This,penStatus) ) 

#define IRTCBuddy2_get_Notes(This,pbstrNotes)	\
    ( (This)->lpVtbl -> get_Notes(This,pbstrNotes) ) 


#define IRTCBuddy2_get_Profile(This,ppProfile)	\
    ( (This)->lpVtbl -> get_Profile(This,ppProfile) ) 

#define IRTCBuddy2_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IRTCBuddy2_EnumerateGroups(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumerateGroups(This,ppEnum) ) 

#define IRTCBuddy2_get_Groups(This,ppCollection)	\
    ( (This)->lpVtbl -> get_Groups(This,ppCollection) ) 

#define IRTCBuddy2_get_PresenceProperty(This,enProperty,pbstrProperty)	\
    ( (This)->lpVtbl -> get_PresenceProperty(This,enProperty,pbstrProperty) ) 

#define IRTCBuddy2_EnumeratePresenceDevices(This,ppEnumDevices)	\
    ( (This)->lpVtbl -> EnumeratePresenceDevices(This,ppEnumDevices) ) 

#define IRTCBuddy2_get_PresenceDevices(This,ppDevicesCollection)	\
    ( (This)->lpVtbl -> get_PresenceDevices(This,ppDevicesCollection) ) 

#define IRTCBuddy2_get_SubscriptionType(This,penSubscriptionType)	\
    ( (This)->lpVtbl -> get_SubscriptionType(This,penSubscriptionType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCBuddy2_INTERFACE_DEFINED__ */


#ifndef __IRTCWatcher_INTERFACE_DEFINED__
#define __IRTCWatcher_INTERFACE_DEFINED__

/* interface IRTCWatcher */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCWatcher;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c7cedad8-346b-4d1b-ac02-a2088df9be4f")
    IRTCWatcher : public IRTCPresenceContact
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out RTC_WATCHER_STATE *penState) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_State( 
            /* [in] */ RTC_WATCHER_STATE enState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCWatcherVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCWatcher * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCWatcher * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCWatcher * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PresentityURI )( 
            __RPC__in IRTCWatcher * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPresentityURI);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PresentityURI )( 
            __RPC__in IRTCWatcher * This,
            /* [in] */ __RPC__in BSTR bstrPresentityURI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IRTCWatcher * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            __RPC__in IRTCWatcher * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Data )( 
            __RPC__in IRTCWatcher * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Data )( 
            __RPC__in IRTCWatcher * This,
            /* [in] */ __RPC__in BSTR bstrData);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Persistent )( 
            __RPC__in IRTCWatcher * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfPersistent);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Persistent )( 
            __RPC__in IRTCWatcher * This,
            /* [in] */ VARIANT_BOOL fPersistent);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            __RPC__in IRTCWatcher * This,
            /* [retval][out] */ __RPC__out RTC_WATCHER_STATE *penState);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_State )( 
            __RPC__in IRTCWatcher * This,
            /* [in] */ RTC_WATCHER_STATE enState);
        
        END_INTERFACE
    } IRTCWatcherVtbl;

    interface IRTCWatcher
    {
        CONST_VTBL struct IRTCWatcherVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCWatcher_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCWatcher_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCWatcher_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCWatcher_get_PresentityURI(This,pbstrPresentityURI)	\
    ( (This)->lpVtbl -> get_PresentityURI(This,pbstrPresentityURI) ) 

#define IRTCWatcher_put_PresentityURI(This,bstrPresentityURI)	\
    ( (This)->lpVtbl -> put_PresentityURI(This,bstrPresentityURI) ) 

#define IRTCWatcher_get_Name(This,pbstrName)	\
    ( (This)->lpVtbl -> get_Name(This,pbstrName) ) 

#define IRTCWatcher_put_Name(This,bstrName)	\
    ( (This)->lpVtbl -> put_Name(This,bstrName) ) 

#define IRTCWatcher_get_Data(This,pbstrData)	\
    ( (This)->lpVtbl -> get_Data(This,pbstrData) ) 

#define IRTCWatcher_put_Data(This,bstrData)	\
    ( (This)->lpVtbl -> put_Data(This,bstrData) ) 

#define IRTCWatcher_get_Persistent(This,pfPersistent)	\
    ( (This)->lpVtbl -> get_Persistent(This,pfPersistent) ) 

#define IRTCWatcher_put_Persistent(This,fPersistent)	\
    ( (This)->lpVtbl -> put_Persistent(This,fPersistent) ) 


#define IRTCWatcher_get_State(This,penState)	\
    ( (This)->lpVtbl -> get_State(This,penState) ) 

#define IRTCWatcher_put_State(This,enState)	\
    ( (This)->lpVtbl -> put_State(This,enState) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCWatcher_INTERFACE_DEFINED__ */


#ifndef __IRTCWatcher2_INTERFACE_DEFINED__
#define __IRTCWatcher2_INTERFACE_DEFINED__

/* interface IRTCWatcher2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCWatcher2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D4D9967F-D011-4b1d-91E3-ABA78F96393D")
    IRTCWatcher2 : public IRTCWatcher
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Profile( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile2 **ppProfile) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Scope( 
            /* [retval][out] */ __RPC__out RTC_ACE_SCOPE *penScope) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCWatcher2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCWatcher2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCWatcher2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCWatcher2 * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PresentityURI )( 
            __RPC__in IRTCWatcher2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPresentityURI);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PresentityURI )( 
            __RPC__in IRTCWatcher2 * This,
            /* [in] */ __RPC__in BSTR bstrPresentityURI);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IRTCWatcher2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            __RPC__in IRTCWatcher2 * This,
            /* [in] */ __RPC__in BSTR bstrName);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Data )( 
            __RPC__in IRTCWatcher2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Data )( 
            __RPC__in IRTCWatcher2 * This,
            /* [in] */ __RPC__in BSTR bstrData);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Persistent )( 
            __RPC__in IRTCWatcher2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfPersistent);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Persistent )( 
            __RPC__in IRTCWatcher2 * This,
            /* [in] */ VARIANT_BOOL fPersistent);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            __RPC__in IRTCWatcher2 * This,
            /* [retval][out] */ __RPC__out RTC_WATCHER_STATE *penState);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_State )( 
            __RPC__in IRTCWatcher2 * This,
            /* [in] */ RTC_WATCHER_STATE enState);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Profile )( 
            __RPC__in IRTCWatcher2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile2 **ppProfile);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Scope )( 
            __RPC__in IRTCWatcher2 * This,
            /* [retval][out] */ __RPC__out RTC_ACE_SCOPE *penScope);
        
        END_INTERFACE
    } IRTCWatcher2Vtbl;

    interface IRTCWatcher2
    {
        CONST_VTBL struct IRTCWatcher2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCWatcher2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCWatcher2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCWatcher2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCWatcher2_get_PresentityURI(This,pbstrPresentityURI)	\
    ( (This)->lpVtbl -> get_PresentityURI(This,pbstrPresentityURI) ) 

#define IRTCWatcher2_put_PresentityURI(This,bstrPresentityURI)	\
    ( (This)->lpVtbl -> put_PresentityURI(This,bstrPresentityURI) ) 

#define IRTCWatcher2_get_Name(This,pbstrName)	\
    ( (This)->lpVtbl -> get_Name(This,pbstrName) ) 

#define IRTCWatcher2_put_Name(This,bstrName)	\
    ( (This)->lpVtbl -> put_Name(This,bstrName) ) 

#define IRTCWatcher2_get_Data(This,pbstrData)	\
    ( (This)->lpVtbl -> get_Data(This,pbstrData) ) 

#define IRTCWatcher2_put_Data(This,bstrData)	\
    ( (This)->lpVtbl -> put_Data(This,bstrData) ) 

#define IRTCWatcher2_get_Persistent(This,pfPersistent)	\
    ( (This)->lpVtbl -> get_Persistent(This,pfPersistent) ) 

#define IRTCWatcher2_put_Persistent(This,fPersistent)	\
    ( (This)->lpVtbl -> put_Persistent(This,fPersistent) ) 


#define IRTCWatcher2_get_State(This,penState)	\
    ( (This)->lpVtbl -> get_State(This,penState) ) 

#define IRTCWatcher2_put_State(This,enState)	\
    ( (This)->lpVtbl -> put_State(This,enState) ) 


#define IRTCWatcher2_get_Profile(This,ppProfile)	\
    ( (This)->lpVtbl -> get_Profile(This,ppProfile) ) 

#define IRTCWatcher2_get_Scope(This,penScope)	\
    ( (This)->lpVtbl -> get_Scope(This,penScope) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCWatcher2_INTERFACE_DEFINED__ */


#ifndef __IRTCBuddyGroup_INTERFACE_DEFINED__
#define __IRTCBuddyGroup_INTERFACE_DEFINED__

/* interface IRTCBuddyGroup */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCBuddyGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("60361E68-9164-4389-A4C6-D0B3925BDA5E")
    IRTCBuddyGroup : public IUnknown
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrGroupName) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ __RPC__in BSTR bstrGroupName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddBuddy( 
            /* [in] */ __RPC__in_opt IRTCBuddy *pBuddy) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveBuddy( 
            /* [in] */ __RPC__in_opt IRTCBuddy *pBuddy) = 0;
        
        virtual /* [helpstring][hidden] */ HRESULT STDMETHODCALLTYPE EnumerateBuddies( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumBuddies **ppEnum) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Buddies( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppCollection) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Data( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrData) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Data( 
            /* [in] */ __RPC__in BSTR bstrData) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Profile( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile2 **ppProfile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCBuddyGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCBuddyGroup * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCBuddyGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCBuddyGroup * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IRTCBuddyGroup * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrGroupName);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            __RPC__in IRTCBuddyGroup * This,
            /* [in] */ __RPC__in BSTR bstrGroupName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddBuddy )( 
            __RPC__in IRTCBuddyGroup * This,
            /* [in] */ __RPC__in_opt IRTCBuddy *pBuddy);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveBuddy )( 
            __RPC__in IRTCBuddyGroup * This,
            /* [in] */ __RPC__in_opt IRTCBuddy *pBuddy);
        
        /* [helpstring][hidden] */ HRESULT ( STDMETHODCALLTYPE *EnumerateBuddies )( 
            __RPC__in IRTCBuddyGroup * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumBuddies **ppEnum);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Buddies )( 
            __RPC__in IRTCBuddyGroup * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppCollection);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Data )( 
            __RPC__in IRTCBuddyGroup * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrData);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Data )( 
            __RPC__in IRTCBuddyGroup * This,
            /* [in] */ __RPC__in BSTR bstrData);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Profile )( 
            __RPC__in IRTCBuddyGroup * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile2 **ppProfile);
        
        END_INTERFACE
    } IRTCBuddyGroupVtbl;

    interface IRTCBuddyGroup
    {
        CONST_VTBL struct IRTCBuddyGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCBuddyGroup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCBuddyGroup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCBuddyGroup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCBuddyGroup_get_Name(This,pbstrGroupName)	\
    ( (This)->lpVtbl -> get_Name(This,pbstrGroupName) ) 

#define IRTCBuddyGroup_put_Name(This,bstrGroupName)	\
    ( (This)->lpVtbl -> put_Name(This,bstrGroupName) ) 

#define IRTCBuddyGroup_AddBuddy(This,pBuddy)	\
    ( (This)->lpVtbl -> AddBuddy(This,pBuddy) ) 

#define IRTCBuddyGroup_RemoveBuddy(This,pBuddy)	\
    ( (This)->lpVtbl -> RemoveBuddy(This,pBuddy) ) 

#define IRTCBuddyGroup_EnumerateBuddies(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumerateBuddies(This,ppEnum) ) 

#define IRTCBuddyGroup_get_Buddies(This,ppCollection)	\
    ( (This)->lpVtbl -> get_Buddies(This,ppCollection) ) 

#define IRTCBuddyGroup_get_Data(This,pbstrData)	\
    ( (This)->lpVtbl -> get_Data(This,pbstrData) ) 

#define IRTCBuddyGroup_put_Data(This,bstrData)	\
    ( (This)->lpVtbl -> put_Data(This,bstrData) ) 

#define IRTCBuddyGroup_get_Profile(This,ppProfile)	\
    ( (This)->lpVtbl -> get_Profile(This,ppProfile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCBuddyGroup_INTERFACE_DEFINED__ */


#ifndef __IRTCEventNotification_INTERFACE_DEFINED__
#define __IRTCEventNotification_INTERFACE_DEFINED__

/* interface IRTCEventNotification */
/* [unique][oleautomation][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCEventNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("13fa24c7-5748-4b21-91f5-7397609ce747")
    IRTCEventNotification : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Event( 
            /* [in] */ RTC_EVENT RTCEvent,
            /* [in] */ __RPC__in_opt IDispatch *pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCEventNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCEventNotification * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCEventNotification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCEventNotification * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Event )( 
            __RPC__in IRTCEventNotification * This,
            /* [in] */ RTC_EVENT RTCEvent,
            /* [in] */ __RPC__in_opt IDispatch *pEvent);
        
        END_INTERFACE
    } IRTCEventNotificationVtbl;

    interface IRTCEventNotification
    {
        CONST_VTBL struct IRTCEventNotificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCEventNotification_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCEventNotification_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCEventNotification_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCEventNotification_Event(This,RTCEvent,pEvent)	\
    ( (This)->lpVtbl -> Event(This,RTCEvent,pEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCEventNotification_INTERFACE_DEFINED__ */


#ifndef __IRTCPortManager_INTERFACE_DEFINED__
#define __IRTCPortManager_INTERFACE_DEFINED__

/* interface IRTCPortManager */
/* [unique][oleautomation][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCPortManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DA77C14B-6208-43ca-8DDF-5B60A0A69FAC")
    IRTCPortManager : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMapping( 
            /* [in] */ __RPC__in BSTR bstrRemoteAddress,
            /* [in] */ RTC_PORT_TYPE enPortType,
            /* [out][in] */ __RPC__deref_inout_opt BSTR *pbstrInternalLocalAddress,
            /* [out][in] */ __RPC__inout long *plInternalLocalPort,
            /* [out][in] */ __RPC__deref_inout_opt BSTR *pbstrExternalLocalAddress,
            /* [out][in] */ __RPC__inout long *plExternalLocalPort) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UpdateRemoteAddress( 
            /* [in] */ __RPC__in BSTR bstrRemoteAddress,
            /* [in] */ __RPC__in BSTR bstrInternalLocalAddress,
            /* [in] */ long lInternalLocalPort,
            /* [in] */ __RPC__in BSTR bstrExternalLocalAddress,
            /* [in] */ long lExternalLocalPort) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReleaseMapping( 
            /* [in] */ __RPC__in BSTR bstrInternalLocalAddress,
            /* [in] */ long lInternalLocalPort,
            /* [in] */ __RPC__in BSTR bstrExternalLocalAddress,
            /* [in] */ long lExternalLocalAddress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCPortManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCPortManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCPortManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCPortManager * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetMapping )( 
            __RPC__in IRTCPortManager * This,
            /* [in] */ __RPC__in BSTR bstrRemoteAddress,
            /* [in] */ RTC_PORT_TYPE enPortType,
            /* [out][in] */ __RPC__deref_inout_opt BSTR *pbstrInternalLocalAddress,
            /* [out][in] */ __RPC__inout long *plInternalLocalPort,
            /* [out][in] */ __RPC__deref_inout_opt BSTR *pbstrExternalLocalAddress,
            /* [out][in] */ __RPC__inout long *plExternalLocalPort);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UpdateRemoteAddress )( 
            __RPC__in IRTCPortManager * This,
            /* [in] */ __RPC__in BSTR bstrRemoteAddress,
            /* [in] */ __RPC__in BSTR bstrInternalLocalAddress,
            /* [in] */ long lInternalLocalPort,
            /* [in] */ __RPC__in BSTR bstrExternalLocalAddress,
            /* [in] */ long lExternalLocalPort);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReleaseMapping )( 
            __RPC__in IRTCPortManager * This,
            /* [in] */ __RPC__in BSTR bstrInternalLocalAddress,
            /* [in] */ long lInternalLocalPort,
            /* [in] */ __RPC__in BSTR bstrExternalLocalAddress,
            /* [in] */ long lExternalLocalAddress);
        
        END_INTERFACE
    } IRTCPortManagerVtbl;

    interface IRTCPortManager
    {
        CONST_VTBL struct IRTCPortManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCPortManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCPortManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCPortManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCPortManager_GetMapping(This,bstrRemoteAddress,enPortType,pbstrInternalLocalAddress,plInternalLocalPort,pbstrExternalLocalAddress,plExternalLocalPort)	\
    ( (This)->lpVtbl -> GetMapping(This,bstrRemoteAddress,enPortType,pbstrInternalLocalAddress,plInternalLocalPort,pbstrExternalLocalAddress,plExternalLocalPort) ) 

#define IRTCPortManager_UpdateRemoteAddress(This,bstrRemoteAddress,bstrInternalLocalAddress,lInternalLocalPort,bstrExternalLocalAddress,lExternalLocalPort)	\
    ( (This)->lpVtbl -> UpdateRemoteAddress(This,bstrRemoteAddress,bstrInternalLocalAddress,lInternalLocalPort,bstrExternalLocalAddress,lExternalLocalPort) ) 

#define IRTCPortManager_ReleaseMapping(This,bstrInternalLocalAddress,lInternalLocalPort,bstrExternalLocalAddress,lExternalLocalAddress)	\
    ( (This)->lpVtbl -> ReleaseMapping(This,bstrInternalLocalAddress,lInternalLocalPort,bstrExternalLocalAddress,lExternalLocalAddress) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCPortManager_INTERFACE_DEFINED__ */


#ifndef __IRTCSessionPortManagement_INTERFACE_DEFINED__
#define __IRTCSessionPortManagement_INTERFACE_DEFINED__

/* interface IRTCSessionPortManagement */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCSessionPortManagement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a072f1d6-0286-4e1f-85f2-17a2948456ec")
    IRTCSessionPortManagement : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPortManager( 
            /* [in] */ __RPC__in_opt IRTCPortManager *pPortManager) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCSessionPortManagementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCSessionPortManagement * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCSessionPortManagement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCSessionPortManagement * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPortManager )( 
            __RPC__in IRTCSessionPortManagement * This,
            /* [in] */ __RPC__in_opt IRTCPortManager *pPortManager);
        
        END_INTERFACE
    } IRTCSessionPortManagementVtbl;

    interface IRTCSessionPortManagement
    {
        CONST_VTBL struct IRTCSessionPortManagementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCSessionPortManagement_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCSessionPortManagement_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCSessionPortManagement_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCSessionPortManagement_SetPortManager(This,pPortManager)	\
    ( (This)->lpVtbl -> SetPortManager(This,pPortManager) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCSessionPortManagement_INTERFACE_DEFINED__ */


#ifndef __IRTCClientPortManagement_INTERFACE_DEFINED__
#define __IRTCClientPortManagement_INTERFACE_DEFINED__

/* interface IRTCClientPortManagement */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCClientPortManagement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d5df3f03-4bde-4417-aefe-71177bdaea66")
    IRTCClientPortManagement : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartListenAddressAndPort( 
            /* [in] */ __RPC__in BSTR bstrInternalLocalAddress,
            /* [in] */ long lInternalLocalPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopListenAddressAndPort( 
            /* [in] */ __RPC__in BSTR bstrInternalLocalAddress,
            /* [in] */ long lInternalLocalPort) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPortRange( 
            /* [in] */ RTC_PORT_TYPE enPortType,
            /* [out] */ __RPC__out long *plMinValue,
            /* [out] */ __RPC__out long *plMaxValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCClientPortManagementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCClientPortManagement * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCClientPortManagement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCClientPortManagement * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartListenAddressAndPort )( 
            __RPC__in IRTCClientPortManagement * This,
            /* [in] */ __RPC__in BSTR bstrInternalLocalAddress,
            /* [in] */ long lInternalLocalPort);
        
        HRESULT ( STDMETHODCALLTYPE *StopListenAddressAndPort )( 
            __RPC__in IRTCClientPortManagement * This,
            /* [in] */ __RPC__in BSTR bstrInternalLocalAddress,
            /* [in] */ long lInternalLocalPort);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPortRange )( 
            __RPC__in IRTCClientPortManagement * This,
            /* [in] */ RTC_PORT_TYPE enPortType,
            /* [out] */ __RPC__out long *plMinValue,
            /* [out] */ __RPC__out long *plMaxValue);
        
        END_INTERFACE
    } IRTCClientPortManagementVtbl;

    interface IRTCClientPortManagement
    {
        CONST_VTBL struct IRTCClientPortManagementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCClientPortManagement_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCClientPortManagement_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCClientPortManagement_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCClientPortManagement_StartListenAddressAndPort(This,bstrInternalLocalAddress,lInternalLocalPort)	\
    ( (This)->lpVtbl -> StartListenAddressAndPort(This,bstrInternalLocalAddress,lInternalLocalPort) ) 

#define IRTCClientPortManagement_StopListenAddressAndPort(This,bstrInternalLocalAddress,lInternalLocalPort)	\
    ( (This)->lpVtbl -> StopListenAddressAndPort(This,bstrInternalLocalAddress,lInternalLocalPort) ) 

#define IRTCClientPortManagement_GetPortRange(This,enPortType,plMinValue,plMaxValue)	\
    ( (This)->lpVtbl -> GetPortRange(This,enPortType,plMinValue,plMaxValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCClientPortManagement_INTERFACE_DEFINED__ */


#ifndef __IRTCUserSearch_INTERFACE_DEFINED__
#define __IRTCUserSearch_INTERFACE_DEFINED__

/* interface IRTCUserSearch */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCUserSearch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B619882B-860C-4db4-BE1B-693B6505BBE5")
    IRTCUserSearch : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateQuery( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCUserSearchQuery **ppQuery) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ExecuteSearch( 
            /* [in] */ __RPC__in_opt IRTCUserSearchQuery *pQuery,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ LONG_PTR lCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCUserSearchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCUserSearch * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCUserSearch * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCUserSearch * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateQuery )( 
            __RPC__in IRTCUserSearch * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCUserSearchQuery **ppQuery);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ExecuteSearch )( 
            __RPC__in IRTCUserSearch * This,
            /* [in] */ __RPC__in_opt IRTCUserSearchQuery *pQuery,
            /* [in] */ __RPC__in_opt IRTCProfile *pProfile,
            /* [in] */ LONG_PTR lCookie);
        
        END_INTERFACE
    } IRTCUserSearchVtbl;

    interface IRTCUserSearch
    {
        CONST_VTBL struct IRTCUserSearchVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCUserSearch_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCUserSearch_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCUserSearch_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCUserSearch_CreateQuery(This,ppQuery)	\
    ( (This)->lpVtbl -> CreateQuery(This,ppQuery) ) 

#define IRTCUserSearch_ExecuteSearch(This,pQuery,pProfile,lCookie)	\
    ( (This)->lpVtbl -> ExecuteSearch(This,pQuery,pProfile,lCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCUserSearch_INTERFACE_DEFINED__ */


#ifndef __IRTCUserSearchQuery_INTERFACE_DEFINED__
#define __IRTCUserSearchQuery_INTERFACE_DEFINED__

/* interface IRTCUserSearchQuery */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCUserSearchQuery;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("288300F5-D23A-4365-9A73-9985C98C2881")
    IRTCUserSearchQuery : public IUnknown
    {
    public:
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_SearchTerm( 
            /* [in] */ __RPC__in BSTR bstrName,
            /* [in] */ __RPC__in BSTR bstrValue) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SearchTerm( 
            /* [in] */ __RPC__in BSTR bstrName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrValue) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SearchTerms( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrNames) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_SearchPreference( 
            /* [in] */ RTC_USER_SEARCH_PREFERENCE enPreference,
            /* [in] */ long lValue) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPreference( 
            /* [in] */ RTC_USER_SEARCH_PREFERENCE enPreference,
            /* [retval][out] */ __RPC__out long *plValue) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_SearchDomain( 
            /* [in] */ __RPC__in BSTR bstrDomain) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SearchDomain( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDomain) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCUserSearchQueryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCUserSearchQuery * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCUserSearchQuery * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCUserSearchQuery * This);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SearchTerm )( 
            __RPC__in IRTCUserSearchQuery * This,
            /* [in] */ __RPC__in BSTR bstrName,
            /* [in] */ __RPC__in BSTR bstrValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchTerm )( 
            __RPC__in IRTCUserSearchQuery * This,
            /* [in] */ __RPC__in BSTR bstrName,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchTerms )( 
            __RPC__in IRTCUserSearchQuery * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrNames);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SearchPreference )( 
            __RPC__in IRTCUserSearchQuery * This,
            /* [in] */ RTC_USER_SEARCH_PREFERENCE enPreference,
            /* [in] */ long lValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPreference )( 
            __RPC__in IRTCUserSearchQuery * This,
            /* [in] */ RTC_USER_SEARCH_PREFERENCE enPreference,
            /* [retval][out] */ __RPC__out long *plValue);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SearchDomain )( 
            __RPC__in IRTCUserSearchQuery * This,
            /* [in] */ __RPC__in BSTR bstrDomain);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchDomain )( 
            __RPC__in IRTCUserSearchQuery * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDomain);
        
        END_INTERFACE
    } IRTCUserSearchQueryVtbl;

    interface IRTCUserSearchQuery
    {
        CONST_VTBL struct IRTCUserSearchQueryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCUserSearchQuery_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCUserSearchQuery_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCUserSearchQuery_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCUserSearchQuery_put_SearchTerm(This,bstrName,bstrValue)	\
    ( (This)->lpVtbl -> put_SearchTerm(This,bstrName,bstrValue) ) 

#define IRTCUserSearchQuery_get_SearchTerm(This,bstrName,pbstrValue)	\
    ( (This)->lpVtbl -> get_SearchTerm(This,bstrName,pbstrValue) ) 

#define IRTCUserSearchQuery_get_SearchTerms(This,pbstrNames)	\
    ( (This)->lpVtbl -> get_SearchTerms(This,pbstrNames) ) 

#define IRTCUserSearchQuery_put_SearchPreference(This,enPreference,lValue)	\
    ( (This)->lpVtbl -> put_SearchPreference(This,enPreference,lValue) ) 

#define IRTCUserSearchQuery_get_SearchPreference(This,enPreference,plValue)	\
    ( (This)->lpVtbl -> get_SearchPreference(This,enPreference,plValue) ) 

#define IRTCUserSearchQuery_put_SearchDomain(This,bstrDomain)	\
    ( (This)->lpVtbl -> put_SearchDomain(This,bstrDomain) ) 

#define IRTCUserSearchQuery_get_SearchDomain(This,pbstrDomain)	\
    ( (This)->lpVtbl -> get_SearchDomain(This,pbstrDomain) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCUserSearchQuery_INTERFACE_DEFINED__ */


#ifndef __IRTCUserSearchResult_INTERFACE_DEFINED__
#define __IRTCUserSearchResult_INTERFACE_DEFINED__

/* interface IRTCUserSearchResult */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCUserSearchResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("851278B2-9592-480f-8DB5-2DE86B26B54D")
    IRTCUserSearchResult : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ RTC_USER_SEARCH_COLUMN enColumn,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCUserSearchResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCUserSearchResult * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCUserSearchResult * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCUserSearchResult * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            __RPC__in IRTCUserSearchResult * This,
            /* [in] */ RTC_USER_SEARCH_COLUMN enColumn,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrValue);
        
        END_INTERFACE
    } IRTCUserSearchResultVtbl;

    interface IRTCUserSearchResult
    {
        CONST_VTBL struct IRTCUserSearchResultVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCUserSearchResult_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCUserSearchResult_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCUserSearchResult_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCUserSearchResult_get_Value(This,enColumn,pbstrValue)	\
    ( (This)->lpVtbl -> get_Value(This,enColumn,pbstrValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCUserSearchResult_INTERFACE_DEFINED__ */


#ifndef __IRTCEnumUserSearchResults_INTERFACE_DEFINED__
#define __IRTCEnumUserSearchResults_INTERFACE_DEFINED__

/* interface IRTCEnumUserSearchResults */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCEnumUserSearchResults;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("83D4D877-AA5D-4a5b-8D0E-002A8067E0E8")
    IRTCEnumUserSearchResults : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) IRTCUserSearchResult **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumUserSearchResults **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCEnumUserSearchResultsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCEnumUserSearchResults * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCEnumUserSearchResults * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCEnumUserSearchResults * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IRTCEnumUserSearchResults * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) IRTCUserSearchResult **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IRTCEnumUserSearchResults * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IRTCEnumUserSearchResults * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IRTCEnumUserSearchResults * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumUserSearchResults **ppEnum);
        
        END_INTERFACE
    } IRTCEnumUserSearchResultsVtbl;

    interface IRTCEnumUserSearchResults
    {
        CONST_VTBL struct IRTCEnumUserSearchResultsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCEnumUserSearchResults_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCEnumUserSearchResults_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCEnumUserSearchResults_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCEnumUserSearchResults_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IRTCEnumUserSearchResults_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IRTCEnumUserSearchResults_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IRTCEnumUserSearchResults_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCEnumUserSearchResults_INTERFACE_DEFINED__ */


#ifndef __IRTCUserSearchResultsEvent_INTERFACE_DEFINED__
#define __IRTCUserSearchResultsEvent_INTERFACE_DEFINED__

/* interface IRTCUserSearchResultsEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCUserSearchResultsEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D8C8C3CD-7FAC-4088-81C5-C24CBC0938E3")
    IRTCUserSearchResultsEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE EnumerateResults( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumUserSearchResults **ppEnum) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Results( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppCollection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Profile( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile2 **ppProfile) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Query( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCUserSearchQuery **ppQuery) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Cookie( 
            /* [retval][out] */ __RPC__out LONG_PTR *plCookie) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusCode( 
            /* [retval][out] */ __RPC__out long *plStatusCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MoreAvailable( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfMoreAvailable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCUserSearchResultsEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCUserSearchResultsEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCUserSearchResultsEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCUserSearchResultsEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCUserSearchResultsEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCUserSearchResultsEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCUserSearchResultsEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCUserSearchResultsEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE *EnumerateResults )( 
            __RPC__in IRTCUserSearchResultsEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumUserSearchResults **ppEnum);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Results )( 
            __RPC__in IRTCUserSearchResultsEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCCollection **ppCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Profile )( 
            __RPC__in IRTCUserSearchResultsEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCProfile2 **ppProfile);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Query )( 
            __RPC__in IRTCUserSearchResultsEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCUserSearchQuery **ppQuery);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Cookie )( 
            __RPC__in IRTCUserSearchResultsEvent * This,
            /* [retval][out] */ __RPC__out LONG_PTR *plCookie);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusCode )( 
            __RPC__in IRTCUserSearchResultsEvent * This,
            /* [retval][out] */ __RPC__out long *plStatusCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MoreAvailable )( 
            __RPC__in IRTCUserSearchResultsEvent * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfMoreAvailable);
        
        END_INTERFACE
    } IRTCUserSearchResultsEventVtbl;

    interface IRTCUserSearchResultsEvent
    {
        CONST_VTBL struct IRTCUserSearchResultsEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCUserSearchResultsEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCUserSearchResultsEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCUserSearchResultsEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCUserSearchResultsEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCUserSearchResultsEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCUserSearchResultsEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCUserSearchResultsEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCUserSearchResultsEvent_EnumerateResults(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumerateResults(This,ppEnum) ) 

#define IRTCUserSearchResultsEvent_get_Results(This,ppCollection)	\
    ( (This)->lpVtbl -> get_Results(This,ppCollection) ) 

#define IRTCUserSearchResultsEvent_get_Profile(This,ppProfile)	\
    ( (This)->lpVtbl -> get_Profile(This,ppProfile) ) 

#define IRTCUserSearchResultsEvent_get_Query(This,ppQuery)	\
    ( (This)->lpVtbl -> get_Query(This,ppQuery) ) 

#define IRTCUserSearchResultsEvent_get_Cookie(This,plCookie)	\
    ( (This)->lpVtbl -> get_Cookie(This,plCookie) ) 

#define IRTCUserSearchResultsEvent_get_StatusCode(This,plStatusCode)	\
    ( (This)->lpVtbl -> get_StatusCode(This,plStatusCode) ) 

#define IRTCUserSearchResultsEvent_get_MoreAvailable(This,pfMoreAvailable)	\
    ( (This)->lpVtbl -> get_MoreAvailable(This,pfMoreAvailable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCUserSearchResultsEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCSessionReferStatusEvent_INTERFACE_DEFINED__
#define __IRTCSessionReferStatusEvent_INTERFACE_DEFINED__

/* interface IRTCSessionReferStatusEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCSessionReferStatusEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3D8FC2CD-5D76-44AB-BB68-2A80353B34A2")
    IRTCSessionReferStatusEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession2 **ppSession) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReferStatus( 
            /* [retval][out] */ __RPC__out RTC_SESSION_REFER_STATUS *penReferStatus) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusCode( 
            /* [retval][out] */ __RPC__out long *plStatusCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusText( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatusText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCSessionReferStatusEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCSessionReferStatusEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCSessionReferStatusEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCSessionReferStatusEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCSessionReferStatusEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCSessionReferStatusEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCSessionReferStatusEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCSessionReferStatusEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Session )( 
            __RPC__in IRTCSessionReferStatusEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession2 **ppSession);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReferStatus )( 
            __RPC__in IRTCSessionReferStatusEvent * This,
            /* [retval][out] */ __RPC__out RTC_SESSION_REFER_STATUS *penReferStatus);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusCode )( 
            __RPC__in IRTCSessionReferStatusEvent * This,
            /* [retval][out] */ __RPC__out long *plStatusCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusText )( 
            __RPC__in IRTCSessionReferStatusEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStatusText);
        
        END_INTERFACE
    } IRTCSessionReferStatusEventVtbl;

    interface IRTCSessionReferStatusEvent
    {
        CONST_VTBL struct IRTCSessionReferStatusEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCSessionReferStatusEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCSessionReferStatusEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCSessionReferStatusEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCSessionReferStatusEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCSessionReferStatusEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCSessionReferStatusEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCSessionReferStatusEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCSessionReferStatusEvent_get_Session(This,ppSession)	\
    ( (This)->lpVtbl -> get_Session(This,ppSession) ) 

#define IRTCSessionReferStatusEvent_get_ReferStatus(This,penReferStatus)	\
    ( (This)->lpVtbl -> get_ReferStatus(This,penReferStatus) ) 

#define IRTCSessionReferStatusEvent_get_StatusCode(This,plStatusCode)	\
    ( (This)->lpVtbl -> get_StatusCode(This,plStatusCode) ) 

#define IRTCSessionReferStatusEvent_get_StatusText(This,pbstrStatusText)	\
    ( (This)->lpVtbl -> get_StatusText(This,pbstrStatusText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCSessionReferStatusEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCSessionReferredEvent_INTERFACE_DEFINED__
#define __IRTCSessionReferredEvent_INTERFACE_DEFINED__

/* interface IRTCSessionReferredEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRTCSessionReferredEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("176A6828-4FCC-4F28-A862-04597A6CF1C4")
    IRTCSessionReferredEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession2 **ppSession) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReferredByURI( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrReferredByURI) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReferToURI( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrReferoURI) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReferCookie( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrReferCookie) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Accept( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reject( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetReferredSessionState( 
            /* [in] */ RTC_SESSION_STATE enState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCSessionReferredEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCSessionReferredEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCSessionReferredEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCSessionReferredEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCSessionReferredEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCSessionReferredEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCSessionReferredEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCSessionReferredEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Session )( 
            __RPC__in IRTCSessionReferredEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCSession2 **ppSession);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReferredByURI )( 
            __RPC__in IRTCSessionReferredEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrReferredByURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReferToURI )( 
            __RPC__in IRTCSessionReferredEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrReferoURI);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReferCookie )( 
            __RPC__in IRTCSessionReferredEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrReferCookie);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Accept )( 
            __RPC__in IRTCSessionReferredEvent * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reject )( 
            __RPC__in IRTCSessionReferredEvent * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetReferredSessionState )( 
            __RPC__in IRTCSessionReferredEvent * This,
            /* [in] */ RTC_SESSION_STATE enState);
        
        END_INTERFACE
    } IRTCSessionReferredEventVtbl;

    interface IRTCSessionReferredEvent
    {
        CONST_VTBL struct IRTCSessionReferredEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCSessionReferredEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCSessionReferredEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCSessionReferredEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCSessionReferredEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCSessionReferredEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCSessionReferredEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCSessionReferredEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRTCSessionReferredEvent_get_Session(This,ppSession)	\
    ( (This)->lpVtbl -> get_Session(This,ppSession) ) 

#define IRTCSessionReferredEvent_get_ReferredByURI(This,pbstrReferredByURI)	\
    ( (This)->lpVtbl -> get_ReferredByURI(This,pbstrReferredByURI) ) 

#define IRTCSessionReferredEvent_get_ReferToURI(This,pbstrReferoURI)	\
    ( (This)->lpVtbl -> get_ReferToURI(This,pbstrReferoURI) ) 

#define IRTCSessionReferredEvent_get_ReferCookie(This,pbstrReferCookie)	\
    ( (This)->lpVtbl -> get_ReferCookie(This,pbstrReferCookie) ) 

#define IRTCSessionReferredEvent_Accept(This)	\
    ( (This)->lpVtbl -> Accept(This) ) 

#define IRTCSessionReferredEvent_Reject(This)	\
    ( (This)->lpVtbl -> Reject(This) ) 

#define IRTCSessionReferredEvent_SetReferredSessionState(This,enState)	\
    ( (This)->lpVtbl -> SetReferredSessionState(This,enState) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCSessionReferredEvent_INTERFACE_DEFINED__ */


#ifndef __IRTCSessionDescriptionManager_INTERFACE_DEFINED__
#define __IRTCSessionDescriptionManager_INTERFACE_DEFINED__

/* interface IRTCSessionDescriptionManager */
/* [unique][oleautomation][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCSessionDescriptionManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BA7F518E-D336-4070-93A6-865395C843F9")
    IRTCSessionDescriptionManager : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EvaluateSessionDescription( 
            /* [in] */ __RPC__in BSTR bstrContentType,
            /* [in] */ __RPC__in BSTR bstrSessionDescription,
            /* [out][in] */ __RPC__inout VARIANT_BOOL *pfApplicationSession) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCSessionDescriptionManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCSessionDescriptionManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCSessionDescriptionManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCSessionDescriptionManager * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EvaluateSessionDescription )( 
            __RPC__in IRTCSessionDescriptionManager * This,
            /* [in] */ __RPC__in BSTR bstrContentType,
            /* [in] */ __RPC__in BSTR bstrSessionDescription,
            /* [out][in] */ __RPC__inout VARIANT_BOOL *pfApplicationSession);
        
        END_INTERFACE
    } IRTCSessionDescriptionManagerVtbl;

    interface IRTCSessionDescriptionManager
    {
        CONST_VTBL struct IRTCSessionDescriptionManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCSessionDescriptionManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCSessionDescriptionManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCSessionDescriptionManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCSessionDescriptionManager_EvaluateSessionDescription(This,bstrContentType,bstrSessionDescription,pfApplicationSession)	\
    ( (This)->lpVtbl -> EvaluateSessionDescription(This,bstrContentType,bstrSessionDescription,pfApplicationSession) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCSessionDescriptionManager_INTERFACE_DEFINED__ */


#ifndef __IRTCEnumPresenceDevices_INTERFACE_DEFINED__
#define __IRTCEnumPresenceDevices_INTERFACE_DEFINED__

/* interface IRTCEnumPresenceDevices */
/* [unique][helpstring][hidden][uuid][object] */ 


EXTERN_C const IID IID_IRTCEnumPresenceDevices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("708C2AB7-8BF8-42f8-8C7D-635197AD5539")
    IRTCEnumPresenceDevices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) IRTCPresenceDevice **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumPresenceDevices **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCEnumPresenceDevicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCEnumPresenceDevices * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCEnumPresenceDevices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCEnumPresenceDevices * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IRTCEnumPresenceDevices * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) IRTCPresenceDevice **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IRTCEnumPresenceDevices * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IRTCEnumPresenceDevices * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IRTCEnumPresenceDevices * This,
            /* [retval][out] */ __RPC__deref_out_opt IRTCEnumPresenceDevices **ppEnum);
        
        END_INTERFACE
    } IRTCEnumPresenceDevicesVtbl;

    interface IRTCEnumPresenceDevices
    {
        CONST_VTBL struct IRTCEnumPresenceDevicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCEnumPresenceDevices_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCEnumPresenceDevices_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCEnumPresenceDevices_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCEnumPresenceDevices_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IRTCEnumPresenceDevices_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IRTCEnumPresenceDevices_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IRTCEnumPresenceDevices_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCEnumPresenceDevices_INTERFACE_DEFINED__ */


#ifndef __IRTCPresenceDevice_INTERFACE_DEFINED__
#define __IRTCPresenceDevice_INTERFACE_DEFINED__

/* interface IRTCPresenceDevice */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRTCPresenceDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BC6A90DD-AD9A-48da-9B0C-2515E38521AD")
    IRTCPresenceDevice : public IUnknown
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ __RPC__out RTC_PRESENCE_STATUS *penStatus) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Notes( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrNotes) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_PresenceProperty( 
            /* [in] */ RTC_PRESENCE_PROPERTY enProperty,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProperty) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPresenceData( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrNamespace,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCPresenceDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCPresenceDevice * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCPresenceDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCPresenceDevice * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            __RPC__in IRTCPresenceDevice * This,
            /* [retval][out] */ __RPC__out RTC_PRESENCE_STATUS *penStatus);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Notes )( 
            __RPC__in IRTCPresenceDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrNotes);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PresenceProperty )( 
            __RPC__in IRTCPresenceDevice * This,
            /* [in] */ RTC_PRESENCE_PROPERTY enProperty,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrProperty);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPresenceData )( 
            __RPC__in IRTCPresenceDevice * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrNamespace,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrData);
        
        END_INTERFACE
    } IRTCPresenceDeviceVtbl;

    interface IRTCPresenceDevice
    {
        CONST_VTBL struct IRTCPresenceDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCPresenceDevice_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCPresenceDevice_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCPresenceDevice_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCPresenceDevice_get_Status(This,penStatus)	\
    ( (This)->lpVtbl -> get_Status(This,penStatus) ) 

#define IRTCPresenceDevice_get_Notes(This,pbstrNotes)	\
    ( (This)->lpVtbl -> get_Notes(This,pbstrNotes) ) 

#define IRTCPresenceDevice_get_PresenceProperty(This,enProperty,pbstrProperty)	\
    ( (This)->lpVtbl -> get_PresenceProperty(This,enProperty,pbstrProperty) ) 

#define IRTCPresenceDevice_GetPresenceData(This,pbstrNamespace,pbstrData)	\
    ( (This)->lpVtbl -> GetPresenceData(This,pbstrNamespace,pbstrData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTCPresenceDevice_INTERFACE_DEFINED__ */



#ifndef __RTCCORELib_LIBRARY_DEFINED__
#define __RTCCORELib_LIBRARY_DEFINED__

/* library RTCCORELib */
/* [helpstring][version][uuid] */ 

























































EXTERN_C const IID LIBID_RTCCORELib;

#ifndef __IRTCDispatchEventNotification_DISPINTERFACE_DEFINED__
#define __IRTCDispatchEventNotification_DISPINTERFACE_DEFINED__

/* dispinterface IRTCDispatchEventNotification */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID_IRTCDispatchEventNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("176ddfbe-fec0-4d55-bc87-84cff1ef7f91")
    IRTCDispatchEventNotification : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct IRTCDispatchEventNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRTCDispatchEventNotification * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRTCDispatchEventNotification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRTCDispatchEventNotification * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRTCDispatchEventNotification * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRTCDispatchEventNotification * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRTCDispatchEventNotification * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRTCDispatchEventNotification * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IRTCDispatchEventNotificationVtbl;

    interface IRTCDispatchEventNotification
    {
        CONST_VTBL struct IRTCDispatchEventNotificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTCDispatchEventNotification_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTCDispatchEventNotification_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTCDispatchEventNotification_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTCDispatchEventNotification_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRTCDispatchEventNotification_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRTCDispatchEventNotification_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRTCDispatchEventNotification_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __IRTCDispatchEventNotification_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_RTCClient;

#ifdef __cplusplus

class DECLSPEC_UUID("7a42ea29-a2b7-40c4-b091-f6f024aa89be")
RTCClient;
#endif
#endif /* __RTCCORELib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\sal_supp.h ===
// A temporary header to supplement sal.h with things that currently 
// cannot be put into sal.h.
// This is designed to be included at the beginning of a compilation unit
// (via force-include) if necessary.

#ifndef SAL_SUPP_H // [
#define SAL_SUPP_H

#if !defined(__midl) && defined(_PREFAST_) && _MSC_VER >= 1000 // [

// Declare a function to be an annotation or primop (respectively).
// Done this way so that they don't appear in the regular compiler's
// namespace.
#define __ANNOTATION(fun)          __declspec("SAL_annotation") void __SA_##fun
 
#define __PRIMOP(type, fun)        __declspec("SAL_primop") type __SA_##fun

// We're tying to phase this out, someday.  The parser quotes the param.
#define __AuToQuOtE                         __declspec("SAL_AuToQuOtE")

// Normally the parser does some simple type checking of annotation params,
// defer that check to the plugin.
#define __deferTypecheck                    __declspec("SAL_deferTypecheck")

__ANNOTATION(SAL_useHeader(void));
#define __useHeader                               __declspec("SAL_useHeader()")

__ANNOTATION(SAL_entrypoint(__AuToQuOtE char *, __AuToQuOtE char *));
__ANNOTATION(SAL_success(__int64));

// Only appears in model files, but needs to be declared.
//???
__ANNOTATION(SAL_TypeName(__AuToQuOtE char *));

// These are needed because the declarations below need to be after __in
// (etc.) is defined.  Once this file is merged then the 'x' vesions should
// be the standard ones.
#define __xin __declspec("SAL_pre") __declspec("SAL_valid") __declspec("SAL_pre") __declspec("SAL_deref") __declspec("SAL_readonly")

__ANNOTATION(SAL_blocksOn(__xin void*));

//__declspec("SAL_pre")
//__declspec("SAL_valid")
//__declspec("SAL_pre")
//__declspec("SAL_deref")
//__declspec("SAL_readonly")
__PRIMOP(char *, macroValue$(__xin char *));
__PRIMOP(int, macroDefined$(__xin char *));
__PRIMOP(char *, strstr$(__xin char *, __xin char *));

#else // ][

#define __ANNOTATION(fun)
#define __PRIMOP(type, fun)
#define __AuToQuOtE
#define __deferTypecheck
#define __useHeader

#endif // ]

#endif // ]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\sas.h ===
/*++

Copyright (c) 2009 Microsoft Corporation

Module Name:

    sas.h

Abstract:

    This header defines SendSAS().

Author:

    felixk 3/8/2009

--*/

#pragma once

#ifdef __cplusplus
extern "C"
{
#endif

VOID
WINAPI
SendSAS(
    __in BOOL AsUser );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\sbe.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for sbe.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __sbe_h__
#define __sbe_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IStreamBufferInitialize_FWD_DEFINED__
#define __IStreamBufferInitialize_FWD_DEFINED__
typedef interface IStreamBufferInitialize IStreamBufferInitialize;
#endif 	/* __IStreamBufferInitialize_FWD_DEFINED__ */


#ifndef __IStreamBufferSink_FWD_DEFINED__
#define __IStreamBufferSink_FWD_DEFINED__
typedef interface IStreamBufferSink IStreamBufferSink;
#endif 	/* __IStreamBufferSink_FWD_DEFINED__ */


#ifndef __IStreamBufferSink2_FWD_DEFINED__
#define __IStreamBufferSink2_FWD_DEFINED__
typedef interface IStreamBufferSink2 IStreamBufferSink2;
#endif 	/* __IStreamBufferSink2_FWD_DEFINED__ */


#ifndef __IStreamBufferSink3_FWD_DEFINED__
#define __IStreamBufferSink3_FWD_DEFINED__
typedef interface IStreamBufferSink3 IStreamBufferSink3;
#endif 	/* __IStreamBufferSink3_FWD_DEFINED__ */


#ifndef __IStreamBufferSource_FWD_DEFINED__
#define __IStreamBufferSource_FWD_DEFINED__
typedef interface IStreamBufferSource IStreamBufferSource;
#endif 	/* __IStreamBufferSource_FWD_DEFINED__ */


#ifndef __IStreamBufferRecordControl_FWD_DEFINED__
#define __IStreamBufferRecordControl_FWD_DEFINED__
typedef interface IStreamBufferRecordControl IStreamBufferRecordControl;
#endif 	/* __IStreamBufferRecordControl_FWD_DEFINED__ */


#ifndef __IStreamBufferRecComp_FWD_DEFINED__
#define __IStreamBufferRecComp_FWD_DEFINED__
typedef interface IStreamBufferRecComp IStreamBufferRecComp;
#endif 	/* __IStreamBufferRecComp_FWD_DEFINED__ */


#ifndef __IStreamBufferRecordingAttribute_FWD_DEFINED__
#define __IStreamBufferRecordingAttribute_FWD_DEFINED__
typedef interface IStreamBufferRecordingAttribute IStreamBufferRecordingAttribute;
#endif 	/* __IStreamBufferRecordingAttribute_FWD_DEFINED__ */


#ifndef __IEnumStreamBufferRecordingAttrib_FWD_DEFINED__
#define __IEnumStreamBufferRecordingAttrib_FWD_DEFINED__
typedef interface IEnumStreamBufferRecordingAttrib IEnumStreamBufferRecordingAttrib;
#endif 	/* __IEnumStreamBufferRecordingAttrib_FWD_DEFINED__ */


#ifndef __IStreamBufferConfigure_FWD_DEFINED__
#define __IStreamBufferConfigure_FWD_DEFINED__
typedef interface IStreamBufferConfigure IStreamBufferConfigure;
#endif 	/* __IStreamBufferConfigure_FWD_DEFINED__ */


#ifndef __IStreamBufferConfigure2_FWD_DEFINED__
#define __IStreamBufferConfigure2_FWD_DEFINED__
typedef interface IStreamBufferConfigure2 IStreamBufferConfigure2;
#endif 	/* __IStreamBufferConfigure2_FWD_DEFINED__ */


#ifndef __IStreamBufferConfigure3_FWD_DEFINED__
#define __IStreamBufferConfigure3_FWD_DEFINED__
typedef interface IStreamBufferConfigure3 IStreamBufferConfigure3;
#endif 	/* __IStreamBufferConfigure3_FWD_DEFINED__ */


#ifndef __IStreamBufferMediaSeeking_FWD_DEFINED__
#define __IStreamBufferMediaSeeking_FWD_DEFINED__
typedef interface IStreamBufferMediaSeeking IStreamBufferMediaSeeking;
#endif 	/* __IStreamBufferMediaSeeking_FWD_DEFINED__ */


#ifndef __IStreamBufferMediaSeeking2_FWD_DEFINED__
#define __IStreamBufferMediaSeeking2_FWD_DEFINED__
typedef interface IStreamBufferMediaSeeking2 IStreamBufferMediaSeeking2;
#endif 	/* __IStreamBufferMediaSeeking2_FWD_DEFINED__ */


#ifndef __IStreamBufferDataCounters_FWD_DEFINED__
#define __IStreamBufferDataCounters_FWD_DEFINED__
typedef interface IStreamBufferDataCounters IStreamBufferDataCounters;
#endif 	/* __IStreamBufferDataCounters_FWD_DEFINED__ */


#ifndef __ISBE2GlobalEvent_FWD_DEFINED__
#define __ISBE2GlobalEvent_FWD_DEFINED__
typedef interface ISBE2GlobalEvent ISBE2GlobalEvent;
#endif 	/* __ISBE2GlobalEvent_FWD_DEFINED__ */


#ifndef __ISBE2GlobalEvent2_FWD_DEFINED__
#define __ISBE2GlobalEvent2_FWD_DEFINED__
typedef interface ISBE2GlobalEvent2 ISBE2GlobalEvent2;
#endif 	/* __ISBE2GlobalEvent2_FWD_DEFINED__ */


#ifndef __ISBE2SpanningEvent_FWD_DEFINED__
#define __ISBE2SpanningEvent_FWD_DEFINED__
typedef interface ISBE2SpanningEvent ISBE2SpanningEvent;
#endif 	/* __ISBE2SpanningEvent_FWD_DEFINED__ */


#ifndef __ISBE2Crossbar_FWD_DEFINED__
#define __ISBE2Crossbar_FWD_DEFINED__
typedef interface ISBE2Crossbar ISBE2Crossbar;
#endif 	/* __ISBE2Crossbar_FWD_DEFINED__ */


#ifndef __ISBE2StreamMap_FWD_DEFINED__
#define __ISBE2StreamMap_FWD_DEFINED__
typedef interface ISBE2StreamMap ISBE2StreamMap;
#endif 	/* __ISBE2StreamMap_FWD_DEFINED__ */


#ifndef __ISBE2EnumStream_FWD_DEFINED__
#define __ISBE2EnumStream_FWD_DEFINED__
typedef interface ISBE2EnumStream ISBE2EnumStream;
#endif 	/* __ISBE2EnumStream_FWD_DEFINED__ */


#ifndef __ISBE2MediaTypeProfile_FWD_DEFINED__
#define __ISBE2MediaTypeProfile_FWD_DEFINED__
typedef interface ISBE2MediaTypeProfile ISBE2MediaTypeProfile;
#endif 	/* __ISBE2MediaTypeProfile_FWD_DEFINED__ */


#ifndef __ISBE2FileScan_FWD_DEFINED__
#define __ISBE2FileScan_FWD_DEFINED__
typedef interface ISBE2FileScan ISBE2FileScan;
#endif 	/* __ISBE2FileScan_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "strmif.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_sbe_0000_0000 */
/* [local] */ 


















extern RPC_IF_HANDLE __MIDL_itf_sbe_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sbe_0000_0000_v0_0_s_ifspec;

#ifndef __IStreamBufferInitialize_INTERFACE_DEFINED__
#define __IStreamBufferInitialize_INTERFACE_DEFINED__

/* interface IStreamBufferInitialize */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferInitialize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9ce50f2d-6ba7-40fb-a034-50b1a674ec78")
    IStreamBufferInitialize : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetHKEY( 
            /* [in] */ HKEY hkeyRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSIDs( 
            /* [in] */ DWORD cSIDs,
            /* [size_is][in] */ PSID *ppSID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferInitializeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStreamBufferInitialize * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStreamBufferInitialize * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStreamBufferInitialize * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetHKEY )( 
            IStreamBufferInitialize * This,
            /* [in] */ HKEY hkeyRoot);
        
        HRESULT ( STDMETHODCALLTYPE *SetSIDs )( 
            IStreamBufferInitialize * This,
            /* [in] */ DWORD cSIDs,
            /* [size_is][in] */ PSID *ppSID);
        
        END_INTERFACE
    } IStreamBufferInitializeVtbl;

    interface IStreamBufferInitialize
    {
        CONST_VTBL struct IStreamBufferInitializeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferInitialize_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamBufferInitialize_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamBufferInitialize_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamBufferInitialize_SetHKEY(This,hkeyRoot)	\
    ( (This)->lpVtbl -> SetHKEY(This,hkeyRoot) ) 

#define IStreamBufferInitialize_SetSIDs(This,cSIDs,ppSID)	\
    ( (This)->lpVtbl -> SetSIDs(This,cSIDs,ppSID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamBufferInitialize_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sbe_0000_0001 */
/* [local] */ 


enum __MIDL___MIDL_itf_sbe_0000_0001_0001
    {	RECORDING_TYPE_CONTENT	= 0,
	RECORDING_TYPE_REFERENCE	= ( RECORDING_TYPE_CONTENT + 1 ) 
    } ;


extern RPC_IF_HANDLE __MIDL_itf_sbe_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sbe_0000_0001_v0_0_s_ifspec;

#ifndef __IStreamBufferSink_INTERFACE_DEFINED__
#define __IStreamBufferSink_INTERFACE_DEFINED__

/* interface IStreamBufferSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("afd1f242-7efd-45ee-ba4e-407a25c9a77a")
    IStreamBufferSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LockProfile( 
            /* [in] */ __RPC__in LPCWSTR pszStreamBufferFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRecorder( 
            /* [in] */ __RPC__in LPCWSTR pszFilename,
            /* [in] */ DWORD dwRecordType,
            /* [out] */ __RPC__deref_out_opt IUnknown **pRecordingIUnknown) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsProfileLocked( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStreamBufferSink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStreamBufferSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStreamBufferSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockProfile )( 
            __RPC__in IStreamBufferSink * This,
            /* [in] */ __RPC__in LPCWSTR pszStreamBufferFilename);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRecorder )( 
            __RPC__in IStreamBufferSink * This,
            /* [in] */ __RPC__in LPCWSTR pszFilename,
            /* [in] */ DWORD dwRecordType,
            /* [out] */ __RPC__deref_out_opt IUnknown **pRecordingIUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *IsProfileLocked )( 
            __RPC__in IStreamBufferSink * This);
        
        END_INTERFACE
    } IStreamBufferSinkVtbl;

    interface IStreamBufferSink
    {
        CONST_VTBL struct IStreamBufferSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamBufferSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamBufferSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamBufferSink_LockProfile(This,pszStreamBufferFilename)	\
    ( (This)->lpVtbl -> LockProfile(This,pszStreamBufferFilename) ) 

#define IStreamBufferSink_CreateRecorder(This,pszFilename,dwRecordType,pRecordingIUnknown)	\
    ( (This)->lpVtbl -> CreateRecorder(This,pszFilename,dwRecordType,pRecordingIUnknown) ) 

#define IStreamBufferSink_IsProfileLocked(This)	\
    ( (This)->lpVtbl -> IsProfileLocked(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamBufferSink_INTERFACE_DEFINED__ */


#ifndef __IStreamBufferSink2_INTERFACE_DEFINED__
#define __IStreamBufferSink2_INTERFACE_DEFINED__

/* interface IStreamBufferSink2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferSink2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DB94A660-F4FB-4bfa-BCC6-FE159A4EEA93")
    IStreamBufferSink2 : public IStreamBufferSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UnlockProfile( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferSink2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStreamBufferSink2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStreamBufferSink2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStreamBufferSink2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockProfile )( 
            __RPC__in IStreamBufferSink2 * This,
            /* [in] */ __RPC__in LPCWSTR pszStreamBufferFilename);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRecorder )( 
            __RPC__in IStreamBufferSink2 * This,
            /* [in] */ __RPC__in LPCWSTR pszFilename,
            /* [in] */ DWORD dwRecordType,
            /* [out] */ __RPC__deref_out_opt IUnknown **pRecordingIUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *IsProfileLocked )( 
            __RPC__in IStreamBufferSink2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockProfile )( 
            __RPC__in IStreamBufferSink2 * This);
        
        END_INTERFACE
    } IStreamBufferSink2Vtbl;

    interface IStreamBufferSink2
    {
        CONST_VTBL struct IStreamBufferSink2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferSink2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamBufferSink2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamBufferSink2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamBufferSink2_LockProfile(This,pszStreamBufferFilename)	\
    ( (This)->lpVtbl -> LockProfile(This,pszStreamBufferFilename) ) 

#define IStreamBufferSink2_CreateRecorder(This,pszFilename,dwRecordType,pRecordingIUnknown)	\
    ( (This)->lpVtbl -> CreateRecorder(This,pszFilename,dwRecordType,pRecordingIUnknown) ) 

#define IStreamBufferSink2_IsProfileLocked(This)	\
    ( (This)->lpVtbl -> IsProfileLocked(This) ) 


#define IStreamBufferSink2_UnlockProfile(This)	\
    ( (This)->lpVtbl -> UnlockProfile(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamBufferSink2_INTERFACE_DEFINED__ */


#ifndef __IStreamBufferSink3_INTERFACE_DEFINED__
#define __IStreamBufferSink3_INTERFACE_DEFINED__

/* interface IStreamBufferSink3 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferSink3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("974723f2-887a-4452-9366-2cff3057bc8f")
    IStreamBufferSink3 : public IStreamBufferSink2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAvailableFilter( 
            /* [out][in] */ __RPC__inout REFERENCE_TIME *prtMin) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferSink3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStreamBufferSink3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStreamBufferSink3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStreamBufferSink3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockProfile )( 
            __RPC__in IStreamBufferSink3 * This,
            /* [in] */ __RPC__in LPCWSTR pszStreamBufferFilename);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRecorder )( 
            __RPC__in IStreamBufferSink3 * This,
            /* [in] */ __RPC__in LPCWSTR pszFilename,
            /* [in] */ DWORD dwRecordType,
            /* [out] */ __RPC__deref_out_opt IUnknown **pRecordingIUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *IsProfileLocked )( 
            __RPC__in IStreamBufferSink3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockProfile )( 
            __RPC__in IStreamBufferSink3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAvailableFilter )( 
            __RPC__in IStreamBufferSink3 * This,
            /* [out][in] */ __RPC__inout REFERENCE_TIME *prtMin);
        
        END_INTERFACE
    } IStreamBufferSink3Vtbl;

    interface IStreamBufferSink3
    {
        CONST_VTBL struct IStreamBufferSink3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferSink3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamBufferSink3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamBufferSink3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamBufferSink3_LockProfile(This,pszStreamBufferFilename)	\
    ( (This)->lpVtbl -> LockProfile(This,pszStreamBufferFilename) ) 

#define IStreamBufferSink3_CreateRecorder(This,pszFilename,dwRecordType,pRecordingIUnknown)	\
    ( (This)->lpVtbl -> CreateRecorder(This,pszFilename,dwRecordType,pRecordingIUnknown) ) 

#define IStreamBufferSink3_IsProfileLocked(This)	\
    ( (This)->lpVtbl -> IsProfileLocked(This) ) 


#define IStreamBufferSink3_UnlockProfile(This)	\
    ( (This)->lpVtbl -> UnlockProfile(This) ) 


#define IStreamBufferSink3_SetAvailableFilter(This,prtMin)	\
    ( (This)->lpVtbl -> SetAvailableFilter(This,prtMin) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamBufferSink3_INTERFACE_DEFINED__ */


#ifndef __IStreamBufferSource_INTERFACE_DEFINED__
#define __IStreamBufferSource_INTERFACE_DEFINED__

/* interface IStreamBufferSource */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1c5bd776-6ced-4f44-8164-5eab0e98db12")
    IStreamBufferSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetStreamSink( 
            /* [in] */ __RPC__in_opt IStreamBufferSink *pIStreamBufferSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStreamBufferSource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStreamBufferSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStreamBufferSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamSink )( 
            __RPC__in IStreamBufferSource * This,
            /* [in] */ __RPC__in_opt IStreamBufferSink *pIStreamBufferSink);
        
        END_INTERFACE
    } IStreamBufferSourceVtbl;

    interface IStreamBufferSource
    {
        CONST_VTBL struct IStreamBufferSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferSource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamBufferSource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamBufferSource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamBufferSource_SetStreamSink(This,pIStreamBufferSink)	\
    ( (This)->lpVtbl -> SetStreamSink(This,pIStreamBufferSink) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamBufferSource_INTERFACE_DEFINED__ */


#ifndef __IStreamBufferRecordControl_INTERFACE_DEFINED__
#define __IStreamBufferRecordControl_INTERFACE_DEFINED__

/* interface IStreamBufferRecordControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferRecordControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ba9b6c99-f3c7-4ff2-92db-cfdd4851bf31")
    IStreamBufferRecordControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [out][in] */ __RPC__inout REFERENCE_TIME *prtStart) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ REFERENCE_TIME rtStop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordingStatus( 
            /* [out] */ __RPC__out HRESULT *phResult,
            /* [out] */ __RPC__out BOOL *pbStarted,
            /* [out] */ __RPC__out BOOL *pbStopped) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferRecordControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStreamBufferRecordControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStreamBufferRecordControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStreamBufferRecordControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            __RPC__in IStreamBufferRecordControl * This,
            /* [out][in] */ __RPC__inout REFERENCE_TIME *prtStart);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            __RPC__in IStreamBufferRecordControl * This,
            /* [in] */ REFERENCE_TIME rtStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordingStatus )( 
            __RPC__in IStreamBufferRecordControl * This,
            /* [out] */ __RPC__out HRESULT *phResult,
            /* [out] */ __RPC__out BOOL *pbStarted,
            /* [out] */ __RPC__out BOOL *pbStopped);
        
        END_INTERFACE
    } IStreamBufferRecordControlVtbl;

    interface IStreamBufferRecordControl
    {
        CONST_VTBL struct IStreamBufferRecordControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferRecordControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamBufferRecordControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamBufferRecordControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamBufferRecordControl_Start(This,prtStart)	\
    ( (This)->lpVtbl -> Start(This,prtStart) ) 

#define IStreamBufferRecordControl_Stop(This,rtStop)	\
    ( (This)->lpVtbl -> Stop(This,rtStop) ) 

#define IStreamBufferRecordControl_GetRecordingStatus(This,phResult,pbStarted,pbStopped)	\
    ( (This)->lpVtbl -> GetRecordingStatus(This,phResult,pbStarted,pbStopped) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamBufferRecordControl_INTERFACE_DEFINED__ */


#ifndef __IStreamBufferRecComp_INTERFACE_DEFINED__
#define __IStreamBufferRecComp_INTERFACE_DEFINED__

/* interface IStreamBufferRecComp */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferRecComp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9E259A9B-8815-42ae-B09F-221970B154FD")
    IStreamBufferRecComp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in LPCWSTR pszTargetFilename,
            /* [in] */ __RPC__in LPCWSTR pszSBRecProfileRef) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in LPCWSTR pszSBRecording) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppendEx( 
            /* [in] */ __RPC__in LPCWSTR pszSBRecording,
            /* [in] */ REFERENCE_TIME rtStart,
            /* [in] */ REFERENCE_TIME rtStop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentLength( 
            /* [out] */ __RPC__out DWORD *pcSeconds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferRecCompVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStreamBufferRecComp * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStreamBufferRecComp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStreamBufferRecComp * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IStreamBufferRecComp * This,
            /* [in] */ __RPC__in LPCWSTR pszTargetFilename,
            /* [in] */ __RPC__in LPCWSTR pszSBRecProfileRef);
        
        HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IStreamBufferRecComp * This,
            /* [in] */ __RPC__in LPCWSTR pszSBRecording);
        
        HRESULT ( STDMETHODCALLTYPE *AppendEx )( 
            __RPC__in IStreamBufferRecComp * This,
            /* [in] */ __RPC__in LPCWSTR pszSBRecording,
            /* [in] */ REFERENCE_TIME rtStart,
            /* [in] */ REFERENCE_TIME rtStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentLength )( 
            __RPC__in IStreamBufferRecComp * This,
            /* [out] */ __RPC__out DWORD *pcSeconds);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            __RPC__in IStreamBufferRecComp * This);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            __RPC__in IStreamBufferRecComp * This);
        
        END_INTERFACE
    } IStreamBufferRecCompVtbl;

    interface IStreamBufferRecComp
    {
        CONST_VTBL struct IStreamBufferRecCompVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferRecComp_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamBufferRecComp_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamBufferRecComp_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamBufferRecComp_Initialize(This,pszTargetFilename,pszSBRecProfileRef)	\
    ( (This)->lpVtbl -> Initialize(This,pszTargetFilename,pszSBRecProfileRef) ) 

#define IStreamBufferRecComp_Append(This,pszSBRecording)	\
    ( (This)->lpVtbl -> Append(This,pszSBRecording) ) 

#define IStreamBufferRecComp_AppendEx(This,pszSBRecording,rtStart,rtStop)	\
    ( (This)->lpVtbl -> AppendEx(This,pszSBRecording,rtStart,rtStop) ) 

#define IStreamBufferRecComp_GetCurrentLength(This,pcSeconds)	\
    ( (This)->lpVtbl -> GetCurrentLength(This,pcSeconds) ) 

#define IStreamBufferRecComp_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IStreamBufferRecComp_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamBufferRecComp_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sbe_0000_0007 */
/* [local] */ 

////////////////////////////////////////////////////////////////
//
// List of pre-defined attributes 
//
static const WCHAR g_wszStreamBufferRecordingDuration[] =L"Duration";
static const WCHAR g_wszStreamBufferRecordingBitrate[] =L"Bitrate";
static const WCHAR g_wszStreamBufferRecordingSeekable[] =L"Seekable";
static const WCHAR g_wszStreamBufferRecordingStridable[] =L"Stridable";
static const WCHAR g_wszStreamBufferRecordingBroadcast[] =L"Broadcast";
static const WCHAR g_wszStreamBufferRecordingProtected[] =L"Is_Protected";
static const WCHAR g_wszStreamBufferRecordingTrusted[] =L"Is_Trusted";
static const WCHAR g_wszStreamBufferRecordingSignature_Name[] =L"Signature_Name";
static const WCHAR g_wszStreamBufferRecordingHasAudio[] =L"HasAudio";
static const WCHAR g_wszStreamBufferRecordingHasImage[] =L"HasImage";
static const WCHAR g_wszStreamBufferRecordingHasScript[] =L"HasScript";
static const WCHAR g_wszStreamBufferRecordingHasVideo[] =L"HasVideo";
static const WCHAR g_wszStreamBufferRecordingCurrentBitrate[] =L"CurrentBitrate";
static const WCHAR g_wszStreamBufferRecordingOptimalBitrate[] =L"OptimalBitrate";
static const WCHAR g_wszStreamBufferRecordingHasAttachedImages[] =L"HasAttachedImages";
static const WCHAR g_wszStreamBufferRecordingSkipBackward[] =L"Can_Skip_Backward";
static const WCHAR g_wszStreamBufferRecordingSkipForward[] =L"Can_Skip_Forward";
static const WCHAR g_wszStreamBufferRecordingNumberOfFrames[] =L"NumberOfFrames";
static const WCHAR g_wszStreamBufferRecordingFileSize[] =L"FileSize";
static const WCHAR g_wszStreamBufferRecordingHasArbitraryDataStream[] =L"HasArbitraryDataStream";
static const WCHAR g_wszStreamBufferRecordingHasFileTransferStream[] =L"HasFileTransferStream";

////////////////////////////////////////////////////////////////
//
// The content description object supports 5 basic attributes.
//
static const WCHAR g_wszStreamBufferRecordingTitle[] =L"Title";
static const WCHAR g_wszStreamBufferRecordingAuthor[] =L"Author";
static const WCHAR g_wszStreamBufferRecordingDescription[] =L"Description";
static const WCHAR g_wszStreamBufferRecordingRating[] =L"Rating";
static const WCHAR g_wszStreamBufferRecordingCopyright[] =L"Copyright";

////////////////////////////////////////////////////////////////
//
// These attributes are used to configure DRM using IWMDRMWriter::SetDRMAttribute.
//
static const WCHAR *g_wszStreamBufferRecordingUse_DRM = L"Use_DRM";
static const WCHAR *g_wszStreamBufferRecordingDRM_Flags = L"DRM_Flags";
static const WCHAR *g_wszStreamBufferRecordingDRM_Level = L"DRM_Level";

////////////////////////////////////////////////////////////////
//
// These are the additional attributes defined in the WM attribute
// namespace that give information about the content.
//
static const WCHAR g_wszStreamBufferRecordingAlbumTitle[] =L"WM/AlbumTitle";
static const WCHAR g_wszStreamBufferRecordingTrack[] =L"WM/Track";
static const WCHAR g_wszStreamBufferRecordingPromotionURL[] =L"WM/PromotionURL";
static const WCHAR g_wszStreamBufferRecordingAlbumCoverURL[] =L"WM/AlbumCoverURL";
static const WCHAR g_wszStreamBufferRecordingGenre[] =L"WM/Genre";
static const WCHAR g_wszStreamBufferRecordingYear[] =L"WM/Year";
static const WCHAR g_wszStreamBufferRecordingGenreID[] =L"WM/GenreID";
static const WCHAR g_wszStreamBufferRecordingMCDI[] =L"WM/MCDI";
static const WCHAR g_wszStreamBufferRecordingComposer[] =L"WM/Composer";
static const WCHAR g_wszStreamBufferRecordingLyrics[] =L"WM/Lyrics";
static const WCHAR g_wszStreamBufferRecordingTrackNumber[] =L"WM/TrackNumber";
static const WCHAR g_wszStreamBufferRecordingToolName[] =L"WM/ToolName";
static const WCHAR g_wszStreamBufferRecordingToolVersion[] =L"WM/ToolVersion";
static const WCHAR g_wszStreamBufferRecordingIsVBR[] =L"IsVBR";
static const WCHAR g_wszStreamBufferRecordingAlbumArtist[] =L"WM/AlbumArtist";

////////////////////////////////////////////////////////////////
//
// These optional attributes may be used to give information 
// about the branding of the content.
//
static const WCHAR g_wszStreamBufferRecordingBannerImageType[] =L"BannerImageType";
static const WCHAR g_wszStreamBufferRecordingBannerImageData[] =L"BannerImageData";
static const WCHAR g_wszStreamBufferRecordingBannerImageURL[] =L"BannerImageURL";
static const WCHAR g_wszStreamBufferRecordingCopyrightURL[] =L"CopyrightURL";
////////////////////////////////////////////////////////////////
//
// Optional attributes, used to give information 
// about video stream properties.
//
static const WCHAR g_wszStreamBufferRecordingAspectRatioX[] =L"AspectRatioX";
static const WCHAR g_wszStreamBufferRecordingAspectRatioY[] =L"AspectRatioY";
////////////////////////////////////////////////////////////////
//
// The NSC file supports the following attributes.
//
static const WCHAR g_wszStreamBufferRecordingNSCName[] =L"NSC_Name";
static const WCHAR g_wszStreamBufferRecordingNSCAddress[] =L"NSC_Address";
static const WCHAR g_wszStreamBufferRecordingNSCPhone[] =L"NSC_Phone";
static const WCHAR g_wszStreamBufferRecordingNSCEmail[] =L"NSC_Email";
static const WCHAR g_wszStreamBufferRecordingNSCDescription[] =L"NSC_Description";

typedef /* [v1_enum][uuid] */  DECLSPEC_UUID("99038221-f409-4d44-8313-bff73269a85e") 
enum STREAMBUFFER_ATTR_DATATYPE
    {	STREAMBUFFER_TYPE_DWORD	= 0,
	STREAMBUFFER_TYPE_STRING	= 1,
	STREAMBUFFER_TYPE_BINARY	= 2,
	STREAMBUFFER_TYPE_BOOL	= 3,
	STREAMBUFFER_TYPE_QWORD	= 4,
	STREAMBUFFER_TYPE_WORD	= 5,
	STREAMBUFFER_TYPE_GUID	= 6
    } 	STREAMBUFFER_ATTR_DATATYPE;



extern RPC_IF_HANDLE __MIDL_itf_sbe_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sbe_0000_0007_v0_0_s_ifspec;

#ifndef __IStreamBufferRecordingAttribute_INTERFACE_DEFINED__
#define __IStreamBufferRecordingAttribute_INTERFACE_DEFINED__

/* interface IStreamBufferRecordingAttribute */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferRecordingAttribute;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("16CA4E03-FE69-4705-BD41-5B7DFC0C95F3")
    IStreamBufferRecordingAttribute : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAttribute( 
            /* [in] */ ULONG ulReserved,
            /* [in] */ __RPC__in LPCWSTR pszAttributeName,
            /* [in] */ STREAMBUFFER_ATTR_DATATYPE StreamBufferAttributeType,
            /* [size_is][in] */ __RPC__in_ecount_full(cbAttributeLength) BYTE *pbAttribute,
            /* [in] */ WORD cbAttributeLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeCount( 
            /* [in] */ ULONG ulReserved,
            /* [out] */ __RPC__out WORD *pcAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeByName( 
            /* [in] */ __RPC__in LPCWSTR pszAttributeName,
            /* [in] */ __RPC__in ULONG *pulReserved,
            /* [out] */ __RPC__out STREAMBUFFER_ATTR_DATATYPE *pStreamBufferAttributeType,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbLength) BYTE *pbAttribute,
            /* [out][in] */ __RPC__inout WORD *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeByIndex( 
            /* [in] */ WORD wIndex,
            /* [in] */ __RPC__in ULONG *pulReserved,
            /* [out] */ __RPC__out WCHAR *pszAttributeName,
            /* [out][in] */ __RPC__inout WORD *pcchNameLength,
            /* [out] */ __RPC__out STREAMBUFFER_ATTR_DATATYPE *pStreamBufferAttributeType,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbLength) BYTE *pbAttribute,
            /* [out][in] */ __RPC__inout WORD *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAttributes( 
            /* [out] */ __RPC__deref_out_opt IEnumStreamBufferRecordingAttrib **ppIEnumStreamBufferAttrib) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferRecordingAttributeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStreamBufferRecordingAttribute * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStreamBufferRecordingAttribute * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStreamBufferRecordingAttribute * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAttribute )( 
            __RPC__in IStreamBufferRecordingAttribute * This,
            /* [in] */ ULONG ulReserved,
            /* [in] */ __RPC__in LPCWSTR pszAttributeName,
            /* [in] */ STREAMBUFFER_ATTR_DATATYPE StreamBufferAttributeType,
            /* [size_is][in] */ __RPC__in_ecount_full(cbAttributeLength) BYTE *pbAttribute,
            /* [in] */ WORD cbAttributeLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeCount )( 
            __RPC__in IStreamBufferRecordingAttribute * This,
            /* [in] */ ULONG ulReserved,
            /* [out] */ __RPC__out WORD *pcAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeByName )( 
            __RPC__in IStreamBufferRecordingAttribute * This,
            /* [in] */ __RPC__in LPCWSTR pszAttributeName,
            /* [in] */ __RPC__in ULONG *pulReserved,
            /* [out] */ __RPC__out STREAMBUFFER_ATTR_DATATYPE *pStreamBufferAttributeType,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbLength) BYTE *pbAttribute,
            /* [out][in] */ __RPC__inout WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeByIndex )( 
            __RPC__in IStreamBufferRecordingAttribute * This,
            /* [in] */ WORD wIndex,
            /* [in] */ __RPC__in ULONG *pulReserved,
            /* [out] */ __RPC__out WCHAR *pszAttributeName,
            /* [out][in] */ __RPC__inout WORD *pcchNameLength,
            /* [out] */ __RPC__out STREAMBUFFER_ATTR_DATATYPE *pStreamBufferAttributeType,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbLength) BYTE *pbAttribute,
            /* [out][in] */ __RPC__inout WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAttributes )( 
            __RPC__in IStreamBufferRecordingAttribute * This,
            /* [out] */ __RPC__deref_out_opt IEnumStreamBufferRecordingAttrib **ppIEnumStreamBufferAttrib);
        
        END_INTERFACE
    } IStreamBufferRecordingAttributeVtbl;

    interface IStreamBufferRecordingAttribute
    {
        CONST_VTBL struct IStreamBufferRecordingAttributeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferRecordingAttribute_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamBufferRecordingAttribute_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamBufferRecordingAttribute_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamBufferRecordingAttribute_SetAttribute(This,ulReserved,pszAttributeName,StreamBufferAttributeType,pbAttribute,cbAttributeLength)	\
    ( (This)->lpVtbl -> SetAttribute(This,ulReserved,pszAttributeName,StreamBufferAttributeType,pbAttribute,cbAttributeLength) ) 

#define IStreamBufferRecordingAttribute_GetAttributeCount(This,ulReserved,pcAttributes)	\
    ( (This)->lpVtbl -> GetAttributeCount(This,ulReserved,pcAttributes) ) 

#define IStreamBufferRecordingAttribute_GetAttributeByName(This,pszAttributeName,pulReserved,pStreamBufferAttributeType,pbAttribute,pcbLength)	\
    ( (This)->lpVtbl -> GetAttributeByName(This,pszAttributeName,pulReserved,pStreamBufferAttributeType,pbAttribute,pcbLength) ) 

#define IStreamBufferRecordingAttribute_GetAttributeByIndex(This,wIndex,pulReserved,pszAttributeName,pcchNameLength,pStreamBufferAttributeType,pbAttribute,pcbLength)	\
    ( (This)->lpVtbl -> GetAttributeByIndex(This,wIndex,pulReserved,pszAttributeName,pcchNameLength,pStreamBufferAttributeType,pbAttribute,pcbLength) ) 

#define IStreamBufferRecordingAttribute_EnumAttributes(This,ppIEnumStreamBufferAttrib)	\
    ( (This)->lpVtbl -> EnumAttributes(This,ppIEnumStreamBufferAttrib) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamBufferRecordingAttribute_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sbe_0000_0008 */
/* [local] */ 

typedef struct STREAMBUFFER_ATTRIBUTE
    {
    LPWSTR pszName;
    STREAMBUFFER_ATTR_DATATYPE StreamBufferAttributeType;
    BYTE *pbAttribute;
    WORD cbLength;
    } 	STREAMBUFFER_ATTRIBUTE;



extern RPC_IF_HANDLE __MIDL_itf_sbe_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sbe_0000_0008_v0_0_s_ifspec;

#ifndef __IEnumStreamBufferRecordingAttrib_INTERFACE_DEFINED__
#define __IEnumStreamBufferRecordingAttrib_INTERFACE_DEFINED__

/* interface IEnumStreamBufferRecordingAttrib */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumStreamBufferRecordingAttrib;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C18A9162-1E82-4142-8C73-5690FA62FE33")
    IEnumStreamBufferRecordingAttrib : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cRequest,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(cRequest) STREAMBUFFER_ATTRIBUTE *pStreamBufferAttribute,
            /* [out] */ __RPC__out ULONG *pcReceived) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cRecords) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumStreamBufferRecordingAttrib **ppIEnumStreamBufferAttrib) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumStreamBufferRecordingAttribVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumStreamBufferRecordingAttrib * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumStreamBufferRecordingAttrib * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumStreamBufferRecordingAttrib * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumStreamBufferRecordingAttrib * This,
            /* [in] */ ULONG cRequest,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(cRequest) STREAMBUFFER_ATTRIBUTE *pStreamBufferAttribute,
            /* [out] */ __RPC__out ULONG *pcReceived);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumStreamBufferRecordingAttrib * This,
            /* [in] */ ULONG cRecords);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumStreamBufferRecordingAttrib * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumStreamBufferRecordingAttrib * This,
            /* [out] */ __RPC__deref_out_opt IEnumStreamBufferRecordingAttrib **ppIEnumStreamBufferAttrib);
        
        END_INTERFACE
    } IEnumStreamBufferRecordingAttribVtbl;

    interface IEnumStreamBufferRecordingAttrib
    {
        CONST_VTBL struct IEnumStreamBufferRecordingAttribVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumStreamBufferRecordingAttrib_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumStreamBufferRecordingAttrib_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumStreamBufferRecordingAttrib_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumStreamBufferRecordingAttrib_Next(This,cRequest,pStreamBufferAttribute,pcReceived)	\
    ( (This)->lpVtbl -> Next(This,cRequest,pStreamBufferAttribute,pcReceived) ) 

#define IEnumStreamBufferRecordingAttrib_Skip(This,cRecords)	\
    ( (This)->lpVtbl -> Skip(This,cRecords) ) 

#define IEnumStreamBufferRecordingAttrib_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumStreamBufferRecordingAttrib_Clone(This,ppIEnumStreamBufferAttrib)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnumStreamBufferAttrib) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumStreamBufferRecordingAttrib_INTERFACE_DEFINED__ */


#ifndef __IStreamBufferConfigure_INTERFACE_DEFINED__
#define __IStreamBufferConfigure_INTERFACE_DEFINED__

/* interface IStreamBufferConfigure */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferConfigure;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ce14dfae-4098-4af7-bbf7-d6511f835414")
    IStreamBufferConfigure : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDirectory( 
            /* [in] */ __RPC__in LPCWSTR pszDirectoryName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDirectory( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszDirectoryName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackingFileCount( 
            /* [in] */ DWORD dwMin,
            /* [in] */ DWORD dwMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackingFileCount( 
            /* [out] */ __RPC__out DWORD *pdwMin,
            /* [out] */ __RPC__out DWORD *pdwMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackingFileDuration( 
            /* [in] */ DWORD dwSeconds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackingFileDuration( 
            /* [out] */ __RPC__out DWORD *pdwSeconds) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferConfigureVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStreamBufferConfigure * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStreamBufferConfigure * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStreamBufferConfigure * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDirectory )( 
            __RPC__in IStreamBufferConfigure * This,
            /* [in] */ __RPC__in LPCWSTR pszDirectoryName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDirectory )( 
            __RPC__in IStreamBufferConfigure * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszDirectoryName);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackingFileCount )( 
            __RPC__in IStreamBufferConfigure * This,
            /* [in] */ DWORD dwMin,
            /* [in] */ DWORD dwMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetBackingFileCount )( 
            __RPC__in IStreamBufferConfigure * This,
            /* [out] */ __RPC__out DWORD *pdwMin,
            /* [out] */ __RPC__out DWORD *pdwMax);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackingFileDuration )( 
            __RPC__in IStreamBufferConfigure * This,
            /* [in] */ DWORD dwSeconds);
        
        HRESULT ( STDMETHODCALLTYPE *GetBackingFileDuration )( 
            __RPC__in IStreamBufferConfigure * This,
            /* [out] */ __RPC__out DWORD *pdwSeconds);
        
        END_INTERFACE
    } IStreamBufferConfigureVtbl;

    interface IStreamBufferConfigure
    {
        CONST_VTBL struct IStreamBufferConfigureVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferConfigure_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamBufferConfigure_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamBufferConfigure_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamBufferConfigure_SetDirectory(This,pszDirectoryName)	\
    ( (This)->lpVtbl -> SetDirectory(This,pszDirectoryName) ) 

#define IStreamBufferConfigure_GetDirectory(This,ppszDirectoryName)	\
    ( (This)->lpVtbl -> GetDirectory(This,ppszDirectoryName) ) 

#define IStreamBufferConfigure_SetBackingFileCount(This,dwMin,dwMax)	\
    ( (This)->lpVtbl -> SetBackingFileCount(This,dwMin,dwMax) ) 

#define IStreamBufferConfigure_GetBackingFileCount(This,pdwMin,pdwMax)	\
    ( (This)->lpVtbl -> GetBackingFileCount(This,pdwMin,pdwMax) ) 

#define IStreamBufferConfigure_SetBackingFileDuration(This,dwSeconds)	\
    ( (This)->lpVtbl -> SetBackingFileDuration(This,dwSeconds) ) 

#define IStreamBufferConfigure_GetBackingFileDuration(This,pdwSeconds)	\
    ( (This)->lpVtbl -> GetBackingFileDuration(This,pdwSeconds) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamBufferConfigure_INTERFACE_DEFINED__ */


#ifndef __IStreamBufferConfigure2_INTERFACE_DEFINED__
#define __IStreamBufferConfigure2_INTERFACE_DEFINED__

/* interface IStreamBufferConfigure2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferConfigure2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("53E037BF-3992-4282-AE34-2487B4DAE06B")
    IStreamBufferConfigure2 : public IStreamBufferConfigure
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMultiplexedPacketSize( 
            /* [in] */ DWORD cbBytesPerPacket) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMultiplexedPacketSize( 
            /* [out] */ __RPC__out DWORD *pcbBytesPerPacket) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFFTransitionRates( 
            /* [in] */ DWORD dwMaxFullFrameRate,
            /* [in] */ DWORD dwMaxNonSkippingRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFFTransitionRates( 
            /* [out] */ __RPC__out DWORD *pdwMaxFullFrameRate,
            /* [out] */ __RPC__out DWORD *pdwMaxNonSkippingRate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferConfigure2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStreamBufferConfigure2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStreamBufferConfigure2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStreamBufferConfigure2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDirectory )( 
            __RPC__in IStreamBufferConfigure2 * This,
            /* [in] */ __RPC__in LPCWSTR pszDirectoryName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDirectory )( 
            __RPC__in IStreamBufferConfigure2 * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszDirectoryName);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackingFileCount )( 
            __RPC__in IStreamBufferConfigure2 * This,
            /* [in] */ DWORD dwMin,
            /* [in] */ DWORD dwMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetBackingFileCount )( 
            __RPC__in IStreamBufferConfigure2 * This,
            /* [out] */ __RPC__out DWORD *pdwMin,
            /* [out] */ __RPC__out DWORD *pdwMax);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackingFileDuration )( 
            __RPC__in IStreamBufferConfigure2 * This,
            /* [in] */ DWORD dwSeconds);
        
        HRESULT ( STDMETHODCALLTYPE *GetBackingFileDuration )( 
            __RPC__in IStreamBufferConfigure2 * This,
            /* [out] */ __RPC__out DWORD *pdwSeconds);
        
        HRESULT ( STDMETHODCALLTYPE *SetMultiplexedPacketSize )( 
            __RPC__in IStreamBufferConfigure2 * This,
            /* [in] */ DWORD cbBytesPerPacket);
        
        HRESULT ( STDMETHODCALLTYPE *GetMultiplexedPacketSize )( 
            __RPC__in IStreamBufferConfigure2 * This,
            /* [out] */ __RPC__out DWORD *pcbBytesPerPacket);
        
        HRESULT ( STDMETHODCALLTYPE *SetFFTransitionRates )( 
            __RPC__in IStreamBufferConfigure2 * This,
            /* [in] */ DWORD dwMaxFullFrameRate,
            /* [in] */ DWORD dwMaxNonSkippingRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetFFTransitionRates )( 
            __RPC__in IStreamBufferConfigure2 * This,
            /* [out] */ __RPC__out DWORD *pdwMaxFullFrameRate,
            /* [out] */ __RPC__out DWORD *pdwMaxNonSkippingRate);
        
        END_INTERFACE
    } IStreamBufferConfigure2Vtbl;

    interface IStreamBufferConfigure2
    {
        CONST_VTBL struct IStreamBufferConfigure2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferConfigure2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamBufferConfigure2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamBufferConfigure2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamBufferConfigure2_SetDirectory(This,pszDirectoryName)	\
    ( (This)->lpVtbl -> SetDirectory(This,pszDirectoryName) ) 

#define IStreamBufferConfigure2_GetDirectory(This,ppszDirectoryName)	\
    ( (This)->lpVtbl -> GetDirectory(This,ppszDirectoryName) ) 

#define IStreamBufferConfigure2_SetBackingFileCount(This,dwMin,dwMax)	\
    ( (This)->lpVtbl -> SetBackingFileCount(This,dwMin,dwMax) ) 

#define IStreamBufferConfigure2_GetBackingFileCount(This,pdwMin,pdwMax)	\
    ( (This)->lpVtbl -> GetBackingFileCount(This,pdwMin,pdwMax) ) 

#define IStreamBufferConfigure2_SetBackingFileDuration(This,dwSeconds)	\
    ( (This)->lpVtbl -> SetBackingFileDuration(This,dwSeconds) ) 

#define IStreamBufferConfigure2_GetBackingFileDuration(This,pdwSeconds)	\
    ( (This)->lpVtbl -> GetBackingFileDuration(This,pdwSeconds) ) 


#define IStreamBufferConfigure2_SetMultiplexedPacketSize(This,cbBytesPerPacket)	\
    ( (This)->lpVtbl -> SetMultiplexedPacketSize(This,cbBytesPerPacket) ) 

#define IStreamBufferConfigure2_GetMultiplexedPacketSize(This,pcbBytesPerPacket)	\
    ( (This)->lpVtbl -> GetMultiplexedPacketSize(This,pcbBytesPerPacket) ) 

#define IStreamBufferConfigure2_SetFFTransitionRates(This,dwMaxFullFrameRate,dwMaxNonSkippingRate)	\
    ( (This)->lpVtbl -> SetFFTransitionRates(This,dwMaxFullFrameRate,dwMaxNonSkippingRate) ) 

#define IStreamBufferConfigure2_GetFFTransitionRates(This,pdwMaxFullFrameRate,pdwMaxNonSkippingRate)	\
    ( (This)->lpVtbl -> GetFFTransitionRates(This,pdwMaxFullFrameRate,pdwMaxNonSkippingRate) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamBufferConfigure2_INTERFACE_DEFINED__ */


#ifndef __IStreamBufferConfigure3_INTERFACE_DEFINED__
#define __IStreamBufferConfigure3_INTERFACE_DEFINED__

/* interface IStreamBufferConfigure3 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferConfigure3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7E2D2A1E-7192-4bd7-80C1-061FD1D10402")
    IStreamBufferConfigure3 : public IStreamBufferConfigure2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetStartRecConfig( 
            /* [in] */ BOOL fStartStopsCur) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStartRecConfig( 
            /* [out] */ __RPC__out BOOL *pfStartStopsCur) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNamespace( 
            /* [in] */ __RPC__in LPWSTR pszNamespace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespace( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszNamespace) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferConfigure3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStreamBufferConfigure3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStreamBufferConfigure3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStreamBufferConfigure3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDirectory )( 
            __RPC__in IStreamBufferConfigure3 * This,
            /* [in] */ __RPC__in LPCWSTR pszDirectoryName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDirectory )( 
            __RPC__in IStreamBufferConfigure3 * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszDirectoryName);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackingFileCount )( 
            __RPC__in IStreamBufferConfigure3 * This,
            /* [in] */ DWORD dwMin,
            /* [in] */ DWORD dwMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetBackingFileCount )( 
            __RPC__in IStreamBufferConfigure3 * This,
            /* [out] */ __RPC__out DWORD *pdwMin,
            /* [out] */ __RPC__out DWORD *pdwMax);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackingFileDuration )( 
            __RPC__in IStreamBufferConfigure3 * This,
            /* [in] */ DWORD dwSeconds);
        
        HRESULT ( STDMETHODCALLTYPE *GetBackingFileDuration )( 
            __RPC__in IStreamBufferConfigure3 * This,
            /* [out] */ __RPC__out DWORD *pdwSeconds);
        
        HRESULT ( STDMETHODCALLTYPE *SetMultiplexedPacketSize )( 
            __RPC__in IStreamBufferConfigure3 * This,
            /* [in] */ DWORD cbBytesPerPacket);
        
        HRESULT ( STDMETHODCALLTYPE *GetMultiplexedPacketSize )( 
            __RPC__in IStreamBufferConfigure3 * This,
            /* [out] */ __RPC__out DWORD *pcbBytesPerPacket);
        
        HRESULT ( STDMETHODCALLTYPE *SetFFTransitionRates )( 
            __RPC__in IStreamBufferConfigure3 * This,
            /* [in] */ DWORD dwMaxFullFrameRate,
            /* [in] */ DWORD dwMaxNonSkippingRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetFFTransitionRates )( 
            __RPC__in IStreamBufferConfigure3 * This,
            /* [out] */ __RPC__out DWORD *pdwMaxFullFrameRate,
            /* [out] */ __RPC__out DWORD *pdwMaxNonSkippingRate);
        
        HRESULT ( STDMETHODCALLTYPE *SetStartRecConfig )( 
            __RPC__in IStreamBufferConfigure3 * This,
            /* [in] */ BOOL fStartStopsCur);
        
        HRESULT ( STDMETHODCALLTYPE *GetStartRecConfig )( 
            __RPC__in IStreamBufferConfigure3 * This,
            /* [out] */ __RPC__out BOOL *pfStartStopsCur);
        
        HRESULT ( STDMETHODCALLTYPE *SetNamespace )( 
            __RPC__in IStreamBufferConfigure3 * This,
            /* [in] */ __RPC__in LPWSTR pszNamespace);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamespace )( 
            __RPC__in IStreamBufferConfigure3 * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszNamespace);
        
        END_INTERFACE
    } IStreamBufferConfigure3Vtbl;

    interface IStreamBufferConfigure3
    {
        CONST_VTBL struct IStreamBufferConfigure3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferConfigure3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamBufferConfigure3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamBufferConfigure3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamBufferConfigure3_SetDirectory(This,pszDirectoryName)	\
    ( (This)->lpVtbl -> SetDirectory(This,pszDirectoryName) ) 

#define IStreamBufferConfigure3_GetDirectory(This,ppszDirectoryName)	\
    ( (This)->lpVtbl -> GetDirectory(This,ppszDirectoryName) ) 

#define IStreamBufferConfigure3_SetBackingFileCount(This,dwMin,dwMax)	\
    ( (This)->lpVtbl -> SetBackingFileCount(This,dwMin,dwMax) ) 

#define IStreamBufferConfigure3_GetBackingFileCount(This,pdwMin,pdwMax)	\
    ( (This)->lpVtbl -> GetBackingFileCount(This,pdwMin,pdwMax) ) 

#define IStreamBufferConfigure3_SetBackingFileDuration(This,dwSeconds)	\
    ( (This)->lpVtbl -> SetBackingFileDuration(This,dwSeconds) ) 

#define IStreamBufferConfigure3_GetBackingFileDuration(This,pdwSeconds)	\
    ( (This)->lpVtbl -> GetBackingFileDuration(This,pdwSeconds) ) 


#define IStreamBufferConfigure3_SetMultiplexedPacketSize(This,cbBytesPerPacket)	\
    ( (This)->lpVtbl -> SetMultiplexedPacketSize(This,cbBytesPerPacket) ) 

#define IStreamBufferConfigure3_GetMultiplexedPacketSize(This,pcbBytesPerPacket)	\
    ( (This)->lpVtbl -> GetMultiplexedPacketSize(This,pcbBytesPerPacket) ) 

#define IStreamBufferConfigure3_SetFFTransitionRates(This,dwMaxFullFrameRate,dwMaxNonSkippingRate)	\
    ( (This)->lpVtbl -> SetFFTransitionRates(This,dwMaxFullFrameRate,dwMaxNonSkippingRate) ) 

#define IStreamBufferConfigure3_GetFFTransitionRates(This,pdwMaxFullFrameRate,pdwMaxNonSkippingRate)	\
    ( (This)->lpVtbl -> GetFFTransitionRates(This,pdwMaxFullFrameRate,pdwMaxNonSkippingRate) ) 


#define IStreamBufferConfigure3_SetStartRecConfig(This,fStartStopsCur)	\
    ( (This)->lpVtbl -> SetStartRecConfig(This,fStartStopsCur) ) 

#define IStreamBufferConfigure3_GetStartRecConfig(This,pfStartStopsCur)	\
    ( (This)->lpVtbl -> GetStartRecConfig(This,pfStartStopsCur) ) 

#define IStreamBufferConfigure3_SetNamespace(This,pszNamespace)	\
    ( (This)->lpVtbl -> SetNamespace(This,pszNamespace) ) 

#define IStreamBufferConfigure3_GetNamespace(This,ppszNamespace)	\
    ( (This)->lpVtbl -> GetNamespace(This,ppszNamespace) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamBufferConfigure3_INTERFACE_DEFINED__ */


#ifndef __IStreamBufferMediaSeeking_INTERFACE_DEFINED__
#define __IStreamBufferMediaSeeking_INTERFACE_DEFINED__

/* interface IStreamBufferMediaSeeking */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferMediaSeeking;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f61f5c26-863d-4afa-b0ba-2f81dc978596")
    IStreamBufferMediaSeeking : public IMediaSeeking
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferMediaSeekingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStreamBufferMediaSeeking * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStreamBufferMediaSeeking * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStreamBufferMediaSeeking * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCapabilities )( 
            __RPC__in IStreamBufferMediaSeeking * This,
            /* [annotation][out] */ 
            __out  DWORD *pCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *CheckCapabilities )( 
            __RPC__in IStreamBufferMediaSeeking * This,
            /* [out][in] */ __RPC__inout DWORD *pCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *IsFormatSupported )( 
            __RPC__in IStreamBufferMediaSeeking * This,
            /* [in] */ __RPC__in const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *QueryPreferredFormat )( 
            __RPC__in IStreamBufferMediaSeeking * This,
            /* [annotation][out] */ 
            __out  GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimeFormat )( 
            __RPC__in IStreamBufferMediaSeeking * This,
            /* [annotation][out] */ 
            __out  GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingTimeFormat )( 
            __RPC__in IStreamBufferMediaSeeking * This,
            /* [in] */ __RPC__in const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimeFormat )( 
            __RPC__in IStreamBufferMediaSeeking * This,
            /* [in] */ __RPC__in const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetDuration )( 
            __RPC__in IStreamBufferMediaSeeking * This,
            /* [annotation][out] */ 
            __out  LONGLONG *pDuration);
        
        HRESULT ( STDMETHODCALLTYPE *GetStopPosition )( 
            __RPC__in IStreamBufferMediaSeeking * This,
            /* [annotation][out] */ 
            __out  LONGLONG *pStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentPosition )( 
            __RPC__in IStreamBufferMediaSeeking * This,
            /* [annotation][out] */ 
            __out  LONGLONG *pCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertTimeFormat )( 
            __RPC__in IStreamBufferMediaSeeking * This,
            /* [annotation][out] */ 
            __out  LONGLONG *pTarget,
            /* [annotation][in] */ 
            __in_opt  const GUID *pTargetFormat,
            /* [in] */ LONGLONG Source,
            /* [annotation][in] */ 
            __in_opt  const GUID *pSourceFormat);
        
        HRESULT ( STDMETHODCALLTYPE *SetPositions )( 
            __RPC__in IStreamBufferMediaSeeking * This,
            /* [annotation][out][in] */ 
            __inout_opt  LONGLONG *pCurrent,
            /* [in] */ DWORD dwCurrentFlags,
            /* [annotation][out][in] */ 
            __inout_opt  LONGLONG *pStop,
            /* [in] */ DWORD dwStopFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetPositions )( 
            __RPC__in IStreamBufferMediaSeeking * This,
            /* [annotation][out] */ 
            __out_opt  LONGLONG *pCurrent,
            /* [annotation][out] */ 
            __out_opt  LONGLONG *pStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailable )( 
            __RPC__in IStreamBufferMediaSeeking * This,
            /* [annotation][out] */ 
            __out_opt  LONGLONG *pEarliest,
            /* [annotation][out] */ 
            __out_opt  LONGLONG *pLatest);
        
        HRESULT ( STDMETHODCALLTYPE *SetRate )( 
            __RPC__in IStreamBufferMediaSeeking * This,
            /* [in] */ double dRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetRate )( 
            __RPC__in IStreamBufferMediaSeeking * This,
            /* [annotation][out] */ 
            __out  double *pdRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreroll )( 
            __RPC__in IStreamBufferMediaSeeking * This,
            /* [annotation][out] */ 
            __out  LONGLONG *pllPreroll);
        
        END_INTERFACE
    } IStreamBufferMediaSeekingVtbl;

    interface IStreamBufferMediaSeeking
    {
        CONST_VTBL struct IStreamBufferMediaSeekingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferMediaSeeking_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamBufferMediaSeeking_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamBufferMediaSeeking_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamBufferMediaSeeking_GetCapabilities(This,pCapabilities)	\
    ( (This)->lpVtbl -> GetCapabilities(This,pCapabilities) ) 

#define IStreamBufferMediaSeeking_CheckCapabilities(This,pCapabilities)	\
    ( (This)->lpVtbl -> CheckCapabilities(This,pCapabilities) ) 

#define IStreamBufferMediaSeeking_IsFormatSupported(This,pFormat)	\
    ( (This)->lpVtbl -> IsFormatSupported(This,pFormat) ) 

#define IStreamBufferMediaSeeking_QueryPreferredFormat(This,pFormat)	\
    ( (This)->lpVtbl -> QueryPreferredFormat(This,pFormat) ) 

#define IStreamBufferMediaSeeking_GetTimeFormat(This,pFormat)	\
    ( (This)->lpVtbl -> GetTimeFormat(This,pFormat) ) 

#define IStreamBufferMediaSeeking_IsUsingTimeFormat(This,pFormat)	\
    ( (This)->lpVtbl -> IsUsingTimeFormat(This,pFormat) ) 

#define IStreamBufferMediaSeeking_SetTimeFormat(This,pFormat)	\
    ( (This)->lpVtbl -> SetTimeFormat(This,pFormat) ) 

#define IStreamBufferMediaSeeking_GetDuration(This,pDuration)	\
    ( (This)->lpVtbl -> GetDuration(This,pDuration) ) 

#define IStreamBufferMediaSeeking_GetStopPosition(This,pStop)	\
    ( (This)->lpVtbl -> GetStopPosition(This,pStop) ) 

#define IStreamBufferMediaSeeking_GetCurrentPosition(This,pCurrent)	\
    ( (This)->lpVtbl -> GetCurrentPosition(This,pCurrent) ) 

#define IStreamBufferMediaSeeking_ConvertTimeFormat(This,pTarget,pTargetFormat,Source,pSourceFormat)	\
    ( (This)->lpVtbl -> ConvertTimeFormat(This,pTarget,pTargetFormat,Source,pSourceFormat) ) 

#define IStreamBufferMediaSeeking_SetPositions(This,pCurrent,dwCurrentFlags,pStop,dwStopFlags)	\
    ( (This)->lpVtbl -> SetPositions(This,pCurrent,dwCurrentFlags,pStop,dwStopFlags) ) 

#define IStreamBufferMediaSeeking_GetPositions(This,pCurrent,pStop)	\
    ( (This)->lpVtbl -> GetPositions(This,pCurrent,pStop) ) 

#define IStreamBufferMediaSeeking_GetAvailable(This,pEarliest,pLatest)	\
    ( (This)->lpVtbl -> GetAvailable(This,pEarliest,pLatest) ) 

#define IStreamBufferMediaSeeking_SetRate(This,dRate)	\
    ( (This)->lpVtbl -> SetRate(This,dRate) ) 

#define IStreamBufferMediaSeeking_GetRate(This,pdRate)	\
    ( (This)->lpVtbl -> GetRate(This,pdRate) ) 

#define IStreamBufferMediaSeeking_GetPreroll(This,pllPreroll)	\
    ( (This)->lpVtbl -> GetPreroll(This,pllPreroll) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamBufferMediaSeeking_INTERFACE_DEFINED__ */


#ifndef __IStreamBufferMediaSeeking2_INTERFACE_DEFINED__
#define __IStreamBufferMediaSeeking2_INTERFACE_DEFINED__

/* interface IStreamBufferMediaSeeking2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferMediaSeeking2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3a439ab0-155f-470a-86a6-9ea54afd6eaf")
    IStreamBufferMediaSeeking2 : public IStreamBufferMediaSeeking
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRateEx( 
            /* [in] */ double dRate,
            /* [in] */ DWORD dwFramesPerSec) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferMediaSeeking2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStreamBufferMediaSeeking2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStreamBufferMediaSeeking2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStreamBufferMediaSeeking2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCapabilities )( 
            __RPC__in IStreamBufferMediaSeeking2 * This,
            /* [annotation][out] */ 
            __out  DWORD *pCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *CheckCapabilities )( 
            __RPC__in IStreamBufferMediaSeeking2 * This,
            /* [out][in] */ __RPC__inout DWORD *pCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *IsFormatSupported )( 
            __RPC__in IStreamBufferMediaSeeking2 * This,
            /* [in] */ __RPC__in const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *QueryPreferredFormat )( 
            __RPC__in IStreamBufferMediaSeeking2 * This,
            /* [annotation][out] */ 
            __out  GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimeFormat )( 
            __RPC__in IStreamBufferMediaSeeking2 * This,
            /* [annotation][out] */ 
            __out  GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingTimeFormat )( 
            __RPC__in IStreamBufferMediaSeeking2 * This,
            /* [in] */ __RPC__in const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimeFormat )( 
            __RPC__in IStreamBufferMediaSeeking2 * This,
            /* [in] */ __RPC__in const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetDuration )( 
            __RPC__in IStreamBufferMediaSeeking2 * This,
            /* [annotation][out] */ 
            __out  LONGLONG *pDuration);
        
        HRESULT ( STDMETHODCALLTYPE *GetStopPosition )( 
            __RPC__in IStreamBufferMediaSeeking2 * This,
            /* [annotation][out] */ 
            __out  LONGLONG *pStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentPosition )( 
            __RPC__in IStreamBufferMediaSeeking2 * This,
            /* [annotation][out] */ 
            __out  LONGLONG *pCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertTimeFormat )( 
            __RPC__in IStreamBufferMediaSeeking2 * This,
            /* [annotation][out] */ 
            __out  LONGLONG *pTarget,
            /* [annotation][in] */ 
            __in_opt  const GUID *pTargetFormat,
            /* [in] */ LONGLONG Source,
            /* [annotation][in] */ 
            __in_opt  const GUID *pSourceFormat);
        
        HRESULT ( STDMETHODCALLTYPE *SetPositions )( 
            __RPC__in IStreamBufferMediaSeeking2 * This,
            /* [annotation][out][in] */ 
            __inout_opt  LONGLONG *pCurrent,
            /* [in] */ DWORD dwCurrentFlags,
            /* [annotation][out][in] */ 
            __inout_opt  LONGLONG *pStop,
            /* [in] */ DWORD dwStopFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetPositions )( 
            __RPC__in IStreamBufferMediaSeeking2 * This,
            /* [annotation][out] */ 
            __out_opt  LONGLONG *pCurrent,
            /* [annotation][out] */ 
            __out_opt  LONGLONG *pStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailable )( 
            __RPC__in IStreamBufferMediaSeeking2 * This,
            /* [annotation][out] */ 
            __out_opt  LONGLONG *pEarliest,
            /* [annotation][out] */ 
            __out_opt  LONGLONG *pLatest);
        
        HRESULT ( STDMETHODCALLTYPE *SetRate )( 
            __RPC__in IStreamBufferMediaSeeking2 * This,
            /* [in] */ double dRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetRate )( 
            __RPC__in IStreamBufferMediaSeeking2 * This,
            /* [annotation][out] */ 
            __out  double *pdRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreroll )( 
            __RPC__in IStreamBufferMediaSeeking2 * This,
            /* [annotation][out] */ 
            __out  LONGLONG *pllPreroll);
        
        HRESULT ( STDMETHODCALLTYPE *SetRateEx )( 
            __RPC__in IStreamBufferMediaSeeking2 * This,
            /* [in] */ double dRate,
            /* [in] */ DWORD dwFramesPerSec);
        
        END_INTERFACE
    } IStreamBufferMediaSeeking2Vtbl;

    interface IStreamBufferMediaSeeking2
    {
        CONST_VTBL struct IStreamBufferMediaSeeking2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferMediaSeeking2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamBufferMediaSeeking2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamBufferMediaSeeking2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamBufferMediaSeeking2_GetCapabilities(This,pCapabilities)	\
    ( (This)->lpVtbl -> GetCapabilities(This,pCapabilities) ) 

#define IStreamBufferMediaSeeking2_CheckCapabilities(This,pCapabilities)	\
    ( (This)->lpVtbl -> CheckCapabilities(This,pCapabilities) ) 

#define IStreamBufferMediaSeeking2_IsFormatSupported(This,pFormat)	\
    ( (This)->lpVtbl -> IsFormatSupported(This,pFormat) ) 

#define IStreamBufferMediaSeeking2_QueryPreferredFormat(This,pFormat)	\
    ( (This)->lpVtbl -> QueryPreferredFormat(This,pFormat) ) 

#define IStreamBufferMediaSeeking2_GetTimeFormat(This,pFormat)	\
    ( (This)->lpVtbl -> GetTimeFormat(This,pFormat) ) 

#define IStreamBufferMediaSeeking2_IsUsingTimeFormat(This,pFormat)	\
    ( (This)->lpVtbl -> IsUsingTimeFormat(This,pFormat) ) 

#define IStreamBufferMediaSeeking2_SetTimeFormat(This,pFormat)	\
    ( (This)->lpVtbl -> SetTimeFormat(This,pFormat) ) 

#define IStreamBufferMediaSeeking2_GetDuration(This,pDuration)	\
    ( (This)->lpVtbl -> GetDuration(This,pDuration) ) 

#define IStreamBufferMediaSeeking2_GetStopPosition(This,pStop)	\
    ( (This)->lpVtbl -> GetStopPosition(This,pStop) ) 

#define IStreamBufferMediaSeeking2_GetCurrentPosition(This,pCurrent)	\
    ( (This)->lpVtbl -> GetCurrentPosition(This,pCurrent) ) 

#define IStreamBufferMediaSeeking2_ConvertTimeFormat(This,pTarget,pTargetFormat,Source,pSourceFormat)	\
    ( (This)->lpVtbl -> ConvertTimeFormat(This,pTarget,pTargetFormat,Source,pSourceFormat) ) 

#define IStreamBufferMediaSeeking2_SetPositions(This,pCurrent,dwCurrentFlags,pStop,dwStopFlags)	\
    ( (This)->lpVtbl -> SetPositions(This,pCurrent,dwCurrentFlags,pStop,dwStopFlags) ) 

#define IStreamBufferMediaSeeking2_GetPositions(This,pCurrent,pStop)	\
    ( (This)->lpVtbl -> GetPositions(This,pCurrent,pStop) ) 

#define IStreamBufferMediaSeeking2_GetAvailable(This,pEarliest,pLatest)	\
    ( (This)->lpVtbl -> GetAvailable(This,pEarliest,pLatest) ) 

#define IStreamBufferMediaSeeking2_SetRate(This,dRate)	\
    ( (This)->lpVtbl -> SetRate(This,dRate) ) 

#define IStreamBufferMediaSeeking2_GetRate(This,pdRate)	\
    ( (This)->lpVtbl -> GetRate(This,pdRate) ) 

#define IStreamBufferMediaSeeking2_GetPreroll(This,pllPreroll)	\
    ( (This)->lpVtbl -> GetPreroll(This,pllPreroll) ) 



#define IStreamBufferMediaSeeking2_SetRateEx(This,dRate,dwFramesPerSec)	\
    ( (This)->lpVtbl -> SetRateEx(This,dRate,dwFramesPerSec) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamBufferMediaSeeking2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sbe_0000_0014 */
/* [local] */ 

typedef struct SBE_PIN_DATA
    {
    ULONGLONG cDataBytes;
    ULONGLONG cSamplesProcessed;
    ULONGLONG cDiscontinuities;
    ULONGLONG cSyncPoints;
    ULONGLONG cTimestamps;
    } 	SBE_PIN_DATA;



extern RPC_IF_HANDLE __MIDL_itf_sbe_0000_0014_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sbe_0000_0014_v0_0_s_ifspec;

#ifndef __IStreamBufferDataCounters_INTERFACE_DEFINED__
#define __IStreamBufferDataCounters_INTERFACE_DEFINED__

/* interface IStreamBufferDataCounters */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferDataCounters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9D2A2563-31AB-402e-9A6B-ADB903489440")
    IStreamBufferDataCounters : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetData( 
            /* [out] */ __RPC__out SBE_PIN_DATA *pPinData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetData( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferDataCountersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStreamBufferDataCounters * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStreamBufferDataCounters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStreamBufferDataCounters * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetData )( 
            __RPC__in IStreamBufferDataCounters * This,
            /* [out] */ __RPC__out SBE_PIN_DATA *pPinData);
        
        HRESULT ( STDMETHODCALLTYPE *ResetData )( 
            __RPC__in IStreamBufferDataCounters * This);
        
        END_INTERFACE
    } IStreamBufferDataCountersVtbl;

    interface IStreamBufferDataCounters
    {
        CONST_VTBL struct IStreamBufferDataCountersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferDataCounters_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamBufferDataCounters_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamBufferDataCounters_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamBufferDataCounters_GetData(This,pPinData)	\
    ( (This)->lpVtbl -> GetData(This,pPinData) ) 

#define IStreamBufferDataCounters_ResetData(This)	\
    ( (This)->lpVtbl -> ResetData(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamBufferDataCounters_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sbe_0000_0015 */
/* [local] */ 

#define STREAMBUFFER_EC_BASE                     0x0326
enum {
    //  timehole event
    //      param1 = timehole stream offset ms
    //      param1 = timehole size ms
    STREAMBUFFER_EC_TIMEHOLE = STREAMBUFFER_EC_BASE,
    
    STREAMBUFFER_EC_STALE_DATA_READ,
    
    STREAMBUFFER_EC_STALE_FILE_DELETED,
    STREAMBUFFER_EC_CONTENT_BECOMING_STALE,
    STREAMBUFFER_EC_WRITE_FAILURE,
    STREAMBUFFER_EC_WRITE_FAILURE_CLEAR,
    //
    //  unexpected read failure
    //      param1 = HRESULT failure
    //      param2 = undefined
    STREAMBUFFER_EC_READ_FAILURE,
    //
    //  playback rate change
    //      param1 = old_playback_rate * 10000 e.g. 2x is 20000
    //      param2 = new_playback_rate * 10000
    STREAMBUFFER_EC_RATE_CHANGED,
    //
    //  index frame insertion notification
    // 
    STREAMBUFFER_EC_PRIMARY_AUDIO,
    //
    //  about to send playback rate change that is due to IMediaSeeking::SetPositions() call
    //      param1 = old_playback_rate * 10000 e.g. 2x is 20000
    //      param2 = new_playback_rate * 10000
    STREAMBUFFER_EC_RATE_CHANGING_FOR_SETPOSITIONS,
    //
    //  the work of a SetPositions() call has finished
    //      param1 = unused (set to 0 -- if uses are defined, they will be non-0)
    //      param2 = unused (set to 0 -- if uses are defined later, they will be non-0)
    STREAMBUFFER_EC_SETPOSITIONS_EVENTS_DONE,
} ;






// {8966A89E-F83E-4c0e-BC3B-BFA7649E04CB}
DEFINE_GUID(EVENTID_SBE2RecControlStarted, 
0x8966a89e, 0xf83e, 0x4c0e, 0xbc, 0x3b, 0xbf, 0xa7, 0x64, 0x9e, 0x4, 0xcb);
// {454B1EC8-0C9B-4caa-B1A1-1E7A2666F6C3}
DEFINE_GUID(EVENTID_SBE2RecControlStopped, 
0x454b1ec8, 0xc9b, 0x4caa, 0xb1, 0xa1, 0x1e, 0x7a, 0x26, 0x66, 0xf6, 0xc3);
DEFINE_GUID (SBE2_STREAM_DESC_EVENT,
0x2313a4ed, 0xbf2d, 0x454f, 0xad, 0x8a, 0xd9, 0x5b, 0xa7, 0xf9, 0x1f, 0xee);
// {000FCF09-97F5-46ac-9769-7A83B35384FB}
DEFINE_GUID (SBE2_V1_STREAMS_CREATION_EVENT,
0xfcf09, 0x97f5, 0x46ac, 0x97, 0x69, 0x7a, 0x83, 0xb3, 0x53, 0x84, 0xfb);
// {A72530A3-0344-4cab-A2D0-FE937DBDCAB3}
DEFINE_GUID (SBE2_V2_STREAMS_CREATION_EVENT,
0xa72530a3, 0x344, 0x4cab, 0xa2, 0xd0, 0xfe, 0x93, 0x7d, 0xbd, 0xca, 0xb3);
typedef enum {
DEF_MODE_PROFILE = 0x0000001,
DEF_MODE_STREAMS = 0x0000002,
} CROSSBAR_DEFAULT_FLAGS ;
typedef DWORD SBE2_STREAM_ID;

#define	SBE2_STREAM_DESC_VERSION	( 1 )

typedef /* [public][public] */ struct __MIDL___MIDL_itf_sbe_0000_0015_0001
    {
    DWORD Version;
    SBE2_STREAM_ID StreamId;
    DWORD Default;
    DWORD Reserved;
    } 	SBE2_STREAM_DESC;

typedef /* [public] */ struct __MIDL___MIDL_itf_sbe_0000_0015_0002
    {
    DWORD Version;
    DWORD StreamId;
    BOOL Default;
    BOOL Creation;
    DWORD Reserved;
    GUID guidSubMediaType;
    GUID guidFormatType;
    AM_MEDIA_TYPE MediaType;
    } 	DVR_STREAM_DESC;



extern RPC_IF_HANDLE __MIDL_itf_sbe_0000_0015_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sbe_0000_0015_v0_0_s_ifspec;

#ifndef __ISBE2GlobalEvent_INTERFACE_DEFINED__
#define __ISBE2GlobalEvent_INTERFACE_DEFINED__

/* interface ISBE2GlobalEvent */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISBE2GlobalEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("caede759-b6b1-11db-a578-0018f3fa24c6")
    ISBE2GlobalEvent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEvent( 
            /* [in] */ __RPC__in REFGUID idEvt,
            /* [in] */ ULONG param1,
            /* [in] */ ULONG param2,
            /* [in] */ ULONG param3,
            /* [in] */ ULONG param4,
            /* [out] */ __RPC__out BOOL *pSpanning,
            /* [out][in] */ __RPC__inout DWORD *pcb,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcb) BYTE *pb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISBE2GlobalEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISBE2GlobalEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISBE2GlobalEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISBE2GlobalEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            __RPC__in ISBE2GlobalEvent * This,
            /* [in] */ __RPC__in REFGUID idEvt,
            /* [in] */ ULONG param1,
            /* [in] */ ULONG param2,
            /* [in] */ ULONG param3,
            /* [in] */ ULONG param4,
            /* [out] */ __RPC__out BOOL *pSpanning,
            /* [out][in] */ __RPC__inout DWORD *pcb,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcb) BYTE *pb);
        
        END_INTERFACE
    } ISBE2GlobalEventVtbl;

    interface ISBE2GlobalEvent
    {
        CONST_VTBL struct ISBE2GlobalEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISBE2GlobalEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISBE2GlobalEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISBE2GlobalEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISBE2GlobalEvent_GetEvent(This,idEvt,param1,param2,param3,param4,pSpanning,pcb,pb)	\
    ( (This)->lpVtbl -> GetEvent(This,idEvt,param1,param2,param3,param4,pSpanning,pcb,pb) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISBE2GlobalEvent_INTERFACE_DEFINED__ */


#ifndef __ISBE2GlobalEvent2_INTERFACE_DEFINED__
#define __ISBE2GlobalEvent2_INTERFACE_DEFINED__

/* interface ISBE2GlobalEvent2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISBE2GlobalEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6D8309BF-00FE-4506-8B03-F8C65B5C9B39")
    ISBE2GlobalEvent2 : public ISBE2GlobalEvent
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEventEx( 
            /* [in] */ __RPC__in REFGUID idEvt,
            /* [in] */ ULONG param1,
            /* [in] */ ULONG param2,
            /* [in] */ ULONG param3,
            /* [in] */ ULONG param4,
            /* [out] */ __RPC__out BOOL *pSpanning,
            /* [out][in] */ __RPC__inout DWORD *pcb,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcb) BYTE *pb,
            /* [out] */ __RPC__out REFERENCE_TIME *pStreamTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISBE2GlobalEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISBE2GlobalEvent2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISBE2GlobalEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISBE2GlobalEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            __RPC__in ISBE2GlobalEvent2 * This,
            /* [in] */ __RPC__in REFGUID idEvt,
            /* [in] */ ULONG param1,
            /* [in] */ ULONG param2,
            /* [in] */ ULONG param3,
            /* [in] */ ULONG param4,
            /* [out] */ __RPC__out BOOL *pSpanning,
            /* [out][in] */ __RPC__inout DWORD *pcb,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcb) BYTE *pb);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventEx )( 
            __RPC__in ISBE2GlobalEvent2 * This,
            /* [in] */ __RPC__in REFGUID idEvt,
            /* [in] */ ULONG param1,
            /* [in] */ ULONG param2,
            /* [in] */ ULONG param3,
            /* [in] */ ULONG param4,
            /* [out] */ __RPC__out BOOL *pSpanning,
            /* [out][in] */ __RPC__inout DWORD *pcb,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcb) BYTE *pb,
            /* [out] */ __RPC__out REFERENCE_TIME *pStreamTime);
        
        END_INTERFACE
    } ISBE2GlobalEvent2Vtbl;

    interface ISBE2GlobalEvent2
    {
        CONST_VTBL struct ISBE2GlobalEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISBE2GlobalEvent2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISBE2GlobalEvent2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISBE2GlobalEvent2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISBE2GlobalEvent2_GetEvent(This,idEvt,param1,param2,param3,param4,pSpanning,pcb,pb)	\
    ( (This)->lpVtbl -> GetEvent(This,idEvt,param1,param2,param3,param4,pSpanning,pcb,pb) ) 


#define ISBE2GlobalEvent2_GetEventEx(This,idEvt,param1,param2,param3,param4,pSpanning,pcb,pb,pStreamTime)	\
    ( (This)->lpVtbl -> GetEventEx(This,idEvt,param1,param2,param3,param4,pSpanning,pcb,pb,pStreamTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISBE2GlobalEvent2_INTERFACE_DEFINED__ */


#ifndef __ISBE2SpanningEvent_INTERFACE_DEFINED__
#define __ISBE2SpanningEvent_INTERFACE_DEFINED__

/* interface ISBE2SpanningEvent */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISBE2SpanningEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("caede760-b6b1-11db-a578-0018f3fa24c6")
    ISBE2SpanningEvent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEvent( 
            /* [in] */ __RPC__in REFGUID idEvt,
            /* [in] */ SBE2_STREAM_ID streamId,
            /* [out][in] */ __RPC__inout DWORD *pcb,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcb) BYTE *pb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISBE2SpanningEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISBE2SpanningEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISBE2SpanningEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISBE2SpanningEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            __RPC__in ISBE2SpanningEvent * This,
            /* [in] */ __RPC__in REFGUID idEvt,
            /* [in] */ SBE2_STREAM_ID streamId,
            /* [out][in] */ __RPC__inout DWORD *pcb,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcb) BYTE *pb);
        
        END_INTERFACE
    } ISBE2SpanningEventVtbl;

    interface ISBE2SpanningEvent
    {
        CONST_VTBL struct ISBE2SpanningEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISBE2SpanningEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISBE2SpanningEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISBE2SpanningEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISBE2SpanningEvent_GetEvent(This,idEvt,streamId,pcb,pb)	\
    ( (This)->lpVtbl -> GetEvent(This,idEvt,streamId,pcb,pb) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISBE2SpanningEvent_INTERFACE_DEFINED__ */


#ifndef __ISBE2Crossbar_INTERFACE_DEFINED__
#define __ISBE2Crossbar_INTERFACE_DEFINED__

/* interface ISBE2Crossbar */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISBE2Crossbar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("547b6d26-3226-487e-8253-8aa168749434")
    ISBE2Crossbar : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnableDefaultMode( 
            /* [in] */ DWORD DefaultFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInitialProfile( 
            /* [out] */ __RPC__deref_out_opt ISBE2MediaTypeProfile **ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputProfile( 
            /* [in] */ __RPC__in_opt ISBE2MediaTypeProfile *pProfile,
            /* [out] */ __RPC__out DWORD *pcOutputPins,
            /* [out] */ __RPC__deref_out_opt IPin **ppOutputPins) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumStreams( 
            /* [out] */ __RPC__deref_out_opt ISBE2EnumStream **ppStreams) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISBE2CrossbarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISBE2Crossbar * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISBE2Crossbar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISBE2Crossbar * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnableDefaultMode )( 
            __RPC__in ISBE2Crossbar * This,
            /* [in] */ DWORD DefaultFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetInitialProfile )( 
            __RPC__in ISBE2Crossbar * This,
            /* [out] */ __RPC__deref_out_opt ISBE2MediaTypeProfile **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputProfile )( 
            __RPC__in ISBE2Crossbar * This,
            /* [in] */ __RPC__in_opt ISBE2MediaTypeProfile *pProfile,
            /* [out] */ __RPC__out DWORD *pcOutputPins,
            /* [out] */ __RPC__deref_out_opt IPin **ppOutputPins);
        
        HRESULT ( STDMETHODCALLTYPE *EnumStreams )( 
            __RPC__in ISBE2Crossbar * This,
            /* [out] */ __RPC__deref_out_opt ISBE2EnumStream **ppStreams);
        
        END_INTERFACE
    } ISBE2CrossbarVtbl;

    interface ISBE2Crossbar
    {
        CONST_VTBL struct ISBE2CrossbarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISBE2Crossbar_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISBE2Crossbar_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISBE2Crossbar_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISBE2Crossbar_EnableDefaultMode(This,DefaultFlags)	\
    ( (This)->lpVtbl -> EnableDefaultMode(This,DefaultFlags) ) 

#define ISBE2Crossbar_GetInitialProfile(This,ppProfile)	\
    ( (This)->lpVtbl -> GetInitialProfile(This,ppProfile) ) 

#define ISBE2Crossbar_SetOutputProfile(This,pProfile,pcOutputPins,ppOutputPins)	\
    ( (This)->lpVtbl -> SetOutputProfile(This,pProfile,pcOutputPins,ppOutputPins) ) 

#define ISBE2Crossbar_EnumStreams(This,ppStreams)	\
    ( (This)->lpVtbl -> EnumStreams(This,ppStreams) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISBE2Crossbar_INTERFACE_DEFINED__ */


#ifndef __ISBE2StreamMap_INTERFACE_DEFINED__
#define __ISBE2StreamMap_INTERFACE_DEFINED__

/* interface ISBE2StreamMap */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISBE2StreamMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("667c7745-85b1-4c55-ae55-4e25056159fc")
    ISBE2StreamMap : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MapStream( 
            /* [in] */ SBE2_STREAM_ID Stream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnmapStream( 
            /* [in] */ SBE2_STREAM_ID Stream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumMappedStreams( 
            /* [out] */ __RPC__deref_out_opt ISBE2EnumStream **ppStreams) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISBE2StreamMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISBE2StreamMap * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISBE2StreamMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISBE2StreamMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *MapStream )( 
            __RPC__in ISBE2StreamMap * This,
            /* [in] */ SBE2_STREAM_ID Stream);
        
        HRESULT ( STDMETHODCALLTYPE *UnmapStream )( 
            __RPC__in ISBE2StreamMap * This,
            /* [in] */ SBE2_STREAM_ID Stream);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMappedStreams )( 
            __RPC__in ISBE2StreamMap * This,
            /* [out] */ __RPC__deref_out_opt ISBE2EnumStream **ppStreams);
        
        END_INTERFACE
    } ISBE2StreamMapVtbl;

    interface ISBE2StreamMap
    {
        CONST_VTBL struct ISBE2StreamMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISBE2StreamMap_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISBE2StreamMap_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISBE2StreamMap_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISBE2StreamMap_MapStream(This,Stream)	\
    ( (This)->lpVtbl -> MapStream(This,Stream) ) 

#define ISBE2StreamMap_UnmapStream(This,Stream)	\
    ( (This)->lpVtbl -> UnmapStream(This,Stream) ) 

#define ISBE2StreamMap_EnumMappedStreams(This,ppStreams)	\
    ( (This)->lpVtbl -> EnumMappedStreams(This,ppStreams) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISBE2StreamMap_INTERFACE_DEFINED__ */


#ifndef __ISBE2EnumStream_INTERFACE_DEFINED__
#define __ISBE2EnumStream_INTERFACE_DEFINED__

/* interface ISBE2EnumStream */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISBE2EnumStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f7611092-9fbc-46ec-a7c7-548ea78b71a4")
    ISBE2EnumStream : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cRequest,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(cRequest) SBE2_STREAM_DESC *pStreamDesc,
            /* [out] */ __RPC__out ULONG *pcReceived) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cRecords) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt ISBE2EnumStream **ppIEnumStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISBE2EnumStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISBE2EnumStream * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISBE2EnumStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISBE2EnumStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in ISBE2EnumStream * This,
            /* [in] */ ULONG cRequest,
            /* [size_is][out][in] */ __RPC__inout_ecount_full(cRequest) SBE2_STREAM_DESC *pStreamDesc,
            /* [out] */ __RPC__out ULONG *pcReceived);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in ISBE2EnumStream * This,
            /* [in] */ ULONG cRecords);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in ISBE2EnumStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in ISBE2EnumStream * This,
            /* [out] */ __RPC__deref_out_opt ISBE2EnumStream **ppIEnumStream);
        
        END_INTERFACE
    } ISBE2EnumStreamVtbl;

    interface ISBE2EnumStream
    {
        CONST_VTBL struct ISBE2EnumStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISBE2EnumStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISBE2EnumStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISBE2EnumStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISBE2EnumStream_Next(This,cRequest,pStreamDesc,pcReceived)	\
    ( (This)->lpVtbl -> Next(This,cRequest,pStreamDesc,pcReceived) ) 

#define ISBE2EnumStream_Skip(This,cRecords)	\
    ( (This)->lpVtbl -> Skip(This,cRecords) ) 

#define ISBE2EnumStream_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define ISBE2EnumStream_Clone(This,ppIEnumStream)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnumStream) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISBE2EnumStream_INTERFACE_DEFINED__ */


#ifndef __ISBE2MediaTypeProfile_INTERFACE_DEFINED__
#define __ISBE2MediaTypeProfile_INTERFACE_DEFINED__

/* interface ISBE2MediaTypeProfile */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISBE2MediaTypeProfile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f238267d-4671-40d7-997e-25dc32cfed2a")
    ISBE2MediaTypeProfile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamCount( 
            /* [out] */ __RPC__out DWORD *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [in] */ DWORD Index,
            /* [out] */ __RPC__deref_out_opt AM_MEDIA_TYPE **ppMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStream( 
            /* [in] */ __RPC__in AM_MEDIA_TYPE *pMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteStream( 
            /* [in] */ DWORD Index) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISBE2MediaTypeProfileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISBE2MediaTypeProfile * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISBE2MediaTypeProfile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISBE2MediaTypeProfile * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamCount )( 
            __RPC__in ISBE2MediaTypeProfile * This,
            /* [out] */ __RPC__out DWORD *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            __RPC__in ISBE2MediaTypeProfile * This,
            /* [in] */ DWORD Index,
            /* [out] */ __RPC__deref_out_opt AM_MEDIA_TYPE **ppMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *AddStream )( 
            __RPC__in ISBE2MediaTypeProfile * This,
            /* [in] */ __RPC__in AM_MEDIA_TYPE *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteStream )( 
            __RPC__in ISBE2MediaTypeProfile * This,
            /* [in] */ DWORD Index);
        
        END_INTERFACE
    } ISBE2MediaTypeProfileVtbl;

    interface ISBE2MediaTypeProfile
    {
        CONST_VTBL struct ISBE2MediaTypeProfileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISBE2MediaTypeProfile_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISBE2MediaTypeProfile_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISBE2MediaTypeProfile_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISBE2MediaTypeProfile_GetStreamCount(This,pCount)	\
    ( (This)->lpVtbl -> GetStreamCount(This,pCount) ) 

#define ISBE2MediaTypeProfile_GetStream(This,Index,ppMediaType)	\
    ( (This)->lpVtbl -> GetStream(This,Index,ppMediaType) ) 

#define ISBE2MediaTypeProfile_AddStream(This,pMediaType)	\
    ( (This)->lpVtbl -> AddStream(This,pMediaType) ) 

#define ISBE2MediaTypeProfile_DeleteStream(This,Index)	\
    ( (This)->lpVtbl -> DeleteStream(This,Index) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISBE2MediaTypeProfile_INTERFACE_DEFINED__ */


#ifndef __ISBE2FileScan_INTERFACE_DEFINED__
#define __ISBE2FileScan_INTERFACE_DEFINED__

/* interface ISBE2FileScan */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISBE2FileScan;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3E2BF5A5-4F96-4899-A1A3-75E8BE9A5AC0")
    ISBE2FileScan : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RepairFile( 
            /* [in] */ __RPC__in LPCWSTR filename) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISBE2FileScanVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISBE2FileScan * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISBE2FileScan * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISBE2FileScan * This);
        
        HRESULT ( STDMETHODCALLTYPE *RepairFile )( 
            __RPC__in ISBE2FileScan * This,
            /* [in] */ __RPC__in LPCWSTR filename);
        
        END_INTERFACE
    } ISBE2FileScanVtbl;

    interface ISBE2FileScan
    {
        CONST_VTBL struct ISBE2FileScanVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISBE2FileScan_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISBE2FileScan_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISBE2FileScan_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISBE2FileScan_RepairFile(This,filename)	\
    ( (This)->lpVtbl -> RepairFile(This,filename) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISBE2FileScan_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\sapi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for sapi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __sapi_h__
#define __sapi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISpNotifySource_FWD_DEFINED__
#define __ISpNotifySource_FWD_DEFINED__
typedef interface ISpNotifySource ISpNotifySource;
#endif 	/* __ISpNotifySource_FWD_DEFINED__ */


#ifndef __ISpNotifySink_FWD_DEFINED__
#define __ISpNotifySink_FWD_DEFINED__
typedef interface ISpNotifySink ISpNotifySink;
#endif 	/* __ISpNotifySink_FWD_DEFINED__ */


#ifndef __ISpNotifyTranslator_FWD_DEFINED__
#define __ISpNotifyTranslator_FWD_DEFINED__
typedef interface ISpNotifyTranslator ISpNotifyTranslator;
#endif 	/* __ISpNotifyTranslator_FWD_DEFINED__ */


#ifndef __ISpDataKey_FWD_DEFINED__
#define __ISpDataKey_FWD_DEFINED__
typedef interface ISpDataKey ISpDataKey;
#endif 	/* __ISpDataKey_FWD_DEFINED__ */


#ifndef __ISpRegDataKey_FWD_DEFINED__
#define __ISpRegDataKey_FWD_DEFINED__
typedef interface ISpRegDataKey ISpRegDataKey;
#endif 	/* __ISpRegDataKey_FWD_DEFINED__ */


#ifndef __ISpObjectTokenCategory_FWD_DEFINED__
#define __ISpObjectTokenCategory_FWD_DEFINED__
typedef interface ISpObjectTokenCategory ISpObjectTokenCategory;
#endif 	/* __ISpObjectTokenCategory_FWD_DEFINED__ */


#ifndef __ISpObjectToken_FWD_DEFINED__
#define __ISpObjectToken_FWD_DEFINED__
typedef interface ISpObjectToken ISpObjectToken;
#endif 	/* __ISpObjectToken_FWD_DEFINED__ */


#ifndef __ISpObjectTokenInit_FWD_DEFINED__
#define __ISpObjectTokenInit_FWD_DEFINED__
typedef interface ISpObjectTokenInit ISpObjectTokenInit;
#endif 	/* __ISpObjectTokenInit_FWD_DEFINED__ */


#ifndef __IEnumSpObjectTokens_FWD_DEFINED__
#define __IEnumSpObjectTokens_FWD_DEFINED__
typedef interface IEnumSpObjectTokens IEnumSpObjectTokens;
#endif 	/* __IEnumSpObjectTokens_FWD_DEFINED__ */


#ifndef __ISpObjectWithToken_FWD_DEFINED__
#define __ISpObjectWithToken_FWD_DEFINED__
typedef interface ISpObjectWithToken ISpObjectWithToken;
#endif 	/* __ISpObjectWithToken_FWD_DEFINED__ */


#ifndef __ISpResourceManager_FWD_DEFINED__
#define __ISpResourceManager_FWD_DEFINED__
typedef interface ISpResourceManager ISpResourceManager;
#endif 	/* __ISpResourceManager_FWD_DEFINED__ */


#ifndef __ISpEventSource_FWD_DEFINED__
#define __ISpEventSource_FWD_DEFINED__
typedef interface ISpEventSource ISpEventSource;
#endif 	/* __ISpEventSource_FWD_DEFINED__ */


#ifndef __ISpEventSource2_FWD_DEFINED__
#define __ISpEventSource2_FWD_DEFINED__
typedef interface ISpEventSource2 ISpEventSource2;
#endif 	/* __ISpEventSource2_FWD_DEFINED__ */


#ifndef __ISpEventSink_FWD_DEFINED__
#define __ISpEventSink_FWD_DEFINED__
typedef interface ISpEventSink ISpEventSink;
#endif 	/* __ISpEventSink_FWD_DEFINED__ */


#ifndef __ISpStreamFormat_FWD_DEFINED__
#define __ISpStreamFormat_FWD_DEFINED__
typedef interface ISpStreamFormat ISpStreamFormat;
#endif 	/* __ISpStreamFormat_FWD_DEFINED__ */


#ifndef __ISpStream_FWD_DEFINED__
#define __ISpStream_FWD_DEFINED__
typedef interface ISpStream ISpStream;
#endif 	/* __ISpStream_FWD_DEFINED__ */


#ifndef __ISpStreamFormatConverter_FWD_DEFINED__
#define __ISpStreamFormatConverter_FWD_DEFINED__
typedef interface ISpStreamFormatConverter ISpStreamFormatConverter;
#endif 	/* __ISpStreamFormatConverter_FWD_DEFINED__ */


#ifndef __ISpAudio_FWD_DEFINED__
#define __ISpAudio_FWD_DEFINED__
typedef interface ISpAudio ISpAudio;
#endif 	/* __ISpAudio_FWD_DEFINED__ */


#ifndef __ISpMMSysAudio_FWD_DEFINED__
#define __ISpMMSysAudio_FWD_DEFINED__
typedef interface ISpMMSysAudio ISpMMSysAudio;
#endif 	/* __ISpMMSysAudio_FWD_DEFINED__ */


#ifndef __ISpTranscript_FWD_DEFINED__
#define __ISpTranscript_FWD_DEFINED__
typedef interface ISpTranscript ISpTranscript;
#endif 	/* __ISpTranscript_FWD_DEFINED__ */


#ifndef __ISpLexicon_FWD_DEFINED__
#define __ISpLexicon_FWD_DEFINED__
typedef interface ISpLexicon ISpLexicon;
#endif 	/* __ISpLexicon_FWD_DEFINED__ */


#ifndef __ISpContainerLexicon_FWD_DEFINED__
#define __ISpContainerLexicon_FWD_DEFINED__
typedef interface ISpContainerLexicon ISpContainerLexicon;
#endif 	/* __ISpContainerLexicon_FWD_DEFINED__ */


#ifndef __ISpShortcut_FWD_DEFINED__
#define __ISpShortcut_FWD_DEFINED__
typedef interface ISpShortcut ISpShortcut;
#endif 	/* __ISpShortcut_FWD_DEFINED__ */


#ifndef __ISpPhoneConverter_FWD_DEFINED__
#define __ISpPhoneConverter_FWD_DEFINED__
typedef interface ISpPhoneConverter ISpPhoneConverter;
#endif 	/* __ISpPhoneConverter_FWD_DEFINED__ */


#ifndef __ISpPhoneticAlphabetConverter_FWD_DEFINED__
#define __ISpPhoneticAlphabetConverter_FWD_DEFINED__
typedef interface ISpPhoneticAlphabetConverter ISpPhoneticAlphabetConverter;
#endif 	/* __ISpPhoneticAlphabetConverter_FWD_DEFINED__ */


#ifndef __ISpPhoneticAlphabetSelection_FWD_DEFINED__
#define __ISpPhoneticAlphabetSelection_FWD_DEFINED__
typedef interface ISpPhoneticAlphabetSelection ISpPhoneticAlphabetSelection;
#endif 	/* __ISpPhoneticAlphabetSelection_FWD_DEFINED__ */


#ifndef __ISpVoice_FWD_DEFINED__
#define __ISpVoice_FWD_DEFINED__
typedef interface ISpVoice ISpVoice;
#endif 	/* __ISpVoice_FWD_DEFINED__ */


#ifndef __ISpPhrase_FWD_DEFINED__
#define __ISpPhrase_FWD_DEFINED__
typedef interface ISpPhrase ISpPhrase;
#endif 	/* __ISpPhrase_FWD_DEFINED__ */


#ifndef __ISpPhraseAlt_FWD_DEFINED__
#define __ISpPhraseAlt_FWD_DEFINED__
typedef interface ISpPhraseAlt ISpPhraseAlt;
#endif 	/* __ISpPhraseAlt_FWD_DEFINED__ */


#ifndef __ISpPhrase2_FWD_DEFINED__
#define __ISpPhrase2_FWD_DEFINED__
typedef interface ISpPhrase2 ISpPhrase2;
#endif 	/* __ISpPhrase2_FWD_DEFINED__ */


#ifndef __ISpRecoResult_FWD_DEFINED__
#define __ISpRecoResult_FWD_DEFINED__
typedef interface ISpRecoResult ISpRecoResult;
#endif 	/* __ISpRecoResult_FWD_DEFINED__ */


#ifndef __ISpRecoResult2_FWD_DEFINED__
#define __ISpRecoResult2_FWD_DEFINED__
typedef interface ISpRecoResult2 ISpRecoResult2;
#endif 	/* __ISpRecoResult2_FWD_DEFINED__ */


#ifndef __ISpXMLRecoResult_FWD_DEFINED__
#define __ISpXMLRecoResult_FWD_DEFINED__
typedef interface ISpXMLRecoResult ISpXMLRecoResult;
#endif 	/* __ISpXMLRecoResult_FWD_DEFINED__ */


#ifndef __ISpGrammarBuilder_FWD_DEFINED__
#define __ISpGrammarBuilder_FWD_DEFINED__
typedef interface ISpGrammarBuilder ISpGrammarBuilder;
#endif 	/* __ISpGrammarBuilder_FWD_DEFINED__ */


#ifndef __ISpRecoGrammar_FWD_DEFINED__
#define __ISpRecoGrammar_FWD_DEFINED__
typedef interface ISpRecoGrammar ISpRecoGrammar;
#endif 	/* __ISpRecoGrammar_FWD_DEFINED__ */


#ifndef __ISpGrammarBuilder2_FWD_DEFINED__
#define __ISpGrammarBuilder2_FWD_DEFINED__
typedef interface ISpGrammarBuilder2 ISpGrammarBuilder2;
#endif 	/* __ISpGrammarBuilder2_FWD_DEFINED__ */


#ifndef __ISpRecoGrammar2_FWD_DEFINED__
#define __ISpRecoGrammar2_FWD_DEFINED__
typedef interface ISpRecoGrammar2 ISpRecoGrammar2;
#endif 	/* __ISpRecoGrammar2_FWD_DEFINED__ */


#ifndef __ISpeechResourceLoader_FWD_DEFINED__
#define __ISpeechResourceLoader_FWD_DEFINED__
typedef interface ISpeechResourceLoader ISpeechResourceLoader;
#endif 	/* __ISpeechResourceLoader_FWD_DEFINED__ */


#ifndef __ISpRecoContext_FWD_DEFINED__
#define __ISpRecoContext_FWD_DEFINED__
typedef interface ISpRecoContext ISpRecoContext;
#endif 	/* __ISpRecoContext_FWD_DEFINED__ */


#ifndef __ISpRecoContext2_FWD_DEFINED__
#define __ISpRecoContext2_FWD_DEFINED__
typedef interface ISpRecoContext2 ISpRecoContext2;
#endif 	/* __ISpRecoContext2_FWD_DEFINED__ */


#ifndef __ISpProperties_FWD_DEFINED__
#define __ISpProperties_FWD_DEFINED__
typedef interface ISpProperties ISpProperties;
#endif 	/* __ISpProperties_FWD_DEFINED__ */


#ifndef __ISpRecognizer_FWD_DEFINED__
#define __ISpRecognizer_FWD_DEFINED__
typedef interface ISpRecognizer ISpRecognizer;
#endif 	/* __ISpRecognizer_FWD_DEFINED__ */


#ifndef __ISpSerializeState_FWD_DEFINED__
#define __ISpSerializeState_FWD_DEFINED__
typedef interface ISpSerializeState ISpSerializeState;
#endif 	/* __ISpSerializeState_FWD_DEFINED__ */


#ifndef __ISpRecognizer2_FWD_DEFINED__
#define __ISpRecognizer2_FWD_DEFINED__
typedef interface ISpRecognizer2 ISpRecognizer2;
#endif 	/* __ISpRecognizer2_FWD_DEFINED__ */


#ifndef __ISpRecoCategory_FWD_DEFINED__
#define __ISpRecoCategory_FWD_DEFINED__
typedef interface ISpRecoCategory ISpRecoCategory;
#endif 	/* __ISpRecoCategory_FWD_DEFINED__ */


#ifndef __ISpRecognizer3_FWD_DEFINED__
#define __ISpRecognizer3_FWD_DEFINED__
typedef interface ISpRecognizer3 ISpRecognizer3;
#endif 	/* __ISpRecognizer3_FWD_DEFINED__ */


#ifndef __ISpEnginePronunciation_FWD_DEFINED__
#define __ISpEnginePronunciation_FWD_DEFINED__
typedef interface ISpEnginePronunciation ISpEnginePronunciation;
#endif 	/* __ISpEnginePronunciation_FWD_DEFINED__ */


#ifndef __ISpeechDataKey_FWD_DEFINED__
#define __ISpeechDataKey_FWD_DEFINED__
typedef interface ISpeechDataKey ISpeechDataKey;
#endif 	/* __ISpeechDataKey_FWD_DEFINED__ */


#ifndef __ISpeechObjectToken_FWD_DEFINED__
#define __ISpeechObjectToken_FWD_DEFINED__
typedef interface ISpeechObjectToken ISpeechObjectToken;
#endif 	/* __ISpeechObjectToken_FWD_DEFINED__ */


#ifndef __ISpeechObjectTokens_FWD_DEFINED__
#define __ISpeechObjectTokens_FWD_DEFINED__
typedef interface ISpeechObjectTokens ISpeechObjectTokens;
#endif 	/* __ISpeechObjectTokens_FWD_DEFINED__ */


#ifndef __ISpeechObjectTokenCategory_FWD_DEFINED__
#define __ISpeechObjectTokenCategory_FWD_DEFINED__
typedef interface ISpeechObjectTokenCategory ISpeechObjectTokenCategory;
#endif 	/* __ISpeechObjectTokenCategory_FWD_DEFINED__ */


#ifndef __ISpeechAudioBufferInfo_FWD_DEFINED__
#define __ISpeechAudioBufferInfo_FWD_DEFINED__
typedef interface ISpeechAudioBufferInfo ISpeechAudioBufferInfo;
#endif 	/* __ISpeechAudioBufferInfo_FWD_DEFINED__ */


#ifndef __ISpeechAudioStatus_FWD_DEFINED__
#define __ISpeechAudioStatus_FWD_DEFINED__
typedef interface ISpeechAudioStatus ISpeechAudioStatus;
#endif 	/* __ISpeechAudioStatus_FWD_DEFINED__ */


#ifndef __ISpeechAudioFormat_FWD_DEFINED__
#define __ISpeechAudioFormat_FWD_DEFINED__
typedef interface ISpeechAudioFormat ISpeechAudioFormat;
#endif 	/* __ISpeechAudioFormat_FWD_DEFINED__ */


#ifndef __ISpeechWaveFormatEx_FWD_DEFINED__
#define __ISpeechWaveFormatEx_FWD_DEFINED__
typedef interface ISpeechWaveFormatEx ISpeechWaveFormatEx;
#endif 	/* __ISpeechWaveFormatEx_FWD_DEFINED__ */


#ifndef __ISpeechBaseStream_FWD_DEFINED__
#define __ISpeechBaseStream_FWD_DEFINED__
typedef interface ISpeechBaseStream ISpeechBaseStream;
#endif 	/* __ISpeechBaseStream_FWD_DEFINED__ */


#ifndef __ISpeechFileStream_FWD_DEFINED__
#define __ISpeechFileStream_FWD_DEFINED__
typedef interface ISpeechFileStream ISpeechFileStream;
#endif 	/* __ISpeechFileStream_FWD_DEFINED__ */


#ifndef __ISpeechMemoryStream_FWD_DEFINED__
#define __ISpeechMemoryStream_FWD_DEFINED__
typedef interface ISpeechMemoryStream ISpeechMemoryStream;
#endif 	/* __ISpeechMemoryStream_FWD_DEFINED__ */


#ifndef __ISpeechCustomStream_FWD_DEFINED__
#define __ISpeechCustomStream_FWD_DEFINED__
typedef interface ISpeechCustomStream ISpeechCustomStream;
#endif 	/* __ISpeechCustomStream_FWD_DEFINED__ */


#ifndef __ISpeechAudio_FWD_DEFINED__
#define __ISpeechAudio_FWD_DEFINED__
typedef interface ISpeechAudio ISpeechAudio;
#endif 	/* __ISpeechAudio_FWD_DEFINED__ */


#ifndef __ISpeechMMSysAudio_FWD_DEFINED__
#define __ISpeechMMSysAudio_FWD_DEFINED__
typedef interface ISpeechMMSysAudio ISpeechMMSysAudio;
#endif 	/* __ISpeechMMSysAudio_FWD_DEFINED__ */


#ifndef __ISpeechVoice_FWD_DEFINED__
#define __ISpeechVoice_FWD_DEFINED__
typedef interface ISpeechVoice ISpeechVoice;
#endif 	/* __ISpeechVoice_FWD_DEFINED__ */


#ifndef __ISpeechVoiceStatus_FWD_DEFINED__
#define __ISpeechVoiceStatus_FWD_DEFINED__
typedef interface ISpeechVoiceStatus ISpeechVoiceStatus;
#endif 	/* __ISpeechVoiceStatus_FWD_DEFINED__ */


#ifndef ___ISpeechVoiceEvents_FWD_DEFINED__
#define ___ISpeechVoiceEvents_FWD_DEFINED__
typedef interface _ISpeechVoiceEvents _ISpeechVoiceEvents;
#endif 	/* ___ISpeechVoiceEvents_FWD_DEFINED__ */


#ifndef __ISpeechRecognizer_FWD_DEFINED__
#define __ISpeechRecognizer_FWD_DEFINED__
typedef interface ISpeechRecognizer ISpeechRecognizer;
#endif 	/* __ISpeechRecognizer_FWD_DEFINED__ */


#ifndef __ISpeechRecognizerStatus_FWD_DEFINED__
#define __ISpeechRecognizerStatus_FWD_DEFINED__
typedef interface ISpeechRecognizerStatus ISpeechRecognizerStatus;
#endif 	/* __ISpeechRecognizerStatus_FWD_DEFINED__ */


#ifndef __ISpeechRecoContext_FWD_DEFINED__
#define __ISpeechRecoContext_FWD_DEFINED__
typedef interface ISpeechRecoContext ISpeechRecoContext;
#endif 	/* __ISpeechRecoContext_FWD_DEFINED__ */


#ifndef __ISpeechRecoGrammar_FWD_DEFINED__
#define __ISpeechRecoGrammar_FWD_DEFINED__
typedef interface ISpeechRecoGrammar ISpeechRecoGrammar;
#endif 	/* __ISpeechRecoGrammar_FWD_DEFINED__ */


#ifndef ___ISpeechRecoContextEvents_FWD_DEFINED__
#define ___ISpeechRecoContextEvents_FWD_DEFINED__
typedef interface _ISpeechRecoContextEvents _ISpeechRecoContextEvents;
#endif 	/* ___ISpeechRecoContextEvents_FWD_DEFINED__ */


#ifndef __ISpeechGrammarRule_FWD_DEFINED__
#define __ISpeechGrammarRule_FWD_DEFINED__
typedef interface ISpeechGrammarRule ISpeechGrammarRule;
#endif 	/* __ISpeechGrammarRule_FWD_DEFINED__ */


#ifndef __ISpeechGrammarRules_FWD_DEFINED__
#define __ISpeechGrammarRules_FWD_DEFINED__
typedef interface ISpeechGrammarRules ISpeechGrammarRules;
#endif 	/* __ISpeechGrammarRules_FWD_DEFINED__ */


#ifndef __ISpeechGrammarRuleState_FWD_DEFINED__
#define __ISpeechGrammarRuleState_FWD_DEFINED__
typedef interface ISpeechGrammarRuleState ISpeechGrammarRuleState;
#endif 	/* __ISpeechGrammarRuleState_FWD_DEFINED__ */


#ifndef __ISpeechGrammarRuleStateTransition_FWD_DEFINED__
#define __ISpeechGrammarRuleStateTransition_FWD_DEFINED__
typedef interface ISpeechGrammarRuleStateTransition ISpeechGrammarRuleStateTransition;
#endif 	/* __ISpeechGrammarRuleStateTransition_FWD_DEFINED__ */


#ifndef __ISpeechGrammarRuleStateTransitions_FWD_DEFINED__
#define __ISpeechGrammarRuleStateTransitions_FWD_DEFINED__
typedef interface ISpeechGrammarRuleStateTransitions ISpeechGrammarRuleStateTransitions;
#endif 	/* __ISpeechGrammarRuleStateTransitions_FWD_DEFINED__ */


#ifndef __ISpeechTextSelectionInformation_FWD_DEFINED__
#define __ISpeechTextSelectionInformation_FWD_DEFINED__
typedef interface ISpeechTextSelectionInformation ISpeechTextSelectionInformation;
#endif 	/* __ISpeechTextSelectionInformation_FWD_DEFINED__ */


#ifndef __ISpeechRecoResult_FWD_DEFINED__
#define __ISpeechRecoResult_FWD_DEFINED__
typedef interface ISpeechRecoResult ISpeechRecoResult;
#endif 	/* __ISpeechRecoResult_FWD_DEFINED__ */


#ifndef __ISpeechRecoResult2_FWD_DEFINED__
#define __ISpeechRecoResult2_FWD_DEFINED__
typedef interface ISpeechRecoResult2 ISpeechRecoResult2;
#endif 	/* __ISpeechRecoResult2_FWD_DEFINED__ */


#ifndef __ISpeechRecoResultTimes_FWD_DEFINED__
#define __ISpeechRecoResultTimes_FWD_DEFINED__
typedef interface ISpeechRecoResultTimes ISpeechRecoResultTimes;
#endif 	/* __ISpeechRecoResultTimes_FWD_DEFINED__ */


#ifndef __ISpeechPhraseAlternate_FWD_DEFINED__
#define __ISpeechPhraseAlternate_FWD_DEFINED__
typedef interface ISpeechPhraseAlternate ISpeechPhraseAlternate;
#endif 	/* __ISpeechPhraseAlternate_FWD_DEFINED__ */


#ifndef __ISpeechPhraseAlternates_FWD_DEFINED__
#define __ISpeechPhraseAlternates_FWD_DEFINED__
typedef interface ISpeechPhraseAlternates ISpeechPhraseAlternates;
#endif 	/* __ISpeechPhraseAlternates_FWD_DEFINED__ */


#ifndef __ISpeechPhraseInfo_FWD_DEFINED__
#define __ISpeechPhraseInfo_FWD_DEFINED__
typedef interface ISpeechPhraseInfo ISpeechPhraseInfo;
#endif 	/* __ISpeechPhraseInfo_FWD_DEFINED__ */


#ifndef __ISpeechPhraseElement_FWD_DEFINED__
#define __ISpeechPhraseElement_FWD_DEFINED__
typedef interface ISpeechPhraseElement ISpeechPhraseElement;
#endif 	/* __ISpeechPhraseElement_FWD_DEFINED__ */


#ifndef __ISpeechPhraseElements_FWD_DEFINED__
#define __ISpeechPhraseElements_FWD_DEFINED__
typedef interface ISpeechPhraseElements ISpeechPhraseElements;
#endif 	/* __ISpeechPhraseElements_FWD_DEFINED__ */


#ifndef __ISpeechPhraseReplacement_FWD_DEFINED__
#define __ISpeechPhraseReplacement_FWD_DEFINED__
typedef interface ISpeechPhraseReplacement ISpeechPhraseReplacement;
#endif 	/* __ISpeechPhraseReplacement_FWD_DEFINED__ */


#ifndef __ISpeechPhraseReplacements_FWD_DEFINED__
#define __ISpeechPhraseReplacements_FWD_DEFINED__
typedef interface ISpeechPhraseReplacements ISpeechPhraseReplacements;
#endif 	/* __ISpeechPhraseReplacements_FWD_DEFINED__ */


#ifndef __ISpeechPhraseProperty_FWD_DEFINED__
#define __ISpeechPhraseProperty_FWD_DEFINED__
typedef interface ISpeechPhraseProperty ISpeechPhraseProperty;
#endif 	/* __ISpeechPhraseProperty_FWD_DEFINED__ */


#ifndef __ISpeechPhraseProperties_FWD_DEFINED__
#define __ISpeechPhraseProperties_FWD_DEFINED__
typedef interface ISpeechPhraseProperties ISpeechPhraseProperties;
#endif 	/* __ISpeechPhraseProperties_FWD_DEFINED__ */


#ifndef __ISpeechPhraseRule_FWD_DEFINED__
#define __ISpeechPhraseRule_FWD_DEFINED__
typedef interface ISpeechPhraseRule ISpeechPhraseRule;
#endif 	/* __ISpeechPhraseRule_FWD_DEFINED__ */


#ifndef __ISpeechPhraseRules_FWD_DEFINED__
#define __ISpeechPhraseRules_FWD_DEFINED__
typedef interface ISpeechPhraseRules ISpeechPhraseRules;
#endif 	/* __ISpeechPhraseRules_FWD_DEFINED__ */


#ifndef __ISpeechLexicon_FWD_DEFINED__
#define __ISpeechLexicon_FWD_DEFINED__
typedef interface ISpeechLexicon ISpeechLexicon;
#endif 	/* __ISpeechLexicon_FWD_DEFINED__ */


#ifndef __ISpeechLexiconWords_FWD_DEFINED__
#define __ISpeechLexiconWords_FWD_DEFINED__
typedef interface ISpeechLexiconWords ISpeechLexiconWords;
#endif 	/* __ISpeechLexiconWords_FWD_DEFINED__ */


#ifndef __ISpeechLexiconWord_FWD_DEFINED__
#define __ISpeechLexiconWord_FWD_DEFINED__
typedef interface ISpeechLexiconWord ISpeechLexiconWord;
#endif 	/* __ISpeechLexiconWord_FWD_DEFINED__ */


#ifndef __ISpeechLexiconPronunciations_FWD_DEFINED__
#define __ISpeechLexiconPronunciations_FWD_DEFINED__
typedef interface ISpeechLexiconPronunciations ISpeechLexiconPronunciations;
#endif 	/* __ISpeechLexiconPronunciations_FWD_DEFINED__ */


#ifndef __ISpeechLexiconPronunciation_FWD_DEFINED__
#define __ISpeechLexiconPronunciation_FWD_DEFINED__
typedef interface ISpeechLexiconPronunciation ISpeechLexiconPronunciation;
#endif 	/* __ISpeechLexiconPronunciation_FWD_DEFINED__ */


#ifndef __ISpeechXMLRecoResult_FWD_DEFINED__
#define __ISpeechXMLRecoResult_FWD_DEFINED__
typedef interface ISpeechXMLRecoResult ISpeechXMLRecoResult;
#endif 	/* __ISpeechXMLRecoResult_FWD_DEFINED__ */


#ifndef __ISpeechRecoResultDispatch_FWD_DEFINED__
#define __ISpeechRecoResultDispatch_FWD_DEFINED__
typedef interface ISpeechRecoResultDispatch ISpeechRecoResultDispatch;
#endif 	/* __ISpeechRecoResultDispatch_FWD_DEFINED__ */


#ifndef __ISpeechPhraseInfoBuilder_FWD_DEFINED__
#define __ISpeechPhraseInfoBuilder_FWD_DEFINED__
typedef interface ISpeechPhraseInfoBuilder ISpeechPhraseInfoBuilder;
#endif 	/* __ISpeechPhraseInfoBuilder_FWD_DEFINED__ */


#ifndef __ISpeechPhoneConverter_FWD_DEFINED__
#define __ISpeechPhoneConverter_FWD_DEFINED__
typedef interface ISpeechPhoneConverter ISpeechPhoneConverter;
#endif 	/* __ISpeechPhoneConverter_FWD_DEFINED__ */


#ifndef __SpNotifyTranslator_FWD_DEFINED__
#define __SpNotifyTranslator_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpNotifyTranslator SpNotifyTranslator;
#else
typedef struct SpNotifyTranslator SpNotifyTranslator;
#endif /* __cplusplus */

#endif 	/* __SpNotifyTranslator_FWD_DEFINED__ */


#ifndef __SpObjectTokenCategory_FWD_DEFINED__
#define __SpObjectTokenCategory_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpObjectTokenCategory SpObjectTokenCategory;
#else
typedef struct SpObjectTokenCategory SpObjectTokenCategory;
#endif /* __cplusplus */

#endif 	/* __SpObjectTokenCategory_FWD_DEFINED__ */


#ifndef __SpObjectToken_FWD_DEFINED__
#define __SpObjectToken_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpObjectToken SpObjectToken;
#else
typedef struct SpObjectToken SpObjectToken;
#endif /* __cplusplus */

#endif 	/* __SpObjectToken_FWD_DEFINED__ */


#ifndef __SpResourceManager_FWD_DEFINED__
#define __SpResourceManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpResourceManager SpResourceManager;
#else
typedef struct SpResourceManager SpResourceManager;
#endif /* __cplusplus */

#endif 	/* __SpResourceManager_FWD_DEFINED__ */


#ifndef __SpStreamFormatConverter_FWD_DEFINED__
#define __SpStreamFormatConverter_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpStreamFormatConverter SpStreamFormatConverter;
#else
typedef struct SpStreamFormatConverter SpStreamFormatConverter;
#endif /* __cplusplus */

#endif 	/* __SpStreamFormatConverter_FWD_DEFINED__ */


#ifndef __SpMMAudioEnum_FWD_DEFINED__
#define __SpMMAudioEnum_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpMMAudioEnum SpMMAudioEnum;
#else
typedef struct SpMMAudioEnum SpMMAudioEnum;
#endif /* __cplusplus */

#endif 	/* __SpMMAudioEnum_FWD_DEFINED__ */


#ifndef __SpMMAudioIn_FWD_DEFINED__
#define __SpMMAudioIn_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpMMAudioIn SpMMAudioIn;
#else
typedef struct SpMMAudioIn SpMMAudioIn;
#endif /* __cplusplus */

#endif 	/* __SpMMAudioIn_FWD_DEFINED__ */


#ifndef __SpMMAudioOut_FWD_DEFINED__
#define __SpMMAudioOut_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpMMAudioOut SpMMAudioOut;
#else
typedef struct SpMMAudioOut SpMMAudioOut;
#endif /* __cplusplus */

#endif 	/* __SpMMAudioOut_FWD_DEFINED__ */


#ifndef __SpStream_FWD_DEFINED__
#define __SpStream_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpStream SpStream;
#else
typedef struct SpStream SpStream;
#endif /* __cplusplus */

#endif 	/* __SpStream_FWD_DEFINED__ */


#ifndef __SpVoice_FWD_DEFINED__
#define __SpVoice_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpVoice SpVoice;
#else
typedef struct SpVoice SpVoice;
#endif /* __cplusplus */

#endif 	/* __SpVoice_FWD_DEFINED__ */


#ifndef __SpSharedRecoContext_FWD_DEFINED__
#define __SpSharedRecoContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpSharedRecoContext SpSharedRecoContext;
#else
typedef struct SpSharedRecoContext SpSharedRecoContext;
#endif /* __cplusplus */

#endif 	/* __SpSharedRecoContext_FWD_DEFINED__ */


#ifndef __SpInprocRecognizer_FWD_DEFINED__
#define __SpInprocRecognizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpInprocRecognizer SpInprocRecognizer;
#else
typedef struct SpInprocRecognizer SpInprocRecognizer;
#endif /* __cplusplus */

#endif 	/* __SpInprocRecognizer_FWD_DEFINED__ */


#ifndef __SpSharedRecognizer_FWD_DEFINED__
#define __SpSharedRecognizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpSharedRecognizer SpSharedRecognizer;
#else
typedef struct SpSharedRecognizer SpSharedRecognizer;
#endif /* __cplusplus */

#endif 	/* __SpSharedRecognizer_FWD_DEFINED__ */


#ifndef __SpLexicon_FWD_DEFINED__
#define __SpLexicon_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpLexicon SpLexicon;
#else
typedef struct SpLexicon SpLexicon;
#endif /* __cplusplus */

#endif 	/* __SpLexicon_FWD_DEFINED__ */


#ifndef __SpUnCompressedLexicon_FWD_DEFINED__
#define __SpUnCompressedLexicon_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpUnCompressedLexicon SpUnCompressedLexicon;
#else
typedef struct SpUnCompressedLexicon SpUnCompressedLexicon;
#endif /* __cplusplus */

#endif 	/* __SpUnCompressedLexicon_FWD_DEFINED__ */


#ifndef __SpCompressedLexicon_FWD_DEFINED__
#define __SpCompressedLexicon_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpCompressedLexicon SpCompressedLexicon;
#else
typedef struct SpCompressedLexicon SpCompressedLexicon;
#endif /* __cplusplus */

#endif 	/* __SpCompressedLexicon_FWD_DEFINED__ */


#ifndef __SpShortcut_FWD_DEFINED__
#define __SpShortcut_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpShortcut SpShortcut;
#else
typedef struct SpShortcut SpShortcut;
#endif /* __cplusplus */

#endif 	/* __SpShortcut_FWD_DEFINED__ */


#ifndef __SpPhoneConverter_FWD_DEFINED__
#define __SpPhoneConverter_FWD_DEFINED__

#ifdef __cplusplus
typedef class SpPhoneConverter SpPhoneConverter;
#else
typedef struct SpPhoneConverter SpPhoneConverter;
#endif /* __cplusplus */

#endif 	/* __Sp