lType ) {
    case CTRL_C_EVENT:
    case CTRL_BREAK_EVENT:
    case CTRL_CLOSE_EVENT:

        fprintf( stdout, "Terminating...\n" );

        //
        // Close notification and connection if needed
        //

        if ( fNotificationOpened ) {
            DmCloseNotificationSession( DmSession );
        }

        if ( fConnectionOpened ) {
            DmUseSharedConnection( FALSE );
        }

        return FALSE;
    }

    return TRUE;
}








/////////////////////////////////////////////////////////////////////////////
// CNetDebug


STDMETHODIMP CNetDebug::Connect(BSTR xboxName)
{
    HRESULT hr = S_OK;
	
	//
	//  Hook Ctrl+C handle so that we can do cleanup work
	//

	SetConsoleCtrlHandler( ConsoleCtrlHandler, TRUE );

    //
    // Open a shared debug connection with xbdm
    //

    hr = DmUseSharedConnection( TRUE );

    if ( FAILED(hr) )
	{
        TranslateError( hr );
    	return hr;
    }
	else
	{
        fConnectionOpened = TRUE;
    }

	LPSTR Ansi_XboxName = NULL;
	UnicodeToAnsi(xboxName,&Ansi_XboxName);
	
	cout<<"Connect to - "<<Ansi_XboxName<<endl;
	
	hr = DmSetXboxName(Ansi_XboxName);

	if ( FAILED(hr) )
	{
        TranslateError( hr );
    	DmUseSharedConnection( FALSE );
		return 1;
    }

	return hr;
}



STDMETHODIMP CNetDebug::Start()
{

	cout<<"START"<<endl;

	HRESULT hr = S_OK;


	LIST_HEAD = new debugline;
	LIST_HEAD->data = NULL;
	LIST_HEAD->next = NULL;


	hr = DmOpenNotificationSession( DM_PERSISTENT, &DmSession );

	
    if ( SUCCEEDED(hr) ) 
	{
        fNotificationOpened = TRUE;
        
		hr = DmNotify( DmSession, DM_DEBUGSTR, NotificationProc );
		if ( SUCCEEDED(hr) )
		{
			cout<<"+++++++++++++++++++++++++++++++++++Started Listening"<<endl;
		}
		else
		{
			TranslateError( hr );
		}
	}
	else
	{
		TranslateError( hr );
	}
	
	return hr;

}


STDMETHODIMP CNetDebug::Stop()
{
	cout<<"Stop"<<endl;
	return DmCloseNotificationSession( DmSession );
}

STDMETHODIMP CNetDebug::GetLine(unsigned int lineNum, short operation, BSTR *pVal)
{
	cout<<"GetLine"<<endl;


	return S_OK;
}

STDMETHODIMP CNetDebug::GetAllLines(BOOL clear, BSTR *pVal)
{
	cout<<"***********************************GetAllLines"<<endl;
	*pVal = output_lines(LIST_HEAD);
	return S_OK;
}

STDMETHODIMP CNetDebug::get_ParseTag(BSTR *pVal)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CNetDebug::put_ParseTag(BSTR newVal)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CNetDebug::Disconnect()
{
	cout<<"Disconnect"<<endl;
	clear(LIST_HEAD);
	return DmUseSharedConnection( FALSE );

}

STDMETHODIMP CNetDebug::ClearLines()
{
	cout<<"ClearLines"<<endl;
	
	clear(LIST_HEAD);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\automation\xbDebug\xbDebug.cpp ===
// xbDebug.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f xbDebugps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "xbDebug.h"

#include "xbDebug_i.c"
#include "NetDebug.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_NetDebug, CNetDebug)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_XBDEBUGLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\automation\xbDebug\xbDebug_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Feb 11 15:00:43 2002
 */
/* Compiler settings for C:\xbox\private\test\ui\automation\xbDebug\xbDebug.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_INetDebug = {0xB6BD872B,0xD6C7,0x4ACD,{0x97,0x04,0x81,0xF4,0xDC,0xE6,0x5C,0xA4}};


const IID LIBID_XBDEBUGLib = {0x2EF1DC7D,0xB7B4,0x4B86,{0x92,0xBE,0x93,0x57,0x20,0xE3,0x25,0xBB}};


const CLSID CLSID_NetDebug = {0xB11C43CA,0x5735,0x43FD,{0x98,0xAF,0x52,0x87,0x5C,0xC5,0x6E,0xA7}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\automation\xbDebug\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xbDebug.rc
//
#define IDS_PROJNAME                    100
#define IDR_NETDEBUG                    101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\automation\xbDebug\NetDebug.h ===
// NetDebug.h : Declaration of the CNetDebug

#ifndef __NETDEBUG_H_
#define __NETDEBUG_H_

#include "resource.h"       // main symbols


#include <windows.h>
#include <stdio.h>
#include <xboxdbg.h>




/////////////////////////////////////////////////////////////////////////////
// CNetDebug
class ATL_NO_VTABLE CNetDebug : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CNetDebug, &CLSID_NetDebug>,
	public IDispatchImpl<INetDebug, &IID_INetDebug, &LIBID_XBDEBUGLib>
{
public:
	CNetDebug()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_NETDEBUG)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNetDebug)
	COM_INTERFACE_ENTRY(INetDebug)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// INetDebug
public:
	STDMETHOD(ClearLines)();
	STDMETHOD(Disconnect)();
	STDMETHOD(get_ParseTag)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ParseTag)(/*[in]*/ BSTR newVal);
	STDMETHOD(GetAllLines)(/*[in]*/ BOOL clear, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(GetLine)(/*[in]*/ unsigned lineNum, /*[in]*/ short operation, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(Stop)();
	STDMETHOD(Start)();
	STDMETHOD(Connect)(/*[in]*/ BSTR xboxName);
};



#endif //__NETDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\Cortana\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\automation\xbDebug\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__83736F15_2667_435D_B691_5C671E7D0BF7__INCLUDED_)
#define AFX_STDAFX_H__83736F15_2667_435D_B691_5C671E7D0BF7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__83736F15_2667_435D_B691_5C671E7D0BF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\automation\xbDebug\xbDebug.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Feb 11 15:00:43 2002
 */
/* Compiler settings for C:\xbox\private\test\ui\automation\xbDebug\xbDebug.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __xbDebug_h__
#define __xbDebug_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __INetDebug_FWD_DEFINED__
#define __INetDebug_FWD_DEFINED__
typedef interface INetDebug INetDebug;
#endif 	/* __INetDebug_FWD_DEFINED__ */


#ifndef __NetDebug_FWD_DEFINED__
#define __NetDebug_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetDebug NetDebug;
#else
typedef struct NetDebug NetDebug;
#endif /* __cplusplus */

#endif 	/* __NetDebug_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __INetDebug_INTERFACE_DEFINED__
#define __INetDebug_INTERFACE_DEFINED__

/* interface INetDebug */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_INetDebug;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B6BD872B-D6C7-4ACD-9704-81F4DCE65CA4")
    INetDebug : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ BSTR xboxName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLine( 
            /* [in] */ unsigned int lineNum,
            /* [in] */ short operation,
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetAllLines( 
            /* [in] */ BOOL clear,
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ParseTag( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ParseTag( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ClearLines( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetDebugVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INetDebug __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INetDebug __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INetDebug __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            INetDebug __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            INetDebug __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            INetDebug __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            INetDebug __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            INetDebug __RPC_FAR * This,
            /* [in] */ BSTR xboxName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            INetDebug __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            INetDebug __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLine )( 
            INetDebug __RPC_FAR * This,
            /* [in] */ unsigned int lineNum,
            /* [in] */ short operation,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllLines )( 
            INetDebug __RPC_FAR * This,
            /* [in] */ BOOL clear,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ParseTag )( 
            INetDebug __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ParseTag )( 
            INetDebug __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            INetDebug __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearLines )( 
            INetDebug __RPC_FAR * This);
        
        END_INTERFACE
    } INetDebugVtbl;

    interface INetDebug
    {
        CONST_VTBL struct INetDebugVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetDebug_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetDebug_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetDebug_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetDebug_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define INetDebug_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define INetDebug_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define INetDebug_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define INetDebug_Connect(This,xboxName)	\
    (This)->lpVtbl -> Connect(This,xboxName)

#define INetDebug_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define INetDebug_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define INetDebug_GetLine(This,lineNum,operation,pVal)	\
    (This)->lpVtbl -> GetLine(This,lineNum,operation,pVal)

#define INetDebug_GetAllLines(This,clear,pVal)	\
    (This)->lpVtbl -> GetAllLines(This,clear,pVal)

#define INetDebug_get_ParseTag(This,pVal)	\
    (This)->lpVtbl -> get_ParseTag(This,pVal)

#define INetDebug_put_ParseTag(This,newVal)	\
    (This)->lpVtbl -> put_ParseTag(This,newVal)

#define INetDebug_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define INetDebug_ClearLines(This)	\
    (This)->lpVtbl -> ClearLines(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE INetDebug_Connect_Proxy( 
    INetDebug __RPC_FAR * This,
    /* [in] */ BSTR xboxName);


void __RPC_STUB INetDebug_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE INetDebug_Start_Proxy( 
    INetDebug __RPC_FAR * This);


void __RPC_STUB INetDebug_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE INetDebug_Stop_Proxy( 
    INetDebug __RPC_FAR * This);


void __RPC_STUB INetDebug_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE INetDebug_GetLine_Proxy( 
    INetDebug __RPC_FAR * This,
    /* [in] */ unsigned int lineNum,
    /* [in] */ short operation,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB INetDebug_GetLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE INetDebug_GetAllLines_Proxy( 
    INetDebug __RPC_FAR * This,
    /* [in] */ BOOL clear,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB INetDebug_GetAllLines_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE INetDebug_get_ParseTag_Proxy( 
    INetDebug __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB INetDebug_get_ParseTag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE INetDebug_put_ParseTag_Proxy( 
    INetDebug __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB INetDebug_put_ParseTag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE INetDebug_Disconnect_Proxy( 
    INetDebug __RPC_FAR * This);


void __RPC_STUB INetDebug_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE INetDebug_ClearLines_Proxy( 
    INetDebug __RPC_FAR * This);


void __RPC_STUB INetDebug_ClearLines_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetDebug_INTERFACE_DEFINED__ */



#ifndef __XBDEBUGLib_LIBRARY_DEFINED__
#define __XBDEBUGLib_LIBRARY_DEFINED__

/* library XBDEBUGLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_XBDEBUGLib;

EXTERN_C const CLSID CLSID_NetDebug;

#ifdef __cplusplus

class DECLSPEC_UUID("B11C43CA-5735-43FD-98AF-52875CC56EA7")
NetDebug;
#endif
#endif /* __XBDEBUGLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\automation\xbnetdbg\xbnetdbg.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xbnetdbg.h

Abstract:

    This is a pre-compiled header file for Xbox debug message monitor

--*/

#include <windows.h>
#include <stdio.h>
#include <xboxdbg.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\automation\xbnetdbg\xbnetdbg.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xbnetdbg.cpp

Abstract:

    This module implements routines which monitor debug message from Xbox.
    The debug messages are captured using XboxDbg notification mechanism.

--*/

#include "xbnetdbg.h"

PDMN_SESSION DmSession = NULL;
BOOL fNotificationOpened = FALSE;
BOOL fConnectionOpened = FALSE;


VOID
TranslateError(
    HRESULT hr
    )

/*
Routine Description:

    This routine translates HRESULT returned from XboxDbg APIs into string and
    output to standard error

Auguments:

    hr - HRESULT returned from various XboxDbg APIs

Return Value:

    None
*/

{
    CHAR Buffer[512];

    DmTranslateErrorA( hr, Buffer, sizeof(Buffer) );
    fprintf( stderr, Buffer );
}



DWORD
WINAPI
NotificationProc(
    ULONG Notification,
    DWORD Parameter
    )
/*++

Routine Description:

    This is a callback routine registered by DmNotify.  It is called by XboxDbg
    for various types of notification event.

Arguments:

    Notification - Type of notification, DM_DEBUGSTR for example

    Parameter - Optional parameter based on notification type

Return Value:

    Always zero

--*/
{
    PDMN_DEBUGSTR p = (PDMN_DEBUGSTR)Parameter;

    //
    // Process only if notification type is DM_DEBUGSTR and there is
    // a valid string length
    //

    if ( Notification == DM_DEBUGSTR && p->Length ) {
        fprintf( stdout, "%.*s", p->Length, p->String );
    }

    return 0;
}

BOOL
WINAPI
ConsoleCtrlHandler(
    DWORD CtrlType
    )
/*++

Routine Description:

    A HandlerRoutine function is an application-defined function used with
    the SetConsoleCtrlHandler function.  A console process uses this function
    to handle control signals received by the process

Arguments:

    CtrlType - Indicates the type of control signal received by the handler.

Return Value:

    Return FALSE to terminate the process

--*/
{
    switch ( CtrlType ) {
    case CTRL_C_EVENT:
    case CTRL_BREAK_EVENT:
    case CTRL_CLOSE_EVENT:

        fprintf( stdout, "Terminating...\n" );

        //
        // Close notification and connection if needed
        //

        if ( fNotificationOpened ) {
            DmCloseNotificationSession( DmSession );
        }

        if ( fConnectionOpened ) {
            DmUseSharedConnection( FALSE );
        }

        return FALSE;
    }

    return TRUE;
}

int __cdecl main( int cArg, char **rgszArg )
{
    char *szExe = *rgszArg;
    HRESULT hr;

    //
    // Hook Ctrl+C handle so that we can do a cleanup work
    //

    SetConsoleCtrlHandler( ConsoleCtrlHandler, TRUE );

    //
    // Open a shared debug connection with xbdm
    //

    hr = DmUseSharedConnection( TRUE );

    if ( FAILED(hr) ) {
        TranslateError( hr );
        return 1;
    } else {
        fConnectionOpened = TRUE;
    }

    //
    // Process command line arguments if any
    //

    ++rgszArg;

    while ( --cArg ) {

        if ( **rgszArg != '-' && **rgszArg != '/' ) {
usage:
            fprintf( stderr, "usage: %s [-x xboxname]\n", szExe );
            DmUseSharedConnection( FALSE );
            return 1;
        }

        char *szArg = *rgszArg++;

        while( *++szArg ) {

            switch( *szArg ) {
            case 'x':
            case 'X':
                if (!--cArg) {
                    goto usage;
                }

                hr = DmSetXboxName( *rgszArg++ );

                if( FAILED(hr) ) {
                    TranslateError( hr );
                    DmUseSharedConnection( FALSE );
                    return 1;
                }
                break;

            default:
                goto usage;
            }
        }
    }

    fprintf( stdout, "Initializing...\n" );
    hr = DmOpenNotificationSession( DM_PERSISTENT, &DmSession );

    if ( SUCCEEDED(hr) ) {

        fNotificationOpened = TRUE;

        hr = DmNotify( DmSession, DM_DEBUGSTR, NotificationProc );

        if ( SUCCEEDED(hr) ) {
            fprintf( stdout, "Start listening (Ctrl+C to exit)...\n" );
            Sleep( INFINITE );
        } else {
            TranslateError( hr );
        }

        DmCloseNotificationSession( DmSession );

    } else {
        TranslateError( hr );
    }

    DmUseSharedConnection( FALSE );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\automation\xbDebug\xbDebug_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Feb 11 15:00:43 2002
 */
/* Compiler settings for C:\xbox\private\test\ui\automation\xbDebug\xbDebug.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )

#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "xbDebug.h"

#define TYPE_FORMAT_STRING_SIZE   55                                
#define PROC_FORMAT_STRING_SIZE   247                               

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: INetDebug, ver. 0.0,
   GUID={0xB6BD872B,0xD6C7,0x4ACD,{0x97,0x04,0x81,0xF4,0xDC,0xE6,0x5C,0xA4}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO INetDebug_ServerInfo;

#pragma code_seg(".orpc")
extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[1];

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x50100a4, /* MIDL Version 5.1.164 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    1,  /* Flags */
    0,  /* Reserved3 */
    0,  /* Reserved4 */
    0   /* Reserved5 */
    };

static const unsigned short INetDebug_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    28,
    50,
    72,
    112,
    146,
    174,
    202,
    224
    };

static const MIDL_SERVER_INFO INetDebug_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &INetDebug_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO INetDebug_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &INetDebug_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(16) _INetDebugProxyVtbl = 
{
    &INetDebug_ProxyInfo,
    &IID_INetDebug,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* INetDebug::Connect */ ,
    (void *)-1 /* INetDebug::Start */ ,
    (void *)-1 /* INetDebug::Stop */ ,
    (void *)-1 /* INetDebug::GetLine */ ,
    (void *)-1 /* INetDebug::GetAllLines */ ,
    (void *)-1 /* INetDebug::get_ParseTag */ ,
    (void *)-1 /* INetDebug::put_ParseTag */ ,
    (void *)-1 /* INetDebug::Disconnect */ ,
    (void *)-1 /* INetDebug::ClearLines */
};


static const PRPC_STUB_FUNCTION INetDebug_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _INetDebugStubVtbl =
{
    &IID_INetDebug,
    &INetDebug_ServerInfo,
    16,
    &INetDebug_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

#pragma data_seg(".rdata")

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[1] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf, [wire_marshal] or [user_marshal] attribute, more than 32 methods in the interface.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure Connect */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/*  8 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter xboxName */

/* 16 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 18 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 20 */	NdrFcShort( 0x1a ),	/* Type Offset=26 */

	/* Return value */

/* 22 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 24 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 26 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Start */

/* 28 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 30 */	NdrFcLong( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 36 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
/* 40 */	NdrFcShort( 0x8 ),	/* 8 */
/* 42 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 44 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 46 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 48 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Stop */

/* 50 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 52 */	NdrFcLong( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0x9 ),	/* 9 */
#ifndef _ALPHA_
/* 58 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0x8 ),	/* 8 */
/* 64 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 66 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 68 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 70 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetLine */

/* 72 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 74 */	NdrFcLong( 0x0 ),	/* 0 */
/* 78 */	NdrFcShort( 0xa ),	/* 10 */
#ifndef _ALPHA_
/* 80 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 82 */	NdrFcShort( 0xe ),	/* 14 */
/* 84 */	NdrFcShort( 0x8 ),	/* 8 */
/* 86 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter lineNum */

/* 88 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 90 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 92 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter operation */

/* 94 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 96 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 98 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Parameter pVal */

/* 100 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 102 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 104 */	NdrFcShort( 0x2c ),	/* Type Offset=44 */

	/* Return value */

/* 106 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 108 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 110 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAllLines */

/* 112 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 114 */	NdrFcLong( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0xb ),	/* 11 */
#ifndef _ALPHA_
/* 120 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 122 */	NdrFcShort( 0x8 ),	/* 8 */
/* 124 */	NdrFcShort( 0x8 ),	/* 8 */
/* 126 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter clear */

/* 128 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 130 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 132 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pVal */

/* 134 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 136 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 138 */	NdrFcShort( 0x2c ),	/* Type Offset=44 */

	/* Return value */

/* 140 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 142 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 144 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ParseTag */

/* 146 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 148 */	NdrFcLong( 0x0 ),	/* 0 */
/* 152 */	NdrFcShort( 0xc ),	/* 12 */
#ifndef _ALPHA_
/* 154 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 156 */	NdrFcShort( 0x0 ),	/* 0 */
/* 158 */	NdrFcShort( 0x8 ),	/* 8 */
/* 160 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pVal */

/* 162 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 164 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 166 */	NdrFcShort( 0x2c ),	/* Type Offset=44 */

	/* Return value */

/* 168 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 170 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 172 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_ParseTag */

/* 174 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 176 */	NdrFcLong( 0x0 ),	/* 0 */
/* 180 */	NdrFcShort( 0xd ),	/* 13 */
#ifndef _ALPHA_
/* 182 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 184 */	NdrFcShort( 0x0 ),	/* 0 */
/* 186 */	NdrFcShort( 0x8 ),	/* 8 */
/* 188 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter newVal */

/* 190 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 192 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 194 */	NdrFcShort( 0x1a ),	/* Type Offset=26 */

	/* Return value */

/* 196 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 198 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 200 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Disconnect */

/* 202 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 204 */	NdrFcLong( 0x0 ),	/* 0 */
/* 208 */	NdrFcShort( 0xe ),	/* 14 */
#ifndef _ALPHA_
/* 210 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 212 */	NdrFcShort( 0x0 ),	/* 0 */
/* 214 */	NdrFcShort( 0x8 ),	/* 8 */
/* 216 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 218 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 220 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 222 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ClearLines */

/* 224 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 226 */	NdrFcLong( 0x0 ),	/* 0 */
/* 230 */	NdrFcShort( 0xf ),	/* 15 */
#ifndef _ALPHA_
/* 232 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 236 */	NdrFcShort( 0x8 ),	/* 8 */
/* 238 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 240 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 242 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 244 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0xc ),	/* Offset= 12 (16) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 16 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 18 */	NdrFcShort( 0x8 ),	/* 8 */
/* 20 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (6) */
/* 22 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 24 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 26 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */
/* 30 */	NdrFcShort( 0x4 ),	/* 4 */
/* 32 */	NdrFcShort( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (2) */
/* 36 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 38 */	NdrFcShort( 0x6 ),	/* Offset= 6 (44) */
/* 40 */	
			0x13, 0x0,	/* FC_OP */
/* 42 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (16) */
/* 44 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 46 */	NdrFcShort( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0x4 ),	/* 4 */
/* 50 */	NdrFcShort( 0x0 ),	/* 0 */
/* 52 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (40) */

			0x0
        }
    };

const CInterfaceProxyVtbl * _xbDebug_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_INetDebugProxyVtbl,
    0
};

const CInterfaceStubVtbl * _xbDebug_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_INetDebugStubVtbl,
    0
};

PCInterfaceName const _xbDebug_InterfaceNamesList[] = 
{
    "INetDebug",
    0
};

const IID *  _xbDebug_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _xbDebug_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _xbDebug, pIID, n)

int __stdcall _xbDebug_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_xbDebug_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo xbDebug_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _xbDebug_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _xbDebug_StubVtblList,
    (const PCInterfaceName * ) & _xbDebug_InterfaceNamesList,
    (const IID ** ) & _xbDebug_BaseIIDList,
    & _xbDebug_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\Cortana\Input.cs ===
using System;


namespace Cortana
{

	public class Simulator
	{
		//
		//PRIVATE DECLARATIONS
		//
		//declarations of the available objects
		private USBSIMULATORLib.SimulatorClass simulator = new USBSIMULATORLib.SimulatorClass();
		private USBSIMULATORLib.DukeClass duke = new USBSIMULATORLib.DukeClass();
		private USBSIMULATORLib.MUClass mu = new USBSIMULATORLib.MUClass();
		private USBSIMULATORLib.HawkClass hawk = new USBSIMULATORLib.HawkClass();
		
		//Private Methods
		private bool InsertDevice(USBSIMULATORLib.DukeClass dev)
		{
			//Plugs in a duke and verifies it's connection
			int retry = 3;
			int time;
			do  
			{
				dev.Plug();
				for(time=32; time<1000; time*=2)
				{
					System.Threading.Thread.Sleep(time);
					if(dev.enumerated == 1) return true;
				}
				dev.Unplug();
				System.Threading.Thread.Sleep(250);
				--retry;
			} while(retry != 0);
			
			Console.WriteLine("[InsertDevice]:Failed to enumerate Duke");
			return false;
		}

		private string VerifySimulator(string address) 
		{
			//Verifies the simulator is connected to the address that is given
			
			string version = simulator.GetVersion(address);
			if(version == "")
			{
				return "";
			}

			short boards = simulator.GetUSBPorts(address);
			if(boards == 0)
			{
				return "no USB";
			}
			
			string simulatorStats = "Simulator (" + address + "):\n";
			simulatorStats += "  Version:    " + version + "\n";
			simulatorStats += "  MacAddr:    " + simulator.GetMACAddr(address) + "\n";
			simulatorStats += "  USB Boards: NOT SURE\n";

			return simulatorStats;
		}

		
			
		//PUBLIC PROPERTIES
		public string SIMULATOR_IP;
		public ushort BUTTON_DOWN_DELAY
		{
			// The USB simulator will hold the button down this long before releasing
			get 
			{ 
				return duke.buttonDownDelay; 
			}
			set 
			{
				duke.buttonDownDelay = value;
 			}
		}

		public ushort BUTTON_UP_DELAY
		{
			// The USB simulator will wait this long before proceeding after a button press
			get
			{
				return duke.buttonUpDelay;
			}
			set
			{
				duke.buttonUpDelay = value;
			}
		}

		public int XDASH_TRANSITION_DELAY;  // Seconds it takes to transition between menus
		public short DUKE_PORT
		{
			// Port on USBsim that will drive the duke
			get
			{
				return duke.port;
			}
			set
			{
				duke.port = value;
			}
		}


		//METHODS
		public Simulator()
		{
			//Default Constructor
			SIMULATOR_IP = "";
			XDASH_TRANSITION_DELAY = 0;

		}

		~Simulator()
		{
			duke.Unplug();
			mu.Unplug();
			hawk.Unplug();

			duke.Free();
			mu.Free();
			hawk.Free();
		}

		public bool PlugDuke()
		{
			//Checks to see if we set the simulator_IP
			if (SIMULATOR_IP == "")
			{
				Console.WriteLine("[PlugDuke]:SIMULATOR_IP not set");
				return false;
			}

			//Checks to see if we set the DUKE_PORT
			if (duke.port == 0)
			{
				Console.WriteLine("[PlugDuke]:DUKE_PORT not set");
				return false;
			}

			// This Verifies that the Simulator is connected
			// before trying to connect a duke
			string SimStatus = VerifySimulator(SIMULATOR_IP);
			if (SimStatus == "")
			{
				Console.WriteLine("[PlugDuke]:The Simulator is not connected");
			}
			else
			{
				Console.WriteLine("[PlugDuke]:" + SimStatus);
			}

			duke.IP = SIMULATOR_IP;
			return InsertDevice(duke);
		}
        	
		public bool Button(string ButtonName)
		{
			//This enumeration check will have to be removed later
			//we shouldn't be going it before every press
			if (duke.enumerated == 1)
			{
				duke.Button(ButtonName);
				return true;
			}
			else
			{
				Console.WriteLine("[PlugDuke]:Duke not enumerated");
				return false;
			}

			//This is where we verify that the button press was recieved
			/*
			if (VerifyButton(ButtonName)==false)
			{
				//check enumeration and try again if not enumerated
			}
			else
			{
				return true;
			}
			*/

		}

		public bool SetButtonState(int digital,
			short a,
			short b,
			short x,
			short y,
			short black,
			short white,
			short left_t,
			short right_t,
			short thumbLX,
			short thumbLY,
			short thumbRX,
			short thumbRY)
		{
			duke.SetButtonState(digital, a,b,x,y,black,white,left_t,right_t,thumbLX,thumbLY,thumbRX,thumbRY);
		
			//This is where we verify the button press took place
			//
			// return VerifyButtons(all buttons)
			return true;
		
		}

		public bool PressButtonFrom_XTC_Command(string command)
		{
			bool result = false;
			string s = command.ToUpper();
			switch (s)
			{
					// deliberate fallthrough here
				case "PRESS_A":
					result = Button("A");
					break;
				case "PRESS_START": 
					result = Button("START");
					break;
				case "PRESS_X": 
					result = Button("X");
					break;
				case "PRESS_Y": 
					result = Button("Y");
					break;
				case "PRESS_BLACK": 
					result = Button("BLACK");
					break;
				case "PRESS_WHITE":
					result = Button("WHITE");
					break;
				case "PRESS_LEFT_STICK":
					result = Button("LEFTTHUMB");
					break;
				case "PRESS_RIGHT_STICK":
					result = Button("RIGHTTHUMB");
					break;
				case "PRESS_RIGHT_TRIGGER":
					result = Button("RIGHTTRIGGER");
					break;
				case "PRESS_LEFT_TRIGGER":
					result = Button("LEFTTRIGGER");
					break;
				case "DPAD_UP":
					result = Button("DPADN");
					break;
				case "LEFT_STICK_UP":
					result = Button("UP");
					break;
				case "DPAD_NW":
					result = Button("DPADNW");
					break;
				case "DPAD_NE":
					result = Button("DPADNE");
					break;
				case "LEFT_STICK_NW":
					result = Button("A");
					break;
				case "LEFT_STICK_NE":
					result = Button("A");
					break;
				case "DPAD_DOWN":
					result = Button("DPADS");
					break;
				case "LEFT_STICK_DOWN":
					result = Button("DOWN");
					break;
				case "DPAD_SW":
					result = Button("DPADSW");
					break;
				case "DPAD_SE":
					result = Button("DPADSE");
					break;
				case "LEFT_STICK_SW":
					result = Button("A");
					break;
				case "LEFT_STICK_SE": 
					result = Button("A");
					break;
				case "LEFT_STICK_LEFT": 
					result = Button("LEFT");
					break;
				case "LEFT_STICK_RIGHT": 
					result = Button("RIGHT");
					break;
				case "DPAD_LEFT": 
					result = Button("DPADW");
					break;
				case "DPAD_RIGHT": 
					result = Button("DPADE");
					break;
				case "RIGHT_STICK_LEFT":
					result = Button("A");
					break;
				case "RIGHT_STICK_RIGHT": 
					result = Button("A");
					break;
				case "PRESS_B":
					result = Button("B");
					break;
				case "PRESS_BACK":
					result = Button("BACK");
					break;
				default:
					Console.WriteLine("Unknown PARAM command: {0}",s);
					result = false;
					break;
			}
			
			return result;
		}
		
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\Cortana\Engine.cs ===
using System;

namespace Cortana
{
	/// <summary>
	/// Summary description for Engine.
	/// </summary>
	public class CEngine
	{
		private bool		m_Initialized = false;
		private string		m_ModelFilename = "";
		private string		m_InitRunFilename = "";
		private string		m_DRIVER_TYPE = "";
		private string		m_SIMULATOR_IP = "";
		private string		m_SIMULATOR_PORT = "";
		private string		m_BUTTON_DOWN_DELAY = "";
		private string		m_BUTTON_UP_DELAY = "";
		private string		m_XDASH_TRANSITION_DELAY = "";
		private string		m_INIT_TEST_FILENAME = "";
		


		public string ModelFilename()
		{
			string s = m_ModelFilename;
			return s;	// return copy of private data
		}

		public string InitRunFilename()
		{
			string s = m_InitRunFilename;
			return s;	// return copy of private data
		}

		public string INIT_TEST_FILENAME()
		{
			string s = m_INIT_TEST_FILENAME;
			return s;	// return copy of private data
		}

		public string SIMULATOR_IP()
		{
			string s = m_SIMULATOR_IP;
			return s;	// return copy of private data
		}

		public ushort BUTTON_DOWN_DELAY()
		{
			string s = m_BUTTON_DOWN_DELAY;
			ushort u = UInt16.Parse(s);
			return u;	// return copy of private data
		}

		public ushort BUTTON_UP_DELAY()
		{
			string s = m_BUTTON_UP_DELAY;
			ushort u = UInt16.Parse(s);
			return u;	// return copy of private data
		}

		public int XDASH_TRANSITION_DELAY()
		{
			string s = m_XDASH_TRANSITION_DELAY;
			int i = Int32.Parse(s);
			return i;	// return copy of private data
		}

		public short SIMULATOR_PORT()
		{
			string s = m_SIMULATOR_PORT;
			short x = Int16.Parse(s);
			return x;	// return copy of private data
		}

		public void ShowUsage()
		{
			Console.WriteLine("Launches the XBOX UI Automation Framework.\n");
			Console.WriteLine("Cortana.exe	/M:modelname	/IR:initrunname\n");
			Console.WriteLine("/M	specifies the TMT model file to execute");
			Console.WriteLine("		/M:netconfig.xtc");
			Console.WriteLine("		/M:\"c:\\My Tests\\netconfig.xtc\"\n");
			Console.WriteLine("/IR	specifies the InitRun file used to preconfig the XTC run");
			Console.WriteLine("		/IR:InitRun.xml");
			Console.WriteLine("		/IR:\"c:\\My Tests\\InitRun.xml\"");
			Console.WriteLine();
		}

		public bool Init(string[] args)
		{
			// init's the engine
			// returns:
			//		false on failure to init
			//		true on success

			ClearVars();
			if (!ParseArgs(args))
				return false;
			if (!RequiredArgsProvided())
				return false;			

			m_Initialized = true;
			return true;
		}

		private void ClearVars()
		{
			m_Initialized = false;
			m_ModelFilename = "";
			m_InitRunFilename = "";
			m_DRIVER_TYPE = "";
			m_SIMULATOR_IP = "";
			m_SIMULATOR_PORT = "";
			m_BUTTON_DOWN_DELAY = "";
			m_BUTTON_UP_DELAY = "";
			m_XDASH_TRANSITION_DELAY = "";
			m_INIT_TEST_FILENAME = "";
		}

		private bool ParseArgs(string[] args)
		{
			string temp;

			foreach (string s in args)
			{
				temp = s.ToUpper();
				//Console.WriteLine("{0}",temp);
				if (temp.StartsWith("/M:"))
				{
					if ("" != m_ModelFilename)
					{
						return false; // switch already used
					}
					temp = temp.Substring(3);
					temp = temp.Trim();
					m_ModelFilename = temp;
				}
				else if (temp.StartsWith("/IR:"))
				{
					if ("" != m_InitRunFilename)
					{
						return false; // switch already used
					}
					temp = temp.Substring(4);
					temp = temp.Trim();
					m_InitRunFilename = temp;
				}
				else
				{
					return false;	//invalid arg found
				}

			}
			return true;
		}

		private bool RequiredArgsProvided()
		{
			if ("" != m_ModelFilename)
				return true;
			else
				return false; // requirements not met
		}


		public bool InitRun()
		{
			if (!m_Initialized)
			{
				Console.WriteLine("Engine::InitRun() - Engine Not Initialized!");
				return false;
			}
			CInitRun InitRun = new CInitRun();
			if (!InitRun.ProcessInitRunFile(this.InitRunFilename()))
			{
				return false;
			}

			m_INIT_TEST_FILENAME		= InitRun.INIT_TEST_FILENAME();
			m_DRIVER_TYPE				= InitRun.DRIVER_TYPE();
			m_SIMULATOR_IP				= InitRun.SIMULATOR_IP();
			m_SIMULATOR_PORT			= InitRun.SIMULATOR_PORT();
			m_BUTTON_DOWN_DELAY			= InitRun.BUTTON_DOWN_DELAY();
			m_BUTTON_UP_DELAY			= InitRun.BUTTON_UP_DELAY();
			m_XDASH_TRANSITION_DELAY	= InitRun.XDASH_TRANSITION_DELAY();


			return true;
		}
	}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\Cortana\Main.cs ===
using System;


namespace Cortana
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	/// 

	class CMain
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		/// 

		[STAThread]
		static void Main(string[] args)
		{
			CEngine		m_Engine	= new CEngine();
			ProcessXTC	m_XTC_Obj	= new ProcessXTC();
			Simulator	m_INPUT		= new Simulator();

			if (-1 == args.GetUpperBound(0))
			{
				// Console.WriteLine("UI not yet implemented.\nDefaulting to console mode.\n");
				m_Engine.ShowUsage();
				return;
			}
			else
			{
				if (!m_Engine.Init(args))
				{
					m_Engine.ShowUsage();
					return;
				}
				Console.WriteLine("Start Processing...");
				Console.WriteLine("Model File: {0}",m_Engine.ModelFilename());
				Console.WriteLine("InitRun File: {0}",m_Engine.InitRunFilename());
				if (!m_Engine.InitRun())
				{
					Console.WriteLine("InitRun failed!");
					return;
				}
				else
				{
					m_INPUT.SIMULATOR_IP				= m_Engine.SIMULATOR_IP(); 
					m_INPUT.DUKE_PORT					= m_Engine.SIMULATOR_PORT();
					m_INPUT.BUTTON_DOWN_DELAY			= m_Engine.BUTTON_DOWN_DELAY();
					m_INPUT.BUTTON_UP_DELAY			= m_Engine.BUTTON_UP_DELAY();
					m_INPUT.XDASH_TRANSITION_DELAY	= m_Engine.XDASH_TRANSITION_DELAY();
					
					if (!m_INPUT.PlugDuke())
					{
						return;
					}

					Console.WriteLine("InitRun succeeded.");
					
				}

				m_XTC_Obj.ProcessXTC_Main(ref m_Engine, ref m_INPUT);
				
				Console.WriteLine("Done.");
			}
			return;
		}
	}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\Cortana\verify.cs ===
using System;

namespace Cortana
{

	public class Verify
	{
		
		private State MyState = new State();

		extern public bool VerifyButton(string ButtonName);
		extern public bool VerifyScreen(string ScreenName);
		extern public bool VerifyFocus(string Focus);
		extern public bool VerifyHelpText(string HelpText);


	/*	{
			//This is where we check the debug spew for the last button
			return true;
		}*/
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\xbDebug\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( xbDebug )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( xbDebug ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\Cortana\state.cs ===
using System;



namespace Cortana
{

	public class State
	{		
		//PUBLIC METHODS
		public bool Connect(string xboxname)
		{
			debug.Connect(xboxname);
			// Check Connection
			return true;
		}

		public bool disconnect()
		{
			debug.Disconnect();	
			return true;
		}

		public bool Start()
		{
			debug.Start();	
			return true;
		}

		public bool Stop()
		{
			debug.Stop();
			return true;
		}

		public bool StartPolling()
		{
			return true;
		}
		
		public string GiveButtonPress()
		{
			return LAST_BUTTON;
		}

		public string GiveCurrentScreen()
		{
			return CURRENT_SCREEN;
		}	
	
		public string GiveCurrentFocus()
		{
			return CURRENT_FOCUS;
		}

		public string GiveHelpText()
		{
			return HELP_TEXT;
		}




		//PRIVATE PROPERTIES
		private XBDEBUGLib.NetDebug debug = new XBDEBUGLib.NetDebug();
		
		private string HELP_TEXT;
		private string CURRENT_SCREEN;
		private string CURRENT_FOCUS;
		private string LAST_BUTTON;

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\xbDebug\NetDebug.h ===
// NetDebug.h : Declaration of the CNetDebug

#ifndef __NETDEBUG_H_
#define __NETDEBUG_H_

#include "resource.h"       // main symbols


#include <windows.h>
#include <stdio.h>
#include <xboxdbg.h>




/////////////////////////////////////////////////////////////////////////////
// CNetDebug
class ATL_NO_VTABLE CNetDebug : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CNetDebug, &CLSID_NetDebug>,
	public IDispatchImpl<INetDebug, &IID_INetDebug, &LIBID_XBDEBUGLib>
{
public:
	CNetDebug()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_NETDEBUG)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNetDebug)
	COM_INTERFACE_ENTRY(INetDebug)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// INetDebug
public:
	STDMETHOD(ClearLines)();
	STDMETHOD(Disconnect)();
	STDMETHOD(get_ParseTag)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ParseTag)(/*[in]*/ BSTR newVal);
	STDMETHOD(GetAllLines)(/*[in]*/ BOOL clear, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(GetLine)(/*[in]*/ unsigned lineNum, /*[in]*/ short operation, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(Stop)();
	STDMETHOD(Start)();
	STDMETHOD(Connect)(/*[in]*/ BSTR xboxName);
};



#endif //__NETDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\Cortana\ReadXML.cs ===
using System;
using System.IO;
using System.Xml;

namespace Cortana
{
   public class ProcessXTC
   {
     
	   
	  public void ProcessXTC_Main(ref CEngine Engine, ref Simulator	INPUT)
      {

         XmlTextReader reader = null;
		 CInitTest m_InitTest = new CInitTest();

         reader = new XmlTextReader(Engine.ModelFilename());
		  try
		  {
			  reader.Read();
			  reader.Close();
			  reader = new XmlTextReader(Engine.ModelFilename());
		  }
		  catch
		  {
			  Console.WriteLine("Failure to read file: {0}",Engine.ModelFilename());
			  return;
		  }

		 Console.WriteLine("Processing of stream started...");
         Console.WriteLine();

		  int testcount = 0;
		  bool bTestInitialized = false;

		  if (null == reader)
		  {
			  Console.WriteLine("Unable to open file.");
		  }
		  else
		  {

			  while (reader.Read())
			  {
				  switch (reader.NodeType)
				  {
					  case XmlNodeType.ProcessingInstruction:
						  //OutputXML (reader, "ProcessingInstruction");
						  break;
					  case XmlNodeType.DocumentType:
						  //OutputXML (reader, "DocumentType");
						  break;
					  case XmlNodeType.Comment:
						  //OutputXML (reader, "Comment");
						  break;
					  case XmlNodeType.Element:
						  if ("TEST" == reader.Name)
						  {
							  testcount++;
							  if (testcount > 1)
								  Console.WriteLine();
							  bTestInitialized = false; // this gets set on first TRANSITION
							  Console.Write("Test {0}: ",testcount);						
							  reader.MoveToAttribute("Title");
							  Console.WriteLine(reader.Value);
						  }
				  
						  if ("TRANSITION" == reader.Name)
						  {
							  if (! bTestInitialized)
							  {
								  reader.MoveToAttribute("ModelName");
								  Console.WriteLine("Call InitTest(\"{0}\")",reader.Value);
								  if (!m_InitTest.ProcessInitTestCommands(ref Engine, ref INPUT,reader.Value))
								  {
								  	  Console.WriteLine("InitTest failed! Aborting Test");
								  	  return;
								  }
								  bTestInitialized = true;
							  }
						  }

						  if ("ACTION" == reader.Name)
						  {
							  if (0 == reader.AttributeCount)
							  {
								  Console.WriteLine("Empty ACTION detected. No action taken.");
							  }
							  else
							  {
								  reader.MoveToAttribute("Name");
								  Console.WriteLine("Performing ACTION: {0}",reader.Value);
								  // note - do no work here! the PARAM element is what we need to parse!
							  }
						  }

						  if ("PARAM" == reader.Name)
						  {
                              reader.MoveToAttribute("Value");
							  Console.WriteLine("Interpretting PARAM: {0}",reader.Value);
							  string s = reader.Value.ToUpper();
							  Console.WriteLine("Calling {0}",s);
							  
							  bool result = false;
							  switch (s)
							  {
								// deliberate fallthrough here
								  case "PRESS_A":
								  case "PRESS_START": 
								  case "PRESS_X": 
								  case "PRESS_Y": 
								  case "PRESS_BLACK": 
								  case "PRESS_WHITE":
								  case "PRESS_LEFT_STICK":
								  case "PRESS_RIGHT_STICK":
								  case "PRESS_RIGHT_TRIGGER":
								  case "PRESS_LEFT_TRIGGER":
								  case "DPAD_UP":
								  case "LEFT_STICK_UP":
								  case "DPAD_NW":
								  case "DPAD_NE":
								  case "LEFT_STICK_NW":
								  case "LEFT_STICK_NE":
								  case "DPAD_DOWN":
								  case "LEFT_STICK_DOWN":
								  case "DPAD_SW":
								  case "DPAD_SE":
								  case "LEFT_STICK_SW":
								  case "LEFT_STICK_SE": 
								  case "LEFT_STICK_LEFT": 
								  case "LEFT_STICK_RIGHT": 
								  case "DPAD_LEFT": 
								  case "DPAD_RIGHT": 
								  case "RIGHT_STICK_LEFT":
								  case "RIGHT_STICK_RIGHT": 
								  case "PRESS_B":
								  case "PRESS_BACK":
									  result = INPUT.PressButtonFrom_XTC_Command(s);
									  break;
								  default:
									  Console.WriteLine("Unknown PARAM command: {0}",s);
									  result = false;
									  break;
							  }
							  if (!result)
							  {
								  Console.WriteLine("Failed to press the button. Quitting.");
								  return;
							  }
						  }

						  if ("STATEVAR" == reader.Name)
						  {
							  reader.MoveToAttribute("Name");
							  string s = reader.Value.ToUpper();
							  switch (s)
							  {
									  // deliberate fallthrough here
								  case "SCREENNAME":
								  case "BUTTONFOCUS": 
									  Console.Write("Verifying STATEVAR [{0}] == ",s);
									  reader.MoveToAttribute("Value");
									  Console.WriteLine("\"{0}\"",reader.Value.ToUpper());
									  //check it
									  break;
								  default:
									  Console.WriteLine("Unknown STATEVAR: {0}",s);
									  break;
							  }
							  
						  }

						  break;
					  case XmlNodeType.Text:
						  //OutputXML (reader, "Text");
						  break;
					  case XmlNodeType.Whitespace:
						  break;
				  }
			  }
		  }

			  Console.WriteLine();
			  Console.WriteLine("Processing of stream complete.");
			  Console.WriteLine("Total Tests: {0}",testcount);

			  if (reader != null){reader.Close();}
		  }

   }

   public class CInitRun
	{
	   private bool		m_bInitialized = false;
	   private string	m_DRIVER_TYPE = "";
	   private string	m_SIMULATOR_IP = "";
	   private string	m_SIMULATOR_PORT = "";
	   private string	m_BUTTON_DOWN_DELAY = "";
	   private string	m_BUTTON_UP_DELAY = "";
	   private string	m_XDASH_TRANSITION_DELAY = "";
	   private string	m_INIT_TEST_FILENAME = "";
	   



		public bool ProcessInitRunFile(string initrunfilename)
		{

			XmlTextReader reader = null;

			reader = new XmlTextReader (initrunfilename);
			try
			{
				reader.Read();
				reader.Close();
				reader = new XmlTextReader (initrunfilename);
			}
			catch
			{
				Console.WriteLine("Failure to read file: {0}",initrunfilename);
				return false;
			}

			Console.WriteLine("Processing InitRun file...");
			Console.WriteLine();

			if (null == reader)
			{
				Console.WriteLine("Unable to open file.");
				return false;
			}
			else
			{

				while (reader.Read())
				{
					switch (reader.NodeType)
					{
						case XmlNodeType.ProcessingInstruction:
							//OutputXML (reader, "ProcessingInstruction");
							break;
						case XmlNodeType.DocumentType:
							//OutputXML (reader, "DocumentType");
							break;
						case XmlNodeType.Comment:
							//OutputXML (reader, "Comment");
							break;
						case XmlNodeType.Element:
							
							if ("DRIVER_TYPE" == reader.Name)
							{
								Console.Write("DRIVER_TYPE: ");						
								reader.MoveToAttribute("Value");
								Console.WriteLine(reader.Value);
								m_DRIVER_TYPE = reader.Value;
							}

							if ("SIMULATOR_IP" == reader.Name)
							{
								Console.Write("SIMULATOR_IP: ");						
								reader.MoveToAttribute("Value");
								Console.WriteLine(reader.Value);
								m_SIMULATOR_IP = reader.Value;
							}

							if ("BUTTON_DOWN_DELAY" == reader.Name)
							{
								Console.Write("BUTTON_DOWN_DELAY: ");						
								reader.MoveToAttribute("Value");
								Console.WriteLine(reader.Value);
								m_BUTTON_DOWN_DELAY = reader.Value;
							}

							if ("BUTTON_UP_DELAY" == reader.Name)
							{
								Console.Write("BUTTON_UP_DELAY: ");						
								reader.MoveToAttribute("Value");
								Console.WriteLine(reader.Value);
								m_BUTTON_UP_DELAY = reader.Value;
							}

							if ("XDASH_TRANSITION_DELAY" == reader.Name)
							{
								Console.Write("XDASH_TRANSITION_DELAY");						
								reader.MoveToAttribute("Value");
								Console.WriteLine(reader.Value);
								m_XDASH_TRANSITION_DELAY = reader.Value;
							}

							if ("SIMULATOR_PORT" == reader.Name)
							{
								Console.Write("SIMULATOR_PORT");						
								reader.MoveToAttribute("Value");
								Console.WriteLine(reader.Value);
								m_SIMULATOR_PORT = reader.Value;
							}

							if ("INIT_TEST_FILENAME" == reader.Name)
							{
								Console.Write("INIT_TEST_FILENAME");						
								reader.MoveToAttribute("Value");
								Console.WriteLine(reader.Value);
								m_INIT_TEST_FILENAME = reader.Value;
							}

							break;
						case XmlNodeType.Text:
							//OutputXML (reader, "Text");
							break;
						case XmlNodeType.Whitespace:
							break;
					}
				}
			}

			Console.WriteLine();
			Console.WriteLine("Processing InitRun file complete.");
			m_bInitialized = true;
			if (reader != null){reader.Close();}
			return true;
		}

	   public bool Initialized()
	   {
		   bool retval = m_bInitialized;
		   return retval;
	   }

	   public string INIT_TEST_FILENAME()
	   {
		   string retval = "uninitialized";
		   if (m_bInitialized)
			   retval = m_INIT_TEST_FILENAME;
		   return retval;
	   }

	   public string DRIVER_TYPE()
	   {
		   string retval = "uninitialized";
		   if (m_bInitialized)
			   retval = m_DRIVER_TYPE;
		   return retval;
	   }

	   public string SIMULATOR_IP()
	   {
		   string retval = "uninitialized";
		   if (m_bInitialized)
			   retval = m_SIMULATOR_IP;
		   return retval;
	   }

	   public string BUTTON_DOWN_DELAY()
	   {
		   string retval = "uninitialized";
		   if (m_bInitialized)
			   retval = m_BUTTON_DOWN_DELAY;
		   return retval;
	   }

	   public string BUTTON_UP_DELAY()
	   {
		   string retval = "uninitialized";
		   if (m_bInitialized)
			   retval = m_BUTTON_UP_DELAY;
		   return retval;
	   }

	   public string XDASH_TRANSITION_DELAY()
	   {
		   string retval = "uninitialized";
		   if (m_bInitialized)
			   retval = m_XDASH_TRANSITION_DELAY;
		   return retval;
	   }

	   public string SIMULATOR_PORT()
	   {
		   string retval = "uninitialized";
		   if (m_bInitialized)
			   retval = m_SIMULATOR_PORT;
		   return retval;
	   }

	}
   public class CInitTest
	{
	   
		public bool ProcessInitTestCommands(ref CEngine Engine, ref Simulator INPUT, string MODELNAME)
		{

			XmlTextReader reader = null;

			reader = new XmlTextReader(Engine.INIT_TEST_FILENAME());

			try
			{
				reader.Read();
				reader.Close();
				reader = new XmlTextReader(Engine.INIT_TEST_FILENAME());
			}
			catch
			{
				Console.WriteLine("Failure to read file: {0}",Engine.INIT_TEST_FILENAME());
				return false;
			}

			Console.WriteLine("Processing InitTest stream started...");
			Console.WriteLine();

			bool bModelNamefound = false;

			if (null == reader)
			{
				Console.WriteLine("Unable to open file.");
				return false;
			}
			else
			{
				
				while (reader.Read())
				{
					switch (reader.NodeType)
					{
						case XmlNodeType.ProcessingInstruction:
							//OutputXML (reader, "ProcessingInstruction");
							break;
						case XmlNodeType.DocumentType:
							//OutputXML (reader, "DocumentType");
							break;
						case XmlNodeType.Comment:
							//OutputXML (reader, "Comment");
							break;
						case XmlNodeType.Element:
							if ("ModelName" == reader.Name)
							{
								Console.Write("Found InitTest ModelName: ");
								reader.MoveToAttribute("Value");
								Console.WriteLine(reader.Value);
								if (reader.Value == MODELNAME)
								{
									bModelNamefound = true;
									Console.WriteLine("Executing: {0}",MODELNAME);
									while (reader.Read())
									{
										if (reader.NodeType == XmlNodeType.Element)
										{
											if ("Command" != reader.Name)
											{
												Console.WriteLine("End of Commands for {0}",MODELNAME);
												return true;
											}
											else
											{
												reader.MoveToAttribute("Value");
												Console.WriteLine("Executing Command: {0}",reader.Value);
												if (reader.Value == "INITTEST")
												{	// read ModelName attribute, then execute as a new InitTest
													reader.MoveToAttribute("ModelName");
													if (!ProcessInitTestCommands(ref Engine,ref INPUT,reader.Value))
													{
														return false;
													}
													else
													{
														// successful interpret, keep going...
														// do nothing in this else
													}
												}
												else
												{	// just execute it
													if (!INPUT.PressButtonFrom_XTC_Command(reader.Value))
													{
														Console.WriteLine("Failed InitTest command aborting.");
														return false;
													}
													else
													{
														// success on the command, keep processing
														// and do nothing in this else
														Console.WriteLine("InitTest command succeeded.");
													}
												}
											}
										}
										else
										{
											//Console.WriteLine(".");
										}

									}
								}
							}

							break;
						case XmlNodeType.Text:
							//OutputXML (reader, "Text");
							break;
						case XmlNodeType.Whitespace:
							break;
					}
				}
			}

			Console.WriteLine();
			Console.WriteLine("Processing of InitTest stream complete.");

			if (reader != null){reader.Close();}
			if (!bModelNamefound)
			{
				Console.WriteLine("InitTest for {0} not found!",MODELNAME);
				return false;
			}
			else
			{
				return true; // ModelName was processed
			}
		}

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\xbDebug\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xbDebug.rc
//
#define IDS_PROJNAME                    100
#define IDR_NETDEBUG                    101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\xbDebug\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\xbDebug\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__83736F15_2667_435D_B691_5C671E7D0BF7__INCLUDED_)
#define AFX_STDAFX_H__83736F15_2667_435D_B691_5C671E7D0BF7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__83736F15_2667_435D_B691_5C671E7D0BF7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\xbDebug\xbDebug.cpp ===
// xbDebug.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f xbDebugps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "xbDebug.h"

#include "xbDebug_i.c"
#include "NetDebug.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_NetDebug, CNetDebug)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_XBDEBUGLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\Models\StartMenuLoader.cs ===
using System;

using Modeling;
using Modeling.Events;
using Modeling.TMT;

//TODO: Change the using statment below to reflect the actual namespace of your models
using CustomModels;

namespace Loaders{

	/***************  StartMenu Loader ****************
	 *	Description: Custom exe loader for StartMenu TMT project
	 *	Area: 
	 *	Author: 
	 *	Dependencies: Modeling.dll, Modeling.TMT.dll
	 *	Revision History:
	 **********************************************************/

	class StartMenuLoader{

		static void Main(string[] args){
		
			//Show Usage information
			if (args.Length == 0 || GetArgument("?", args) != null)
			{
				ShowUsage();
				return;
			}

			//Get the Command line arguments
			string XTCPath = GetArgument(null, args);
			if (XTCPath == null){
				string exeName = System.IO.Path.GetFileName(System.Reflection.Assembly.GetExecutingAssembly().Location);
				Console.WriteLine("You must specify a XTC file to load at command line.\n Type " + exeName + " /? for syntax information.");
				return;
			}
			int StartCase = -1;
			int EndCase = -1;
			if (GetArgument("StartCase", args) != null)
				StartCase = int.Parse(GetArgument("StartCase", args));
			if (GetArgument("EndCase", args) != null)
				EndCase = int.Parse(GetArgument("EndCase", args));

			//Specifies whether to throw an Exception when an object RaiseError()
			Automation.BreakOnError = false;
			//Specifies whether to allow Exceptions to be thrown
			Automation.Debug = (GetArgument("Debug", args) != null);
			
			//Create and open the TextLog object
			TextLog myLog = new TextLog("StartMenu.log", true);
			if (!myLog.Open())
			{
				Console.WriteLine("Errors occured while opening the Log file StartMenu.log.\n" + myLog.Errors);
				return;
			}

			//Create the Automation Object
			Automation myAutomation = new Automation();
			myAutomation.Logger = myLog;
			
			//Create the XTCTraversal and add it to the Automation object
			XTCTraversal myTraversal = new XTCTraversal(XTCPath, StartCase, EndCase);
			myAutomation.AddTraversal(myTraversal);
			if (myTraversal.Errors.Count > 0)
			{
				Console.WriteLine("Errors occured while loading the XTC file.\n" + myTraversal.Errors);
				myLog.Close();
				return;
			}
			
			bool testResult = false;
			
			//Initialize the Automation Object
			bool initResult = myAutomation.Initialize();
			if (initResult)
			{
				//Create the Models
				myTraversal.AddModel( new StartMenu() );
				if (myTraversal.Models[myTraversal.Models.Length-1].Errors.Count > 0)
				{
					Console.WriteLine("Errors occured during StartMenu Initialize.");
					Console.WriteLine(myTraversal.Models[myTraversal.Models.Length-1].Errors);
					goto CleanUp;
				}
				//Perform Automation Test
				testResult = myAutomation.Run();
			}

			CleanUp:
			//Clean Up the Automation
			myAutomation.CleanUp();
			
			//Close the TextLog
			myLog.Close();
			
			if (initResult && testResult)
				Console.WriteLine("\n**** PASS ****\n\n Automation results were successful.");
			else
				Console.WriteLine("\n**** FAIL ****\n\n" + myAutomation.Errors.ToString());
		}


		/// <summary>
		/// Shows command line syntax for this loader
		/// </summary>
		private static void ShowUsage(){
			string exeName = System.IO.Path.GetFileName(System.Reflection.Assembly.GetExecutingAssembly().Location);
			Console.WriteLine("Custom exe loader for StartMenu TMT project");
			Console.WriteLine("");
			Console.WriteLine("Usage:");
			Console.WriteLine("    " + exeName + " XTC_Filename [/StartCase:value] [/EndCase:value] [/Debug]");
			Console.WriteLine("");
			Console.WriteLine("XTC_Filename : Path to the TMT .xtc file.");
			Console.WriteLine("StartCase    : Test Case to start Traversing.");
			Console.WriteLine("EndCase      : Test Case to end Traversing.");
			Console.WriteLine("Debug        : Allow exceptions to be thrown and caught by a debugger.");
			Console.WriteLine("");
			Console.WriteLine("Example: " + exeName + " \"RandomQuery.xtc\" /StartCase:10 /EndCase:12");
		}

		/// <summary>
		/// Retrieves the value of a command line argument
		/// </summary>
		/// <param name="name">The name of the argument to retrieve</param>
		/// <param name="args">The arguments to retrieve from</param>
		/// <returns>The value of the specified argument (as a string), null if not found</returns>
		private static string GetArgument(string name, string[] args){
			foreach (string arg in args){
				if (arg.StartsWith("/")){
					int pos = arg.IndexOf(":");
					if (pos > 0){
						string argName = arg.Substring(1, pos-1);
						if (argName.ToLower() == name.ToLower())
							return arg.Substring(pos+1).Trim();
					}
					else if ("/" + name == arg)
						return "true";
				}
				else if (name == null)
					return arg;
			}
			return null;
		}

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\xbDebug\xbDebug_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Feb 11 15:00:43 2002
 */
/* Compiler settings for C:\xbox\private\test\ui\automation\xbDebug\xbDebug.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_INetDebug = {0xB6BD872B,0xD6C7,0x4ACD,{0x97,0x04,0x81,0xF4,0xDC,0xE6,0x5C,0xA4}};


const IID LIBID_XBDEBUGLib = {0x2EF1DC7D,0xB7B4,0x4B86,{0x92,0xBE,0x93,0x57,0x20,0xE3,0x25,0xBB}};


const CLSID CLSID_NetDebug = {0xB11C43CA,0x5735,0x43FD,{0x98,0xAF,0x52,0x87,0x5C,0xC5,0x6E,0xA7}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\xbnetdbg\xbnetdbg.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xbnetdbg.cpp

Abstract:

    This module implements routines which monitor debug message from Xbox.
    The debug messages are captured using XboxDbg notification mechanism.

--*/

#include "xbnetdbg.h"

PDMN_SESSION DmSession = NULL;
BOOL fNotificationOpened = FALSE;
BOOL fConnectionOpened = FALSE;


VOID
TranslateError(
    HRESULT hr
    )

/*
Routine Description:

    This routine translates HRESULT returned from XboxDbg APIs into string and
    output to standard error

Auguments:

    hr - HRESULT returned from various XboxDbg APIs

Return Value:

    None
*/

{
    CHAR Buffer[512];

    DmTranslateErrorA( hr, Buffer, sizeof(Buffer) );
    fprintf( stderr, Buffer );
}



DWORD
WINAPI
NotificationProc(
    ULONG Notification,
    DWORD Parameter
    )
/*++

Routine Description:

    This is a callback routine registered by DmNotify.  It is called by XboxDbg
    for various types of notification event.

Arguments:

    Notification - Type of notification, DM_DEBUGSTR for example

    Parameter - Optional parameter based on notification type

Return Value:

    Always zero

--*/
{
    PDMN_DEBUGSTR p = (PDMN_DEBUGSTR)Parameter;

    //
    // Process only if notification type is DM_DEBUGSTR and there is
    // a valid string length
    //

    if ( Notification == DM_DEBUGSTR && p->Length ) {
        fprintf( stdout, "%.*s", p->Length, p->String );
    }

    return 0;
}

BOOL
WINAPI
ConsoleCtrlHandler(
    DWORD CtrlType
    )
/*++

Routine Description:

    A HandlerRoutine function is an application-defined function used with
    the SetConsoleCtrlHandler function.  A console process uses this function
    to handle control signals received by the process

Arguments:

    CtrlType - Indicates the type of control signal received by the handler.

Return Value:

    Return FALSE to terminate the process

--*/
{
    switch ( CtrlType ) {
    case CTRL_C_EVENT:
    case CTRL_BREAK_EVENT:
    case CTRL_CLOSE_EVENT:

        fprintf( stdout, "Terminating...\n" );

        //
        // Close notification and connection if needed
        //

        if ( fNotificationOpened ) {
            DmCloseNotificationSession( DmSession );
        }

        if ( fConnectionOpened ) {
            DmUseSharedConnection( FALSE );
        }

        return FALSE;
    }

    return TRUE;
}

int __cdecl main( int cArg, char **rgszArg )
{
    char *szExe = *rgszArg;
    HRESULT hr;

    //
    // Hook Ctrl+C handle so that we can do a cleanup work
    //

    SetConsoleCtrlHandler( ConsoleCtrlHandler, TRUE );

    //
    // Open a shared debug connection with xbdm
    //

    hr = DmUseSharedConnection( TRUE );

    if ( FAILED(hr) ) {
        TranslateError( hr );
        return 1;
    } else {
        fConnectionOpened = TRUE;
    }

    //
    // Process command line arguments if any
    //

    ++rgszArg;

    while ( --cArg ) {

        if ( **rgszArg != '-' && **rgszArg != '/' ) {
usage:
            fprintf( stderr, "usage: %s [-x xboxname]\n", szExe );
            DmUseSharedConnection( FALSE );
            return 1;
        }

        char *szArg = *rgszArg++;

        while( *++szArg ) {

            switch( *szArg ) {
            case 'x':
            case 'X':
                if (!--cArg) {
                    goto usage;
                }

                hr = DmSetXboxName( *rgszArg++ );

                if( FAILED(hr) ) {
                    TranslateError( hr );
                    DmUseSharedConnection( FALSE );
                    return 1;
                }
                break;

            default:
                goto usage;
            }
        }
    }

    fprintf( stdout, "Initializing...\n" );
    hr = DmOpenNotificationSession( DM_PERSISTENT, &DmSession );

    if ( SUCCEEDED(hr) ) {

        fNotificationOpened = TRUE;

        hr = DmNotify( DmSession, DM_DEBUGSTR, NotificationProc );

        if ( SUCCEEDED(hr) ) {
            fprintf( stdout, "Start listening (Ctrl+C to exit)...\n" );
            Sleep( INFINITE );
        } else {
            TranslateError( hr );
        }

        DmCloseNotificationSession( DmSession );

    } else {
        TranslateError( hr );
    }

    DmUseSharedConnection( FALSE );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\xbnetdbg\xbnetdbg.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xbnetdbg.h

Abstract:

    This is a pre-compiled header file for Xbox debug message monitor

--*/

#include <windows.h>
#include <stdio.h>
#include <xboxdbg.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\TCPDuke\Msg.h ===
//-------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
// Author: Natalyp
//-------------------------------------------------------------
#pragma once
// those data structures are defined in Xbox.h, 
// cannot include the XBox.h due to various data types conflicts
/////////////////// XBOX definitions 
typedef struct _XINPUT_GAMEPAD
{
    WORD    wButtons;
    BYTE    bAnalogButtons[8];
    SHORT   sThumbLX;
    SHORT   sThumbLY;
    SHORT   sThumbRX;
    SHORT   sThumbRY;
} XINPUT_GAMEPAD, *PXINPUT_GAMEPAD;

#define XINPUT_GAMEPAD_DPAD_UP          0x00000001
#define XINPUT_GAMEPAD_DPAD_DOWN        0x00000002
#define XINPUT_GAMEPAD_DPAD_LEFT        0x00000004
#define XINPUT_GAMEPAD_DPAD_RIGHT       0x00000008
#define XINPUT_GAMEPAD_START            0x00000010
#define XINPUT_GAMEPAD_BACK             0x00000020
#define XINPUT_GAMEPAD_LEFT_THUMB       0x00000040
#define XINPUT_GAMEPAD_RIGHT_THUMB      0x00000080

#define XINPUT_GAMEPAD_A                0
#define XINPUT_GAMEPAD_B                1
#define XINPUT_GAMEPAD_X                2
#define XINPUT_GAMEPAD_Y                3
#define XINPUT_GAMEPAD_BLACK            4
#define XINPUT_GAMEPAD_WHITE            5
#define XINPUT_GAMEPAD_LEFT_TRIGGER     6
#define XINPUT_GAMEPAD_RIGHT_TRIGGER    7

#define XINPUT_GAMEPAD_MAX_CROSSTALK	30

typedef struct _XINPUT_RUMBLE
{
   WORD   wLeftMotorSpeed;
   WORD   wRightMotorSpeed;
} XINPUT_RUMBLE, *PXINPUT_RUMBLE;

typedef struct _XINPUT_STATE
{
    DWORD dwPacketNumber;
    union
    {
        XINPUT_GAMEPAD Gamepad;
    };
} XINPUT_STATE, *PXINPUT_STATE;

// HACK, HACK, HACK!! - complete wierdness - when XINPUT_FEEDBACK_HEADER_INTERNAL_SIZE = 58 
// as in the Xbox.h, the buffer is padded to 60, changed to be 56+2 is the expected size
#define XINPUT_FEEDBACK_HEADER_INTERNAL_SIZE 56
typedef struct _XINPUT_FEEDBACK_HEADER
{
    DWORD           dwStatus;
    HANDLE  hEvent;
    BYTE            Reserved[XINPUT_FEEDBACK_HEADER_INTERNAL_SIZE];
} XINPUT_FEEDBACK_HEADER, *PXINPUT_FEEDBACK_HEADER;

typedef struct _XINPUT_FEEDBACK
{
    XINPUT_FEEDBACK_HEADER Header;
    union
    {
      XINPUT_RUMBLE Rumble;
    };
} XINPUT_FEEDBACK, *PXINPUT_FEEDBACK;

typedef struct _XINPUT_CAPABILITIES
{
    BYTE    SubType;
    WORD    Reserved;
    union
    {
      XINPUT_GAMEPAD Gamepad;
    } In;
    union
    {
      XINPUT_RUMBLE Rumble;
    } Out;
} XINPUT_CAPABILITIES, *PXINPUT_CAPABILITIES;

////////////////////// End of XBox.h include

// here is XBGAMEPAD structure from XBINput.h
struct XBGAMEPAD : public XINPUT_GAMEPAD
{
    // The following members are inherited from XINPUT_GAMEPAD:
    //    WORD    wButtons;
    //    BYTE    bAnalogButtons[8];
    //    SHORT   sThumbLX;
    //    SHORT   sThumbLY;
    //    SHORT   sThumbRX;
    //    SHORT   sThumbRY;

    // Thumb stick values converted to range [-1,+1]
    FLOAT      fX1;
    FLOAT      fY1;
    FLOAT      fX2;
    FLOAT      fY2;
    
    // State of buttons tracked since last poll
    WORD       wLastButtons;
    BOOL       bLastAnalogButtons[8];
    WORD       wPressedButtons;
    BOOL       bPressedAnalogButtons[8];

    // Rumble properties
    XINPUT_RUMBLE   Rumble;
    XINPUT_FEEDBACK Feedback;

    // Device properties
    XINPUT_CAPABILITIES caps;
    HANDLE     hDevice;

    // Flags for whether gamepad was just inserted or removed
    BOOL       bInserted;
    BOOL       bRemoved;
};

// This the AUTOMATION message definition
// Currently two messages are expected
// m_byMessageId = 1 - Gamepad to simulate user input
// m_byMessageId = 2 - Heartbit message , if no traffic inspected by the server during 1 minute, 
// the connection will be terminated by the server. 
// Client should send one of those two message at least once in a minute
struct AutoMessage
{
	char m_byMessageId;
	union Data
	{
		XBGAMEPAD xbGamepad;
	} m_Data;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\xbDebug\NetDebug.cpp ===
// NetDebug.cpp : Implementation of CNetDebug
#include "stdafx.h"
#include "XbDebug.h"
#include "NetDebug.h"
#include <comdef.h>
#include <iostream.h>



PDMN_SESSION DmSession = NULL;
BOOL fNotificationOpened = FALSE;
BOOL fConnectionOpened = FALSE;
INT EVENT_MESSAGE = 9999;

///////////////////////
// put linked list declaration here


/*
 * AnsiToUnicode converts the ANSI string pszA to a Unicode string
 * and returns the Unicode string through ppszW. Space for the
 * the converted string is allocated by AnsiToUnicode.
 */ 

HRESULT __fastcall AnsiToUnicode(LPCSTR pszA, LPOLESTR* ppszW)
{

    ULONG cCharacters;
    DWORD dwError;

    // If input is null then just return the same.
    if (NULL == pszA)
    {
        *ppszW = NULL;
        return NOERROR;
    }

    // Determine number of wide characters to be allocated for the
    // Unicode string.
    cCharacters =  strlen(pszA)+1;

    // Use of the OLE allocator is required if the resultant Unicode
    // string will be passed to another COM component and if that
    // component will free it. Otherwise you can use your own allocator.
    *ppszW = (LPOLESTR) CoTaskMemAlloc(cCharacters*2);
    if (NULL == *ppszW)
        return E_OUTOFMEMORY;

    // Covert to Unicode.
    if (0 == MultiByteToWideChar(CP_ACP, 0, pszA, cCharacters,
                  *ppszW, cCharacters))
    {
        dwError = GetLastError();
        CoTaskMemFree(*ppszW);
        *ppszW = NULL;
        return HRESULT_FROM_WIN32(dwError);
    }

    return NOERROR;
}




/*
 * UnicodeToAnsi converts the Unicode string pszW to an ANSI string
 * and returns the ANSI string through ppszA. Space for the
 * the converted string is allocated by UnicodeToAnsi.
 */ 

HRESULT __fastcall UnicodeToAnsi(LPCOLESTR pszW, LPSTR* ppszA)
{

    ULONG cbAnsi, cCharacters;
    DWORD dwError;

    // If input is null then just return the same.
    if (pszW == NULL)
    {
        *ppszA = NULL;
        return NOERROR;
    }

    cCharacters = wcslen(pszW)+1;
    // Determine number of bytes to be allocated for ANSI string. An
    // ANSI string can have at most 2 bytes per character (for Double
    // Byte Character Strings.)
    cbAnsi = cCharacters*2;

    // Use of the OLE allocator is not required because the resultant
    // ANSI  string will never be passed to another COM component. You
    // can use your own allocator.
    *ppszA = (LPSTR) CoTaskMemAlloc(cbAnsi);
    if (NULL == *ppszA)
        return E_OUTOFMEMORY;

    // Convert to ANSI.
    if (0 == WideCharToMultiByte(CP_ACP, 0, pszW, cCharacters, *ppszA,
                  cbAnsi, NULL, NULL))
    {
        dwError = GetLastError();
        CoTaskMemFree(*ppszA);
        *ppszA = NULL;
        return HRESULT_FROM_WIN32(dwError);
    }
    return NOERROR;

} 





struct debugline
{
	BSTR data;
	debugline *next;

};




typedef debugline* debuglinePtr;

//declare the head of the list as global
debuglinePtr LIST_HEAD;





void tail_insert(debuglinePtr& head, BSTR the_data)
{
	//This function will add a debug line to the head of the linked list
	debuglinePtr temp_ptr;
	temp_ptr = head;
	
	while (temp_ptr->next != NULL)
	{
		temp_ptr=temp_ptr->next;
	}

	debuglinePtr newline;
	newline = new debugline;

	newline->data = the_data;
	newline->next = NULL;

	temp_ptr->next = newline;
	
}




void head_insert(debuglinePtr& head, BSTR the_data)
{
	//This function will add a debug line to the head of the linked list
	
	debuglinePtr temp_ptr;
	temp_ptr = new debugline;
	if (NULL == temp_ptr)
	{
		//couldn't create the new debugline struct
		exit(1);
	}

	temp_ptr->data = the_data;

	temp_ptr->next= head;
	head = temp_ptr;
}




BSTR output_lines(debuglinePtr& head)
{
	// this function get all the data in the linked list and output it as one BSTR
	_bstr_t Full_String = head->data;
	debuglinePtr temp_ptr;
	temp_ptr = head;
	while (head->next != NULL)
	{
		_bstr_t tmpbstr( temp_ptr->data, false );
		Full_String += tmpbstr;
		temp_ptr = temp_ptr->next;	
	}
	

	return Full_String;
}




BSTR output_lines(debuglinePtr& head, int begin, int end)
{
	// this function will erase all the data in the linked list and reset the head
	_bstr_t Full_String;
	if (begin <= end)
	{
		debuglinePtr temp_ptr = head;
		// Traversing the list
		for (int i = 1; (begin > i) && (temp_ptr != NULL); i++)
		{
			temp_ptr = temp_ptr->next;
		}
		
		// Start deleting
		while (i <= end && temp_ptr != NULL)
		{
			_bstr_t tmpbstr( temp_ptr->data, false );
			Full_String += tmpbstr;
			temp_ptr = temp_ptr->next;
			i++;
		}
	}
	else
	{
		// you can put error msg here if you wish.
	}
	return (LPWSTR)Full_String;
}




void clear(debuglinePtr& head)
{
	// this function will erase all the data in the linked list and reset the head
	debuglinePtr temp_ptr;
	while (head->next != NULL)
	{
		temp_ptr = head;
		head = head->next;
		delete temp_ptr;
	}
}





void clear(debuglinePtr& head, int begin, int end)
{
	// this function will erase all the data in the linked list and reset the head
	if (begin <= end)
	{
		debuglinePtr temp_ptr = head;
		debuglinePtr temp_end = NULL;
		// Traversing the list
		for (int i = 1; (begin > i) && (temp_ptr != NULL); i++)
		{
			temp_end = temp_ptr;
			temp_ptr = temp_ptr->next;
		}
		
		// Start deleting
		while (i <= end && temp_ptr != NULL)
		{
			temp_end->next = temp_ptr->next;
			delete temp_ptr;
			temp_ptr = temp_end->next;
			i++;
		}
	}
	else
	{
		// you can put error msg here if you wish.
	}

}




///////////////////////////////////////////////////////////////////////////////
///  Sak's code

DWORD WINAPI NotificationProc( ULONG Notification, DWORD Parameter )
/*++

Routine Description:

    This is a callback routine registered by DmNotify.  It is called by XboxDbg
    for various types of notification event.

Arguments:

    Notification - Type of notification, DM_DEBUGSTR for example

    Parameter - Optional parameter based on notification type

Return Value:

    Always zero

--*/
{
	PDMN_DEBUGSTR p = NULL;
	p = (PDMN_DEBUGSTR)Parameter;

    //
    // Process only if notification type is DM_DEBUGSTR and there is
    // a valid string length
    //

    if ( Notification == DM_DEBUGSTR && p->Length ) {
        //Put into linked list here
		/*
		WCHAR* psz = new WCHAR[p->Length + 1];
		psz[p->Length] = 0;
		MultiByteToWideChar(CP_ACP, 0, p->String, p->Length, psz, p->Length);
		BSTR bstrMsg = SysAllocString(psz);
		cout<<*psz<<endl;
		delete[] psz;
		tail_insert(LIST_HEAD,bstrMsg);
		*/

		//Send Event Here
		SendMessage(HWND_BROADCAST,EVENT_MESSAGE,(LPARAM)"AUTO",(LPARAM)p->String);



    }

	
    return 0;
}






VOID TranslateError( HRESULT hr )

/*
Routine Description:

    This routine translates HRESULT returned from XboxDbg APIs into string and
    output to standard error

Auguments:

    hr - HRESULT returned from various XboxDbg APIs

Return Value:

    None
*/

{
    CHAR Buffer[512];

    DmTranslateErrorA( hr, Buffer, sizeof(Buffer) );
    cout<<"TRANSLATE ERROR - "<<Buffer<<endl;
}





BOOL WINAPI ConsoleCtrlHandler( DWORD CtrlType )
/*++

Routine Description:

    A HandlerRoutine function is an application-defined function used with
    the SetConsoleCtrlHandler function.  A console process uses this function
    to handle control signals received by the process

Arguments:

    CtrlType - Indicates the type of control signal received by the handler.

Return Value:

    Return FALSE to terminate the process

--*/
{
    switch ( CtrlType ) {
    case CTRL_C_EVENT:
    case CTRL_BREAK_EVENT:
    case CTRL_CLOSE_EVENT:

        fprintf( stdout, "Terminating...\n" );

        //
        // Close notification and connection if needed
        //

        if ( fNotificationOpened ) {
            DmCloseNotificationSession( DmSession );
        }

        if ( fConnectionOpened ) {
            DmUseSharedConnection( FALSE );
        }

        return FALSE;
    }

    return TRUE;
}








/////////////////////////////////////////////////////////////////////////////
// CNetDebug


STDMETHODIMP CNetDebug::Connect(BSTR xboxName)
{
    HRESULT hr = S_OK;
	
	//
	//  Hook Ctrl+C handle so that we can do cleanup work
	//

	SetConsoleCtrlHandler( ConsoleCtrlHandler, TRUE );

    //
    // Open a shared debug connection with xbdm
    //

    hr = DmUseSharedConnection( TRUE );

    if ( FAILED(hr) )
	{
        TranslateError( hr );
    	return hr;
    }
	else
	{
        fConnectionOpened = TRUE;
    }

	LPSTR Ansi_XboxName = NULL;
	UnicodeToAnsi(xboxName,&Ansi_XboxName);
	
	cout<<"Connect to - "<<Ansi_XboxName<<endl;
	
	hr = DmSetXboxName(Ansi_XboxName);

	if ( FAILED(hr) )
	{
        TranslateError( hr );
    	DmUseSharedConnection( FALSE );
		return 1;
    }

	return hr;
}



STDMETHODIMP CNetDebug::Start()
{

	cout<<"START"<<endl;

	HRESULT hr = S_OK;


	LIST_HEAD = new debugline;
	LIST_HEAD->data = NULL;
	LIST_HEAD->next = NULL;


	hr = DmOpenNotificationSession( DM_PERSISTENT, &DmSession );

	
    if ( SUCCEEDED(hr) ) 
	{
        fNotificationOpened = TRUE;
        
		hr = DmNotify( DmSession, DM_DEBUGSTR, NotificationProc );
		if ( SUCCEEDED(hr) )
		{
			cout<<"+++++++++++++++++++++++++++++++++++Started Listening"<<endl;
		}
		else
		{
			TranslateError( hr );
		}
	}
	else
	{
		TranslateError( hr );
	}
	
	return hr;

}


STDMETHODIMP CNetDebug::Stop()
{
	cout<<"Stop"<<endl;
	return DmCloseNotificationSession( DmSession );
}

STDMETHODIMP CNetDebug::GetLine(unsigned int lineNum, short operation, BSTR *pVal)
{
	cout<<"GetLine"<<endl;


	return S_OK;
}

STDMETHODIMP CNetDebug::GetAllLines(BOOL clear, BSTR *pVal)
{
	cout<<"***********************************GetAllLines"<<endl;
	*pVal = output_lines(LIST_HEAD);
	return S_OK;
}

STDMETHODIMP CNetDebug::get_ParseTag(BSTR *pVal)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CNetDebug::put_ParseTag(BSTR newVal)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CNetDebug::Disconnect()
{
	cout<<"Disconnect"<<endl;
	clear(LIST_HEAD);
	return DmUseSharedConnection( FALSE );

}

STDMETHODIMP CNetDebug::ClearLines()
{
	cout<<"ClearLines"<<endl;
	
	clear(LIST_HEAD);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\TCPDuke\main.cpp ===
//-------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
// Author: Natalyp
//-------------------------------------------------------------
#include <windows.h>
#include <winsock2.h>

#include <stdio.h>
#include "Msg.h"
#include "XboxDbg.h"

const int ciServerPort = 10000;

void Cleanup(int sd)
{
	if(sd != INVALID_SOCKET)
	{
		shutdown(sd, SD_SEND);
		closesocket(sd);	
	}
}

int _cdecl main (int argc, char *argv[]) {

  int sd, rc, i;
  SOCKADDR_IN localAddr, servAddr;
  struct hostent* host;
  static char szBuf[256];
  

  if(argc < 2) {
	sprintf(szBuf, "usage: %s <server> \n", argv[0]);
    OutputDebugString(szBuf);
   return -1;
  }

  WSADATA WsaData;
  int iResult = WSAStartup( MAKEWORD(2,2), &WsaData );
  if( iResult != NO_ERROR )
  {
	return -1;
  }

  if (DmSetXboxName(argv[1]) != XBDM_NOERR)
  {
	  DWORD dwRes = GetLastError();
	  OutputDebugString("DmSetXboxName failed\n");
	  return -1;
  }

  DWORD dwDebugIPAddr = 0;
  if (DmResolveXboxName(&dwDebugIPAddr) != XBDM_NOERR)
  {
	  DWORD dwRes = GetLastError();
	  OutputDebugString("DmResolveXboxName failed\n");
	  return -1;
  }

  DWORD dwTitleIPAddr = 0;
  if(DmGetAltAddress(&dwTitleIPAddr)!= XBDM_NOERR)
  {
	  DWORD dwRes = GetLastError();
	  OutputDebugString("DmGetAltAddress failed\n");
	  return -1;
  }

   host = gethostbyname(argv[1]);
   servAddr.sin_family = host->h_addrtype;
   memcpy((char *) &servAddr.sin_addr.s_addr, host->h_addr_list[0], host->h_length);
   servAddr.sin_port = htons(ciServerPort);

/*  servAddr.sin_family = AF_INET;
  servAddr.sin_addr.s_addr = htonl(dwTitleIPAddr);
  servAddr.sin_port = htons(ciServerPort);
*/
  /* create socket */
  sd = socket(AF_INET, SOCK_STREAM, 0);
  if(sd<0) 
  {
    OutputDebugString("cannot open socket\n ");
    return -1;
  }

  /* connect to server */
  rc = connect(sd, (struct sockaddr *) &servAddr, sizeof(servAddr));
  if(rc<0) 
  {
	int iErr = WSAGetLastError();
    perror("cannot connect ");
    return -1;
  }


  for(int j = 0; j<3; j++) 
  {

	  AutoMessage GamepadMsg;
	  ZeroMemory(&GamepadMsg, sizeof(GamepadMsg));
	  GamepadMsg.m_byMessageId= 1;

	  GamepadMsg.m_Data.xbGamepad.wButtons = 0xaaaa;
	  GamepadMsg.m_Data.xbGamepad.wPressedButtons = XINPUT_GAMEPAD_DPAD_DOWN;
	  GamepadMsg.m_Data.xbGamepad.wLastButtons=3;
      GamepadMsg.m_Data.xbGamepad.bInserted = true;
      GamepadMsg.m_Data.xbGamepad.bRemoved = true;
	  GamepadMsg.m_Data.xbGamepad.hDevice = (HANDLE) 1234;
	  GamepadMsg.m_Data.xbGamepad.Feedback.Header.hEvent = (HANDLE) 1234;
	  GamepadMsg.m_Data.xbGamepad.Feedback.Header.dwStatus = 0xbbbbbbbb;
	  memset(GamepadMsg.m_Data.xbGamepad.Feedback.Header.Reserved, 'a', sizeof(GamepadMsg.m_Data.xbGamepad.Feedback.Header.Reserved));

	  // sending Gamepad message
	  rc = send(sd,(char*) &GamepadMsg, sizeof(GamepadMsg), 0);
      if(rc<0) 
	  {
		  perror("cannot send data ");
		  Cleanup(sd);
		  return -1;
	  }

	  // sending heartbit message
	  AutoMessage HeartBitMsg;
	  ZeroMemory(&HeartBitMsg, sizeof(HeartBitMsg));
	  HeartBitMsg.m_byMessageId= 2;
	  rc = send(sd,(char*) &HeartBitMsg, sizeof(HeartBitMsg), 0);

    if(rc<0) 
	{
      perror("cannot send data ");
      Cleanup(sd);
      return -1;
    }
	
	Sleep(10000);
  }

  for (i=0; i<5; i++)
  {
	AutoMessage HeartBitMsg;
	ZeroMemory(&HeartBitMsg, sizeof(HeartBitMsg));
	HeartBitMsg.m_byMessageId= 2;
	rc = send(sd,(char*) &HeartBitMsg, sizeof(HeartBitMsg), 0);

	if(rc<0) 
	{
	  perror("cannot send data ");
	  Cleanup(sd);
	  return -1;
	}
	Sleep(45000);
  }
// simulate connection reset by the server
  Sleep(12000);
  Cleanup(sd);
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\Models\StartMenu.cs ===
using System;

using Modeling;
using Modeling.Events;

//TODO: Rename the Model Namespace to reflect your area
namespace CustomModels {

	/****************  StartMenu Model *****************
	 *	Description: 
	 *	Area: 
	 *	Author: 
	 *	Dependencies: Modeling.dll
	 *	Revision History:
	 **********************************************************/
	/// <summary>
	/// StartMenu Model class
	/// </summary>
	public class StartMenu : Model 
	{

		//Custom Properties
		/* TODO: Add any custom Properties here that you want to make available to your Model handlers
		 * Example:
		 *	private int myVariable = 5;
		 */
		
		/// <summary>
		/// Creates a StartMenu Model instance
		/// </summary>
		public StartMenu()
		{
			Description = "StartMenu Model";
			ModelPath = "StartMenu.csv";

			//Attach Event Handlers
			OnInitialize += new EventHandler(OnInitialize_Handler);
			OnCleanUp += new EventHandler(OnCleanUp_Handler);
			OnGetCurrentState += new StateEventHandler(OnGetCurrentState_Handler);

			//Add StateVariables
			AddStateVariable("ScreenName");
			AddStateVariable("ButtonFocus");			
			//Add Action Handlers
			AddAction("StartButtonPress", new ActionHandler(StartButtonPress));
			AddAction("OtherButtonPress", new ActionHandler(OtherButtonPress));
			AddAction("StandardNavigationUpPress", new ActionHandler(StandardNavigationUpPress));
			AddAction("StandardNavigationDownPress", new ActionHandler(StandardNavigationDownPress));
			AddAction("NavigateLeftRightPress", new ActionHandler(NavigateLeftRightPress));
			AddAction("BackButtonPress", new ActionHandler(BackButtonPress));
		}


		/// <summary>
		/// Initializes the Model
		/// </summary>
		/// <remarks>
		/// Attached to OnInitialize event which is fired when your model is
		/// created and added to a Traversal
		/// </remarks>
		/// <param name="sender">The model that fired the event</param>
		/// <param name="e">Contains no information (EventArgs.Empty)</param>
		private void OnInitialize_Handler(object sender, EventArgs e)
		{
			//TODO: Put code here that prepares the interfaces that your model will test.
			
		}


		/// <summary>
		/// Cleans up the Model
		/// </summary>
		/// <remarks>
		/// Attached to OnCleanUp event which is fired when your model is
		/// removed from the Traversal
		/// </remarks>
		/// <param name="sender">The model that fired the event</param>
		/// <param name="e">Contains no information (EventArgs.Empty)</param>
		private void OnCleanUp_Handler(object sender, EventArgs e) 
		{
			//TODO: Put code here that releases any interfaces that your model used during the test.
			
		}


		/// <summary>
		/// Gets the current State of the Model
		/// </summary>
		/// <remarks>
		/// Attached to OnGetCurrentState event which is fired after
		/// each action to validate
		/// </remarks>
		/// <param name="sender">Model that fired the event</param>
		/// <param name="e">The current State in a StateEventArgs</param>
		private void OnGetCurrentState_Handler(object sender, StateEventArgs e)
		{
			// The state values set here will be compared to the expected state by the Model's default ValidateState function.
			// Only put code here that sets the State object to represent the current State of the Model.
			
			//TODO: Modify the sample code below to set the value of each state variable
			e.State["ScreenName"] = null;	//This screen is open
			e.State["ButtonFocus"] = null;	//This button in main has focus
		}

		

		/// <summary>
		/// 
		/// </summary>
		/// <remarks>Handler for StartButtonPress</remarks>
		/// <param name="endState">Expected end State object</param>
		/// <param name="inParams">Input action parameters object</param>
		/// <param name="outParams">Output action parameters object</param>
		/// <returns>false if errors</returns>
		private bool StartButtonPress(State endState, State inParams, State outParams)
		{
			//Action Params (listed here for convienence during coding)
			//inParams["StartButtons"] - Press a start button

			/* You should perform your action based on the Action Parameters passed to you in the Params Object.
			 * Use the ParamsOut object to validate the result of the action
			 * If the action fails you should call RaiseError and return false.
			 */
			//TODO: Add necessary action specific functionality here.

			return true;
		}


		/// <summary>
		/// 
		/// </summary>
		/// <remarks>Handler for OtherButtonPress</remarks>
		/// <param name="endState">Expected end State object</param>
		/// <param name="inParams">Input action parameters object</param>
		/// <param name="outParams">Output action parameters object</param>
		/// <returns>false if errors</returns>
		private bool OtherButtonPress(State endState, State inParams, State outParams)
		{
			//Action Params (listed here for convienence during coding)
			//inParams["OtherButtons"] - press another button

			/* You should perform your action based on the Action Parameters passed to you in the Params Object.
			 * Use the ParamsOut object to validate the result of the action
			 * If the action fails you should call RaiseError and return false.
			 */
			//TODO: Add necessary action specific functionality here.

			return true;
		}


		/// <summary>
		/// 
		/// </summary>
		/// <remarks>Handler for StandardNavigationUpPress</remarks>
		/// <param name="endState">Expected end State object</param>
		/// <param name="inParams">Input action parameters object</param>
		/// <param name="outParams">Output action parameters object</param>
		/// <returns>false if errors</returns>
		private bool StandardNavigationUpPress(State endState, State inParams, State outParams)
		{
			//Action Params (listed here for convienence during coding)
			//inParams["StandardNavigationUp"] - Navigate the dash using standard means

			/* You should perform your action based on the Action Parameters passed to you in the Params Object.
			 * Use the ParamsOut object to validate the result of the action
			 * If the action fails you should call RaiseError and return false.
			 */
			//TODO: Add necessary action specific functionality here.

			return true;
		}


		/// <summary>
		/// 
		/// </summary>
		/// <remarks>Handler for StandardNavigationDownPress</remarks>
		/// <param name="endState">Expected end State object</param>
		/// <param name="inParams">Input action parameters object</param>
		/// <param name="outParams">Output action parameters object</param>
		/// <returns>false if errors</returns>
		private bool StandardNavigationDownPress(State endState, State inParams, State outParams)
		{
			//Action Params (listed here for convienence during coding)
			//inParams["StandardNavigationDown"] - Navigate the dash using standard means 

			/* You should perform your action based on the Action Parameters passed to you in the Params Object.
			 * Use the ParamsOut object to validate the result of the action
			 * If the action fails you should call RaiseError and return false.
			 */
			//TODO: Add necessary action specific functionality here.

			return true;
		}


		/// <summary>
		/// 
		/// </summary>
		/// <remarks>Handler for NavigateLeftRightPress</remarks>
		/// <param name="endState">Expected end State object</param>
		/// <param name="inParams">Input action parameters object</param>
		/// <param name="outParams">Output action parameters object</param>
		/// <returns>false if errors</returns>
		private bool NavigateLeftRightPress(State endState, State inParams, State outParams)
		{
			//Action Params (listed here for convienence during coding)
			//inParams["NavigateLeftRight"] - Navigate the dash using standard means 

			/* You should perform your action based on the Action Parameters passed to you in the Params Object.
			 * Use the ParamsOut object to validate the result of the action
			 * If the action fails you should call RaiseError and return false.
			 */
			//TODO: Add necessary action specific functionality here.

			return true;
		}


		/// <summary>
		/// 
		/// </summary>
		/// <remarks>Handler for BackButtonPress</remarks>
		/// <param name="endState">Expected end State object</param>
		/// <param name="inParams">Input action parameters object</param>
		/// <param name="outParams">Output action parameters object</param>
		/// <returns>false if errors</returns>
		private bool BackButtonPress(State endState, State inParams, State outParams)
		{
			//Action Params (listed here for convienence during coding)
			//inParams["BackButton"] - Press a back button

			/* You should perform your action based on the Action Parameters passed to you in the Params Object.
			 * Use the ParamsOut object to validate the result of the action
			 * If the action fails you should call RaiseError and return false.
			 */
			//TODO: Add necessary action specific functionality here.

			return true;
		}

	
	}

}

//This script file was generated using TMT on: Monday, January 28, 2002 15:27:26
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\xbDebug\xbDebug_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Feb 11 15:00:43 2002
 */
/* Compiler settings for C:\xbox\private\test\ui\automation\xbDebug\xbDebug.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )

#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "xbDebug.h"

#define TYPE_FORMAT_STRING_SIZE   55                                
#define PROC_FORMAT_STRING_SIZE   247                               

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: INetDebug, ver. 0.0,
   GUID={0xB6BD872B,0xD6C7,0x4ACD,{0x97,0x04,0x81,0xF4,0xDC,0xE6,0x5C,0xA4}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO INetDebug_ServerInfo;

#pragma code_seg(".orpc")
extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[1];

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x50100a4, /* MIDL Version 5.1.164 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    1,  /* Flags */
    0,  /* Reserved3 */
    0,  /* Reserved4 */
    0   /* Reserved5 */
    };

static const unsigned short INetDebug_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    28,
    50,
    72,
    112,
    146,
    174,
    202,
    224
    };

static const MIDL_SERVER_INFO INetDebug_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &INetDebug_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO INetDebug_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &INetDebug_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(16) _INetDebugProxyVtbl = 
{
    &INetDebug_ProxyInfo,
    &IID_INetDebug,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* INetDebug::Connect */ ,
    (void *)-1 /* INetDebug::Start */ ,
    (void *)-1 /* INetDebug::Stop */ ,
    (void *)-1 /* INetDebug::GetLine */ ,
    (void *)-1 /* INetDebug::GetAllLines */ ,
    (void *)-1 /* INetDebug::get_ParseTag */ ,
    (void *)-1 /* INetDebug::put_ParseTag */ ,
    (void *)-1 /* INetDebug::Disconnect */ ,
    (void *)-1 /* INetDebug::ClearLines */
};


static const PRPC_STUB_FUNCTION INetDebug_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _INetDebugStubVtbl =
{
    &IID_INetDebug,
    &INetDebug_ServerInfo,
    16,
    &INetDebug_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

#pragma data_seg(".rdata")

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[1] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf, [wire_marshal] or [user_marshal] attribute, more than 32 methods in the interface.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure Connect */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/*  8 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter xboxName */

/* 16 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 18 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 20 */	NdrFcShort( 0x1a ),	/* Type Offset=26 */

	/* Return value */

/* 22 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 24 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 26 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Start */

/* 28 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 30 */	NdrFcLong( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 36 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
/* 40 */	NdrFcShort( 0x8 ),	/* 8 */
/* 42 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 44 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 46 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 48 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Stop */

/* 50 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 52 */	NdrFcLong( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0x9 ),	/* 9 */
#ifndef _ALPHA_
/* 58 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0x8 ),	/* 8 */
/* 64 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 66 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 68 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 70 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetLine */

/* 72 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 74 */	NdrFcLong( 0x0 ),	/* 0 */
/* 78 */	NdrFcShort( 0xa ),	/* 10 */
#ifndef _ALPHA_
/* 80 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 82 */	NdrFcShort( 0xe ),	/* 14 */
/* 84 */	NdrFcShort( 0x8 ),	/* 8 */
/* 86 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter lineNum */

/* 88 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 90 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 92 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter operation */

/* 94 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 96 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 98 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Parameter pVal */

/* 100 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 102 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 104 */	NdrFcShort( 0x2c ),	/* Type Offset=44 */

	/* Return value */

/* 106 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 108 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 110 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAllLines */

/* 112 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 114 */	NdrFcLong( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0xb ),	/* 11 */
#ifndef _ALPHA_
/* 120 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 122 */	NdrFcShort( 0x8 ),	/* 8 */
/* 124 */	NdrFcShort( 0x8 ),	/* 8 */
/* 126 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter clear */

/* 128 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 130 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 132 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pVal */

/* 134 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 136 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 138 */	NdrFcShort( 0x2c ),	/* Type Offset=44 */

	/* Return value */

/* 140 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 142 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 144 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ParseTag */

/* 146 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 148 */	NdrFcLong( 0x0 ),	/* 0 */
/* 152 */	NdrFcShort( 0xc ),	/* 12 */
#ifndef _ALPHA_
/* 154 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 156 */	NdrFcShort( 0x0 ),	/* 0 */
/* 158 */	NdrFcShort( 0x8 ),	/* 8 */
/* 160 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pVal */

/* 162 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 164 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 166 */	NdrFcShort( 0x2c ),	/* Type Offset=44 */

	/* Return value */

/* 168 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 170 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 172 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_ParseTag */

/* 174 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 176 */	NdrFcLong( 0x0 ),	/* 0 */
/* 180 */	NdrFcShort( 0xd ),	/* 13 */
#ifndef _ALPHA_
/* 182 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 184 */	NdrFcShort( 0x0 ),	/* 0 */
/* 186 */	NdrFcShort( 0x8 ),	/* 8 */
/* 188 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter newVal */

/* 190 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 192 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 194 */	NdrFcShort( 0x1a ),	/* Type Offset=26 */

	/* Return value */

/* 196 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 198 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 200 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Disconnect */

/* 202 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 204 */	NdrFcLong( 0x0 ),	/* 0 */
/* 208 */	NdrFcShort( 0xe ),	/* 14 */
#ifndef _ALPHA_
/* 210 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 212 */	NdrFcShort( 0x0 ),	/* 0 */
/* 214 */	NdrFcShort( 0x8 ),	/* 8 */
/* 216 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 218 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 220 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 222 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ClearLines */

/* 224 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 226 */	NdrFcLong( 0x0 ),	/* 0 */
/* 230 */	NdrFcShort( 0xf ),	/* 15 */
#ifndef _ALPHA_
/* 232 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 236 */	NdrFcShort( 0x8 ),	/* 8 */
/* 238 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 240 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 242 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 244 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0xc ),	/* Offset= 12 (16) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 16 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 18 */	NdrFcShort( 0x8 ),	/* 8 */
/* 20 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (6) */
/* 22 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 24 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 26 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */
/* 30 */	NdrFcShort( 0x4 ),	/* 4 */
/* 32 */	NdrFcShort( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (2) */
/* 36 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 38 */	NdrFcShort( 0x6 ),	/* Offset= 6 (44) */
/* 40 */	
			0x13, 0x0,	/* FC_OP */
/* 42 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (16) */
/* 44 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 46 */	NdrFcShort( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0x4 ),	/* 4 */
/* 50 */	NdrFcShort( 0x0 ),	/* 0 */
/* 52 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (40) */

			0x0
        }
    };

const CInterfaceProxyVtbl * _xbDebug_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_INetDebugProxyVtbl,
    0
};

const CInterfaceStubVtbl * _xbDebug_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_INetDebugStubVtbl,
    0
};

PCInterfaceName const _xbDebug_InterfaceNamesList[] = 
{
    "INetDebug",
    0
};

const IID *  _xbDebug_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _xbDebug_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _xbDebug, pIID, n)

int __stdcall _xbDebug_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_xbDebug_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo xbDebug_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _xbDebug_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _xbDebug_StubVtblList,
    (const PCInterfaceName * ) & _xbDebug_InterfaceNamesList,
    (const IID ** ) & _xbDebug_BaseIIDList,
    & _xbDebug_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\cortana\xbDebug\xbDebug.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Mon Feb 11 15:00:43 2002
 */
/* Compiler settings for C:\xbox\private\test\ui\automation\xbDebug\xbDebug.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __xbDebug_h__
#define __xbDebug_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __INetDebug_FWD_DEFINED__
#define __INetDebug_FWD_DEFINED__
typedef interface INetDebug INetDebug;
#endif 	/* __INetDebug_FWD_DEFINED__ */


#ifndef __NetDebug_FWD_DEFINED__
#define __NetDebug_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetDebug NetDebug;
#else
typedef struct NetDebug NetDebug;
#endif /* __cplusplus */

#endif 	/* __NetDebug_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __INetDebug_INTERFACE_DEFINED__
#define __INetDebug_INTERFACE_DEFINED__

/* interface INetDebug */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_INetDebug;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B6BD872B-D6C7-4ACD-9704-81F4DCE65CA4")
    INetDebug : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ BSTR xboxName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLine( 
            /* [in] */ unsigned int lineNum,
            /* [in] */ short operation,
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetAllLines( 
            /* [in] */ BOOL clear,
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ParseTag( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ParseTag( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ClearLines( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetDebugVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INetDebug __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INetDebug __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INetDebug __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            INetDebug __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            INetDebug __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            INetDebug __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            INetDebug __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            INetDebug __RPC_FAR * This,
            /* [in] */ BSTR xboxName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            INetDebug __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            INetDebug __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLine )( 
            INetDebug __RPC_FAR * This,
            /* [in] */ unsigned int lineNum,
            /* [in] */ short operation,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllLines )( 
            INetDebug __RPC_FAR * This,
            /* [in] */ BOOL clear,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ParseTag )( 
            INetDebug __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ParseTag )( 
            INetDebug __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Disconnect )( 
            INetDebug __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearLines )( 
            INetDebug __RPC_FAR * This);
        
        END_INTERFACE
    } INetDebugVtbl;

    interface INetDebug
    {
        CONST_VTBL struct INetDebugVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetDebug_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetDebug_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetDebug_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetDebug_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define INetDebug_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define INetDebug_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define INetDebug_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define INetDebug_Connect(This,xboxName)	\
    (This)->lpVtbl -> Connect(This,xboxName)

#define INetDebug_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define INetDebug_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define INetDebug_GetLine(This,lineNum,operation,pVal)	\
    (This)->lpVtbl -> GetLine(This,lineNum,operation,pVal)

#define INetDebug_GetAllLines(This,clear,pVal)	\
    (This)->lpVtbl -> GetAllLines(This,clear,pVal)

#define INetDebug_get_ParseTag(This,pVal)	\
    (This)->lpVtbl -> get_ParseTag(This,pVal)

#define INetDebug_put_ParseTag(This,newVal)	\
    (This)->lpVtbl -> put_ParseTag(This,newVal)

#define INetDebug_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define INetDebug_ClearLines(This)	\
    (This)->lpVtbl -> ClearLines(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE INetDebug_Connect_Proxy( 
    INetDebug __RPC_FAR * This,
    /* [in] */ BSTR xboxName);


void __RPC_STUB INetDebug_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE INetDebug_Start_Proxy( 
    INetDebug __RPC_FAR * This);


void __RPC_STUB INetDebug_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE INetDebug_Stop_Proxy( 
    INetDebug __RPC_FAR * This);


void __RPC_STUB INetDebug_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE INetDebug_GetLine_Proxy( 
    INetDebug __RPC_FAR * This,
    /* [in] */ unsigned int lineNum,
    /* [in] */ short operation,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB INetDebug_GetLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE INetDebug_GetAllLines_Proxy( 
    INetDebug __RPC_FAR * This,
    /* [in] */ BOOL clear,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB INetDebug_GetAllLines_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE INetDebug_get_ParseTag_Proxy( 
    INetDebug __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB INetDebug_get_ParseTag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE INetDebug_put_ParseTag_Proxy( 
    INetDebug __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB INetDebug_put_ParseTag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE INetDebug_Disconnect_Proxy( 
    INetDebug __RPC_FAR * This);


void __RPC_STUB INetDebug_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE INetDebug_ClearLines_Proxy( 
    INetDebug __RPC_FAR * This);


void __RPC_STUB INetDebug_ClearLines_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetDebug_INTERFACE_DEFINED__ */



#ifndef __XBDEBUGLib_LIBRARY_DEFINED__
#define __XBDEBUGLib_LIBRARY_DEFINED__

/* library XBDEBUGLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_XBDEBUGLib;

EXTERN_C const CLSID CLSID_NetDebug;

#ifdef __cplusplus

class DECLSPEC_UUID("B11C43CA-5735-43FD-98AF-52875CC56EA7")
NetDebug;
#endif
#endif /* __XBDEBUGLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\DukeInfo\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#define APP_TITLE_NAME_A                        "DukeInfo"

// Screen Dimensions
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2 )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2 )

// Launcher Menu Item Information
#define MENU_LAUNCH_MACHINENAME_X1              SCREEN_X_CENTER             // This is not used, it is calculated
#define MENU_LAUNCH_MACHINENAME_Y1              ( SCREEN_HEIGHT - 65.0f )
#define MENU_LAUNCH_NUMXBES_Y1                  MENUBOX_MAINAREA_Y1 - 28.0f
#define MENU_LAUNCH_MACHINENAME_FONTHEIGHT      28
#define MENU_LAUNCH_TOP_BORDER_SIZE             10.0f

// Menubox constants
#define MENUBOX_MAINAREA_X1                      99.0f
#define MENUBOX_MAINAREA_Y1                     134.0f
#define MENUBOX_MAINAREA_X2                     535.0f
#define MENUBOX_MAINAREA_Y2                     375.0f
#define MENUBOX_VALUE_X1                        225.0f
#define MENUBOX_RIGHT_COL_X1                    290.0f
#define MENUBOX_RIGHT_VALUE_X1                  455.0f

#define MENUBOX_SELECTBAR_X1                    MENUBOX_MAINAREA_X1
#define MENUBOX_SELECTBAR_X2                    ( MENUBOX_MAINAREA_X2 + 1 )

#define MENUBOX_TEXT_TOP_BORDER                   4.0f
#define MENUBOX_TEXT_BOTTOM_BORDER                0.0f
#define MENUBOX_TEXT_LSIDE_BORDER                 4.0f
#define MENUBOX_TEXT_RSIDE_BORDER                 4.0f

#define MENUBOX_TEXTAREA_X1                     ( MENUBOX_MAINAREA_X1 + MENUBOX_TEXT_LSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y1                     ( MENUBOX_MAINAREA_Y1 + MENUBOX_TEXT_TOP_BORDER)
#define MENUBOX_TEXTAREA_X2                     ( MENUBOX_MAINAREA_X2 - MENUBOX_TEXT_RSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y2                     ( MENUBOX_MAINAREA_Y2 - MENUBOX_TEXT_BOTTOM_BORDER )

// Behaviour constants
#define KEY_PRESS_DELAY                         400  // milliseconds

// Font info
#define FONT_DEFAULT_HEIGHT                     18
#define FONT_DEFAULT_WIDTH                      8
#define FONT_ALIAS_LEVEL                        4
#define FONT_DEFAULT_STYLE                      XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS

// Screen Item Constants
#define SCREEN_ITEM_TEXT_LENGTH                 128

// Colors
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_LIGHT_GRAY                        0xFFC8C8C8
#define COLOR_LIME_GREEN                        0xFF9BD351
#define COLOR_DARK_GREEN                        0xFF2C531E

#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_TEXT_FG_COLOR            COLOR_DARK_GREEN
#define SCREEN_DEFAULT_TEXT_BG_COLOR            SCREEN_DEFAULT_BACKGROUND_COLOR

// Menu Item constants
#define ITEM_SELECTOR_BORDER_SPACE              2
#define ITEM_VERT_SPACING                       7.0f
#define ITEM_SELECTOR_COLOR                     COLOR_LIME_GREEN

// File path and location constants
#define FILE_DATA_DRIVE_W                       L"t:"
#define FILE_DATA_DRIVE_A                       "t:"
#define FILE_DATA_MEDIA_DIRECTORY_W             FILE_DATA_DRIVE_W L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_MENU_DIRECTORY_A              FILE_DATA_DRIVE_A "\\menus"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\images"
#define FILE_SPLASHSCREEN_LOCATION_A            FILE_DATA_IMAGE_DIRECTORY_A "\\loading.bmp"
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY_W L"\\tahoma.ttf"

// XBox Information
#define NUM_XBOX_PORTS                          4
#define NUM_XBOX_MU_SLOTS                       8
#define NUM_DUKE_BUTTONS                        8
#define NUM_DUKE_CONTROLS                       8
#define NUM_DUKE_SLOTS                          2

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\DukeInfo\dukeinfo.cpp ===
#include "stdafx.h"
#include "menuscreen.h"

// Forward declarations
HRESULT DrawScreen(void );
HRESULT SetupMenusAndItems( void );
HRESULT CleanUp( void );
HRESULT Init( void );

// Menus are created here
CMenuScreen g_RootMenu( NULL );     // Only screen in our app

// Other globals
CXBoxVideo Screen;                  // Screen object where all text / info is displayed
USBManager Controllers;             // Used to determine what buttons / direction the user is pressing
CXItem* g_pCurrentScreen = NULL;	// Pointer to the current menu object

void _cdecl main()
{
    XDBGTRC( APP_TITLE_NAME_A, "***** main()" );

    Init();

    do
    {
        DrawScreen();
    } while( true );

    CleanUp();

    XDBGTRC( APP_TITLE_NAME_A, "***** main()" );
}

// Draw our screen
HRESULT DrawScreen( void )
{
    g_pCurrentScreen->Action( &Screen );        // Current menu action
    Screen.ShowScreen();                        // Move the screen from the backbuffer to the foreground

    return S_OK;
}

// Initialize our application - video, sound, etc
HRESULT Init( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "Init()" );

    // Initialize our drawing routines (d3d, etc)
    Screen.Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );

    // Display our 'splash' screen
    BitmapFile oSplashScreen;
    oSplashScreen.read( 0, 0, FILE_SPLASHSCREEN_LOCATION_A );

    Screen.ClearScreen( COLOR_BLACK );
    oSplashScreen.render( Screen.GetD3DDevicePtr() );
    Screen.ShowScreen();

    // Setup Menus and Items
    SetupMenusAndItems();

    return S_OK;
}

// Clean up our application (close drivers, etc)
HRESULT CleanUp( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CleanUp()" );

    Screen.DeInitialize();

    return S_OK;
}

// Setup our Menus and Items for our application
HRESULT SetupMenusAndItems( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "  SetupMenusAndItems()" );

    HRESULT hr = S_OK;

    // Setup the Root Menu
    hr = g_RootMenu.Init( &Screen, FILE_DATA_MENU_DIRECTORY_A "\\root.mnu" );
    if( FAILED( hr ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "SetupMenusAndItems():Failed to add the root item info!!" );
    }

    // Establish our root menu
    g_pCurrentScreen = &g_RootMenu;

    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\DukeInfo\imagefile.h ===
#ifndef __ImageFile_H
#define __ImageFile_H

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;

class BitmapFile {
private:
	int ImageSize;
	DWORD *pixels;
	int xpos, ypos;

	// Bitmap File Header
	WORD Type;
	DWORD FileSize;
	WORD Reserved1;
	WORD Reserved2;
	DWORD OffBits;
	
	// Bitmap Info Header
	DWORD InfoSize;
	DWORD Width;
	DWORD Height;
	WORD Planes;
	WORD BitCount;
	DWORD Compression;
	DWORD SizeImage;
	DWORD XPelsPerMeter;
	DWORD YPelsPerMeter;
	DWORD ClrUsed;
	DWORD ClrImportant;

public:
	BitmapFile(void);
	~BitmapFile(void);
	
	void write(char *file, int imageWidth, int imageHeight, DWORD *pixels);
	int imagesize(char *file);
	void read(int xloc, int yloc, char *file);
	bool render(IDirect3DDevice8 *d3dDevice);

    DWORD GetWidth() { return Width; };         // Get the Width of the bitmap file
    DWORD GetHeight() { return Height; };       // Get the Height of the bitmap file
    int   GetXPos() { return xpos; };           // Get the X Position of the bitmap file
    int   GetYPos() { return ypos; };           // Get the Y Position of the bitmap file
    void  SetXPos( int x ) { xpos = x; };       // Set the X Position of the bitmap file
    void  SetYPos( int y ) { ypos = y; };       // Set the Y Position of the bitmap file
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\DukeInfo\imagefile.cpp ===
#include "stdafx.h"
#include "imagefile.h"

//////////////////////////////////////////////////////////////////////
// .BMP File format functions

BitmapFile::BitmapFile() {
	xpos = 0;
	ypos = 0;

	// Initialize Bitmap File Header
	Type	  = 19778;
	FileSize  = 192056;	//check this
	Reserved1 = 0;
	Reserved2 = 0;
	OffBits	  = 54;	//check this

	// Initialize Bitmap Info Header
	InfoSize	  = 40;
	Width		  = 0;
	Height		  = 0;
	Planes		  = 1;
	BitCount	  = 24;
	Compression	  = 0;
	SizeImage	  = 0;
	XPelsPerMeter = 2834;
	YPelsPerMeter = 2834;
	ClrUsed		  = 0;
	ClrImportant  = 0;
}

BitmapFile::~BitmapFile() {
    if( pixels )
    {
	    delete [] pixels;
        pixels = NULL;
    }
}

void BitmapFile::write(char *file, int imageWidth, int imageHeight, DWORD *pixels) {
	FILE *output;

	Width     = imageWidth;
	Height	  = imageHeight;
	ImageSize = imageWidth * imageHeight;

	//open the new bitmap file
	output = fopen(file, "wb");

	// Write the Bitmap File header information
	fwrite(&Type, sizeof(WORD), 1, output);
	fwrite(&FileSize, sizeof(DWORD), 1, output);
	fwrite(&Reserved1, sizeof(WORD), 1, output);
	fwrite(&Reserved2, sizeof(WORD), 1, output);
	fwrite(&OffBits, sizeof(DWORD), 1, output);

	//Write the Bitmap Info header information
	fwrite(&InfoSize, sizeof(DWORD), 1, output);
	fwrite(&Width, sizeof(DWORD), 1, output);
	fwrite(&Height, sizeof(DWORD), 1, output);
	fwrite(&Planes, sizeof(WORD), 1, output);
	fwrite(&BitCount, sizeof(WORD), 1, output);
	fwrite(&Compression, sizeof(DWORD), 1, output);
	fwrite(&SizeImage, sizeof(DWORD), 1, output);
	fwrite(&XPelsPerMeter, sizeof(DWORD), 1, output);
	fwrite(&YPelsPerMeter, sizeof(DWORD), 1, output);
	fwrite(&ClrUsed, sizeof(DWORD), 1, output);
	fwrite(&ClrImportant, sizeof(DWORD), 1, output);

	fclose(output);
}

int BitmapFile::imagesize(char *file) {
	FILE *input;
	input = fopen(file, "rb");

	// Read the Bitmap File header information
	fread(&Type, sizeof(WORD), 1, input);
	fread(&FileSize, sizeof(DWORD), 1, input);
	fread(&Reserved1, sizeof(WORD), 1, input);
	fread(&Reserved2, sizeof(WORD), 1, input);
	fread(&OffBits, sizeof(DWORD), 1, input);

	//Read the Bitmap Info header information
	fread(&InfoSize, sizeof(DWORD), 1, input);
	fread(&Width, sizeof(DWORD), 1, input);
	fread(&Height, sizeof(DWORD), 1, input);

	fclose(input);

	return (Width * Height);
}

void BitmapFile::read(int xloc, int yloc, char *file) {
	FILE *input;
	xpos = xloc;
	ypos = yloc;

	//open the new bitmap file
	input = fopen(file, "rb");
    if( !input )
    {
        XDBGWRN( APP_TITLE_NAME_A, "BitmapFile::read():fopen failed!! - '%s'", file );
        return;
    }

	// Read the Bitmap File header information
	fread(&Type, sizeof(WORD), 1, input);
	fread(&FileSize, sizeof(DWORD), 1, input);
	fread(&Reserved1, sizeof(WORD), 1, input);
	fread(&Reserved2, sizeof(WORD), 1, input);
	fread(&OffBits, sizeof(DWORD), 1, input);

	//Read the Bitmap Info header information
	fread(&InfoSize, sizeof(DWORD), 1, input);
	fread(&Width, sizeof(DWORD), 1, input);
	fread(&Height, sizeof(DWORD), 1, input);
	fread(&Planes, sizeof(WORD), 1, input);
	fread(&BitCount, sizeof(WORD), 1, input);
	fread(&Compression, sizeof(DWORD), 1, input);
	fread(&SizeImage, sizeof(DWORD), 1, input);
	fread(&XPelsPerMeter, sizeof(DWORD), 1, input);
	fread(&YPelsPerMeter, sizeof(DWORD), 1, input);
	fread(&ClrUsed, sizeof(DWORD), 1, input);
	fread(&ClrImportant, sizeof(DWORD), 1, input);

	ImageSize = Width * Height;
	pixels = new DWORD[ImageSize];

	float remainer = (float)Width / 4;
	float delta = remainer - (int)remainer;

	BYTE blue, green, red;
	for(int y = (int)Height - 1; y >= 0 ; y--)
	{
		for(int x = 0; x < (int)Width; x++)
		{
			fread(&blue, sizeof(BYTE), 1, input);
			fread(&green, sizeof(BYTE), 1, input);
			fread(&red, sizeof(BYTE), 1, input);
			int position = (y * (int)Width) + x;
			pixels[position] = (0xff << 24) | (red << 16) | (green << 8) | (blue);
		}
		
		//account for the extra bytes in bitmap files
		if(delta == 0.25f) fseek(input, 1, SEEK_CUR);
		else if(delta == 0.50f) fseek(input, 2, SEEK_CUR);
		else if(delta == 0.75f) fseek(input, 3, SEEK_CUR);
	}

	fclose(input);
}

bool BitmapFile::render(IDirect3DDevice8 *d3dDevice) {
	HRESULT hr;
	IDirect3DSurface8 *backBuffer;
	D3DLOCKED_RECT backBufferInfo;
	hr = d3dDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &backBuffer);
	if( FAILED( hr ))
	{
		XDBGWRN( APP_TITLE_NAME_A, "BitmapFile::render():Failed to get the backbuffer" );
		return false;
	}

	RECT container;
	container.top = ypos;
	container.left = xpos;
	container.bottom = ypos + Height;
	container.right = xpos + Width;	

	hr = backBuffer->LockRect(&backBufferInfo, &container, 0);
	if( FAILED( hr ))
	{
		XDBGWRN( APP_TITLE_NAME_A, "BitmapFile::render():Failed to lock the backbuffer" );
        backBuffer->Release();
		return false;
	}

	int destPitch = backBufferInfo.Pitch;
	int sourcePitch = Width * 4;
	BYTE *s = (BYTE*)pixels;
	BYTE *p = (BYTE*)backBufferInfo.pBits;
	for(int y = 0; y < (int)Height; y++)
	{
		memcpy(p, s, sourcePitch);
		s += sourcePitch;
		p += destPitch;
	}

	backBuffer->UnlockRect();
    backBuffer->Release();
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\DukeInfo\linkedlist.h ===
/*****************************************************
*** linkedlist.h
***
*** Header file for our linked list class.  This class
*** will allow the user to create a linked list using
*** any type of item.
***
*** by James N. Helm
*** October 31st, 2000
*** 
*****************************************************/

#ifndef _LINKEDLIST_H_
#define _LINKEDLIST_H_

#define BREAK_INTO_DEBUGGER _asm { int 3 }

template <class T> class CLinkedList
{
public:
    // Constructors and Destructors
    CLinkedList( void );
    ~CLinkedList( void );

    // Public Properties

    // Public Methods
    HRESULT AddNode( const T& item );                                           // Add a node to our linked list
    HRESULT DelNode( unsigned int uiIndex );                                    // Delete a node from our list by using an index
    HRESULT EmptyList( void );                                                  // Empty all of the items out of our list
    HRESULT MoveTo( unsigned int uiIndex );                                     // Move to the specified item in our list via index
    HRESULT MoveNext();                                                         // Move to the next item in the list
    HRESULT MovePrev();                                                         // Move to the prev item in the list
    unsigned int GetNumItems( void ) const;                                     // Get the number of items in our list
    void SetDeleteDataItem( bool bDelItem ) { m_bDeleteDataItem = bDelItem; };  // Set this if the list needs to delete the dataitem
    T& GetCurrentNode() const;                                                  // Get a data item from the current node in our list
    T& GetNode( unsigned int uiIndex );                                         // Get a data item from our list by using an index
    T& operator[]( unsigned int uiIndex );                                      // Get a data item from our list by using an index

private:
    // Node of our linked list
    struct _LISTNODE
    {
        T dataItem;
        struct _LISTNODE* pNext;
        struct _LISTNODE* pPrev;
    };

    // Private Properties
    unsigned int m_uicNumItems;         // Number of items in the list
    struct _LISTNODE* m_pHead;          // Head of our list
    struct _LISTNODE* m_pLast;          // Last Node of our list
    struct _LISTNODE* m_pCurrent;       // Points at the current item in the list
    unsigned int m_uicCurrentItemIndex; // Index of the item that is currently being pointed at
    bool m_bDeleteDataItem;             // This needs to be TRUE if you are passing in a structure / item that was 'new'ed

    // Private Methods

};


// Default Constructor.  Properties are initialized here
template< class T > CLinkedList< T >::CLinkedList( void )
: m_bDeleteDataItem( false),
  m_uicNumItems( 0 ),
  m_uicCurrentItemIndex( 0 ),
  m_pHead( NULL ),
  m_pLast( NULL),
  m_pCurrent( NULL )
{
}


// Destructor.  Memory cleanup is performed here
template< class T > CLinkedList< T >::~CLinkedList( void )
{
    // Empty all items from our list
    EmptyList();
}


// Add a node to our list
template< class T > HRESULT CLinkedList< T >::AddNode( const T& item )
{
    // Item to be added to our list
    struct _LISTNODE* pNewItem = new struct _LISTNODE;

    if( !pNewItem )
    {
        XDBGERR( APP_TITLE_NAME_A, "*** ERROR: CLinkedList():AddNode(): Could not allocate memory!!" );
        return E_OUTOFMEMORY;
    }

    pNewItem->dataItem = item;
    pNewItem->pNext = NULL;
    pNewItem->pPrev = NULL;

    // Check to see if we have a head node.  If not, add the item there
    if( !m_pHead )
    {
        m_pCurrent = m_pLast = m_pHead = pNewItem;
        m_uicCurrentItemIndex = 1;  // Points at the head node
        
    }
    else // Add the node to the end of our list
    {
        m_pLast->pNext = pNewItem;  // Add the new node to our list
        pNewItem->pPrev = m_pLast;  // Update the new nodes previous pointer
        m_pLast = pNewItem;         // Update our pLast pointer to point at the new last node
    }

    // Increment the number of items in our list
    ++m_uicNumItems;

    return S_OK;
}


// Delete a node from our list
template< class T > HRESULT CLinkedList< T >::DelNode( unsigned int uiIndex )
{
    // Make sure our index is valid.  If not, break in to the debugger
    if( uiIndex >= GetNumItems() )
    {
        return E_INVALIDARG;
    };

    struct _LISTNODE* pPrevNode = m_pHead;
    struct _LISTNODE* pSearchNode = m_pHead;

    // If we have a valid index, delete the referenced node
    for( unsigned int x = 0; x < uiIndex; ++x )
    {
        pPrevNode = pSearchNode;
        pSearchNode = pSearchNode->pNext;
    }

    // Deal with the head of the list
    if( pSearchNode == m_pHead )
    {
        // Check to see if it's the last node, and update our
        // our pointers
        if( m_pLast == m_pHead )
        {
            m_pCurrent = m_pLast = m_pHead = NULL;
        }
        else if( m_pCurrent = m_pHead ) // Deal with the 'Current' pointer if we have to
        {
            m_pCurrent = m_pHead = m_pHead->pNext;       // If head is the only node, m_pHead->pNext will be NULL
        }
        else // Only deal with the head node
        {
            m_pHead = m_pHead->pNext;       // If head is the only node, m_pHead->pNext will be NULL
        }

        // Check to see if our current point still points at anything, and if not,
        // make sure we set the Item Index to 0
        if( !m_pCurrent )
        {
            m_uicCurrentItemIndex = 0;
        }

        // Check to see if the new head node points at anything, and if so,
        // make sure the pPrev pointer is NULL
        if( m_pHead )
        {
            m_pHead->pPrev = NULL;
        }
    }
    else if( pSearchNode == m_pLast )   // Delete the last node in our list
    {
        // Check to see if our current node is pointing at the last node, and deal with it
        if( m_pCurrent == m_pLast )
        {
            m_pCurrent = m_pLast = pPrevNode;
            --m_uicCurrentItemIndex;            // Decrement our current item index since we were pointing at the last node
        }
        else // Only deal with the last node pointer, and don't worry about the current node pointer
        {
            m_pLast = pPrevNode;
        }
    }
    else // Not the head node or the last node ( middle node! )
    {

        // Check to see if our current node is this node, and if so,
        // move it along as well
        if( pSearchNode = m_pCurrent )
        {
            // Set our list to skip over the node we'll delete, and set our current pointer to the same item
            m_pCurrent = pPrevNode->pNext = pSearchNode->pNext;
        }
        else // Don't worry about the current node pointer, simply skip the node we'll delete
        {
            // Set our list to skip over the node we'll delete
            pPrevNode->pNext = pSearchNode->pNext;
        }
    }

    if( m_bDeleteDataItem )
    {
        delete pSearchNode->dataItem;
        pSearchNode->dataItem = NULL;
    }

    // Delete the node
    delete pSearchNode;
    pSearchNode = NULL;

    // Decrement our number of items counter
    --m_uicNumItems;

    return S_OK;
}


// Empty all the items from our list
template< class T > HRESULT CLinkedList< T >::EmptyList( void )
{
    HRESULT hr = S_OK;

    // Call our "DelNode" function until we are out of items
    while( GetNumItems() > 0 )
    {
        if( FAILED( hr = DelNode( 0 ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CLinkedList::EmptyList():Failed to delete node!!" );
        }
    }

    return hr;
}


// Get a data item from the current node in our list
template< class T > T& CLinkedList< T >::GetCurrentNode() const
{
    if( m_pCurrent )
    {
        return m_pCurrent->dataItem;
    }

    // This will only happen if the current pointer isn't pointing at a node
    // shame on the developer!!
    XDBGWRN( APP_TITLE_NAME_A, "CLinkedList GetCurrentNode():BREAKING IN TO THE DEBUGGER!!" );
    XDBGERR( APP_TITLE_NAME_A, "CLinkedList GetCurrentNode()No node at the current pointer!!" );
    BREAK_INTO_DEBUGGER; // Can't return anything nice here, so break in to the debugger
    
    return m_pCurrent->dataItem; // This line should never be executed, as m_pCurrent isn't valid!!
}


// Get a data item from our list by using an index value
template< class T > T& CLinkedList< T >::GetNode( unsigned int uiIndex )
{
    // Move to the requested Node in the list
    // MoveTo will handle an invalid index case
    HRESULT hr = MoveTo( uiIndex );
    if( FAILED( hr ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CLinkedList GetNode():BREAKING IN TO THE DEBUGGER!!" );
        XDBGERR( APP_TITLE_NAME_A, "CLinkedList GetNode():MoveTo failed!" );
        BREAK_INTO_DEBUGGER;    // Can't return anything nice here, so break in to the debugger
    }

    // Return the requested node to the user
    return GetCurrentNode();
}


// Move to the specified item in our list via index
template< class T > HRESULT CLinkedList< T >::MoveTo( unsigned int uiIndex )
{
    // Make sure our index is valid.  If not, return an error
    if( uiIndex >= GetNumItems() )
    {
        return E_INVALIDARG;
    };

    struct _LISTNODE* pSearchNode = m_pHead;

    // If we have a valid index, find the node in the list
    for( unsigned int x = 0; x < uiIndex; ++x )
    {
        pSearchNode = pSearchNode->pNext;
    }

    // Set our current pointer to the node we found and update our index
    m_pCurrent = pSearchNode;
    m_uicCurrentItemIndex = uiIndex;

    return S_OK;
}


// Move to the next item in the list
template< class T > HRESULT CLinkedList< T >::MoveNext()
{
    if( m_pCurrent->pNext )
    {
        m_pCurrent = m_pCurrent->pNext;
        ++m_uicCurrentItemIndex;
    }

    return S_OK;
}


// Move to the prev item in the list
template< class T > HRESULT CLinkedList< T >::MovePrev()
{
    if( m_pCurrent->pPrev )
    {
        m_pCurrent = m_pCurrent->pPrev;
        --m_uicCurrentItemIndex;
    }

    return S_OK;
}


// Get a data item from our list by using an index value
template< class T > T& CLinkedList< T >::operator[]( unsigned int uiIndex )
{
    return GetNode( uiIndex );
}


// Get a the number of items in our list
template< class T > unsigned int CLinkedList< T >::GetNumItems( void ) const
{
    return m_uicNumItems;
}


#endif // _LINKEDLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\DukeInfo\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define BREAK_INTO_DEBUGGER     _asm { int 3 }
#define ARRAYSIZE(a)            (sizeof(a) / sizeof(a[0]))
#define XFONT_TRUETYPE

#include <ntos.h>
#include <xtl.h>
#include <xfont.h>
#include <xdbg.h>
#include <stdio.h>

#include "constants.h"
#include "linkedlist.h"
#include "xboxvideo.h"
#include "usbmanager.h"
#include "xitem.h"

// Menus and Commands

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\DukeInfo\settingsmenu.cpp ===
/*****************************************************
*** settingsmenu.cpp
***
*** CPP file for our XShell Launch menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** December 2nd, 2000
***
*****************************************************/

#include "constants.h"
#include "settingsmenu.h"

extern CXItem* g_pCurrentScreen;  // Pointer to the current menu object

// Constructors
CSettingsMenu::CSettingsMenu()
: CMenuScreen()
{
    XDBGTRC( APP_TITLE_NAME_A, "CSettingsMenu::CSettingsMenu()" );

    m_uiNumItems = NUM_MAX_ENUM + 1;
    SetSelectedItem( 0 );
}


CSettingsMenu::CSettingsMenu( CXItem* pParent )
: CMenuScreen( pParent )
{
    XDBGTRC( APP_TITLE_NAME_A, "CSettingsMenu::CSettingsMenu(ex)" );

    m_uiNumItems = NUM_MAX_ENUM + 1;
    SetSelectedItem( 0 );
}


// Destructor
CSettingsMenu::~CSettingsMenu()
{
}


// Draws a menu on to the screen
void CSettingsMenu::Action( CXBoxVideo* pScreen )
{
    unsigned int nStringWidth = 0;
    float fScreenCenter = ( ( MENUBOX_SELECTBAR_X2 - MENUBOX_SELECTBAR_X1 ) / 2.0f ) + MENUBOX_SELECTBAR_X1;

    // Draw the bitmap items
    m_bitmapItems.MoveTo( 0 );  // Start at the 1st Item
    for( unsigned int x = 0; x < m_bitmapItems.GetNumItems(); ++x )
    {
        m_bitmapItems.GetCurrentNode()->render( pScreen->GetD3DDevicePtr() );
        m_bitmapItems.MoveNext();
    }
    
    // Draw the panel items
    m_panelItems.MoveTo( 0 );  // Start at the 1st Item
    for( x = 0; x < m_panelItems.GetNumItems(); ++x )
    {
        pScreen->DrawBox( m_panelItems.GetCurrentNode()->X1Pos, m_panelItems.GetCurrentNode()->Y1Pos, m_panelItems.GetCurrentNode()->X2Pos, m_panelItems.GetCurrentNode()->Y2Pos, m_panelItems.GetCurrentNode()->color );
        m_panelItems.MoveNext();
    }

    // Draw the line items
    m_lineItems.MoveTo( 0 );  // Start at the 1st Item
    for( x = 0; x < m_lineItems.GetNumItems(); ++x )
    {
        pScreen->DrawLine( m_lineItems.GetCurrentNode()->X1Pos, m_lineItems.GetCurrentNode()->Y1Pos, m_lineItems.GetCurrentNode()->X2Pos, m_lineItems.GetCurrentNode()->Y2Pos, m_lineItems.GetCurrentNode()->width, m_lineItems.GetCurrentNode()->color );
        m_lineItems.MoveNext();
    }

    // Draw the outline items
    m_outlineItems.MoveTo( 0 );  // Start at the 1st Item
    for( x = 0; x < m_outlineItems.GetNumItems(); ++x )
    {
        pScreen->DrawOutline( m_outlineItems.GetCurrentNode()->X1Pos, m_outlineItems.GetCurrentNode()->Y1Pos, m_outlineItems.GetCurrentNode()->X2Pos, m_outlineItems.GetCurrentNode()->Y2Pos, m_outlineItems.GetCurrentNode()->width, m_outlineItems.GetCurrentNode()->color );
        m_outlineItems.MoveNext();
    }

    // Draw the header items
    m_headerItems.MoveTo( 0 );  // Start at the 1st Item
    for( x = 0; x < m_headerItems.GetNumItems(); ++x )
    {
        pScreen->DrawText( m_headerItems.GetCurrentNode()->XPos, m_headerItems.GetCurrentNode()->YPos, m_headerItems.GetCurrentNode()->fgcolor, m_headerItems.GetCurrentNode()->bgcolor, L"%s", m_headerItems.GetCurrentNode()->text );
        m_headerItems.MoveNext();
    } 
    
    // Draw the text items
    m_textItems.MoveTo( NUM_MAX_ENUM + 1 );  // Start at the item past our screen index
    for( x = NUM_MAX_ENUM + 1; x < m_textItems.GetNumItems(); ++x )
    {
        pScreen->DrawText( m_textItems.GetCurrentNode()->XPos, m_textItems.GetCurrentNode()->YPos, m_textItems.GetCurrentNode()->fgcolor, m_textItems.GetCurrentNode()->bgcolor, L"%s", m_textItems.GetCurrentNode()->text );
        m_textItems.MoveNext();
    }

    // Draw a box behind the currently highlighted choice
    float X1Pos = MENUBOX_SELECTBAR_X1;
    float Y1Pos = m_textItems[GetSelectedItem()]->YPos - ITEM_SELECTOR_BORDER_SPACE;
    float X2Pos = MENUBOX_SELECTBAR_X2;
    float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * ITEM_SELECTOR_BORDER_SPACE );

    pScreen->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, ITEM_SELECTOR_COLOR );

    // Load the settings in to our object from the config sector of the
    // XBox
    m_XBoxSettings.LoadSettings();
    
    WCHAR wideString[100];

    // IP Address
    m_textItems.MoveTo( ENUM_IPADDRESS );
    float XPos = fScreenCenter  - ( pScreen->GetStringPixelWidth( m_textItems.GetCurrentNode()->text ) );
    pScreen->DrawText( XPos, m_textItems.GetCurrentNode()->YPos, m_textItems.GetCurrentNode()->fgcolor, m_textItems.GetCurrentNode()->bgcolor, L"%s", m_textItems.GetCurrentNode()->text );

    ZeroMemory( wideString, sizeof( WCHAR ) * 100 );
    XPos = fScreenCenter + 5.0f;

    // If our IP Address is null, display "dhcp" info
    if( '\0' == m_XBoxSettings.GetSetting( XC_ONLINE_IP_ADDRESS )[0] )
    {
        _snwprintf( wideString, 100, L"(use dhcp)" );
    }
    else
    {
        _snwprintf( wideString, 100, L"%S", m_XBoxSettings.GetSetting( XC_ONLINE_IP_ADDRESS ) );
    }
    pScreen->DrawText( XPos, m_textItems.GetCurrentNode()->YPos, COLOR_DARK_GREEN, m_textItems.GetCurrentNode()->bgcolor, L"%s", wideString );

    // Subnet Mask
    m_textItems.MoveTo( ENUM_SUBNETMASK );
    XPos = fScreenCenter - ( pScreen->GetStringPixelWidth( m_textItems.GetCurrentNode()->text ) );
    pScreen->DrawText( XPos, m_textItems.GetCurrentNode()->YPos, m_textItems.GetCurrentNode()->fgcolor, m_textItems.GetCurrentNode()->bgcolor, L"%s", m_textItems.GetCurrentNode()->text );
    
    ZeroMemory( wideString, sizeof( WCHAR ) * 100 );
    XPos = fScreenCenter + 5.0f;
    _snwprintf( wideString, 100, L"%S", m_XBoxSettings.GetSetting( XC_ONLINE_SUBNET_ADDRESS ) );
    pScreen->DrawText( XPos, m_textItems.GetCurrentNode()->YPos, COLOR_DARK_GREEN, m_textItems.GetCurrentNode()->bgcolor, L"%s", wideString );

    // Gateway
    m_textItems.MoveTo( ENUM_GATEWAY );
    XPos = fScreenCenter - ( pScreen->GetStringPixelWidth( m_textItems.GetCurrentNode()->text ) );
    pScreen->DrawText( XPos, m_textItems.GetCurrentNode()->YPos, m_textItems.GetCurrentNode()->fgcolor, m_textItems.GetCurrentNode()->bgcolor, L"%s", m_textItems.GetCurrentNode()->text );

    ZeroMemory( wideString, sizeof( WCHAR ) * 100 );
    XPos = fScreenCenter + 5.0f;
    _snwprintf( wideString, 100, L"%S", m_XBoxSettings.GetSetting( XC_ONLINE_DEFAULT_GATEWAY_ADDRESS ) );
    pScreen->DrawText( XPos, m_textItems.GetCurrentNode()->YPos, COLOR_DARK_GREEN, m_textItems.GetCurrentNode()->bgcolor, L"%s", wideString );

    // Display Settings
    m_textItems.MoveTo( ENUM_DISPLAYSETTING );
    XPos = fScreenCenter - ( pScreen->GetStringPixelWidth( m_textItems.GetCurrentNode()->text ) );
    pScreen->DrawText( XPos, m_textItems.GetCurrentNode()->YPos, m_textItems.GetCurrentNode()->fgcolor, m_textItems.GetCurrentNode()->bgcolor, L"%s", m_textItems.GetCurrentNode()->text );

    ZeroMemory( wideString, sizeof( WCHAR ) * 100 );
    XPos = fScreenCenter + 5.0f;
    _snwprintf( wideString, 100, L"%S", m_XBoxSettings.GetSetting( XC_VIDEO_FLAGS ) );
    pScreen->DrawText( XPos, m_textItems.GetCurrentNode()->YPos, COLOR_DARK_GREEN, m_textItems.GetCurrentNode()->bgcolor, L"%s", wideString );

    // Machine Name
    m_textItems.MoveTo( ENUM_MACHINENAME );
    XPos = fScreenCenter - ( pScreen->GetStringPixelWidth( m_textItems.GetCurrentNode()->text ) );
    pScreen->DrawText( XPos, m_textItems.GetCurrentNode()->YPos, m_textItems.GetCurrentNode()->fgcolor, m_textItems.GetCurrentNode()->bgcolor, L"%s", m_textItems.GetCurrentNode()->text );

    ZeroMemory( wideString, sizeof( WCHAR ) * 100 );
    XPos = fScreenCenter + 5.0f;
    _snwprintf( wideString, 100, L"%S", m_XBoxSettings.GetSetting( XSETTINGS_MACHINE_NAME ) );
    pScreen->DrawText( XPos, m_textItems.GetCurrentNode()->YPos, COLOR_DARK_GREEN, m_textItems.GetCurrentNode()->bgcolor, L"%s", wideString );
}


// Handle any requests for the joystick (thumb-pad)
void CSettingsMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, bool bFirstYPress, bool bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_BOTTOM, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_TOP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    // This is the RIGHT Thumb Joystick on the controller
    case JOYSTICK_RIGHT:
        {
            // Y
            if( nThumbX < 0 ) // Move the right joystick to the left
            {
            }
            else if( nThumbX > 0 ) // Move right joystick to the right
            {
            }
            
            // X
            if( nThumbX < 0 ) // Move the right joystick left
            {
            }
            else if( nThumbX > 0 ) // Move the right joystick right
            {
            }

            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CSettingsMenu::HandleInput( enum CONTROLS controlPressed, bool bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
	case CONTROL_START:
		{
			break;
		}
	case CONTROL_SELECT:
		{
			break;
		}
	case CONTROL_TRIGGER_LEFT:
		{
			break;
		}
	case CONTROL_TRIGGER_RIGHT:
		{
			break;
		}
    case CONTROL_DPAD_TOP:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() > 0 )
                {
                    // Check to see if we are on the display settings
                    // If so, skip over the Subnet Mask and Gateway if our IP Address is NULL
                    if( ENUM_MACHINENAME == GetSelectedItem() )
                    {
                        if( '\0' == m_XBoxSettings.GetSetting( XC_ONLINE_IP_ADDRESS )[0] )
                        {
                            SetSelectedItem( GetSelectedItem() - 3 );
                        }
                        else
                        {
                            SetSelectedItem( GetSelectedItem() - 1 );
                        }
                    }
                    else // Otherwise, just hop to the previous item
                    {
                        SetSelectedItem( GetSelectedItem() - 1 );
                    }
                }
            }
            break;
        }
    case CONTROL_DPAD_BOTTOM:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( ( (unsigned int)GetSelectedItem() + 1 ) < GetNumItems() )
                {
                    // If we have the IP Address highlighted, and it's set to NULL, we
                    // should skip over the Subnet mask and Gateway
                    if( ENUM_IPADDRESS == GetSelectedItem() )
                    {
                        if( '\0' == m_XBoxSettings.GetSetting( XC_ONLINE_IP_ADDRESS )[0] )
                        {
                            SetSelectedItem( GetSelectedItem() + 3 );
                        }
                        else
                        {
                            SetSelectedItem( GetSelectedItem() + 1 );
                        }
                    }
                    else // Otherwise, just hop to the next item
                    {
                        SetSelectedItem( GetSelectedItem() + 1 );
                    }
                }
            }
            break;
        }
    case CONTROL_DPAD_LEFT:
        {
            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CSettingsMenu::HandleInput( enum BUTTONS buttonPressed, bool bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                switch( GetSelectedItem() )
                {
                case ENUM_IPADDRESS:
                    {
                        m_IPMenu.SetAddress( m_XBoxSettings.GetSetting( XC_ONLINE_IP_ADDRESS ) );
                        g_pCurrentScreen = &m_IPMenu;
                        break;                
                    }
                case ENUM_SUBNETMASK:
                    {
                        m_SubnetMenu.SetAddress( m_XBoxSettings.GetSetting( XC_ONLINE_SUBNET_ADDRESS ) );
                        g_pCurrentScreen = &m_SubnetMenu;
                        break;
                    }
                case ENUM_GATEWAY:
                    {
                        m_GatewayMenu.SetAddress( m_XBoxSettings.GetSetting( XC_ONLINE_DEFAULT_GATEWAY_ADDRESS ) );
                        g_pCurrentScreen = &m_GatewayMenu;
                        break;
                    }
                case ENUM_DISPLAYSETTING:
                    {
                        m_DisplaySettingsMenu.SetDisplaySetting( m_XBoxSettings.GetDisplaySettingDW() );
                        g_pCurrentScreen = &m_DisplaySettingsMenu;
                        break;
                    }
                case ENUM_MACHINENAME:
                    {
                        m_MachineNameMenu.SetMachineName( m_XBoxSettings.GetSetting( XSETTINGS_MACHINE_NAME ) );
                        g_pCurrentScreen = &m_MachineNameMenu;
                        break;
                    }
                }
            }
            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                g_pCurrentScreen = GetParent();
            }
            break;
        }
    case BUTTON_C:
        {
            break;
        }
    case BUTTON_D:
        {
            break;
        }
    case BUTTON_E:
        {
            break;
        }
    case BUTTON_F:
        {
            break;
        }
    case BUTTON_7:
        {
            break;
        }
    case BUTTON_8:
        {
            break;
        }
    case BUTTON_9:
        {
            break;
        }
    case BUTTON_10:
        {
            break;
        }
    }
}


// Initialize the Menu
HRESULT CSettingsMenu::Init( CXBoxVideo* pScreen, char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CSettingsMenu::Init()" );

     // Get our XBox Settings
    m_XBoxSettings.Init();

    // Get our screen information
    ImportScreenItems( menuFileName );

    // Get the height of the font
    unsigned int decent;
    pScreen->GetFontSize( &m_uiFontHeightOfItem, &decent );

    // Initialize our IP Menu
    m_IPMenu.Init( pScreen, FILE_DATA_MENU_DIRECTORY_A "\\ip.mnu" );
    m_IPMenu.SetParent( this );
    m_IPMenu.SetSettingsPtr( &m_XBoxSettings );

    // Initialize our Subnet Menu
    m_SubnetMenu.Init( pScreen, FILE_DATA_MENU_DIRECTORY_A "\\subnet.mnu" );
    m_SubnetMenu.SetParent( this );
    m_SubnetMenu.SetSettingsPtr( &m_XBoxSettings );

    // Initialize our Gateway Menu
    m_GatewayMenu.Init( pScreen, FILE_DATA_MENU_DIRECTORY_A "\\gateway.mnu" );
    m_GatewayMenu.SetParent( this );
    m_GatewayMenu.SetSettingsPtr( &m_XBoxSettings );

    // Initialize our Display Settings Menu
    m_DisplaySettingsMenu.Init( pScreen, FILE_DATA_MENU_DIRECTORY_A "\\dispset.mnu" );
    m_DisplaySettingsMenu.SetParent( this );
    m_DisplaySettingsMenu.SetSettingsPtr( &m_XBoxSettings );

    // Initialize our Machine Name Menu
    m_MachineNameMenu.Init( pScreen, FILE_DATA_MENU_DIRECTORY_A "\\machine.mnu" );
    m_MachineNameMenu.SetParent( this );
    m_MachineNameMenu.SetSettingsPtr( &m_XBoxSettings );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\DukeInfo\settingsmenu.h ===
/*****************************************************
*** settingsmenu.h
***
*** Header file for our XShell Settings menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** December 2nd, 2000
***
*****************************************************/

#ifndef _SETTINGSMENU_H_
#define _SETTINGSMENU_H_

enum SettingsValues
{
    ENUM_DISPLAYSETTING = 0,
    ENUM_IPADDRESS,
    ENUM_SUBNETMASK,
    ENUM_GATEWAY,
    ENUM_MACHINENAME
};

#define NUM_MAX_ENUM    ENUM_MACHINENAME   // This should be the highest enum from the list above (SettingsValues)

#include "ipmenu.h"
#include "subnetmenu.h"
#include "gatewaymenu.h"
#include "machinenamemenu.h"
#include "dispsetmenu.h"

class CSettingsMenu : public CMenuScreen
{
public:
    CSettingsMenu();
    CSettingsMenu( CXItem* pParent );
    ~CSettingsMenu();

    // Must be overridden for this to be a Item on our XShell program
    void Action( CXBoxVideo* Screen );
    void HandleInput( enum BUTTONS buttonPressed, bool bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, bool bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, bool bFirstYPress, bool bFirstXPress );

    // Public Methods
    char* GetMachineName() { return m_XBoxSettings.GetSetting( XSETTINGS_MACHINE_NAME ); }; // Get the machine name from the settings object
    HRESULT Init( CXBoxVideo* pScreen, char* menuFileName );                                // Initialize our font and settings

private:
    CXSettings m_XBoxSettings;                      // Settings that are stored on the XBox
    CIPMenu m_IPMenu;                               // IP Menu Object to get input from the user when entering an IP Address
    CSubnetMenu m_SubnetMenu;                       // Subnet Menu Object to get input from the user when entering a Subnet Mask
    CGatewayMenu m_GatewayMenu;                     // Gateway Object to get input from the user when entering a Gateway
    CMachineNameMenu m_MachineNameMenu;             // MachineName Object to get input from the user when entering a Machine Name
    CDisplaySettingsMenu m_DisplaySettingsMenu;     // Display Settings menu Object to get the Display Setting the user wishes
};

#endif // _SETTINGSMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\DukeInfo\menuscreen.cpp ===
/*****************************************************
*** menuscreen.cpp
***
*** CPP file for our XShell Generic menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
*** 
*** by James N. Helm
*** December 1st, 2000
*** 
*****************************************************/

#include "stdafx.h"
#include "menuscreen.h"

extern CXItem* g_pCurrentScreen;  // Pointer to the current menu object
extern USBManager Controllers;    // Used to determine what buttons / direction the user is pressing

// Constructor
CMenuScreen::CMenuScreen()
: CXItem(),
m_nJoystickDeadZone( 0 ),
m_port( 0 ),
m_keyPressDelayTimer( 0 )
{
    XDBGTRC( APP_TITLE_NAME_A, "CMenuScreen::CMenuScreen()" );

    m_textItems.SetDeleteDataItem( true );
    m_panelItems.SetDeleteDataItem( true );
    m_lineItems.SetDeleteDataItem( true );
    m_outlineItems.SetDeleteDataItem( true );
    m_bitmapItems.SetDeleteDataItem( true );
    m_headerItems.SetDeleteDataItem( true );
}


// Constructor
CMenuScreen::CMenuScreen( CXItem* pParent )
: CXItem( pParent ),
m_nJoystickDeadZone( 0 ),
m_port( 0 ),
m_keyPressDelayTimer( 0 )
{
    XDBGTRC( APP_TITLE_NAME_A, "CMenuScreen::CMenuScreen(ex)" );

    m_textItems.SetDeleteDataItem( true );
    m_panelItems.SetDeleteDataItem( true );
    m_lineItems.SetDeleteDataItem( true );
    m_outlineItems.SetDeleteDataItem( true );
    m_bitmapItems.SetDeleteDataItem( true );
    m_headerItems.SetDeleteDataItem( true );
}


// Destructor
CMenuScreen::~CMenuScreen()
{
}


// Draws a menu on to the screen
void CMenuScreen::Action( CXBoxVideo* pScreen )
{
    unsigned int nStringWidth = 0;

    // Draw the bitmap items
    m_bitmapItems.MoveTo( 0 );  // Start at the 1st Item
    for( unsigned int x = 0; x < m_bitmapItems.GetNumItems(); ++x )
    {
        m_bitmapItems.GetCurrentNode()->render( pScreen->GetD3DDevicePtr() );
        m_bitmapItems.MoveNext();
    }
    
    // Draw the panel items
    m_panelItems.MoveTo( 0 );  // Start at the 1st Item
    for( x = 0; x < m_panelItems.GetNumItems(); ++x )
    {
        pScreen->DrawBox( m_panelItems.GetCurrentNode()->X1Pos, m_panelItems.GetCurrentNode()->Y1Pos, m_panelItems.GetCurrentNode()->X2Pos, m_panelItems.GetCurrentNode()->Y2Pos, m_panelItems.GetCurrentNode()->color );
        m_panelItems.MoveNext();
    }

    // Draw the line items
    m_lineItems.MoveTo( 0 );  // Start at the 1st Item
    for( x = 0; x < m_lineItems.GetNumItems(); ++x )
    {
        pScreen->DrawLine( m_lineItems.GetCurrentNode()->X1Pos, m_lineItems.GetCurrentNode()->Y1Pos, m_lineItems.GetCurrentNode()->X2Pos, m_lineItems.GetCurrentNode()->Y2Pos, (float)m_lineItems.GetCurrentNode()->width, m_lineItems.GetCurrentNode()->color );
        m_lineItems.MoveNext();
    }

    // Draw the outline items
    m_outlineItems.MoveTo( 0 );  // Start at the 1st Item
    for( x = 0; x < m_outlineItems.GetNumItems(); ++x )
    {
        pScreen->DrawOutline( m_outlineItems.GetCurrentNode()->X1Pos, m_outlineItems.GetCurrentNode()->Y1Pos, m_outlineItems.GetCurrentNode()->X2Pos, m_outlineItems.GetCurrentNode()->Y2Pos, (float)m_outlineItems.GetCurrentNode()->width, m_outlineItems.GetCurrentNode()->color );
        m_outlineItems.MoveNext();
    }

    // Draw the header items
    m_headerItems.MoveTo( 0 );  // Start at the 1st Item
    for( x = 0; x < m_headerItems.GetNumItems(); ++x )
    {
        pScreen->DrawText( m_headerItems.GetCurrentNode()->XPos, m_headerItems.GetCurrentNode()->YPos, m_headerItems.GetCurrentNode()->fgcolor, m_headerItems.GetCurrentNode()->bgcolor, L"%s", m_headerItems.GetCurrentNode()->text );
        m_headerItems.MoveNext();
    } 
    
    // Draw the text items
    m_textItems.MoveTo( 0 );  // Start at the 1st Item
    for( x = 0; x < m_textItems.GetNumItems(); ++x )
    {
        pScreen->DrawText( m_textItems.GetCurrentNode()->XPos, m_textItems.GetCurrentNode()->YPos, m_textItems.GetCurrentNode()->fgcolor, m_textItems.GetCurrentNode()->bgcolor, L"%s", m_textItems.GetCurrentNode()->text );
        m_textItems.MoveNext();
    }

    // Info on current port
    pScreen->DrawText( 450.0f, 106.0f, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"Port - '%d'", m_port+1 );

    // Get the state of the Input Device
    XINPUT_STATE* pState;
    Controllers.ProcessInput();
    pState = Controllers.GetControllerState( m_port );

    pScreen->DrawText( MENUBOX_TEXTAREA_X1, MENUBOX_TEXTAREA_Y1, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"A Button" );
    pScreen->DrawText( MENUBOX_VALUE_X1,    MENUBOX_TEXTAREA_Y1, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"- '%d'", pState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] );

    pScreen->DrawText( MENUBOX_TEXTAREA_X1, MENUBOX_TEXTAREA_Y1 + ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"B Button" );
    pScreen->DrawText( MENUBOX_VALUE_X1,    MENUBOX_TEXTAREA_Y1 + ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"- '%d'", pState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] );

    pScreen->DrawText( MENUBOX_TEXTAREA_X1, MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 2), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"X Button" );
    pScreen->DrawText( MENUBOX_VALUE_X1,    MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 2), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"- '%d'", pState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] );

    pScreen->DrawText( MENUBOX_TEXTAREA_X1, MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 3), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"Y Button" );
    pScreen->DrawText( MENUBOX_VALUE_X1,    MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 3), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"- '%d'", pState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] );

    pScreen->DrawText( MENUBOX_TEXTAREA_X1, MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 4), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"Black Button" );
    pScreen->DrawText( MENUBOX_VALUE_X1,    MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 4), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"- '%d'", pState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] );

    pScreen->DrawText( MENUBOX_TEXTAREA_X1, MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 5), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"White Button" );
    pScreen->DrawText( MENUBOX_VALUE_X1,    MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 5), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"- '%d'", pState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] );

    pScreen->DrawText( MENUBOX_TEXTAREA_X1, MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 6), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"Left Trigger" );
    pScreen->DrawText( MENUBOX_VALUE_X1,    MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 6), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"- '%d'", pState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] );

    pScreen->DrawText( MENUBOX_TEXTAREA_X1, MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 7), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"Right Trigger" );
    pScreen->DrawText( MENUBOX_VALUE_X1,    MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 7), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"- '%d'", pState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] );

    pScreen->DrawText( MENUBOX_RIGHT_COL_X1,   MENUBOX_TEXTAREA_Y1, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"Left Thumbstick X" );
    pScreen->DrawText( MENUBOX_RIGHT_VALUE_X1, MENUBOX_TEXTAREA_Y1, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"- '%d'", pState->Gamepad.sThumbLX );

    pScreen->DrawText( MENUBOX_RIGHT_COL_X1,   MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 1), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"Left Thumbstick Y" );
    pScreen->DrawText( MENUBOX_RIGHT_VALUE_X1, MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 1), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"- '%d'", pState->Gamepad.sThumbLY );

    pScreen->DrawText( MENUBOX_RIGHT_COL_X1,   MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 2), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"Right Thumbstick X" );
    pScreen->DrawText( MENUBOX_RIGHT_VALUE_X1, MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 2), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"- '%d'", pState->Gamepad.sThumbRX );

    pScreen->DrawText( MENUBOX_RIGHT_COL_X1,   MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 3), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"Right Thumbstick Y" );
    pScreen->DrawText( MENUBOX_RIGHT_VALUE_X1, MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 3), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"- '%d'", pState->Gamepad.sThumbRY );

    pScreen->DrawText( MENUBOX_RIGHT_COL_X1,   MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 4), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"DPad Up" );
    pScreen->DrawText( MENUBOX_RIGHT_VALUE_X1, MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 4), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"- '%d'", !!( pState->Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP ) );

    pScreen->DrawText( MENUBOX_RIGHT_COL_X1,   MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 5), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"DPad Down" );
    pScreen->DrawText( MENUBOX_RIGHT_VALUE_X1, MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 5), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"- '%d'", !!( pState->Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN ) );

    pScreen->DrawText( MENUBOX_RIGHT_COL_X1,   MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 6), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"DPad Left" );
    pScreen->DrawText( MENUBOX_RIGHT_VALUE_X1, MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 6), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"- '%d'", !!( pState->Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT ) );

    pScreen->DrawText( MENUBOX_RIGHT_COL_X1,   MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 7), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"DPad Right" );
    pScreen->DrawText( MENUBOX_RIGHT_VALUE_X1, MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 7), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"- '%d'", !!( pState->Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT ) );

    pScreen->DrawText( MENUBOX_RIGHT_COL_X1,   MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 8), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"Start" );
    pScreen->DrawText( MENUBOX_RIGHT_VALUE_X1, MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 8), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"- '%d'", !!( pState->Gamepad.wButtons & XINPUT_GAMEPAD_START ) );

    pScreen->DrawText( MENUBOX_RIGHT_COL_X1,   MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 9), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"Back" );
    pScreen->DrawText( MENUBOX_RIGHT_VALUE_X1, MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 9), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"- '%d'", !!( pState->Gamepad.wButtons & XINPUT_GAMEPAD_BACK ) );

    pScreen->DrawText( MENUBOX_RIGHT_COL_X1,   MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 10), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"Left Thumb" );
    pScreen->DrawText( MENUBOX_RIGHT_VALUE_X1, MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 10), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"- '%d'", !!( pState->Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_THUMB ) );

    pScreen->DrawText( MENUBOX_RIGHT_COL_X1,   MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 11), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"Right Thumb" );
    pScreen->DrawText( MENUBOX_RIGHT_VALUE_X1, MENUBOX_TEXTAREA_Y1 + ( ( ITEM_SELECTOR_BORDER_SPACE + FONT_DEFAULT_HEIGHT ) * 11), SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"- '%d'", !!( pState->Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_THUMB ) );

    // Check to see if the user wishes to change ports
    if( Controllers.IsControlPressed( PORT_ANY, CONTROL_START ) &&
        Controllers.IsControlPressed( PORT_ANY, CONTROL_BACK ) &&
        Controllers.IsButtonPressed( PORT_ANY, BUTTON_LEFT_TRIGGER ) &&
        Controllers.IsButtonPressed( PORT_ANY, BUTTON_RIGHT_TRIGGER ) )
    {
        if( ( GetTickCount() - m_keyPressDelayTimer ) > KEY_PRESS_DELAY )
        {
          ++m_port;

          if( m_port >= NUM_XBOX_PORTS )
          {
              m_port = 0;
          }

          m_keyPressDelayTimer = GetTickCount();
        }
    }

    // Check to see if the user wishes to reboot back to the shell
    if( Controllers.IsControlPressed( PORT_ANY, CONTROL_LEFT_THUMB ) &&
        Controllers.IsControlPressed( PORT_ANY, CONTROL_RIGHT_THUMB ) &&
        Controllers.IsButtonPressed( PORT_ANY, BUTTON_LEFT_TRIGGER ) &&
        Controllers.IsButtonPressed( PORT_ANY, BUTTON_RIGHT_TRIGGER ) )
    {
        // Boot back to the shell
        XLaunchNewImage( NULL, NULL );
    }
} 


// Add the screen and text of the item that will be drawn on to the screen
// to our object
HRESULT CMenuScreen::ImportScreenItems( char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CMenuScreen::ImportScreenItems()" );

    if( !menuFileName )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMenuScreen::ImportScreenItems():menuFileName not set!!" );
        return E_INVALIDARG;
    }

    FILE* menuFile = fopen( menuFileName, "r" );

    if( !menuFile )
    {
        XDBGERR( APP_TITLE_NAME_A, "CMenuScreen::ImportScreenItems():fopen failed!! - '%s'", menuFileName );
        return E_FAIL;
    }

    HRESULT hr = S_OK;
    WCHAR itemType;
    bool bEOF = false;

    while( !bEOF )
    {
        itemType = fgetwc( menuFile );
        if( feof( menuFile ) )
        {
            bEOF = true;
            continue;
        }

        if( L't' == itemType )
        {
            hr = AddTextItemFromFile( menuFile );
        }
        else if( L'p' == itemType )
        {
            hr = AddPanelItemFromFile( menuFile );
        }
        else if( L'l' == itemType )
        {
            hr = AddLineItemFromFile( menuFile );
        }
        else if( L'h' == itemType )
        {
            hr = AddHeaderItemFromFile( menuFile );
        }
        else if( L'o' == itemType )
        {
            hr = AddOutlineItemFromFile( menuFile );
        }
        else if( L'i' == itemType )
        {
            hr = AddBitmapItemFromFile( menuFile );
        }

        // Move to the next line
        while( itemType = fgetwc( menuFile ) )
        {
            if( feof( menuFile ) )
            {
                bEOF = true;
                break;
            }

            if( 10 == itemType )
            {
                break;
            }
        }

        // Check to see if there was a problem, and return if there was
        if( FAILED( hr ) )
        {
            fclose( menuFile );
            return hr;
        }
    }

    fclose( menuFile );

    return S_OK;
}


// Initialize the Menu
HRESULT CMenuScreen::Init( CXBoxVideo* pScreen, char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CMenuScreen::Init()" );

    // Get our screen information
    ImportScreenItems( menuFileName );
    
    return S_OK;
}


// Add a text item to our current screen from a file
HRESULT CMenuScreen::AddTextItemFromFile( FILE* menuFile )
{
    struct _TEXTITEM* pTextItem = new struct _TEXTITEM;
    if( !pTextItem )
    {
        XDBGERR( APP_TITLE_NAME_A, "CMenuScreen::AddTextItemFromFile():Out of memory!!" );
        return E_OUTOFMEMORY;
    }

    ZeroMemory( pTextItem->text, sizeof( WCHAR ) * SCREEN_ITEM_TEXT_LENGTH );
    
    fscanf( menuFile,   "%f", &(pTextItem->XPos) );
    fscanf( menuFile,   "%f", &(pTextItem->YPos) );
    fscanf( menuFile,   "%X", &(pTextItem->fgcolor) );
    fscanf( menuFile,   "%X", &(pTextItem->bgcolor) );
    fwscanf( menuFile, L"%s",   pTextItem->text );

    XDBGTRC( APP_TITLE_NAME_A, "CMenuScreen::AddTextItemFromFile():\n  XPos: %f\n  YPos: %f\n  fgcol: %X\n  bgcol: %X\n  text: %S", pTextItem->XPos, pTextItem->YPos, pTextItem->fgcolor, pTextItem->bgcolor, pTextItem->text );
    
    WCHAR* pChar;
    while( pChar = wcsstr( pTextItem->text, L"_" ) )
    {
        *pChar = L' ';
    }

    m_textItems.AddNode( pTextItem );

    return S_OK;
}


// Add a panel item to our current screen
HRESULT CMenuScreen::AddPanelItemFromFile( FILE* menuFile )
{
    struct _PANELITEM* pPanelItem = new struct _PANELITEM;
    if( !pPanelItem )
    {
        XDBGERR( APP_TITLE_NAME_A, "CMenuScreen::AddPanelItemFromFile():Out of memory!!" );
        return E_OUTOFMEMORY;
    }

    fscanf( menuFile,   "%f", &(pPanelItem->X1Pos) );
    fscanf( menuFile,   "%f", &(pPanelItem->Y1Pos) );
    fscanf( menuFile,   "%f", &(pPanelItem->X2Pos) );
    fscanf( menuFile,   "%f", &(pPanelItem->Y2Pos) );
    fscanf( menuFile,   "%x", &(pPanelItem->color) );

    XDBGTRC( APP_TITLE_NAME_A, "CMenuScreen::AddPanelItemFromFile():\n  X1Pos: %f\n  Y1Pos: %f\n  X2Pos: %f\n  Y2Pos: %f\n  color: %X", pPanelItem->X1Pos, pPanelItem->Y1Pos, pPanelItem->X2Pos, pPanelItem->Y2Pos, pPanelItem->color );

    m_panelItems.AddNode( pPanelItem );

    return S_OK;
}


// Add a line to our current screen
HRESULT CMenuScreen::AddLineItemFromFile( FILE* menuFile )
{
    struct _PANELITEM* pLineItem = new struct _PANELITEM;
    if( !pLineItem )
    {
        XDBGERR( APP_TITLE_NAME_A, "CMenuScreen::AddLineItemFromFile():Out of memory!!" );
        return E_OUTOFMEMORY;
    }

    fscanf( menuFile,   "%f", &(pLineItem->X1Pos) );
    fscanf( menuFile,   "%f", &(pLineItem->Y1Pos) );
    fscanf( menuFile,   "%f", &(pLineItem->X2Pos) );
    fscanf( menuFile,   "%f", &(pLineItem->Y2Pos) );
    fscanf( menuFile,   "%d", &(pLineItem->width) );
    fscanf( menuFile,   "%x", &(pLineItem->color) );

    XDBGTRC( APP_TITLE_NAME_A, "CMenuScreen::AddLineItemFromFile():\n  X1Pos: %f\n  Y1Pos: %f\n  X2Pos: %f\n  Y2Pos: %f\n  width: %d\n  color: %X", pLineItem->X1Pos, pLineItem->Y1Pos, pLineItem->X2Pos, pLineItem->Y2Pos, pLineItem->width, pLineItem->color );

    m_lineItems.AddNode( pLineItem );

    return S_OK;
}


// Add a line to our current screen
HRESULT CMenuScreen::AddOutlineItemFromFile( FILE* menuFile )
{
    struct _PANELITEM* pLineItem = new struct _PANELITEM;
    if( !pLineItem )
    {
        XDBGERR( APP_TITLE_NAME_A, "CMenuScreen::AddOutlineItemFromFile():Out of memory!!" );
        return E_OUTOFMEMORY;
    }

    fscanf( menuFile,   "%f", &(pLineItem->X1Pos) );
    fscanf( menuFile,   "%f", &(pLineItem->Y1Pos) );
    fscanf( menuFile,   "%f", &(pLineItem->X2Pos) );
    fscanf( menuFile,   "%f", &(pLineItem->Y2Pos) );
    fscanf( menuFile,   "%d", &(pLineItem->width) );
    fscanf( menuFile,   "%x", &(pLineItem->color) );

    XDBGTRC( APP_TITLE_NAME_A, "CMenuScreen::AddOutlineItemFromFile():\n  X1Pos: %f\n  Y1Pos: %f\n  X2Pos: %f\n  Y2Pos: %f\n  width: %d\n  color: %X", pLineItem->X1Pos, pLineItem->Y1Pos, pLineItem->X2Pos, pLineItem->Y2Pos, pLineItem->width, pLineItem->color );

    m_outlineItems.AddNode( pLineItem );

    return S_OK;
}


// Add a Bitmap Item to our Screen from a file
HRESULT CMenuScreen::AddBitmapItemFromFile( FILE* menuFile )
{
    BitmapFile* pBitmapItem = new BitmapFile;
    if( !pBitmapItem )
    {
        XDBGERR( APP_TITLE_NAME_A, "CMenuScreen::AddBitmapItemFromFile():Out of memory!!" );
        return E_OUTOFMEMORY;
    }

    int x, y;
    char filename[MAX_PATH];
    char imagename[MAX_PATH];
    ZeroMemory( filename, MAX_PATH );
    ZeroMemory( imagename, MAX_PATH );

    fscanf( menuFile,   "%d", &x );
    fscanf( menuFile,   "%d", &y );
    fscanf( menuFile,   "%s", imagename );

    _snprintf( filename, MAX_PATH, "%s\\%s", FILE_DATA_IMAGE_DIRECTORY_A, imagename );

    pBitmapItem->read( x, y, filename );

    XDBGTRC( APP_TITLE_NAME_A, "CMenuScreen::AddBitmapItemFromFile():\n  XPos: %d\n  YPos: %d\n  Bitmap: %s", x, y, filename );

    m_bitmapItems.AddNode( pBitmapItem );

    return S_OK;

}

// Add a panel item to our current screen
HRESULT CMenuScreen::AddHeaderItemFromFile( FILE* menuFile )
{
    struct _TEXTITEM* pHeaderItem = new struct _TEXTITEM;
    if( !pHeaderItem )
    {
        XDBGERR( APP_TITLE_NAME_A, "CMenuScreen::AddHeaderItemFromFile():Out of memory!!" );
        return E_OUTOFMEMORY;
    }

    ZeroMemory( pHeaderItem->text, sizeof( WCHAR ) * SCREEN_ITEM_TEXT_LENGTH );
    
    fscanf( menuFile,   "%f", &(pHeaderItem->XPos) );
    fscanf( menuFile,   "%f", &(pHeaderItem->YPos) );
    fscanf( menuFile,   "%X", &(pHeaderItem->fgcolor) );
    fscanf( menuFile,   "%X", &(pHeaderItem->bgcolor) );
    fwscanf( menuFile, L"%s",   pHeaderItem->text );

    XDBGTRC( APP_TITLE_NAME_A, "CMenuScreen::AddHeaderItemFromFile():\n  XPos: %f\n  YPos: %f\n  fgcol: %X\n  bgcol: %X\n  text: %S", pHeaderItem->XPos, pHeaderItem->YPos, pHeaderItem->fgcolor, pHeaderItem->bgcolor, pHeaderItem->text );
    
    WCHAR* pChar;
    while( pChar = wcsstr( pHeaderItem->text, L"_" ) )
    {
        *pChar = L' ';
    }

    m_headerItems.AddNode( pHeaderItem );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\DukeInfo\menuscreen.h ===
/*****************************************************
*** menuscreen.h
***
*** Header file for our XShell Generic menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** December 1st , 2000
***
*****************************************************/

#ifndef _MENUSCREEN_H_
#define _MENUSCREEN_H_

#include "imagefile.h"

class CMenuScreen : public CXItem
{
public:
    // Constructors and Destructors
    CMenuScreen();
    CMenuScreen( CXItem* pParent );
    ~CMenuScreen();

    // Must be overridden for this to be a Item on our XShell program
    virtual void Action( CXBoxVideo* Screen );

    // Public Methods
    virtual HRESULT      Init( CXBoxVideo* pScreen, char* menuFileName );               // Initialize the Menu

protected:
    struct _TEXTITEM
    {
        WCHAR text[SCREEN_ITEM_TEXT_LENGTH];
        float XPos;
        float YPos;
        DWORD fgcolor;
        DWORD bgcolor;
    };

    struct _PANELITEM
    {
        float X1Pos;
        float Y1Pos;
        float X2Pos;
        float Y2Pos;
        unsigned int width;
        DWORD color;
    };

    CLinkedList< struct _TEXTITEM* >  m_textItems;      // Text items that appear on our screen (can be selected)
    CLinkedList< struct _TEXTITEM* >  m_headerItems;    // Header items that appear on our screen (cannot be selected)
    CLinkedList< struct _PANELITEM* > m_panelItems;     // Panel items that appear on our screen
    CLinkedList< struct _PANELITEM* > m_lineItems;      // Lines that appear on our screen
    CLinkedList< struct _PANELITEM* > m_outlineItems;   // Out-line boxes that appear on our screen
    CLinkedList< BitmapFile* >        m_bitmapItems;    // Bitmap image items that appear on our screen

    int            m_nJoystickDeadZone;                 // The dead zone for the joysticks
    int            m_port;                              // The current port the user is viewing
    DWORD          m_keyPressDelayTimer;                // Used to control rapid port changes

    // Methods
    virtual HRESULT ImportScreenItems( char* menuFileName );    // Add item info to the current screen

    virtual HRESULT AddTextItemFromFile( FILE* menuFile );      // Add a Text Item to our Screen from a file
    virtual HRESULT AddPanelItemFromFile( FILE* menuFile );     // Add a Panel Item to our Screen from a file
    virtual HRESULT AddHeaderItemFromFile( FILE* menuFile );    // Add a Header Item to our Screen from a file
    virtual HRESULT AddLineItemFromFile( FILE* menuFile );      // Add a Line Item to our Screen from a file
    virtual HRESULT AddOutlineItemFromFile( FILE* menuFile );   // Add a Outline Item to our Screen from a file
    virtual HRESULT AddBitmapItemFromFile( FILE* menuFile );    // Add a Bitmap Item to our Screen from a file
};

#endif // _MENUSCREEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\DukeInfo\usbmanager.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.h

Abstract:


Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created
    11-01-2000  Modified JNH -- Removed uneeded launcher and socket code

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == _XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#ifndef _USBMANAGER_H_
#define _USBMANAGER_H_

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define BREAK_INTO_DEBUGGER     _asm { int 3 }

// Buttons
enum BUTTONS
{
    BUTTON_MIN = 0,
    BUTTON_A = 0,
    BUTTON_B,
    BUTTON_X,
    BUTTON_Y,
    BUTTON_BLACK,
    BUTTON_WHITE,
    BUTTON_LEFT_TRIGGER,
    BUTTON_RIGHT_TRIGGER,

    BUTTON_MAX
};

enum CONTROLS
{
    CONTROL_MIN = 0,
    CONTROL_DPAD_UP = 0,
    CONTROL_DPAD_DOWN,
    CONTROL_DPAD_LEFT,
    CONTROL_DPAD_RIGHT,
	CONTROL_START,
	CONTROL_BACK,
	CONTROL_LEFT_THUMB,
	CONTROL_RIGHT_THUMB,

    CONTROL_MAX
};

// Ports
enum PORTS
{
    PORT_ANY = -1,
    PORT_MIN = 0,
    PORT_1 = 0,
    PORT_2,
    PORT_3,
    PORT_4,

    PORT_MAX
};

// Joysticks
enum JOYSTICK
{
    JOYSTICK_ANY = -1,
    JOYSTICK_MIN = 0,
    JOYSTICK_LEFT = 0,
    JOYSTICK_RIGHT,

    JOYSTICK_MAX
};

// Parameters
#define FALSE_ON_REPEAT     true
#define TRUE_ON_REPEAT      false

enum
{
    SLOT_CONTROLLER = 0,
    SLOT_TOP,
    SLOT_BOTTOM,
    
    SLOT_MAX
};

class CControllerState
{
public:
    // Constructors and Destructors
    CControllerState()
    {
        for( unsigned int port = 0; port < NUM_XBOX_PORTS; ++port )
        {
            for( unsigned int button = 0; button < NUM_DUKE_BUTTONS; ++button )
            {
                nButtonPress[port][button] = 0;
            }

            for( unsigned int control = 0; control < NUM_DUKE_CONTROLS; ++control )
            {
                bControlPressed[port][control] = false;
            }

            for( unsigned int joystick = 0; joystick < JOYSTICK_MAX; ++joystick )
            {
                sThumbX[port][joystick] = 0;
                sThumbY[port][joystick] = 0;
            }

            dwControllerState[port] = 0;
        }
    };
    
    ~CControllerState(){};

    // Public Properties
    BYTE nButtonPress[NUM_XBOX_PORTS][NUM_DUKE_BUTTONS];
	bool bControlPressed[NUM_XBOX_PORTS][CONTROL_MAX];
    SHORT sThumbX[NUM_XBOX_PORTS][JOYSTICK_MAX];
    SHORT sThumbY[NUM_XBOX_PORTS][JOYSTICK_MAX];
    DWORD dwControllerState[NUM_XBOX_PORTS];
private:
};

class USBDevice
{
public:
    PXPP_DEVICE_TYPE type; // XDEVICE type

public:
    USBDevice()
    {
        type = NULL;
    }
    
    ~USBDevice()
    {
        type = NULL;
    }

public:
    virtual void Insert( unsigned port, unsigned slot ) = 0;
    virtual void Remove( void ) = 0;
};

class DeviceDuke : public USBDevice
{
public:
    HANDLE duke;
    XINPUT_POLLING_PARAMETERS *pollingParameters;

public:
    DeviceDuke()
    {
        type = XDEVICE_TYPE_GAMEPAD;
        pollingParameters = NULL;
        duke = NULL;
    }

    DeviceDuke( unsigned port, unsigned slot, XINPUT_POLLING_PARAMETERS *p )
    {
        type = XDEVICE_TYPE_GAMEPAD;
        pollingParameters = p;
        duke = NULL;
        Insert( port, slot );
    }

    ~DeviceDuke()
    {
        if( duke )
        {
            Remove();
        }
    }

public:
    void Insert( unsigned port, unsigned slot )
    {
        duke = XInputOpen( XDEVICE_TYPE_GAMEPAD, port, 0, pollingParameters );
    }

    void Remove( void )
    {
        XInputClose( duke );
        duke = 0;
    }
};


class USBManager
{
public:
    USBDevice *devices[XGetPortCount()][SLOT_MAX];
    DWORD packetNum[XGetPortCount()][SLOT_MAX];
    XINPUT_POLLING_PARAMETERS pollingParameters;

public:
    USBManager();
    ~USBManager();

public:
    // Calling this will update the controller state objects with the latest info
    void ProcessInput( void );

    // Calling this will check to see if controllers we added or removed
    void CheckForHotplugs( void );

    // This will allow you to determine if a button is 'depressed'.  If an address to a boolean
    // variable is provided, it will return whether or not it's the 'first' press of the button
    bool IsButtonPressed( int port, enum BUTTONS button, int nThreshold=0, bool* bFirstPress=NULL );
    
    // This will allow you to determine if a control is 'depressed'.  If an address to a boolean
    // variable is provided, it will return whether or not it's the 'first' press of the control
    bool IsControlPressed( int port, enum CONTROLS control, bool* bFirstPress=NULL );

    // This will allow you to get the value of the X or Y axis, adjusting for a "dead zone".
    // If a dead zone is passed in, the call will return '0' unless the value of the X or Y axis
    // is greater than the dead zone value.  If an address to a boolean variable is provided, it
    // will return whether or not it's the 'first' press of the joystick
    int  GetJoystickX( int port, enum JOYSTICK, int deadZone=0, bool* bFirstPress=NULL );
    int  GetJoystickY( int port, enum JOYSTICK, int deadZone=0, bool* bFirstPress=NULL );

    // This will allow you to get the raw information for a controller at a specified port
    XINPUT_STATE* GetControllerState( int port );

    // Calling this will determine if there was movement for any item on a controller
    // Will return true if any button or thumbstick has changed since last poll
    bool MovementDetected( int port, int deadZone=0 );

private:
    CControllerState m_ControllerState;
    CControllerState m_PrevControllerState;
    XINPUT_STATE m_DukeState[NUM_XBOX_PORTS];   // Used to hold information regarding XBox Controller States
};

#endif // _USBMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\DukeInfo\usbmanager.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.cpp

Abstract:


Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created
    01-13-2000  Modified   JNH

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#include "stdafx.h"
#include "usbmanager.h"

DWORD XIDMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
};


DWORD XMUMasks[] = {
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_TOP_MASK,
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT3_BOTTOM_MASK
};


USBManager::USBManager()
{
    XDBGWRN( APP_TITLE_NAME_A, "USBManager::USBManager()" );
    
    DWORD insertions, insertions2;
    unsigned i, j;
    unsigned port, slot;

    //Initialize core peripheral port support
    XInitDevices(0,NULL);

    pollingParameters.fAutoPoll = 1;
    pollingParameters.fInterruptOut = 0;
    pollingParameters.ReservedMBZ1 = 0;
    pollingParameters.bInputInterval = 8;  
    pollingParameters.bOutputInterval = 8;
    pollingParameters.ReservedMBZ2 = 0;

    // make sure the usb schema has not changed on us
    // ASSERT(ARRAYSIZE(XIDMasks) == XGetPortCount());
    if( ARRAYSIZE( XIDMasks ) != XGetPortCount() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "USBManager::USBManager():XIDMasks != XGetPortCount!" );
        XDBGWRN( APP_TITLE_NAME_A, "USBManager::USBManager():Will break in to debugger in 60 seconds..." );

        Sleep( 60000 );
        BREAK_INTO_DEBUGGER;
    }
    
    // initialize
    for(i=0; i<XGetPortCount(); i++)
    {
        for(j=0; j<SLOT_MAX; j++)
        {
            devices[i][j] = NULL;
            packetNum[i][j] = 1234;
        }

        memset( &m_DukeState[i], 0, sizeof( m_DukeState[i] ) );
    }

    // look for game pads
    insertions = XGetDevices(XDEVICE_TYPE_GAMEPAD);
    for(i=0; i<XGetPortCount(); i++)
    {
        port = i%XGetPortCount();
        if(insertions & XIDMasks[i])
        {
            devices[i][0] = new DeviceDuke(port, 0, &pollingParameters); 
        }
    }
}


USBManager::~USBManager()
{
    unsigned i, j;

    for(i=0; i<XGetPortCount(); i++)
    {
        for(j=0; j<SLOT_MAX; j++)
        {
            if(devices[i][j] != NULL)
            {
                if( XDEVICE_TYPE_GAMEPAD == devices[i][j]->type )
                {
                    delete (DeviceDuke*)devices[i][j];
                }

                devices[i][j] = NULL;
            }
        }
    }
}


void USBManager::CheckForHotplugs( void )
{
    DWORD addDuke, removeDuke;
    unsigned slot, port;
    unsigned i, j;

    // check for game controllers (insert & removal)
    XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &addDuke, &removeDuke );

    for( i=0; i < XGetPortCount(); i++ )
    {
        port = i % XGetPortCount();
        
        if( removeDuke & XIDMasks[i] )
        {
            delete (DeviceDuke*)devices[i][0];
            devices[i][0] = NULL;
        }

        if( addDuke & XIDMasks[i] )
        {
            devices[i][0] = new DeviceDuke( port, 0, &pollingParameters );
        }
    }
}


// Returns the state of a controller at the specified port
XINPUT_STATE* USBManager::GetControllerState( int port )
{
    if( ( port < 0 ) || ( port >= NUM_XBOX_PORTS ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "USBManager::GetControllerState():Invalid port requested!! - '%d'", port );
        return NULL;
    }
    
    return &m_DukeState[port];
}


bool USBManager::IsControlPressed( int port, enum CONTROLS control, bool* bFirstPress /*=NULL*/)
{
    // Make sure we have a duke at the current location, otherwise return false
    if( port != PORT_ANY )
    {
        if( devices[port][SLOT_CONTROLLER] == NULL )
        {
            return false;
        }
    }

    // Check to see if the user wants to find out for ANY port
    if( port == PORT_ANY )
    {
        for( unsigned int locPort = 0; locPort < NUM_XBOX_PORTS; ++locPort )
        {
            // If there is no Duke at the current port, skip over it
            if( devices[locPort][SLOT_CONTROLLER] == NULL )
            {
                continue;
            }

            if( m_ControllerState.bControlPressed[locPort][control] )
            {
                // If the user gave us a valid address let's return
                // whether or not it's the first press of the item
                if( bFirstPress)
                {
                    // If the previous X value was also greater than the deadZone, return
                    // false for bFirstPress
                    if( m_PrevControllerState.bControlPressed[locPort][control] )
                    {
                        *bFirstPress = false;
                    }
                    else // This must be the first press
                    {
                        *bFirstPress = true;
                    }
                }

                // Return the value of the control
                // This is always true
                return m_ControllerState.bControlPressed[locPort][control];
            }
        }
    }
    else // Only check one port
    {
        if( m_ControllerState.bControlPressed[port][control] )
        {
            // If the user gave us a valid address let's return
            // whether or not it's the first press of the item
            if( bFirstPress)
            {
                // If the previous X value was also greater than the deadZone, return
                // false for bFirstPress
                if( m_PrevControllerState.bControlPressed[port][control] )
                {
                    *bFirstPress = false;
                }
                else // This must be the first press
                {
                    *bFirstPress = true;
                }
            }

            // Return the value of the control
            // This is always true
            return m_ControllerState.bControlPressed[port][control];
        }
    }

    // If the button wasn't pressed, let's return false
    return false;
}


// Will return true if any button or thumbstick has changed since last poll
bool USBManager::MovementDetected( int port, int deadZone /*=0*/ )
{
    if( port != PORT_ANY )
    {
        if( devices[port][SLOT_CONTROLLER] == NULL )
        {
            return false;
        }
    }

    XINPUT_STATE state;
    memset( &state, 0, sizeof( XINPUT_STATE ) );

    // Check to see if the user wants to find out for ANY port
    if( port == PORT_ANY )
    {
        for( unsigned int x = 0; x < NUM_XBOX_PORTS; ++x )
        {
            if( devices[x][0] == NULL )
            {
                continue;
            }

            // Get the state of the current controller
            XInputGetState( ( (DeviceDuke*)devices[x][0] )->duke, &state );

            // Check the buttons
            for( unsigned button = 0; button < BUTTON_MAX; ++button )
            {
                if( IsButtonPressed( x, (enum BUTTONS)button, TRUE_ON_REPEAT ) )
                {
                    return true;
                }
            }

            // Check the controls
            for( unsigned control = 0; control < CONTROL_MAX; ++control )
            {
                if( IsControlPressed( x, (enum CONTROLS)control, TRUE_ON_REPEAT ) )
                {
                    return true;
                }
            }

            // Check the Joysticks
            for( unsigned joystick = 0; joystick < JOYSTICK_MAX; ++joystick )
            {
                if( 0 != GetJoystickX( x, (enum JOYSTICK)joystick, TRUE_ON_REPEAT ) )
                {
                    return true;
                }

                if( 0 != GetJoystickY( x, (enum JOYSTICK)joystick, TRUE_ON_REPEAT ) )
                {
                    return true;
                }
            }
        }
    }
    else // Only one port
    {
        // Get the state of the current controller
        XInputGetState( ( (DeviceDuke*)devices[port][0])->duke, &state);

        // Check the buttons
        for( unsigned button = 0; button < BUTTON_MAX; ++button)
        {
            if( IsButtonPressed( port, (enum BUTTONS)button, TRUE_ON_REPEAT ) )
            {
                return true;
            }
        }

        // Check the controls
        for( unsigned control = 0; control < CONTROL_MAX; ++control)
        {
            if( IsControlPressed( port, (enum CONTROLS)control, TRUE_ON_REPEAT ) )
            {
                return true;
            }
        }

        // Check the Joysticks
        for( unsigned joystick = 0; joystick < JOYSTICK_MAX; ++joystick )
        {
            if( 0 != GetJoystickX( port, (enum JOYSTICK)joystick, TRUE_ON_REPEAT ) )
            {
                return true;
            }

            if( 0 != GetJoystickY( port, (enum JOYSTICK)joystick, TRUE_ON_REPEAT ) )
            {
                return true;
            }
        }
    }

    return false;
}


// Will return the X value of the joystick passed in
int USBManager::GetJoystickX( int port, enum JOYSTICK joystick, int deadZone /*=0*/, bool* bFirstPress /*=NULL*/ )
{
    // Make sure we have a duke at the current location, otherwise return 0
    if( port != PORT_ANY )
    {
        if( devices[port][SLOT_CONTROLLER] == NULL )
        {
            return 0;
        }
    }

    int nReturnVal = 0;

    // Check to see if the user wants to find out for ANY port
    if( port == PORT_ANY )
    {
        for( unsigned int locPort = 0; locPort < NUM_XBOX_PORTS; ++locPort )
        {
            // If there is no Duke in this port, skip to the next port
            if( devices[locPort][SLOT_CONTROLLER] == NULL )
            {
                continue;
            }

            // If the current stick is moved, process the request and return the value!
            if( abs( m_ControllerState.sThumbX[locPort][joystick] ) > deadZone )
            {
                // Determine if the user wishes to know if this is the first time the joystick
                // pressed, or if it's a repeat press
                if( bFirstPress)
                {
                    // If the previous Y value was also greater than the deadZone, return
                    // false for bFirstPress
                    if( abs( m_PrevControllerState.sThumbX[locPort][joystick] ) > deadZone )
                    {
                        *bFirstPress = false;
                    }
                    else // This must be the first press
                    {
                        *bFirstPress = true;
                    }
                }

                // Return the value we got from the joystick
                return m_ControllerState.sThumbX[locPort][joystick];
            }
        }
    }
    else    // Check one port only
    {
        // If the current stick is moved, process the request and return the value!
        if( abs( m_ControllerState.sThumbX[port][joystick] ) > deadZone )
        {
            // Determine if the user wishes to know if this is the first time the joystick
            // pressed, or if it's a repeat press
            if( bFirstPress)
            {
                // If the previous X value was also greater than the deadZone, return
                // false for bFirstPress
                if( abs( m_PrevControllerState.sThumbX[port][joystick] ) > deadZone )
                {
                    *bFirstPress = false;
                }
                else // This must be the first press
                {
                    *bFirstPress = true;
                }
            }

            // Return the value we got from the joystick
            return m_ControllerState.sThumbX[port][joystick];
        }
    }

    // Return 0 if the joystick was not pushed past the dead zone
    return 0;
}


// Will return the Y value of the joystick passed in
int USBManager::GetJoystickY( int port, enum JOYSTICK joystick, int deadZone /*=0*/, bool* bFirstPress /*=NULL*/ )
{
    // Make sure we have a duke at the current location, otherwise return 0
    if( port != PORT_ANY )
    {
        if( devices[port][SLOT_CONTROLLER] == NULL )
        {
            return 0;
        }
    }

    int nReturnVal = 0;

    // Check to see if the user wants to find out for ANY port
    if( port == PORT_ANY )
    {
        for( unsigned int locPort = 0; locPort < NUM_XBOX_PORTS; ++locPort )
        {
            // If there is no Duke in this port, skip to the next port
            if( devices[locPort][SLOT_CONTROLLER] == NULL )
            {
                continue;
            }

            // If the current stick is moved, process the request and return the value!
            if( abs( m_ControllerState.sThumbY[locPort][joystick] ) > deadZone )
            {
                // Determine if the user wishes to know if this is the first time the joystick
                // pressed, or if it's a repeat press
                if( bFirstPress)
                {
                    // If the previous Y value was also greater than the deadZone, return
                    // false for bFirstPress
                    if( abs( m_PrevControllerState.sThumbY[locPort][joystick] ) > deadZone )
                    {
                        *bFirstPress = false;
                    }
                    else // This must be the first press
                    {
                        *bFirstPress = true;
                    }
                }

                // Return the value we got from the joystick
                return m_ControllerState.sThumbY[locPort][joystick];
            }
        }
    }
    else    // Check one port only
    {
        // If the current stick is moved, process the request and return the value!
        if( abs( m_ControllerState.sThumbY[port][joystick] ) > deadZone )
        {
            // Determine if the user wishes to know if this is the first time the joystick
            // pressed, or if it's a repeat press
            if( bFirstPress)
            {
                // If the previous Y value was also greater than the deadZone, return
                // false for bFirstPress
                if( abs( m_PrevControllerState.sThumbY[port][joystick] ) > deadZone )
                {
                    *bFirstPress = false;
                }
                else // This must be the first press
                {
                    *bFirstPress = true;
                }
            }

            // Return the value we got from the joystick
            return m_ControllerState.sThumbY[port][joystick];
        }
    }

    // Return 0 if the joystick was not pushed past the dead zone
    return 0;
}


// Will return TRUE if a button is depressed, or FALSE if it is not
bool USBManager::IsButtonPressed( int port, enum BUTTONS button, int nThreshold /*=0*/, bool* bFirstPress /*=NULL*/ )
{
    // Make sure we have a duke at the current location, otherwise return false
    if( port != PORT_ANY )
    {
        if( devices[port][SLOT_CONTROLLER] == NULL )
        {
            return false;
        }
    }

    // Check to see if the user wants to find out for ANY port
    if( port == PORT_ANY )
    {
        for( unsigned int locPort = 0; locPort < NUM_XBOX_PORTS; ++locPort )
        {
            // If there is no Duke in this port, skip to the next port
            if( devices[locPort][SLOT_CONTROLLER] == NULL )
            {
                continue;
            }

            // If the button is depressed, determine if the user wishes to know
            // if it's a repeat press
            if( m_ControllerState.nButtonPress[locPort][button] > nThreshold )
            {
                // If the user gave us the address of a boolean variable, we should return to them
                // whether or not this is the first time the button was pressed, or if it's a repeat
                // press
                if( bFirstPress )
                {
                    // If in the previous state the button was pressed, return 'false' for bFirstPress
                    if( m_PrevControllerState.nButtonPress[locPort][button] > nThreshold )
                    {
                        *bFirstPress = false;
                    }
                    else // Otherwise, if the Prev value was false, we need to notify the user it's the first press
                    {
                        *bFirstPress = true;
                    }
                }

                // Since a button was pressed, return early out of our loop
                return true;
            }
        }
    }
    else    // Check one port only
    {
        if( m_ControllerState.nButtonPress[port][button] > nThreshold )
        {
            // If the user gave us the address of a boolean variable, we should return to them
            // whether or not this is the first time the button was pressed, or if it's a repeat
            // press
            if( bFirstPress )
            {
                // If in the previous state the button was pressed, return 'false' for bFirstPress
                if( m_PrevControllerState.nButtonPress[port][button] > nThreshold )
                {
                    *bFirstPress = false;
                }
                else // Otherwise, if the Prev value was false, we need to notify the user it's the first press
                {
                    *bFirstPress = true;
                }
            }
        }

        // Return the value of the button
        // This can be 'true' or 'false'
        return !!m_ControllerState.nButtonPress[port][button];
    }

    // If no button was pressed, let's return false;
    return false;
}

void USBManager::ProcessInput( void )
{
    // Store the previous state
    m_PrevControllerState = m_ControllerState;

    // Check to see if any devices were added or removed
    CheckForHotplugs();

    for( unsigned int port = 0; port < NUM_XBOX_PORTS; ++port )
    {
        memset( &m_DukeState[port], 0, sizeof( m_DukeState[port] ) );

        // Make sure a duke is plugged in
        if( devices[port][SLOT_CONTROLLER] == NULL )
        {
            continue;
        }

        XInputGetState( ( (DeviceDuke*)devices[port][SLOT_CONTROLLER] )->duke, &m_DukeState[port] );

        // Packet Number
        m_ControllerState.dwControllerState[port] = m_DukeState[port].dwPacketNumber;

        // Check the buttons
        for( unsigned button = 0; button < BUTTON_MAX; ++button)
        {
            m_ControllerState.nButtonPress[port][button] = m_DukeState[port].Gamepad.bAnalogButtons[button];
        }

        // Check the controls
        for( unsigned control = 0; control < CONTROL_MAX; ++control)
        {
            m_ControllerState.bControlPressed[port][control] = !!( m_DukeState[port].Gamepad.wButtons & ( 1 << control ) );
        }

        // Check the Joysticks
        for( unsigned joystick = 0; joystick < JOYSTICK_MAX; ++joystick )
        {
            m_ControllerState.sThumbX[port][joystick] = m_DukeState[port].Gamepad.sThumbLX;
            m_ControllerState.sThumbY[port][joystick] = m_DukeState[port].Gamepad.sThumbLY;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\DukeInfo\xitem.h ===
/*****************************************************
*** xitem.h
***
*** Header file for our abstract base class for a
*** generic screen of our XDash Config program.
***
*** by James N. Helm
*** November 2nd, 2000
***
*****************************************************/

#ifndef _XDCITEM_H_
#define _XDCITEM_H_

class CXItem
{
public:
    // Constructors and Destructors
    CXItem();
    CXItem( CXItem* pParent );
    ~CXItem();

    // Function that MUST be overridden
    virtual void Action( CXBoxVideo* Screen ) = 0;

    virtual CXItem* GetParent() const { return m_pParent; };

    virtual void SetParent( CXItem* pParent ) { m_pParent = pParent; };

private:
    CXItem* m_pParent;              // Pointer to the parent screen of this item
};

#endif // _XDCITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\DukeInfo\xitem.cpp ===
/*****************************************************
*** xitem.cpp
***
*** CPP file for our abstract base class for a
*** generic screen of our XDash Config program.
*** 
*** by James N. Helm
*** November 2nd, 2000
***
*** Modified 12/03/2000
***   by James N. Helm for XShell
*** 
*****************************************************/

#include "stdafx.h"
#include "xitem.h"

// Constructor
CXItem::CXItem() :
m_pParent( NULL )
{
};


CXItem::CXItem( CXItem* pParent ) :
m_pParent( NULL )
{
    SetParent( pParent );
};

// Destructor
CXItem::~CXItem()
{ 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\DukeInfo\xboxvideo.cpp ===
/*****************************************************
*** xboxvideo.cpp
***
*** CPP file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#include "stdafx.h"
#include "xboxvideo.h"

// Constructor
CXBoxVideo::CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::CXBoxVideo()" );

    m_Device = NULL;
    m_BackBuffer = NULL;
    m_VertexBuffer = NULL;

    // Font properties
    m_Font = NULL;
    m_FontWidth = FONT_DEFAULT_WIDTH;
    m_FontHeight = FONT_DEFAULT_HEIGHT;
    m_FontColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
    m_FontBgColor = SCREEN_DEFAULT_TEXT_BG_COLOR;

    m_ScreenWidth = SCREEN_WIDTH;       // Default the screen width to 640
    m_ScreenHeight = SCREEN_HEIGHT;     // Default the screen height to 480
}

// Destructor
CXBoxVideo::~CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::~CXBoxVideo()" );

    if( m_Device )
    {
        m_Device->Release();
        m_Device = NULL;
    }
    
    if( m_BackBuffer )
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_VertexBuffer )
    {
        m_VertexBuffer->Release();
        m_VertexBuffer = NULL;
    }
}

// Clear the screen
void CXBoxVideo::ClearScreen( DWORD color )
{
    if( FAILED( m_Device->Clear( 0, NULL, D3DCLEAR_TARGET, color, 1.0f, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXboxVideo::ClearScreen():Failed to clear the screen!!" );
    }
}


// Draw the inputed bit array to the screen
//
// Parameters:
//      fx - the upper left x coordinate on screen
//      fy - the upper left y coordinate on screen
//      ulWidth - the width of the bitmap
//      ulHeight - the height of the bitmap
//      pData - a pointer to the array of pixel values
void CXBoxVideo::DrawBitBlt( float fx, float fy, ULONG ulWidth, ULONG ulHeight, const DWORD* pData )
{
    // Check to make sure we received a valid pointer
    if( !pData )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawBitBlt():pData not a valid pointer!" );

        return;
    }

    // Draw the bitmap on the screen, pixel by pixel
	for ( ULONG y = 0; y < ulHeight; y++ )
	{
		for ( ULONG x = 0; x < ulWidth; x++ )
		{
			if ( 0 != pData[y * ulWidth + x] )
			{
				DrawLine( fx + x, fy + y, fx + x, fy + y, 1.0f, pData[y * ulWidth + x] );
			}
		}
	}
}

// Draw a box on the screen
void CXBoxVideo::DrawBox( float x1, float y1, float x2, float y2, DWORD color )
{
	MYVERTEX* pb;
	float maxx, minx;
	float maxy, miny;

	CHECK( m_Device->BeginScene() );
	CHECK( m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * 4, (BYTE**)&pb, 0 ) );
	
	if( IsBadWritePtr( pb, 128 ) )
	{
		XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawBox(): Lockreturned '%p', which is BAD!", pb );

		return;
	}

	if( x1 < x2 )
    {
		minx = x1;
		maxx = x2;
	}
    else
    {
		minx = x2;
		maxx = x1;
	}

	if( y1 < y2 )
    {
		miny = y1;
		maxy = y2;
	}
    else
    {
		miny = y2;
		maxy = y1;
	}

	if( x1 == x2 )
    {
		maxx++;
	}

	pb[0].v.x = minx; pb[0].v.y = miny; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
	pb[1].v.x = maxx; pb[1].v.y = miny; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
	pb[2].v.x = maxx; pb[2].v.y = maxy; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
	pb[3].v.x = minx; pb[3].v.y = maxy; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = color;

	m_VertexBuffer->Unlock();

	m_Device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
	m_Device->EndScene();
}


// Draw a clear rectangle to the screen
void CXBoxVideo::DrawClearRect( float x1, float y1, float x2, float y2, DWORD color ) 
{
	D3DRECT rect;

	if ( m_Device )
	{
		if( x1 < x2 )
        {
			rect.x1 = (long)x1; 
			rect.x2 = (long)x2 + 1;
		}
        else
        {
			rect.x1 = (long)x2; 
			rect.x2 = (long)x1 + 1;
		}

		if( y1 < y2 )
        {
			rect.y1 = (long)y1;
			rect.y2 = (long)y2 + 1;
		}
        else
        {
			rect.y1 = (long)y2;
			rect.y2 = (long)y1 + 1;
		}

		m_Device->Clear( 1, &rect, D3DCLEAR_TARGET, color, 0, 0 );
	}
}

// Draw a line to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      color          --- the RGBA color to draw the box with
HRESULT CXBoxVideo::DrawLine( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    HRESULT hr = S_OK;     // Return code for D3D functions that are called, and for the function
	MYVERTEX* pb;   // Vertex information

    // Set the line width
    if( FAILED( hr = m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Failed: m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth )! - '%d'", hr );
    }

    // Before any rendering can be done, this must be called
	if( FAILED( hr = m_Device->BeginScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->BeginScene()! - '%d'", hr );
    }

    // Locks a range of vertex data and obtains a pointer to the vertex buffer memory.
	if( FAILED( hr = m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * NUM_VB_VERTS, (BYTE**)&pb, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Lock()! - '%d'", hr );
    }

    pb[0].v.x = x1;  pb[0].v.y = y1; pb[0].v.z = .1f;  pb[0].fRHW = .9f;  pb[0].cDiffuse = color;
	pb[1].v.x = x2;  pb[1].v.y = y2; pb[1].v.z = .1f;  pb[1].fRHW = .9f;  pb[1].cDiffuse = color;

    // Unlock the vertext data
	if( FAILED( hr = m_VertexBuffer->Unlock() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Unlock()! - '%d'", hr );
        
        return hr;
    }

    // Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams
    if( FAILED( hr = m_Device->DrawPrimitive( D3DPT_LINELIST, 0, 1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->DrawPrimitive()! - '%d'", hr );
    }

    // Once rendering is complete, this must be called
    // We should try this, even on a failure, in case BeginScene() was successful
    // We'll report it to the debugger, but will not return the fail/success code to the
    // caller
	if( FAILED( m_Device->EndScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->EndScene()! - '%d'", hr );
    }

    return hr;
}

// Draw an outline to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      borderSize     --- width in pixels of the border
//      color          --- the RGBA color to draw the box with
void CXBoxVideo::DrawOutline( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    // Draw the box on the screen
    DrawLine( x1, y1, x1, y2, fLineWidth, color );     // Left Line
    DrawLine( x1, y2, x2, y2, fLineWidth, color );     // Bottom Line
    DrawLine( x2, y2, x2, y1, fLineWidth, color );     // Right Line
    DrawLine( x2, y1, x1, y1, fLineWidth, color );     // Top Line
}


// DeInitialize our Screen by freeing our objects
void CXBoxVideo::DeInitialize( void )
{
    if( m_BackBuffer)
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_Device )
    {
	    m_Device->Release();
        m_Device = NULL;
    }
}

// Prints formatted text using the default font to the screen
// Set colors to 0 to use default color
int CXBoxVideo::DrawText( float x1, float y1, DWORD fgcolor, DWORD bgcolor, const TCHAR* format, ... )
{
    if( !m_Font )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():The font is not set!!" );
        return -1;
    }

	int i;                  // Return Value
	HRESULT hr;             // Return Value for XFONT
	va_list v;              // Argument List
	TCHAR wstr[256];        // Honkin Buffer
    DWORD currentFGColor;   // Current FG Color
    DWORD currentBGColor;   // Current FG Color

    // Set our FONT colors if the user wishes to
    if( fgcolor || bgcolor )
    {
        // Set the foreground color if the user wants to
        if( fgcolor )
        {
            XFONT_SetTextColor( fgcolor );
        }

        // Set the background color if the user wants to
        if( bgcolor )
        {
            XFONT_SetBkColor( bgcolor );
        }
    }

	va_start( v, format );
	i = wvsprintf( wstr, format, v );

    // Print the Text to the backbuffer
    hr = XFONT_TextOut( wstr, i, (long)x1, (long)y1 );

    // If we have a valid font object, check the HRESULT
    if( FAILED( hr ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():XFONT_TextOut failed!!  HRESULT: %x", hr );
    }

	va_end( v );
	
    return i;
}

// Get the size of the current font
void CXBoxVideo::GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():The font is not set!!" );

        return;
    }

    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():Invalid arguments passed!!" );

        return;
    }

    XFONT_GetFontMetrics( pheight, pdecent );
}

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int CXBoxVideo::GetStringPixelWidth( IN LPCWSTR string, IN int length /*=-1*/ ) 
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):The font is not set!!" );

        return -1;
    }
    
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!" );

        return -1;
    }

	unsigned int outlen = 0;        // Return value

	XFONT_GetTextExtent( string, length, &outlen );
	
    return outlen;
}

// Get the width of the char*
int CXBoxVideo::GetStringPixelWidth( IN char* string, IN int length /*=-1*/ ) 
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( char* ):Invalid pointer passed in!" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}

// Get a D3D Transform
HRESULT CXBoxVideo::GetTransform( D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix )
{
    return m_Device->GetTransform( State, pMatrix );
}

// Get the D3D Vertex Shader
HRESULT CXBoxVideo::GetVertexShader( DWORD* pHandle )
{
    return m_Device->GetVertexShader( pHandle );
}

// Lighten the image specified by "pBits"
void CXBoxVideo::LightenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwAddto )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwAddto];
		pshufw mm0, mm0, 01000100b
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		paddusb mm1, mm0 ;//add, saturating to 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}

}

// Darken the image specified by "pBits"
void CXBoxVideo::DarkenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwSubtract )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwSubtract];
		pshufw mm0, mm0, 01000100b ;;//propegate "subtract" into both dwords of mm0
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		psubusb mm1, mm0 ;//subtract, saturating to 0 or 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Initialize D3D for this screen
void CXBoxVideo::Initialize( int width = SCREEN_WIDTH, int height = SCREEN_HEIGHT )
{
    IDirect3D8* pD3D = NULL;
    m_ScreenWidth = width;
    m_ScreenHeight = height;

	if ( m_Device == NULL )
	{
        // Create D3D 8.
		if( FAILED( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize(): Failed to create pD3D!" );
			return;
        }

        // Set the screen mode.
		D3DPRESENT_PARAMETERS d3dpp;
		ZeroMemory( &d3dpp, sizeof( d3dpp ) );

		d3dpp.BackBufferWidth                 = width;
		d3dpp.BackBufferHeight                = height;
		d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
		d3dpp.BackBufferCount                 = 1;

        d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
		d3dpp.Windowed                        = FALSE;                   // Must be false for Xbox
		d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
        d3dpp.EnableAutoDepthStencil          = FALSE; // TRUE;
        d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;

		// Create the m_Device.
		if ( FAILED ( pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                          D3DDEVTYPE_HAL,
                                          NULL,      // Ignored on Xbox
                                          D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                          &d3dpp,
                                          &m_Device ) ) )
		{
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to CreateDevice!" );
			pD3D->Release();

			return;
		}

		// Now we no longer need the D3D interface so let's free it.
		pD3D->Release();
	}

    if( FAILED( m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) Failed!!" );
    }

    // Create our vertex buffer
	if( FAILED( m_Device->CreateVertexBuffer( sizeof( MYVERTEX ) * NUM_VB_VERTS, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to create the Vertex Buffer!!" );
    }

    // Set the stream source
	m_Device->SetStreamSource( 0, m_VertexBuffer, sizeof( MYVERTEX ) );

    // Set our initial vertex shader that is compatible with our 2D scene
	if( FAILED( m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) Failed!!" );
    }

    // Setup matricies
    // Setup our identity matrix
    D3DMATRIX mat;
    mat._11 = mat._22 = mat._33 = mat._44 = 1.0f;
    mat._12 = mat._13 = mat._14 = mat._41 = 0.0f;
    mat._21 = mat._23 = mat._24 = mat._42 = 0.0f;
    mat._31 = mat._32 = mat._34 = mat._43 = 0.0f;

    // World Matrix
    // The world matrix controls the position and orientation 
    // of the polygons in world space. We'll use it later to 
    // spin the triangle.
    D3DMATRIX WorldMatrix = mat;

    // Set the transforms for our 3D world
    if( FAILED( m_Device->SetTransform( D3DTS_WORLD, &WorldMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the World Matrix!!" );
    }
    
    // View Matrix
    // The view matrix defines the position and orientation of 
    // the camera. Here, we are just moving it back along the z-
    // axis by 10 units.
    D3DMATRIX ViewMatrix = mat;
    ViewMatrix._43 = 10.0f;

    if( FAILED( m_Device->SetTransform( D3DTS_VIEW, &ViewMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the View Matrix!!" );
    }

    // Projection Matrix
    // The projection matrix defines how the 3-D scene is "projected" 
    // onto the 2-D render target surface. 

    // Set up a very simple projection that scales x and y 
    // by 2, and translates z by -1.0.
    D3DXMATRIX ProjectionMatrix; //  = mat;
    D3DXMatrixPerspectiveFovLH( &ProjectionMatrix, 1.57f, 640.0f/480.0f, 0.001f, 30.0f );

    if( FAILED( m_Device->SetTransform( D3DTS_PROJECTION, &ProjectionMatrix ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the Projection Matrix!!" );
    }
    
    // Viewport
    D3DVIEWPORT8 D3DViewport;    // Direct3D Viewport

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = width;  // rect.right - rect.left;
    D3DViewport.Height = height; // rect.bottom - rect.top;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( m_Device->SetViewport( &D3DViewport ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set the viewport!!" );
    }
    
    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &m_Font );

	if( m_Font )
    {
	    if( FAILED( m_Device->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &m_BackBuffer ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->GetBackBuffer() Failed!!" );
        }

        XFONT_SelectFont( m_Font );
        XFONT_SetDrawingSurface( m_BackBuffer );
        XFONT_SetTextColor( SCREEN_DEFAULT_TEXT_FG_COLOR );
        XFONT_SetBkColor( SCREEN_DEFAULT_TEXT_BG_COLOR );
        XFONT_SetTextHeight( FONT_DEFAULT_HEIGHT );
        XFONT_SetTextAntialiasLevel( FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( FONT_DEFAULT_STYLE );
    }
}


// Set a D3D Transform
HRESULT CXBoxVideo::SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix )
{
    return m_Device->SetTransform( State, pMatrix );
};

// Display the current backbuffer on to the screen
void CXBoxVideo::ShowScreen()
{
	if( m_Device )
    {
		m_Device->Present( NULL, NULL, NULL, NULL );
	}
}


// Set the D3D Vertex Shader
HRESULT CXBoxVideo::SetVertexShader( DWORD Handle )
{
    return m_Device->SetVertexShader( Handle );
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate0RP\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#define BREAK_INTO_DEBUGGER                     _asm { int 3 }
                                                
#define APP_TITLE_NAME_A                        "GR0-RP"
                                                
// Video Display Dimensions                     
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2.0f )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2.0f )
#define SCREEN_DEFAULT_FOREGROUND_COLOR         COLOR_TV_RED
#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_FONT_HEIGHT              30
#define SCREEN_DEFAULT_FONT_ALIAS_LEVEL         4
#define SCREEN_DEFAULT_FONT_STYLE               XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS

#define TEXT_GAME_RATING_INFO                   L"Rating Level 0 (RP - Rating Pending)"

// Colors                                       
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_RED                               0xFFFF0000
#define COLOR_TV_RED                            0xFF8D3232
#define COLOR_GREEN                             0xFF00FF00
#define COLOR_BLUE                              0xFF0000FF
#define COLOR_TV_LIGHT_BLUE                     0xFFA1A7FF
#define COLOR_LIGHT_YELLOW                      0xFFDDD078
#define COLOR_TV_YELLOW                         0xFFEFEF30
#define COLOR_DARK_GREEN                        0xFF357515

// File path and location constants
#define FILE_DATA_CACHE_SIZE                    5120000
#define FILE_DATA_DRIVE_A                       "t:"
#define FILE_DATA_DRIVE                         L"t:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\images"
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"
#define FILE_DATA_DEFAULT_FONT_FILENAME_A       FILE_DATA_MEDIA_DIRECTORY_A "\\tahoma.ttf"
#define FILE_DATA_DEFAULT_BG_IMAGE_FILENAME     FILE_DATA_IMAGE_DIRECTORY_A "\\background.bmp"

// Vertex Definitions
struct MYVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    cDiffuse;
};

struct MYTEXVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    diffuse;
    float       tu, tv;    // The texture coordinates
};

#define D3DFVF_MYVERTEX     ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE )
#define D3DFVF_MYTEXVERTEX  ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1 )

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\DukeInfo\xboxvideo.h ===
/*****************************************************
*** xboxvideo.h
***
*** Header file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#ifndef _XBOXVIDEO_H_
#define _XBOXVIDEO_H_

// Macros
#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) XDBGWRN( APP_TITLE_NAME_A, #code "File %s Line %d, Failed: %d", __LINE__, __FILE__, _ret__); } while (0);

#define NUM_VB_VERTS            100

// XBox configuration
class CXBoxVideo
{
public:
    // Constructors and Destructors
    CXBoxVideo( void );
    ~CXBoxVideo( void );

    // Public Properties

    // Public Methods
    void Initialize( int width,                         // Initialize D3D for this screen -- height and width default
                     int height );
    
    void DeInitialize( void );                          // Free our objects
    void ClearScreen( DWORD color );                    // Clear the current screen
    
    void DrawBox( float x1,                             // Draw a box on the screen
                  float y1,
                  float x2,
                  float y2,
                  DWORD color );

    void DrawBitBlt( float fx,                          // Draw the inputed bit array to the screen
                     float fy,
                     ULONG ulWidth,
                     ULONG ulHeight,
                     const DWORD* pData );
    
    void DrawClearRect( float x1,                       // Draw a clear rectangle to the screen
                        float y1,
                        float x2,
                        float y2,
                        DWORD color );

    HRESULT DrawLine( float x1,                         // Draw a line on the screen
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    void DrawOutline( float x1,                         // Draw an outline at the current location with a specific border size
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    int DrawText( float x1,                             // Prints formatted text, using the default font size and color
                  float y1,
                  DWORD fgcolor,
                  DWORD bgcolor,
                  const TCHAR* format,
                  ... );

    int GetStringPixelWidth( IN LPCWSTR string,         // Get the pixel width of a string
                             IN int length = -1 );

    int GetStringPixelWidth( IN char* string,           // Get the pixel width of a char*
                             IN int length /*=-1*/ ); 

    void GetFontSize( unsigned int* pheight,            // Get the size of the currently selected font
                      unsigned int* pdecent );

    void LightenImage( int nWidth,                      // Lighten the image specified by "pBits"
                       int nHeight,
                       DWORD* pBits,
                       DWORD dwAddto );
    void DarkenImage( int nWidth,                       // Darken the image specified by "pBits"
                      int nHeight,
                      DWORD* pBits,
                      DWORD dwSubtract );

    HRESULT TruncateStringToFit( char* pString,         // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    HRESULT TruncateStringToFit( WCHAR* pString,        // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    IDirect3DDevice8* GetD3DDevicePtr() { return m_Device; }; // Return the D3DDevice pointer to the caller

    void ShowScreen();                                  // Display the current backbuffer on the screen

    HRESULT GetTransform( D3DTRANSFORMSTATETYPE State,  // Get the D3D Transform
                          D3DMATRIX* pMatrix );         // Set the D3D Transform

    HRESULT SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix );

    HRESULT SetVertexShader( DWORD Handle );            // Set the D3D Vertex Shader
    HRESULT GetVertexShader( DWORD* pHandle );          // Get the D3D Vertex Shader



private:
    // Vertext structure
    struct MYVERTEX
    {
	    D3DXVECTOR3 v;
	    float       fRHW;
	    D3DCOLOR    cDiffuse;
    };

    // Private Properties
    IDirect3DDevice8* m_Device;
    IDirect3DSurface8* m_BackBuffer;
    IDirect3DVertexBuffer8* m_VertexBuffer;
    int m_ScreenWidth; 
    int m_ScreenHeight;
    
    // Font Properties
    XFONT* m_Font;
    float m_FontWidth;
    float m_FontHeight;
    DWORD m_FontColor;
    DWORD m_FontBgColor;

    // Private Methods
};

#endif // _XBOXVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate0RP\PolyObject.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Contstructor
CPolyObject::CPolyObject()
: m_pVertexBuffer( NULL )
{
}

// Destructor
CPolyObject::~CPolyObject()
{
    // Destroy any memory, etc, that we have allocated
    CleanUp();
}


// Clean up any memory allocated, etc.
void CPolyObject::CleanUp()
{
    // Clean up our Vertex Buffer
    if( m_pVertexBuffer )
    {
        m_pVertexBuffer->Release();
        m_pVertexBuffer = NULL;
    }
}


// Initialize our data, including our vertext buffer
void CPolyObject::Initialize( IDirect3DDevice8* pD3DDevice )
{
    // Clean up anything that was previously allocated
    CleanUp();

    // Setup our vertices
    MYTEXVERTEX* pb = NULL;

    // Create our vertex buffer
    pD3DDevice->CreateVertexBuffer( sizeof( MYTEXVERTEX ) * 4, 0, 0, 0, &m_pVertexBuffer );

    m_pVertexBuffer->Lock( 0, 0, (BYTE**)&pb, 0 );

    pb[0].v.x = 0.0f;         pb[0].v.y = 0.0f;          pb[0].v.z = 0.1f; pb[0].fRHW = 0.9f; pb[0].diffuse = COLOR_WHITE; pb[0].tu = 0.0f;         pb[0].tv = 0.0f;
    pb[1].v.x = SCREEN_WIDTH; pb[1].v.y = 0.0f;          pb[1].v.z = 0.1f; pb[1].fRHW = 0.9f; pb[1].diffuse = COLOR_WHITE; pb[1].tu = SCREEN_WIDTH; pb[1].tv = 0.0f;
    pb[2].v.x = SCREEN_WIDTH; pb[2].v.y = SCREEN_HEIGHT; pb[2].v.z = 0.1f; pb[2].fRHW = 0.9f; pb[2].diffuse = COLOR_WHITE; pb[2].tu = SCREEN_WIDTH; pb[2].tv = SCREEN_HEIGHT;
    pb[3].v.x = 0.0f;         pb[3].v.y = SCREEN_HEIGHT; pb[3].v.z = 0.1f; pb[3].fRHW = 0.9f; pb[3].diffuse = COLOR_WHITE; pb[3].tu = 0.0f;         pb[3].tv = SCREEN_HEIGHT;

    m_pVertexBuffer->Unlock();
}


// Render the Poly to the screen
void CPolyObject::Render( IDirect3DDevice8* pD3DDevice )
{
    pD3DDevice->SetVertexShader( D3DFVF_MYTEXVERTEX );
    pD3DDevice->SetStreamSource( 0, m_pVertexBuffer, sizeof( MYTEXVERTEX ) );
    pD3DDevice->DrawPrimitive( D3DPT_TRIANGLEFAN, 0, 2 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate0RP\PolyObject.h ===
/******************************************************
** polyobject.h
** 
** A basic polygon object capable of rendering itself
**
** 03/09/2001
** by James N. Helm
******************************************************/

#ifndef _POLYOBJECT_H_
#define _POLYOBJECT_H_

class CPolyObject
{
public:
    // Constructors and Destructors
    CPolyObject();
    ~CPolyObject();

    // Public Properties
    
    // Public Methods
    void Initialize( IDirect3DDevice8* pD3DDevice );    // Setup our Vertex Buffer and Poly Points
    void Render( IDirect3DDevice8* pD3DDevice );        // Render the poly to the backbuffer

private:
    // Private Properties
    IDirect3DVertexBuffer8* m_pVertexBuffer;            // Vertex buffer for our Polygon

    // Private Methods
    void CleanUp();                                     // Clean up any memory we have allocated
};

#endif // _POLYOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate0RP\GameRate.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Forward declarations
void Render();              // Render the video on to our screen and present it to the user
void CleanUp();             // Clean up memory, etc, when neccessary
BOOL Initialize();          // Initialize anything necessary for the MU Config program
BOOL InitializeD3D();       // Initalize D3D to be used by our application

// Globals
IDirect3DDevice8* g_pD3DDevice          = NULL;     // Pointer to our Direct3D Device Object
CPolyObject       g_mainDisplayPoly;                // Our main display (poly) object
CUDTexture        g_mainDisplayTexture;             // Out main display (texture) object
XFONT*            g_pFont               = NULL;     // Our Default Font Pointer
CHardDrive        g_HardDrive;                      // Xbox Hard Drive

void _cdecl main()
{
    XDBGWRN( APP_TITLE_NAME_A, "main() Entered..." );

    // Initialize the Application
    if( !Initialize() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "main():Failed to initialize!!" );

        return; // Should never return from main.  This is a bad situation
    }

    // Render Loop
    while( TRUE )
    {
        // Render the video on our screen and present it to the user
        Render();
    }

    XDBGWRN( APP_TITLE_NAME_A, "main() Exiting." );
}

void Render()
{
    g_pD3DDevice->Clear( 0, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0 );
    g_pD3DDevice->BeginScene();

    // Render the main screen object here
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    g_pD3DDevice->SetTexture( 0, g_mainDisplayTexture.GetTexture() );
    g_mainDisplayPoly.Render( g_pD3DDevice );
    g_pD3DDevice->SetTexture( 0, NULL );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    g_pD3DDevice->EndScene();
    g_pD3DDevice->Present( NULL, NULL, NULL, NULL );
}


// Clean up memory, etc, when neccessary
void CleanUp()
{
    // Clean up our D3D Device object
    if( g_pD3DDevice )
    {
        g_pD3DDevice->Release();
        g_pD3DDevice = NULL;
    }

    if( g_pFont )
    {
        XFONT_Release( g_pFont );
        g_pFont = NULL;
    }
}


// Initialize anything necessary for the MU Config program
BOOL Initialize()
{
    // Set the file cache size
    XSetFileCacheSize( FILE_DATA_CACHE_SIZE );

    // Get any launch info and display it in to the debugger
    DWORD dwLDataType;
    LAUNCH_DATA lData;
    ZeroMemory( &lData, sizeof( lData ) );

    if( ERROR_SUCCESS == XGetLaunchInfo( &dwLDataType, &lData ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Received Launch Data:" );

        if( LDT_FROM_DASHBOARD == dwLDataType )
        {
            LD_FROM_DASHBOARD* pDashData = (LD_FROM_DASHBOARD*)&lData;
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DASHBOARD" );
            XDBGWRN( APP_TITLE_NAME_A, "  Context - '%d'", pDashData->dwContext );

        }
        else if( LDT_FROM_DEBUGGER_CMDLINE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DEBUGGER CMDLINE" );
        }
        else if( LDT_TITLE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from TITLE" );
        }
        else
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from UNKNOWN" );
        }
    }

    // Check to see if our media exists on the HD -- If not, Copy it
    if( !g_HardDrive.FileExists( FILE_DATA_DEFAULT_FONT_FILENAME_A ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize(): Must Copy Media!!" );

        char pszSource[MAX_PATH+1];
        
        ZeroMemory( pszSource, MAX_PATH+1 );

        _snprintf( pszSource, MAX_PATH, "d:\\%0.8X", XeImageHeader()->Certificate->TitleID );

        // Copy the media -- Assume in it's our Title Dir
        g_HardDrive.CopyDirs( pszSource, "t:" );

        // Copy the DEFAULT.XBE to the user's E drive
        g_HardDrive.UnMapDrive( 'E' );
        g_HardDrive.MapDrive( 'E', "\\Device\\Harddisk0\\Partition1\\devkit" );
        CopyFile( "d:\\default.xbe", "e:\\GRate0RP.xbe", FALSE );
        g_HardDrive.UnMapDrive( 'E' );
    }

    // Initialize Direct3D
    if( !InitializeD3D() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Failed to InitializeD3D!!" );

        return FALSE;
    }

    ////////////////////////////////////////
    // Setup and Initialize our Default FONT
    ////////////////////////////////////////
    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &g_pFont );

    if( g_pFont )
    {
        // XFONT_SetDrawingSurface( m_BackBuffer );
        XFONT_SetTextColor( g_pFont, SCREEN_DEFAULT_FOREGROUND_COLOR );
        XFONT_SetBkColor( g_pFont, SCREEN_DEFAULT_BACKGROUND_COLOR );
        XFONT_SetTextHeight( g_pFont, SCREEN_DEFAULT_FONT_HEIGHT );
        XFONT_SetTextAntialiasLevel( g_pFont, SCREEN_DEFAULT_FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( g_pFont, SCREEN_DEFAULT_FONT_STYLE );
    }
    else
    {
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize our Font!!" );
    }

    // Create our display poly and our display texture
    g_mainDisplayPoly.Initialize( g_pD3DDevice );
    g_mainDisplayTexture.Initialize( g_pD3DDevice, NULL, 1024, 1024 );

    // TODO: Render the bitmap to the poly
    BitmapFile Bitmap;
    Bitmap.read( 0, 0, FILE_DATA_DEFAULT_BG_IMAGE_FILENAME );

    g_mainDisplayTexture.Lock();

    Bitmap.render( g_pD3DDevice, g_mainDisplayTexture.GetTextureSurface() );

    void DrawText( float fX1,                               // Prints formatted text, using the default font size
                   float fY1,
                   DWORD dwFGColor,
                   DWORD dwBGColor,
                   const WCHAR* pwszFormat,
                   ... );

    
    void DrawBox( float fX1,                                // Draw a box on the screen
                  float fY1,
                  float fX2,
                  float fY2,
                  DWORD dwColor );

    int iStringLen = GetStringPixelWidth( TEXT_GAME_RATING_INFO );

    unsigned int uiFontHeight;
    unsigned int uiFontWidth;
    GetFontSize( &uiFontHeight, &uiFontWidth );

    XDBGWRN( APP_TITLE_NAME_A, "Init():uiFontHeight - '%u'", uiFontHeight );
    XDBGWRN( APP_TITLE_NAME_A, "Init():uiFontWidth  - '%u'", uiFontWidth );

    float fTopBotYAdjust   = 100.0f;
    float fTopBotBorder    = 5.0f;
    float fLeftRightBorder = 10.0f;

    float X1 = SCREEN_X_CENTER - ( iStringLen / 2.0f ) - fLeftRightBorder;
    float Y1 = SCREEN_HEIGHT - fTopBotYAdjust;

    float X2 = SCREEN_X_CENTER + ( iStringLen / 2.0f ) + fLeftRightBorder;
    float Y2 = Y1 + uiFontHeight + ( fTopBotBorder * 2 );

    g_mainDisplayTexture.DrawBox( X1, Y1, X2, Y2, COLOR_BLACK );
    g_mainDisplayTexture.DrawText( X1 + fLeftRightBorder, Y1 + fTopBotBorder, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, TEXT_GAME_RATING_INFO );

    g_mainDisplayTexture.Unlock();

    return TRUE;
}


// Initalize D3D to be used by our application
BOOL InitializeD3D()
{
    IDirect3D8* pD3D;
    HRESULT hr = S_OK;

    // Create our Direct3D Object
    pD3D = Direct3DCreate8( D3D_SDK_VERSION );
    if( NULL == pD3D )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Object!!" );

        return FALSE;
    }

    // Create our D3D Device Object
    D3DPRESENT_PARAMETERS d3dpp;
	ZeroMemory( &d3dpp, sizeof( d3dpp ) );

    d3dpp.BackBufferWidth                 = SCREEN_WIDTH;
    d3dpp.BackBufferHeight                = SCREEN_HEIGHT;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.MultiSampleType                 = D3DMULTISAMPLE_4_SAMPLES;
    d3dpp.BackBufferCount                 = 1;

    d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
    d3dpp.Windowed                        = FALSE;                   // Must be FALSE for Xbox
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.EnableAutoDepthStencil          = FALSE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
	d3dpp.FullScreen_RefreshRateInHz      = D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE; // D3DPRESENT_INTERVAL_IMMEDIATE;

    if ( FAILED ( hr = pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                           D3DDEVTYPE_HAL,
                                           NULL,
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                           &d3dpp,
                                           &g_pD3DDevice ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Device Object!!" );
    }

    // Release the D3D Object
    // It's ok to simply release this object, as we know we cannot be here if the D3D Object failed creation
    pD3D->Release();
    pD3D = NULL;

    // If the device failed to create, simply abort the rest of the D3D Initialization
    if( !g_pD3DDevice )
    {
        return FALSE;
    }

    // Create our Viewport
    D3DVIEWPORT8 D3DViewport;

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = SCREEN_WIDTH;
    D3DViewport.Height = SCREEN_HEIGHT;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( hr = g_pD3DDevice->SetViewport( &D3DViewport ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to set the D3D Viewport!!" );
    }

    // Set our Renderstates and our Texture Stage States
    //BUGBUG: Tweak these and remove the ones uneccessary
    g_pD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    g_pD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    g_pD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    g_pD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    g_pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE);
    g_pD3DDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
    g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate1AO\PolyObject.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Contstructor
CPolyObject::CPolyObject()
: m_pVertexBuffer( NULL )
{
}

// Destructor
CPolyObject::~CPolyObject()
{
    // Destroy any memory, etc, that we have allocated
    CleanUp();
}


// Clean up any memory allocated, etc.
void CPolyObject::CleanUp()
{
    // Clean up our Vertex Buffer
    if( m_pVertexBuffer )
    {
        m_pVertexBuffer->Release();
        m_pVertexBuffer = NULL;
    }
}


// Initialize our data, including our vertext buffer
void CPolyObject::Initialize( IDirect3DDevice8* pD3DDevice )
{
    // Clean up anything that was previously allocated
    CleanUp();

    // Setup our vertices
    MYTEXVERTEX* pb = NULL;

    // Create our vertex buffer
    pD3DDevice->CreateVertexBuffer( sizeof( MYTEXVERTEX ) * 4, 0, 0, 0, &m_pVertexBuffer );

    m_pVertexBuffer->Lock( 0, 0, (BYTE**)&pb, 0 );

    pb[0].v.x = 0.0f;         pb[0].v.y = 0.0f;          pb[0].v.z = 0.1f; pb[0].fRHW = 0.9f; pb[0].diffuse = COLOR_WHITE; pb[0].tu = 0.0f;         pb[0].tv = 0.0f;
    pb[1].v.x = SCREEN_WIDTH; pb[1].v.y = 0.0f;          pb[1].v.z = 0.1f; pb[1].fRHW = 0.9f; pb[1].diffuse = COLOR_WHITE; pb[1].tu = SCREEN_WIDTH; pb[1].tv = 0.0f;
    pb[2].v.x = SCREEN_WIDTH; pb[2].v.y = SCREEN_HEIGHT; pb[2].v.z = 0.1f; pb[2].fRHW = 0.9f; pb[2].diffuse = COLOR_WHITE; pb[2].tu = SCREEN_WIDTH; pb[2].tv = SCREEN_HEIGHT;
    pb[3].v.x = 0.0f;         pb[3].v.y = SCREEN_HEIGHT; pb[3].v.z = 0.1f; pb[3].fRHW = 0.9f; pb[3].diffuse = COLOR_WHITE; pb[3].tu = 0.0f;         pb[3].tv = SCREEN_HEIGHT;

    m_pVertexBuffer->Unlock();
}


// Render the Poly to the screen
void CPolyObject::Render( IDirect3DDevice8* pD3DDevice )
{
    pD3DDevice->SetVertexShader( D3DFVF_MYTEXVERTEX );
    pD3DDevice->SetStreamSource( 0, m_pVertexBuffer, sizeof( MYTEXVERTEX ) );
    pD3DDevice->DrawPrimitive( D3DPT_TRIANGLEFAN, 0, 2 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate1AO\PolyObject.h ===
/******************************************************
** polyobject.h
** 
** A basic polygon object capable of rendering itself
**
** 03/09/2001
** by James N. Helm
******************************************************/

#ifndef _POLYOBJECT_H_
#define _POLYOBJECT_H_

class CPolyObject
{
public:
    // Constructors and Destructors
    CPolyObject();
    ~CPolyObject();

    // Public Properties
    
    // Public Methods
    void Initialize( IDirect3DDevice8* pD3DDevice );    // Setup our Vertex Buffer and Poly Points
    void Render( IDirect3DDevice8* pD3DDevice );        // Render the poly to the backbuffer

private:
    // Private Properties
    IDirect3DVertexBuffer8* m_pVertexBuffer;            // Vertex buffer for our Polygon

    // Private Methods
    void CleanUp();                                     // Clean up any memory we have allocated
};

#endif // _POLYOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate0RP\XFontFuncs.h ===
#ifndef _XFONTFUNCS_H_
#define _XFONTFUNCS_H_

// Get the pixel width of a string
int GetStringPixelWidth( IN WCHAR* string,
                         IN int length = -1 );

// Get the pixel width of a char*
int GetStringPixelWidth( IN char* string,
                         IN int length = -1 );

// Get the size of the currently selected font
void GetFontSize( unsigned int* pheight,
                  unsigned int* pdecent );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

#endif // _XFONTFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate0RP\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define XFONT_TRUETYPE

#include <xapip.h>
#include <xdbg.h>
#include <xfont.h>
#include <stdio.h>

// Libs
#include "bitmapfile.h"
#include "harddrive.h"

#include "xfontfuncs.h"
#include "udtexture.h"
#include "constants.h"

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate0RP\xfontfuncs.cpp ===
#include "stdafx.h"
#include "xfontfuncs.h"

extern XFONT *g_pFont;

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int GetStringPixelWidth( IN WCHAR* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!!\n" );

        return -1;
    }

    unsigned int outlen = 0;        // Return value

    XFONT_GetTextExtent( g_pFont, string, length, &outlen );

    return outlen;
}


// Get the width of the char*
int GetStringPixelWidth( IN char* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( char* ):Invalid pointer passed in!!\n" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}


// Get the size of the current font
void GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetFontSize():Invalid arguments passed!!\n" );

        return;
    }

    XFONT_GetFontMetrics( g_pFont, pheight, pdecent );
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate2M\PolyObject.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Contstructor
CPolyObject::CPolyObject()
: m_pVertexBuffer( NULL )
{
}

// Destructor
CPolyObject::~CPolyObject()
{
    // Destroy any memory, etc, that we have allocated
    CleanUp();
}


// Clean up any memory allocated, etc.
void CPolyObject::CleanUp()
{
    // Clean up our Vertex Buffer
    if( m_pVertexBuffer )
    {
        m_pVertexBuffer->Release();
        m_pVertexBuffer = NULL;
    }
}


// Initialize our data, including our vertext buffer
void CPolyObject::Initialize( IDirect3DDevice8* pD3DDevice )
{
    // Clean up anything that was previously allocated
    CleanUp();

    // Setup our vertices
    MYTEXVERTEX* pb = NULL;

    // Create our vertex buffer
    pD3DDevice->CreateVertexBuffer( sizeof( MYTEXVERTEX ) * 4, 0, 0, 0, &m_pVertexBuffer );

    m_pVertexBuffer->Lock( 0, 0, (BYTE**)&pb, 0 );

    pb[0].v.x = 0.0f;         pb[0].v.y = 0.0f;          pb[0].v.z = 0.1f; pb[0].fRHW = 0.9f; pb[0].diffuse = COLOR_WHITE; pb[0].tu = 0.0f;         pb[0].tv = 0.0f;
    pb[1].v.x = SCREEN_WIDTH; pb[1].v.y = 0.0f;          pb[1].v.z = 0.1f; pb[1].fRHW = 0.9f; pb[1].diffuse = COLOR_WHITE; pb[1].tu = SCREEN_WIDTH; pb[1].tv = 0.0f;
    pb[2].v.x = SCREEN_WIDTH; pb[2].v.y = SCREEN_HEIGHT; pb[2].v.z = 0.1f; pb[2].fRHW = 0.9f; pb[2].diffuse = COLOR_WHITE; pb[2].tu = SCREEN_WIDTH; pb[2].tv = SCREEN_HEIGHT;
    pb[3].v.x = 0.0f;         pb[3].v.y = SCREEN_HEIGHT; pb[3].v.z = 0.1f; pb[3].fRHW = 0.9f; pb[3].diffuse = COLOR_WHITE; pb[3].tu = 0.0f;         pb[3].tv = SCREEN_HEIGHT;

    m_pVertexBuffer->Unlock();
}


// Render the Poly to the screen
void CPolyObject::Render( IDirect3DDevice8* pD3DDevice )
{
    pD3DDevice->SetVertexShader( D3DFVF_MYTEXVERTEX );
    pD3DDevice->SetStreamSource( 0, m_pVertexBuffer, sizeof( MYTEXVERTEX ) );
    pD3DDevice->DrawPrimitive( D3DPT_TRIANGLEFAN, 0, 2 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate1AO\GameRate.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Forward declarations
void Render();              // Render the video on to our screen and present it to the user
void CleanUp();             // Clean up memory, etc, when neccessary
BOOL Initialize();          // Initialize anything necessary for the MU Config program
BOOL InitializeD3D();       // Initalize D3D to be used by our application

// Globals
IDirect3DDevice8* g_pD3DDevice          = NULL;     // Pointer to our Direct3D Device Object
CPolyObject       g_mainDisplayPoly;                // Our main display (poly) object
CUDTexture        g_mainDisplayTexture;             // Out main display (texture) object
XFONT*            g_pFont               = NULL;     // Our Default Font Pointer
CHardDrive        g_HardDrive;                      // Xbox Hard Drive

void _cdecl main()
{
    XDBGWRN( APP_TITLE_NAME_A, "main() Entered..." );

    // Initialize the Application
    if( !Initialize() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "main():Failed to initialize!!" );

        return; // Should never return from main.  This is a bad situation
    }

    // Render Loop
    while( TRUE )
    {
        // Render the video on our screen and present it to the user
        Render();
    }

    XDBGWRN( APP_TITLE_NAME_A, "main() Exiting." );
}

void Render()
{
    g_pD3DDevice->Clear( 0, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0 );
    g_pD3DDevice->BeginScene();

    // Render the main screen object here
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    g_pD3DDevice->SetTexture( 0, g_mainDisplayTexture.GetTexture() );
    g_mainDisplayPoly.Render( g_pD3DDevice );
    g_pD3DDevice->SetTexture( 0, NULL );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    g_pD3DDevice->EndScene();
    g_pD3DDevice->Present( NULL, NULL, NULL, NULL );
}


// Clean up memory, etc, when neccessary
void CleanUp()
{
    // Clean up our D3D Device object
    if( g_pD3DDevice )
    {
        g_pD3DDevice->Release();
        g_pD3DDevice = NULL;
    }

    if( g_pFont )
    {
        XFONT_Release( g_pFont );
        g_pFont = NULL;
    }
}


// Initialize anything necessary for the MU Config program
BOOL Initialize()
{
    // Set the file cache size
    XSetFileCacheSize( FILE_DATA_CACHE_SIZE );

    // Get any launch info and display it in to the debugger
    DWORD dwLDataType;
    LAUNCH_DATA lData;
    ZeroMemory( &lData, sizeof( lData ) );

    if( ERROR_SUCCESS == XGetLaunchInfo( &dwLDataType, &lData ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Received Launch Data:" );

        if( LDT_FROM_DASHBOARD == dwLDataType )
        {
            LD_FROM_DASHBOARD* pDashData = (LD_FROM_DASHBOARD*)&lData;
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DASHBOARD" );
            XDBGWRN( APP_TITLE_NAME_A, "  Context - '%d'", pDashData->dwContext );

        }
        else if( LDT_FROM_DEBUGGER_CMDLINE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DEBUGGER CMDLINE" );
        }
        else if( LDT_TITLE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from TITLE" );
        }
        else
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from UNKNOWN" );
        }
    }

    // Check to see if our media exists on the HD -- If not, Copy it
    if( !g_HardDrive.FileExists( FILE_DATA_DEFAULT_FONT_FILENAME_A ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize(): Must Copy Media!!" );

        char pszSource[MAX_PATH+1];
        
        ZeroMemory( pszSource, MAX_PATH+1 );

        _snprintf( pszSource, MAX_PATH, "d:\\%0.8X", XeImageHeader()->Certificate->TitleID );

        // Copy the media -- Assume in it's our Title Dir
        g_HardDrive.CopyDirs( pszSource, "t:" );

        // Copy the DEFAULT.XBE to the user's E drive
        g_HardDrive.UnMapDrive( 'E' );
        g_HardDrive.MapDrive( 'E', "\\Device\\Harddisk0\\Partition1\\devkit" );
        CopyFile( "d:\\default.xbe", "e:\\GRate1AO.xbe", FALSE );
        g_HardDrive.UnMapDrive( 'E' );
    }

    // Initialize Direct3D
    if( !InitializeD3D() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Failed to InitializeD3D!!" );

        return FALSE;
    }

    ////////////////////////////////////////
    // Setup and Initialize our Default FONT
    ////////////////////////////////////////
    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &g_pFont );

    if( g_pFont )
    {
        // XFONT_SetDrawingSurface( m_BackBuffer );
        XFONT_SetTextColor( g_pFont, SCREEN_DEFAULT_FOREGROUND_COLOR );
        XFONT_SetBkColor( g_pFont, SCREEN_DEFAULT_BACKGROUND_COLOR );
        XFONT_SetTextHeight( g_pFont, SCREEN_DEFAULT_FONT_HEIGHT );
        XFONT_SetTextAntialiasLevel( g_pFont, SCREEN_DEFAULT_FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( g_pFont, SCREEN_DEFAULT_FONT_STYLE );
    }
    else
    {
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize our Font!!" );
    }

    // Create our display poly and our display texture
    g_mainDisplayPoly.Initialize( g_pD3DDevice );
    g_mainDisplayTexture.Initialize( g_pD3DDevice, NULL, 1024, 1024 );

    // TODO: Render the bitmap to the poly
    BitmapFile Bitmap;
    Bitmap.read( 0, 0, FILE_DATA_DEFAULT_BG_IMAGE_FILENAME );

    g_mainDisplayTexture.Lock();

    Bitmap.render( g_pD3DDevice, g_mainDisplayTexture.GetTextureSurface() );

    void DrawText( float fX1,                               // Prints formatted text, using the default font size
                   float fY1,
                   DWORD dwFGColor,
                   DWORD dwBGColor,
                   const WCHAR* pwszFormat,
                   ... );

    
    void DrawBox( float fX1,                                // Draw a box on the screen
                  float fY1,
                  float fX2,
                  float fY2,
                  DWORD dwColor );

    int iStringLen = GetStringPixelWidth( TEXT_GAME_RATING_INFO );

    unsigned int uiFontHeight;
    unsigned int uiFontWidth;
    GetFontSize( &uiFontHeight, &uiFontWidth );

    XDBGWRN( APP_TITLE_NAME_A, "Init():uiFontHeight - '%u'", uiFontHeight );
    XDBGWRN( APP_TITLE_NAME_A, "Init():uiFontWidth  - '%u'", uiFontWidth );

    float fTopBotYAdjust   = 100.0f;
    float fTopBotBorder    = 5.0f;
    float fLeftRightBorder = 10.0f;

    float X1 = SCREEN_X_CENTER - ( iStringLen / 2.0f ) - fLeftRightBorder;
    float Y1 = SCREEN_HEIGHT - fTopBotYAdjust;

    float X2 = SCREEN_X_CENTER + ( iStringLen / 2.0f ) + fLeftRightBorder;
    float Y2 = Y1 + uiFontHeight + ( fTopBotBorder * 2 );

    g_mainDisplayTexture.DrawBox( X1, Y1, X2, Y2, COLOR_BLACK );
    g_mainDisplayTexture.DrawText( X1 + fLeftRightBorder, Y1 + fTopBotBorder, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, TEXT_GAME_RATING_INFO );

    g_mainDisplayTexture.Unlock();

    return TRUE;
}


// Initalize D3D to be used by our application
BOOL InitializeD3D()
{
    IDirect3D8* pD3D;
    HRESULT hr = S_OK;

    // Create our Direct3D Object
    pD3D = Direct3DCreate8( D3D_SDK_VERSION );
    if( NULL == pD3D )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Object!!" );

        return FALSE;
    }

    // Create our D3D Device Object
    D3DPRESENT_PARAMETERS d3dpp;
	ZeroMemory( &d3dpp, sizeof( d3dpp ) );

    d3dpp.BackBufferWidth                 = SCREEN_WIDTH;
    d3dpp.BackBufferHeight                = SCREEN_HEIGHT;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.MultiSampleType                 = D3DMULTISAMPLE_4_SAMPLES;
    d3dpp.BackBufferCount                 = 1;

    d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
    d3dpp.Windowed                        = FALSE;                   // Must be FALSE for Xbox
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.EnableAutoDepthStencil          = FALSE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
	d3dpp.FullScreen_RefreshRateInHz      = D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE; // D3DPRESENT_INTERVAL_IMMEDIATE;

    if ( FAILED ( hr = pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                           D3DDEVTYPE_HAL,
                                           NULL,
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                           &d3dpp,
                                           &g_pD3DDevice ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Device Object!!" );
    }

    // Release the D3D Object
    // It's ok to simply release this object, as we know we cannot be here if the D3D Object failed creation
    pD3D->Release();
    pD3D = NULL;

    // If the device failed to create, simply abort the rest of the D3D Initialization
    if( !g_pD3DDevice )
    {
        return FALSE;
    }

    // Create our Viewport
    D3DVIEWPORT8 D3DViewport;

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = SCREEN_WIDTH;
    D3DViewport.Height = SCREEN_HEIGHT;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( hr = g_pD3DDevice->SetViewport( &D3DViewport ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to set the D3D Viewport!!" );
    }

    // Set our Renderstates and our Texture Stage States
    //BUGBUG: Tweak these and remove the ones uneccessary
    g_pD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    g_pD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    g_pD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    g_pD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    g_pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE);
    g_pD3DDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
    g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate1AO\XFontFuncs.h ===
#ifndef _XFONTFUNCS_H_
#define _XFONTFUNCS_H_

// Get the pixel width of a string
int GetStringPixelWidth( IN WCHAR* string,
                         IN int length = -1 );

// Get the pixel width of a char*
int GetStringPixelWidth( IN char* string,
                         IN int length = -1 );

// Get the size of the currently selected font
void GetFontSize( unsigned int* pheight,
                  unsigned int* pdecent );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

#endif // _XFONTFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate1AO\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define XFONT_TRUETYPE

#include <xapip.h>
#include <xdbg.h>
#include <xfont.h>
#include <stdio.h>

// Libs
#include "bitmapfile.h"
#include "harddrive.h"

#include "xfontfuncs.h"
#include "udtexture.h"
#include "constants.h"

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate2M\PolyObject.h ===
/******************************************************
** polyobject.h
** 
** A basic polygon object capable of rendering itself
**
** 03/09/2001
** by James N. Helm
******************************************************/

#ifndef _POLYOBJECT_H_
#define _POLYOBJECT_H_

class CPolyObject
{
public:
    // Constructors and Destructors
    CPolyObject();
    ~CPolyObject();

    // Public Properties
    
    // Public Methods
    void Initialize( IDirect3DDevice8* pD3DDevice );    // Setup our Vertex Buffer and Poly Points
    void Render( IDirect3DDevice8* pD3DDevice );        // Render the poly to the backbuffer

private:
    // Private Properties
    IDirect3DVertexBuffer8* m_pVertexBuffer;            // Vertex buffer for our Polygon

    // Private Methods
    void CleanUp();                                     // Clean up any memory we have allocated
};

#endif // _POLYOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate2M\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define XFONT_TRUETYPE

#include <xapip.h>
#include <xdbg.h>
#include <xfont.h>
#include <stdio.h>

// Libs
#include "bitmapfile.h"
#include "harddrive.h"

#include "xfontfuncs.h"
#include "udtexture.h"
#include "constants.h"

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate1AO\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#define BREAK_INTO_DEBUGGER                     _asm { int 3 }
                                                
#define APP_TITLE_NAME_A                        "GR1-AO"
                                                
// Video Display Dimensions                     
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2.0f )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2.0f )
#define SCREEN_DEFAULT_FOREGROUND_COLOR         COLOR_TV_RED
#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_FONT_HEIGHT              30
#define SCREEN_DEFAULT_FONT_ALIAS_LEVEL         4
#define SCREEN_DEFAULT_FONT_STYLE               XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS

#define TEXT_GAME_RATING_INFO                   L"Rating Level 1 (AO - Adults Only)"

// Colors                                       
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_RED                               0xFFFF0000
#define COLOR_TV_RED                            0xFF8D3232
#define COLOR_GREEN                             0xFF00FF00
#define COLOR_BLUE                              0xFF0000FF
#define COLOR_TV_LIGHT_BLUE                     0xFFA1A7FF
#define COLOR_LIGHT_YELLOW                      0xFFDDD078
#define COLOR_TV_YELLOW                         0xFFEFEF30
#define COLOR_DARK_GREEN                        0xFF357515

// File path and location constants
#define FILE_DATA_CACHE_SIZE                    5120000
#define FILE_DATA_DRIVE_A                       "t:"
#define FILE_DATA_DRIVE                         L"t:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\images"
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"
#define FILE_DATA_DEFAULT_FONT_FILENAME_A       FILE_DATA_MEDIA_DIRECTORY_A "\\tahoma.ttf"
#define FILE_DATA_DEFAULT_BG_IMAGE_FILENAME     FILE_DATA_IMAGE_DIRECTORY_A "\\background.bmp"

// Vertex Definitions
struct MYVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    cDiffuse;
};

struct MYTEXVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    diffuse;
    float       tu, tv;    // The texture coordinates
};

#define D3DFVF_MYVERTEX     ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE )
#define D3DFVF_MYTEXVERTEX  ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1 )

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate1AO\xfontfuncs.cpp ===
#include "stdafx.h"
#include "xfontfuncs.h"

extern XFONT* g_pFont;

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int GetStringPixelWidth( IN WCHAR* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!!\n" );

        return -1;
    }

    unsigned int outlen = 0;        // Return value

    XFONT_GetTextExtent( g_pFont, string, length, &outlen );

    return outlen;
}


// Get the width of the char*
int GetStringPixelWidth( IN char* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( char* ):Invalid pointer passed in!!\n" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}


// Get the size of the current font
void GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetFontSize():Invalid arguments passed!!\n" );

        return;
    }

    XFONT_GetFontMetrics( g_pFont, pheight, pdecent );
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate2M\xfontfuncs.cpp ===
#include "stdafx.h"
#include "xfontfuncs.h"

extern XFONT* g_pFont;

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int GetStringPixelWidth( IN WCHAR* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!!\n" );

        return -1;
    }

    unsigned int outlen = 0;        // Return value

    XFONT_GetTextExtent( g_pFont, string, length, &outlen );

    return outlen;
}


// Get the width of the char*
int GetStringPixelWidth( IN char* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( char* ):Invalid pointer passed in!!\n" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}


// Get the size of the current font
void GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetFontSize():Invalid arguments passed!!\n" );

        return;
    }

    XFONT_GetFontMetrics( g_pFont, pheight, pdecent );
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate2M\XFontFuncs.h ===
#ifndef _XFONTFUNCS_H_
#define _XFONTFUNCS_H_

// Get the pixel width of a string
int GetStringPixelWidth( IN WCHAR* string,
                         IN int length = -1 );

// Get the pixel width of a char*
int GetStringPixelWidth( IN char* string,
                         IN int length = -1 );

// Get the size of the currently selected font
void GetFontSize( unsigned int* pheight,
                  unsigned int* pdecent );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

#endif // _XFONTFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate3T\PolyObject.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Contstructor
CPolyObject::CPolyObject()
: m_pVertexBuffer( NULL )
{
}

// Destructor
CPolyObject::~CPolyObject()
{
    // Destroy any memory, etc, that we have allocated
    CleanUp();
}


// Clean up any memory allocated, etc.
void CPolyObject::CleanUp()
{
    // Clean up our Vertex Buffer
    if( m_pVertexBuffer )
    {
        m_pVertexBuffer->Release();
        m_pVertexBuffer = NULL;
    }
}


// Initialize our data, including our vertext buffer
void CPolyObject::Initialize( IDirect3DDevice8* pD3DDevice )
{
    // Clean up anything that was previously allocated
    CleanUp();

    // Setup our vertices
    MYTEXVERTEX* pb = NULL;

    // Create our vertex buffer
    pD3DDevice->CreateVertexBuffer( sizeof( MYTEXVERTEX ) * 4, 0, 0, 0, &m_pVertexBuffer );

    m_pVertexBuffer->Lock( 0, 0, (BYTE**)&pb, 0 );

    pb[0].v.x = 0.0f;         pb[0].v.y = 0.0f;          pb[0].v.z = 0.1f; pb[0].fRHW = 0.9f; pb[0].diffuse = COLOR_WHITE; pb[0].tu = 0.0f;         pb[0].tv = 0.0f;
    pb[1].v.x = SCREEN_WIDTH; pb[1].v.y = 0.0f;          pb[1].v.z = 0.1f; pb[1].fRHW = 0.9f; pb[1].diffuse = COLOR_WHITE; pb[1].tu = SCREEN_WIDTH; pb[1].tv = 0.0f;
    pb[2].v.x = SCREEN_WIDTH; pb[2].v.y = SCREEN_HEIGHT; pb[2].v.z = 0.1f; pb[2].fRHW = 0.9f; pb[2].diffuse = COLOR_WHITE; pb[2].tu = SCREEN_WIDTH; pb[2].tv = SCREEN_HEIGHT;
    pb[3].v.x = 0.0f;         pb[3].v.y = SCREEN_HEIGHT; pb[3].v.z = 0.1f; pb[3].fRHW = 0.9f; pb[3].diffuse = COLOR_WHITE; pb[3].tu = 0.0f;         pb[3].tv = SCREEN_HEIGHT;

    m_pVertexBuffer->Unlock();
}


// Render the Poly to the screen
void CPolyObject::Render( IDirect3DDevice8* pD3DDevice )
{
    pD3DDevice->SetVertexShader( D3DFVF_MYTEXVERTEX );
    pD3DDevice->SetStreamSource( 0, m_pVertexBuffer, sizeof( MYTEXVERTEX ) );
    pD3DDevice->DrawPrimitive( D3DPT_TRIANGLEFAN, 0, 2 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate3T\PolyObject.h ===
/******************************************************
** polyobject.h
** 
** A basic polygon object capable of rendering itself
**
** 03/09/2001
** by James N. Helm
******************************************************/

#ifndef _POLYOBJECT_H_
#define _POLYOBJECT_H_

class CPolyObject
{
public:
    // Constructors and Destructors
    CPolyObject();
    ~CPolyObject();

    // Public Properties
    
    // Public Methods
    void Initialize( IDirect3DDevice8* pD3DDevice );    // Setup our Vertex Buffer and Poly Points
    void Render( IDirect3DDevice8* pD3DDevice );        // Render the poly to the backbuffer

private:
    // Private Properties
    IDirect3DVertexBuffer8* m_pVertexBuffer;            // Vertex buffer for our Polygon

    // Private Methods
    void CleanUp();                                     // Clean up any memory we have allocated
};

#endif // _POLYOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate3T\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define XFONT_TRUETYPE

#include <xapip.h>
#include <xdbg.h>
#include <xfont.h>
#include <stdio.h>

// Libs
#include "bitmapfile.h"
#include "harddrive.h"

#include "xfontfuncs.h"
#include "udtexture.h"
#include "constants.h"

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate3T\xfontfuncs.cpp ===
#include "stdafx.h"
#include "xfontfuncs.h"

extern XFONT* g_pFont;

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int GetStringPixelWidth( IN WCHAR* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!!\n" );

        return -1;
    }

    unsigned int outlen = 0;        // Return value

    XFONT_GetTextExtent( g_pFont, string, length, &outlen );

    return outlen;
}


// Get the width of the char*
int GetStringPixelWidth( IN char* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( char* ):Invalid pointer passed in!!\n" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}


// Get the size of the current font
void GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetFontSize():Invalid arguments passed!!\n" );

        return;
    }

    XFONT_GetFontMetrics( g_pFont, pheight, pdecent );
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate3T\XFontFuncs.h ===
#ifndef _XFONTFUNCS_H_
#define _XFONTFUNCS_H_

// Get the pixel width of a string
int GetStringPixelWidth( IN WCHAR* string,
                         IN int length = -1 );

// Get the pixel width of a char*
int GetStringPixelWidth( IN char* string,
                         IN int length = -1 );

// Get the size of the currently selected font
void GetFontSize( unsigned int* pheight,
                  unsigned int* pdecent );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

#endif // _XFONTFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate4E\PolyObject.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Contstructor
CPolyObject::CPolyObject()
: m_pVertexBuffer( NULL )
{
}

// Destructor
CPolyObject::~CPolyObject()
{
    // Destroy any memory, etc, that we have allocated
    CleanUp();
}


// Clean up any memory allocated, etc.
void CPolyObject::CleanUp()
{
    // Clean up our Vertex Buffer
    if( m_pVertexBuffer )
    {
        m_pVertexBuffer->Release();
        m_pVertexBuffer = NULL;
    }
}


// Initialize our data, including our vertext buffer
void CPolyObject::Initialize( IDirect3DDevice8* pD3DDevice )
{
    // Clean up anything that was previously allocated
    CleanUp();

    // Setup our vertices
    MYTEXVERTEX* pb = NULL;

    // Create our vertex buffer
    pD3DDevice->CreateVertexBuffer( sizeof( MYTEXVERTEX ) * 4, 0, 0, 0, &m_pVertexBuffer );

    m_pVertexBuffer->Lock( 0, 0, (BYTE**)&pb, 0 );

    pb[0].v.x = 0.0f;         pb[0].v.y = 0.0f;          pb[0].v.z = 0.1f; pb[0].fRHW = 0.9f; pb[0].diffuse = COLOR_WHITE; pb[0].tu = 0.0f;         pb[0].tv = 0.0f;
    pb[1].v.x = SCREEN_WIDTH; pb[1].v.y = 0.0f;          pb[1].v.z = 0.1f; pb[1].fRHW = 0.9f; pb[1].diffuse = COLOR_WHITE; pb[1].tu = SCREEN_WIDTH; pb[1].tv = 0.0f;
    pb[2].v.x = SCREEN_WIDTH; pb[2].v.y = SCREEN_HEIGHT; pb[2].v.z = 0.1f; pb[2].fRHW = 0.9f; pb[2].diffuse = COLOR_WHITE; pb[2].tu = SCREEN_WIDTH; pb[2].tv = SCREEN_HEIGHT;
    pb[3].v.x = 0.0f;         pb[3].v.y = SCREEN_HEIGHT; pb[3].v.z = 0.1f; pb[3].fRHW = 0.9f; pb[3].diffuse = COLOR_WHITE; pb[3].tu = 0.0f;         pb[3].tv = SCREEN_HEIGHT;

    m_pVertexBuffer->Unlock();
}


// Render the Poly to the screen
void CPolyObject::Render( IDirect3DDevice8* pD3DDevice )
{
    pD3DDevice->SetVertexShader( D3DFVF_MYTEXVERTEX );
    pD3DDevice->SetStreamSource( 0, m_pVertexBuffer, sizeof( MYTEXVERTEX ) );
    pD3DDevice->DrawPrimitive( D3DPT_TRIANGLEFAN, 0, 2 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate4E\PolyObject.h ===
/******************************************************
** polyobject.h
** 
** A basic polygon object capable of rendering itself
**
** 03/09/2001
** by James N. Helm
******************************************************/

#ifndef _POLYOBJECT_H_
#define _POLYOBJECT_H_

class CPolyObject
{
public:
    // Constructors and Destructors
    CPolyObject();
    ~CPolyObject();

    // Public Properties
    
    // Public Methods
    void Initialize( IDirect3DDevice8* pD3DDevice );    // Setup our Vertex Buffer and Poly Points
    void Render( IDirect3DDevice8* pD3DDevice );        // Render the poly to the backbuffer

private:
    // Private Properties
    IDirect3DVertexBuffer8* m_pVertexBuffer;            // Vertex buffer for our Polygon

    // Private Methods
    void CleanUp();                                     // Clean up any memory we have allocated
};

#endif // _POLYOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate2M\GameRate.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Forward declarations
void Render();              // Render the video on to our screen and present it to the user
void CleanUp();             // Clean up memory, etc, when neccessary
BOOL Initialize();          // Initialize anything necessary for the MU Config program
BOOL InitializeD3D();       // Initalize D3D to be used by our application

// Globals
IDirect3DDevice8* g_pD3DDevice          = NULL;     // Pointer to our Direct3D Device Object
CPolyObject       g_mainDisplayPoly;                // Our main display (poly) object
CUDTexture        g_mainDisplayTexture;             // Out main display (texture) object
XFONT*            g_pFont               = NULL;     // Our Default Font Pointer
CHardDrive        g_HardDrive;                      // Xbox Hard Drive

void _cdecl main()
{
    XDBGWRN( APP_TITLE_NAME_A, "main() Entered..." );

    // Initialize the Application
    if( !Initialize() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "main():Failed to initialize!!" );

        return; // Should never return from main.  This is a bad situation
    }

    // Render Loop
    while( TRUE )
    {
        // Render the video on our screen and present it to the user
        Render();
    }

    XDBGWRN( APP_TITLE_NAME_A, "main() Exiting." );
}

void Render()
{
    g_pD3DDevice->Clear( 0, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0 );
    g_pD3DDevice->BeginScene();

    // Render the main screen object here
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    g_pD3DDevice->SetTexture( 0, g_mainDisplayTexture.GetTexture() );
    g_mainDisplayPoly.Render( g_pD3DDevice );
    g_pD3DDevice->SetTexture( 0, NULL );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    g_pD3DDevice->EndScene();
    g_pD3DDevice->Present( NULL, NULL, NULL, NULL );
}


// Clean up memory, etc, when neccessary
void CleanUp()
{
    // Clean up our D3D Device object
    if( g_pD3DDevice )
    {
        g_pD3DDevice->Release();
        g_pD3DDevice = NULL;
    }

    if( g_pFont )
    {
        XFONT_Release( g_pFont );
        g_pFont = NULL;
    }
}


// Initialize anything necessary for the MU Config program
BOOL Initialize()
{
    // Set the file cache size
    XSetFileCacheSize( FILE_DATA_CACHE_SIZE );

    // Get any launch info and display it in to the debugger
    DWORD dwLDataType;
    LAUNCH_DATA lData;
    ZeroMemory( &lData, sizeof( lData ) );

    if( ERROR_SUCCESS == XGetLaunchInfo( &dwLDataType, &lData ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Received Launch Data:" );

        if( LDT_FROM_DASHBOARD == dwLDataType )
        {
            LD_FROM_DASHBOARD* pDashData = (LD_FROM_DASHBOARD*)&lData;
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DASHBOARD" );
            XDBGWRN( APP_TITLE_NAME_A, "  Context - '%d'", pDashData->dwContext );

        }
        else if( LDT_FROM_DEBUGGER_CMDLINE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DEBUGGER CMDLINE" );
        }
        else if( LDT_TITLE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from TITLE" );
        }
        else
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from UNKNOWN" );
        }
    }

    // Check to see if our media exists on the HD -- If not, Copy it
    if( !g_HardDrive.FileExists( FILE_DATA_DEFAULT_FONT_FILENAME_A ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize(): Must Copy Media!!" );

        char pszSource[MAX_PATH+1];
        
        ZeroMemory( pszSource, MAX_PATH+1 );

        _snprintf( pszSource, MAX_PATH, "d:\\%0.8X", XeImageHeader()->Certificate->TitleID );

        // Copy the media -- Assume in it's our Title Dir
        g_HardDrive.CopyDirs( pszSource, "t:" );

        // Copy the DEFAULT.XBE to the user's E drive
        g_HardDrive.UnMapDrive( 'E' );
        g_HardDrive.MapDrive( 'E', "\\Device\\Harddisk0\\Partition1\\devkit" );
        CopyFile( "d:\\default.xbe", "e:\\GRate2M.xbe", FALSE );
        g_HardDrive.UnMapDrive( 'E' );
    }
    
    // Initialize Direct3D
    if( !InitializeD3D() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Failed to InitializeD3D!!" );

        return FALSE;
    }

    ////////////////////////////////////////
    // Setup and Initialize our Default FONT
    ////////////////////////////////////////
    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &g_pFont );

    if( g_pFont )
    {
        // XFONT_SetDrawingSurface( m_BackBuffer );
        XFONT_SetTextColor( g_pFont, SCREEN_DEFAULT_FOREGROUND_COLOR );
        XFONT_SetBkColor( g_pFont, SCREEN_DEFAULT_BACKGROUND_COLOR );
        XFONT_SetTextHeight( g_pFont, SCREEN_DEFAULT_FONT_HEIGHT );
        XFONT_SetTextAntialiasLevel( g_pFont, SCREEN_DEFAULT_FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( g_pFont, SCREEN_DEFAULT_FONT_STYLE );
    }
    else
    {
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize our Font!!" );
    }

    // Create our display poly and our display texture
    g_mainDisplayPoly.Initialize( g_pD3DDevice );
    g_mainDisplayTexture.Initialize( g_pD3DDevice, NULL, 1024, 1024 );

    // TODO: Render the bitmap to the poly
    BitmapFile Bitmap;
    Bitmap.read( 0, 0, FILE_DATA_DEFAULT_BG_IMAGE_FILENAME );

    g_mainDisplayTexture.Lock();

    Bitmap.render( g_pD3DDevice, g_mainDisplayTexture.GetTextureSurface() );

    void DrawText( float fX1,                               // Prints formatted text, using the default font size
                   float fY1,
                   DWORD dwFGColor,
                   DWORD dwBGColor,
                   const WCHAR* pwszFormat,
                   ... );

    
    void DrawBox( float fX1,                                // Draw a box on the screen
                  float fY1,
                  float fX2,
                  float fY2,
                  DWORD dwColor );

    int iStringLen = GetStringPixelWidth( TEXT_GAME_RATING_INFO );

    unsigned int uiFontHeight;
    unsigned int uiFontWidth;
    GetFontSize( &uiFontHeight, &uiFontWidth );

    XDBGWRN( APP_TITLE_NAME_A, "Init():uiFontHeight - '%u'", uiFontHeight );
    XDBGWRN( APP_TITLE_NAME_A, "Init():uiFontWidth  - '%u'", uiFontWidth );

    float fTopBotYAdjust   = 100.0f;
    float fTopBotBorder    = 5.0f;
    float fLeftRightBorder = 10.0f;

    float X1 = SCREEN_X_CENTER - ( iStringLen / 2.0f ) - fLeftRightBorder;
    float Y1 = SCREEN_HEIGHT - fTopBotYAdjust;

    float X2 = SCREEN_X_CENTER + ( iStringLen / 2.0f ) + fLeftRightBorder;
    float Y2 = Y1 + uiFontHeight + ( fTopBotBorder * 2 );

    g_mainDisplayTexture.DrawBox( X1, Y1, X2, Y2, COLOR_BLACK );
    g_mainDisplayTexture.DrawText( X1 + fLeftRightBorder, Y1 + fTopBotBorder, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, TEXT_GAME_RATING_INFO );

    g_mainDisplayTexture.Unlock();

    return TRUE;
}


// Initalize D3D to be used by our application
BOOL InitializeD3D()
{
    IDirect3D8* pD3D;
    HRESULT hr = S_OK;

    // Create our Direct3D Object
    pD3D = Direct3DCreate8( D3D_SDK_VERSION );
    if( NULL == pD3D )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Object!!" );

        return FALSE;
    }

    // Create our D3D Device Object
    D3DPRESENT_PARAMETERS d3dpp;
	ZeroMemory( &d3dpp, sizeof( d3dpp ) );

    d3dpp.BackBufferWidth                 = SCREEN_WIDTH;
    d3dpp.BackBufferHeight                = SCREEN_HEIGHT;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.MultiSampleType                 = D3DMULTISAMPLE_4_SAMPLES;
    d3dpp.BackBufferCount                 = 1;

    d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
    d3dpp.Windowed                        = FALSE;                   // Must be FALSE for Xbox
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.EnableAutoDepthStencil          = FALSE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
	d3dpp.FullScreen_RefreshRateInHz      = D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE; // D3DPRESENT_INTERVAL_IMMEDIATE;

    if ( FAILED ( hr = pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                           D3DDEVTYPE_HAL,
                                           NULL,
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                           &d3dpp,
                                           &g_pD3DDevice ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Device Object!!" );
    }

    // Release the D3D Object
    // It's ok to simply release this object, as we know we cannot be here if the D3D Object failed creation
    pD3D->Release();
    pD3D = NULL;

    // If the device failed to create, simply abort the rest of the D3D Initialization
    if( !g_pD3DDevice )
    {
        return FALSE;
    }

    // Create our Viewport
    D3DVIEWPORT8 D3DViewport;

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = SCREEN_WIDTH;
    D3DViewport.Height = SCREEN_HEIGHT;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( hr = g_pD3DDevice->SetViewport( &D3DViewport ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to set the D3D Viewport!!" );
    }

    // Set our Renderstates and our Texture Stage States
    //BUGBUG: Tweak these and remove the ones uneccessary
    g_pD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    g_pD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    g_pD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    g_pD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    g_pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE);
    g_pD3DDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
    g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate4E\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define XFONT_TRUETYPE

#include <xapip.h>
#include <xdbg.h>
#include <xfont.h>
#include <stdio.h>

// Libs
#include "bitmapfile.h"
#include "harddrive.h"

#include "xfontfuncs.h"
#include "udtexture.h"
#include "constants.h"

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate2M\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#define BREAK_INTO_DEBUGGER                     _asm { int 3 }
                                                
#define APP_TITLE_NAME_A                        "GR2-M"
                                                
// Video Display Dimensions                     
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2.0f )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2.0f )
#define SCREEN_DEFAULT_FOREGROUND_COLOR         COLOR_TV_RED
#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_FONT_HEIGHT              30
#define SCREEN_DEFAULT_FONT_ALIAS_LEVEL         4
#define SCREEN_DEFAULT_FONT_STYLE               XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS

#define TEXT_GAME_RATING_INFO                   L"Rating Level 2 (M - Mature)"

// Colors                                       
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_RED                               0xFFFF0000
#define COLOR_TV_RED                            0xFF8D3232
#define COLOR_GREEN                             0xFF00FF00
#define COLOR_BLUE                              0xFF0000FF
#define COLOR_TV_LIGHT_BLUE                     0xFFA1A7FF
#define COLOR_LIGHT_YELLOW                      0xFFDDD078
#define COLOR_TV_YELLOW                         0xFFEFEF30
#define COLOR_DARK_GREEN                        0xFF357515

// File path and location constants
#define FILE_DATA_CACHE_SIZE                    5120000
#define FILE_DATA_DRIVE_A                       "t:"
#define FILE_DATA_DRIVE                         L"t:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\images"
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"
#define FILE_DATA_DEFAULT_FONT_FILENAME_A       FILE_DATA_MEDIA_DIRECTORY_A "\\tahoma.ttf"
#define FILE_DATA_DEFAULT_BG_IMAGE_FILENAME     FILE_DATA_IMAGE_DIRECTORY_A "\\background.bmp"

// Vertex Definitions
struct MYVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    cDiffuse;
};

struct MYTEXVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    diffuse;
    float       tu, tv;    // The texture coordinates
};

#define D3DFVF_MYVERTEX     ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE )
#define D3DFVF_MYTEXVERTEX  ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1 )

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate4E\xfontfuncs.cpp ===
#include "stdafx.h"
#include "xfontfuncs.h"

extern XFONT* g_pFont;

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int GetStringPixelWidth( IN WCHAR* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!!\n" );

        return -1;
    }

    unsigned int outlen = 0;        // Return value

    XFONT_GetTextExtent( g_pFont, string, length, &outlen );

    return outlen;
}


// Get the width of the char*
int GetStringPixelWidth( IN char* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( char* ):Invalid pointer passed in!!\n" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}


// Get the size of the current font
void GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetFontSize():Invalid arguments passed!!\n" );

        return;
    }

    XFONT_GetFontMetrics( g_pFont, pheight, pdecent );
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate4E\XFontFuncs.h ===
#ifndef _XFONTFUNCS_H_
#define _XFONTFUNCS_H_

// Get the pixel width of a string
int GetStringPixelWidth( IN WCHAR* string,
                         IN int length = -1 );

// Get the pixel width of a char*
int GetStringPixelWidth( IN char* string,
                         IN int length = -1 );

// Get the size of the currently selected font
void GetFontSize( unsigned int* pheight,
                  unsigned int* pdecent );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

#endif // _XFONTFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate5KA\PolyObject.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Contstructor
CPolyObject::CPolyObject()
: m_pVertexBuffer( NULL )
{
}

// Destructor
CPolyObject::~CPolyObject()
{
    // Destroy any memory, etc, that we have allocated
    CleanUp();
}


// Clean up any memory allocated, etc.
void CPolyObject::CleanUp()
{
    // Clean up our Vertex Buffer
    if( m_pVertexBuffer )
    {
        m_pVertexBuffer->Release();
        m_pVertexBuffer = NULL;
    }
}


// Initialize our data, including our vertext buffer
void CPolyObject::Initialize( IDirect3DDevice8* pD3DDevice )
{
    // Clean up anything that was previously allocated
    CleanUp();

    // Setup our vertices
    MYTEXVERTEX* pb = NULL;

    // Create our vertex buffer
    pD3DDevice->CreateVertexBuffer( sizeof( MYTEXVERTEX ) * 4, 0, 0, 0, &m_pVertexBuffer );

    m_pVertexBuffer->Lock( 0, 0, (BYTE**)&pb, 0 );

    pb[0].v.x = 0.0f;         pb[0].v.y = 0.0f;          pb[0].v.z = 0.1f; pb[0].fRHW = 0.9f; pb[0].diffuse = COLOR_WHITE; pb[0].tu = 0.0f;         pb[0].tv = 0.0f;
    pb[1].v.x = SCREEN_WIDTH; pb[1].v.y = 0.0f;          pb[1].v.z = 0.1f; pb[1].fRHW = 0.9f; pb[1].diffuse = COLOR_WHITE; pb[1].tu = SCREEN_WIDTH; pb[1].tv = 0.0f;
    pb[2].v.x = SCREEN_WIDTH; pb[2].v.y = SCREEN_HEIGHT; pb[2].v.z = 0.1f; pb[2].fRHW = 0.9f; pb[2].diffuse = COLOR_WHITE; pb[2].tu = SCREEN_WIDTH; pb[2].tv = SCREEN_HEIGHT;
    pb[3].v.x = 0.0f;         pb[3].v.y = SCREEN_HEIGHT; pb[3].v.z = 0.1f; pb[3].fRHW = 0.9f; pb[3].diffuse = COLOR_WHITE; pb[3].tu = 0.0f;         pb[3].tv = SCREEN_HEIGHT;

    m_pVertexBuffer->Unlock();
}


// Render the Poly to the screen
void CPolyObject::Render( IDirect3DDevice8* pD3DDevice )
{
    pD3DDevice->SetVertexShader( D3DFVF_MYTEXVERTEX );
    pD3DDevice->SetStreamSource( 0, m_pVertexBuffer, sizeof( MYTEXVERTEX ) );
    pD3DDevice->DrawPrimitive( D3DPT_TRIANGLEFAN, 0, 2 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate5KA\PolyObject.h ===
/******************************************************
** polyobject.h
** 
** A basic polygon object capable of rendering itself
**
** 03/09/2001
** by James N. Helm
******************************************************/

#ifndef _POLYOBJECT_H_
#define _POLYOBJECT_H_

class CPolyObject
{
public:
    // Constructors and Destructors
    CPolyObject();
    ~CPolyObject();

    // Public Properties
    
    // Public Methods
    void Initialize( IDirect3DDevice8* pD3DDevice );    // Setup our Vertex Buffer and Poly Points
    void Render( IDirect3DDevice8* pD3DDevice );        // Render the poly to the backbuffer

private:
    // Private Properties
    IDirect3DVertexBuffer8* m_pVertexBuffer;            // Vertex buffer for our Polygon

    // Private Methods
    void CleanUp();                                     // Clean up any memory we have allocated
};

#endif // _POLYOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate5KA\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define XFONT_TRUETYPE

#include <xapip.h>
#include <xdbg.h>
#include <xfont.h>
#include <stdio.h>

// Libs
#include "bitmapfile.h"
#include "harddrive.h"

#include "xfontfuncs.h"
#include "udtexture.h"
#include "constants.h"

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate5KA\xfontfuncs.cpp ===
#include "stdafx.h"
#include "xfontfuncs.h"

extern XFONT* g_pFont;

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int GetStringPixelWidth( IN WCHAR* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!!\n" );

        return -1;
    }

    unsigned int outlen = 0;        // Return value

    XFONT_GetTextExtent( g_pFont, string, length, &outlen );

    return outlen;
}


// Get the width of the char*
int GetStringPixelWidth( IN char* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( char* ):Invalid pointer passed in!!\n" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}


// Get the size of the current font
void GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetFontSize():Invalid arguments passed!!\n" );

        return;
    }

    XFONT_GetFontMetrics( g_pFont, pheight, pdecent );
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate5KA\XFontFuncs.h ===
#ifndef _XFONTFUNCS_H_
#define _XFONTFUNCS_H_

// Get the pixel width of a string
int GetStringPixelWidth( IN WCHAR* string,
                         IN int length = -1 );

// Get the pixel width of a char*
int GetStringPixelWidth( IN char* string,
                         IN int length = -1 );

// Get the size of the currently selected font
void GetFontSize( unsigned int* pheight,
                  unsigned int* pdecent );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

#endif // _XFONTFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate4E\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#define BREAK_INTO_DEBUGGER                     _asm { int 3 }
                                                
#define APP_TITLE_NAME_A                        "GR4-E"
                                                
// Video Display Dimensions                     
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2.0f )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2.0f )
#define SCREEN_DEFAULT_FOREGROUND_COLOR         COLOR_TV_RED
#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_FONT_HEIGHT              30
#define SCREEN_DEFAULT_FONT_ALIAS_LEVEL         4
#define SCREEN_DEFAULT_FONT_STYLE               XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS

#define TEXT_GAME_RATING_INFO                   L"Rating Level 4 (E - Everyone)"

// Colors                                       
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_RED                               0xFFFF0000
#define COLOR_TV_RED                            0xFF8D3232
#define COLOR_GREEN                             0xFF00FF00
#define COLOR_BLUE                              0xFF0000FF
#define COLOR_TV_LIGHT_BLUE                     0xFFA1A7FF
#define COLOR_LIGHT_YELLOW                      0xFFDDD078
#define COLOR_TV_YELLOW                         0xFFEFEF30
#define COLOR_DARK_GREEN                        0xFF357515

// File path and location constants
#define FILE_DATA_CACHE_SIZE                    5120000
#define FILE_DATA_DRIVE_A                       "t:"
#define FILE_DATA_DRIVE                         L"t:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\images"
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"
#define FILE_DATA_DEFAULT_FONT_FILENAME_A       FILE_DATA_MEDIA_DIRECTORY_A "\\tahoma.ttf"
#define FILE_DATA_DEFAULT_BG_IMAGE_FILENAME     FILE_DATA_IMAGE_DIRECTORY_A "\\background.bmp"

// Vertex Definitions
struct MYVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    cDiffuse;
};

struct MYTEXVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    diffuse;
    float       tu, tv;    // The texture coordinates
};

#define D3DFVF_MYVERTEX     ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE )
#define D3DFVF_MYTEXVERTEX  ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1 )

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate3T\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#define BREAK_INTO_DEBUGGER                     _asm { int 3 }
                                                
#define APP_TITLE_NAME_A                        "GR3-T"
                                                
// Video Display Dimensions                     
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2.0f )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2.0f )
#define SCREEN_DEFAULT_FOREGROUND_COLOR         COLOR_TV_RED
#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_FONT_HEIGHT              30
#define SCREEN_DEFAULT_FONT_ALIAS_LEVEL         4
#define SCREEN_DEFAULT_FONT_STYLE               XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS

#define TEXT_GAME_RATING_INFO                   L"Rating Level 3 (T - Teen)"

// Colors                                       
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_RED                               0xFFFF0000
#define COLOR_TV_RED                            0xFF8D3232
#define COLOR_GREEN                             0xFF00FF00
#define COLOR_BLUE                              0xFF0000FF
#define COLOR_TV_LIGHT_BLUE                     0xFFA1A7FF
#define COLOR_LIGHT_YELLOW                      0xFFDDD078
#define COLOR_TV_YELLOW                         0xFFEFEF30
#define COLOR_DARK_GREEN                        0xFF357515

// File path and location constants
#define FILE_DATA_CACHE_SIZE                    5120000
#define FILE_DATA_DRIVE_A                       "t:"
#define FILE_DATA_DRIVE                         L"t:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\images"
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"
#define FILE_DATA_DEFAULT_FONT_FILENAME_A       FILE_DATA_MEDIA_DIRECTORY_A "\\tahoma.ttf"
#define FILE_DATA_DEFAULT_BG_IMAGE_FILENAME     FILE_DATA_IMAGE_DIRECTORY_A "\\background.bmp"

// Vertex Definitions
struct MYVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    cDiffuse;
};

struct MYTEXVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    diffuse;
    float       tu, tv;    // The texture coordinates
};

#define D3DFVF_MYVERTEX     ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE )
#define D3DFVF_MYTEXVERTEX  ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1 )

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate6EC\PolyObject.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Contstructor
CPolyObject::CPolyObject()
: m_pVertexBuffer( NULL )
{
}

// Destructor
CPolyObject::~CPolyObject()
{
    // Destroy any memory, etc, that we have allocated
    CleanUp();
}


// Clean up any memory allocated, etc.
void CPolyObject::CleanUp()
{
    // Clean up our Vertex Buffer
    if( m_pVertexBuffer )
    {
        m_pVertexBuffer->Release();
        m_pVertexBuffer = NULL;
    }
}


// Initialize our data, including our vertext buffer
void CPolyObject::Initialize( IDirect3DDevice8* pD3DDevice )
{
    // Clean up anything that was previously allocated
    CleanUp();

    // Setup our vertices
    MYTEXVERTEX* pb = NULL;

    // Create our vertex buffer
    pD3DDevice->CreateVertexBuffer( sizeof( MYTEXVERTEX ) * 4, 0, 0, 0, &m_pVertexBuffer );

    m_pVertexBuffer->Lock( 0, 0, (BYTE**)&pb, 0 );

    pb[0].v.x = 0.0f;         pb[0].v.y = 0.0f;          pb[0].v.z = 0.1f; pb[0].fRHW = 0.9f; pb[0].diffuse = COLOR_WHITE; pb[0].tu = 0.0f;         pb[0].tv = 0.0f;
    pb[1].v.x = SCREEN_WIDTH; pb[1].v.y = 0.0f;          pb[1].v.z = 0.1f; pb[1].fRHW = 0.9f; pb[1].diffuse = COLOR_WHITE; pb[1].tu = SCREEN_WIDTH; pb[1].tv = 0.0f;
    pb[2].v.x = SCREEN_WIDTH; pb[2].v.y = SCREEN_HEIGHT; pb[2].v.z = 0.1f; pb[2].fRHW = 0.9f; pb[2].diffuse = COLOR_WHITE; pb[2].tu = SCREEN_WIDTH; pb[2].tv = SCREEN_HEIGHT;
    pb[3].v.x = 0.0f;         pb[3].v.y = SCREEN_HEIGHT; pb[3].v.z = 0.1f; pb[3].fRHW = 0.9f; pb[3].diffuse = COLOR_WHITE; pb[3].tu = 0.0f;         pb[3].tv = SCREEN_HEIGHT;

    m_pVertexBuffer->Unlock();
}


// Render the Poly to the screen
void CPolyObject::Render( IDirect3DDevice8* pD3DDevice )
{
    pD3DDevice->SetVertexShader( D3DFVF_MYTEXVERTEX );
    pD3DDevice->SetStreamSource( 0, m_pVertexBuffer, sizeof( MYTEXVERTEX ) );
    pD3DDevice->DrawPrimitive( D3DPT_TRIANGLEFAN, 0, 2 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate4E\GameRate.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Forward declarations
void Render();              // Render the video on to our screen and present it to the user
void CleanUp();             // Clean up memory, etc, when neccessary
BOOL Initialize();          // Initialize anything necessary for the MU Config program
BOOL InitializeD3D();       // Initalize D3D to be used by our application

// Globals
IDirect3DDevice8* g_pD3DDevice          = NULL;     // Pointer to our Direct3D Device Object
CPolyObject       g_mainDisplayPoly;                // Our main display (poly) object
CUDTexture        g_mainDisplayTexture;             // Out main display (texture) object
XFONT*            g_pFont               = NULL;     // Our Default Font Pointer
CHardDrive        g_HardDrive;                      // Xbox Hard Drive

void _cdecl main()
{
    XDBGWRN( APP_TITLE_NAME_A, "main() Entered..." );

    // Initialize the Application
    if( !Initialize() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "main():Failed to initialize!!" );

        return; // Should never return from main.  This is a bad situation
    }

    // Render Loop
    while( TRUE )
    {
        // Render the video on our screen and present it to the user
        Render();
    }

    XDBGWRN( APP_TITLE_NAME_A, "main() Exiting." );
}

void Render()
{
    g_pD3DDevice->Clear( 0, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0 );
    g_pD3DDevice->BeginScene();

    // Render the main screen object here
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    g_pD3DDevice->SetTexture( 0, g_mainDisplayTexture.GetTexture() );
    g_mainDisplayPoly.Render( g_pD3DDevice );
    g_pD3DDevice->SetTexture( 0, NULL );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    g_pD3DDevice->EndScene();
    g_pD3DDevice->Present( NULL, NULL, NULL, NULL );
}


// Clean up memory, etc, when neccessary
void CleanUp()
{
    // Clean up our D3D Device object
    if( g_pD3DDevice )
    {
        g_pD3DDevice->Release();
        g_pD3DDevice = NULL;
    }

    if( g_pFont )
    {
        XFONT_Release( g_pFont );
        g_pFont = NULL;
    }
}


// Initialize anything necessary for the MU Config program
BOOL Initialize()
{
    // Set the file cache size
    XSetFileCacheSize( FILE_DATA_CACHE_SIZE );

    // Get any launch info and display it in to the debugger
    DWORD dwLDataType;
    LAUNCH_DATA lData;
    ZeroMemory( &lData, sizeof( lData ) );

    if( ERROR_SUCCESS == XGetLaunchInfo( &dwLDataType, &lData ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Received Launch Data:" );

        if( LDT_FROM_DASHBOARD == dwLDataType )
        {
            LD_FROM_DASHBOARD* pDashData = (LD_FROM_DASHBOARD*)&lData;
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DASHBOARD" );
            XDBGWRN( APP_TITLE_NAME_A, "  Context - '%d'", pDashData->dwContext );

        }
        else if( LDT_FROM_DEBUGGER_CMDLINE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DEBUGGER CMDLINE" );
        }
        else if( LDT_TITLE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from TITLE" );
        }
        else
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from UNKNOWN" );
        }
    }

    // Check to see if our media exists on the HD -- If not, Copy it
    if( !g_HardDrive.FileExists( FILE_DATA_DEFAULT_FONT_FILENAME_A ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize(): Must Copy Media!!" );

        char pszSource[MAX_PATH+1];
        
        ZeroMemory( pszSource, MAX_PATH+1 );

        _snprintf( pszSource, MAX_PATH, "d:\\%0.8X", XeImageHeader()->Certificate->TitleID );

        // Copy the media -- Assume in it's our Title Dir
        g_HardDrive.CopyDirs( pszSource, "t:" );

        // Copy the DEFAULT.XBE to the user's E drive
        g_HardDrive.UnMapDrive( 'E' );
        g_HardDrive.MapDrive( 'E', "\\Device\\Harddisk0\\Partition1\\devkit" );
        CopyFile( "d:\\default.xbe", "e:\\GRate4E.xbe", FALSE );
        g_HardDrive.UnMapDrive( 'E' );
    }

    // Initialize Direct3D
    if( !InitializeD3D() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Failed to InitializeD3D!!" );

        return FALSE;
    }

    ////////////////////////////////////////
    // Setup and Initialize our Default FONT
    ////////////////////////////////////////
    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &g_pFont );

    if( g_pFont )
    {
        // XFONT_SetDrawingSurface( m_BackBuffer );
        XFONT_SetTextColor( g_pFont, SCREEN_DEFAULT_FOREGROUND_COLOR );
        XFONT_SetBkColor( g_pFont, SCREEN_DEFAULT_BACKGROUND_COLOR );
        XFONT_SetTextHeight( g_pFont, SCREEN_DEFAULT_FONT_HEIGHT );
        XFONT_SetTextAntialiasLevel( g_pFont, SCREEN_DEFAULT_FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( g_pFont, SCREEN_DEFAULT_FONT_STYLE );
    }
    else
    {
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize our Font!!" );
    }

    // Create our display poly and our display texture
    g_mainDisplayPoly.Initialize( g_pD3DDevice );
    g_mainDisplayTexture.Initialize( g_pD3DDevice, NULL, 1024, 1024 );

    // TODO: Render the bitmap to the poly
    BitmapFile Bitmap;
    Bitmap.read( 0, 0, FILE_DATA_DEFAULT_BG_IMAGE_FILENAME );

    g_mainDisplayTexture.Lock();

    Bitmap.render( g_pD3DDevice, g_mainDisplayTexture.GetTextureSurface() );

    void DrawText( float fX1,                               // Prints formatted text, using the default font size
                   float fY1,
                   DWORD dwFGColor,
                   DWORD dwBGColor,
                   const WCHAR* pwszFormat,
                   ... );

    
    void DrawBox( float fX1,                                // Draw a box on the screen
                  float fY1,
                  float fX2,
                  float fY2,
                  DWORD dwColor );

    int iStringLen = GetStringPixelWidth( TEXT_GAME_RATING_INFO );

    unsigned int uiFontHeight;
    unsigned int uiFontWidth;
    GetFontSize( &uiFontHeight, &uiFontWidth );

    XDBGWRN( APP_TITLE_NAME_A, "Init():uiFontHeight - '%u'", uiFontHeight );
    XDBGWRN( APP_TITLE_NAME_A, "Init():uiFontWidth  - '%u'", uiFontWidth );

    float fTopBotYAdjust   = 100.0f;
    float fTopBotBorder    = 5.0f;
    float fLeftRightBorder = 10.0f;

    float X1 = SCREEN_X_CENTER - ( iStringLen / 2.0f ) - fLeftRightBorder;
    float Y1 = SCREEN_HEIGHT - fTopBotYAdjust;

    float X2 = SCREEN_X_CENTER + ( iStringLen / 2.0f ) + fLeftRightBorder;
    float Y2 = Y1 + uiFontHeight + ( fTopBotBorder * 2 );

    g_mainDisplayTexture.DrawBox( X1, Y1, X2, Y2, COLOR_BLACK );
    g_mainDisplayTexture.DrawText( X1 + fLeftRightBorder, Y1 + fTopBotBorder, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, TEXT_GAME_RATING_INFO );

    g_mainDisplayTexture.Unlock();

    return TRUE;
}


// Initalize D3D to be used by our application
BOOL InitializeD3D()
{
    IDirect3D8* pD3D;
    HRESULT hr = S_OK;

    // Create our Direct3D Object
    pD3D = Direct3DCreate8( D3D_SDK_VERSION );
    if( NULL == pD3D )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Object!!" );

        return FALSE;
    }

    // Create our D3D Device Object
    D3DPRESENT_PARAMETERS d3dpp;
	ZeroMemory( &d3dpp, sizeof( d3dpp ) );

    d3dpp.BackBufferWidth                 = SCREEN_WIDTH;
    d3dpp.BackBufferHeight                = SCREEN_HEIGHT;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.MultiSampleType                 = D3DMULTISAMPLE_4_SAMPLES;
    d3dpp.BackBufferCount                 = 1;

    d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
    d3dpp.Windowed                        = FALSE;                   // Must be FALSE for Xbox
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.EnableAutoDepthStencil          = FALSE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
	d3dpp.FullScreen_RefreshRateInHz      = D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE; // D3DPRESENT_INTERVAL_IMMEDIATE;

    if ( FAILED ( hr = pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                           D3DDEVTYPE_HAL,
                                           NULL,
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                           &d3dpp,
                                           &g_pD3DDevice ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Device Object!!" );
    }

    // Release the D3D Object
    // It's ok to simply release this object, as we know we cannot be here if the D3D Object failed creation
    pD3D->Release();
    pD3D = NULL;

    // If the device failed to create, simply abort the rest of the D3D Initialization
    if( !g_pD3DDevice )
    {
        return FALSE;
    }

    // Create our Viewport
    D3DVIEWPORT8 D3DViewport;

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = SCREEN_WIDTH;
    D3DViewport.Height = SCREEN_HEIGHT;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( hr = g_pD3DDevice->SetViewport( &D3DViewport ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to set the D3D Viewport!!" );
    }

    // Set our Renderstates and our Texture Stage States
    //BUGBUG: Tweak these and remove the ones uneccessary
    g_pD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    g_pD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    g_pD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    g_pD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    g_pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE);
    g_pD3DDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
    g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate6EC\PolyObject.h ===
/******************************************************
** polyobject.h
** 
** A basic polygon object capable of rendering itself
**
** 03/09/2001
** by James N. Helm
******************************************************/

#ifndef _POLYOBJECT_H_
#define _POLYOBJECT_H_

class CPolyObject
{
public:
    // Constructors and Destructors
    CPolyObject();
    ~CPolyObject();

    // Public Properties
    
    // Public Methods
    void Initialize( IDirect3DDevice8* pD3DDevice );    // Setup our Vertex Buffer and Poly Points
    void Render( IDirect3DDevice8* pD3DDevice );        // Render the poly to the backbuffer

private:
    // Private Properties
    IDirect3DVertexBuffer8* m_pVertexBuffer;            // Vertex buffer for our Polygon

    // Private Methods
    void CleanUp();                                     // Clean up any memory we have allocated
};

#endif // _POLYOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate5KA\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#define BREAK_INTO_DEBUGGER                     _asm { int 3 }
                                                
#define APP_TITLE_NAME_A                        "GR5-KA"
                                                
// Video Display Dimensions                     
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2.0f )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2.0f )
#define SCREEN_DEFAULT_FOREGROUND_COLOR         COLOR_TV_RED
#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_FONT_HEIGHT              30
#define SCREEN_DEFAULT_FONT_ALIAS_LEVEL         4
#define SCREEN_DEFAULT_FONT_STYLE               XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS

#define TEXT_GAME_RATING_INFO                   L"Rating Level 5 (K-A - Kids to Adults)"

// Colors                                       
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_RED                               0xFFFF0000
#define COLOR_TV_RED                            0xFF8D3232
#define COLOR_GREEN                             0xFF00FF00
#define COLOR_BLUE                              0xFF0000FF
#define COLOR_TV_LIGHT_BLUE                     0xFFA1A7FF
#define COLOR_LIGHT_YELLOW                      0xFFDDD078
#define COLOR_TV_YELLOW                         0xFFEFEF30
#define COLOR_DARK_GREEN                        0xFF357515

// File path and location constants
#define FILE_DATA_CACHE_SIZE                    5120000
#define FILE_DATA_DRIVE_A                       "t:"
#define FILE_DATA_DRIVE                         L"t:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\images"
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"
#define FILE_DATA_DEFAULT_FONT_FILENAME_A       FILE_DATA_MEDIA_DIRECTORY_A "\\tahoma.ttf"
#define FILE_DATA_DEFAULT_BG_IMAGE_FILENAME     FILE_DATA_IMAGE_DIRECTORY_A "\\background.bmp"

// Vertex Definitions
struct MYVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    cDiffuse;
};

struct MYTEXVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    diffuse;
    float       tu, tv;    // The texture coordinates
};

#define D3DFVF_MYVERTEX     ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE )
#define D3DFVF_MYTEXVERTEX  ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1 )

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate3T\GameRate.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Forward declarations
void Render();              // Render the video on to our screen and present it to the user
void CleanUp();             // Clean up memory, etc, when neccessary
BOOL Initialize();          // Initialize anything necessary for the MU Config program
BOOL InitializeD3D();       // Initalize D3D to be used by our application

// Globals
IDirect3DDevice8* g_pD3DDevice          = NULL;     // Pointer to our Direct3D Device Object
CPolyObject       g_mainDisplayPoly;                // Our main display (poly) object
CUDTexture        g_mainDisplayTexture;             // Out main display (texture) object
XFONT*            g_pFont               = NULL;     // Our Default Font Pointer
CHardDrive        g_HardDrive;                      // Xbox Hard Drive

void _cdecl main()
{
    XDBGWRN( APP_TITLE_NAME_A, "main() Entered..." );

    // Initialize the Application
    if( !Initialize() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "main():Failed to initialize!!" );

        return; // Should never return from main.  This is a bad situation
    }

    // Render Loop
    while( TRUE )
    {
        // Render the video on our screen and present it to the user
        Render();
    }

    XDBGWRN( APP_TITLE_NAME_A, "main() Exiting." );
}

void Render()
{
    g_pD3DDevice->Clear( 0, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0 );
    g_pD3DDevice->BeginScene();

    // Render the main screen object here
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    g_pD3DDevice->SetTexture( 0, g_mainDisplayTexture.GetTexture() );
    g_mainDisplayPoly.Render( g_pD3DDevice );
    g_pD3DDevice->SetTexture( 0, NULL );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    g_pD3DDevice->EndScene();
    g_pD3DDevice->Present( NULL, NULL, NULL, NULL );
}


// Clean up memory, etc, when neccessary
void CleanUp()
{
    // Clean up our D3D Device object
    if( g_pD3DDevice )
    {
        g_pD3DDevice->Release();
        g_pD3DDevice = NULL;
    }

    if( g_pFont )
    {
        XFONT_Release( g_pFont );
        g_pFont = NULL;
    }
}


// Initialize anything necessary for the MU Config program
BOOL Initialize()
{
    // Set the file cache size
    XSetFileCacheSize( FILE_DATA_CACHE_SIZE );

    // Get any launch info and display it in to the debugger
    DWORD dwLDataType;
    LAUNCH_DATA lData;
    ZeroMemory( &lData, sizeof( lData ) );

    if( ERROR_SUCCESS == XGetLaunchInfo( &dwLDataType, &lData ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Received Launch Data:" );

        if( LDT_FROM_DASHBOARD == dwLDataType )
        {
            LD_FROM_DASHBOARD* pDashData = (LD_FROM_DASHBOARD*)&lData;
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DASHBOARD" );
            XDBGWRN( APP_TITLE_NAME_A, "  Context - '%d'", pDashData->dwContext );

        }
        else if( LDT_FROM_DEBUGGER_CMDLINE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DEBUGGER CMDLINE" );
        }
        else if( LDT_TITLE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from TITLE" );
        }
        else
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from UNKNOWN" );
        }
    }

    // Check to see if our media exists on the HD -- If not, Copy it
    if( !g_HardDrive.FileExists( FILE_DATA_DEFAULT_FONT_FILENAME_A ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize(): Must Copy Media!!" );

        char pszSource[MAX_PATH+1];
        
        ZeroMemory( pszSource, MAX_PATH+1 );

        _snprintf( pszSource, MAX_PATH, "d:\\%0.8X", XeImageHeader()->Certificate->TitleID );

        // Copy the media -- Assume in it's our Title Dir
        g_HardDrive.CopyDirs( pszSource, "t:" );

        // Copy the DEFAULT.XBE to the user's E drive
        g_HardDrive.UnMapDrive( 'E' );
        g_HardDrive.MapDrive( 'E', "\\Device\\Harddisk0\\Partition1\\devkit" );
        CopyFile( "d:\\default.xbe", "e:\\GRate3T.xbe", FALSE );
        g_HardDrive.UnMapDrive( 'E' );
    }
    
    // Initialize Direct3D
    if( !InitializeD3D() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Failed to InitializeD3D!!" );

        return FALSE;
    }

    ////////////////////////////////////////
    // Setup and Initialize our Default FONT
    ////////////////////////////////////////
    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &g_pFont );

    if( g_pFont )
    {
        // XFONT_SetDrawingSurface( m_BackBuffer );
        XFONT_SetTextColor( g_pFont, SCREEN_DEFAULT_FOREGROUND_COLOR );
        XFONT_SetBkColor( g_pFont, SCREEN_DEFAULT_BACKGROUND_COLOR );
        XFONT_SetTextHeight( g_pFont, SCREEN_DEFAULT_FONT_HEIGHT );
        XFONT_SetTextAntialiasLevel( g_pFont, SCREEN_DEFAULT_FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( g_pFont, SCREEN_DEFAULT_FONT_STYLE );
    }
    else
    {
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize our Font!!" );
    }

    // Create our display poly and our display texture
    g_mainDisplayPoly.Initialize( g_pD3DDevice );
    g_mainDisplayTexture.Initialize( g_pD3DDevice, NULL, 1024, 1024 );

    // TODO: Render the bitmap to the poly
    BitmapFile Bitmap;
    Bitmap.read( 0, 0, FILE_DATA_DEFAULT_BG_IMAGE_FILENAME );

    g_mainDisplayTexture.Lock();

    Bitmap.render( g_pD3DDevice, g_mainDisplayTexture.GetTextureSurface() );

    void DrawText( float fX1,                               // Prints formatted text, using the default font size
                   float fY1,
                   DWORD dwFGColor,
                   DWORD dwBGColor,
                   const WCHAR* pwszFormat,
                   ... );

    
    void DrawBox( float fX1,                                // Draw a box on the screen
                  float fY1,
                  float fX2,
                  float fY2,
                  DWORD dwColor );

    int iStringLen = GetStringPixelWidth( TEXT_GAME_RATING_INFO );

    unsigned int uiFontHeight;
    unsigned int uiFontWidth;
    GetFontSize( &uiFontHeight, &uiFontWidth );

    XDBGWRN( APP_TITLE_NAME_A, "Init():uiFontHeight - '%u'", uiFontHeight );
    XDBGWRN( APP_TITLE_NAME_A, "Init():uiFontWidth  - '%u'", uiFontWidth );

    float fTopBotYAdjust   = 100.0f;
    float fTopBotBorder    = 5.0f;
    float fLeftRightBorder = 10.0f;

    float X1 = SCREEN_X_CENTER - ( iStringLen / 2.0f ) - fLeftRightBorder;
    float Y1 = SCREEN_HEIGHT - fTopBotYAdjust;

    float X2 = SCREEN_X_CENTER + ( iStringLen / 2.0f ) + fLeftRightBorder;
    float Y2 = Y1 + uiFontHeight + ( fTopBotBorder * 2 );

    g_mainDisplayTexture.DrawBox( X1, Y1, X2, Y2, COLOR_BLACK );
    g_mainDisplayTexture.DrawText( X1 + fLeftRightBorder, Y1 + fTopBotBorder, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, TEXT_GAME_RATING_INFO );

    g_mainDisplayTexture.Unlock();

    return TRUE;
}


// Initalize D3D to be used by our application
BOOL InitializeD3D()
{
    IDirect3D8* pD3D;
    HRESULT hr = S_OK;

    // Create our Direct3D Object
    pD3D = Direct3DCreate8( D3D_SDK_VERSION );
    if( NULL == pD3D )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Object!!" );

        return FALSE;
    }

    // Create our D3D Device Object
    D3DPRESENT_PARAMETERS d3dpp;
	ZeroMemory( &d3dpp, sizeof( d3dpp ) );

    d3dpp.BackBufferWidth                 = SCREEN_WIDTH;
    d3dpp.BackBufferHeight                = SCREEN_HEIGHT;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.MultiSampleType                 = D3DMULTISAMPLE_4_SAMPLES;
    d3dpp.BackBufferCount                 = 1;

    d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
    d3dpp.Windowed                        = FALSE;                   // Must be FALSE for Xbox
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.EnableAutoDepthStencil          = FALSE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
	d3dpp.FullScreen_RefreshRateInHz      = D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE; // D3DPRESENT_INTERVAL_IMMEDIATE;

    if ( FAILED ( hr = pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                           D3DDEVTYPE_HAL,
                                           NULL,
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                           &d3dpp,
                                           &g_pD3DDevice ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Device Object!!" );
    }

    // Release the D3D Object
    // It's ok to simply release this object, as we know we cannot be here if the D3D Object failed creation
    pD3D->Release();
    pD3D = NULL;

    // If the device failed to create, simply abort the rest of the D3D Initialization
    if( !g_pD3DDevice )
    {
        return FALSE;
    }

    // Create our Viewport
    D3DVIEWPORT8 D3DViewport;

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = SCREEN_WIDTH;
    D3DViewport.Height = SCREEN_HEIGHT;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( hr = g_pD3DDevice->SetViewport( &D3DViewport ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to set the D3D Viewport!!" );
    }

    // Set our Renderstates and our Texture Stage States
    //BUGBUG: Tweak these and remove the ones uneccessary
    g_pD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    g_pD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    g_pD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    g_pD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    g_pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE);
    g_pD3DDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
    g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate6EC\XFontFuncs.h ===
#ifndef _XFONTFUNCS_H_
#define _XFONTFUNCS_H_

// Get the pixel width of a string
int GetStringPixelWidth( IN WCHAR* string,
                         IN int length = -1 );

// Get the pixel width of a char*
int GetStringPixelWidth( IN char* string,
                         IN int length = -1 );

// Get the size of the currently selected font
void GetFontSize( unsigned int* pheight,
                  unsigned int* pdecent );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

#endif // _XFONTFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate6EC\xfontfuncs.cpp ===
#include "stdafx.h"
#include "xfontfuncs.h"

extern XFONT* g_pFont;

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int GetStringPixelWidth( IN WCHAR* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!!\n" );

        return -1;
    }

    unsigned int outlen = 0;        // Return value

    XFONT_GetTextExtent( g_pFont, string, length, &outlen );

    return outlen;
}


// Get the width of the char*
int GetStringPixelWidth( IN char* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( char* ):Invalid pointer passed in!!\n" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}


// Get the size of the current font
void GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetFontSize():Invalid arguments passed!!\n" );

        return;
    }

    XFONT_GetFontMetrics( g_pFont, pheight, pdecent );
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate5KA\GameRate.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Forward declarations
void Render();              // Render the video on to our screen and present it to the user
void CleanUp();             // Clean up memory, etc, when neccessary
BOOL Initialize();          // Initialize anything necessary for the MU Config program
BOOL InitializeD3D();       // Initalize D3D to be used by our application

// Globals
IDirect3DDevice8* g_pD3DDevice          = NULL;     // Pointer to our Direct3D Device Object
CPolyObject       g_mainDisplayPoly;                // Our main display (poly) object
CUDTexture        g_mainDisplayTexture;             // Out main display (texture) object
XFONT*            g_pFont               = NULL;     // Our Default Font Pointer
CHardDrive        g_HardDrive;                      // Xbox Hard Drive

void _cdecl main()
{
    XDBGWRN( APP_TITLE_NAME_A, "main() Entered..." );

    // Initialize the Application
    if( !Initialize() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "main():Failed to initialize!!" );

        return; // Should never return from main.  This is a bad situation
    }

    // Render Loop
    while( TRUE )
    {
        // Render the video on our screen and present it to the user
        Render();
    }

    XDBGWRN( APP_TITLE_NAME_A, "main() Exiting." );
}

void Render()
{
    g_pD3DDevice->Clear( 0, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0 );
    g_pD3DDevice->BeginScene();

    // Render the main screen object here
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    g_pD3DDevice->SetTexture( 0, g_mainDisplayTexture.GetTexture() );
    g_mainDisplayPoly.Render( g_pD3DDevice );
    g_pD3DDevice->SetTexture( 0, NULL );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    g_pD3DDevice->EndScene();
    g_pD3DDevice->Present( NULL, NULL, NULL, NULL );
}


// Clean up memory, etc, when neccessary
void CleanUp()
{
    // Clean up our D3D Device object
    if( g_pD3DDevice )
    {
        g_pD3DDevice->Release();
        g_pD3DDevice = NULL;
    }

    if( g_pFont )
    {
        XFONT_Release( g_pFont );
        g_pFont = NULL;
    }
}


// Initialize anything necessary for the MU Config program
BOOL Initialize()
{
    // Set the file cache size
    XSetFileCacheSize( FILE_DATA_CACHE_SIZE );

    // Get any launch info and display it in to the debugger
    DWORD dwLDataType;
    LAUNCH_DATA lData;
    ZeroMemory( &lData, sizeof( lData ) );

    if( ERROR_SUCCESS == XGetLaunchInfo( &dwLDataType, &lData ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Received Launch Data:" );

        if( LDT_FROM_DASHBOARD == dwLDataType )
        {
            LD_FROM_DASHBOARD* pDashData = (LD_FROM_DASHBOARD*)&lData;
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DASHBOARD" );
            XDBGWRN( APP_TITLE_NAME_A, "  Context - '%d'", pDashData->dwContext );

        }
        else if( LDT_FROM_DEBUGGER_CMDLINE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DEBUGGER CMDLINE" );
        }
        else if( LDT_TITLE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from TITLE" );
        }
        else
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from UNKNOWN" );
        }
    }

    // Check to see if our media exists on the HD -- If not, Copy it
    if( !g_HardDrive.FileExists( FILE_DATA_DEFAULT_FONT_FILENAME_A ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize(): Must Copy Media!!" );

        char pszSource[MAX_PATH+1];
        
        ZeroMemory( pszSource, MAX_PATH+1 );

        _snprintf( pszSource, MAX_PATH, "d:\\%0.8X", XeImageHeader()->Certificate->TitleID );

        // Copy the media -- Assume in it's our Title Dir
        g_HardDrive.CopyDirs( pszSource, "t:" );

        // Copy the DEFAULT.XBE to the user's E drive
        g_HardDrive.UnMapDrive( 'E' );
        g_HardDrive.MapDrive( 'E', "\\Device\\Harddisk0\\Partition1\\devkit" );
        CopyFile( "d:\\default.xbe", "e:\\GRate5KA.xbe", FALSE );
        g_HardDrive.UnMapDrive( 'E' );
    }

    // Initialize Direct3D
    if( !InitializeD3D() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Failed to InitializeD3D!!" );

        return FALSE;
    }

    ////////////////////////////////////////
    // Setup and Initialize our Default FONT
    ////////////////////////////////////////
    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &g_pFont );

    if( g_pFont )
    {
        // XFONT_SetDrawingSurface( m_BackBuffer );
        XFONT_SetTextColor( g_pFont, SCREEN_DEFAULT_FOREGROUND_COLOR );
        XFONT_SetBkColor( g_pFont, SCREEN_DEFAULT_BACKGROUND_COLOR );
        XFONT_SetTextHeight( g_pFont, SCREEN_DEFAULT_FONT_HEIGHT );
        XFONT_SetTextAntialiasLevel( g_pFont, SCREEN_DEFAULT_FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( g_pFont, SCREEN_DEFAULT_FONT_STYLE );
    }
    else
    {
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize our Font!!" );
    }

    // Create our display poly and our display texture
    g_mainDisplayPoly.Initialize( g_pD3DDevice );
    g_mainDisplayTexture.Initialize( g_pD3DDevice, NULL, 1024, 1024 );

    // TODO: Render the bitmap to the poly
    BitmapFile Bitmap;
    Bitmap.read( 0, 0, FILE_DATA_DEFAULT_BG_IMAGE_FILENAME );

    g_mainDisplayTexture.Lock();

    Bitmap.render( g_pD3DDevice, g_mainDisplayTexture.GetTextureSurface() );

    void DrawText( float fX1,                               // Prints formatted text, using the default font size
                   float fY1,
                   DWORD dwFGColor,
                   DWORD dwBGColor,
                   const WCHAR* pwszFormat,
                   ... );

    
    void DrawBox( float fX1,                                // Draw a box on the screen
                  float fY1,
                  float fX2,
                  float fY2,
                  DWORD dwColor );

    int iStringLen = GetStringPixelWidth( TEXT_GAME_RATING_INFO );

    unsigned int uiFontHeight;
    unsigned int uiFontWidth;
    GetFontSize( &uiFontHeight, &uiFontWidth );

    XDBGWRN( APP_TITLE_NAME_A, "Init():uiFontHeight - '%u'", uiFontHeight );
    XDBGWRN( APP_TITLE_NAME_A, "Init():uiFontWidth  - '%u'", uiFontWidth );

    float fTopBotYAdjust   = 100.0f;
    float fTopBotBorder    = 5.0f;
    float fLeftRightBorder = 10.0f;

    float X1 = SCREEN_X_CENTER - ( iStringLen / 2.0f ) - fLeftRightBorder;
    float Y1 = SCREEN_HEIGHT - fTopBotYAdjust;

    float X2 = SCREEN_X_CENTER + ( iStringLen / 2.0f ) + fLeftRightBorder;
    float Y2 = Y1 + uiFontHeight + ( fTopBotBorder * 2 );

    g_mainDisplayTexture.DrawBox( X1, Y1, X2, Y2, COLOR_BLACK );
    g_mainDisplayTexture.DrawText( X1 + fLeftRightBorder, Y1 + fTopBotBorder, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, TEXT_GAME_RATING_INFO );

    g_mainDisplayTexture.Unlock();

    return TRUE;
}


// Initalize D3D to be used by our application
BOOL InitializeD3D()
{
    IDirect3D8* pD3D;
    HRESULT hr = S_OK;

    // Create our Direct3D Object
    pD3D = Direct3DCreate8( D3D_SDK_VERSION );
    if( NULL == pD3D )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Object!!" );

        return FALSE;
    }

    // Create our D3D Device Object
    D3DPRESENT_PARAMETERS d3dpp;
	ZeroMemory( &d3dpp, sizeof( d3dpp ) );

    d3dpp.BackBufferWidth                 = SCREEN_WIDTH;
    d3dpp.BackBufferHeight                = SCREEN_HEIGHT;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.MultiSampleType                 = D3DMULTISAMPLE_4_SAMPLES;
    d3dpp.BackBufferCount                 = 1;

    d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
    d3dpp.Windowed                        = FALSE;                   // Must be FALSE for Xbox
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.EnableAutoDepthStencil          = FALSE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
	d3dpp.FullScreen_RefreshRateInHz      = D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE; // D3DPRESENT_INTERVAL_IMMEDIATE;

    if ( FAILED ( hr = pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                           D3DDEVTYPE_HAL,
                                           NULL,
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                           &d3dpp,
                                           &g_pD3DDevice ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Device Object!!" );
    }

    // Release the D3D Object
    // It's ok to simply release this object, as we know we cannot be here if the D3D Object failed creation
    pD3D->Release();
    pD3D = NULL;

    // If the device failed to create, simply abort the rest of the D3D Initialization
    if( !g_pD3DDevice )
    {
        return FALSE;
    }

    // Create our Viewport
    D3DVIEWPORT8 D3DViewport;

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = SCREEN_WIDTH;
    D3DViewport.Height = SCREEN_HEIGHT;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( hr = g_pD3DDevice->SetViewport( &D3DViewport ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to set the D3D Viewport!!" );
    }

    // Set our Renderstates and our Texture Stage States
    //BUGBUG: Tweak these and remove the ones uneccessary
    g_pD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    g_pD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    g_pD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    g_pD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    g_pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE);
    g_pD3DDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
    g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion1\PolyObject.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Contstructor
CPolyObject::CPolyObject()
: m_pVertexBuffer( NULL )
{
}

// Destructor
CPolyObject::~CPolyObject()
{
    // Destroy any memory, etc, that we have allocated
    CleanUp();
}


// Clean up any memory allocated, etc.
void CPolyObject::CleanUp()
{
    // Clean up our Vertex Buffer
    if( m_pVertexBuffer )
    {
        m_pVertexBuffer->Release();
        m_pVertexBuffer = NULL;
    }
}


// Initialize our data, including our vertext buffer
void CPolyObject::Initialize( IDirect3DDevice8* pD3DDevice )
{
    // Clean up anything that was previously allocated
    CleanUp();

    // Setup our vertices
    MYTEXVERTEX* pb = NULL;

    // Create our vertex buffer
    pD3DDevice->CreateVertexBuffer( sizeof( MYTEXVERTEX ) * 4, 0, 0, 0, &m_pVertexBuffer );

    m_pVertexBuffer->Lock( 0, 0, (BYTE**)&pb, 0 );

    pb[0].v.x = 0.0f;         pb[0].v.y = 0.0f;          pb[0].v.z = 0.1f; pb[0].fRHW = 0.9f; pb[0].diffuse = COLOR_WHITE; pb[0].tu = 0.0f;         pb[0].tv = 0.0f;
    pb[1].v.x = SCREEN_WIDTH; pb[1].v.y = 0.0f;          pb[1].v.z = 0.1f; pb[1].fRHW = 0.9f; pb[1].diffuse = COLOR_WHITE; pb[1].tu = SCREEN_WIDTH; pb[1].tv = 0.0f;
    pb[2].v.x = SCREEN_WIDTH; pb[2].v.y = SCREEN_HEIGHT; pb[2].v.z = 0.1f; pb[2].fRHW = 0.9f; pb[2].diffuse = COLOR_WHITE; pb[2].tu = SCREEN_WIDTH; pb[2].tv = SCREEN_HEIGHT;
    pb[3].v.x = 0.0f;         pb[3].v.y = SCREEN_HEIGHT; pb[3].v.z = 0.1f; pb[3].fRHW = 0.9f; pb[3].diffuse = COLOR_WHITE; pb[3].tu = 0.0f;         pb[3].tv = SCREEN_HEIGHT;

    m_pVertexBuffer->Unlock();
}


// Render the Poly to the screen
void CPolyObject::Render( IDirect3DDevice8* pD3DDevice )
{
    pD3DDevice->SetVertexShader( D3DFVF_MYTEXVERTEX );
    pD3DDevice->SetStreamSource( 0, m_pVertexBuffer, sizeof( MYTEXVERTEX ) );
    pD3DDevice->DrawPrimitive( D3DPT_TRIANGLEFAN, 0, 2 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion1\PolyObject.h ===
/******************************************************
** polyobject.h
** 
** A basic polygon object capable of rendering itself
**
** 03/09/2001
** by James N. Helm
******************************************************/

#ifndef _POLYOBJECT_H_
#define _POLYOBJECT_H_

class CPolyObject
{
public:
    // Constructors and Destructors
    CPolyObject();
    ~CPolyObject();

    // Public Properties
    
    // Public Methods
    void Initialize( IDirect3DDevice8* pD3DDevice );    // Setup our Vertex Buffer and Poly Points
    void Render( IDirect3DDevice8* pD3DDevice );        // Render the poly to the backbuffer

private:
    // Private Properties
    IDirect3DVertexBuffer8* m_pVertexBuffer;            // Vertex buffer for our Polygon

    // Private Methods
    void CleanUp();                                     // Clean up any memory we have allocated
};

#endif // _POLYOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion1\XFontFuncs.h ===
#ifndef _XFONTFUNCS_H_
#define _XFONTFUNCS_H_

// Get the pixel width of a string
int GetStringPixelWidth( IN WCHAR* string,
                         IN int length = -1 );

// Get the pixel width of a char*
int GetStringPixelWidth( IN char* string,
                         IN int length = -1 );

// Get the size of the currently selected font
void GetFontSize( unsigned int* pheight,
                  unsigned int* pdecent );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

#endif // _XFONTFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion1\xfontfuncs.cpp ===
#include "stdafx.h"
#include "xfontfuncs.h"

extern XFONT* g_pFont;

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int GetStringPixelWidth( IN WCHAR* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!!\n" );

        return -1;
    }

    unsigned int outlen = 0;        // Return value

    XFONT_GetTextExtent( g_pFont, string, length, &outlen );

    return outlen;
}


// Get the width of the char*
int GetStringPixelWidth( IN char* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( char* ):Invalid pointer passed in!!\n" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}


// Get the size of the current font
void GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetFontSize():Invalid arguments passed!!\n" );

        return;
    }

    XFONT_GetFontMetrics( g_pFont, pheight, pdecent );
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate6EC\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define XFONT_TRUETYPE

#include <xapip.h>
#include <xdbg.h>
#include <xfont.h>
#include <stdio.h>

// Libs
#include "bitmapfile.h"
#include "harddrive.h"
#include "wavemedia.h"

#include "xfontfuncs.h"
#include "udtexture.h"
#include "constants.h"

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion2\PolyObject.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Contstructor
CPolyObject::CPolyObject()
: m_pVertexBuffer( NULL )
{
}

// Destructor
CPolyObject::~CPolyObject()
{
    // Destroy any memory, etc, that we have allocated
    CleanUp();
}


// Clean up any memory allocated, etc.
void CPolyObject::CleanUp()
{
    // Clean up our Vertex Buffer
    if( m_pVertexBuffer )
    {
        m_pVertexBuffer->Release();
        m_pVertexBuffer = NULL;
    }
}


// Initialize our data, including our vertext buffer
void CPolyObject::Initialize( IDirect3DDevice8* pD3DDevice )
{
    // Clean up anything that was previously allocated
    CleanUp();

    // Setup our vertices
    MYTEXVERTEX* pb = NULL;

    // Create our vertex buffer
    pD3DDevice->CreateVertexBuffer( sizeof( MYTEXVERTEX ) * 4, 0, 0, 0, &m_pVertexBuffer );

    m_pVertexBuffer->Lock( 0, 0, (BYTE**)&pb, 0 );

    pb[0].v.x = 0.0f;         pb[0].v.y = 0.0f;          pb[0].v.z = 0.1f; pb[0].fRHW = 0.9f; pb[0].diffuse = COLOR_WHITE; pb[0].tu = 0.0f;         pb[0].tv = 0.0f;
    pb[1].v.x = SCREEN_WIDTH; pb[1].v.y = 0.0f;          pb[1].v.z = 0.1f; pb[1].fRHW = 0.9f; pb[1].diffuse = COLOR_WHITE; pb[1].tu = SCREEN_WIDTH; pb[1].tv = 0.0f;
    pb[2].v.x = SCREEN_WIDTH; pb[2].v.y = SCREEN_HEIGHT; pb[2].v.z = 0.1f; pb[2].fRHW = 0.9f; pb[2].diffuse = COLOR_WHITE; pb[2].tu = SCREEN_WIDTH; pb[2].tv = SCREEN_HEIGHT;
    pb[3].v.x = 0.0f;         pb[3].v.y = SCREEN_HEIGHT; pb[3].v.z = 0.1f; pb[3].fRHW = 0.9f; pb[3].diffuse = COLOR_WHITE; pb[3].tu = 0.0f;         pb[3].tv = SCREEN_HEIGHT;

    m_pVertexBuffer->Unlock();
}


// Render the Poly to the screen
void CPolyObject::Render( IDirect3DDevice8* pD3DDevice )
{
    pD3DDevice->SetVertexShader( D3DFVF_MYTEXVERTEX );
    pD3DDevice->SetStreamSource( 0, m_pVertexBuffer, sizeof( MYTEXVERTEX ) );
    pD3DDevice->DrawPrimitive( D3DPT_TRIANGLEFAN, 0, 2 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion1\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define XFONT_TRUETYPE

#include <xapip.h>
#include <xdbg.h>
#include <xfont.h>
#include <stdio.h>

// Libs
#include "bitmapfile.h"
#include "harddrive.h"
#include "wavemedia.h"

#include "xfontfuncs.h"
#include "udtexture.h"
#include "constants.h"

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate6EC\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#define BREAK_INTO_DEBUGGER                     _asm { int 3 }
                                                
#define APP_TITLE_NAME_A                        "GR6-EC"
                                                
// Video Display Dimensions                     
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2.0f )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2.0f )
#define SCREEN_DEFAULT_FOREGROUND_COLOR         COLOR_TV_RED
#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_FONT_HEIGHT              32
#define SCREEN_DEFAULT_FONT_ALIAS_LEVEL         4
#define SCREEN_DEFAULT_FONT_STYLE               XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS

#define TEXT_GAME_RATING_INFO                   L"Rating Level 6 (EC - Early Childhood)"

// Colors                                       
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_RED                               0xFFFF0000
#define COLOR_TV_RED                            0xFF8D3232
#define COLOR_GREEN                             0xFF00FF00
#define COLOR_BLUE                              0xFF0000FF
#define COLOR_TV_LIGHT_BLUE                     0xFFA1A7FF
#define COLOR_LIGHT_YELLOW                      0xFFDDD078
#define COLOR_TV_YELLOW                         0xFFEFEF30
#define COLOR_DARK_GREEN                        0xFF357515

// File path and location constants
#define FILE_DATA_CACHE_SIZE                    5120000
#define FILE_DATA_DRIVE_A                       "t:"
#define FILE_DATA_DRIVE                         L"t:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\images"
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"
#define FILE_DATA_DEFAULT_FONT_FILENAME_A       FILE_DATA_MEDIA_DIRECTORY_A "\\tahoma.ttf"
#define FILE_DATA_DEFAULT_STARTSOUND_FILENAME_A FILE_DATA_MEDIA_DIRECTORY_A "\\startsound.wav"
#define FILE_DATA_DEFAULT_BG_IMAGE_FILENAME     FILE_DATA_IMAGE_DIRECTORY_A "\\background.bmp"

// Vertex Definitions
struct MYVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    cDiffuse;
};

struct MYTEXVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    diffuse;
    float       tu, tv;    // The texture coordinates
};

#define D3DFVF_MYVERTEX     ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE )
#define D3DFVF_MYTEXVERTEX  ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1 )

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion2\PolyObject.h ===
/******************************************************
** polyobject.h
** 
** A basic polygon object capable of rendering itself
**
** 03/09/2001
** by James N. Helm
******************************************************/

#ifndef _POLYOBJECT_H_
#define _POLYOBJECT_H_

class CPolyObject
{
public:
    // Constructors and Destructors
    CPolyObject();
    ~CPolyObject();

    // Public Properties
    
    // Public Methods
    void Initialize( IDirect3DDevice8* pD3DDevice );    // Setup our Vertex Buffer and Poly Points
    void Render( IDirect3DDevice8* pD3DDevice );        // Render the poly to the backbuffer

private:
    // Private Properties
    IDirect3DVertexBuffer8* m_pVertexBuffer;            // Vertex buffer for our Polygon

    // Private Methods
    void CleanUp();                                     // Clean up any memory we have allocated
};

#endif // _POLYOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRatings\GRate6EC\GameRate.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Forward declarations
void Render();              // Render the video on to our screen and present it to the user
void CleanUp();             // Clean up memory, etc, when neccessary
BOOL Initialize();          // Initialize anything necessary for the MU Config program
BOOL InitializeD3D();       // Initalize D3D to be used by our application
HRESULT InitDSound( void );

// Globals
IDirect3DDevice8* g_pD3DDevice          = NULL;     // Pointer to our Direct3D Device Object
LPDIRECTSOUND     g_pDSound             = NULL;     // Pointer to our DirectSound Object
CPolyObject       g_mainDisplayPoly;                // Our main display (poly) object
CUDTexture        g_mainDisplayTexture;             // Out main display (texture) object
XFONT*            g_pFont               = NULL;     // Our Default Font Pointer
CHardDrive        g_HardDrive;                      // Xbox Hard Drive
BOOL              g_StartSoundPlayed    = FALSE;    // Used to determine if we've already played the start sound

void _cdecl main()
{
    XDBGWRN( APP_TITLE_NAME_A, "main() Entered..." );

    // Initialize the Application
    if( !Initialize() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "main():Failed to initialize!!" );

        return; // Should never return from main.  This is a bad situation
    }

    CWaveMedia StartSound;
    StartSound.Init( g_pDSound, FILE_DATA_DEFAULT_STARTSOUND_FILENAME_A );

    // Render Loop
    while( TRUE )
    {
        // Render the video on our screen and present it to the user
        Render();

        if( !g_StartSoundPlayed )
        {
            g_StartSoundPlayed = TRUE;

            StartSound.Play();
        }
    }

    XDBGWRN( APP_TITLE_NAME_A, "main() Exiting." );
}

void Render()
{
    g_pD3DDevice->Clear( 0, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0 );
    g_pD3DDevice->BeginScene();

    // Render the main screen object here
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    g_pD3DDevice->SetTexture( 0, g_mainDisplayTexture.GetTexture() );
    g_mainDisplayPoly.Render( g_pD3DDevice );
    g_pD3DDevice->SetTexture( 0, NULL );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    g_pD3DDevice->EndScene();
    g_pD3DDevice->Present( NULL, NULL, NULL, NULL );
}


// Clean up memory, etc, when neccessary
void CleanUp()
{
    // Clean up our D3D Device object
    if( g_pD3DDevice )
    {
        g_pD3DDevice->Release();
        g_pD3DDevice = NULL;
    }

    if( g_pFont )
    {
        XFONT_Release( g_pFont );
        g_pFont = NULL;
    }

    // Clean up DSound
    if( NULL != g_pDSound )
    {
        g_pDSound->Release();
        g_pDSound = NULL;
    }
}


// Initialize anything necessary for the MU Config program
BOOL Initialize()
{
    // Set the file cache size
    XSetFileCacheSize( FILE_DATA_CACHE_SIZE );

    // Get any launch info and display it in to the debugger
    DWORD dwLDataType;
    LAUNCH_DATA lData;
    ZeroMemory( &lData, sizeof( lData ) );

    if( ERROR_SUCCESS == XGetLaunchInfo( &dwLDataType, &lData ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Received Launch Data:" );

        if( LDT_FROM_DASHBOARD == dwLDataType )
        {
            LD_FROM_DASHBOARD* pDashData = (LD_FROM_DASHBOARD*)&lData;
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DASHBOARD" );
            XDBGWRN( APP_TITLE_NAME_A, "  Context - '%d'", pDashData->dwContext );

        }
        else if( LDT_FROM_DEBUGGER_CMDLINE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DEBUGGER CMDLINE" );
        }
        else if( LDT_TITLE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from TITLE" );
        }
        else
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from UNKNOWN" );
        }
    }

    // Check to see if our media exists on the HD -- If not, Copy it
    if( !g_HardDrive.FileExists( FILE_DATA_DEFAULT_FONT_FILENAME_A ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize(): Must Copy Media!!" );

        char pszSource[MAX_PATH+1];
        
        ZeroMemory( pszSource, MAX_PATH+1 );

        _snprintf( pszSource, MAX_PATH, "d:\\%0.8X", XeImageHeader()->Certificate->TitleID );

        // Copy the media -- Assume in it's our Title Dir
        g_HardDrive.CopyDirs( pszSource, "t:" );

        // Copy the DEFAULT.XBE to the user's E drive
        g_HardDrive.UnMapDrive( 'E' );
        g_HardDrive.MapDrive( 'E', "\\Device\\Harddisk0\\Partition1\\devkit" );
        CopyFile( "d:\\default.xbe", "e:\\GRate6EC.xbe", FALSE );
        g_HardDrive.UnMapDrive( 'E' );
    }

    // Initialize Direct3D
    if( !InitializeD3D() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Failed to InitializeD3D!!" );

        return FALSE;
    }

    ////////////////////////////////////////
    // Setup and Initialize our Default FONT
    ////////////////////////////////////////
    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &g_pFont );

    if( g_pFont )
    {
        // XFONT_SetDrawingSurface( m_BackBuffer );
        XFONT_SetTextColor( g_pFont, SCREEN_DEFAULT_FOREGROUND_COLOR );
        XFONT_SetBkColor( g_pFont, SCREEN_DEFAULT_BACKGROUND_COLOR );
        XFONT_SetTextHeight( g_pFont, SCREEN_DEFAULT_FONT_HEIGHT );
        XFONT_SetTextAntialiasLevel( g_pFont, SCREEN_DEFAULT_FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( g_pFont, SCREEN_DEFAULT_FONT_STYLE );
    }
    else
    {
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize our Font!!" );
    }

    ////////////////////
    // Initialize DSound
    ////////////////////
    if( FAILED( InitDSound() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize DSound!!" );
    }

    // Create our display poly and our display texture
    g_mainDisplayPoly.Initialize( g_pD3DDevice );
    g_mainDisplayTexture.Initialize( g_pD3DDevice, NULL, 1024, 1024 );

    // Render the bitmap to the poly
    BitmapFile Bitmap;
    Bitmap.read( 0, 0, FILE_DATA_DEFAULT_BG_IMAGE_FILENAME );

    g_mainDisplayTexture.Lock();

    Bitmap.render( g_pD3DDevice, g_mainDisplayTexture.GetTextureSurface() );

    void DrawText( float fX1,                               // Prints formatted text, using the default font size
                   float fY1,
                   DWORD dwFGColor,
                   DWORD dwBGColor,
                   const WCHAR* pwszFormat,
                   ... );

    
    void DrawBox( float fX1,                                // Draw a box on the screen
                  float fY1,
                  float fX2,
                  float fY2,
                  DWORD dwColor );

    int iStringLen = GetStringPixelWidth( TEXT_GAME_RATING_INFO );

    unsigned int uiFontHeight;
    unsigned int uiFontWidth;
    GetFontSize( &uiFontHeight, &uiFontWidth );

    XDBGWRN( APP_TITLE_NAME_A, "Init():uiFontHeight - '%u'", uiFontHeight );
    XDBGWRN( APP_TITLE_NAME_A, "Init():uiFontWidth  - '%u'", uiFontWidth );

    float fTopBotYAdjust   = 100.0f;
    float fTopBotBorder    = 5.0f;
    float fLeftRightBorder = 10.0f;

    float X1 = SCREEN_X_CENTER - ( iStringLen / 2.0f ) - fLeftRightBorder;
    float Y1 = SCREEN_HEIGHT - fTopBotYAdjust;

    float X2 = SCREEN_X_CENTER + ( iStringLen / 2.0f ) + fLeftRightBorder;
    float Y2 = Y1 + uiFontHeight + ( fTopBotBorder * 2 );

    g_mainDisplayTexture.DrawBox( X1, Y1, X2, Y2, COLOR_BLACK );
    g_mainDisplayTexture.DrawText( X1 + fLeftRightBorder, Y1 + fTopBotBorder, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, TEXT_GAME_RATING_INFO );

    g_mainDisplayTexture.Unlock();

    return TRUE;
}


// Initalize D3D to be used by our application
BOOL InitializeD3D()
{
    IDirect3D8* pD3D;
    HRESULT hr = S_OK;

    // Create our Direct3D Object
    pD3D = Direct3DCreate8( D3D_SDK_VERSION );
    if( NULL == pD3D )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Object!!" );

        return FALSE;
    }

    // Create our D3D Device Object
    D3DPRESENT_PARAMETERS d3dpp;
	ZeroMemory( &d3dpp, sizeof( d3dpp ) );

    d3dpp.BackBufferWidth                 = SCREEN_WIDTH;
    d3dpp.BackBufferHeight                = SCREEN_HEIGHT;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.MultiSampleType                 = D3DMULTISAMPLE_4_SAMPLES;
    d3dpp.BackBufferCount                 = 1;

    d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
    d3dpp.Windowed                        = FALSE;                   // Must be FALSE for Xbox
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.EnableAutoDepthStencil          = FALSE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
	d3dpp.FullScreen_RefreshRateInHz      = D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE; // D3DPRESENT_INTERVAL_IMMEDIATE;

    if ( FAILED ( hr = pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                           D3DDEVTYPE_HAL,
                                           NULL,
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                           &d3dpp,
                                           &g_pD3DDevice ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Device Object!!" );
    }

    // Release the D3D Object
    // It's ok to simply release this object, as we know we cannot be here if the D3D Object failed creation
    pD3D->Release();
    pD3D = NULL;

    // If the device failed to create, simply abort the rest of the D3D Initialization
    if( !g_pD3DDevice )
    {
        return FALSE;
    }

    // Create our Viewport
    D3DVIEWPORT8 D3DViewport;

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = SCREEN_WIDTH;
    D3DViewport.Height = SCREEN_HEIGHT;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( hr = g_pD3DDevice->SetViewport( &D3DViewport ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to set the D3D Viewport!!" );
    }

    // Set our Renderstates and our Texture Stage States
    //BUGBUG: Tweak these and remove the ones uneccessary
    g_pD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    g_pD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    g_pD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    g_pD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    g_pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE);
    g_pD3DDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
    g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    return TRUE;
}

// Initialize DSound
HRESULT InitDSound()
{
	HRESULT hr = S_OK;

    if( NULL != g_pDSound )
    {
        g_pDSound->Release();
        g_pDSound = NULL;
    }

	if (FAILED(hr = DirectSoundCreate(NULL, &g_pDSound, NULL)))
	{
        XDBGWRN( APP_TITLE_NAME_A, "DirectSoundCreate FAILED!! Error - '0x%.08X'", hr );

        return hr;
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion2\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define XFONT_TRUETYPE

#include <xapip.h>
#include <xdbg.h>
#include <xfont.h>
#include <stdio.h>

// Libs
#include "bitmapfile.h"
#include "harddrive.h"
#include "wavemedia.h"

#include "xfontfuncs.h"
#include "udtexture.h"
#include "constants.h"

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion2\xfontfuncs.cpp ===
#include "stdafx.h"
#include "xfontfuncs.h"

extern XFONT *g_pFont;

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int GetStringPixelWidth( IN WCHAR* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!!\n" );

        return -1;
    }

    unsigned int outlen = 0;        // Return value

    XFONT_GetTextExtent( g_pFont, string, length, &outlen );

    return outlen;
}


// Get the width of the char*
int GetStringPixelWidth( IN char* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( char* ):Invalid pointer passed in!!\n" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}


// Get the size of the current font
void GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetFontSize():Invalid arguments passed!!\n" );

        return;
    }

    XFONT_GetFontMetrics( g_pFont, pheight, pdecent );
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion2\XFontFuncs.h ===
#ifndef _XFONTFUNCS_H_
#define _XFONTFUNCS_H_

// Get the pixel width of a string
int GetStringPixelWidth( IN WCHAR* string,
                         IN int length = -1 );

// Get the pixel width of a char*
int GetStringPixelWidth( IN char* string,
                         IN int length = -1 );

// Get the size of the currently selected font
void GetFontSize( unsigned int* pheight,
                  unsigned int* pdecent );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

#endif // _XFONTFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion3\PolyObject.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Contstructor
CPolyObject::CPolyObject()
: m_pVertexBuffer( NULL )
{
}

// Destructor
CPolyObject::~CPolyObject()
{
    // Destroy any memory, etc, that we have allocated
    CleanUp();
}


// Clean up any memory allocated, etc.
void CPolyObject::CleanUp()
{
    // Clean up our Vertex Buffer
    if( m_pVertexBuffer )
    {
        m_pVertexBuffer->Release();
        m_pVertexBuffer = NULL;
    }
}


// Initialize our data, including our vertext buffer
void CPolyObject::Initialize( IDirect3DDevice8* pD3DDevice )
{
    // Clean up anything that was previously allocated
    CleanUp();

    // Setup our vertices
    MYTEXVERTEX* pb = NULL;

    // Create our vertex buffer
    pD3DDevice->CreateVertexBuffer( sizeof( MYTEXVERTEX ) * 4, 0, 0, 0, &m_pVertexBuffer );

    m_pVertexBuffer->Lock( 0, 0, (BYTE**)&pb, 0 );

    pb[0].v.x = 0.0f;         pb[0].v.y = 0.0f;          pb[0].v.z = 0.1f; pb[0].fRHW = 0.9f; pb[0].diffuse = COLOR_WHITE; pb[0].tu = 0.0f;         pb[0].tv = 0.0f;
    pb[1].v.x = SCREEN_WIDTH; pb[1].v.y = 0.0f;          pb[1].v.z = 0.1f; pb[1].fRHW = 0.9f; pb[1].diffuse = COLOR_WHITE; pb[1].tu = SCREEN_WIDTH; pb[1].tv = 0.0f;
    pb[2].v.x = SCREEN_WIDTH; pb[2].v.y = SCREEN_HEIGHT; pb[2].v.z = 0.1f; pb[2].fRHW = 0.9f; pb[2].diffuse = COLOR_WHITE; pb[2].tu = SCREEN_WIDTH; pb[2].tv = SCREEN_HEIGHT;
    pb[3].v.x = 0.0f;         pb[3].v.y = SCREEN_HEIGHT; pb[3].v.z = 0.1f; pb[3].fRHW = 0.9f; pb[3].diffuse = COLOR_WHITE; pb[3].tu = 0.0f;         pb[3].tv = SCREEN_HEIGHT;

    m_pVertexBuffer->Unlock();
}


// Render the Poly to the screen
void CPolyObject::Render( IDirect3DDevice8* pD3DDevice )
{
    pD3DDevice->SetVertexShader( D3DFVF_MYTEXVERTEX );
    pD3DDevice->SetStreamSource( 0, m_pVertexBuffer, sizeof( MYTEXVERTEX ) );
    pD3DDevice->DrawPrimitive( D3DPT_TRIANGLEFAN, 0, 2 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion3\PolyObject.h ===
/******************************************************
** polyobject.h
** 
** A basic polygon object capable of rendering itself
**
** 03/09/2001
** by James N. Helm
******************************************************/

#ifndef _POLYOBJECT_H_
#define _POLYOBJECT_H_

class CPolyObject
{
public:
    // Constructors and Destructors
    CPolyObject();
    ~CPolyObject();

    // Public Properties
    
    // Public Methods
    void Initialize( IDirect3DDevice8* pD3DDevice );    // Setup our Vertex Buffer and Poly Points
    void Render( IDirect3DDevice8* pD3DDevice );        // Render the poly to the backbuffer

private:
    // Private Properties
    IDirect3DVertexBuffer8* m_pVertexBuffer;            // Vertex buffer for our Polygon

    // Private Methods
    void CleanUp();                                     // Clean up any memory we have allocated
};

#endif // _POLYOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion1\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#define BREAK_INTO_DEBUGGER                     _asm { int 3 }
                                                
#define APP_TITLE_NAME_A                        "GREG1"
                                                
// Video Display Dimensions                     
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2.0f )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2.0f )
#define SCREEN_DEFAULT_FOREGROUND_COLOR         COLOR_TV_BLUE
#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_FONT_HEIGHT              32
#define SCREEN_DEFAULT_FONT_ALIAS_LEVEL         4
#define SCREEN_DEFAULT_FONT_STYLE               XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS

#define TEXT_GAME_REGION_INFO                   L"Game Region 1"

// Colors                                       
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_RED                               0xFFFF0000
#define COLOR_TV_RED                            0xFF8D3232
#define COLOR_GREEN                             0xFF00FF00
#define COLOR_BLUE                              0xFF0000FF
#define COLOR_TV_LIGHT_BLUE                     0xFFA1A7FF
#define COLOR_TV_BLUE                           0xFF20209F
#define COLOR_LIGHT_YELLOW                      0xFFDDD078
#define COLOR_TV_YELLOW                         0xFFEFEF30
#define COLOR_DARK_GREEN                        0xFF357515

// File path and location constants
#define FILE_DATA_CACHE_SIZE                    5120000
#define FILE_DATA_DRIVE_A                       "t:"
#define FILE_DATA_DRIVE                         L"t:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\images"
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"
#define FILE_DATA_DEFAULT_FONT_FILENAME_A       FILE_DATA_MEDIA_DIRECTORY_A "\\tahoma.ttf"
#define FILE_DATA_DEFAULT_STARTSOUND_FILENAME_A FILE_DATA_MEDIA_DIRECTORY_A "\\startsound.wav"
#define FILE_DATA_DEFAULT_BG_IMAGE_FILENAME     FILE_DATA_IMAGE_DIRECTORY_A "\\background.bmp"

// Vertex Definitions
struct MYVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    cDiffuse;
};

struct MYTEXVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    diffuse;
    float       tu, tv;    // The texture coordinates
};

#define D3DFVF_MYVERTEX     ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE )
#define D3DFVF_MYTEXVERTEX  ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1 )

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion3\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define XFONT_TRUETYPE

#include <xapip.h>
#include <xdbg.h>
#include <xfont.h>
#include <stdio.h>

// Libs
#include "bitmapfile.h"
#include "harddrive.h"
#include "wavemedia.h"

#include "xfontfuncs.h"
#include "udtexture.h"
#include "constants.h"

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion3\xfontfuncs.cpp ===
#include "stdafx.h"
#include "xfontfuncs.h"

extern XFONT* g_pFont;

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int GetStringPixelWidth( IN WCHAR* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!!\n" );

        return -1;
    }

    unsigned int outlen = 0;        // Return value

    XFONT_GetTextExtent( g_pFont, string, length, &outlen );

    return outlen;
}


// Get the width of the char*
int GetStringPixelWidth( IN char* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( char* ):Invalid pointer passed in!!\n" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}


// Get the size of the current font
void GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetFontSize():Invalid arguments passed!!\n" );

        return;
    }

    XFONT_GetFontMetrics( g_pFont, pheight, pdecent );
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion1\GameRegion.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Forward declarations
void Render();              // Render the video on to our screen and present it to the user
void CleanUp();             // Clean up memory, etc, when neccessary
BOOL Initialize();          // Initialize anything necessary for the MU Config program
BOOL InitializeD3D();       // Initalize D3D to be used by our application
HRESULT InitDSound( void );

// Globals
IDirect3DDevice8* g_pD3DDevice          = NULL;     // Pointer to our Direct3D Device Object
LPDIRECTSOUND     g_pDSound             = NULL;     // Pointer to our DirectSound Object
CPolyObject       g_mainDisplayPoly;                // Our main display (poly) object
CUDTexture        g_mainDisplayTexture;             // Out main display (texture) object
XFONT*            g_pFont               = NULL;     // Our Default Font Pointer
CHardDrive        g_HardDrive;                      // Xbox Hard Drive
BOOL              g_StartSoundPlayed    = FALSE;    // Used to determine if we've already played the start sound

void _cdecl main()
{
    XDBGWRN( APP_TITLE_NAME_A, "main() Entered..." );

    // Initialize the Application
    if( !Initialize() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "main():Failed to initialize!!" );

        return; // Should never return from main.  This is a bad situation
    }

    CWaveMedia StartSound;
    StartSound.Init( g_pDSound, FILE_DATA_DEFAULT_STARTSOUND_FILENAME_A );

    // Render Loop
    while( TRUE )
    {
        // Render the video on our screen and present it to the user
        Render();

        if( !g_StartSoundPlayed )
        {
            g_StartSoundPlayed = TRUE;

            // StartSound.Play();
        }
    }

    XDBGWRN( APP_TITLE_NAME_A, "main() Exiting." );
}

void Render()
{
    g_pD3DDevice->Clear( 0, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0 );
    g_pD3DDevice->BeginScene();

    // Render the main screen object here
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    g_pD3DDevice->SetTexture( 0, g_mainDisplayTexture.GetTexture() );
    g_mainDisplayPoly.Render( g_pD3DDevice );
    g_pD3DDevice->SetTexture( 0, NULL );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    g_pD3DDevice->EndScene();
    g_pD3DDevice->Present( NULL, NULL, NULL, NULL );
}


// Clean up memory, etc, when neccessary
void CleanUp()
{
    // Clean up our D3D Device object
    if( g_pD3DDevice )
    {
        g_pD3DDevice->Release();
        g_pD3DDevice = NULL;
    }

    if( g_pFont )
    {
        XFONT_Release( g_pFont );
        g_pFont = NULL;
    }

    // Clean up DSound
    if( NULL != g_pDSound )
    {
        g_pDSound->Release();
        g_pDSound = NULL;
    }
}


// Initialize anything necessary for the MU Config program
BOOL Initialize()
{
    // Set the file cache size
    XSetFileCacheSize( FILE_DATA_CACHE_SIZE );

    // Get any launch info and display it in to the debugger
    DWORD dwLDataType;
    LAUNCH_DATA lData;
    ZeroMemory( &lData, sizeof( lData ) );

    if( ERROR_SUCCESS == XGetLaunchInfo( &dwLDataType, &lData ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Received Launch Data:" );

        if( LDT_FROM_DASHBOARD == dwLDataType )
        {
            LD_FROM_DASHBOARD* pDashData = (LD_FROM_DASHBOARD*)&lData;
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DASHBOARD" );
            XDBGWRN( APP_TITLE_NAME_A, "  Context - '%d'", pDashData->dwContext );

        }
        else if( LDT_FROM_DEBUGGER_CMDLINE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DEBUGGER CMDLINE" );
        }
        else if( LDT_TITLE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from TITLE" );
        }
        else
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from UNKNOWN" );
        }
    }

    // Check to see if our media exists on the HD -- If not, Copy it
    if( !g_HardDrive.FileExists( FILE_DATA_DEFAULT_FONT_FILENAME_A ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize(): Must Copy Media!!" );

        char pszSource[MAX_PATH+1];
        
        ZeroMemory( pszSource, MAX_PATH+1 );

        _snprintf( pszSource, MAX_PATH, "d:\\%0.8X", XeImageHeader()->Certificate->TitleID );

        // Copy the media -- Assume in it's our Title Dir
        g_HardDrive.CopyDirs( pszSource, "t:" );

        // Copy the DEFAULT.XBE to the user's E drive
        g_HardDrive.UnMapDrive( 'E' );
        g_HardDrive.MapDrive( 'E', "\\Device\\Harddisk0\\Partition1\\devkit" );
        CopyFile( "d:\\default.xbe", "e:\\GRegion1.xbe", FALSE );
        g_HardDrive.UnMapDrive( 'E' );
    }

    // Initialize Direct3D
    if( !InitializeD3D() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Failed to InitializeD3D!!" );

        return FALSE;
    }

    ////////////////////////////////////////
    // Setup and Initialize our Default FONT
    ////////////////////////////////////////
    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &g_pFont );

    if( g_pFont )
    {
        // XFONT_SetDrawingSurface( m_BackBuffer );
        XFONT_SetTextColor( g_pFont, SCREEN_DEFAULT_FOREGROUND_COLOR );
        XFONT_SetBkColor( g_pFont, SCREEN_DEFAULT_BACKGROUND_COLOR );
        XFONT_SetTextHeight( g_pFont, SCREEN_DEFAULT_FONT_HEIGHT );
        XFONT_SetTextAntialiasLevel( g_pFont, SCREEN_DEFAULT_FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( g_pFont, SCREEN_DEFAULT_FONT_STYLE );
    }
    else
    {
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize our Font!!" );
    }

    ////////////////////
    // Initialize DSound
    ////////////////////
    if( FAILED( InitDSound() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize DSound!!" );
    }

    // Create our display poly and our display texture
    g_mainDisplayPoly.Initialize( g_pD3DDevice );
    g_mainDisplayTexture.Initialize( g_pD3DDevice, NULL, 1024, 1024 );

    // Render the bitmap to the poly
    BitmapFile Bitmap;
    Bitmap.read( 0, 0, FILE_DATA_DEFAULT_BG_IMAGE_FILENAME );

    g_mainDisplayTexture.Lock();

    Bitmap.render( g_pD3DDevice, g_mainDisplayTexture.GetTextureSurface() );

    void DrawText( float fX1,                               // Prints formatted text, using the default font size
                   float fY1,
                   DWORD dwFGColor,
                   DWORD dwBGColor,
                   const WCHAR* pwszFormat,
                   ... );

    
    void DrawBox( float fX1,                                // Draw a box on the screen
                  float fY1,
                  float fX2,
                  float fY2,
                  DWORD dwColor );

    int iStringLen = GetStringPixelWidth( TEXT_GAME_REGION_INFO );

    unsigned int uiFontHeight;
    unsigned int uiFontWidth;
    GetFontSize( &uiFontHeight, &uiFontWidth );

    float fTopBotYAdjust   = 100.0f;
    float fTopBotBorder    = 5.0f;
    float fLeftRightBorder = 10.0f;

    float X1 = SCREEN_X_CENTER - ( iStringLen / 2.0f ) - fLeftRightBorder;
    float Y1 = SCREEN_HEIGHT - fTopBotYAdjust;

    float X2 = SCREEN_X_CENTER + ( iStringLen / 2.0f ) + fLeftRightBorder;
    float Y2 = Y1 + uiFontHeight + ( fTopBotBorder * 2 );

    g_mainDisplayTexture.DrawBox( X1, Y1, X2, Y2, COLOR_BLACK );
    g_mainDisplayTexture.DrawText( X1 + fLeftRightBorder, Y1 + fTopBotBorder, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, TEXT_GAME_REGION_INFO );

    g_mainDisplayTexture.Unlock();

    return TRUE;
}


// Initalize D3D to be used by our application
BOOL InitializeD3D()
{
    IDirect3D8* pD3D;
    HRESULT hr = S_OK;

    // Create our Direct3D Object
    pD3D = Direct3DCreate8( D3D_SDK_VERSION );
    if( NULL == pD3D )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Object!!" );

        return FALSE;
    }

    // Create our D3D Device Object
    D3DPRESENT_PARAMETERS d3dpp;
	ZeroMemory( &d3dpp, sizeof( d3dpp ) );

    d3dpp.BackBufferWidth                 = SCREEN_WIDTH;
    d3dpp.BackBufferHeight                = SCREEN_HEIGHT;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.MultiSampleType                 = D3DMULTISAMPLE_4_SAMPLES;
    d3dpp.BackBufferCount                 = 1;

    d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
    d3dpp.Windowed                        = FALSE;                   // Must be FALSE for Xbox
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.EnableAutoDepthStencil          = FALSE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
	d3dpp.FullScreen_RefreshRateInHz      = D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE; // D3DPRESENT_INTERVAL_IMMEDIATE;

    if ( FAILED ( hr = pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                           D3DDEVTYPE_HAL,
                                           NULL,
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                           &d3dpp,
                                           &g_pD3DDevice ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Device Object!!" );
    }

    // Release the D3D Object
    // It's ok to simply release this object, as we know we cannot be here if the D3D Object failed creation
    pD3D->Release();
    pD3D = NULL;

    // If the device failed to create, simply abort the rest of the D3D Initialization
    if( !g_pD3DDevice )
    {
        return FALSE;
    }

    // Create our Viewport
    D3DVIEWPORT8 D3DViewport;

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = SCREEN_WIDTH;
    D3DViewport.Height = SCREEN_HEIGHT;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( hr = g_pD3DDevice->SetViewport( &D3DViewport ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to set the D3D Viewport!!" );
    }

    // Set our Renderstates and our Texture Stage States
    //BUGBUG: Tweak these and remove the ones uneccessary
    g_pD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    g_pD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    g_pD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    g_pD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    g_pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE);
    g_pD3DDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
    g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    return TRUE;
}

// Initialize DSound
HRESULT InitDSound()
{
	HRESULT hr = S_OK;

    if( NULL != g_pDSound )
    {
        g_pDSound->Release();
        g_pDSound = NULL;
    }

	if (FAILED(hr = DirectSoundCreate(NULL, &g_pDSound, NULL)))
	{
        XDBGWRN( APP_TITLE_NAME_A, "DirectSoundCreate FAILED!! Error - '0x%.08X'", hr );

        return hr;
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion3\XFontFuncs.h ===
#ifndef _XFONTFUNCS_H_
#define _XFONTFUNCS_H_

// Get the pixel width of a string
int GetStringPixelWidth( IN WCHAR* string,
                         IN int length = -1 );

// Get the pixel width of a char*
int GetStringPixelWidth( IN char* string,
                         IN int length = -1 );

// Get the size of the currently selected font
void GetFontSize( unsigned int* pheight,
                  unsigned int* pdecent );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

#endif // _XFONTFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegionAll\PolyObject.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Contstructor
CPolyObject::CPolyObject()
: m_pVertexBuffer( NULL )
{
}

// Destructor
CPolyObject::~CPolyObject()
{
    // Destroy any memory, etc, that we have allocated
    CleanUp();
}


// Clean up any memory allocated, etc.
void CPolyObject::CleanUp()
{
    // Clean up our Vertex Buffer
    if( m_pVertexBuffer )
    {
        m_pVertexBuffer->Release();
        m_pVertexBuffer = NULL;
    }
}


// Initialize our data, including our vertext buffer
void CPolyObject::Initialize( IDirect3DDevice8* pD3DDevice )
{
    // Clean up anything that was previously allocated
    CleanUp();

    // Setup our vertices
    MYTEXVERTEX* pb = NULL;

    // Create our vertex buffer
    pD3DDevice->CreateVertexBuffer( sizeof( MYTEXVERTEX ) * 4, 0, 0, 0, &m_pVertexBuffer );

    m_pVertexBuffer->Lock( 0, 0, (BYTE**)&pb, 0 );

    pb[0].v.x = 0.0f;         pb[0].v.y = 0.0f;          pb[0].v.z = 0.1f; pb[0].fRHW = 0.9f; pb[0].diffuse = COLOR_WHITE; pb[0].tu = 0.0f;         pb[0].tv = 0.0f;
    pb[1].v.x = SCREEN_WIDTH; pb[1].v.y = 0.0f;          pb[1].v.z = 0.1f; pb[1].fRHW = 0.9f; pb[1].diffuse = COLOR_WHITE; pb[1].tu = SCREEN_WIDTH; pb[1].tv = 0.0f;
    pb[2].v.x = SCREEN_WIDTH; pb[2].v.y = SCREEN_HEIGHT; pb[2].v.z = 0.1f; pb[2].fRHW = 0.9f; pb[2].diffuse = COLOR_WHITE; pb[2].tu = SCREEN_WIDTH; pb[2].tv = SCREEN_HEIGHT;
    pb[3].v.x = 0.0f;         pb[3].v.y = SCREEN_HEIGHT; pb[3].v.z = 0.1f; pb[3].fRHW = 0.9f; pb[3].diffuse = COLOR_WHITE; pb[3].tu = 0.0f;         pb[3].tv = SCREEN_HEIGHT;

    m_pVertexBuffer->Unlock();
}


// Render the Poly to the screen
void CPolyObject::Render( IDirect3DDevice8* pD3DDevice )
{
    pD3DDevice->SetVertexShader( D3DFVF_MYTEXVERTEX );
    pD3DDevice->SetStreamSource( 0, m_pVertexBuffer, sizeof( MYTEXVERTEX ) );
    pD3DDevice->DrawPrimitive( D3DPT_TRIANGLEFAN, 0, 2 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegionAll\PolyObject.h ===
/******************************************************
** polyobject.h
** 
** A basic polygon object capable of rendering itself
**
** 03/09/2001
** by James N. Helm
******************************************************/

#ifndef _POLYOBJECT_H_
#define _POLYOBJECT_H_

class CPolyObject
{
public:
    // Constructors and Destructors
    CPolyObject();
    ~CPolyObject();

    // Public Properties
    
    // Public Methods
    void Initialize( IDirect3DDevice8* pD3DDevice );    // Setup our Vertex Buffer and Poly Points
    void Render( IDirect3DDevice8* pD3DDevice );        // Render the poly to the backbuffer

private:
    // Private Properties
    IDirect3DVertexBuffer8* m_pVertexBuffer;            // Vertex buffer for our Polygon

    // Private Methods
    void CleanUp();                                     // Clean up any memory we have allocated
};

#endif // _POLYOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion2\GameRegion.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Forward declarations
void Render();              // Render the video on to our screen and present it to the user
void CleanUp();             // Clean up memory, etc, when neccessary
BOOL Initialize();          // Initialize anything necessary for the MU Config program
BOOL InitializeD3D();       // Initalize D3D to be used by our application
HRESULT InitDSound( void );

// Globals
IDirect3DDevice8* g_pD3DDevice          = NULL;     // Pointer to our Direct3D Device Object
LPDIRECTSOUND     g_pDSound             = NULL;     // Pointer to our DirectSound Object
CPolyObject       g_mainDisplayPoly;                // Our main display (poly) object
CUDTexture        g_mainDisplayTexture;             // Out main display (texture) object
XFONT*            g_pFont               = NULL;     // Our Default Font Pointer
CHardDrive        g_HardDrive;                      // Xbox Hard Drive
BOOL              g_StartSoundPlayed    = FALSE;    // Used to determine if we've already played the start sound

void _cdecl main()
{
    XDBGWRN( APP_TITLE_NAME_A, "main() Entered..." );

    // Initialize the Application
    if( !Initialize() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "main():Failed to initialize!!" );

        return; // Should never return from main.  This is a bad situation
    }

    CWaveMedia StartSound;
    StartSound.Init( g_pDSound, FILE_DATA_DEFAULT_STARTSOUND_FILENAME_A );

    // Render Loop
    while( TRUE )
    {
        // Render the video on our screen and present it to the user
        Render();

        if( !g_StartSoundPlayed )
        {
            g_StartSoundPlayed = TRUE;

            // StartSound.Play();
        }
    }

    XDBGWRN( APP_TITLE_NAME_A, "main() Exiting." );
}

void Render()
{
    g_pD3DDevice->Clear( 0, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0 );
    g_pD3DDevice->BeginScene();

    // Render the main screen object here
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    g_pD3DDevice->SetTexture( 0, g_mainDisplayTexture.GetTexture() );
    g_mainDisplayPoly.Render( g_pD3DDevice );
    g_pD3DDevice->SetTexture( 0, NULL );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    g_pD3DDevice->EndScene();
    g_pD3DDevice->Present( NULL, NULL, NULL, NULL );
}


// Clean up memory, etc, when neccessary
void CleanUp()
{
    // Clean up our D3D Device object
    if( g_pD3DDevice )
    {
        g_pD3DDevice->Release();
        g_pD3DDevice = NULL;
    }

    if( g_pFont )
    {
        XFONT_Release( g_pFont );
        g_pFont = NULL;
    }

    // Clean up DSound
    if( NULL != g_pDSound )
    {
        g_pDSound->Release();
        g_pDSound = NULL;
    }
}


// Initialize anything necessary for the MU Config program
BOOL Initialize()
{
    // Set the file cache size
    XSetFileCacheSize( FILE_DATA_CACHE_SIZE );

    // Get any launch info and display it in to the debugger
    DWORD dwLDataType;
    LAUNCH_DATA lData;
    ZeroMemory( &lData, sizeof( lData ) );

    if( ERROR_SUCCESS == XGetLaunchInfo( &dwLDataType, &lData ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Received Launch Data:" );

        if( LDT_FROM_DASHBOARD == dwLDataType )
        {
            LD_FROM_DASHBOARD* pDashData = (LD_FROM_DASHBOARD*)&lData;
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DASHBOARD" );
            XDBGWRN( APP_TITLE_NAME_A, "  Context - '%d'", pDashData->dwContext );

        }
        else if( LDT_FROM_DEBUGGER_CMDLINE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DEBUGGER CMDLINE" );
        }
        else if( LDT_TITLE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from TITLE" );
        }
        else
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from UNKNOWN" );
        }
    }

    // Check to see if our media exists on the HD -- If not, Copy it
    if( !g_HardDrive.FileExists( FILE_DATA_DEFAULT_FONT_FILENAME_A ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize(): Must Copy Media!!" );

        char pszSource[MAX_PATH+1];
        
        ZeroMemory( pszSource, MAX_PATH+1 );

        _snprintf( pszSource, MAX_PATH, "d:\\%0.8X", XeImageHeader()->Certificate->TitleID );

        // Copy the media -- Assume in it's our Title Dir
        g_HardDrive.CopyDirs( pszSource, "t:" );

        // Copy the DEFAULT.XBE to the user's E drive
        g_HardDrive.UnMapDrive( 'E' );
        g_HardDrive.MapDrive( 'E', "\\Device\\Harddisk0\\Partition1\\devkit" );
        CopyFile( "d:\\default.xbe", "e:\\GRegion2.xbe", FALSE );
        g_HardDrive.UnMapDrive( 'E' );
    }

    // Initialize Direct3D
    if( !InitializeD3D() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Failed to InitializeD3D!!" );

        return FALSE;
    }

    ////////////////////////////////////////
    // Setup and Initialize our Default FONT
    ////////////////////////////////////////
    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &g_pFont );

    if( g_pFont )
    {
        // XFONT_SetDrawingSurface( m_BackBuffer );
        XFONT_SetTextColor( g_pFont, SCREEN_DEFAULT_FOREGROUND_COLOR );
        XFONT_SetBkColor( g_pFont, SCREEN_DEFAULT_BACKGROUND_COLOR );
        XFONT_SetTextHeight( g_pFont, SCREEN_DEFAULT_FONT_HEIGHT );
        XFONT_SetTextAntialiasLevel( g_pFont, SCREEN_DEFAULT_FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( g_pFont, SCREEN_DEFAULT_FONT_STYLE );
    }
    else
    {
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize our Font!!" );
    }

    ////////////////////
    // Initialize DSound
    ////////////////////
    if( FAILED( InitDSound() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize DSound!!" );
    }

    // Create our display poly and our display texture
    g_mainDisplayPoly.Initialize( g_pD3DDevice );
    g_mainDisplayTexture.Initialize( g_pD3DDevice, NULL, 1024, 1024 );

    // Render the bitmap to the poly
    BitmapFile Bitmap;
    Bitmap.read( 0, 0, FILE_DATA_DEFAULT_BG_IMAGE_FILENAME );

    g_mainDisplayTexture.Lock();

    Bitmap.render( g_pD3DDevice, g_mainDisplayTexture.GetTextureSurface() );

    void DrawText( float fX1,                               // Prints formatted text, using the default font size
                   float fY1,
                   DWORD dwFGColor,
                   DWORD dwBGColor,
                   const WCHAR* pwszFormat,
                   ... );

    
    void DrawBox( float fX1,                                // Draw a box on the screen
                  float fY1,
                  float fX2,
                  float fY2,
                  DWORD dwColor );

    int iStringLen = GetStringPixelWidth( TEXT_GAME_REGION_INFO );

    unsigned int uiFontHeight;
    unsigned int uiFontWidth;
    GetFontSize( &uiFontHeight, &uiFontWidth );

    float fTopBotYAdjust   = 100.0f;
    float fTopBotBorder    = 5.0f;
    float fLeftRightBorder = 10.0f;

    float X1 = SCREEN_X_CENTER - ( iStringLen / 2.0f ) - fLeftRightBorder;
    float Y1 = SCREEN_HEIGHT - fTopBotYAdjust;

    float X2 = SCREEN_X_CENTER + ( iStringLen / 2.0f ) + fLeftRightBorder;
    float Y2 = Y1 + uiFontHeight + ( fTopBotBorder * 2 );

    g_mainDisplayTexture.DrawBox( X1, Y1, X2, Y2, COLOR_BLACK );
    g_mainDisplayTexture.DrawText( X1 + fLeftRightBorder, Y1 + fTopBotBorder, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, TEXT_GAME_REGION_INFO );

    g_mainDisplayTexture.Unlock();

    return TRUE;
}


// Initalize D3D to be used by our application
BOOL InitializeD3D()
{
    IDirect3D8* pD3D;
    HRESULT hr = S_OK;

    // Create our Direct3D Object
    pD3D = Direct3DCreate8( D3D_SDK_VERSION );
    if( NULL == pD3D )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Object!!" );

        return FALSE;
    }

    // Create our D3D Device Object
    D3DPRESENT_PARAMETERS d3dpp;
	ZeroMemory( &d3dpp, sizeof( d3dpp ) );

    d3dpp.BackBufferWidth                 = SCREEN_WIDTH;
    d3dpp.BackBufferHeight                = SCREEN_HEIGHT;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.MultiSampleType                 = D3DMULTISAMPLE_4_SAMPLES;
    d3dpp.BackBufferCount                 = 1;

    d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
    d3dpp.Windowed                        = FALSE;                   // Must be FALSE for Xbox
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.EnableAutoDepthStencil          = FALSE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
	d3dpp.FullScreen_RefreshRateInHz      = D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE; // D3DPRESENT_INTERVAL_IMMEDIATE;

    if ( FAILED ( hr = pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                           D3DDEVTYPE_HAL,
                                           NULL,
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                           &d3dpp,
                                           &g_pD3DDevice ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Device Object!!" );
    }

    // Release the D3D Object
    // It's ok to simply release this object, as we know we cannot be here if the D3D Object failed creation
    pD3D->Release();
    pD3D = NULL;

    // If the device failed to create, simply abort the rest of the D3D Initialization
    if( !g_pD3DDevice )
    {
        return FALSE;
    }

    // Create our Viewport
    D3DVIEWPORT8 D3DViewport;

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = SCREEN_WIDTH;
    D3DViewport.Height = SCREEN_HEIGHT;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( hr = g_pD3DDevice->SetViewport( &D3DViewport ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to set the D3D Viewport!!" );
    }

    // Set our Renderstates and our Texture Stage States
    //BUGBUG: Tweak these and remove the ones uneccessary
    g_pD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    g_pD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    g_pD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    g_pD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    g_pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE);
    g_pD3DDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
    g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    return TRUE;
}

// Initialize DSound
HRESULT InitDSound()
{
	HRESULT hr = S_OK;

    if( NULL != g_pDSound )
    {
        g_pDSound->Release();
        g_pDSound = NULL;
    }

	if (FAILED(hr = DirectSoundCreate(NULL, &g_pDSound, NULL)))
	{
        XDBGWRN( APP_TITLE_NAME_A, "DirectSoundCreate FAILED!! Error - '0x%.08X'", hr );

        return hr;
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegionAll\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define XFONT_TRUETYPE

#include <xapip.h>
#include <xdbg.h>
#include <xfont.h>
#include <stdio.h>

// Libs
#include "bitmapfile.h"
#include "harddrive.h"
#include "wavemedia.h"

#include "xfontfuncs.h"
#include "udtexture.h"
#include "constants.h"

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegionAll\xfontfuncs.cpp ===
#include "stdafx.h"
#include "xfontfuncs.h"

extern XFONT *g_pFont;

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int GetStringPixelWidth( IN WCHAR* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!!\n" );

        return -1;
    }

    unsigned int outlen = 0;        // Return value

    XFONT_GetTextExtent( g_pFont, string, length, &outlen );

    return outlen;
}


// Get the width of the char*
int GetStringPixelWidth( IN char* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( char* ):Invalid pointer passed in!!\n" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}


// Get the size of the current font
void GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetFontSize():Invalid arguments passed!!\n" );

        return;
    }

    XFONT_GetFontMetrics( g_pFont, pheight, pdecent );
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion2\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#define BREAK_INTO_DEBUGGER                     _asm { int 3 }
                                                
#define APP_TITLE_NAME_A                        "GREG2"
                                                
// Video Display Dimensions                     
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2.0f )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2.0f )
#define SCREEN_DEFAULT_FOREGROUND_COLOR         COLOR_TV_BLUE
#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_FONT_HEIGHT              32
#define SCREEN_DEFAULT_FONT_ALIAS_LEVEL         4
#define SCREEN_DEFAULT_FONT_STYLE               XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS

#define TEXT_GAME_REGION_INFO                   L"Game Region 2"

// Colors                                       
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_RED                               0xFFFF0000
#define COLOR_TV_RED                            0xFF8D3232
#define COLOR_GREEN                             0xFF00FF00
#define COLOR_BLUE                              0xFF0000FF
#define COLOR_TV_LIGHT_BLUE                     0xFFA1A7FF
#define COLOR_TV_BLUE                           0xFF20209F
#define COLOR_LIGHT_YELLOW                      0xFFDDD078
#define COLOR_TV_YELLOW                         0xFFEFEF30
#define COLOR_DARK_GREEN                        0xFF357515

// File path and location constants
#define FILE_DATA_CACHE_SIZE                    5120000
#define FILE_DATA_DRIVE_A                       "t:"
#define FILE_DATA_DRIVE                         L"t:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\images"
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"
#define FILE_DATA_DEFAULT_FONT_FILENAME_A       FILE_DATA_MEDIA_DIRECTORY_A "\\tahoma.ttf"
#define FILE_DATA_DEFAULT_STARTSOUND_FILENAME_A FILE_DATA_MEDIA_DIRECTORY_A "\\startsound.wav"
#define FILE_DATA_DEFAULT_BG_IMAGE_FILENAME     FILE_DATA_IMAGE_DIRECTORY_A "\\background.bmp"

// Vertex Definitions
struct MYVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    cDiffuse;
};

struct MYTEXVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    diffuse;
    float       tu, tv;    // The texture coordinates
};

#define D3DFVF_MYVERTEX     ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE )
#define D3DFVF_MYTEXVERTEX  ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1 )

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegionAll\XFontFuncs.h ===
#ifndef _XFONTFUNCS_H_
#define _XFONTFUNCS_H_

// Get the pixel width of a string
int GetStringPixelWidth( IN WCHAR* string,
                         IN int length = -1 );

// Get the pixel width of a char*
int GetStringPixelWidth( IN char* string,
                         IN int length = -1 );

// Get the size of the currently selected font
void GetFontSize( unsigned int* pheight,
                  unsigned int* pdecent );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

#endif // _XFONTFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion3\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#define BREAK_INTO_DEBUGGER                     _asm { int 3 }
                                                
#define APP_TITLE_NAME_A                        "GREG3"
                                                
// Video Display Dimensions                     
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2.0f )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2.0f )
#define SCREEN_DEFAULT_FOREGROUND_COLOR         COLOR_TV_BLUE
#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_FONT_HEIGHT              32
#define SCREEN_DEFAULT_FONT_ALIAS_LEVEL         4
#define SCREEN_DEFAULT_FONT_STYLE               XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS

#define TEXT_GAME_REGION_INFO                   L"Game Region 3"

// Colors                                       
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_RED                               0xFFFF0000
#define COLOR_TV_RED                            0xFF8D3232
#define COLOR_GREEN                             0xFF00FF00
#define COLOR_BLUE                              0xFF0000FF
#define COLOR_TV_LIGHT_BLUE                     0xFFA1A7FF
#define COLOR_TV_BLUE                           0xFF20209F
#define COLOR_LIGHT_YELLOW                      0xFFDDD078
#define COLOR_TV_YELLOW                         0xFFEFEF30
#define COLOR_DARK_GREEN                        0xFF357515

// File path and location constants
#define FILE_DATA_CACHE_SIZE                    5120000
#define FILE_DATA_DRIVE_A                       "t:"
#define FILE_DATA_DRIVE                         L"t:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\images"
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"
#define FILE_DATA_DEFAULT_FONT_FILENAME_A       FILE_DATA_MEDIA_DIRECTORY_A "\\tahoma.ttf"
#define FILE_DATA_DEFAULT_STARTSOUND_FILENAME_A FILE_DATA_MEDIA_DIRECTORY_A "\\startsound.wav"
#define FILE_DATA_DEFAULT_BG_IMAGE_FILENAME     FILE_DATA_IMAGE_DIRECTORY_A "\\background.bmp"

// Vertex Definitions
struct MYVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    cDiffuse;
};

struct MYTEXVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    diffuse;
    float       tu, tv;    // The texture coordinates
};

#define D3DFVF_MYVERTEX     ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE )
#define D3DFVF_MYTEXVERTEX  ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1 )

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegion3\GameRegion.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Forward declarations
void Render();              // Render the video on to our screen and present it to the user
void CleanUp();             // Clean up memory, etc, when neccessary
BOOL Initialize();          // Initialize anything necessary for the MU Config program
BOOL InitializeD3D();       // Initalize D3D to be used by our application
HRESULT InitDSound( void );

// Globals
IDirect3DDevice8* g_pD3DDevice          = NULL;     // Pointer to our Direct3D Device Object
LPDIRECTSOUND     g_pDSound             = NULL;     // Pointer to our DirectSound Object
CPolyObject       g_mainDisplayPoly;                // Our main display (poly) object
CUDTexture        g_mainDisplayTexture;             // Out main display (texture) object
XFONT*            g_pFont               = NULL;     // Our Default Font Pointer
CHardDrive        g_HardDrive;                      // Xbox Hard Drive
BOOL              g_StartSoundPlayed    = FALSE;    // Used to determine if we've already played the start sound

void _cdecl main()
{
    XDBGWRN( APP_TITLE_NAME_A, "main() Entered..." );

    // Initialize the Application
    if( !Initialize() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "main():Failed to initialize!!" );

        return; // Should never return from main.  This is a bad situation
    }

    CWaveMedia StartSound;
    StartSound.Init( g_pDSound, FILE_DATA_DEFAULT_STARTSOUND_FILENAME_A );

    // Render Loop
    while( TRUE )
    {
        // Render the video on our screen and present it to the user
        Render();

        if( !g_StartSoundPlayed )
        {
            g_StartSoundPlayed = TRUE;

            // StartSound.Play();
        }
    }

    XDBGWRN( APP_TITLE_NAME_A, "main() Exiting." );
}

void Render()
{
    g_pD3DDevice->Clear( 0, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0 );
    g_pD3DDevice->BeginScene();

    // Render the main screen object here
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    g_pD3DDevice->SetTexture( 0, g_mainDisplayTexture.GetTexture() );
    g_mainDisplayPoly.Render( g_pD3DDevice );
    g_pD3DDevice->SetTexture( 0, NULL );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    g_pD3DDevice->EndScene();
    g_pD3DDevice->Present( NULL, NULL, NULL, NULL );
}


// Clean up memory, etc, when neccessary
void CleanUp()
{
    // Clean up our D3D Device object
    if( g_pD3DDevice )
    {
        g_pD3DDevice->Release();
        g_pD3DDevice = NULL;
    }

    if( g_pFont )
    {
        XFONT_Release( g_pFont );
        g_pFont = NULL;
    }

    // Clean up DSound
    if( NULL != g_pDSound )
    {
        g_pDSound->Release();
        g_pDSound = NULL;
    }
}


// Initialize anything necessary for the MU Config program
BOOL Initialize()
{
    // Set the file cache size
    XSetFileCacheSize( FILE_DATA_CACHE_SIZE );

    // Get any launch info and display it in to the debugger
    DWORD dwLDataType;
    LAUNCH_DATA lData;
    ZeroMemory( &lData, sizeof( lData ) );

    if( ERROR_SUCCESS == XGetLaunchInfo( &dwLDataType, &lData ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Received Launch Data:" );

        if( LDT_FROM_DASHBOARD == dwLDataType )
        {
            LD_FROM_DASHBOARD* pDashData = (LD_FROM_DASHBOARD*)&lData;
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DASHBOARD" );
            XDBGWRN( APP_TITLE_NAME_A, "  Context - '%d'", pDashData->dwContext );

        }
        else if( LDT_FROM_DEBUGGER_CMDLINE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DEBUGGER CMDLINE" );
        }
        else if( LDT_TITLE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from TITLE" );
        }
        else
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from UNKNOWN" );
        }
    }

    // Check to see if our media exists on the HD -- If not, Copy it
    if( !g_HardDrive.FileExists( FILE_DATA_DEFAULT_FONT_FILENAME_A ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize(): Must Copy Media!!" );

        char pszSource[MAX_PATH+1];
        
        ZeroMemory( pszSource, MAX_PATH+1 );

        _snprintf( pszSource, MAX_PATH, "d:\\%0.8X", XeImageHeader()->Certificate->TitleID );

        // Copy the media -- Assume in it's our Title Dir
        g_HardDrive.CopyDirs( pszSource, "t:" );

        // Copy the DEFAULT.XBE to the user's E drive
        g_HardDrive.UnMapDrive( 'E' );
        g_HardDrive.MapDrive( 'E', "\\Device\\Harddisk0\\Partition1\\devkit" );
        CopyFile( "d:\\default.xbe", "e:\\GRegion3.xbe", FALSE );
        g_HardDrive.UnMapDrive( 'E' );
    }

    // Initialize Direct3D
    if( !InitializeD3D() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Failed to InitializeD3D!!" );

        return FALSE;
    }

    ////////////////////////////////////////
    // Setup and Initialize our Default FONT
    ////////////////////////////////////////
    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &g_pFont );

    if( g_pFont )
    {
        // XFONT_SetDrawingSurface( m_BackBuffer );
        XFONT_SetTextColor( g_pFont, SCREEN_DEFAULT_FOREGROUND_COLOR );
        XFONT_SetBkColor( g_pFont, SCREEN_DEFAULT_BACKGROUND_COLOR );
        XFONT_SetTextHeight( g_pFont, SCREEN_DEFAULT_FONT_HEIGHT );
        XFONT_SetTextAntialiasLevel( g_pFont, SCREEN_DEFAULT_FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( g_pFont, SCREEN_DEFAULT_FONT_STYLE );
    }
    else
    {
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize our Font!!" );
    }

    ////////////////////
    // Initialize DSound
    ////////////////////
    if( FAILED( InitDSound() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize DSound!!" );
    }

    // Create our display poly and our display texture
    g_mainDisplayPoly.Initialize( g_pD3DDevice );
    g_mainDisplayTexture.Initialize( g_pD3DDevice, NULL, 1024, 1024 );

    // Render the bitmap to the poly
    BitmapFile Bitmap;
    Bitmap.read( 0, 0, FILE_DATA_DEFAULT_BG_IMAGE_FILENAME );

    g_mainDisplayTexture.Lock();

    Bitmap.render( g_pD3DDevice, g_mainDisplayTexture.GetTextureSurface() );

    void DrawText( float fX1,                               // Prints formatted text, using the default font size
                   float fY1,
                   DWORD dwFGColor,
                   DWORD dwBGColor,
                   const WCHAR* pwszFormat,
                   ... );

    
    void DrawBox( float fX1,                                // Draw a box on the screen
                  float fY1,
                  float fX2,
                  float fY2,
                  DWORD dwColor );

    int iStringLen = GetStringPixelWidth( TEXT_GAME_REGION_INFO );

    unsigned int uiFontHeight;
    unsigned int uiFontWidth;
    GetFontSize( &uiFontHeight, &uiFontWidth );

    float fTopBotYAdjust   = 100.0f;
    float fTopBotBorder    = 5.0f;
    float fLeftRightBorder = 10.0f;

    float X1 = SCREEN_X_CENTER - ( iStringLen / 2.0f ) - fLeftRightBorder;
    float Y1 = SCREEN_HEIGHT - fTopBotYAdjust;

    float X2 = SCREEN_X_CENTER + ( iStringLen / 2.0f ) + fLeftRightBorder;
    float Y2 = Y1 + uiFontHeight + ( fTopBotBorder * 2 );

    g_mainDisplayTexture.DrawBox( X1, Y1, X2, Y2, COLOR_BLACK );
    g_mainDisplayTexture.DrawText( X1 + fLeftRightBorder, Y1 + fTopBotBorder, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, TEXT_GAME_REGION_INFO );

    g_mainDisplayTexture.Unlock();

    return TRUE;
}


// Initalize D3D to be used by our application
BOOL InitializeD3D()
{
    IDirect3D8* pD3D;
    HRESULT hr = S_OK;

    // Create our Direct3D Object
    pD3D = Direct3DCreate8( D3D_SDK_VERSION );
    if( NULL == pD3D )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Object!!" );

        return FALSE;
    }

    // Create our D3D Device Object
    D3DPRESENT_PARAMETERS d3dpp;
	ZeroMemory( &d3dpp, sizeof( d3dpp ) );

    d3dpp.BackBufferWidth                 = SCREEN_WIDTH;
    d3dpp.BackBufferHeight                = SCREEN_HEIGHT;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.MultiSampleType                 = D3DMULTISAMPLE_4_SAMPLES;
    d3dpp.BackBufferCount                 = 1;

    d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
    d3dpp.Windowed                        = FALSE;                   // Must be FALSE for Xbox
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.EnableAutoDepthStencil          = FALSE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
	d3dpp.FullScreen_RefreshRateInHz      = D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE; // D3DPRESENT_INTERVAL_IMMEDIATE;

    if ( FAILED ( hr = pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                           D3DDEVTYPE_HAL,
                                           NULL,
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                           &d3dpp,
                                           &g_pD3DDevice ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Device Object!!" );
    }

    // Release the D3D Object
    // It's ok to simply release this object, as we know we cannot be here if the D3D Object failed creation
    pD3D->Release();
    pD3D = NULL;

    // If the device failed to create, simply abort the rest of the D3D Initialization
    if( !g_pD3DDevice )
    {
        return FALSE;
    }

    // Create our Viewport
    D3DVIEWPORT8 D3DViewport;

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = SCREEN_WIDTH;
    D3DViewport.Height = SCREEN_HEIGHT;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( hr = g_pD3DDevice->SetViewport( &D3DViewport ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to set the D3D Viewport!!" );
    }

    // Set our Renderstates and our Texture Stage States
    //BUGBUG: Tweak these and remove the ones uneccessary
    g_pD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    g_pD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    g_pD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    g_pD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    g_pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE);
    g_pD3DDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
    g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    return TRUE;
}

// Initialize DSound
HRESULT InitDSound()
{
	HRESULT hr = S_OK;

    if( NULL != g_pDSound )
    {
        g_pDSound->Release();
        g_pDSound = NULL;
    }

	if (FAILED(hr = DirectSoundCreate(NULL, &g_pDSound, NULL)))
	{
        XDBGWRN( APP_TITLE_NAME_A, "DirectSoundCreate FAILED!! Error - '0x%.08X'", hr );

        return hr;
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegionAll\GameRegion.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Forward declarations
void Render();              // Render the video on to our screen and present it to the user
void CleanUp();             // Clean up memory, etc, when neccessary
BOOL Initialize();          // Initialize anything necessary for the MU Config program
BOOL InitializeD3D();       // Initalize D3D to be used by our application
HRESULT InitDSound( void );

// Globals
IDirect3DDevice8* g_pD3DDevice          = NULL;     // Pointer to our Direct3D Device Object
LPDIRECTSOUND     g_pDSound             = NULL;     // Pointer to our DirectSound Object
CPolyObject       g_mainDisplayPoly;                // Our main display (poly) object
CUDTexture        g_mainDisplayTexture;             // Out main display (texture) object
XFONT*            g_pFont = NULL;                   // Our Default Font Pointer
CHardDrive        g_HardDrive;                      // Xbox Hard Drive
BOOL              g_StartSoundPlayed    = FALSE;    // Used to determine if we've already played the start sound

void _cdecl main()
{
    XDBGWRN( APP_TITLE_NAME_A, "main() Entered..." );

    // Initialize the Application
    if( !Initialize() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "main():Failed to initialize!!" );

        return; // Should never return from main.  This is a bad situation
    }

    CWaveMedia StartSound;
    StartSound.Init( g_pDSound, FILE_DATA_DEFAULT_STARTSOUND_FILENAME_A );

    // Render Loop
    while( TRUE )
    {
        // Render the video on our screen and present it to the user
        Render();

        if( !g_StartSoundPlayed )
        {
            g_StartSoundPlayed = TRUE;

            // StartSound.Play();
        }
    }

    XDBGWRN( APP_TITLE_NAME_A, "main() Exiting." );
}

void Render()
{
    g_pD3DDevice->Clear( 0, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0 );
    g_pD3DDevice->BeginScene();

    // Render the main screen object here
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    g_pD3DDevice->SetTexture( 0, g_mainDisplayTexture.GetTexture() );
    g_mainDisplayPoly.Render( g_pD3DDevice );
    g_pD3DDevice->SetTexture( 0, NULL );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    g_pD3DDevice->EndScene();
    g_pD3DDevice->Present( NULL, NULL, NULL, NULL );
}


// Clean up memory, etc, when neccessary
void CleanUp()
{
    // Clean up our D3D Device object
    if( g_pD3DDevice )
    {
        g_pD3DDevice->Release();
        g_pD3DDevice = NULL;
    }

    if( g_pFont )
    {
        XFONT_Release( g_pFont );
        g_pFont = NULL;
    }

    // Clean up DSound
    if( NULL != g_pDSound )
    {
        g_pDSound->Release();
        g_pDSound = NULL;
    }
}


// Initialize anything necessary for the MU Config program
BOOL Initialize()
{
    // Set the file cache size
    XSetFileCacheSize( FILE_DATA_CACHE_SIZE );

    // Get any launch info and display it in to the debugger
    DWORD dwLDataType;
    LAUNCH_DATA lData;
    ZeroMemory( &lData, sizeof( lData ) );

    if( ERROR_SUCCESS == XGetLaunchInfo( &dwLDataType, &lData ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Received Launch Data:" );

        if( LDT_FROM_DASHBOARD == dwLDataType )
        {
            LD_FROM_DASHBOARD* pDashData = (LD_FROM_DASHBOARD*)&lData;
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DASHBOARD" );
            XDBGWRN( APP_TITLE_NAME_A, "  Context - '%d'", pDashData->dwContext );

        }
        else if( LDT_FROM_DEBUGGER_CMDLINE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DEBUGGER CMDLINE" );
        }
        else if( LDT_TITLE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from TITLE" );
        }
        else
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from UNKNOWN" );
        }
    }

    // Check to see if our media exists on the HD -- If not, Copy it
    if( !g_HardDrive.FileExists( FILE_DATA_DEFAULT_FONT_FILENAME_A ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize(): Must Copy Media!!" );

        char pszSource[MAX_PATH+1];
        
        ZeroMemory( pszSource, MAX_PATH+1 );

        _snprintf( pszSource, MAX_PATH, "d:\\%0.8X", XeImageHeader()->Certificate->TitleID );

        // Copy the media -- Assume in it's our Title Dir
        g_HardDrive.CopyDirs( pszSource, "t:" );

        // Copy the DEFAULT.XBE to the user's E drive
        g_HardDrive.UnMapDrive( 'E' );
        g_HardDrive.MapDrive( 'E', "\\Device\\Harddisk0\\Partition1\\devkit" );
        CopyFile( "d:\\default.xbe", "e:\\GRegionAll.xbe", FALSE );
        g_HardDrive.UnMapDrive( 'E' );
    }

    // Initialize Direct3D
    if( !InitializeD3D() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Failed to InitializeD3D!!" );

        return FALSE;
    }

    ////////////////////////////////////////
    // Setup and Initialize our Default FONT
    ////////////////////////////////////////
    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &g_pFont );

    if( g_pFont )
    {
        // XFONT_SetDrawingSurface( m_BackBuffer );
        XFONT_SetTextColor( g_pFont, SCREEN_DEFAULT_FOREGROUND_COLOR );
        XFONT_SetBkColor( g_pFont, SCREEN_DEFAULT_BACKGROUND_COLOR );
        XFONT_SetTextHeight( g_pFont, SCREEN_DEFAULT_FONT_HEIGHT );
        XFONT_SetTextAntialiasLevel( g_pFont, SCREEN_DEFAULT_FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( g_pFont, SCREEN_DEFAULT_FONT_STYLE );
    }
    else
    {
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize our Font!!" );
    }

    ////////////////////
    // Initialize DSound
    ////////////////////
    if( FAILED( InitDSound() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize DSound!!" );
    }

    // Create our display poly and our display texture
    g_mainDisplayPoly.Initialize( g_pD3DDevice );
    g_mainDisplayTexture.Initialize( g_pD3DDevice, NULL, 1024, 1024 );

    // Render the bitmap to the poly
    BitmapFile Bitmap;
    Bitmap.read( 0, 0, FILE_DATA_DEFAULT_BG_IMAGE_FILENAME );

    g_mainDisplayTexture.Lock();

    Bitmap.render( g_pD3DDevice, g_mainDisplayTexture.GetTextureSurface() );

    void DrawText( float fX1,                               // Prints formatted text, using the default font size
                   float fY1,
                   DWORD dwFGColor,
                   DWORD dwBGColor,
                   const WCHAR* pwszFormat,
                   ... );

    
    void DrawBox( float fX1,                                // Draw a box on the screen
                  float fY1,
                  float fX2,
                  float fY2,
                  DWORD dwColor );

    int iStringLen = GetStringPixelWidth( TEXT_GAME_REGION_INFO );

    unsigned int uiFontHeight;
    unsigned int uiFontWidth;
    GetFontSize( &uiFontHeight, &uiFontWidth );

    float fTopBotYAdjust   = 100.0f;
    float fTopBotBorder    = 5.0f;
    float fLeftRightBorder = 10.0f;

    float X1 = SCREEN_X_CENTER - ( iStringLen / 2.0f ) - fLeftRightBorder;
    float Y1 = SCREEN_HEIGHT - fTopBotYAdjust;

    float X2 = SCREEN_X_CENTER + ( iStringLen / 2.0f ) + fLeftRightBorder;
    float Y2 = Y1 + uiFontHeight + ( fTopBotBorder * 2 );

    g_mainDisplayTexture.DrawBox( X1, Y1, X2, Y2, COLOR_BLACK );
    g_mainDisplayTexture.DrawText( X1 + fLeftRightBorder, Y1 + fTopBotBorder, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, TEXT_GAME_REGION_INFO );

    g_mainDisplayTexture.Unlock();

    return TRUE;
}


// Initalize D3D to be used by our application
BOOL InitializeD3D()
{
    IDirect3D8* pD3D;
    HRESULT hr = S_OK;

    // Create our Direct3D Object
    pD3D = Direct3DCreate8( D3D_SDK_VERSION );
    if( NULL == pD3D )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Object!!" );

        return FALSE;
    }

    // Create our D3D Device Object
    D3DPRESENT_PARAMETERS d3dpp;
	ZeroMemory( &d3dpp, sizeof( d3dpp ) );

    d3dpp.BackBufferWidth                 = SCREEN_WIDTH;
    d3dpp.BackBufferHeight                = SCREEN_HEIGHT;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.MultiSampleType                 = D3DMULTISAMPLE_4_SAMPLES;
    d3dpp.BackBufferCount                 = 1;

    d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
    d3dpp.Windowed                        = FALSE;                   // Must be FALSE for Xbox
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.EnableAutoDepthStencil          = FALSE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
	d3dpp.FullScreen_RefreshRateInHz      = D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE; // D3DPRESENT_INTERVAL_IMMEDIATE;

    if ( FAILED ( hr = pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                           D3DDEVTYPE_HAL,
                                           NULL,
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                           &d3dpp,
                                           &g_pD3DDevice ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Device Object!!" );
    }

    // Release the D3D Object
    // It's ok to simply release this object, as we know we cannot be here if the D3D Object failed creation
    pD3D->Release();
    pD3D = NULL;

    // If the device failed to create, simply abort the rest of the D3D Initialization
    if( !g_pD3DDevice )
    {
        return FALSE;
    }

    // Create our Viewport
    D3DVIEWPORT8 D3DViewport;

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = SCREEN_WIDTH;
    D3DViewport.Height = SCREEN_HEIGHT;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( hr = g_pD3DDevice->SetViewport( &D3DViewport ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to set the D3D Viewport!!" );
    }

    // Set our Renderstates and our Texture Stage States
    //BUGBUG: Tweak these and remove the ones uneccessary
    g_pD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    g_pD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    g_pD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    g_pD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    g_pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE);
    g_pD3DDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
    g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    return TRUE;
}

// Initialize DSound
HRESULT InitDSound()
{
	HRESULT hr = S_OK;

    if( NULL != g_pDSound )
    {
        g_pDSound->Release();
        g_pDSound = NULL;
    }

	if (FAILED(hr = DirectSoundCreate(NULL, &g_pDSound, NULL)))
	{
        XDBGWRN( APP_TITLE_NAME_A, "DirectSoundCreate FAILED!! Error - '0x%.08X'", hr );

        return hr;
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\GameRegions\GRegionAll\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#define BREAK_INTO_DEBUGGER                     _asm { int 3 }
                                                
#define APP_TITLE_NAME_A                        "GREGALL"
                                                
// Video Display Dimensions                     
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2.0f )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2.0f )
#define SCREEN_DEFAULT_FOREGROUND_COLOR         COLOR_TV_BLUE
#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_FONT_HEIGHT              32
#define SCREEN_DEFAULT_FONT_ALIAS_LEVEL         4
#define SCREEN_DEFAULT_FONT_STYLE               XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS

#define TEXT_GAME_REGION_INFO                   L"Game Region All"

// Colors                                       
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_RED                               0xFFFF0000
#define COLOR_TV_RED                            0xFF8D3232
#define COLOR_GREEN                             0xFF00FF00
#define COLOR_BLUE                              0xFF0000FF
#define COLOR_TV_LIGHT_BLUE                     0xFFA1A7FF
#define COLOR_TV_BLUE                           0xFF20209F
#define COLOR_LIGHT_YELLOW                      0xFFDDD078
#define COLOR_TV_YELLOW                         0xFFEFEF30
#define COLOR_DARK_GREEN                        0xFF357515

// File path and location constants
#define FILE_DATA_CACHE_SIZE                    5120000
#define FILE_DATA_DRIVE_A                       "t:"
#define FILE_DATA_DRIVE                         L"t:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\images"
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"
#define FILE_DATA_DEFAULT_FONT_FILENAME_A       FILE_DATA_MEDIA_DIRECTORY_A "\\tahoma.ttf"
#define FILE_DATA_DEFAULT_STARTSOUND_FILENAME_A FILE_DATA_MEDIA_DIRECTORY_A "\\startsound.wav"
#define FILE_DATA_DEFAULT_BG_IMAGE_FILENAME     FILE_DATA_IMAGE_DIRECTORY_A "\\background.bmp"

// Vertex Definitions
struct MYVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    cDiffuse;
};

struct MYTEXVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    diffuse;
    float       tu, tv;    // The texture coordinates
};

#define D3DFVF_MYVERTEX     ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE )
#define D3DFVF_MYTEXVERTEX  ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1 )

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\3dobject.h ===
#ifndef _3DOBJECT_H_
#define _3DOBJECT_H_

/*
class Face
{
public:	
	WORD        m_wPoint[3];
	D3DXVECTOR3 m_normal;
};

class Quaternion
{
public:
	float m_fW;
	float m_fX;
	float m_fY;
	float m_fZ;
};
*/

class C3DObject
{
public:
    // Constructors and Destructors
    C3DObject(void);
	~C3DObject(void);

    // Public Properties
	D3DXMATRIX   m_WorkMatrix;
	D3DXMATRIX   m_ObjectMatrix;
	D3DXVECTOR4  m_TranslateVector;

    // Public Methods
	void translate( float x, float y, float z );
	void rotateX( float x );
	void rotateY( float y );
	void rotateZ( float z );
	void spinX( float x );
	void spinY( float y );
	void spinZ( float z );
	void localRotateX( float x );
	void localRotateY( float y );
	void localRotateZ( float z );
};

#endif // _3DOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\3dobject.cpp ===
#include "stdafx.h"
#include "3dobject.h"

float divPI = 0.01745f;


// Constructor
C3DObject::C3DObject( void )
{
}


// Desctructor
C3DObject::~C3DObject( void )
{
}


void C3DObject::translate( float x, float y, float z )
{
	m_TranslateVector = m_TranslateVector + D3DXVECTOR4( x, y, z, 0.0f );
}


void C3DObject::rotateX( float x )
{
	D3DXMatrixRotationX( &m_WorkMatrix, x * divPI );

	m_ObjectMatrix = m_WorkMatrix * m_ObjectMatrix;
	D3DXVec4Transform( &m_TranslateVector, &m_TranslateVector, &m_WorkMatrix );
}


void C3DObject::rotateY( float y )
{
	D3DXMatrixRotationY( &m_WorkMatrix, y * divPI );

	m_ObjectMatrix = m_WorkMatrix * m_ObjectMatrix;
	D3DXVec4Transform( &m_TranslateVector, &m_TranslateVector, &m_WorkMatrix );
}


void C3DObject::rotateZ( float z )
{
	D3DXMatrixRotationZ( &m_WorkMatrix, z * divPI );

	m_ObjectMatrix = m_WorkMatrix * m_ObjectMatrix;
	D3DXVec4Transform( &m_TranslateVector, &m_TranslateVector, &m_WorkMatrix );
}


void C3DObject::spinX( float x )
{
	D3DXMatrixRotationX( &m_WorkMatrix, x * divPI );

	m_ObjectMatrix = m_WorkMatrix * m_ObjectMatrix;
}


void C3DObject::spinY( float y )
{
	D3DXMatrixRotationY( &m_WorkMatrix, y * divPI );

	m_ObjectMatrix = m_WorkMatrix * m_ObjectMatrix;
}


void C3DObject::spinZ( float z )
{
	D3DXMatrixRotationZ( &m_WorkMatrix, z * divPI );

	m_ObjectMatrix = m_WorkMatrix * m_ObjectMatrix;
}


void C3DObject::localRotateX( float x )
{
	D3DXMatrixRotationX( &m_WorkMatrix, x * divPI );

	m_ObjectMatrix = m_ObjectMatrix * m_WorkMatrix;
}


void C3DObject::localRotateY( float y )
{
	D3DXMatrixRotationY( &m_WorkMatrix, y * divPI );

	m_ObjectMatrix = m_ObjectMatrix * m_WorkMatrix;
}


void C3DObject::localRotateZ( float z )
{
	D3DXMatrixRotationZ( &m_WorkMatrix, z * divPI );

	m_ObjectMatrix = m_ObjectMatrix * m_WorkMatrix;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\avregionmenu.h ===
/*****************************************************
*** avregionmenu.h
***
*** Header file for our AV Region menu class.  This
*** class will allow a user to select a new AV
*** region
***
*** by James Helm
*** May 13th, 2001
***
*****************************************************/

#ifndef _AVREGIONMENU_H_
#define _AVREGIONMENU_H_

#include "keypadmenu.h"  // Base menu type

class CAVRegionMenu : public CKeypadMenu
{
public:
    // Constructors and Destructor
    CAVRegionMenu( CXItem* pParent );
    ~CAVRegionMenu();

    // Methods
    void Enter();                                                       // This will be called whenever the user enters this menu
    void Action( CUDTexture* pTexture );  // Perform our actions (draw the screen items, etc)
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );   // Handle input to the buttons
    void HandleInput( enum CONTROLS buttonPressed, BOOL bFirstPress );

private:
    // Properties
    CKey m_keyPad[MENU_AVREGION_NUM_COLS][MENU_AVREGION_NUM_ROWS];  // Keypad

    void GenerateKeypad(void);
	BOOL renderKeypad( CUDTexture* pTexture );

    DWORD GetAVRegion();                            // Get the AV Region in a 'menu-friendly' format
    HRESULT SetAVRegion( DWORD dwAVRegion );        // Set the AV Region using our 'menu-friendly' format
};

#endif // _AVREGIONMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\avregionmenu.cpp ===
/*****************************************************
*** avregionmenu.cpp
***
*** CPP file for our AV Region menu class.  This
*** class will allow a user to select a new AV
*** region
***
*** by James Helm
*** May 11th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "avregionmenu.h"

extern CXSettings g_XboxSettings;   // Xbox Settings Object

// Constructor
CAVRegionMenu::CAVRegionMenu( CXItem* pParent )
: CKeypadMenu( pParent )
{
    XDBGTRC( APP_TITLE_NAME_A, "CAVRegionMenu::CAVRegionMenu( CXItem )" );

    // Set the number of items on the menu
    m_uiNumItems = AVREGIONMENU_ITEM_NUM_ITEMS;
    SetSelectedItem( 0 );

	GenerateKeypad();

    // Default the key to the TOP Button
	m_xKeypos = 0;
	m_yKeypos = 0;
}


// Destructor
CAVRegionMenu::~CAVRegionMenu()
{
}

// Draws a menu on to the screen
void CAVRegionMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should update our texture, if not, return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else // Reset the Update flag
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture so we can render to it
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );
    
    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

    //
	// Render the current AV Region Text
    //
    int iStringPixelWidth = GetStringPixelWidth( MENU_AVREGION_CURRENT_REGION_TEXT );
    float fXPos = SCREEN_X_CENTER - ( iStringPixelWidth / 2.0f );
    float fYPos = MENU_AVREGION_TEXT_Y1;
    pTexture->DrawText( fXPos, fYPos, SCREEN_INACTIVE_OPTION_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", MENU_AVREGION_CURRENT_REGION_TEXT );

    iStringPixelWidth = GetStringPixelWidth( g_wpszAVRegionMenuItems[GetAVRegion()] );
    fXPos = SCREEN_X_CENTER - ( iStringPixelWidth / 2.0f );
    unsigned int uiFontHeight, uiFontWidth;
    GetFontSize( &uiFontHeight, &uiFontWidth );
    fYPos = MENU_AVREGION_TEXT_Y1 + uiFontHeight + MENUBOX_ITEM_VERT_SPACING;
    pTexture->DrawText( fXPos, fYPos, SCREEN_ACTIVE_OPTION_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", g_wpszAVRegionMenuItems[GetAVRegion()] );
    
    //
    // Draw our keypad / AV Region Menu Items
    //
	renderKeypad( pTexture );

    // Unlock our Texture
    pTexture->Unlock();
}

// Handles input (of the BUTTONS) for the current menu
void CAVRegionMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Don't update the setting unless the user is on one of the buttons
            if( 0 == m_xKeypos )
            {
                m_bUpdateTexture = TRUE;

                // Set the AV Region in to the Config Sector
                HRESULT hr = SetAVRegion( m_yKeypos ); // m_yKeypos will map to the enum AVRegionMenu items
                if( FAILED( hr ) )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "CAVRegionMenu::HandleInput():Failed to set the AV Region!! Region - '%d', Error - '0x%X.08'", m_yKeypos, hr );
                }

                Leave( GetParent() );
            }
            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                Leave( GetParent() );
            }
            break;
        }
    }
}

// Handles input (of the CONTROLS) for the current menu
void CAVRegionMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            if( m_yKeypos != 0 )
            {
                m_bUpdateTexture = TRUE;

                m_yKeypos--;
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            if( m_yKeypos < ( AVREGIONMENU_ITEM_NUM_ITEMS - 1 ) )
            {
                m_bUpdateTexture = TRUE;

				m_yKeypos++;
            }
            break;
        }
    case CONTROL_DPAD_LEFT:
        {
            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            break;
        }
	}
}


void CAVRegionMenu::GenerateKeypad(void) 
{
	// First create numberpad
	int xgrid  = MENU_AVREGION_NUM_COLS;
	int ygrid  = MENU_AVREGION_NUM_ROWS;
	int xstart = MENU_AVREGION_BUTTON_X1;
	int ystart = MENU_AVREGION_BUTTON_Y1;
	int width  = MENU_AVREGION_BUTTON_WIDTH;
	int height = 32;
	int spacer = 2;

	int currentx = xstart;
	int currenty = ystart;

	for(int y = 0; y < ygrid; y++)
	{
		for(int x = 0; x < xgrid; x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_FOREGROUND_COLOR );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}

    // Set the text of the keys
    for( int z = 0; z < AVREGIONMENU_ITEM_NUM_ITEMS; z++ )
    {
        m_keyPad[0][z].defineText(g_wpszAVRegionMenuItems[z]);
    }
}


BOOL CAVRegionMenu::renderKeypad( CUDTexture* pTexture )
{
	
	// Render outlines of keys	
	float x1, x2;
	float y1, y2;
	for(int x = 0; x < MENU_AVREGION_NUM_COLS; x++)
	{
		for(int y = 0; y < MENU_AVREGION_NUM_ROWS; y++)
		{
			if(m_keyPad[x][y].getRender())
			{
                // Lock our texture
                pTexture->Lock();

				x1 = (float)m_keyPad[x][y].m_iXOrigin;
				x2 = (float)(m_keyPad[x][y].m_iXOrigin + m_keyPad[x][y].m_iWidth);
				
				y1 = (float)m_keyPad[x][y].m_iYOrigin;
				y2 = (float)(m_keyPad[x][y].m_iYOrigin + m_keyPad[x][y].m_iHeight);
	
				// hilight key if currently selected
                DWORD dwCharColor;
				if((m_xKeypos == x) && (m_yKeypos == y))
                {
					pTexture->DrawBox( x1, y1, x2, y2, SCREEN_DEFAULT_SELECTOR_COLOR );
                    
                    dwCharColor = SCREEN_SELECTED_OPTION_COLOR;
                }
                else
                {
                    dwCharColor = SCREEN_DEFAULT_FOREGROUND_COLOR;
                }

                pTexture->DrawOutline( x1, y1, x2, y2, MENU_AVREGION_LINE_WIDTH, m_keyPad[x][y].m_dwSelectColor );
				
				unsigned int decent;
				unsigned int fontHeight;
				GetFontSize( &fontHeight, &decent );
				
				float textX = (float)((m_keyPad[x][y].m_iWidth / 2) + m_keyPad[x][y].m_iXOrigin) - GetStringPixelWidth( m_keyPad[x][y].m_pwszResultChar ) / 2;
				float textY = (float)((m_keyPad[x][y].m_iHeight / 2) + m_keyPad[x][y].m_iYOrigin) - (fontHeight / 2);
				pTexture->DrawText( textX, textY, dwCharColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", m_keyPad[x][y].m_pwszResultChar);

                // Unlock our Texture
                pTexture->Unlock();
			}
		}
	}
	
	return TRUE;
}

// This will be called whenever the user enters this menu
void CAVRegionMenu::Enter()
{
    // Call the base-class enter
    CKeypadMenu::Enter();

    // Default the key to the TOP Button
	m_xKeypos = 0;
	m_yKeypos = GetAVRegion();
}


// Get the AV Region in a 'menu-friendly' format
DWORD CAVRegionMenu::GetAVRegion()
{
    switch( g_XboxSettings.GetAVRegion() )
    {
    case XSETTINGS_DISPLAY_SETTING_NTSC_M:
        {
            return AVREGIONMENU_ITEM_REGION1;

            break;
        }
    case XSETTINGS_DISPLAY_SETTING_NTSC_J:
        {
            return AVREGIONMENU_ITEM_REGION2;

            break;
        }
    case XSETTINGS_DISPLAY_SETTING_PAL_I:
        {
            return AVREGIONMENU_ITEM_REGION3;

            break;
        }
    default:
        {
            XDBGWRN( APP_TITLE_NAME_A, "CAVRegionMenu::GetAVRegion():Received unknown AV Region from Config Sector!! Region - '%d'", g_XboxSettings.GetAVRegion() );
            XDBGWRN( APP_TITLE_NAME_A, "CAVRegionMenu::GetAVRegion():Setting AV Region to - '%d'", XSETTINGS_DISPLAY_SETTING_NTSC_M );

            HRESULT hr = g_XboxSettings.SetAVRegion( XSETTINGS_DISPLAY_SETTING_NTSC_M );
            if( FAILED( hr ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CAVRegionMenu::GetAVRegion():Failed to Set the AV Region!! Region - '%d', Error - '0x%0.8X (%d)'", XSETTINGS_DISPLAY_SETTING_NTSC_M, hr, hr );
            }

            break;
        }
    }

    return XSETTINGS_DISPLAY_SETTING_NONE;
}


// Set the AV Region using our 'menu-friendly' format
HRESULT CAVRegionMenu::SetAVRegion( DWORD dwAVRegion )
{
    DWORD dwConfigSectorAVRegion = XSETTINGS_DISPLAY_SETTING_NONE;

    switch( dwAVRegion )
    {
    case AVREGIONMENU_ITEM_REGION1:
        {
            dwConfigSectorAVRegion = XSETTINGS_DISPLAY_SETTING_NTSC_M;

            break;
        }
    case AVREGIONMENU_ITEM_REGION2:
        {
            dwConfigSectorAVRegion = XSETTINGS_DISPLAY_SETTING_NTSC_J;

            break;
        }
    case AVREGIONMENU_ITEM_REGION3:
        {
            dwConfigSectorAVRegion = XSETTINGS_DISPLAY_SETTING_PAL_I;

            break;
        }
    default:
        {
            XDBGWRN( APP_TITLE_NAME_A, "CAVRegionMenu::SetAVRegion():Invalid AV Region Passed In - '%d'", dwAVRegion );

            return E_INVALIDARG;
        }
    }

    HRESULT hr = g_XboxSettings.SetAVRegion( dwConfigSectorAVRegion );
    if( FAILED( hr ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CAVRegionMenu::SetAVRegion():Failed to set the AV Region!! Region - '%d', Error - '0x%0.8X (%d)'", dwConfigSectorAVRegion, hr, hr );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\LKeyGen\lkeygen.cpp ===
#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <xcrypt.h>

BOOL GetMacAddressFromUser( unsigned char* pszBuffer );
void ComputeSecretKey( BYTE* pbMacAddress, int iMacAddressSize, char* pszBuffer );
void Usage();   // Display usage for the program
BOOL ValidMACAddress( unsigned char* pszMacAddress );
void DisplaySecretCode( char* pszCode );
BOOL MACStringToHexString( unsigned char* pszMacAddress );

int __cdecl main( int argc, char* argv[] )
{
    unsigned char pszMacAddress[13];
    char pszSecretKey[5];
    BOOL bValidAddress = FALSE;

    ZeroMemory( pszMacAddress, 13 );
    ZeroMemory( pszSecretKey, 5 );

    if( argc > 2 )
    {
        Usage();

        return 0;
    }

    if( argc == 2 )
    {
        // First check to see if they are asking for Help or Usage
        if( ( strcmp( argv[1], "/?" ) == 0 ) || 
            ( strcmp( argv[1], "-?" ) == 0 ) ||
            ( strcmp( argv[1], "?" ) == 0 ) )
        {
            Usage();

            return 0;
        }

        // Check to see if the parameter is a valid MAC Address
        if( bValidAddress = ValidMACAddress( (unsigned char*)argv[1] ) )
        {
            strcpy( (char*)pszMacAddress, argv[1] );
        }
    }
    else
    //
    // Get the MAC Address from the user via the keyboard
    //
    {
        printf("Please enter the Title MAC Address: ");
        bValidAddress = GetMacAddressFromUser( pszMacAddress );
    }

    if( !bValidAddress )
    {
        printf( "Invalid MAC Address entered.\r\n" );

        return -1;
    }

    //
    // Convert our 12 byte string to a 6 byte Hex value string
    //
    if( !MACStringToHexString( pszMacAddress ) )
    {
        printf( "Failed to properly convert the MAC Address!!\r\n" );

        return -1;
    }

    //
    // Must be a valid MAC Address.
    //

    // Generate the key code
    ComputeSecretKey( (BYTE*)pszMacAddress, 6, pszSecretKey );

    // Display the Secret Code in a friendly manner
    DisplaySecretCode( pszSecretKey );

    return 0;
};


BOOL GetMacAddressFromUser( unsigned char* pszBuffer )
{
    BOOL bReturn = TRUE;
    BOOL bExit = FALSE;
    unsigned int x = 0;

    if( NULL == pszBuffer )
    {
        return FALSE;
    }

    while( !bExit ) // ( x < 12 )
    {
        int iChar = _getch();
        
        // Check for valid inputs
        if( ( iChar >= 48 && iChar <= 57 ) || ( iChar >= 65 && iChar <= 70 ) || ( iChar >= 97 && iChar <= 102 ) )
        //
        // Valid input
        //
        {
            if( x < 12 )
            {
                printf( "%c", iChar );
                pszBuffer[x++] = (UCHAR)iChar;
            }
        }
        else if( iChar == 8 )  // Check for back space key
        {
            if( x > 0 ) // Check to see if we have at least 1 character to backspace
            {
                printf( "%c %c", iChar, iChar );
                pszBuffer[--x] = '\0';
            }
        }
        else if( iChar == 13 )   // Check for ENTER key
        //
        // Check for return code
        //
        {
            bExit = TRUE;
            printf( "\r\n", iChar );

            if( x < 12 )
            {
                // Invalid input
                bReturn = FALSE;
            }
        }
    }

    return bReturn;
}


void DisplaySecretCode( char* pszCode )
{
    unsigned int x = 0;

    if( NULL == pszCode )
    {
        return;
    }

    printf( "\r\nEnter the following code:\r\n    " );
    for( x = 0; x < 4; x++ )
    {
        switch( pszCode[x] )
        {
        case 'A':
            printf( "A button" );
            break;
        case 'B':
            printf( "B button" );
            break;
        case 'Y':
            printf( "Y button" );
            break;
        case 'X':
            printf( "X button" );
            break;
        case 'L':
            printf( "Black button" );
            break;
        case 'W':
            printf( "White button" );
            break;
        case 'U':
            printf( "DPAD Up" );
            break;
        case 'D':
            printf( "DPAD Down" );
            break;
        case 'F':
            printf( "DPAD Left" );
            break;
        case 'R':
            printf( "DPAD Right" );
            break;
        case 'T':
            printf( "Left Thumb Button" );
            break;
        case 'I':
            printf( "Right Thumb Button" );
            break;
        case 'E':
            printf( "Left Trigger" );
            break;
        case 'O':
            printf( "Right Trigger" );
            break;
        }

        if( x < 3 )
            printf( " --> " );
        else
            printf( "\r\n" );
    }
}

// These should never change
#define SYMMETRIC_KEY_LEN 16
#define SECRET_RAND_KEY "\xAC\x21\x07\x1B\xB5\x94\xE8\x23\x50\x33\x4A\x71\x72\x7A\xD5\x91"
#define SECRET_RAND_KEY_LEN SYMMETRIC_KEY_LEN

// A   - A Button
// B   - B Button
// Y   - Y Button
// X   - X Button
// L   - bLack Button
// W   - White Button
// U   - DPAD Up
// D   - DPAD Down
// F   - DPAD leFt
// R   - DPAD Right
// T   - Left Thumb Button
// I   - rIght Thumb Position
// E   - lEft trigger button
// O   - right trigger buttOn
void ComputeSecretKey( BYTE* pbMacAddress, int iMacAddressSize, char* pszBuffer )
{

    BYTE Digest[XC_SERVICE_DIGEST_SIZE];
    WORD* pwDigestWORD = (WORD*)(&Digest[0]);
    int i = 4;
    
    // Don't use "A" or "X" button in the combination
    char* secretKeyMap = "BYLWUDFRTIEO";

    if( ( NULL == pszBuffer ) || ( NULL == pbMacAddress ) )
    {
        return;
    }
    
    
    XcHMAC( (LPBYTE)SECRET_RAND_KEY, SECRET_RAND_KEY_LEN,
            pbMacAddress, iMacAddressSize,
            NULL, 0,
            Digest );
    

    RtlZeroMemory( pszBuffer, 4 );
    while ( --i >= 0 )
    {
        pszBuffer[i] = secretKeyMap[ (*pwDigestWORD++) % 12 ];
    }
}


BOOL ValidMACAddress( unsigned char* pszMacAddress )
{
    unsigned int x = 0;

    if( NULL == pszMacAddress )
    {
        return FALSE;
    }

    // First check the length
    if( strlen( (char*)pszMacAddress ) != 12 )
    {
        return FALSE;
    }

    // Check the characters
    for( x = 0; x < 12; x++ )
    {
        if( ( pszMacAddress[x] < 48 ) || ( pszMacAddress[x] > 102 ) )
            return FALSE;

        if( ( pszMacAddress[x] > 57 ) && ( pszMacAddress[x] < 65 ) )
            return FALSE;

        if( ( pszMacAddress[x] > 70 ) && ( pszMacAddress[x] < 97 ) )
            return FALSE;
    }

    return TRUE;
}


BOOL MACStringToHexString( unsigned char* pszStringMacAddress )
{
    // unsigned char* pszTemp = pszStringMacAddress;  // Hack for VC6 Compiler

    int iTemp[6];
    ZeroMemory( iTemp, 6 * sizeof( iTemp[0] ) );

    if( sscanf( (char*)pszStringMacAddress, "%2x%2x%2x%2x%2x%2x", &iTemp[0], &iTemp[1], &iTemp[2], &iTemp[3], &iTemp[4], &iTemp[5] ) != 6)
    {
        printf( "Error in converting the MAC Address String to HEX Ints!\r\n" );

        return FALSE;
    }

    for( unsigned int x = 0; x < 6; x++ )
    {
        pszStringMacAddress[x] = (UCHAR)iTemp[x];
    }
    
    pszStringMacAddress[x] = '\0';

    return TRUE;
}


void Usage()
{
    printf( "Generates the secret key to display Xbox information from the XDK Launcher.\r\n" );
    printf( "\r\n" );
    printf( "LKEYGEN [Xbox Title MAC Address]\r\n" );
    printf( "\r\n" );
    printf( "  [Xbox Title MAC Address]\r\n" );
    printf( "               The debug MAC address of the Xbox for which the key should be generated.\r\n" );
    printf( "               This is an optional parameter.  If not specified, the program will prompt\r\n" );
    printf( "               for the MAC address.  The MAC address must be 12 digits long.\r\n" );
    printf( "\r\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\datetimemenu.cpp ===
/*****************************************************
*** datetimemenu.h
***
*** Header file for our DATE/TIME menu class.  This
*** menu will allow the user to select a different
*** date / time.
***
*** by James N. Helm
*** June 18th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "datetimemenu.h"

// Constructors
CDateTimeMenu::CDateTimeMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_bDateTimeModified( FALSE )
{
    XDBGWRN( APP_TITLE_NAME_A, "CDateTimeMenu::CDateTimeMenu()" );

    m_uiNumItems = DATETIMEMENU_NUM_ITEMS;
    SetSelectedItem( 0 );

    ZeroMemory( &m_sysTime, sizeof( m_sysTime ) );
    GetSystemTime( &m_sysTime );

    m_dwTickCount = GetTickCount();
}


// Destructor
CDateTimeMenu::~CDateTimeMenu()
{
}


// Draws a menu on to the screen
void CDateTimeMenu::Action( CUDTexture* pTexture )
{
    if( ( ( GetTickCount() - m_dwTickCount ) > 1000 ) && ( !m_bDateTimeModified ) )
    {
        m_dwTickCount = GetTickCount();
        GetSystemTime( &m_sysTime );

        m_bUpdateTexture = TRUE;
    }

    // Check to see if we should update the texture
    // If not, return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else // reset the texture flag to FALSE
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

    // Create the Time String to be displayed
    WCHAR pwszTimeString[50];
    ZeroMemory( pwszTimeString, sizeof( WCHAR ) * 50 );
    _snwprintf( pwszTimeString, 49, L"%02d:%02d:%02d  %02d/%02d/%04d", m_sysTime.wHour, m_sysTime.wMinute, m_sysTime.wSecond, m_sysTime.wMonth, m_sysTime.wDay, m_sysTime.wYear );
    /*
    char pszHour[3], pszMinute[3], pszSecond[3], pszMonth[3], pszDay[3], pszYear[5];
    pszHour[2] = pszMinute[2] = pszSecond[2] = pszMonth[2] = pszDay[2] = pszYear[4] = '\0';

    sprintf( pszHour, "%02d", m_sysTime.wHour );
    sprintf( pszMinute, "%02d", m_sysTime.wMinute );
    sprintf( pszSecond, "%02d", m_sysTime.wSecond );
    sprintf( pszMonth, "%02d", m_sysTime.wMonth );
    sprintf( pszDay, "%02d", m_sysTime.wDay );
    sprintf( pszYear, "%04d", m_sysTime.wYear );
    */

    // Calculate the position of the string on the screen
    float XPos = SCREEN_X_CENTER - ( GetStringPixelWidth( pwszTimeString ) / 2.0f );
    float YPos = SCREEN_Y_CENTER - ( m_uiFontHeightOfItem / 2.0f ); // MENUBOX_MAINAREA_Y1 + MENUBOX_MAINAREA_BORDERWIDTH_TOP + ( ( MENUBOX_ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * x );

    // Draw a selector around the current item
    float X1Pos, X2Pos, Y1Pos, Y2Pos;
    WCHAR pwszTempString[50];
    ZeroMemory( pwszTempString, sizeof( WCHAR ) * 50 );

    // We can calculate the YPos for the items no matter what they are
    Y1Pos = YPos - MENUBOX_SELECTOR_BORDER_WIDTH; // MENUBOX_MAINAREA_Y1 + MENUBOX_MAINAREA_BORDERWIDTH_TOP + ( ( MENUBOX_ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * GetSelectedItem() ) - MENUBOX_SELECTOR_BORDER_WIDTH;
    Y2Pos = YPos + m_uiFontHeightOfItem + MENUBOX_SELECTOR_BORDER_WIDTH;

    switch( GetSelectedItem() )
    {
    case DATETIMEMENU_HOURS:
        {
            X1Pos = XPos - MENUBOX_SELECTOR_BORDER_WIDTH; // MENUBOX_SELECTOR_X1;
            _snwprintf( pwszTempString, 49, L"%02d", m_sysTime.wHour );
            X2Pos = XPos + GetStringPixelWidth( pwszTempString ) + MENUBOX_SELECTOR_BORDER_WIDTH;

            break;
        }
    case DATETIMEMENU_MINUTES:
        {
            _snwprintf( pwszTempString, 49, L"%02d:", m_sysTime.wHour );
            X1Pos = XPos + GetStringPixelWidth( pwszTempString ) - MENUBOX_SELECTOR_BORDER_WIDTH; // MENUBOX_SELECTOR_X1;
            _snwprintf( pwszTempString, 49, L"%02d:%02d", m_sysTime.wHour, m_sysTime.wMinute );
            X2Pos = XPos + GetStringPixelWidth( pwszTempString ) + MENUBOX_SELECTOR_BORDER_WIDTH;

            break;
        }
    case DATETIMEMENU_SECONDS:
        {
            _snwprintf( pwszTempString, 49, L"%02d:%02d:", m_sysTime.wHour, m_sysTime.wMinute );
            X1Pos = XPos + GetStringPixelWidth( pwszTempString ) - MENUBOX_SELECTOR_BORDER_WIDTH; // MENUBOX_SELECTOR_X1;
            _snwprintf( pwszTempString, 49, L"%02d:%02d:%02d", m_sysTime.wHour, m_sysTime.wMinute, m_sysTime.wSecond );
            X2Pos = XPos + GetStringPixelWidth( pwszTempString ) + MENUBOX_SELECTOR_BORDER_WIDTH;

            break;
        }
    case DATETIMEMENU_MONTHS:
        {
            _snwprintf( pwszTempString, 49, L"%02d:%02d:%02d  ", m_sysTime.wHour, m_sysTime.wMinute, m_sysTime.wSecond );
            X1Pos = XPos + GetStringPixelWidth( pwszTempString ) - MENUBOX_SELECTOR_BORDER_WIDTH; // MENUBOX_SELECTOR_X1;
            _snwprintf( pwszTempString, 49, L"%02d:%02d:%02d  %02d", m_sysTime.wHour, m_sysTime.wMinute, m_sysTime.wSecond, m_sysTime.wMonth );
            X2Pos = XPos + GetStringPixelWidth( pwszTempString ) + MENUBOX_SELECTOR_BORDER_WIDTH;

            break;
        }
    case DATETIMEMENU_DAYS:
        {
            _snwprintf( pwszTempString, 49, L"%02d:%02d:%02d  %02d/", m_sysTime.wHour, m_sysTime.wMinute, m_sysTime.wSecond, m_sysTime.wMonth );
            X1Pos = XPos + GetStringPixelWidth( pwszTempString ) - MENUBOX_SELECTOR_BORDER_WIDTH; // MENUBOX_SELECTOR_X1;
            _snwprintf( pwszTempString, 49, L"%02d:%02d:%02d  %02d/%02d", m_sysTime.wHour, m_sysTime.wMinute, m_sysTime.wSecond, m_sysTime.wMonth, m_sysTime.wDay );
            X2Pos = XPos + GetStringPixelWidth( pwszTempString ) + MENUBOX_SELECTOR_BORDER_WIDTH;

            break;
        }
    case DATETIMEMENU_YEARS:
        {
            _snwprintf( pwszTempString, 49, L"%02d:%02d:%02d  %02d/%02d/", m_sysTime.wHour, m_sysTime.wMinute, m_sysTime.wSecond, m_sysTime.wMonth, m_sysTime.wDay );
            X1Pos = XPos + GetStringPixelWidth( pwszTempString ) - MENUBOX_SELECTOR_BORDER_WIDTH; // MENUBOX_SELECTOR_X1;
            _snwprintf( pwszTempString, 49, L"%02d:%02d:%02d  %02d/%02d/%04d", m_sysTime.wHour, m_sysTime.wMinute, m_sysTime.wSecond, m_sysTime.wMonth, m_sysTime.wDay, m_sysTime.wYear );
            X2Pos = XPos + GetStringPixelWidth( pwszTempString ) + MENUBOX_SELECTOR_BORDER_WIDTH;

            break;
        }
    }

    pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, SCREEN_DEFAULT_SELECTOR_COLOR );

    // Draw time
    pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%ls", pwszTimeString );

    // Unlock our texture and restore our render target
    pTexture->Unlock();
}


// Handle any requests for the joystick (thumb-pad)
void CDateTimeMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_LEFT, bFirstXPress );
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_RIGHT, bFirstXPress );
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CDateTimeMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = INPUT_KEYPRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = INPUT_KEYPRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_LEFT:
        {
            if( GetSelectedItem() > 0 )
            {
                m_bUpdateTexture = TRUE;

                SetSelectedItem( GetSelectedItem() - 1 );
            }
            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            if( GetSelectedItem() < (int)( GetNumItems() - 1 ) )
            {
                m_bUpdateTexture = TRUE;

                SetSelectedItem( GetSelectedItem() + 1 );
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            m_bUpdateTexture = TRUE;
            m_bDateTimeModified = TRUE;

            switch( GetSelectedItem() )
            {
            case DATETIMEMENU_HOURS:
                {
                    if( m_sysTime.wHour > 0 )
                    {
                        m_sysTime.wHour--;
                    }
                    else
                    {
                        m_sysTime.wHour = 23;
                    }

                    break;
                }
            case DATETIMEMENU_MINUTES:
                {
                    if( m_sysTime.wMinute > 0 )
                    {
                        m_sysTime.wMinute--;
                    }
                    else
                    {
                        m_sysTime.wMinute = 59;
                    }

                    break;
                }
            case DATETIMEMENU_SECONDS:
                {
                    if( m_sysTime.wSecond > 0 )
                    {
                        m_sysTime.wSecond--;
                    }
                    else
                    {
                        m_sysTime.wSecond = 59;
                    }

                    break;
                }
            case DATETIMEMENU_MONTHS:
                {
                    if( m_sysTime.wMonth > 1 )
                    {
                        m_sysTime.wMonth--;
                    }
                    else
                    {
                        m_sysTime.wMonth = 12;
                    }

                    break;
                }
            case DATETIMEMENU_DAYS:
                {
                    if( m_sysTime.wDay > 1 )
                    {
                        m_sysTime.wDay--;
                    }
                    else
                    {
                        m_sysTime.wDay = 31;
                    }

                    break;
                }
            case DATETIMEMENU_YEARS:
                {
                    if( m_sysTime.wYear > 1980 )
                    {
                        m_sysTime.wYear--;
                    }
                    else
                    {
                        m_sysTime.wYear = 2099;
                    }

                    break;
                }
            }

            break;
        }
    case CONTROL_DPAD_UP:
        {
            m_bUpdateTexture = TRUE;
            m_bDateTimeModified = TRUE;

            switch( GetSelectedItem() )
            {
            case DATETIMEMENU_HOURS:
                {
                    if( m_sysTime.wHour < 23 )
                    {
                        m_sysTime.wHour++;
                    }
                    else
                    {
                        m_sysTime.wHour = 0;
                    }

                    break;
                }
            case DATETIMEMENU_MINUTES:
                {
                    if( m_sysTime.wMinute < 59 )
                    {
                        m_sysTime.wMinute++;
                    }
                    else
                    {
                        m_sysTime.wMinute = 0;
                    }

                    break;
                }
            case DATETIMEMENU_SECONDS:
                {
                    if( m_sysTime.wSecond < 59 )
                    {
                        m_sysTime.wSecond++;
                    }
                    else
                    {
                        m_sysTime.wSecond = 0;
                    }

                    break;
                }
            case DATETIMEMENU_MONTHS:
                {
                    if( m_sysTime.wMonth < 12 )
                    {
                        m_sysTime.wMonth++;
                    }
                    else
                    {
                        m_sysTime.wMonth = 1;
                    }

                    break;
                }
            case DATETIMEMENU_DAYS:
                {
                    if( m_sysTime.wDay < 31 )
                    {
                        m_sysTime.wDay++;
                    }
                    else
                    {
                        m_sysTime.wDay = 1;
                    }

                    break;
                }
            case DATETIMEMENU_YEARS:
                {
                    if( m_sysTime.wYear < 2099 )
                    {
                        m_sysTime.wYear++;
                    }
                    else
                    {
                        m_sysTime.wYear = 1980;
                    }

                    break;
                }
            }

            break;
        }
    }
}


// Handles input (of the BUTTONS) for the current menu
void CDateTimeMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Refresh our Texture
            m_bUpdateTexture = TRUE;

            switch( GetSelectedItem() )
            {
            case DATETIMEMENU_HOURS:
                {
                    break;
                }
            case DATETIMEMENU_MINUTES:
                {
                    break;
                }
            case DATETIMEMENU_SECONDS:
                {
                    break;
                }
            case DATETIMEMENU_MONTHS:
                {
                    break;
                }
            case DATETIMEMENU_DAYS:
                {
                    break;
                }
            case DATETIMEMENU_YEARS:
                {
                    break;
                }
            }

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                Leave( GetParent() );
            }
            break;
        }
    case BUTTON_X:
        {
            break;
        }
    case BUTTON_Y:
        {
            break;
        }
    case BUTTON_BLACK:
        {
            break;
        }
    case BUTTON_WHITE:
        {
            break;
        }
    }
}


// Initialize the Menu
HRESULT CDateTimeMenu::Init( IDirect3DDevice8* pD3DDevice, char* menuFileName )
{
    XDBGWRN( APP_TITLE_NAME_A, "CDateTimeMenu::Init()" );

    HRESULT hr = CMenuScreen::Init( pD3DDevice, menuFileName );

    return hr;
}


/*
// Should be called whenever a user leaves the menu
void CDateTimeMenu::Leave( CXItem* pItem )
{
    // Call our base class leave
    CMenuScreen::Leave( pItem );

    // Default our selection to the top item when the user returns
    // SetSelectedItem( 0 );
}

// This will be called whenever the user enters this menu
void CDateTimeMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    //
    // Update the MU's on our screen
    //
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#define BREAK_INTO_DEBUGGER                     _asm { int 3 }
                                                
#define APP_TITLE_NAME_A                        "MUConfig"
                                                
// Video Display Dimensions                     
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2.0f )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2.0f )
#define SCREEN_DEFAULT_FOREGROUND_COLOR         COLOR_LIGHT_YELLOW
#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_FONT_HEIGHT              18
#define SCREEN_DEFAULT_FONT_ALIAS_LEVEL         4
#define SCREEN_DEFAULT_FONT_STYLE               XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS
#define SCREEN_DEFAULT_SELECTOR_COLOR           COLOR_DARK_GREEN
#define SCREEN_SELECTED_OPTION_COLOR            SCREEN_DEFAULT_FOREGROUND_COLOR
#define SCREEN_ACTIVE_OPTION_COLOR              SCREEN_DEFAULT_FOREGROUND_COLOR
#define SCREEN_INACTIVE_OPTION_COLOR            COLOR_DARK_GREEN
#define SCREEN_MOUNTED_OPTION_COLOR             COLOR_TV_LIGHT_BLUE
#define SCREEN_UNFORMATTED_OPTION_COLOR         COLOR_TV_YELLOW
                                                
// Menubox constants                            
#define MENUBOX_MAINAREA_X1                     102.0f
#define MENUBOX_MAINAREA_Y1                     135.0f
#define MENUBOX_MAINAREA_X2                     536.0f
#define MENUBOX_MAINAREA_Y2                     367.0f
#define MENUBOX_SELECTOR_X1                     MENUBOX_MAINAREA_X1
#define MENUBOX_SELECTOR_X2                     MENUBOX_MAINAREA_X2
#define MENUBOX_SELECTOR_BORDER_WIDTH           2.0f
#define MENUBOX_MAINAREA_BORDERWIDTH_TOP        2.0f
#define MENUBOX_MAINAREA_BORDERWIDTH_BOTTOM     2.0f
#define MENUBOX_MAINAREA_BORDERWIDTH_LEFT       10.0f
#define MENUBOX_MAINAREA_BORDERWIDTH_RIGHT      10.0f
#define MENUBOX_ITEM_VERT_SPACING               7.0f
#define MENUBOX_WINDOW_TITLE_X1                 130
#define MENUBOX_WINDOW_TITLE_Y1                 95
#define MENUBOX_WINDOW_FOOTER_X1                130
#define MENUBOX_WINDOW_FOOTER_Y1                387
                                                
// Input related items                          
#define INPUT_JOYSTICK_DEADZONE                 20000       // 0 - 32768
#define INPUT_BUTTON_THRESHOLD                  50          // 0 - 255
#define INPUT_KEYPRESS_INITIAL_DELAY            400         // milliseconds
#define INPUT_KEYPRESS_REPEAT_DELAY             50
#define REMOTE_BUTTON_REPEAT_THRESHOLD          200         // milliseconds
                                                
// Xbox related items                           
#define XBOX_CONSOLE_NUM_PORTS                  4
#define XBOX_CONTROLLER_NUM_BUTTONS             8
#define XBOX_CONTROLLER_NUM_CONTROLS            8
#define XBOX_CONTROLLER_NUM_SLOTS               2
#define XBOX_MU_NAME_LENGTH                     32
                                                
// Colors                                       
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_RED                               0xFFFF0000
#define COLOR_TV_RED                            0xFF8D3232
#define COLOR_GREEN                             0xFF00FF00
#define COLOR_BLUE                              0xFF0000FF
#define COLOR_TV_LIGHT_BLUE                     0xFFA1A7FF
#define COLOR_LIGHT_YELLOW                      0xFFDDD078
#define COLOR_TV_YELLOW                         0xFFEFEF30
#define COLOR_DARK_GREEN                        0xFF357515
                                                
// Screen Item Constants                        
#define SCREEN_ITEM_TEXT_LENGTH                 150

// Data value limits
#define DATAVALUE_IPADDRESS_LENGTH              15
#define DATAVALUE_MACHINENAME_LENGTH            20
#define DATAVALUE_DISPLAYSETTING_TEXT_LENGTH    20
#define DATAVALUE_MUNAME_LENGTH                 20  // BUGBUG:Check with Chrispi on size
                                                
// File path and location constants
#define FILE_DATA_CDRIVE_PARTITION              "\\Device\\Harddisk0\\partition1"
#define FILE_DATA_YDRIVE_PARTITION              "\\Device\\Harddisk0\\partition2"
#define FILE_DATA_UDATA_PATH                    FILE_DATA_CDRIVE_PARTITION "\\udata"
#define FILE_DATA_CACHE_SIZE                    5120000
#define FILE_DATA_UNICODE_SIGNATURE             L'\xFEFF'
#define FILE_DATA_UDATA_DRIVE_LETTER_A          'X'
#define FILE_DATA_TDATA_DRIVE_LETTER_A          'V'
#define FILE_DATA_TDATA_DRIVE_LETTER            L't'
// #define FILE_DATA_DRIVE_A                       "t:"
// #define FILE_DATA_DRIVE                         L"t:"
#define FILE_DATA_DRIVE_A                       "d:"
#define FILE_DATA_DRIVE                         L"d:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\media"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\media"
#define FILE_DATA_MENU_DIRECTORY_A              FILE_DATA_DRIVE_A "\\menus"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\images"
#define FILE_DATA_DATA_DIRECTORY_A              FILE_DATA_DRIVE_A "\\data"
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"
#define FILE_DATA_DEFAULT_FONT_FILENAME_A       FILE_DATA_MEDIA_DIRECTORY_A "\\tahoma.ttf"
#define FILE_SPLASHSCREEN_LOCATION_A            FILE_DATA_IMAGE_DIRECTORY_A "\\loading.bmp"
#define FILE_WMATRACK_LOCATION_A                FILE_DATA_DATA_DIRECTORY_A "\\%hs%u.wma"
#define FILE_TRACKINI_LOCATION_A                FILE_DATA_DATA_DIRECTORY_A "\\TrackInfo.ini"
// #define FILE_DATA_TITLE_IMAGE_FILENAME          "titleimage.xbx"
// #define FILE_DATA_SAVEGAME_IMAGE_FILENAME       "saveimage.xbx"
#define FILE_DATA_GAMEDATA_FILENAME             "game.xsv"
// #define FILE_DATA_TITLE_IMAGE_PATHINFO          FILE_DATA_DATA_DIRECTORY_A "\\" FILE_DATA_TITLE_IMAGE_FILENAME
// #define FILE_DATA_SAVEGAME_IMAGE_PATHINFO       FILE_DATA_DATA_DIRECTORY_A "\\" FILE_DATA_SAVEGAME_IMAGE_FILENAME
#define FILE_DATA_GAMEDATA_PATHINFO             FILE_DATA_DATA_DIRECTORY_A "\\" FILE_DATA_GAMEDATA_FILENAME
#define FILE_DATA_XDASH_TITLEID                 "fffe0000"
#define FILE_DATA_CONFIG_TITLEID                "00001123"
#define FILE_DATA_XDASH_XBE_LOCATION            NULL // "\\Device\\Harddisk0\\Partition1\\samples\\xdash\\xboxdash.xbe"

// Feedback information
#define CONTROLLER_RUMBLE_SPEED					65535
#define CONTROLLER_RUMBLE_MILLISECOND_TIME		250		// 1/4 of a second

// Menu specific information

// Root Menu
#define MENU_ROOT_MENU_FILENAME_A               FILE_DATA_MENU_DIRECTORY_A "\\root.mnu"

// Memory Menu
#define MENU_MEMORY_MENU_FILENAME_A             FILE_DATA_MENU_DIRECTORY_A "\\memory.mnu"

// HD Options Menu
#define MENU_HDOPTIONS_MENU_FILENAME_A          FILE_DATA_MENU_DIRECTORY_A "\\hdoptions.mnu"
#define MENU_HDOPTIONS_NUMBER_SIZE              MENU_MUOPTIONS_NUMBER_SIZE
#define MENU_HDOPTIONS_SAVEGAMENAME_SIZE        MENU_MUOPTIONS_SAVEGAMENAME_SIZE

// Entry Point Menu
#define MENU_XBCONFIG_MENU_FILENAME_A           FILE_DATA_MENU_DIRECTORY_A "\\xbconfig.mnu"

// Entry Point Menu
#define MENU_ENTRY_MENU_FILENAME_A              FILE_DATA_MENU_DIRECTORY_A "\\entry.mnu"
#define MENU_ENTRY_NUMBER_SIZE					11

// ST Menu
#define MENU_ST_MENU_FILENAME_A                 FILE_DATA_MENU_DIRECTORY_A "\\stmenu.mnu"
#define MENU_ST_NUMBER_SIZE                     10
#define MENU_ST_SOUNDTRACKNAME_SIZE             MAX_SOUNDTRACK_NAME
#define MENU_ST_TRACKNAME_SIZE                  MAX_SONG_NAME

// Game Region Menu
#define MENU_GAMEREGION_MENU_FILENAME_A         FILE_DATA_MENU_DIRECTORY_A "\\gamereg.mnu"
#define MENU_GAMEREGION_NUM_COLS                1
#define MENU_GAMEREGION_NUM_ROWS                GAMEREGIONMENU_ITEM_NUM_ITEMS
#define MENU_GAMEREGION_LINE_WIDTH              KEYPAD_LINE_WIDTH
#define MENU_GAMEREGION_BUTTON_X1               170
#define MENU_GAMEREGION_BUTTON_Y1               KEYPAD_TOPROW_Y1
#define MENU_GAMEREGION_BUTTON_WIDTH            300
#define MENU_GAMEREGION_CURRENT_REGION_TEXT     L"Current Xbox Game Region: "
#define MENU_GAMEREGION_TEXT_Y1                 135

// AV Region Menu
#define MENU_AVREGION_MENU_FILENAME_A           FILE_DATA_MENU_DIRECTORY_A "\\avreg.mnu"
#define MENU_AVREGION_NUM_COLS                  1
#define MENU_AVREGION_NUM_ROWS                  AVREGIONMENU_ITEM_NUM_ITEMS
#define MENU_AVREGION_LINE_WIDTH                KEYPAD_LINE_WIDTH
#define MENU_AVREGION_BUTTON_X1                 170
#define MENU_AVREGION_BUTTON_Y1                 KEYPAD_TOPROW_Y1
#define MENU_AVREGION_BUTTON_WIDTH              300
#define MENU_AVREGION_CURRENT_REGION_TEXT       L"Current Xbox AV Region: "
#define MENU_AVREGION_TEXT_Y1                   135

// DVD Region Menu
#define MENU_DVDREGION_MENU_FILENAME_A          FILE_DATA_MENU_DIRECTORY_A "\\dvdreg.mnu"
#define MENU_DVDREGION_NUM_COLS                 1
#define MENU_DVDREGION_NUM_ROWS                 DVDREGIONMENU_ITEM_NUM_ITEMS
#define MENU_DVDREGION_LINE_WIDTH               KEYPAD_LINE_WIDTH
#define MENU_DVDREGION_BUTTON_X1                170
#define MENU_DVDREGION_BUTTON_Y1                165
#define MENU_DVDREGION_BUTTON_WIDTH             300
#define MENU_DVDREGION_BUTTON_HEIGHT            27
#define MENU_DVDREGION_CURRENT_REGION_TEXT      L"Current Xbox DVD Region: "
#define MENU_DVDREGION_TEXT_Y1                  135


// Keypad Menu
#define MENU_KEYPAD_MENU_FILENAME_A             FILE_DATA_MENU_DIRECTORY_A "\\keypad.mnu"
#define KEYPAD_LINE_WIDTH                       1.0f
#define KEYPAD_TEXT_Y1                          150
#define KEYPAD_VALUE_Y1                         175
#define KEYPAD_TOPROW_Y1                        200
#define KEYPAD_TOPROW_X1                        210

#define KEY_PRESS_INITIAL_DELAY                 400         // milliseconds
#define KEY_PRESS_REPEAT_DELAY                  50

// Keyboard Menu
#define MENU_KEYBOARD_MENU_FILENAME_A           FILE_DATA_MENU_DIRECTORY_A "\\keybrd.mnu"
#define KEYBOARD_LINE_WIDTH                     1.0f
#define KEYBOARD_TEXT_Y1                        140
#define KEYBOARD_VALUE_Y1                       165
#define KEYBOARD_TOPROW_Y1                      200
#define KEYBOARD_TOPROW_X1                      110

// Memory Area Constants
#define MEMORY_AREA_BLOCK_SIZE_MAX_NUM_LOW_PART 262143
#define MEMORY_AREA_BLOCK_SIZE_IN_BYTES         16384

// Vertex Definitions
struct MYVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    cDiffuse;
};

struct MYTEXVERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    diffuse;
    float       tu, tv;    // The texture coordinates
};

#define D3DFVF_MYVERTEX     ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE )
#define D3DFVF_MYTEXVERTEX  ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1 )

// XBOX Item names and enums

// USB Contant declarations for # of MU's and Controllers
static XDEVICE_PREALLOC_TYPE g_deviceTypes[] = 
{
    { XDEVICE_TYPE_GAMEPAD, 4 },
    { XDEVICE_TYPE_MEMORY_UNIT, 8 }
};

// Memory Unit BitMasks used for detection
static DWORD g_dwMUBitMask[] = {
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT3_TOP_MASK,
    XDEVICE_PORT3_BOTTOM_MASK
};

// Memory Unit names
static WCHAR* g_wpszMUPortNames[] = {
    L"MU 1A",
    L"MU 1B",
    L"MU 2A",
    L"MU 2B",
    L"MU 3A",
    L"MU 3B",
    L"MU 4A",
    L"MU 4B"
};


// Memory Menu Items
enum MemoryMenu
{
	MEMORYMENU_ITEM_MU1A,
    MEMORYMENU_ITEM_MU1B,
    MEMORYMENU_ITEM_MU2A,
    MEMORYMENU_ITEM_MU2B,
    MEMORYMENU_ITEM_MU3A,
    MEMORYMENU_ITEM_MU3B,
    MEMORYMENU_ITEM_MU4A,
    MEMORYMENU_ITEM_MU4B,
    MEMORYMENU_ITEM_XBOX_HARD_DRIVE,

    MEMORYMENU_ITEM_NUM_ITEMS
};

static WCHAR* g_wpszMemoryMenuItems[] = {
    g_wpszMUPortNames[0],
    g_wpszMUPortNames[1],
    g_wpszMUPortNames[2],
    g_wpszMUPortNames[3],
    g_wpszMUPortNames[4],
    g_wpszMUPortNames[5],
    g_wpszMUPortNames[6],
    g_wpszMUPortNames[7],
    L"Xbox Hard Drive"
};


// Root Menu Items
enum RootMenu
{
	ROOTMENU_ITEM_MEMORY,
    ROOTMENU_ITEM_SOUNDTRACKS,
    ROOTMENU_ITEM_XDASH_ENTRY_POINTS,
	ROOTMENU_ITEM_XBOX_CONFIGURATION,
    ROOTMENU_ITEM_INSTALL_MUCONFIG,
	
    ROOTMENU_ITEM_NUM_ITEMS
};

static WCHAR* g_wpszRootMenuItems[] = {
    L"Memory Areas",
    L"Soundtracks",
    L"XDash Entry Points",
	L"Xbox Configuration",
    L"Install MUConfig to Hard Disk"
};

// Save Game Menu Items
#define MENU_SAVEGAME_MENU_FILENAME_A               FILE_DATA_MENU_DIRECTORY_A "\\sgames.mnu" 

// Game Title Menu Items
#define MENU_GAMETITLE_MENU_FILENAME_A              FILE_DATA_MENU_DIRECTORY_A "\\gtitles.mnu"

// Xbox Configuration Menu Items
enum XBConfigMenu
{
    XBCONFIGMENU_ITEM_RESET_XBOX_TO_DEFAULTS,
    XBCONFIGMENU_ITEM_RESET_CLOCK,
    XBCONFIGMENU_ITEM_RESET_TIMEZONE,
    XBCONFIGMENU_ITEM_RESET_LANGUAGE,
	XBCONFIGMENU_ITEM_SET_GAME_REGION,
	XBCONFIGMENU_ITEM_SET_DVD_REGION,
    XBCONFIGMENU_ITEM_SET_AV_REGION,
    XBCONFIGMENU_ITEM_CHANGE_HDKEY,
    XBCONFIGMENU_ITEM_DISPLAY_RECKEY,
    XBCONFIGMENU_ITEM_RESET_HDKEY,
    XBCONFIGMENU_ITEM_CLEAR_REFERB,
    XBCONFIGMENU_ITEM_CORRUPT_CDRIVE,
    XBCONFIGMENU_ITEM_CORRUPT_YDRIVE,
    XBCONFIGMENU_ITEM_TOGGLE_DTS,
    XBCONFIGMENU_ITEM_TOGGLE_DOLBY,
    XBCONFIGMENU_ITEM_TOGGLE_1080I,
    XBCONFIGMENU_ITEM_TOGGLE_720P,
    XBCONFIGMENU_ITEM_TOGGLE_480P,
    XBCONFIGMENU_ITEM_TOGGLE_PAL60,
    XBCONFIGMENU_ITEM_TOGGLE_WIDESCREEN,
    XBCONFIGMENU_ITEM_TOGGLE_LETTERBOX,
    
    XBCONFIGMENU_ITEM_NUM_ITEMS
};

static WCHAR* g_wpszXBConfigMenuItems[] = {
    L"Reset the Xbox to its initial state",
    L"Reset the Xbox Clock",
    L"Reset the TimeZone",
    L"Reset the Language",
    L"Set the Xbox Game Region",
    L"Set the Xbox DVD Region",
    L"Set the Xbox AV Region",
    L"Change HD Key (randomly)",
    L"In-Dash Recovery Key",
    L"Reset HD Key to all O's",
    L"Clear Refurb Info",
    L"Corrupt the C Parition",
    L"Corrupt the Y Parition",
    L"Toggle DTS",
    L"Toggle Dolby Digital",
    L"Toggle 1080i",
    L"Toggle 720p",
    L"Toggle 480p",
    L"Toggle PAL60",
    L"Toggle Widescreen",
    L"Toggle Letterbox"
};

// DVD Region Menu Items
enum DVDRegionMenu
{
    DVDREGIONMENU_ITEM_REGION0,
    DVDREGIONMENU_ITEM_REGION1,
    DVDREGIONMENU_ITEM_REGION2,
    DVDREGIONMENU_ITEM_REGION3,
    DVDREGIONMENU_ITEM_REGION4,
    DVDREGIONMENU_ITEM_REGION5,
    DVDREGIONMENU_ITEM_REGION6,
    
    DVDREGIONMENU_ITEM_NUM_ITEMS
};

static WCHAR* g_wpszDVDRegionMenuItems[] = {
    L"Region 0 (not set)",
    L"Region 1 (North America)",
    L"Region 2 (Japan and Europe)",
    L"Region 3 (SE Asia)",
    L"Region 4 (Australia / SA)",
    L"Region 5 (NW Asia / N Africa)",
    L"Region 6 (China)"
};


// AV Region Menu Items
enum AVRegionMenu
{
    AVREGIONMENU_ITEM_REGION1,
    AVREGIONMENU_ITEM_REGION2,
    AVREGIONMENU_ITEM_REGION3,
    
    AVREGIONMENU_ITEM_NUM_ITEMS
};

static WCHAR* g_wpszAVRegionMenuItems[] = {
    L"Region 1 NTSC (North America)",
    L"Region 2 NTSC (Japan)",
    L"Region 3 PAL (Rest of World)"
};


// Game Region Menu Items
#define GAMEREGION_NONE 0

enum GameRegionMenu
{
    GAMEREGIONMENU_ITEM_REGION1,
    GAMEREGIONMENU_ITEM_REGION2,
    GAMEREGIONMENU_ITEM_REGION3,
    GAMEREGIONMENU_ITEM_NUM_ITEMS
};

static WCHAR* g_wpszGameRegionMenuItems[] = {
    L"Region 1 NTSC (North America)",
    L"Region 2 OTHER (Japan)",
    L"Region 3 PAL (Rest of World)"
};

// MU Options Menu Items
enum MUOptionsMenu
{
    MUOPTIONSMENU_ITEM_CREATE_TITLES_AND_SGAMES,
    MUOPTIONSMENU_ITEM_CREATE_SAVED_GAME,
    MUOPTIONSMENU_ITEM_SET_DATETIME_FOR_SAVED_GAME,
    MUOPTIONSMENU_ITEM_CREATE_FILE,
    MUOPTIONSMENU_ITEM_ERASE,
    MUOPTIONSMENU_ITEM_CREATEMU_A,
    MUOPTIONSMENU_ITEM_CREATEMU_B,
    MUOPTIONSMENU_ITEM_CREATEMU_C,
    MUOPTIONSMENU_ITEM_CREATEMU_D,
    MUOPTIONSMENU_ITEM_CREATEMU_E,
    MUOPTIONSMENU_ITEM_CREATEMU_F,
    MUOPTIONSMENU_ITEM_CREATEMU_G,
    MUOPTIONSMENU_ITEM_CREATEMU_H,
    MUOPTIONSMENU_ITEM_CREATEMU_I,
    MUOPTIONSMENU_ITEM_CREATEMU_J,
    MUOPTIONSMENU_ITEM_CREATEMU_K,
    MUOPTIONSMENU_ITEM_CREATEMU_L,
    MUOPTIONSMENU_ITEM_CREATEMU_M,
    MUOPTIONSMENU_ITEM_CREATEMU_N,
    MUOPTIONSMENU_ITEM_CREATEMU_O,
    MUOPTIONSMENU_ITEM_CREATEMU_P,
    MUOPTIONSMENU_ITEM_CREATEMU_Q,
    MUOPTIONSMENU_ITEM_CREATEMU_R,
    MUOPTIONSMENU_ITEM_CREATEMU_S,
    MUOPTIONSMENU_ITEM_CREATEMU_T,
    MUOPTIONSMENU_ITEM_CREATEMU_U,
    MUOPTIONSMENU_ITEM_CREATEMU_V,
    MUOPTIONSMENU_ITEM_CREATEMU_W,
    MUOPTIONSMENU_ITEM_CREATEMU_X,
    MUOPTIONSMENU_ITEM_CREATEMU_Y,
    MUOPTIONSMENU_ITEM_CREATEMU_Z,
    MUOPTIONSMENU_ITEM_CREATEMU_AA,
    MUOPTIONSMENU_ITEM_CREATEMU_BB,

    MUOPTIONSMENU_ITEM_NUM_ITEMS
};

static WCHAR* g_wpszMUOptionsMenuItems[] = {
    L"Create 'X' Game Titles w/ 'X' Saved Games",
    L"Create Single Saved Game",
    L"Set Date/Time for a Saved Game",
    L"Create File of Specified Size",
    L"Erase all files",
    L"Create MU - A (blank)",
    L"Create MU - B (M Name / 1 bl)",
    L"Create MU - C (1c Name / 1GT-0SG / 1/2 bl)",
    L"Create MU - D (M+1c Name / 1GT-1SG / MAX bl)",
    L"Create MU - E (LG Name / 2GT-2SG)",
    L"Create MU - F (Inv Name / Sorting)",
    L"Create MU - G (Emp Name / MAX GT-1SG)",
    L"Create MU - H (Emp Name / MAX GT-10SG)",
    L"Create MU - I (Emp Name / 1GT-4SG)",
    L"Create MU - J (Emp Name / 1GT-5SG)",
    L"Create MU - K (Emp Name / 1GT-6SG)",
    L"Create MU - L (1GT-MAX SG)",
    L"Create MU - M (1GT-MAX+1 SG)",
    L"Create MU - N (2GT-MAX SG)",
    L"Create MU - O (10GT-5SG)",
    L"Create MU - P (10GT-1st has 10SG)",
    L"Create MU - Q (10GT-1st has 15SG)",
    L"Create MU - R (10GT-1st has 20SG)",
    L"Create MU - S (10GT-1st has 25SG)",
    L"Create MU - T (10GT-1st has 30SG)",
    L"Create MU - U (10GT-1st has 35SG)",
    L"Create MU - V (10GT-1st has 40SG)",
    L"Create MU - W (10GT-1st has 45SG)",
    L"Create MU - X (10GT-1st has 50SG)",
    L"Create MU - Y (Meta Var 1 of 2)",
    L"Create MU - Z (Meta Var 2 of 2)",
    L"Create MU - AA (SG Many Files)",
	L"Create MU - BB (Jap Sorting)"
};

#define MENU_MUOPTIONS_MENU_FILENAME_A          FILE_DATA_MENU_DIRECTORY_A "\\muoptions.mnu"
#define MENU_MUOPTIONS_NUMBER_SIZE              10
#define MENU_MUOPTIONS_SAVEGAMENAME_SIZE        255

// HD Options Menu Items
enum HDOptionsMenu
{
	HDOPTIONSMENU_ITEM_UDATA_CREATE_TITLES,
    HDOPTIONSMENU_ITEM_UDATA_CREATE_TITLES_AND_SGAMES,
    HDOPTIONSMENU_ITEM_UDATA_CREATE_SAVED_GAME,
    HDOPTIONSMENU_ITEM_TDATA_ERASE,
    HDOPTIONSMENU_ITEM_UDATA_ERASE,
    HDOPTIONSMENU_ITEM_CREATE_FILE,
    HDOPTIONSMENU_ITEM_CONFIG_METAVARS,
    HDOPTIONSMENU_ITEM_CONFIG_SORTORDER,
	HDOPTIONSMENU_ITEM_CONFIG_SORTORDER_JAP,
    
    HDOPTIONSMENU_ITEM_NUM_ITEMS
};

static WCHAR* g_wpszHDOptionsMenuItems[] = {
    L"(UDATA) Create 'X' Game Titles",
    L"(UDATA) Create 'X' Game Titles w/ 'X' Saved Games",
    L"(UDATA) Create Single Saved Game",
    L"(TDATA) Erase all files",
    L"(UDATA) Erase all files",
    L"Create File of Specified Size",
    L"Configure for Saved Game Meta Variations",
    L"Configure for Saved Game Sorting Order (English)",
	L"Configure for Saved Game Sorting Order (Japanese)"
};


// DATE/TIME Menu Items
enum DateTimeMenu
{
	DATETIMEMENU_HOURS,
    DATETIMEMENU_MINUTES,
    DATETIMEMENU_SECONDS,
    DATETIMEMENU_MONTHS,
    DATETIMEMENU_DAYS,
    DATETIMEMENU_YEARS,

    DATETIMEMENU_NUM_ITEMS
};

#define DATETIMEMENU_FILENAME_A                 FILE_DATA_MENU_DIRECTORY_A "\\datetime.mnu"

// Soundtrack Menu Items
enum STMenu
{
    STMENU_ITEM_CREATE_SMALL_SOUNDTRACKS_AND_TRACKS,
	STMENU_ITEM_CREATE_SOUNDTRACKS_AND_TRACKS,
    STMENU_ITEM_CREATE_NAMED_SOUNDTRACK,
    STMENU_ITEM_ADD_NAMED_TRACK_TO_SOUNDTRACK,
    STMENU_ITEM_CREATE_SORTING,
	STMENU_ITEM_CREATE_SORTING_JAP,	
	STMENU_ITEM_REMOVE_ALL_SOUNDTRACKS,
    
    STMENU_ITEM_NUM_ITEMS
};

static WCHAR* g_wpszSTMenuItems[] = {
    L"Create 'X' Soundtracks w/ 'X' Tracks (small)",
    L"Create 'X' Soundtracks w/ 'X' Tracks",
    L"Create a named Soundtrack",
    L"Add a named Track to current Soundtrack",
	L"Create Soundtracks for Sorting (English)",
	L"Create Soundtracks for Sorting (Japanese)", 
    L"Remove all Soundtracks"
};

// Entry Point Menu Items
enum EntryMenu
{
	ENTRYMENU_ITEM_ROOT_MENU,
    ENTRYMENU_ITEM_MEMORY_CLEANUP,
    ENTRYMENU_ITEM_MUSIC,
    ENTRYMENU_ITEM_SETTINGS,
	ENTRYMENU_ITEM_SETTINGS_CLOCK,
	ENTRYMENU_ITEM_SETTINGS_TIMEZONE,
	ENTRYMENU_ITEM_SETTINGS_LANGUAGE,
	ENTRYMENU_ITEM_SETTINGS_CLOCK_TIMEZONE_LANGUAGE,
	ENTRYMENU_ITEM_SETTINGS_CLOCK_TIMEZONE,
	ENTRYMENU_ITEM_SETTINGS_CLOCK_LANGUAGE,
	ENTRYMENU_ITEM_SETTINGS_TIMEZONE_LANGUAGE,
    ENTRYMENU_ITEM_SETTINGS_COLLECTION,
    ENTRYMENU_ITEM_SETTINGS_VIDEO,
    ENTRYMENU_ITEM_SETTINGS_AUDIO,
    ENTRYMENU_ITEM_ERROR,
    ENTRYMENU_ITEM_ERROR_INVALID_XBE,
    ENTRYMENU_ITEM_ERROR_INVALID_HARD_DISK,
    ENTRYMENU_ITEM_ERROR_INVALID_XBE_REGION,
    ENTRYMENU_ITEM_ERROR_INVALID_XBE_PARENTAL_CONTROL,
    ENTRYMENU_ITEM_ERROR_INVALID_XBE_MEDIA_TYPE,
    
    ENTRYMENU_ITEM_NUM_ITEMS
};

static WCHAR* g_wpszEntryMenuItems[] = {
    L"XDash Root Menu",
    L"Memory Cleanup",
    L"Music",
    L"Settings",
	L"Settings - Clock",
	L"Settings - Timezone",
	L"Settings - Language",
	L"Settings - Clock,Timezone,Language",
	L"Settings - Clock,Timezone",
	L"Settings - Clock,Language",
	L"Settings - Timezone,Language",
	L"Settings - Collection",
    L"Settings - Video",
    L"Settings - Audio",
    L"Error Message",
    L"Error - Invalid XBE",
    L"Error - Invalid Hard Disk",
    L"Error - Invalid XBE Region",
    L"Error - Invalid XBE Parental Control",
    L"Error - Invalid XBE Media Type"
};

#define XSHELL_LAUNCH_CONTEXT_ROOT          1
#define XSHELL_LAUNCH_CONTEXT_MEMORY        2
#define XSHELL_LAUNCH_CONTEXT_ERROR         3
#define XSHELL_LAUNCH_CONTEXT_SETTINGS      4
#define XSHELL_LAUNCH_CONTEXT_MUSIC         5

#define ENTRYMENU_NUM_ITEMS_TO_DISPLAY      9

//
// META DATA CONTANTS
//
//#define META_FILE_METAXBX_FILENAME          "titlemeta.xbx"
//#define META_FILE_METAXBX_TITLENAME_TOKEN   L"TitleName="
//#define META_FILE_METAXBX_PUBNAME_TOKEN     L"PubName="
#define META_FILE_SAVEXBX_FILENAME          "savemeta.xbx"
//#define META_FILE_SAVEXBX_SAVENAME_TOKEN    L"Name="
/*

enum LangCodes
{
    ENUM_LANGUAGECODE_DEFAULT,
    ENUM_LANGUAGECODE_ENGLISH,
    ENUM_LANGUAGECODE_JAPANESE,
    ENUM_LANGUAGECODE_GERMAN,
    ENUM_LANGUAGECODE_ITALIAN,
    ENUM_LANGUAGECODE_FRENCH,
    ENUM_LANGUAGECODE_SPANISH,

    ENUM_LANGUAGECODE_NUM_ITEMS
};

static WCHAR* gwpszLanguageCodes[] = {
    L"[default]",
    L"[EN]",
    L"[JA]",
    L"[DE]",
    L"[IT]",
    L"[FR]",
    L"[ES]"
};
*/

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\datetimemenu.h ===
/*****************************************************
*** datetimemenu.h
***
*** Header file for our DATE/TIME menu class.  This
*** menu will allow the user to select a different
*** date / time.
***
*** by James N. Helm
*** June 18th, 2001
***
*****************************************************/

#ifndef _DATETIMEMENU_H_
#define _DATETIMEMENU_H_

#include "menuscreen.h"  // Base menu type

class CDateTimeMenu : public CMenuScreen
{
public:
    CDateTimeMenu( CXItem* pParent );
    ~CDateTimeMenu();

    // Must be overridden for this to be a Item on our XShell program
    // void Enter();                                       // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed,
                      BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed,
                      BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick,
                      int nThumbY,
                      int nThumbX,
                      BOOL bFirstYPress,
                      BOOL bFirstXPress );

    // Public Methods
    HRESULT Init( IDirect3DDevice8* pD3DDevice, char* menuFileName );       // Initialize our font and settings

private:
    // Private Methods
    // void Leave( CXItem* pItem );                                        // This should be called whenever a user leaves this menu

    // Private Properties
    SYSTEMTIME  m_sysTime;              // Structure to hold our DATE/TIME information
    BOOL        m_bDateTimeModified;    // Used to determine if the user has modified the Date/Time
    DWORD       m_dwTickCount;          // Used to update our texture once a second
};

#endif // _DATETIMEMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\entrymenu.cpp ===
/*****************************************************
*** entrymenu.cpp
***
*** CPP file for our Entry Point menu
*** class. This menu class will allow you to perform
*** various Entry Point operations.
***
*** by James N. Helm
*** April 23rd, 2001
***
*****************************************************/

#include "stdafx.h"
#include "entrymenu.h"

extern CKeypadMenu      g_MenuKeypad;   // Virtual Keypad Menu to be used by all screens
extern CKeyboardMenu    g_MenuKeyboard; // Virtual Keyboard Menu to be used by all screens

// Constructors
CEntryMenu::CEntryMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_pwszValueBuffer( NULL ),
m_pwszBuffer1( NULL ),
m_pwszBuffer2( NULL ),
m_uiTopItemIndex( 0 ),
m_uiNumItemsToDisplay( ENTRYMENU_NUM_ITEMS_TO_DISPLAY )
{
    XDBGWRN( APP_TITLE_NAME_A, "CEntryMenu::CEntryMenu()" );

    m_uiNumItems = ENTRYMENU_ITEM_NUM_ITEMS;
    SetSelectedItem( 0 );

    m_pwszValueBuffer = new WCHAR[MENU_ENTRY_NUMBER_SIZE];
    if( !m_pwszValueBuffer )
    {
        XDBGERR( APP_TITLE_NAME_A, "CEntryMenu::CEntryMenu():Failed to allocate memory!!" );
    }
}


// Destructor
CEntryMenu::~CEntryMenu()
{
    if( m_pwszValueBuffer )
    {
        delete[] m_pwszValueBuffer;
        m_pwszValueBuffer = NULL;
    }

    if( m_pwszBuffer1 )
    {
        delete[] m_pwszBuffer1;
        m_pwszBuffer1 = NULL;
    }

    if( m_pwszBuffer2 )
    {
        delete[] m_pwszBuffer2;
        m_pwszBuffer2 = NULL;
    }
}


// Draws a menu on to the screen
void CEntryMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should update the texture
    // If not, return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else // reset the texture flag to FALSE
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

    DWORD dwItemColor = 0;

    // Draw a selector around the current item
    float X1Pos = MENUBOX_SELECTOR_X1;
    float Y1Pos = MENUBOX_MAINAREA_Y1 + MENUBOX_MAINAREA_BORDERWIDTH_TOP + ( ( MENUBOX_ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( GetSelectedItem() - m_uiTopItemIndex ) ) - MENUBOX_SELECTOR_BORDER_WIDTH;
    float X2Pos = MENUBOX_SELECTOR_X2;
    float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * MENUBOX_SELECTOR_BORDER_WIDTH );

    pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, SCREEN_DEFAULT_SELECTOR_COLOR );

    // Draw the Menu Options
    for( unsigned int x = m_uiTopItemIndex; x < ( m_uiNumItemsToDisplay + m_uiTopItemIndex ); ++x )
    {
        // Make sure we don't try to access out of range items
        if( x == GetNumItems() )
        {
            break;
        }

        float XPos = MENUBOX_MAINAREA_X1 + MENUBOX_MAINAREA_BORDERWIDTH_LEFT;
        float YPos = MENUBOX_MAINAREA_Y1 + MENUBOX_MAINAREA_BORDERWIDTH_TOP + ( ( MENUBOX_ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( x - m_uiTopItemIndex ) );

        DWORD dwItemColor = SCREEN_ACTIVE_OPTION_COLOR;

        pTexture->DrawText( XPos, YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", g_wpszEntryMenuItems[x] );
    }

    // Unlock our texture and restore our render target
    pTexture->Unlock();

	if( m_bActionInitiated )
	{
        m_bActionInitiated = FALSE;

        switch( GetSelectedItem() )
        {
		/*
        case ENTRYMENU_ITEM_ROOT_MENU:
			{
			}
		*/
        case ENTRYMENU_ITEM_MEMORY_CLEANUP:
            {
                // Check the value passed for the number of blocks, and asked
                // for the drive letter

                // Check to see if the user set an initial value
                if( L'\0' == m_pwszBuffer1[0] )
                {
                    break;
                }

                // Get the drive letter
                if( L'\0' == m_pwszBuffer2[0] )
                {
				    // Prompt the user for the Drive Letter
                    g_MenuKeyboard.SetInfo( L"Enter the drive letter", m_pwszBuffer2, 1 );
                    g_MenuKeyboard.SetParent( this );
                    m_bActionInitiated = TRUE;

                    Leave( &g_MenuKeyboard );

                    break;
                }

                // Process our values
                
                WCHAR* pwszStopString = NULL;

                // Convert the user value to a DWORD
                DWORD dwNumBlocks = wcstol( m_pwszBuffer1, &pwszStopString, 10 );

				// Reboot to the Memory Cleanup menu
				LD_LAUNCH_DASHBOARD launchData;
				ZeroMemory( &launchData, sizeof( launchData ) );

				launchData.dwReason     = XLD_LAUNCH_DASHBOARD_MEMORY;
                launchData.dwContext    = XSHELL_LAUNCH_CONTEXT_MEMORY;
                launchData.dwParameter1 = m_pwszBuffer2[0];
				launchData.dwParameter2 = dwNumBlocks;

				XLaunchNewImage( FILE_DATA_XDASH_XBE_LOCATION, (PLAUNCH_DATA)&launchData );
			}
        case ENTRYMENU_ITEM_MUSIC:
            {
                break;
            }
        case ENTRYMENU_ITEM_SETTINGS:
            {
                // Check to see if the user set a value
                if( L'\0' == m_pwszBuffer1[0] )
                {
                    break;
                }


                // Reboot to the XDash Settings Menu
                WCHAR* pwszStopString = NULL;

				LD_LAUNCH_DASHBOARD launchData;
				ZeroMemory( &launchData, sizeof( launchData ) );

				launchData.dwReason  = XLD_LAUNCH_DASHBOARD_SETTINGS;
                launchData.dwContext = XSHELL_LAUNCH_CONTEXT_SETTINGS;
				launchData.dwParameter1 = wcstol( m_pwszBuffer1, &pwszStopString, 10 );

				XLaunchNewImage( FILE_DATA_XDASH_XBE_LOCATION, (PLAUNCH_DATA)&launchData );

                break;
            }
        case ENTRYMENU_ITEM_ERROR:
            {
                // Check to see if the user set a value
                if( L'\0' == m_pwszBuffer1[0] )
                {
                    break;
                }

                // Get the second error code
                if( L'\0' == m_pwszBuffer2[0] )
                {
				    // Prompt the user for the Drive Letter
                    g_MenuKeypad.SetInfo( L"Enter the 2nd Error Code", m_pwszBuffer2, MENU_ENTRY_NUMBER_SIZE - 1 );
                    g_MenuKeypad.SetParent( this );
                    m_bActionInitiated = TRUE;

                    Leave( &g_MenuKeypad );

                    break;
                }

                WCHAR* pwszStopString = NULL;

				// Reboot to the Error Display
				LD_LAUNCH_DASHBOARD launchData;
				ZeroMemory( &launchData, sizeof( launchData ) );

				launchData.dwReason     = XLD_LAUNCH_DASHBOARD_ERROR;
                launchData.dwContext    = XSHELL_LAUNCH_CONTEXT_ERROR;
				launchData.dwParameter1 = wcstol( m_pwszBuffer1, &pwszStopString, 10 );
                launchData.dwParameter2 = wcstol( m_pwszBuffer2, &pwszStopString, 10 );

				XLaunchNewImage( FILE_DATA_XDASH_XBE_LOCATION, (PLAUNCH_DATA)&launchData );
			}
		}
	}
}


// Handle any requests for the joystick (thumb-pad)
void CEntryMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CEntryMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = INPUT_KEYPRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = INPUT_KEYPRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            if( GetSelectedItem() > 0 )
            {
                m_bUpdateTexture = TRUE;
                
                SetSelectedItem( GetSelectedItem() - 1 );

                // Make sure we are displaying the correct items
                if( GetSelectedItem() < (int)m_uiTopItemIndex )
                {
                    m_uiTopItemIndex = GetSelectedItem();
                }
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            if( (unsigned int)GetSelectedItem() < ( GetNumItems() - 1 ) )
            {
                m_bUpdateTexture = TRUE;

                SetSelectedItem( GetSelectedItem() + 1 );

                // Make sure we are displaying the correct items
                if( GetSelectedItem() >= (int)( m_uiNumItemsToDisplay + m_uiTopItemIndex ) )
                {
                    m_uiTopItemIndex += 1;
                }
            }
            break;
        }
    }
}


// Handles input (of the BUTTONS) for the current menu
void CEntryMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Refresh our Texture
            m_bUpdateTexture = TRUE;

            switch( GetSelectedItem() )
            {
            case ENTRYMENU_ITEM_ROOT_MENU:
                {
					// Reboot to the XDash Root Menu
					LD_LAUNCH_DASHBOARD launchData;
					ZeroMemory( &launchData, sizeof( launchData ) );

                    launchData.dwContext = XSHELL_LAUNCH_CONTEXT_ROOT;
					launchData.dwReason = XLD_LAUNCH_DASHBOARD_MAIN_MENU;

					XLaunchNewImage( FILE_DATA_XDASH_XBE_LOCATION, (PLAUNCH_DATA)&launchData );
                    
                    break;
                }
            case ENTRYMENU_ITEM_MEMORY_CLEANUP:
                {
                    // Make sure we setup Buffer 1
                    if( m_pwszBuffer1 )
                    {
                        delete[] m_pwszBuffer1;
                        m_pwszBuffer1 = NULL;
                    }

                    m_pwszBuffer1 = new WCHAR[MENU_ENTRY_NUMBER_SIZE];
                    if( NULL == m_pwszBuffer1 )
                    {
                        XDBGWRN( APP_TITLE_NAME_A, "CEntryMenu::HandleInput()(MEMORY)Failed to allocate memory for Buffer 1!!" );

                        break;
                    }
                    ZeroMemory( m_pwszBuffer1, sizeof( WCHAR ) * MENU_ENTRY_NUMBER_SIZE );

                    // Make sure we setup Buffer 2
                    if( m_pwszBuffer2 )
                    {
                        delete[] m_pwszBuffer2;
                        m_pwszBuffer2 = NULL;
                    }

                    m_pwszBuffer2 = new WCHAR[2];
                    if( NULL == m_pwszBuffer2 )
                    {
                        XDBGWRN( APP_TITLE_NAME_A, "CEntryMenu::HandleInput()(MEMORY)Failed to allocate memory for Buffer 2!!" );

                        break;
                    }
                    ZeroMemory( m_pwszBuffer2, sizeof( WCHAR ) * 2 );

					// Prompt the user for the amount of space needed (blocks)
                    g_MenuKeypad.SetInfo( L"Enter # of Blocks", m_pwszBuffer1, MENU_ENTRY_NUMBER_SIZE - 1 );
                    g_MenuKeypad.SetParent( this );
                    m_bActionInitiated = TRUE;

                    Leave( &g_MenuKeypad );

                    break;
                }
            case ENTRYMENU_ITEM_MUSIC:
                {
					// Reboot to the XDash Music Menu
					LD_LAUNCH_DASHBOARD launchData;
					ZeroMemory( &launchData, sizeof( launchData ) );

                    launchData.dwContext = XSHELL_LAUNCH_CONTEXT_MUSIC;
					launchData.dwReason  = XLD_LAUNCH_DASHBOARD_MUSIC;

					XLaunchNewImage( FILE_DATA_XDASH_XBE_LOCATION, (PLAUNCH_DATA)&launchData );
                    
                    break;
                }
            case ENTRYMENU_ITEM_SETTINGS:
                {
                    // Make sure we setup Buffer 1
                    if( m_pwszBuffer1 )
                    {
                        delete[] m_pwszBuffer1;
                        m_pwszBuffer1 = NULL;
                    }

                    m_pwszBuffer1 = new WCHAR[MENU_ENTRY_NUMBER_SIZE];
                    if( NULL == m_pwszBuffer1 )
                    {
                        XDBGWRN( APP_TITLE_NAME_A, "CEntryMenu::HandleInput()(MEMORY)Failed to allocate memory for Buffer 1!!" );

                        break;
                    }
                    ZeroMemory( m_pwszBuffer1, sizeof( WCHAR ) * MENU_ENTRY_NUMBER_SIZE );
					
					// Prompt the user for the amount of space needed (blocks)
                    g_MenuKeypad.SetInfo( L"Enter Settings Location #", m_pwszBuffer1, MENU_ENTRY_NUMBER_SIZE - 1 );
                    g_MenuKeypad.SetParent( this );
                    m_bActionInitiated = TRUE;

                    Leave( &g_MenuKeypad );

                    break;
                }

			case ENTRYMENU_ITEM_SETTINGS_CLOCK:
				{
					// Reboot to the XDash Clock
					LD_LAUNCH_DASHBOARD launchData;
					ZeroMemory( &launchData, sizeof( launchData ) );

                    launchData.dwContext    = XSHELL_LAUNCH_CONTEXT_SETTINGS;
					launchData.dwReason     = XLD_LAUNCH_DASHBOARD_SETTINGS;
					launchData.dwParameter1 = XLD_SETTINGS_CLOCK;

					XLaunchNewImage( FILE_DATA_XDASH_XBE_LOCATION, (PLAUNCH_DATA)&launchData );

                    break;
				}

			case ENTRYMENU_ITEM_SETTINGS_TIMEZONE:
				{
					// Reboot to the XDash TimeZone
					LD_LAUNCH_DASHBOARD launchData;
					ZeroMemory( &launchData, sizeof( launchData ) );

                    launchData.dwContext    = XSHELL_LAUNCH_CONTEXT_SETTINGS;
					launchData.dwReason     = XLD_LAUNCH_DASHBOARD_SETTINGS;
					launchData.dwParameter1 = XLD_SETTINGS_TIMEZONE;

					XLaunchNewImage( FILE_DATA_XDASH_XBE_LOCATION, (PLAUNCH_DATA)&launchData );

                    break;
				}
			case ENTRYMENU_ITEM_SETTINGS_LANGUAGE:
				{
					// Reboot to the XDash Language
					LD_LAUNCH_DASHBOARD launchData;
					ZeroMemory( &launchData, sizeof( launchData ) );

                    launchData.dwContext    = XSHELL_LAUNCH_CONTEXT_SETTINGS;
					launchData.dwReason     = XLD_LAUNCH_DASHBOARD_SETTINGS;
					launchData.dwParameter1 = XLD_SETTINGS_LANGUAGE;

					XLaunchNewImage( FILE_DATA_XDASH_XBE_LOCATION, (PLAUNCH_DATA)&launchData );

                    break;
				}

			case ENTRYMENU_ITEM_SETTINGS_CLOCK_TIMEZONE_LANGUAGE:
				{
					// Reboot to the XDash Clock, Timezone and language
					LD_LAUNCH_DASHBOARD launchData;
					ZeroMemory( &launchData, sizeof( launchData ) );

                    launchData.dwContext    = XSHELL_LAUNCH_CONTEXT_SETTINGS;
					launchData.dwReason     = XLD_LAUNCH_DASHBOARD_SETTINGS;
					launchData.dwParameter1 = XLD_SETTINGS_CLOCK + XLD_SETTINGS_TIMEZONE + XLD_SETTINGS_LANGUAGE;

					XLaunchNewImage( FILE_DATA_XDASH_XBE_LOCATION, (PLAUNCH_DATA)&launchData );

                    break;
				}
			case ENTRYMENU_ITEM_SETTINGS_CLOCK_TIMEZONE:
				{
					// Reboot to the XDash Clock and Timezone
					LD_LAUNCH_DASHBOARD launchData;
					ZeroMemory( &launchData, sizeof( launchData ) );

                    launchData.dwContext    = XSHELL_LAUNCH_CONTEXT_SETTINGS;
					launchData.dwReason     = XLD_LAUNCH_DASHBOARD_SETTINGS;
					launchData.dwParameter1 = XLD_SETTINGS_CLOCK + XLD_SETTINGS_TIMEZONE;

					XLaunchNewImage( FILE_DATA_XDASH_XBE_LOCATION, (PLAUNCH_DATA)&launchData );

                    break;
				}
			case ENTRYMENU_ITEM_SETTINGS_CLOCK_LANGUAGE:
				{
					// Reboot to the XDash Clock and language
					LD_LAUNCH_DASHBOARD launchData;
					ZeroMemory( &launchData, sizeof( launchData ) );

                    launchData.dwContext    = XSHELL_LAUNCH_CONTEXT_SETTINGS;
					launchData.dwReason     = XLD_LAUNCH_DASHBOARD_SETTINGS;
					launchData.dwParameter1 = XLD_SETTINGS_CLOCK + XLD_SETTINGS_LANGUAGE;

					XLaunchNewImage( FILE_DATA_XDASH_XBE_LOCATION, (PLAUNCH_DATA)&launchData );

                    break;
				}

			case ENTRYMENU_ITEM_SETTINGS_TIMEZONE_LANGUAGE:
				{
					// Reboot to the XDash Timezone and language
					LD_LAUNCH_DASHBOARD launchData;
					ZeroMemory( &launchData, sizeof( launchData ) );

                    launchData.dwContext    = XSHELL_LAUNCH_CONTEXT_SETTINGS;
					launchData.dwReason     = XLD_LAUNCH_DASHBOARD_SETTINGS;
					launchData.dwParameter1 = XLD_SETTINGS_TIMEZONE + XLD_SETTINGS_LANGUAGE;

					XLaunchNewImage( FILE_DATA_XDASH_XBE_LOCATION, (PLAUNCH_DATA)&launchData );

                    break;
				}

            case ENTRYMENU_ITEM_SETTINGS_COLLECTION:
                {
					// Reboot to the XDash Settings Collection Menu
					LD_LAUNCH_DASHBOARD launchData;
					ZeroMemory( &launchData, sizeof( launchData ) );

                    launchData.dwContext    = XSHELL_LAUNCH_CONTEXT_SETTINGS;
					launchData.dwReason     = XLD_LAUNCH_DASHBOARD_SETTINGS;

					XLaunchNewImage( FILE_DATA_XDASH_XBE_LOCATION, (PLAUNCH_DATA)&launchData );

                    break;
                }
            case ENTRYMENU_ITEM_SETTINGS_VIDEO:
                {
					// Reboot to the XDash Settings Video Menu
					LD_LAUNCH_DASHBOARD launchData;
					ZeroMemory( &launchData, sizeof( launchData ) );

                    launchData.dwContext    = XSHELL_LAUNCH_CONTEXT_SETTINGS;
					launchData.dwReason     = XLD_LAUNCH_DASHBOARD_SETTINGS;
                    launchData.dwParameter1 = XLD_SETTINGS_VIDEO;

					XLaunchNewImage( FILE_DATA_XDASH_XBE_LOCATION, (PLAUNCH_DATA)&launchData );

                    break;
                }
            case ENTRYMENU_ITEM_SETTINGS_AUDIO:
                {
					// Reboot to the XDash Settings Audio Menu
					LD_LAUNCH_DASHBOARD launchData;
					ZeroMemory( &launchData, sizeof( launchData ) );

                    launchData.dwContext    = XSHELL_LAUNCH_CONTEXT_SETTINGS;
					launchData.dwReason     = XLD_LAUNCH_DASHBOARD_SETTINGS;
                    launchData.dwParameter1 = XLD_SETTINGS_AUDIO;

					XLaunchNewImage( FILE_DATA_XDASH_XBE_LOCATION, (PLAUNCH_DATA)&launchData );

                    break;
                }
            case ENTRYMENU_ITEM_ERROR:
                {
                    // Make sure we setup Buffer 1
                    if( m_pwszBuffer1 )
                    {
                        delete[] m_pwszBuffer1;
                        m_pwszBuffer1 = NULL;
                    }

                    m_pwszBuffer1 = new WCHAR[MENU_ENTRY_NUMBER_SIZE];
                    if( NULL == m_pwszBuffer1 )
                    {
                        XDBGWRN( APP_TITLE_NAME_A, "CEntryMenu::HandleInput()(MEMORY)Failed to allocate memory for Buffer 1!!" );

                        break;
                    }
                    ZeroMemory( m_pwszBuffer1, sizeof( WCHAR ) * MENU_ENTRY_NUMBER_SIZE );

                    // Make sure we setup Buffer 2
                    if( m_pwszBuffer2 )
                    {
                        delete[] m_pwszBuffer2;
                        m_pwszBuffer2 = NULL;
                    }

                    m_pwszBuffer2 = new WCHAR[MENU_ENTRY_NUMBER_SIZE];
                    if( NULL == m_pwszBuffer2 )
                    {
                        XDBGWRN( APP_TITLE_NAME_A, "CEntryMenu::HandleInput()(MEMORY)Failed to allocate memory for Buffer 2!!" );

                        break;
                    }
                    ZeroMemory( m_pwszBuffer2, sizeof( WCHAR ) * MENU_ENTRY_NUMBER_SIZE );

					// Propmt user for error code
                    g_MenuKeypad.SetInfo( L"Enter the 1st Error Code", m_pwszBuffer1, MENU_ENTRY_NUMBER_SIZE - 1 );
                    g_MenuKeypad.SetParent( this );
                    m_bActionInitiated = TRUE;

                    Leave( &g_MenuKeypad );

                    break;
                }
            case ENTRYMENU_ITEM_ERROR_INVALID_XBE:
                {
					// Reboot to the XDash Error Menu
					LD_LAUNCH_DASHBOARD launchData;
					ZeroMemory( &launchData, sizeof( launchData ) );

				    launchData.dwReason     = XLD_LAUNCH_DASHBOARD_ERROR;
                    launchData.dwContext    = XSHELL_LAUNCH_CONTEXT_ERROR;
				    launchData.dwParameter1 = XLD_ERROR_INVALID_XBE;

					XLaunchNewImage( FILE_DATA_XDASH_XBE_LOCATION, (PLAUNCH_DATA)&launchData );

                    break;
                }
            case ENTRYMENU_ITEM_ERROR_INVALID_HARD_DISK:
                {
					// Reboot to the XDash Error Menu
					LD_LAUNCH_DASHBOARD launchData;
					ZeroMemory( &launchData, sizeof( launchData ) );

				    launchData.dwReason     = XLD_LAUNCH_DASHBOARD_ERROR;
                    launchData.dwContext    = XSHELL_LAUNCH_CONTEXT_ERROR;
				    launchData.dwParameter1 = XLD_ERROR_INVALID_HARD_DISK;

					XLaunchNewImage( FILE_DATA_XDASH_XBE_LOCATION, (PLAUNCH_DATA)&launchData );

                    break;
                }
            case ENTRYMENU_ITEM_ERROR_INVALID_XBE_REGION:
                {
					// Reboot to the XDash Error Menu
					LD_LAUNCH_DASHBOARD launchData;
					ZeroMemory( &launchData, sizeof( launchData ) );

				    launchData.dwReason     = XLD_LAUNCH_DASHBOARD_ERROR;
                    launchData.dwContext    = XSHELL_LAUNCH_CONTEXT_ERROR;
				    launchData.dwParameter1 = XLD_ERROR_XBE_REGION;

					XLaunchNewImage( FILE_DATA_XDASH_XBE_LOCATION, (PLAUNCH_DATA)&launchData );

                    break;
                }
            case ENTRYMENU_ITEM_ERROR_INVALID_XBE_PARENTAL_CONTROL:
                {
					// Reboot to the XDash Error Menu
					LD_LAUNCH_DASHBOARD launchData;
					ZeroMemory( &launchData, sizeof( launchData ) );

				    launchData.dwReason     = XLD_LAUNCH_DASHBOARD_ERROR;
                    launchData.dwContext    = XSHELL_LAUNCH_CONTEXT_ERROR;
				    launchData.dwParameter1 = XLD_ERROR_XBE_PARENTAL_CONTROL;

					XLaunchNewImage( FILE_DATA_XDASH_XBE_LOCATION, (PLAUNCH_DATA)&launchData );

                    break;
                }
            case ENTRYMENU_ITEM_ERROR_INVALID_XBE_MEDIA_TYPE:
                {
					// Reboot to the XDash Error Menu
					LD_LAUNCH_DASHBOARD launchData;
					ZeroMemory( &launchData, sizeof( launchData ) );

				    launchData.dwReason     = XLD_LAUNCH_DASHBOARD_ERROR;
                    launchData.dwContext    = XSHELL_LAUNCH_CONTEXT_ERROR;
				    launchData.dwParameter1 = XLD_ERROR_XBE_MEDIA_TYPE;

					XLaunchNewImage( FILE_DATA_XDASH_XBE_LOCATION, (PLAUNCH_DATA)&launchData );

                    break;
                }
            }

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                Leave( GetParent() );
            }
            break;
        }
    case BUTTON_X:
        {
            break;
        }
    case BUTTON_Y:
        {
            break;
        }
    case BUTTON_BLACK:
        {
            break;
        }
    case BUTTON_WHITE:
        {
            break;
        }
    }
}


// Initialize the Menu
HRESULT CEntryMenu::Init( IDirect3DDevice8* pD3DDevice, char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CEntryMenu::Init()" );

    CMenuScreen::Init( pD3DDevice, menuFileName );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\entrymenu.h ===
/*****************************************************
*** entrymenu.h
***
*** Header file for our Entry Point menu
*** class. This menu class will allow you to perform
*** various Entry Point operations.
***
*** by James N. Helm
*** April 23rd, 2001
***
*****************************************************/

#ifndef _ENTRYMENU_H_
#define _ENTRYMENU_H_

#include "menuscreen.h"  // Base menu type

class CEntryMenu : public CMenuScreen
{
public:
    CEntryMenu( CXItem* pParent );
    ~CEntryMenu();

    // Must be overridden for this to be a Item on our XShell program
    // void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods
    HRESULT Init( IDirect3DDevice8* pD3DDevice, char* menuFileName );       // Initialize our font and settings

private:
    unsigned int    m_uiTopItemIndex;       // Index of the top item being displayed
    unsigned int    m_uiNumItemsToDisplay;  // Used to hold the number of items to display on our menu

    WCHAR*  m_pwszValueBuffer;				// Buffer to hold info from our Keypad / Keyboard functions
	BOOL	m_bActionInitiated;				// Used to determine when the user is performing an action

    WCHAR*  m_pwszBuffer1;                  // Used to hold info from our Keypad / Keyboard functions
    WCHAR*  m_pwszBuffer2;                  // Used to hold info from our Keypad / Keyboard functions

    // Private Methods
    // void Leave( CXItem* pItem );                                        // This should be called whenever a user leaves this menu
};

#endif // _ENTRYMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\dvdregionmenu.h ===
/*****************************************************
*** dvdregionmenu.h
***
*** Header file for our DVD Region menu class.  This
*** class will allow a user to select a new DVD
*** region
***
*** by James Helm
*** May 12th, 2001
***
*****************************************************/

#ifndef _DVDREGIONMENU_H_
#define _DVDREGIONMENU_H_

#include "keypadmenu.h"  // Base menu type

class CDVDRegionMenu : public CKeypadMenu
{
public:
    // Constructors and Destructor
    CDVDRegionMenu( CXItem* pParent );
    ~CDVDRegionMenu();

    // Methods
    void Enter();                                                       // This will be called whenever the user enters this menu
    void Action( CUDTexture* pTexture );  // Perform our actions (draw the screen items, etc)
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );   // Handle input to the buttons
    void HandleInput( enum CONTROLS buttonPressed, BOOL bFirstPress );

private:
    // Properties
    CKey m_keyPad[MENU_DVDREGION_NUM_COLS][MENU_DVDREGION_NUM_ROWS];  // Keypad

    void GenerateKeypad(void);
	BOOL renderKeypad( CUDTexture* pTexture );

    DWORD GetDVDRegion();                           // Get the DVD Region in a 'menu-friendly' format
    HRESULT SetDVDRegion( DWORD dwDVDRegion );      // Set the DVD Region using our 'menu-friendly' format
};

#endif // _DVDREGIONMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\gameregionmenu.cpp ===
/*****************************************************
*** gameregionmenu.cpp
***
*** CPP file for our Game Region menu class.  This
*** class will allow a user to select a new game
*** region
***
*** by James Helm
*** May 11th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "gameregionmenu.h"

extern CXSettings g_XboxSettings;   // Xbox Settings Object

// Constructor
CGameRegionMenu::CGameRegionMenu( CXItem* pParent )
: CKeypadMenu( pParent )
{
    XDBGTRC( APP_TITLE_NAME_A, "CGameRegionMenu::CGameRegionMenu( CXItem )" );

    // Set the number of items on the menu
    m_uiNumItems = GAMEREGIONMENU_ITEM_NUM_ITEMS;
    SetSelectedItem( 0 );

	GenerateKeypad();

    // Default the key to the TOP Button
	m_xKeypos = 0;
	m_yKeypos = 0;
}


// Destructor
CGameRegionMenu::~CGameRegionMenu()
{
}

// Draws a menu on to the screen
void CGameRegionMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should update our texture, if not, return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else // Reset the Update flag
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture so we can render to it
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );
    
    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

    //
	// Render the current Game Region Text
    //
    int iStringPixelWidth = GetStringPixelWidth( MENU_GAMEREGION_CURRENT_REGION_TEXT );
    float fXPos = SCREEN_X_CENTER - ( iStringPixelWidth / 2.0f );
    float fYPos = MENU_GAMEREGION_TEXT_Y1;
    pTexture->DrawText( fXPos, fYPos, SCREEN_INACTIVE_OPTION_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", MENU_GAMEREGION_CURRENT_REGION_TEXT );

    iStringPixelWidth = GetStringPixelWidth( g_wpszGameRegionMenuItems[GetGameRegion()] );
    fXPos = SCREEN_X_CENTER - ( iStringPixelWidth / 2.0f );
    unsigned int uiFontHeight, uiFontWidth;
    GetFontSize( &uiFontHeight, &uiFontWidth );
    fYPos = MENU_GAMEREGION_TEXT_Y1 + uiFontHeight + MENUBOX_ITEM_VERT_SPACING;
    pTexture->DrawText( fXPos, fYPos, SCREEN_ACTIVE_OPTION_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", g_wpszGameRegionMenuItems[GetGameRegion()] );
    
    //
    // Draw our keypad / Game Region Menu Items
    //
	renderKeypad( pTexture );

    // Unlock our Texture
    pTexture->Unlock();
}

// Handles input (of the BUTTONS) for the current menu
void CGameRegionMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Don't update the setting unless the user is on one of the buttons
            if( 0 == m_xKeypos )
            {
                m_bUpdateTexture = TRUE;

                // Set the Game Region in to the Config Sector
                HRESULT hr = SetGameRegion( m_yKeypos ); // m_yKeypos will map to the enum GameRegionMenu items
                if( FAILED( hr ) )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "CGameRegionMenu::HandleInput():Failed to set the Game Region!! Region - '%d', Error - '0x%X.08'", m_yKeypos, hr );
                }

                Leave( GetParent() );
            }
            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                Leave( GetParent() );
            }
            break;
        }
    }
}

// Handles input (of the CONTROLS) for the current menu
void CGameRegionMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            if( m_yKeypos != 0 )
            {
                m_bUpdateTexture = TRUE;

                m_yKeypos--;
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            if( m_yKeypos < ( GAMEREGIONMENU_ITEM_NUM_ITEMS - 1 ) )
            {
                m_bUpdateTexture = TRUE;

				m_yKeypos++;
            }
            break;
        }
    case CONTROL_DPAD_LEFT:
        {
            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            break;
        }
	}
}


void CGameRegionMenu::GenerateKeypad(void) 
{
	// First create numberpad
	int xgrid  = MENU_GAMEREGION_NUM_COLS;
	int ygrid  = MENU_GAMEREGION_NUM_ROWS;
	int xstart = MENU_GAMEREGION_BUTTON_X1;
	int ystart = MENU_GAMEREGION_BUTTON_Y1;
	int width  = MENU_GAMEREGION_BUTTON_WIDTH;
	int height = 32;
	int spacer = 2;

	int currentx = xstart;
	int currenty = ystart;

	for(int y = 0; y < ygrid; y++)
	{
		for(int x = 0; x < xgrid; x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_FOREGROUND_COLOR );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}

    // Set the text of the keys
    for( int z = 0; z < GAMEREGIONMENU_ITEM_NUM_ITEMS; z++ )
    {
        m_keyPad[0][z].defineText(g_wpszGameRegionMenuItems[z]);
    }
}


BOOL CGameRegionMenu::renderKeypad( CUDTexture* pTexture )
{
	
	// Render outlines of keys	
	float x1, x2;
	float y1, y2;
	for(int x = 0; x < MENU_GAMEREGION_NUM_COLS; x++)
	{
		for(int y = 0; y < MENU_GAMEREGION_NUM_ROWS; y++)
		{
			if(m_keyPad[x][y].getRender())
			{
                // Lock our texture
                pTexture->Lock();

				x1 = (float)m_keyPad[x][y].m_iXOrigin;
				x2 = (float)(m_keyPad[x][y].m_iXOrigin + m_keyPad[x][y].m_iWidth);
				
				y1 = (float)m_keyPad[x][y].m_iYOrigin;
				y2 = (float)(m_keyPad[x][y].m_iYOrigin + m_keyPad[x][y].m_iHeight);
	
				// hilight key if currently selected
                DWORD dwCharColor;
				if((m_xKeypos == x) && (m_yKeypos == y))
                {
					pTexture->DrawBox( x1, y1, x2, y2, SCREEN_DEFAULT_SELECTOR_COLOR );
                    
                    dwCharColor = SCREEN_SELECTED_OPTION_COLOR;
                }
                else
                {
                    dwCharColor = SCREEN_DEFAULT_FOREGROUND_COLOR;
                }

                pTexture->DrawOutline( x1, y1, x2, y2, MENU_GAMEREGION_LINE_WIDTH, m_keyPad[x][y].m_dwSelectColor );
				
				unsigned int decent;
				unsigned int fontHeight;
				GetFontSize( &fontHeight, &decent );
				
				float textX = (float)((m_keyPad[x][y].m_iWidth / 2) + m_keyPad[x][y].m_iXOrigin) - GetStringPixelWidth( m_keyPad[x][y].m_pwszResultChar ) / 2;
				float textY = (float)((m_keyPad[x][y].m_iHeight / 2) + m_keyPad[x][y].m_iYOrigin) - (fontHeight / 2);
				pTexture->DrawText( textX, textY, dwCharColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", m_keyPad[x][y].m_pwszResultChar);

                // Unlock our Texture
                pTexture->Unlock();
			}
		}
	}
	
	return TRUE;
}

// This will be called whenever the user enters this menu
void CGameRegionMenu::Enter()
{
    // Call the base-class enter
    CKeypadMenu::Enter();

    // Default the key to the TOP Button
	m_xKeypos = 0;
	m_yKeypos = GetGameRegion();
}


// Get the Game Region in a 'menu-friendly' format
DWORD CGameRegionMenu::GetGameRegion()
{
    switch( g_XboxSettings.GetGameRegion() )
    {
    case XC_GAME_REGION_NA:
        {
            return GAMEREGIONMENU_ITEM_REGION1;

            break;
        }
    case XC_GAME_REGION_JAPAN:
        {
            return GAMEREGIONMENU_ITEM_REGION2;

            break;
        }
    case XC_GAME_REGION_RESTOFWORLD:
        {
            return GAMEREGIONMENU_ITEM_REGION3;

            break;
        }
    default:
        {
            XDBGWRN( APP_TITLE_NAME_A, "CGameRegionMenu::GetGameRegion():Received unknown Game Region from Config Sector!! Region - '%d'", g_XboxSettings.GetGameRegion() );
            XDBGWRN( APP_TITLE_NAME_A, "CGameRegionMenu::GetGameRegion():Setting Game Region to - '%d'", XC_GAME_REGION_NA );

            HRESULT hr = g_XboxSettings.SetGameRegion( XC_GAME_REGION_NA );
            if( FAILED( hr ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CGameRegionMenu::GetGameRegion():Failed to Set the Game Region!! Region - '%d', Error - '0x%0.8X (%d)'", XC_GAME_REGION_NA, hr, hr );
            }

            break;
        }
    }

    return GAMEREGION_NONE;
}


// Set the Game Region using our 'menu-friendly' format
HRESULT CGameRegionMenu::SetGameRegion( DWORD dwGameRegion )
{
    DWORD dwConfigSectorGameRegion = 0;

    switch( dwGameRegion )
    {
    case GAMEREGIONMENU_ITEM_REGION1:
        {
            dwConfigSectorGameRegion = XC_GAME_REGION_NA;

            break;
        }
    case GAMEREGIONMENU_ITEM_REGION2:
        {
            dwConfigSectorGameRegion = XC_GAME_REGION_JAPAN;

            break;
        }
    case GAMEREGIONMENU_ITEM_REGION3:
        {
            dwConfigSectorGameRegion = XC_GAME_REGION_RESTOFWORLD;

            break;
        }
    default:
        {
            XDBGWRN( APP_TITLE_NAME_A, "CGameRegionMenu::SetGameRegion():Invalid Game Region Passed In - '%d'", dwGameRegion );

            return E_INVALIDARG;
        }
    }

    HRESULT hr = g_XboxSettings.SetGameRegion( dwConfigSectorGameRegion );
    if( FAILED( hr ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CGameRegionMenu::SetGameRegion():Failed to set the Game Region!! Region - '%d', Error - '0x%0.8X (%d)'", dwConfigSectorGameRegion, hr, hr );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\dvdregionmenu.cpp ===
/*****************************************************
*** dvdregionmenu.cpp
***
*** CPP file for our DVD Region menu class.  This
*** class will allow a user to select a new DVD
*** region
***
*** by James Helm
*** May 12th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "dvdregionmenu.h"

extern CXSettings g_XboxSettings;   // Xbox Settings Object

// Constructor
CDVDRegionMenu::CDVDRegionMenu( CXItem* pParent )
: CKeypadMenu( pParent )
{
    XDBGTRC( APP_TITLE_NAME_A, "CDVDRegionMenu::CDVDRegionMenu( CXItem )" );

    // Set the number of items on the menu
    m_uiNumItems = DVDREGIONMENU_ITEM_NUM_ITEMS;
    SetSelectedItem( 0 );

	GenerateKeypad();

    // Default the key to the TOP Button
	m_xKeypos = 0;
	m_yKeypos = 0;
}


// Destructor
CDVDRegionMenu::~CDVDRegionMenu()
{
}

// Draws a menu on to the screen
void CDVDRegionMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should update our texture, if not, return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else // Reset the Update flag
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture so we can render to it
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );
    
    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

    //
	// Render the current DVD Region Text
    //
    WCHAR pwszDVDRegion[100];
    ZeroMemory( pwszDVDRegion, sizeof( WCHAR ) * 100 );

    _snwprintf( pwszDVDRegion, 99, L"%s%d", MENU_DVDREGION_CURRENT_REGION_TEXT, GetDVDRegion() );
    int iStringPixelWidth = GetStringPixelWidth( pwszDVDRegion );
    float fXPos = SCREEN_X_CENTER - ( iStringPixelWidth / 2.0f );
    float fYPos = MENU_DVDREGION_TEXT_Y1;
    pTexture->DrawText( fXPos, fYPos, SCREEN_INACTIVE_OPTION_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", pwszDVDRegion );

    //
    // Draw our keypad / DVD Region Menu Items
    //
	renderKeypad( pTexture );

    // Unlock our Texture
    pTexture->Unlock();
}

// Handles input (of the BUTTONS) for the current menu
void CDVDRegionMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Don't update the setting unless the user is on one of the buttons
            if( 0 == m_xKeypos )
            {
                m_bUpdateTexture = TRUE;

                // Set the DVD Region in to the Config Sector
                HRESULT hr = SetDVDRegion( m_yKeypos ); // m_yKeypos will map to the enum DVDRegionMenu items
                if( FAILED( hr ) )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "CDVDRegionMenu::HandleInput():Failed to set the DVD Region!! Region - '%d', Error - '0x%.8X'", m_yKeypos, hr );
                }

                Leave( GetParent() );
            }
            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                Leave( GetParent() );
            }
            break;
        }
    }
}

// Handles input (of the CONTROLS) for the current menu
void CDVDRegionMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            if( m_yKeypos != 0 )
            {
                m_bUpdateTexture = TRUE;

                m_yKeypos--;
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            if( m_yKeypos < ( DVDREGIONMENU_ITEM_NUM_ITEMS - 1 ) )
            {
                m_bUpdateTexture = TRUE;

				m_yKeypos++;
            }
            break;
        }
    case CONTROL_DPAD_LEFT:
        {
            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            break;
        }
	}
}


void CDVDRegionMenu::GenerateKeypad(void) 
{
	// First create numberpad
	int xgrid  = MENU_DVDREGION_NUM_COLS;
	int ygrid  = MENU_DVDREGION_NUM_ROWS;
	int xstart = MENU_DVDREGION_BUTTON_X1;
	int ystart = MENU_DVDREGION_BUTTON_Y1;
	int width  = MENU_DVDREGION_BUTTON_WIDTH;
	int height = MENU_DVDREGION_BUTTON_HEIGHT;
	int spacer = 2;

	int currentx = xstart;
	int currenty = ystart;

	for(int y = 0; y < ygrid; y++)
	{
		for(int x = 0; x < xgrid; x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_FOREGROUND_COLOR );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}

    // Set the text of the keys
    for( int z = 0; z < DVDREGIONMENU_ITEM_NUM_ITEMS; z++ )
    {
        m_keyPad[0][z].defineText(g_wpszDVDRegionMenuItems[z]);
    }
}


BOOL CDVDRegionMenu::renderKeypad( CUDTexture* pTexture )
{
	
	// Render outlines of keys	
	float x1, x2;
	float y1, y2;
	for(int x = 0; x < MENU_DVDREGION_NUM_COLS; x++)
	{
		for(int y = 0; y < MENU_DVDREGION_NUM_ROWS; y++)
		{
			if(m_keyPad[x][y].getRender())
			{
                // Lock our texture
                pTexture->Lock();

				x1 = (float)m_keyPad[x][y].m_iXOrigin;
				x2 = (float)(m_keyPad[x][y].m_iXOrigin + m_keyPad[x][y].m_iWidth);
				
				y1 = (float)m_keyPad[x][y].m_iYOrigin;
				y2 = (float)(m_keyPad[x][y].m_iYOrigin + m_keyPad[x][y].m_iHeight);
	
				// hilight key if currently selected
                DWORD dwCharColor;
				if((m_xKeypos == x) && (m_yKeypos == y))
                {
					pTexture->DrawBox( x1, y1, x2, y2, SCREEN_DEFAULT_SELECTOR_COLOR );
                    
                    dwCharColor = SCREEN_SELECTED_OPTION_COLOR;
                }
                else
                {
                    dwCharColor = SCREEN_DEFAULT_FOREGROUND_COLOR;
                }

                pTexture->DrawOutline( x1, y1, x2, y2, MENU_DVDREGION_LINE_WIDTH, m_keyPad[x][y].m_dwSelectColor );
				
				unsigned int decent;
				unsigned int fontHeight;
				GetFontSize( &fontHeight, &decent );
				
				float textX = (float)((m_keyPad[x][y].m_iWidth / 2) + m_keyPad[x][y].m_iXOrigin) - GetStringPixelWidth( m_keyPad[x][y].m_pwszResultChar ) / 2;
				float textY = (float)((m_keyPad[x][y].m_iHeight / 2) + m_keyPad[x][y].m_iYOrigin) - (fontHeight / 2);
				pTexture->DrawText( textX, textY, dwCharColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", m_keyPad[x][y].m_pwszResultChar);

                // Unlock our Texture
                pTexture->Unlock();
			}
		}
	}
	
	return TRUE;
}

// This will be called whenever the user enters this menu
void CDVDRegionMenu::Enter()
{
    // Call the base-class enter
    CKeypadMenu::Enter();

    // Default the key to the TOP Button
	m_xKeypos = 0;
	m_yKeypos = GetDVDRegion();
}


// Get the DVD Region in a 'menu-friendly' format
DWORD CDVDRegionMenu::GetDVDRegion()
{
    switch( g_XboxSettings.GetDVDRegion() )
    {
    case XSETTINGS_DVD_REGION0:
        {
            return DVDREGIONMENU_ITEM_REGION0;
            
            break;
        }
    case XSETTINGS_DVD_REGION1:
        {
            return DVDREGIONMENU_ITEM_REGION1;

            break;
        }
    case XSETTINGS_DVD_REGION2:
        {
            return DVDREGIONMENU_ITEM_REGION2;

            break;
        }
    case XSETTINGS_DVD_REGION3:
        {
            return DVDREGIONMENU_ITEM_REGION3;

            break;
        }
    case XSETTINGS_DVD_REGION4:
        {
            return DVDREGIONMENU_ITEM_REGION4;

            break;
        }
    case XSETTINGS_DVD_REGION5:
        {
            return DVDREGIONMENU_ITEM_REGION5;

            break;
        }
    case XSETTINGS_DVD_REGION6:
        {
            return DVDREGIONMENU_ITEM_REGION6;

            break;
        }
    default:
        {
            XDBGWRN( APP_TITLE_NAME_A, "CDVDRegionMenu::GetDVDRegion():Received unknown DVD Region from Config Sector!! Region - '%d'", g_XboxSettings.GetDVDRegion() );
            XDBGWRN( APP_TITLE_NAME_A, "CDVDRegionMenu::GetDVDRegion():Setting DVD Region to - '%d'", DVDREGIONMENU_ITEM_REGION0 );

            HRESULT hr = g_XboxSettings.SetDVDRegion( DVDREGIONMENU_ITEM_REGION0 );
            if( FAILED( hr ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CDVDRegionMenu::GetDVDRegion():Failed to Set the DVD Region!! Region - '%d', Error - '0x%0.8X (%d)'", DVDREGIONMENU_ITEM_REGION0, hr, hr );
            }

            break;
        }
    }

    return DVDREGIONMENU_ITEM_REGION0;
}


// Set the DVD Region using our 'menu-friendly' format
HRESULT CDVDRegionMenu::SetDVDRegion( DWORD dwDVDRegion )
{
    DWORD dwConfigSectorDVDRegion = 0;

    switch( dwDVDRegion )
    {
    case DVDREGIONMENU_ITEM_REGION0:
        {
            dwConfigSectorDVDRegion = XSETTINGS_DVD_REGION0;

            break;
        }
    case DVDREGIONMENU_ITEM_REGION1:
        {
            dwConfigSectorDVDRegion = XSETTINGS_DVD_REGION1;

            break;
        }
    case DVDREGIONMENU_ITEM_REGION2:
        {
            dwConfigSectorDVDRegion = XSETTINGS_DVD_REGION2;

            break;
        }
    case DVDREGIONMENU_ITEM_REGION3:
        {
            dwConfigSectorDVDRegion = XSETTINGS_DVD_REGION3;

            break;
        }
    case DVDREGIONMENU_ITEM_REGION4:
        {
            dwConfigSectorDVDRegion = XSETTINGS_DVD_REGION4;

            break;
        }
    case DVDREGIONMENU_ITEM_REGION5:
        {
            dwConfigSectorDVDRegion = XSETTINGS_DVD_REGION5;

            break;
        }
    case DVDREGIONMENU_ITEM_REGION6:
        {
            dwConfigSectorDVDRegion = XSETTINGS_DVD_REGION6;

            break;
        }
    default:
        {
            XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CDVDRegionMenu::SetDVDRegion():Invalid DVD Region Passed In - '%d'", dwDVDRegion );

            return E_INVALIDARG;
        }
    }

    HRESULT hr = g_XboxSettings.SetDVDRegion( dwConfigSectorDVDRegion );
    if( FAILED( hr ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CDVDRegionMenu::SetDVDRegion():Failed to set the DVD Region!! Region - '%d', Error - '0x%0.8X (%d)'", dwConfigSectorDVDRegion, hr, hr );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\gameregionmenu.h ===
/*****************************************************
*** gameregionmenu.h
***
*** Header file for our Game Region menu class.  This
*** class will allow a user to select a new game
*** region
***
*** by James Helm
*** May 11th, 2001
***
*****************************************************/

#ifndef _GAMEREGIONMENU_H_
#define _GAMEREGIONMENU_H_

#include "keypadmenu.h"  // Base menu type

class CGameRegionMenu : public CKeypadMenu
{
public:
    // Constructors and Destructor
    CGameRegionMenu( CXItem* pParent );
    ~CGameRegionMenu();

    // Methods
    void Enter();                                                       // This will be called whenever the user enters this menu
    void Action( CUDTexture* pTexture );  // Perform our actions (draw the screen items, etc)
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );   // Handle input to the buttons
    void HandleInput( enum CONTROLS buttonPressed, BOOL bFirstPress );

private:
    // Properties
    CKey m_keyPad[MENU_GAMEREGION_NUM_COLS][MENU_GAMEREGION_NUM_ROWS];  // Keypad

    void GenerateKeypad(void);
	BOOL renderKeypad( CUDTexture* pTexture );

    DWORD GetGameRegion();                          // Get the Game Region in a 'menu-friendly' format
    HRESULT SetGameRegion( DWORD dwGameRegion );    // Set the Game Region using our 'menu-friendly' format
};

#endif // _GAMEREGIONMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\gametitlemenu.cpp ===
/*****************************************************
*** gametitlemenu.cpp
***
*** CPP file for our Game Title menu class.  This
*** menu will list all of the Game Titles for a
*** specified Memory Area, and allow the user to
*** select one
***
*** by James N. Helm
*** June 17th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "gametitlemenu.h"

// extern BOOL                 g_bDisplayUpArrow;      // Used to determine if we should render the Up Arrow
// extern BOOL                 g_bDisplayDownArrow;    // Used to determine if we should render the Down Arrow
extern XFONT*               g_pFont;

// Constructors
CGameTitleMenu::CGameTitleMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_uiTopItemIndex( 0 ),
m_pXboxGames( NULL )
{
    XDBGTRC( APP_TITLE_NAME_A, "CGameTitleMenu::CGameTitleMenu(ex)" );

    m_uiNumItems = 0;
    SetSelectedItem( 0 );
}


// Destructor
CGameTitleMenu::~CGameTitleMenu()
{
}

// Draws a menu on to the screen
void CGameTitleMenu::Action( CUDTexture* pTexture )
{
    // Only update the texture if we need to, otherwise return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Update our Font Height
    unsigned int uiDefaultFontHeight = m_uiFontHeightOfItem;
    XFONT_SetTextHeight( g_pFont, GAME_TITLE_MENU_ITEM_FONT_HEIGHT );
    m_uiFontHeightOfItem = GAME_TITLE_MENU_ITEM_FONT_HEIGHT;

    // Let our base menu class draw all the items pulled from the MNU file
    CMenuScreen::Action( pTexture );

    if( GetNumItems() != 0 )
    {
        // Draw a box behind the currently highlighted choice
        float X1Pos = MENUBOX_SELECTOR_X1;
        float Y1Pos = MENUBOX_MAINAREA_Y1 + MENUBOX_MAINAREA_BORDERWIDTH_TOP + ( ( MENUBOX_ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( GetSelectedItem() - m_uiTopItemIndex ) ) - MENUBOX_SELECTOR_BORDER_WIDTH;
        float X2Pos = MENUBOX_SELECTOR_X2;
        float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * MENUBOX_SELECTOR_BORDER_WIDTH );
    
        pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, SCREEN_DEFAULT_SELECTOR_COLOR );

        //
        // Draw our Menu Items
        //

        for( unsigned int x = m_uiTopItemIndex; x < ( GAME_TITLE_MENU_NUM_ITEMS_TO_DISPLAY + m_uiTopItemIndex ); x++ )
        {
            // Make sure we don't try to access out of range items
            if( x == GetNumItems() )
            {
                break;
            }

            float XPos = MENUBOX_MAINAREA_X1 + MENUBOX_MAINAREA_BORDERWIDTH_LEFT;
            float YPos = MENUBOX_MAINAREA_Y1 + MENUBOX_MAINAREA_BORDERWIDTH_TOP + ( ( MENUBOX_ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( x - m_uiTopItemIndex ) );

            pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%hs (%ls)", m_pXboxGames->GetGame( x )->GetTitleID(), m_pXboxGames->GetGame( x )->GetName() );
        }
    }

    // Correct our Font Height
    m_uiFontHeightOfItem = uiDefaultFontHeight;
    XFONT_SetTextHeight( g_pFont, uiDefaultFontHeight );

    // Unlock the texture
    pTexture->Unlock();
}


// Handle any requests for the joystick (thumb-pad)
void CGameTitleMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CGameTitleMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() > 0 )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    // g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() - 1 );

                    // Make sure we are displaying the correct items
                    if( GetSelectedItem() < (int)m_uiTopItemIndex )
                    {
                        m_uiTopItemIndex = GetSelectedItem();

                        // AdjustDisplayArrows();
                    }
                }
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( ( (unsigned int)GetSelectedItem() + 1 ) < GetNumItems() )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    // g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() + 1 );

                    // Make sure we are displaying the correct items
                    if( GetSelectedItem() >= (int)( GAME_TITLE_MENU_NUM_ITEMS_TO_DISPLAY + m_uiTopItemIndex ) )
                    {
                        m_uiTopItemIndex += 1;

                        // AdjustDisplayArrows();
                    }
                }
            }
            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CGameTitleMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                // Play the Select Sound
                // g_Sounds.PlaySelectSound();

                Leave( GetParent() );
            }

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                // g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    case BUTTON_Y:
        {
            break;
        }
    }
}


// Initialize the Menu
HRESULT CGameTitleMenu::Init( IDirect3DDevice8* pD3DDevice, char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CGameTitleMenu::Init()" );

    HRESULT hr = CMenuScreen::Init( pD3DDevice, menuFileName );

    return hr;
}


// Sets the Xbox Game object the menu should use
void CGameTitleMenu::SetInfo( CXboxGames* pXboxGames )
{
    if( NULL == pXboxGames )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CGameTitleMenu::SetInfo():Invalid parameter passed in!!" );

        return;
    }

    m_pXboxGames = pXboxGames;
    m_uiNumItems = m_pXboxGames->GetNumGames();

    if( GetNumItems() > 0 )
    {
        SetSelectedItem( 0 );
    }
}


// Should be called whenever a user leaves the menu
void CGameTitleMenu::Leave( CXItem* pItem )
{
    // Call our base class Leave
    CMenuScreen::Leave( pItem );

    // g_bDisplayUpArrow = FALSE;
    // g_bDisplayDownArrow = FALSE;

    // Make sure we set that we have no items
    m_pXboxGames = NULL;
    m_uiNumItems = 0;
    m_uiTopItemIndex = 0;
}

// This will be called whenever the user enters this menu
void CGameTitleMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Set our selected item to the top of the menu
    if( GetNumItems() > 0 )
    {
        SetSelectedItem( 0 );
        m_uiTopItemIndex = 0;
    }

    // Make sure the proper arrows are displayed
    // AdjustDisplayArrows();
}


/*
// TODO: Implement the arrows
// Adjust the UP and DOWN arrows on the screen
void CGameTitleMenu::AdjustDisplayArrows()
{
    // Decide if we need to turn on the Up Arrow
    if( 0 == m_uiTopItemIndex )
    //
    // We can turn off the Up Arrow, because there is nothing above us
    //
    {
        g_bDisplayUpArrow = FALSE;
    }
    else
    //
    // We have to turn on the Up Arrow, because a menu choice is above us
    //
    {
        g_bDisplayUpArrow = TRUE;
    }

    // Decide if we need to turn on the Down Arrow
    if( ( m_uiTopItemIndex + GAME_TITLE_MENU_NUM_ITEMS_TO_DISPLAY ) == GetNumItems() )
    //
    // We can turn off the Down arrow, because nothing is below us
    //
    {
        g_bDisplayDownArrow = FALSE;
    }
    else
    //
    // We have to turn on the Down Arrow, because there are menu choices below us
    //
    {
        g_bDisplayDownArrow = TRUE;
    }
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\gametitlemenu.h ===
/*****************************************************
*** gametitlemenu.h
***
*** Header file for our Game Title menu class.  This
*** menu will list all of the Game Titles for a
*** specified Memory Area, and allow the user to
*** select one
***
*** by James N. Helm
*** June 17th, 2001
***
*****************************************************/

#ifndef _GAMETITLEMENU_H_
#define _GAMETITLEMENU_H_

#include "menuscreen.h"

class CGameTitleMenu : public CMenuScreen
{
public:
    CGameTitleMenu( CXItem* pParent );
    ~CGameTitleMenu();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();                                       // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );                // Called each frame -- renders screen, and performs other necessary actions
                 
    void HandleInput( enum BUTTONS buttonPressed,       // Handles Button input for this screen
                      BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed,     // Handles Control input for this screen
                      BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick,           // Handles Joystick input for this screen
                      int nThumbY,
                      int nThumbX,
                      BOOL bFirstYPress,
                      BOOL bFirstXPress );

    // Public Methods
    HRESULT Init( IDirect3DDevice8* pD3DDevice, // Initialize our font and settings
                  char* menuFileName );
    void    Leave( CXItem* pItem );             // Should be called whenever a user deactivates this item
    void    SetInfo( CXboxGames* pXboxGames );  // Sets the Xbox Game object the menu should use

private:
    // Private Properties
    unsigned int    m_uiTopItemIndex;           // Index of the top item being displayed
    CXboxGames*     m_pXboxGames;               // Pointer to our Xbox Games Object

    // Private Methods
    // void AdjustDisplayArrows();                     // Adjust the UP and DOWN arrows on the screen
};

#define GAME_TITLE_MENU_ITEM_FONT_HEIGHT        SCREEN_DEFAULT_FONT_HEIGHT
#define GAME_TITLE_MENU_NUM_ITEMS_TO_DISPLAY    9

#endif // _GAMETITLEMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\key.cpp ===
#include "stdafx.h"
#include "key.h"

// Key Class by Victor Blanco
CKey::CKey()
:
m_iXOrigin( 0 ),
m_iYOrigin( 0 ),
m_iWidth( 0 ),
m_iHeight( 0 ),		
m_dwSelectColor( 0x00000000 ),
m_fRender( TRUE ),
m_pwszResultChar( NULL )
{
}

CKey::~CKey()
{
    if( m_pwszResultChar )
    {
        delete[] m_pwszResultChar;
        m_pwszResultChar = NULL;
    }
}

void CKey::define( int iX, int iY, int iW, int iH, DWORD dwColor )
{
	m_iXOrigin = iX;
	m_iYOrigin = iY;
	m_iWidth = iW;
	m_iHeight = iH;		
	m_dwSelectColor = dwColor;	
}

void CKey::defineText( WCHAR* pwszResult )
{
    if( !pwszResult )
    {
        return;
    }

    // Make sure we don't cause a memory leak
    if( m_pwszResultChar )
    {
        delete[] m_pwszResultChar;
        m_pwszResultChar = NULL;
    }

    m_pwszResultChar = _wcsdup( pwszResult );

    /*
	int iLength = wcslen( pwszResult );
	m_pwszResultChar = new WCHAR[iLength + 1];
	wcscpy( m_pwszResultChar, pwszResult );
    */
}

void CKey::setRender( BOOL fValue )
{
	m_fRender = fValue;
}

BOOL CKey::getRender( void )
{
	return m_fRender;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\HDOptions.h ===
/*****************************************************
*** hdoptions.h
***
*** Header file for our Hard Drive Options menu
*** class. This menu class will allow you to perform
*** various operations on the Xbox Hard Drive.
***
*** by James N. Helm
*** April 2nd, 2001
***
*****************************************************/

#ifndef _HDOPTIONS_H_
#define _HDOPTIONS_H_

#include "menuscreen.h"  // Base menu type
#include "harddrive.h"
#include "memconfigs.h"

class CHDOptions : public CMenuScreen
{
public:
    CHDOptions( CXItem* pParent );
    ~CHDOptions();

    // Must be overridden for this to be a Item on our XShell program
    // void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods
    HRESULT Init( IDirect3DDevice8* pD3DDevice, char* menuFileName );       // Initialize our font and settings

private:
    BOOL         m_bActionInitiated;            // Used to track when a user is entering data from a virtual keyboard
    WCHAR*       m_pwszValueBuffer;             // Buffer to hold info from our Keypad / Keyboard functions

    DWORD        m_dwNumTitles;                 // Used to store the number of Titles the user wishes to create
    DWORD        m_dwNumSavedGames;             // Used to store the number of Saved Games the user wishes to create
    WCHAR*       m_pwszSavedGameName;           // Used to store our Saved Game Name
    DWORD        m_dwSavedGameSize;             // Used to store the desired size of the Saved Game
    DWORD        m_dwFileSize;                  // Used to create saved game data of a specific size
    HANDLE       m_hThreadHandle;               // Handle to our thread

    // Private Methods
    // void Leave( CXItem* pItem );                // This should be called whenever a user leaves this menu

    static friend DWORD WINAPI DataCreateThreadFunc( LPVOID lpParameter );
};

#endif // _HDOPTIONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\key.h ===
#ifndef _KEY_H
#define _KEY_H

class CKey
{
public:
	int m_iXOrigin, m_iYOrigin;		// x,y coordinate of the key's upper left pixel
	int m_iWidth, m_iHeight;		// width and height of the key
	DWORD m_dwSelectColor;			// color to hilight the key with upon selection
	WCHAR* m_pwszResultChar;        // value attached to the key
	BOOL m_fRender;				    // should the key be rendered?

	// Constructors and Destructors
	CKey();
	~CKey();

	void define( int iX, int iY, int iW, int iH, DWORD dwColor );
	void defineText( WCHAR* pwszResult );
	void setRender( BOOL fValue );
	BOOL getRender( void );
};

#endif // _KEY_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\gametitles.h ===
/*****************************************************
*** gametitles.h
***
*** Header file for our game title classes.  These
*** classes will enumerate and store information
*** about all of the Game Titles, and their Saved
*** games on the Xbox
***
*** by James N. Helm
*** June 16th, 2001
***
*****************************************************/

#ifndef _GAMETITLES_H_
#define _GAMETITLES_H_

class CMemoryArea;

class CSavedGame
{
public:
    // Constructors and Destructor
    CSavedGame();
    ~CSavedGame();

    // Public Methods
    HRESULT Init( XGAME_FIND_DATA* gameData );  // Initialize the Saved Game object and populate it's data
    WCHAR* GetName();                           // Get a pointer to the name of the saved game
    char* GetDirectory();                       // Get a pointer to the Saved Game directory
    DWORD GetBlockSize();                       // Returns the Block size of the Saved Game
    char* GetGameID();                          // Get a pointer to the Game ID of the Saved Game

    // Public Properties

private:
    // Private Methods

    // Private Properties
    WCHAR* m_pwszName;          // The name of the Saved Game
    DWORD m_dwBlockSize;        // The size of the Saved Game in Blocks
    char* m_pszGameID;          // The Game ID of the Saved Game
    char* m_pszGameDirectory;   // The directory of the Saved Game
    SYSTEMTIME m_GameDate;      // The Date/Time information of the Saved Game
};


class CGameTitle
{
public:
    // Constructors and Destructor
    CGameTitle();
    ~CGameTitle();

    // Public Methods
    HRESULT Init( char* pszDirectory,                       // Initialize our Game Title
                  CMemoryArea* pMemoryArea );
    DWORD GetNumSavedGames();                               // Returns the number of saved games for the game title
    DWORD GetBlockSize();                                   // Get the total block size of the Game Title
    WCHAR* GetName();                                       // Get a pointer to the name of the Game Title
    char* GetDirectory();                                   // Get a pointer to the directory of the Game Title
    char* GetTitleID();                                     // Get a pointer to the title ID of the Game Title
    WCHAR* GetSavedGameName( unsigned int uiIndex );        // Get the name of a Saved Game
    char* GetSavedGameID( unsigned int uiIndex );           // Get the ID of a Saved Game
    DWORD GetSavedGameBlockSize( unsigned int uiIndex );    // Get the block size of a Saved Game

    // Public Properties

private:
    // Private Methods
    HRESULT ProcessSavedGames( char* pszTitleID,            // Process the Saved Games for the specified Game Title
                               CMemoryArea* pMemoryArea );
    
    // Private Properties
    CLinkedList< CSavedGame* >  m_SavedGameList;    // List of pointers to Saved Games
    WCHAR* m_pwszName;                              // Name of the Game Title
    DWORD m_dwBlockSize;                            // Block size of the Game Title
    char* m_pszTitleID;                             // Game Title ID
    char* m_pszDirectory;                           // Directory for our Game Title
};

#define GAME_TITLE_XBX_FILENAME     "titlemeta.xbx"
#define GAME_TITLE_MAX_NAME         40
#define GAME_TITLE_NAME_TOKEN_W     L"TitleName="

class CXboxGames
{
public:
    // Constructors and Destructor
    CXboxGames();
    ~CXboxGames();

    // Public Methods
    HRESULT Init( char* pszDirectory,               // Initialize the list starting at the specified directory
                  CMemoryArea* pMemoryArea );
    CGameTitle* GetGame( unsigned int uiIndex );    // Get a pointer to a game at the specified index
    DWORD GetNumGames();                            // Get the number of Games on the Xbox
    // Public Properties

private:
    // Private Methods
    
    // Private Properties
    CLinkedList< CGameTitle* >  m_GameList;     // List of pointers to GameTitles
};

#endif // _GAMETITLES_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\gametitles.cpp ===
/*****************************************************
*** gametitles.cpp
***
*** CPP file for our game title classes.  These
*** classes will enumerate and store information
*** about all of the Game Titles, and their Saved
*** games on the Xbox
***
*** by James N. Helm
*** June 16th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "gametitles.h"

extern CHardDrive   g_HardDrive;    // Xbox Hard Drive

////////////////
////////////////
// Saved Game //
////////////////
////////////////

// Constructor
CSavedGame::CSavedGame()
: m_pwszName( NULL ),
m_dwBlockSize( 0 ),
m_pszGameID( NULL ),
m_pszGameDirectory( NULL )
{
    ZeroMemory( &m_GameDate, sizeof( m_GameDate ) );
}

// Destructor
CSavedGame::~CSavedGame()
{
    if( NULL != m_pwszName )
    {
        delete[] m_pwszName;
        m_pwszName = NULL;
    }

    if( NULL != m_pszGameID )
    {
        delete[] m_pszGameID;
        m_pszGameID = NULL;
    }

    if( NULL != m_pszGameDirectory )
    {
        delete[] m_pszGameDirectory;
        m_pszGameDirectory = NULL;
    }
}


// Initialize the Saved Game object and populate it's data
HRESULT CSavedGame::Init( XGAME_FIND_DATA* pGameData )
{
    if( NULL == pGameData )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CSavedGame::Init():Invalid parameter passed in!!" );

        return E_INVALIDARG;
    }

    //
    // Store the base Game Information
    //

    //
    // Handle the Saved Game name
    //
    if( NULL != m_pwszName )
    {
        delete[] m_pwszName;
        m_pwszName = NULL;
    }

    m_pwszName = new WCHAR[wcslen(pGameData->szSaveGameName)+1];
    if( NULL == m_pwszName )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CSavedGame::Init():Failed to allocate memory!!" );

        return E_OUTOFMEMORY;
    }
    
    wcscpy( m_pwszName, pGameData->szSaveGameName );

    //
    // Handle the Saved Game Directory
    //
    if( NULL != m_pszGameDirectory )
    {
        delete[] m_pszGameDirectory;
        m_pszGameDirectory = NULL;
    }

    m_pszGameDirectory = new char[strlen(pGameData->szSaveGameDirectory)+1];
    if( NULL == m_pszGameDirectory )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CSavedGame::Init():Failed to allocate memory!!" );

        return E_OUTOFMEMORY;
    }

    strcpy( m_pszGameDirectory, pGameData->szSaveGameDirectory );

    //
    // Handle the Date/Time information
    //
    HRESULT hr = S_OK;
    if( !FileTimeToSystemTime( &pGameData->wfd.ftLastWriteTime, &m_GameDate ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CSavedGame::Init():Failed to convert FileTimeToSystemTime!! Error - '0x%.8X (%d)'", GetLastError(), GetLastError() );

        hr = E_FAIL;
    }

    // Get the Game ID by parsing the Game Directory
    if( NULL != m_pszGameID )
    {
        delete[] m_pszGameID;
        m_pszGameID = NULL;
    }

    char* pszIDPointer = strrchr( m_pszGameDirectory, '\\' );
    if( NULL == pszIDPointer )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CSavedGame::Init():Failed to Get the Title ID!!" );

        return E_FAIL;
    }

    pszIDPointer++;
    m_pszGameID = new char[strlen( pszIDPointer )+1];
    if( NULL == m_pszGameID )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CSavedGame::Init():Failed to Allocate memory!!" );

        return E_OUTOFMEMORY;
    }

    strcpy( m_pszGameID, pszIDPointer );

    // TODO: Get the Game Block Size by navigating the directory and totaling the size of all files

    return hr;
}


// Get a pointer to the name of the saved game
WCHAR* CSavedGame::GetName()
{
    if( NULL == m_pwszName )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CSavedGame::GetName():Returning a NULL pointer!!" );
    }

    return m_pwszName;
}


// Get a pointer to the Saved Game directory
char* CSavedGame::GetDirectory()
{
    if( NULL == m_pszGameDirectory )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CSavedGame::GetDirectory():Returning a NULL pointer!!" );
    }

    return m_pszGameDirectory;
}


// Returns the Block size of the Saved Game
DWORD CSavedGame::GetBlockSize()
{
    return m_dwBlockSize;
}


// Get a pointer to the Game ID of the Saved Game
char* CSavedGame::GetGameID()
{
    if( NULL == m_pszGameID )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CSavedGame::GetGameID():Returning a NULL pointer!!" );
    }

    return m_pszGameID;
}


////////////////
////////////////
// Game Title //
////////////////
////////////////

// Constructor
CGameTitle::CGameTitle()
: m_pwszName( NULL ),
m_dwBlockSize( 0 ),
m_pszTitleID( NULL ),
m_pszDirectory( NULL )
{
    // Make sure if we empty our list we clean up properly
    m_SavedGameList.SetDeleteDataItem( TRUE );
}


// Destructor
CGameTitle::~CGameTitle()
{
    if( NULL != m_pszTitleID )
    {
        delete[] m_pszTitleID;
        m_pszTitleID = NULL;
    }

    if( NULL != m_pszDirectory )
    {
        delete[] m_pszDirectory;
        m_pszDirectory = NULL;
    }

    if( NULL != m_pwszName )
    {
        delete[] m_pwszName;
        m_pwszName = NULL;
    }
}


// Initialize our Game Title
HRESULT CGameTitle::Init( char* pszDirectory, CMemoryArea* pMemoryArea )
{
    if( NULL == pszDirectory )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CGameTitle::Init():Invalid argument passed in!!" );

        return E_INVALIDARG;
    }

    //
    // Handle the directory
    //
    if( NULL != m_pszDirectory )
    {
        delete[] m_pszDirectory;
        m_pszDirectory = NULL;
    }

    m_pszDirectory = new char[strlen( pszDirectory )+1];
    if( NULL == m_pszDirectory )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CGameTitle::Init():Failed to allocate memory!!" );

        return E_OUTOFMEMORY;
    }

    strcpy( m_pszDirectory, pszDirectory );

    //
    // Handle the Title ID
    //
    if( NULL != m_pszTitleID )
    {
        delete[] m_pszTitleID;
        m_pszTitleID = NULL;
    }

    char* pszIDPointer = strrchr( m_pszDirectory, '\\' );
    if( NULL == pszIDPointer )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CGameTitle::Init():Failed to Get the Title ID!!" );

        return E_FAIL;
    }

    pszIDPointer++;
    m_pszTitleID = new char[strlen( pszIDPointer )+1];
    if( NULL == m_pszTitleID )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CGameTitle::Init():Failed to Allocate memory!!" );

        return E_OUTOFMEMORY;
    }

    strcpy( m_pszTitleID, pszIDPointer );

    //
    // Handle the Saved Games
    //
    HRESULT hr = ProcessSavedGames( m_pszTitleID, pMemoryArea );
    if( FAILED( hr ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CGameTitle::Init():Failed to ProcessSavedGames!! Error - '0x%.8X (%d)'", hr, hr );
    }

    // Get the Game Name
    if( NULL != m_pwszName )
    {
        delete[] m_pwszName;
        m_pwszName = NULL;
    }

    char pszFileName[MAX_PATH+1];
    ZeroMemory( pszFileName, MAX_PATH+1 );

    _snprintf( pszFileName, MAX_PATH, "%s\\%s", m_pszDirectory, GAME_TITLE_XBX_FILENAME );

    FILE* pfTitleMeta = fopen( pszFileName, "rb" );
    if( NULL == pfTitleMeta )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CGameTitle::Init():Failed to open the Game Name file!! File - '%hs', Error - '0x%.8X (%d)'", pszFileName, GetLastError(), GetLastError() );

        return E_FAIL;
    }

    WCHAR pwszBuffer[MAX_PATH+1];
    ZeroMemory( pwszBuffer, sizeof( WCHAR ) * ( MAX_PATH+1 ) );
    
    while( fgetws( pwszBuffer, MAX_PATH, pfTitleMeta ) )
    {
        WCHAR* pwszStringLoc = wcsstr( pwszBuffer, GAME_TITLE_NAME_TOKEN_W );
        if( NULL != pwszStringLoc )
        {
            // Adjust our pointer to skip the token
            pwszStringLoc = pwszStringLoc + wcslen( GAME_TITLE_NAME_TOKEN_W );

            // Allocate memory for our buffer
            m_pwszName = new WCHAR[wcslen( pwszStringLoc ) - 1];    // We don't need to allocate space for the null, since this string has a CR at the end, we'll use that
            if( NULL == m_pwszName )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CGameTitle::Init():Failed to Allocate memory!!" );

                hr = E_FAIL;
                
                break;
            }
            else
            {
                m_pwszName[wcslen( pwszStringLoc ) - 2] = L'\0';
                wcsncpy( m_pwszName, pwszStringLoc, wcslen( pwszStringLoc ) - 2 );

                break;
            }
        }
    }

    XDBGWRN( APP_TITLE_NAME_A, "CGameTitle::Init():Game Name - '%ls'", m_pwszName );

    fclose( pfTitleMeta );
    pfTitleMeta = NULL;

    // TODO: Get the Game Block Size

    return hr;
}


// Returns the number of saved games for the game title
DWORD CGameTitle::GetNumSavedGames()
{
    return m_SavedGameList.GetNumItems();
}


// Get the total block size of the Game Title
DWORD CGameTitle::GetBlockSize()
{
    return m_dwBlockSize;
}


// Get a pointer to the name of the Game Title
WCHAR* CGameTitle::GetName()
{
    if( NULL == m_pwszName )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CGameTitle::GetName():Returning a NULL pointer!!" );
    }

    return m_pwszName;
}


// Get a pointer to the directory of the Game Title
char* CGameTitle::GetDirectory()
{
    if( NULL == m_pszDirectory )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CGameTitle::GetDirectory():Returning a NULL pointer!!" );
    }

    return m_pszDirectory;
}


// Get a pointer to the title ID of the Game Title
char* CGameTitle::GetTitleID()
{
    if( NULL == m_pszTitleID )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CGameTitle::GetTitleID():Returning a NULL pointer!!" );
    }

    return m_pszTitleID;
}


// Get the name of a Saved Game
WCHAR* CGameTitle::GetSavedGameName( unsigned int uiIndex )
{
    if( uiIndex >= m_SavedGameList.GetNumItems() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CGameTitle::GetSavedGameName():Invalid Index passed in! Arg - '%u', MAX - '%u'", uiIndex, m_SavedGameList.GetNumItems() - 1 );

        return NULL;
    }

    return m_SavedGameList.GetNode( uiIndex )->GetName();
}


// Get the ID of a Saved Game
char* CGameTitle::GetSavedGameID( unsigned int uiIndex )
{
    if( uiIndex >= m_SavedGameList.GetNumItems() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CGameTitle::GetSavedGameID():Invalid Index passed in! Arg - '%u', MAX - '%u'", uiIndex, m_SavedGameList.GetNumItems() - 1 );

        return NULL;
    }

    return m_SavedGameList.GetNode( uiIndex )->GetGameID();
}


// Get the block size of a Saved Game
DWORD CGameTitle::GetSavedGameBlockSize( unsigned int uiIndex )
{
    if( uiIndex >= m_SavedGameList.GetNumItems() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CGameTitle::GetSavedGameBlockSize():Invalid Index passed in! Arg - '%u', MAX - '%u'", uiIndex, m_SavedGameList.GetNumItems() - 1 );

        return NULL;
    }

    return m_SavedGameList.GetNode( uiIndex )->GetBlockSize();
}


// Process the Saved Games for the specified Game Title
HRESULT CGameTitle::ProcessSavedGames( char* pszTitleID, CMemoryArea* pMemoryArea )
{
    if( NULL == pszTitleID )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CGameTitle::ProcessSavedGames():Invalid Argument Passed In!!" );

        return E_INVALIDARG;
    }

    m_SavedGameList.EmptyList();

    // Map the proper UData Drive
    pMemoryArea->MapUDataToTitleID( pszTitleID );

    char pszGameDrive[4];
    pszGameDrive[3] = '\0';

    sprintf( pszGameDrive, "%c:\\", pMemoryArea->GetUDataDrive() );

    // Use FindFirst / Next Saved Game to fill our Saved Game Data
    XGAME_FIND_DATA gameFindData;
    ZeroMemory( &gameFindData, sizeof( gameFindData ) );

    HANDLE hGame = XFindFirstSaveGame( pszGameDrive,
                                       &gameFindData );
    if( INVALID_HANDLE_VALUE == hGame )
    {
        if( ERROR_FILE_NOT_FOUND == GetLastError() )
        {
            // There are no Saved Games, so this is OK
            return S_OK;
        }

        XDBGWRN( APP_TITLE_NAME_A, "CGameTitle::ProcessSavedGames():Failed to find a Saved Game!! Error - '0x%.8X (%d)'", GetLastError(), GetLastError() );

        return E_FAIL;
    }

    do
    {
        CSavedGame* pSavedGame = new CSavedGame;
        if( NULL == pSavedGame )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CGameTitle::ProcessSavedGames():Failed to allocate memory!!" );

            // Try the next one, but it will fail as well
            continue;
        }

        pSavedGame->Init( &gameFindData );

        m_SavedGameList.AddNode( pSavedGame );
    } while( XFindNextSaveGame( hGame, &gameFindData ) );

    XFindClose( hGame );

    // Remap the U Drive to the proper location
    pMemoryArea->MapUDataToOrigLoc();

    return S_OK;
}


////////////////
////////////////
// Xbox Games //
////////////////
////////////////

// Constructors
CXboxGames::CXboxGames()
{
    // Make sure we clean up after ourselves
    m_GameList.SetDeleteDataItem( TRUE );
}


// Destructor
CXboxGames::~CXboxGames()
{
}


// Initialize the list starting at the specified directory
HRESULT CXboxGames::Init( char* pszDirectory, CMemoryArea* pMemoryArea )
{
    if( NULL == pszDirectory )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXboxGames::Init():Invalid arg passed in!!" );

        return E_INVALIDARG;
    }

    // Make sure our Game list is empty
    m_GameList.EmptyList();

	char pszBuf[MAX_PATH+1];
    ZeroMemory( pszBuf, MAX_PATH+1 );

    // BUGBUG: What if there is a trailing slash?
    _snprintf( pszBuf, MAX_PATH, "%hs\\*.*", pszDirectory );

    char* apszDirectories[4096];
    for( unsigned int x = 0; x < 4096; x++ )
    {
        apszDirectories[x] = NULL;
    }

    unsigned int uiNumDirs = 0;
    WIN32_FIND_DATA wfd;
    ZeroMemory( &wfd, sizeof( wfd ) );

    HANDLE hFile = FindFirstFile( pszBuf, &wfd );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXboxGames::Init():Failed to find first file!! Pattern - '%hs', Error - '0x%.8X (%d)'", pszBuf, GetLastError(), GetLastError() );

        // BUGBUG: This might not be a failure.  There could be no titles!
        return E_FAIL;
    }

    do
    {
        // Skip the . and .. directories
		if ( wfd.cFileName[0] == '.' )
        {
			continue;
        }

        ZeroMemory( pszBuf, MAX_PATH+1 );
        _snprintf( pszBuf, MAX_PATH, "%s\\%s", pszDirectory, wfd.cFileName );

        // Check to see if we are dealing with a directory
        if( wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            apszDirectories[uiNumDirs] = new char[strlen( pszBuf ) + 1];
            if( NULL == apszDirectories[uiNumDirs] )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CXboxGames::Init():Failed to allocate memory!!" );

                continue;
            }

            strcpy( apszDirectories[uiNumDirs], pszBuf );

            uiNumDirs++;
        }
    } while( FindNextFile( hFile, &wfd ) );

    FindClose( hFile );

    // Process the directories we found
    for( unsigned int x = 0; x < uiNumDirs; x++ )
    {
        // Create a Game Title Object
        CGameTitle* pGameTitle = new CGameTitle;
        if( NULL == pGameTitle )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CXboxGames::Init():Failed to allocate memory!!" );

            // We'll try, but the next one will fail too
            continue;
        }
        XDBGWRN( APP_TITLE_NAME_A, "CXboxGames::Init():apszDirectories[x] - '%hs'", apszDirectories[x] );
        pGameTitle->Init( apszDirectories[x], pMemoryArea );

        m_GameList.AddNode( pGameTitle );

        // Clean up any memory we allocated
        delete[] apszDirectories[x];
        apszDirectories[x] = NULL;
    }

    return S_OK;
}


// Get a pointer to a game at the specified index
CGameTitle* CXboxGames::GetGame( unsigned int uiIndex )
{
    if( uiIndex >= m_GameList.GetNumItems() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXboxGames::GetGame():Invalid Index passed in! Arg - '%u', MAX - '%u'", uiIndex, m_GameList.GetNumItems() - 1 );

        return NULL;
    }

    return m_GameList.GetNode( uiIndex );
}


// Returns the number of Games on the Xbox
DWORD CXboxGames::GetNumGames()
{
    return m_GameList.GetNumItems();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\HDOptions.cpp ===
/*****************************************************
*** hdoptions.cpp
***
*** CPP file for our Hard Drive Options menu class.
*** This menu class will allow you to perform various
*** operations on the Xbox Hard Drive.
***
*** by James N. Helm
*** April 2nd, 2001
***
*****************************************************/

#include "stdafx.h"
#include "hdoptions.h"

extern CKeypadMenu   g_MenuKeypad;      // Virtual Keypad Menu to be used by all screens
extern CKeyboardMenu g_MenuKeyboard;    // Virtual Keyboard Menu to be used by all screens
extern CHardDrive    g_HardDrive;       // Xbox Hard Drive

// Constructors
CHDOptions::CHDOptions( CXItem* pParent )
: CMenuScreen( pParent ),
m_bActionInitiated( FALSE ),
m_dwNumTitles( 0 ),
m_dwNumSavedGames( 0 ),
m_dwSavedGameSize( 0 ),
m_dwFileSize( 0 ),
m_hThreadHandle( NULL ),
m_pwszValueBuffer( NULL )
{
    XDBGWRN( APP_TITLE_NAME_A, "CHDOptions::CHDOptions()" );

    m_uiNumItems = HDOPTIONSMENU_ITEM_NUM_ITEMS;
    SetSelectedItem( 0 );

    m_pwszValueBuffer = new WCHAR[MENU_HDOPTIONS_SAVEGAMENAME_SIZE];
    if( !m_pwszValueBuffer )
    {
        XDBGERR( APP_TITLE_NAME_A, "CHDOptions::CHDOptions():Failed to allocate memory!!" );
    }
    ZeroMemory( m_pwszValueBuffer, sizeof( WCHAR ) * MENU_HDOPTIONS_SAVEGAMENAME_SIZE );

    m_pwszSavedGameName = new WCHAR[MENU_HDOPTIONS_SAVEGAMENAME_SIZE];
    if( !m_pwszSavedGameName )
    {
        XDBGERR( APP_TITLE_NAME_A, "CHDOptions::CHDOptions():Failed to allocate memory!!" );
    }
    ZeroMemory( m_pwszSavedGameName, sizeof( WCHAR ) * MENU_HDOPTIONS_SAVEGAMENAME_SIZE );
}


// Destructor
CHDOptions::~CHDOptions()
{
    if( m_pwszValueBuffer )
    {
        delete[] m_pwszValueBuffer;
        m_pwszValueBuffer = NULL;
    }

    if( m_pwszSavedGameName )
    {
        delete[] m_pwszSavedGameName;
        m_pwszSavedGameName = NULL;
    }
}


// Draws a menu on to the screen
void CHDOptions::Action( CUDTexture* pTexture )
{
    // Check to see if we should update the texture
    // If not, return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else // reset the texture flag to FALSE
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

    DWORD dwItemColor = 0;
    // Draw a selector around the current item
    float X1Pos = MENUBOX_SELECTOR_X1;
    float Y1Pos = MENUBOX_MAINAREA_Y1 + MENUBOX_MAINAREA_BORDERWIDTH_TOP + ( ( MENUBOX_ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * GetSelectedItem() ) - MENUBOX_SELECTOR_BORDER_WIDTH;
    float X2Pos = MENUBOX_SELECTOR_X2;
    float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * MENUBOX_SELECTOR_BORDER_WIDTH );

    pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, SCREEN_DEFAULT_SELECTOR_COLOR );

    // Display the space information about the Hard Drive
    pTexture->DrawText( (float)MENUBOX_WINDOW_TITLE_X1 + GetStringPixelWidth( L"HD Options " ), MENUBOX_WINDOW_TITLE_Y1, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"(%d/%d)", g_HardDrive.GetFreeBlocks(), g_HardDrive.GetTotalBlocks() );

    // Draw the Menu Options
    for( unsigned int x = 0; x < HDOPTIONSMENU_ITEM_NUM_ITEMS; ++x )
    {
        float XPos = MENUBOX_MAINAREA_X1 + MENUBOX_MAINAREA_BORDERWIDTH_LEFT;
        float YPos = MENUBOX_MAINAREA_Y1 + MENUBOX_MAINAREA_BORDERWIDTH_TOP + ( ( MENUBOX_ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * x );

        pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", g_wpszHDOptionsMenuItems[x] );
    }

    // Draw our processing message if necessary
    if( m_hThreadHandle )
    {
#define TEXT_BOX_BUFFER_SIZE    20

        pTexture->DrawBox( MENUBOX_MAINAREA_X1 + TEXT_BOX_BUFFER_SIZE, MENUBOX_MAINAREA_Y1 + TEXT_BOX_BUFFER_SIZE, MENUBOX_MAINAREA_X2 - TEXT_BOX_BUFFER_SIZE, MENUBOX_MAINAREA_Y2 - TEXT_BOX_BUFFER_SIZE, COLOR_BLACK );
        pTexture->DrawOutline( MENUBOX_MAINAREA_X1 + TEXT_BOX_BUFFER_SIZE, MENUBOX_MAINAREA_Y1 + TEXT_BOX_BUFFER_SIZE, MENUBOX_MAINAREA_X2 - TEXT_BOX_BUFFER_SIZE, MENUBOX_MAINAREA_Y2 - TEXT_BOX_BUFFER_SIZE, 2, COLOR_DARK_GREEN );
        pTexture->DrawText( SCREEN_X_CENTER - ( GetStringPixelWidth( L"Processing..." ) / 2 ), SCREEN_Y_CENTER, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"Processing..." );

        // Check to see if the thread is done
        DWORD dwExitCode = 0;
        GetExitCodeThread( m_hThreadHandle, &dwExitCode );

        if( STILL_ACTIVE != dwExitCode )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CHDOptions::Action():Thread Exit Code - '%d'", dwExitCode );

            // Our thread has stopped, close it, and reset the handle
            CloseHandle( m_hThreadHandle );
            m_hThreadHandle = NULL;
        }

        m_bUpdateTexture = TRUE;

        // Start our thread on it's merry way
        ResumeThread( m_hThreadHandle );
    }

    // Unlock our texture and restore our render target
    pTexture->Unlock();

    // Take Action if necessary
    if( m_bActionInitiated )
    {
        m_bActionInitiated = FALSE;

        switch( GetSelectedItem() )
        {
        case HDOPTIONSMENU_ITEM_UDATA_CREATE_TITLES:
            {
                // Check to see if the user set a value
                if( '\0' == m_pwszValueBuffer[0] )
                {
                    break;
                }
                
                WCHAR* pwszStopString = NULL;
                char pszGameTitle[9];
                ZeroMemory( pszGameTitle, 9 );

                // Convert the user value to a DWORD
                m_dwNumTitles = wcstol( m_pwszValueBuffer, &pwszStopString, 10 );
                m_dwNumSavedGames = 0;

                m_hThreadHandle = CreateThread( NULL,
                                                0,
                                                DataCreateThreadFunc,
                                                (LPVOID)this,
                                                CREATE_SUSPENDED,
                                                NULL );

                m_bUpdateTexture = TRUE;

                break;
            }
        case HDOPTIONSMENU_ITEM_UDATA_CREATE_TITLES_AND_SGAMES:
            {
                // Check to see if the user set a value
                if( '\0' == m_pwszValueBuffer[0] )
                {
                    // Set this to 0 (Important!!) so that other actions know when to execute
                    m_dwNumTitles = 0;

                    break;
                }

                WCHAR* pwszStopString = NULL;

                // Check to see if we are in the middle of this action
                // If not, store the number of titles.  If so, store the number of
                // Saved Games
                if( 0 == m_dwNumTitles )
                //
                // Store the number of Game Titles to create
                //
                {
                    // Store the number of titles
                    m_dwNumTitles = wcstol( m_pwszValueBuffer, &pwszStopString, 10 );

                    // Mark that we are still in the middle of a transaction
                    m_bActionInitiated = TRUE;
                    m_bUpdateTexture = TRUE;

                    // Prompt the user for the number of Saved Games
                    g_MenuKeypad.SetInfo( L"Enter # of Saved Games", m_pwszValueBuffer, MENU_HDOPTIONS_NUMBER_SIZE );
                    g_MenuKeypad.SetParent( this );

                    Leave( &g_MenuKeypad );
                }
                else
                //
                // Store the number of saved games to create
                //
                {
                    m_dwNumSavedGames = wcstol( m_pwszValueBuffer, &pwszStopString, 10 );

                    // Create the data
                    m_hThreadHandle = CreateThread( NULL,
                                                    0,
                                                    DataCreateThreadFunc,
                                                    (LPVOID)this,
                                                    CREATE_SUSPENDED,
                                                    NULL );

                    m_bUpdateTexture = TRUE;
                }
                break;
            }
        case HDOPTIONSMENU_ITEM_UDATA_CREATE_SAVED_GAME:
            {
                // Check to see if the user set a value
                if( '\0' == m_pwszValueBuffer[0] )
                {
                    m_dwSavedGameSize = 0;
                    m_pwszSavedGameName[0] = 0;

                    break;
                }

                if( 0 == m_pwszSavedGameName[0] )
                {
                    // Store the value the user set
                    wcscpy( m_pwszSavedGameName, m_pwszValueBuffer );

                    // Mark that we are still in the middle of a transaction
                    m_bActionInitiated = TRUE;
                    m_bUpdateTexture = TRUE;

                    // Prompt the user for the Size of the Saved Game
                    g_MenuKeypad.SetInfo( L"Enter size of the Saved Game Fill File", m_pwszValueBuffer, MENU_HDOPTIONS_NUMBER_SIZE );
                    g_MenuKeypad.SetParent( this );

                    Leave( &g_MenuKeypad );
                }
                else
                {
                    WCHAR* pwszStopString = NULL;

                    // Convert the Game Size in to a useable number and launch our thread
                    m_dwSavedGameSize = wcstol( m_pwszValueBuffer, &pwszStopString, 10 );

                    // Create the data
                    m_hThreadHandle = CreateThread( NULL,
                                                    0,
                                                    DataCreateThreadFunc,
                                                    (LPVOID)this,
                                                    CREATE_SUSPENDED,
                                                    NULL );

                    m_bUpdateTexture = TRUE;
                }

                break;
            }
        case HDOPTIONSMENU_ITEM_CREATE_FILE:
            {
                // Check to see if the user set a value
                if( '\0' == m_pwszValueBuffer[0] )
                {
                    break;
                }

                WCHAR* pwszStopString = NULL;

                m_dwFileSize = wcstol( m_pwszValueBuffer, &pwszStopString, 10 );

                // Create the data
                m_hThreadHandle = CreateThread( NULL,
                                                0,
                                                DataCreateThreadFunc,
                                                (LPVOID)this,
                                                CREATE_SUSPENDED,
                                                NULL );

                m_bUpdateTexture = TRUE;

                break;
            }
        case HDOPTIONSMENU_ITEM_TDATA_ERASE:
        case HDOPTIONSMENU_ITEM_UDATA_ERASE:
        case HDOPTIONSMENU_ITEM_CONFIG_METAVARS:
        case HDOPTIONSMENU_ITEM_CONFIG_SORTORDER:
            {
                // Perform the action
                m_hThreadHandle = CreateThread( NULL,
                                                0,
                                                DataCreateThreadFunc,
                                                (LPVOID)this,
                                                CREATE_SUSPENDED,
                                                NULL );

                m_bUpdateTexture = TRUE;
                
                break;
            }

		case HDOPTIONSMENU_ITEM_CONFIG_SORTORDER_JAP:
			{
                // Perform the action
                m_hThreadHandle = CreateThread( NULL,
                                                0,
                                                DataCreateThreadFunc,
                                                (LPVOID)this,
                                                CREATE_SUSPENDED,
                                                NULL );

                m_bUpdateTexture = TRUE;
                
                break;
            }
        }
    }
}


// Handle any requests for the joystick (thumb-pad)
void CHDOptions::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CHDOptions::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // Make sure the system is not working
    if( m_hThreadHandle )
    {
        return;
    }

    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = INPUT_KEYPRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = INPUT_KEYPRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            if( GetSelectedItem() > 0 )
            {
                m_bUpdateTexture = TRUE;

                SetSelectedItem( GetSelectedItem() - 1 );
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            if( GetSelectedItem() < ( HDOPTIONSMENU_ITEM_NUM_ITEMS - 1 ) )
            {
                m_bUpdateTexture = TRUE;

                SetSelectedItem( GetSelectedItem() + 1 );
            }
            break;
        }
    }
}


// Handles input (of the BUTTONS) for the current menu
void CHDOptions::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( ( !bFirstPress ) || m_hThreadHandle )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Refresh our Texture
            m_bUpdateTexture = TRUE;

            switch( GetSelectedItem() )
            {
            case HDOPTIONSMENU_ITEM_UDATA_CREATE_TITLES:
                {
                    // Prompt the user for the number of Game Titles
                    g_MenuKeypad.SetInfo( L"Enter # of Game Titles", m_pwszValueBuffer, MENU_HDOPTIONS_NUMBER_SIZE );
                    g_MenuKeypad.SetParent( this );
                    m_bActionInitiated = TRUE;

                    Leave( &g_MenuKeypad );

                    break;
                }
            case HDOPTIONSMENU_ITEM_UDATA_CREATE_TITLES_AND_SGAMES:
                {
                    // Prompt the user for the number of Game Titles
                    g_MenuKeypad.SetInfo( L"Enter # of Game Titles", m_pwszValueBuffer, MENU_HDOPTIONS_NUMBER_SIZE );
                    g_MenuKeypad.SetParent( this );
                    m_bActionInitiated = TRUE;

                    Leave( &g_MenuKeypad );
                    break;
                }
            case HDOPTIONSMENU_ITEM_UDATA_CREATE_SAVED_GAME:
                {
                    g_MenuKeyboard.SetInfo( L"Enter the name of the Saved Game:", m_pwszValueBuffer, MENU_HDOPTIONS_SAVEGAMENAME_SIZE );
                    g_MenuKeyboard.SetParent( this );
                    m_bActionInitiated = TRUE;

                    Leave( &g_MenuKeyboard );
                    break;
                }
            case HDOPTIONSMENU_ITEM_CREATE_FILE:
                {
                    // Prompt the user for the size of the file
                    WCHAR pwszHDInfo[100];
                    ZeroMemory( pwszHDInfo, sizeof( WCHAR) * 100 );

                    swprintf( pwszHDInfo, L"(%d) blocks free; Enter Size of File (in blocks):", g_HardDrive.GetFreeBlocks() );

                    g_MenuKeypad.SetInfo( pwszHDInfo, m_pwszValueBuffer, MENU_HDOPTIONS_NUMBER_SIZE );
                    g_MenuKeypad.SetParent( this );
                    m_bActionInitiated = TRUE;

                    Leave( &g_MenuKeypad );
                    break;
                }
            case HDOPTIONSMENU_ITEM_TDATA_ERASE:
            case HDOPTIONSMENU_ITEM_UDATA_ERASE:
            case HDOPTIONSMENU_ITEM_CONFIG_METAVARS:
            case HDOPTIONSMENU_ITEM_CONFIG_SORTORDER:
                {
                    m_bActionInitiated = TRUE;

                    break;
                }
			case HDOPTIONSMENU_ITEM_CONFIG_SORTORDER_JAP:
                {
                    m_bActionInitiated = TRUE;

                    break;
                }
            }

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                Leave( GetParent() );
            }
            break;
        }
    case BUTTON_X:
        {
            break;
        }
    case BUTTON_Y:
        {
            break;
        }
    case BUTTON_BLACK:
        {
            break;
        }
    case BUTTON_WHITE:
        {
            break;
        }
    }
}


// Initialize the Menu
HRESULT CHDOptions::Init( IDirect3DDevice8* pD3DDevice, char* menuFileName )
{
    XDBGWRN( APP_TITLE_NAME_A, "CHDOptions::Init()" );

    CMenuScreen::Init( pD3DDevice, menuFileName );

    return S_OK;
}


DWORD WINAPI DataCreateThreadFunc( LPVOID lpParameter )
{
    CHDOptions* pHDOptions = (CHDOptions*)lpParameter;
    switch( pHDOptions->GetSelectedItem() )
    {
    case HDOPTIONSMENU_ITEM_UDATA_CREATE_TITLES:
    case HDOPTIONSMENU_ITEM_UDATA_CREATE_TITLES_AND_SGAMES:
        {
            // Create the Game Titles
            DWORD dwNumTries = 0;
            DWORD dwXModifier = 0;
            for( DWORD x = 0; x < pHDOptions->m_dwNumTitles; x++ )
            {
                char pszTitleID[9];
                pszTitleID[8] = '\0';
                sprintf( pszTitleID, "%0.8X", x + dwXModifier );

                while( FAILED( g_HardDrive.CreateGameTitle( g_HardDrive.GetUDataDrive(), pszTitleID ) ) )
                {
                    ++dwXModifier;
                    sprintf( pszTitleID, "%0.8X", x + dwXModifier );

                    if( ( ERROR_DISK_FULL == GetLastError() ) || ( dwNumTries++ == 100 ) )
                    {
                        break;
                    }
                }

                // Map the UData Partition to the proper directory
                if( FAILED ( g_HardDrive.MapUDataToTitleID( x + dwXModifier ) ) )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "CHDOptions::DataCreateThreadFunc():Failed to mount the title ID!!" );
                }
                else
                {
                    // Create the Saved Games
                    WCHAR pwszSavedGameName[50];
                    for( DWORD y = 0; y < pHDOptions->m_dwNumSavedGames; y++ )
                    {
                        _snwprintf( pwszSavedGameName, 49, L"Saved Game #%02d%c", y, L'\0' );

                        SYSTEMTIME sysTime;
                        ZeroMemory( &sysTime, sizeof( sysTime ) );

                        sysTime.wMonth = ( rand() % 12 ) + 1;
                        sysTime.wDay = ( rand() % 28 ) + 1;
                        sysTime.wYear = ( rand() % 99 ) + 2001;
                        sysTime.wHour = rand() % 24;
                        sysTime.wMinute = rand() % 60;
                        sysTime.wSecond = rand() % 60;

                        g_HardDrive.CreateSavedGame( pwszSavedGameName,
                                                     NULL,
                                                     0,
                                                     &sysTime,
                                                     "",
                                                     FALSE );
                    }
                }
            }

            // Map the UData Partition back to the original location
            g_HardDrive.MapUDataToOrigLoc();
            // g_HardDrive.MapUDataToTitleID( FILE_DATA_CONFIG_TITLEID );

            break;
        }
    case HDOPTIONSMENU_ITEM_UDATA_CREATE_SAVED_GAME:
        {
            // Create the Game Title to hold our Game
            char pszTitleID[9];
            pszTitleID[8] = '\0';

            // Create the Game Titles
            DWORD dwNumTries = 0;
            DWORD dwXModifier = 0;
            for( DWORD x = 0x00005000; x < 0x00005001; x++ )
            {
                sprintf( pszTitleID, "%0.8X", x + dwXModifier );

                while( FAILED( g_HardDrive.CreateGameTitle( g_HardDrive.GetUDataDrive(), pszTitleID ) ) )
                {
                    ++dwXModifier;
                    sprintf( pszTitleID, "%0.8X", x + dwXModifier );

                    if( ( ERROR_DISK_FULL == GetLastError() ) || ( dwNumTries++ == 100 ) )
                    {
                        break;
                    }
                }

                // Map the UData Partition to the proper directory
                g_HardDrive.MapUDataToTitleID( x + dwXModifier );
            }

            char pszGamePath[MAX_PATH+1];
            pszGamePath[MAX_PATH] = 0;

            SYSTEMTIME sysTime;
            ZeroMemory( &sysTime, sizeof( sysTime ) );

            sysTime.wMonth = ( rand() % 12 ) + 1;
            sysTime.wDay = ( rand() % 28 ) + 1;
            sysTime.wYear = ( rand() % 99 ) + 2001;
            sysTime.wHour = rand() % 24;
            sysTime.wMinute = rand() % 60;
            sysTime.wSecond = rand() % 60;

            // Create the Saved Games
            g_HardDrive.CreateSavedGame( pHDOptions->m_pwszSavedGameName,
                                         pszGamePath,
                                         MAX_PATH,
                                         &sysTime,
                                         "",
                                         FALSE );

            // Create a file of a certain size within the Saved Game

            // If the user is settings the game to a block sized larger than possible, Max it out
            if( pHDOptions->m_dwSavedGameSize > g_HardDrive.GetFreeBlocks() )
            {
                pHDOptions->m_dwSavedGameSize = g_HardDrive.GetFreeBlocks();
            }

            strcat( pszGamePath, "\\" );

            g_HardDrive.FillArea( pszGamePath, pHDOptions->m_dwSavedGameSize );

            // Map the UData Partition back to the original location
            g_HardDrive.MapUDataToTitleID( FILE_DATA_CONFIG_TITLEID );

            break;
        }
    case HDOPTIONSMENU_ITEM_CREATE_FILE:
        {
            // Create a file of the specified size
            char pszDirectory[4];
            ZeroMemory( pszDirectory, 4 );

            sprintf( pszDirectory, "%c:\\", g_HardDrive.GetTDataDrive() );
            g_HardDrive.FillArea( pszDirectory, pHDOptions->m_dwFileSize );

            break;
        }
    case HDOPTIONSMENU_ITEM_TDATA_ERASE:
        {
            g_HardDrive.Erase( FILE_DATA_TDATA_DRIVE_LETTER_A );

            break;
        }
    case HDOPTIONSMENU_ITEM_UDATA_ERASE:
        {
            g_HardDrive.Erase();

            break;
        }
    case HDOPTIONSMENU_ITEM_CONFIG_METAVARS:
        {
            // Create the games
            CreateMetaVarGames( &g_HardDrive );

            break;
        }
    case HDOPTIONSMENU_ITEM_CONFIG_SORTORDER:
        {
            CreateSortOrderGames( &g_HardDrive, TRUE );

            break;
        }
	case HDOPTIONSMENU_ITEM_CONFIG_SORTORDER_JAP:
        {
            CreateSortOrderGames( &g_HardDrive, FALSE );

            break;
        }
    }

    // Set this to 0 (Important!!) so that other actions know when to execute
    pHDOptions->m_dwNumTitles = 0;
    pHDOptions->m_dwNumSavedGames = 0;
    pHDOptions->m_dwFileSize = 0;
    pHDOptions->m_pwszSavedGameName[0] = 0;
    pHDOptions->m_dwSavedGameSize = 0;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\keyboardmenu.h ===
/*****************************************************
*** keyboardmenu.h
***
*** Header file for our Keyboard Menu class.
*** This is a base menu type
***
*** by James N. Helm
*** December 6th, 2000
***
*****************************************************/

#ifndef _KEYBOARDMENU_H_
#define _KEYBOARDMENU_H_

#define KEYBOARD_NUM_ROWS    4
#define KEYBOARD_NUM_COLS    10

#include "menuscreen.h"  // Base menu type

class CKeyboardMenu : public CMenuScreen
{
public:
    // Constructors and Destructors
    CKeyboardMenu( CXItem* pParent );
    virtual ~CKeyboardMenu();

    // Process drawing and input for a menu screen
    virtual void Enter();   // This will be called whenever this menu is entered / activated
    virtual void Action( CUDTexture* pTexture );
    virtual void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    virtual void HandleInput( enum CONTROLS buttonPressed, BOOL bFirstPress );
    virtual void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    HRESULT SetInfo( WCHAR* pwszTextString,                 // This should be called before the Keyboard is invoked
                     WCHAR* pwszValueBuffer,
                     unsigned int uiValueSize );

protected:
    // Properties
    WCHAR*       m_pwszTextString;                                   // The string that will be displayed to the user
    WCHAR*       m_pwszValueBuffer;                                  // Will hold the information that is collected
    unsigned int m_uiValueSize;                                      // The length of the value you wish to collect
    BOOL         m_bDropKeyPress;                                    // Used to prevent the 'instant' keypress when a user navigates in here
	int          m_xKeypos;                                          // Current X position on the Keyboard
    int          m_yKeypos;                                          // Current Y position on the Keyboard
	CKey         m_keyPad[KEYBOARD_NUM_COLS][KEYBOARD_NUM_ROWS];     // Each Key displayed on the Keyboard
	
    // Private Methods
	virtual void GenerateKeypad(void);                  // Create the keypad that will be used
	virtual BOOL renderKeypad( CUDTexture* pTexture );  // Draw the keypad on to the our texture
};

#endif // _MACHINENAMEMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\keyboardmenu.cpp ===
/*****************************************************
*** keyboardmenu.cpp
***
*** CPP file for our Keyboard Menu class.
***
*** by James N. Helm
*** December 6th, 2000
***
*****************************************************/

#include "stdafx.h"
#include "keyboardmenu.h"

extern CXItem* g_pCurrentScreen;	// Pointer to the current menu object
extern USBManager g_USBDevices;		// Handles all USB Device input/output

// Constructors
CKeyboardMenu::CKeyboardMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_pwszTextString( NULL ),
m_pwszValueBuffer( NULL ),
m_uiValueSize( 0 ),
m_bDropKeyPress( TRUE )
{
	GenerateKeypad();

    // Default the focus to the OK Button
	m_xKeypos = KEYBOARD_NUM_COLS - 1;
    m_yKeypos = 0;
}


// Destructor
CKeyboardMenu::~CKeyboardMenu()
{
    if( m_pwszTextString )
    {
        delete[] m_pwszTextString;
        m_pwszTextString = NULL;
    }
}


// Draws a menu on to the screen
void CKeyboardMenu::Action( CUDTexture* pTexture )
{
    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

	// Draw our keypad
	renderKeypad( pTexture );

	// Draw our User defined Text
    pTexture->DrawText( SCREEN_X_CENTER - ( GetStringPixelWidth( m_pwszTextString ) / 2 ), KEYBOARD_TEXT_Y1, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", m_pwszTextString );

    // Draw the current value on to the screen
    pTexture->DrawText( SCREEN_X_CENTER - ( GetStringPixelWidth( m_pwszValueBuffer ) / 2 ), KEYBOARD_VALUE_Y1, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", m_pwszValueBuffer );

    // Unlock our texture
    pTexture->Unlock();
}


// Handle the Joystick Input
void CKeyboardMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_LEFT, bFirstXPress );
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
                HandleInput( CONTROL_DPAD_RIGHT, bFirstXPress );
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CKeyboardMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            for( int x = ( m_yKeypos - 1 ); x >= 0; x-- )
            {
                if( m_keyPad[m_xKeypos][x].getRender() && ( wcscmp( m_keyPad[m_xKeypos][x].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    m_bUpdateTexture = TRUE;
                    m_yKeypos = x;
                    break;
                }

            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            for( int x = ( m_yKeypos + 1 ); x < KEYBOARD_NUM_ROWS; x++ )
            {
                if( m_keyPad[m_xKeypos][x].getRender() && ( wcscmp( m_keyPad[m_xKeypos][x].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    m_bUpdateTexture = TRUE;
                    m_yKeypos = x;
                    break;
                }
            }
            break;
        }
    case CONTROL_DPAD_LEFT:
        {
            for( int x = ( m_xKeypos - 1 ); x >= 0; x-- )
            {
                if( m_keyPad[x][m_yKeypos].getRender() && ( wcscmp( m_keyPad[x][m_yKeypos].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    m_bUpdateTexture = TRUE;
                    m_xKeypos = x;
                    break;
                }

            }
            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            for( int x = ( m_xKeypos + 1 ); x < KEYBOARD_NUM_COLS; x++ )
            {
                if( m_keyPad[x][m_yKeypos].getRender() && ( wcscmp( m_keyPad[x][m_yKeypos].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    m_bUpdateTexture = TRUE;
                    m_xKeypos = x;
                    break;
                }
            }
            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CKeyboardMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    if( bFirstPress )
    {
        m_bDropKeyPress = FALSE;

        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    if ( m_bDropKeyPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
			// Deal with keyboard input
			if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"" ) )              //backspace
			{
				int len = wcslen( m_pwszValueBuffer );
				
				if( len > 0 )
				{
                    m_bUpdateTexture = TRUE;

					m_pwszValueBuffer[len - 1] = L'\0';
				}
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"ok" ) )        //ok
			{
                m_bDropKeyPress = TRUE;
                m_xKeypos = m_yKeypos = 0;
                
                // Go Back one menu
                if( GetParent() )
                {
					// g_USBDevices.Rumble( PORT_ANY, CONTROLLER_RUMBLE_SPEED, CONTROLLER_RUMBLE_MILLISECOND_TIME );

                    Leave( GetParent() );
                }
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"cancel" ) )    //cancel
			{
                m_bDropKeyPress = TRUE;
                m_xKeypos = m_yKeypos = 0;

                // Set the text to nothing
                m_pwszValueBuffer[0] = '\0';

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
			}
			else
			{
                // Ensure we don't exceed the limit of an IP Address
                if( wcslen( m_pwszValueBuffer ) < m_uiValueSize )
                {
                    m_bUpdateTexture = TRUE;

                    if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"space" ) )    //space bar
                    //
                    // Space bar
                    //
                    {
                        wcscat( m_pwszValueBuffer, L" " );
                    }
                    else
                    //
                    // Normal Character
                    //
                    {
    				    wcscat( m_pwszValueBuffer, m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar );
                    }
                }
			}
            break;
        }
    case BUTTON_B:
        {
            m_bDropKeyPress = TRUE;
            m_xKeypos = m_yKeypos = 0;

            // Set the text to nothing
            m_pwszValueBuffer[0] = '\0';

            // Go Back one menu
            if( GetParent() )
            {
                Leave( GetParent() );
            }
            break;
        }
    }
}


// Generate the kepad we will be using
void CKeyboardMenu::GenerateKeypad(void) 
{
	
	// First create numberpad
	int xgrid  = KEYBOARD_NUM_COLS - 1;
	int ygrid  = KEYBOARD_NUM_ROWS;
	int xstart = KEYBOARD_TOPROW_X1;
	int ystart = KEYBOARD_TOPROW_Y1;
	int width  = 32;
	int height = 32;
	int spacer = 2;
	int currentx = xstart;
	int currenty = ystart;

	WCHAR buffer[3];
    ZeroMemory( buffer, sizeof( WCHAR ) * 3 );

    unsigned short alpha = 48;

	for(int y = 0; y < ygrid; y++)
	{
		for(int x = 0; x < xgrid; x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_FOREGROUND_COLOR );
			currentx += width + spacer;
			buffer[0] = alpha;
			m_keyPad[x][y].defineText(buffer);
			alpha++;
			
			//cycle to numbers after we hit 'Z'
			if(alpha == 58) alpha = 97;
		}
		currentx = xstart;
		currenty += height + spacer;
	}


	// Second generate larger buttons
	int xbase  = xgrid;
	xgrid  = 1;
	ygrid  = KEYBOARD_NUM_ROWS;
	xstart = KEYBOARD_TOPROW_X1 + 313;
	ystart = KEYBOARD_TOPROW_Y1;
	width  = 103;
	height = 32;
	spacer = 2;
	currentx = xstart;
	currenty = ystart;

	for(y = 0; y < ygrid; y++)
	{
		for(int x = xbase; x < (xbase + xgrid); x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_FOREGROUND_COLOR );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}
	
	m_keyPad[9][0].defineText(L"ok");
	m_keyPad[9][1].defineText(L"cancel");
	m_keyPad[9][2].defineText(L"space");
	m_keyPad[9][3].defineText(L"");

}


// Draw our keypad
BOOL CKeyboardMenu::renderKeypad( CUDTexture* pTexture )
{
	
	// Render outlines of keys	
	float x1, x2;
	float y1, y2;
	for(int x = 0; x < KEYBOARD_NUM_COLS; x++)
	{
		for(int y = 0; y < KEYBOARD_NUM_ROWS; y++)
		{
			if( m_keyPad[x][y].getRender() && ( wcscmp( m_keyPad[x][y].m_pwszResultChar, L"place" ) != 0 ) )
			{
                // Lock our texture so that we can render to it
                pTexture->Lock();

				x1 = (float)m_keyPad[x][y].m_iXOrigin;
				x2 = (float)(m_keyPad[x][y].m_iXOrigin + m_keyPad[x][y].m_iWidth);
				
				y1 = (float)m_keyPad[x][y].m_iYOrigin;
				y2 = (float)(m_keyPad[x][y].m_iYOrigin + m_keyPad[x][y].m_iHeight);
	
				// hilight key if currently selected
                DWORD dwCharColor;
				if((m_xKeypos == x) && (m_yKeypos == y))
                {
					pTexture->DrawBox( x1, y1, x2, y2, SCREEN_DEFAULT_SELECTOR_COLOR );
                    
                    dwCharColor = SCREEN_SELECTED_OPTION_COLOR;
                }
                else
                {
                    dwCharColor = SCREEN_DEFAULT_FOREGROUND_COLOR;
                }

                pTexture->DrawOutline( x1, y1, x2, y2, KEYBOARD_LINE_WIDTH, m_keyPad[x][y].m_dwSelectColor );
				
				unsigned int decent;
				unsigned int fontHeight;
				GetFontSize( &fontHeight, &decent );
				
				float textX = (float)((m_keyPad[x][y].m_iWidth / 2) + m_keyPad[x][y].m_iXOrigin) - GetStringPixelWidth( m_keyPad[x][y].m_pwszResultChar ) / 2;
				float textY = (float)((m_keyPad[x][y].m_iHeight / 2) + m_keyPad[x][y].m_iYOrigin) - (fontHeight / 2);
				
                pTexture->DrawText( textX, textY, dwCharColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", m_keyPad[x][y].m_pwszResultChar);

                // Unlock our texture
                pTexture->Unlock();
			}
		}
	}
	
	return TRUE;
}



// This will be called whenever this menu is entered / activated
void CKeyboardMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Default the focus to the OK Button
	m_xKeypos = KEYBOARD_NUM_COLS - 1;
    m_yKeypos = 0;
}


// This should be called before the Keyboard is invoked
HRESULT CKeyboardMenu::SetInfo( WCHAR* pwszTextString, WCHAR* pwszValueBuffer, unsigned int uiValueSize )
{
    // Check to make sure we were passed valid buffers
    if( ( !pwszTextString ) || ( !pwszValueBuffer ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CKeyboardMenu::SetInfo():Invalid argument passed in!!" );

        return E_INVALIDARG;
    }

    // Clean up memory if necessary
    if( m_pwszTextString )
    {
        delete[] m_pwszTextString;
        m_pwszTextString = NULL;
    }

    // Set our properties
    m_pwszTextString = _wcsdup( pwszTextString );
    m_pwszValueBuffer = pwszValueBuffer;
    m_uiValueSize = uiValueSize;

    // Clear Memory
    m_pwszValueBuffer[0] = L'\0';

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\keypadmenu.h ===
/*****************************************************
*** keypadmenu.h
***
*** Header file for our XShell keypad menu class.
***
*** by James Helm
*** December 5th, 2000
***
*****************************************************/

#ifndef _KEYPADMENU_H_
#define _KEYPADMENU_H_

#define KEYPAD_NUM_ROWS    4
#define KEYPAD_NUM_COLS    4

#include "key.h"
#include "menuscreen.h"  // Base menu type

class CKeypadMenu : public CMenuScreen
{
public:
    // Constructors and Destructors
    CKeypadMenu( CXItem* pParent );
    virtual ~CKeypadMenu();

    // Methods
    virtual void Enter();   // This will be called whenever this menu is entered / activated
    virtual void Action( CUDTexture* pTexture );
    virtual void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    virtual void HandleInput( enum CONTROLS buttonPressed, BOOL bFirstPress );
    virtual void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    HRESULT SetInfo( WCHAR* pwszTextString,                 // This should be called before the Keyboard is invoked
                     WCHAR* pwszValueBuffer,
                     unsigned int uiValueSize );

protected:
    // Properties
    WCHAR* m_pwszTextString;                                // The string that will be displayed to the user
    WCHAR* m_pwszValueBuffer;                               // Will hold the information that is collected
    unsigned int m_uiValueSize;                             // The length of the value you wish to collect
    BOOL m_bDropKeyPress;                                   // Used to prevent the 'instant' keypress when a user navigates in here
	int m_xKeypos;                                          // X Position of the current Key on the Keypad
    int m_yKeypos;                                          // Y Position of the current Key on the Keypad
	CKey m_keyPad[KEYPAD_NUM_ROWS][KEYPAD_NUM_COLS];        // Information for each Key appearing on the Keypad

    // Private Methods
	virtual void GenerateKeypad(void);                      // Creates the keypad
	virtual BOOL renderKeypad( CUDTexture* pTexture );      // Renders the Keypad on to the texture
};

#endif // _KEYPADMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\keypadmenu.cpp ===
/*****************************************************
*** keypadmenu.cpp
***
*** CPP file for our XShell keypad menu class.
***
*** by James Helm
*** December 5th, 2000
***
*****************************************************/

#include "stdafx.h"
#include "keypadmenu.h"

extern USBManager g_USBDevices;		// Handles all USB Device input/output

// Constructors
CKeypadMenu::CKeypadMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_pwszTextString( NULL ),
m_pwszValueBuffer( NULL ),
m_uiValueSize( 0 ),
m_bDropKeyPress( TRUE )
{
	GenerateKeypad();

    // Default the focus to the OK button
	m_xKeypos = KEYPAD_NUM_COLS - 1;
	m_yKeypos = 0;
}


// Destructor
CKeypadMenu::~CKeypadMenu()
{
    if( m_pwszTextString )
    {
        delete[] m_pwszTextString;
        m_pwszTextString = NULL;
    }
}


// Draws a menu on to the screen
void CKeypadMenu::Action( CUDTexture* pTexture )
{
    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

	// Draw our keypad
	renderKeypad( pTexture );

	// Draw our User defined Text
    pTexture->DrawText( SCREEN_X_CENTER - ( GetStringPixelWidth( m_pwszTextString ) / 2 ), KEYPAD_TEXT_Y1, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", m_pwszTextString );

    // Draw the current value on to the screen
    pTexture->DrawText( SCREEN_X_CENTER - ( GetStringPixelWidth( m_pwszValueBuffer ) / 2 ), KEYPAD_VALUE_Y1, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", m_pwszValueBuffer );
    
    // Unlock our texture
    pTexture->Unlock();
}


// Handle the Joystick Input
void CKeypadMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_LEFT, bFirstXPress );
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
                HandleInput( CONTROL_DPAD_RIGHT, bFirstXPress );
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CKeypadMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            for( int x = ( m_yKeypos - 1 ); x >= 0; x-- )
            {
                if( m_keyPad[m_xKeypos][x].getRender() && ( wcscmp( m_keyPad[m_xKeypos][x].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    m_bUpdateTexture = TRUE;
                    m_yKeypos = x;
                    break;
                }

            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            for( int x = ( m_yKeypos + 1 ); x < KEYPAD_NUM_ROWS; x++ )
            {
                if( m_keyPad[m_xKeypos][x].getRender() && ( wcscmp( m_keyPad[m_xKeypos][x].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    m_bUpdateTexture = TRUE;
                    m_yKeypos = x;
                    break;
                }
            }
            break;
        }
    case CONTROL_DPAD_LEFT:
        {
            for( int x = ( m_xKeypos - 1 ); x >= 0; x-- )
            {
                if( m_keyPad[x][m_yKeypos].getRender() && ( wcscmp( m_keyPad[x][m_yKeypos].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    m_bUpdateTexture = TRUE;
                    m_xKeypos = x;
                    break;
                }

            }
            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            for( int x = ( m_xKeypos + 1 ); x < KEYPAD_NUM_COLS; x++ )
            {
                if( m_keyPad[x][m_yKeypos].getRender() && ( wcscmp( m_keyPad[x][m_yKeypos].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    m_bUpdateTexture = TRUE;
                    m_xKeypos = x;
                    break;
                }
            }
            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CKeypadMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    if( bFirstPress )
    {
        m_bDropKeyPress = FALSE;

        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    if ( m_bDropKeyPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
			// Deal with keyboard input
			if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"" ) )                //backspace
			{
				int len = wcslen( m_pwszValueBuffer );
				
				if( len > 0 )
				{
                    m_bUpdateTexture = TRUE;

					m_pwszValueBuffer[len - 1] = L'\0';
				}
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"ok" ) )          //ok
			{
                m_bDropKeyPress = TRUE;
                m_xKeypos = m_yKeypos = 0;

                // Go Back one menu
                if( GetParent() )
                {
					// g_USBDevices.Rumble( PORT_ANY, CONTROLLER_RUMBLE_SPEED, CONTROLLER_RUMBLE_MILLISECOND_TIME );

                    Leave( GetParent() );
                }
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"cancel" ) )      //cancel
			{
                m_bDropKeyPress = TRUE;
                m_xKeypos = m_yKeypos = 0;

                // Set the text to nothing
                m_pwszValueBuffer[0] = '\0';

                // Go Back one menu
                if( GetParent() )
                {
                    Leave( GetParent() );
                }
			}
			else
			{
                // Ensure we don't exceed the limit of an IP Address
                if( wcslen( m_pwszValueBuffer ) < m_uiValueSize )
                {
                    m_bUpdateTexture = TRUE;

				    wcscat( m_pwszValueBuffer, m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar );
                }
			}
            break;
        }
    case BUTTON_B:
        {
            m_bDropKeyPress = TRUE;
            m_xKeypos = m_yKeypos = 0;

            // Set the text to nothing
            m_pwszValueBuffer[0] = '\0';

            // Go Back one menu
            if( GetParent() )
            {
                Leave( GetParent() );
            }
            break;
        }
    }
}


void CKeypadMenu::GenerateKeypad(void) 
{
	// First create numberpad
	int xgrid  = KEYPAD_NUM_COLS - 1;
	int ygrid  = KEYPAD_NUM_ROWS;
	int xstart = KEYPAD_TOPROW_X1;
	int ystart = KEYPAD_TOPROW_Y1;
	int width  = 32;
	int height = 32;
	int spacer = 2;

	int currentx = xstart;
	int currenty = ystart;

	for(int y = 0; y < ygrid; y++)
	{
		for(int x = 0; x < xgrid; x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_FOREGROUND_COLOR );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}


	// Second generate larger buttons
	int xbase  = xgrid;
	xgrid  = 1;
	ygrid  = 4;
	xstart = KEYPAD_TOPROW_X1 + 113;
	ystart = KEYPAD_TOPROW_Y1;
	width  = 103;
	height = 32;
	spacer = 2;
	
	currentx = xstart;
	currenty = ystart;
	for(y = 0; y < ygrid; y++)
	{
		for(int x = xbase; x < (xbase + xgrid); x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_FOREGROUND_COLOR );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}

	// Set the text of the keys
	m_keyPad[0][0].defineText(L"1");        m_keyPad[1][0].defineText(L"2");    m_keyPad[2][0].defineText(L"3");        m_keyPad[3][0].defineText(L"ok");
	m_keyPad[0][1].defineText(L"4");        m_keyPad[1][1].defineText(L"5");    m_keyPad[2][1].defineText(L"6");        m_keyPad[3][1].defineText(L"cancel");
	m_keyPad[0][2].defineText(L"7");        m_keyPad[1][2].defineText(L"8");    m_keyPad[2][2].defineText(L"9");        m_keyPad[3][2].defineText(L"");
	m_keyPad[0][3].defineText(L"place");    m_keyPad[1][3].defineText(L"0");    m_keyPad[2][3].defineText(L"place");    m_keyPad[3][3].defineText(L"place");
}


BOOL CKeypadMenu::renderKeypad( CUDTexture* pTexture )
{
	
	// Render outlines of keys	
	float x1, x2;
	float y1, y2;
	for(int x = 0; x < KEYPAD_NUM_ROWS; x++)
	{
		for(int y = 0; y < KEYPAD_NUM_COLS; y++)
		{
			if( m_keyPad[x][y].getRender() && ( wcscmp( m_keyPad[x][y].m_pwszResultChar, L"place" ) != 0 ) )
			{
                // Lock our Texture
                pTexture->Lock();

				x1 = (float)m_keyPad[x][y].m_iXOrigin;
				x2 = (float)(m_keyPad[x][y].m_iXOrigin + m_keyPad[x][y].m_iWidth);
				
				y1 = (float)m_keyPad[x][y].m_iYOrigin;
				y2 = (float)(m_keyPad[x][y].m_iYOrigin + m_keyPad[x][y].m_iHeight);
	
				// hilight key if currently selected
                DWORD dwCharColor;
				if((m_xKeypos == x) && (m_yKeypos == y))
                {
                    // Draw the selector box around the currently highlighted number
					pTexture->DrawBox( x1, y1, x2, y2, SCREEN_DEFAULT_SELECTOR_COLOR );
                    
                    dwCharColor = SCREEN_SELECTED_OPTION_COLOR;
                }
                else
                {
                    dwCharColor = SCREEN_DEFAULT_FOREGROUND_COLOR;
                }

                pTexture->DrawOutline( x1, y1, x2, y2, KEYPAD_LINE_WIDTH, m_keyPad[x][y].m_dwSelectColor );
				
				unsigned int decent;
				unsigned int fontHeight;
				GetFontSize( &fontHeight, &decent );
				
				float textX = (float)((m_keyPad[x][y].m_iWidth / 2) + m_keyPad[x][y].m_iXOrigin) - GetStringPixelWidth( m_keyPad[x][y].m_pwszResultChar ) / 2;
				float textY = (float)((m_keyPad[x][y].m_iHeight / 2) + m_keyPad[x][y].m_iYOrigin) - (fontHeight / 2);
				pTexture->DrawText( textX, textY, dwCharColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", m_keyPad[x][y].m_pwszResultChar);

                // Unlock our Texture
                pTexture->Unlock();
			}
		}
	}
	
	return TRUE;
}


// This will be called whenever this menu is entered / activated
void CKeypadMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Default the focus to the OK button
	m_xKeypos = KEYPAD_NUM_COLS - 1;
	m_yKeypos = 0;
}


// This should be called before the Keyboard is invoked
HRESULT CKeypadMenu::SetInfo( WCHAR* pwszTextString, WCHAR* pwszValueBuffer, unsigned int uiValueSize )
{
    // Check to make sure we were passed valid buffers
    if( ( !pwszTextString ) || ( !pwszValueBuffer ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CKeypadMenu::SetInfo():Invalid argument passed in!!" );

        return E_INVALIDARG;
    }

    // Clean up memory if necessary
    if( m_pwszTextString )
    {
        delete[] m_pwszTextString;
        m_pwszTextString = NULL;
    }

    // Set our properties
    m_pwszTextString = _wcsdup( pwszTextString );
    m_pwszValueBuffer = pwszValueBuffer;
    m_uiValueSize = uiValueSize;

    // Clear Memory
    m_pwszValueBuffer[0] = L'\0';

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\memconfigs.cpp ===
/*****************************************************
*** memconfigs.h
***
*** CPP file for our library of functions that
*** will allows us to configure various memory
*** areas in different ways
***
*** by James N. Helm
*** June 20th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "memconfigs.h"
#include "TCHAR.h"


// A:
// MU Name     : Missing name (No Nickname)
// MU Space    : 0 blocks used
HRESULT CreateMU_A( CMemoryUnit* pMemoryUnit )
{
    return pMemoryUnit->Format( TRUE );
}


// B:
// MU Name     : MAX (31) chars
// Game Config : 0 Game Titles
// MU Space    : 1 block used
HRESULT CreateMU_B( CMemoryUnit* pMemoryUnit )
{
    pMemoryUnit->Format( TRUE );

    pMemoryUnit->Name( L"MAX+1muNAME23456789012345678901" );

    char pszDir[4];
    pszDir[3] = '\0';
    sprintf( pszDir, "%c:\\", pMemoryUnit->GetUDataDrive() );

    pMemoryUnit->FillArea( pszDir, 1 );

    return S_OK;
}


// C:
// MU Name     : 1 char
// Game Config : 1 Game Title, 0 Saved Games
// MU Space    : 1/2 blocks used
HRESULT CreateMU_C( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"1" );

    // Create the Game Titles and Saves
    CreateGamesAndSaves( pMemoryUnit, 1, 0 );

    //
    // Fill 1/2 of the blocks
    //

    // Get the available and free block sizes
    DWORD dwFree = pMemoryUnit->GetFreeBlocks();
    DWORD dwTotal = pMemoryUnit->GetTotalBlocks();

    DWORD dwNumBlocksToFill = ( dwTotal / 2 ) - ( dwTotal - dwFree );

    char pszDir[4];
    pszDir[3] = '\0';
    sprintf( pszDir, "%c:\\", pMemoryUnit->GetUDataDrive() );

    pMemoryUnit->FillArea( pszDir, dwNumBlocksToFill );

    return S_OK;
}


// D:
// THIS IS IMPOSSIBLE NOW -- MU Name     : MAX + 1 (33) chars
// Game Config : 1 Game Title, 1 Saved Game
// MU Space    : MAX blocks used
HRESULT CreateMU_D( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    // BUGBUG -- Pretty sure we can't set a 33 char name
    pMemoryUnit->Name( L"MAX+1muNAME2345678901234567890123" );

    // Create the Game Titles and Saves
    CreateGamesAndSaves( pMemoryUnit, 1, 1 );

    //
    // Fill all of the blocks
    //

    // Get the available and free block sizes
    DWORD dwFree = pMemoryUnit->GetFreeBlocks();

    char pszDir[4];
    pszDir[3] = '\0';
    sprintf( pszDir, "%c:\\", pMemoryUnit->GetUDataDrive() );

    pMemoryUnit->FillArea( pszDir, dwFree );

    return S_OK;
}


// E:
// MU Name     : Large (1023 chars)
// Game Config : 2+ Game Titles, 2+ Saved Games
// MU Space    : MAX - 1 blocks used
HRESULT CreateMU_E( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    // BUGBUG -- Pretty sure we can't set a LARGE char name
    // pMemoryUnit->Name( L"Large: 1023 characters - 56789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012" );

    // Create the Game Titles and Saves
    CreateGamesAndSaves( pMemoryUnit, 2, 2 );
    
    //
    // Fill all of the blocks except 1
    //

    // Get the available and free block sizes
    DWORD dwFree = pMemoryUnit->GetFreeBlocks();

    char pszDir[4];
    pszDir[3] = '\0';
    sprintf( pszDir, "%c:\\", pMemoryUnit->GetUDataDrive() );

    pMemoryUnit->FillArea( pszDir, dwFree - 1 );

    return S_OK;
}


// F:
// MU Name     : Invalid Chars
// Game Config : Game Titles arranged for sorting
HRESULT CreateMU_F( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"\x0001\x0002\x0003\x0004\x0005\x0006\x0007\x0008\x0009\x000A\x000B\x000C\x000D\x000E\x000F\x0010\x0011\x0012\x0013\x0014\x0015" );

    // Create Game Sorting routine
    CreateSortOrderGames( pMemoryUnit, TRUE );

    return S_OK;
}


// G:
// MU Name     : Empty muname.xbx (0 chars, no Nickname)
// Game Config : MAX (4096) Game Titles, 1 Saved Game, 1 Block Per Game
HRESULT CreateMU_G( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"" );

    // Create the Game Titles and Saves
    CreateGamesAndSaves( pMemoryUnit, 4096, 1 );

    return S_OK;
}


// H:
// MU Name     : Missing muname.xbx (No Nickname)
// Game Config : MAX (4096) Game Titles, 10 saved Games, 1 Block Per Game
HRESULT CreateMU_H( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"" );

    // Create the Game Titles and Saves
    CreateGamesAndSaves( pMemoryUnit, 4096, 10 );

    return S_OK;
}


// I:
// MU Name     : Missing muname.xbx (No Nickname)
// Game Config : 1 Game Title, 3 Saved Games ( 1 less than a screen line)
HRESULT CreateMU_I( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"" );

    // Create the Game Titles and Saves
    CreateGamesAndSaves( pMemoryUnit, 1, 3 );

    return S_OK;
}


// J:
// MU Name     : Missing muname.xbx (No Nickname)
// Game Config : 1 Game Title, 4 Saved Games ( equal to a screen line)
HRESULT CreateMU_J( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"" );

    // Create the Game Titles and Saves
    CreateGamesAndSaves( pMemoryUnit, 1, 4 );

    return S_OK;
}


// K:
// MU Name     : Missing muname.xbx (No Nickname)
// Game Config : 1 Game Title, 5 Saved Games ( 1 more than a screen line)
HRESULT CreateMU_K( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"" );

    // Create the Game Titles and Saves
    CreateGamesAndSaves( pMemoryUnit, 1, 5 );

    return S_OK;
}


// L:
// MU Name     : Descriptive
// Game Config : 1 Game Title, MAX (500) Saved Games, 1 Block Per Game
HRESULT CreateMU_L( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"1 Game, 500 Saves" );

    // Create the Game Titles and Saves
    // BUGBUG: 500 won't fit, so we'll use something that will be faster
    CreateGamesAndSaves( pMemoryUnit, 1, 300 );

    return S_OK;
}


// M:
// MU Name     : Descriptive
// Game Config : 1 Game Title, MAX + 1 (501) Saved Games, 1 Block Per Game
HRESULT CreateMU_M( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"1 Game, 501 Saves" );

    // Create the Game Titles and Saves
    // BUGBUG: 500 won't fit, so we'll use something that will be faster
    CreateGamesAndSaves( pMemoryUnit, 1, 300 );

    return S_OK;
}


// N:
// MU Name     : Descriptive
// Game Config : 2 Game Titles, MAX (500) Saved Games, 1 block per game, each titles uses 1/2 space
HRESULT CreateMU_N( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"2 Games, 500 Saves" );

    // Create the Game Titles and Saves
    // BUGBUG: 500 won't fit, so we'll use something that will be faster
    CreateGamesAndSaves( pMemoryUnit, 2, 300 );

    return S_OK;
}


// O:
// MU Name     : Descriptive
// Game Config : 10 Titles, each has 4 or less Saved Games
HRESULT CreateMU_O( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"10 Games, 4 Saves" );

    // Create the Game Titles and Saves
    CreateGamesAndSaves( pMemoryUnit, 10, 4 );

    return S_OK;
}


// P:
// MU Name     : Descriptive
// Game Config : 10 Titles, 1st has 8 Saved Games
HRESULT CreateMU_P( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"10 Games, 1st has 8 Saves" );

    // Create the Game Titles and Saves
    CreateGamesAndSaves( pMemoryUnit, 1, 8 );
    CreateGamesAndSaves( pMemoryUnit, 9, 1 );

    return S_OK;
}


// Q:
// MU Name     : Descriptive
// Game Config : 10 Titles, 1st has 12 Saved Games
HRESULT CreateMU_Q( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"10 Games, 1st has 12 Saves" );

    // Create the Game Titles and Saves
    CreateGamesAndSaves( pMemoryUnit, 1, 12 );
    CreateGamesAndSaves( pMemoryUnit, 9, 1 );

    return S_OK;
}


// R:
// MU Name     : Descriptive
// Game Config : 10 Titles, 1st has 16 Saved Games
HRESULT CreateMU_R( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"10 Games, 1st has 16 Saves" );

    // Create the Game Titles and Saves
    CreateGamesAndSaves( pMemoryUnit, 1, 16 );
    CreateGamesAndSaves( pMemoryUnit, 9, 1 );

    return S_OK;
}

// S:
// MU Name     : Descriptive
// Game Config : 10 Titles, 1st has 25 Saved Games
HRESULT CreateMU_S( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"10 Games, 1st has 25 Saves" );

    // Create the Game Titles and Saves
    CreateGamesAndSaves( pMemoryUnit, 1, 25 );
    CreateGamesAndSaves( pMemoryUnit, 9, 1 );

    return S_OK;
}


// T:
// MU Name     : Descriptive
// Game Config : 10 Titles, 1st has 30 Saved Games
HRESULT CreateMU_T( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"10 Games, 1st has 30 Saves" );

    // Create the Game Titles and Saves
    CreateGamesAndSaves( pMemoryUnit, 1, 30 );
    CreateGamesAndSaves( pMemoryUnit, 9, 1 );

    return S_OK;
}


// U:
// MU Name     : Descriptive
// Game Config : 10 Titles, 1st has 35 Saved Games
HRESULT CreateMU_U( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"10 Games, 1st has 35 Saves" );

    // Create the Game Titles and Saves
    CreateGamesAndSaves( pMemoryUnit, 1, 35 );
    CreateGamesAndSaves( pMemoryUnit, 9, 1 );

    return S_OK;
}


// V:
// MU Name     : Descriptive
// Game Config : 10 Titles, 1st has 40 Saved Games
HRESULT CreateMU_V( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"10 Games, 1st has 40 Saves" );

    // Create the Game Titles and Saves
    CreateGamesAndSaves( pMemoryUnit, 1, 40 );
    CreateGamesAndSaves( pMemoryUnit, 9, 1 );

    return S_OK;
}


// W:
// MU Name     : Descriptive
// Game Config : 10 Titles, 1st has 45 Saved Games
HRESULT CreateMU_W( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"10 Games, 1st has 45 Saves" );

    // Create the Game Titles and Saves
    CreateGamesAndSaves( pMemoryUnit, 1, 45 );
    CreateGamesAndSaves( pMemoryUnit, 9, 1 );

    return S_OK;
}


// X:
// MU Name     : Descriptive
// Game Config : 10 Titles, 1st has 50 Saved Games
HRESULT CreateMU_X( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"10 Games, 1st has 50 Saves" );

    // Create the Game Titles and Saves
    CreateGamesAndSaves( pMemoryUnit, 1, 50 );
    CreateGamesAndSaves( pMemoryUnit, 9, 1 );

    return S_OK;
}


// Y:
// MU Name     : Descriptive
// Save Config : SAVE.XBX is MISSING
// Save Config : SAVE.XBX is EMPTY
// Save Config : SAVE.XBX has SaveName = 0 chars
// Save Config : SAVE.XBX has SaveName = 1 char
// Save Config : SAVE.XBX has SaveName = MAX (63) chars
// Save Config : SAVE.XBX has SaveName = MAX + 1 (64) chars
// Save Config : SAVE.XBX has SaveName = Huge
// Save Config : IMAGE.XBX is MISSING
// Save Config : IMAGE.XBX is SMALL (32x32) in size
// Save Config : IMAGE.XBX is NORMAL (64x64) in size
// Save Config : IMAGE.XBX is LARGER (128x128) in size
// Save Config : IMAGE.XBX is LARGER (256x256) in size
// Save Config : IMAGE.XBX is LARGE (1024x1024) in size
// Save Config : IMAGE.XBX is 1 byte file
// Save Config : IMAGE.XBX is CORRUPT XBX file
// Save Config : Time is set to 12:00am
// Save Config : Time is set to 12:00pm
// Save Config : All META Data Missing (No IMAGE.XBX, or SAVE.XBX)
// Save Config : Parent Game has 0 char title
// Save Config : Parent Game has 1 char title
// Save Config : Parent Game has MAX (63) char title
// Save Config : Parent Game has MAX + 1 (64) char title
// Save Config : Size is 1 block
// Save Config : Save Game cannot be copied (NoCopy=1)
// Save Config : Save Game can be copied (NoCopy=0)
// Save Config : NoCopy=Large
// Save Config : NoCopy=Huge
HRESULT CreateMU_Y( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"Meta Data Vars (1 of 2)" );

    // Create the games
    CreateMetaVarGames( pMemoryUnit );

    return S_OK;
}


// Z:
// MU Name     : Descriptive
// Save Config : Size is MAX (504) blocks
HRESULT CreateMU_Z( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"Meta Data Vars (2 of 2)" );

    // Create a Game Title
    pMemoryUnit->CreateGameTitle( pMemoryUnit->GetUDataDrive(), "00000001" );

    // Mount the MU to our Game Title directory
    pMemoryUnit->Unmount();
    if( FAILED( pMemoryUnit->MapUDataToTitleID( "00000001" ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CreateMU_Z():Failed to MapUDataToTitleID!! ID - '00000001', Error - '0x%0.8X (%d)'", GetLastError(), GetLastError() );
    }
    else
    {
        char pszGameDir[MAX_PATH+1];
        ZeroMemory( pszGameDir, MAX_PATH+1 );
        pMemoryUnit->CreateSavedGame( L"Max Blocks Game",
                                      pszGameDir,
                                      MAX_PATH,
                                      NULL,
                                      "",
                                      FALSE );

        DWORD dwFree = pMemoryUnit->GetFreeBlocks();
        char pszFilePath[MAX_PATH+1];
        ZeroMemory( pszFilePath, MAX_PATH+1 );

        _snprintf( pszFilePath, MAX_PATH, "%hsfill_file.xdk", pszGameDir );
        XDBGWRN( APP_TITLE_NAME_A, "CreateMU_Z():File path - '%hs'", pszFilePath );

        // Fill the Game
        LARGE_INTEGER liNumBlocks;
        liNumBlocks.QuadPart = dwFree * MEMORY_AREA_BLOCK_SIZE_IN_BYTES;
        pMemoryUnit->CreateFileOfSize( pszFilePath, liNumBlocks );
    }

    // Restore the MU to it's orignal Mount location
    pMemoryUnit->Unmount();
    pMemoryUnit->Mount();

    return S_OK;
}


// AA:
// MU Name     : Descriptive
// Save Config : Saved Game contains many smaller (1 block) files
HRESULT CreateMU_AA( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"Saved Game Many Files" );

    // Create a Game Title
    pMemoryUnit->CreateGameTitle( pMemoryUnit->GetUDataDrive(), "00000001" );

    // Mount the MU to our Game Title directory
    pMemoryUnit->Unmount();
    if( FAILED( pMemoryUnit->MapUDataToTitleID( "00000001" ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CreateMU_AA():Failed to MapUDataToTitleID!! ID - '00000001', Error - '0x%0.8X (%d)'", GetLastError(), GetLastError() );
    }
    else
    {
        char pszGameDir[MAX_PATH+1];
        ZeroMemory( pszGameDir, MAX_PATH+1 );
        pMemoryUnit->CreateSavedGame( L"Max Blocks Game",
                                      pszGameDir,
                                      MAX_PATH,
                                      NULL,
                                      "",
                                      FALSE );

        char pszFilePath[MAX_PATH+1];
        ZeroMemory( pszFilePath, MAX_PATH+1 );

        LARGE_INTEGER liNumBlocks;
        liNumBlocks.QuadPart = MEMORY_AREA_BLOCK_SIZE_IN_BYTES;

        DWORD dwFree = pMemoryUnit->GetFreeBlocks();
        for( unsigned int x = 0; x < dwFree; x++ )
        {
            _snprintf( pszFilePath, MAX_PATH, "%hsfile_%d.xdk", pszGameDir, x );

            pMemoryUnit->CreateFileOfSize( pszFilePath, liNumBlocks );
        }
    }

    // Restore the MU to it's orignal Mount location
    pMemoryUnit->Unmount();
    pMemoryUnit->Mount();

    return S_OK;
}



// BB:
// MU Name     : Jap Sort
// Game Config : Game Titles arranged for japanese sorting
HRESULT CreateMU_BB( CMemoryUnit* pMemoryUnit )
{
    // Format the MU
    pMemoryUnit->Format( TRUE );

    // Name the MU
    pMemoryUnit->Name( L"Jap Sort" );

    // Create Game Sorting routine
    CreateSortOrderGames( pMemoryUnit, FALSE );

    return S_OK;
}

void CreateGenGame( CMemoryArea* pMemoryArea, DWORD dwTitleID, WCHAR* pwszGameName, unsigned int uiNumSavedGames, BOOL bPrependLangCodeToName/*=TRUE*/ )
{
    if( NULL == pwszGameName )
    {
        return;
    }

    // Create the Game Titles
    char pszGameTitle[9];
    
    pszGameTitle[8] = '\0';
    sprintf( pszGameTitle, "%0.8X", dwTitleID );
    pMemoryArea->CreateGameTitle( pMemoryArea->GetUDataDrive(), pszGameTitle, pwszGameName, bPrependLangCodeToName );

    if( uiNumSavedGames > 0 )
    {
        if( FAILED( pMemoryArea->MapUDataToTitleID( pszGameTitle ) ) )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CreateGenGame():Failed to MapUDataToTitleID!! ID - '%hs', Error - '0x%0.8X (%d)'", pszGameTitle, GetLastError(), GetLastError() );
        }
        else
        {
            WCHAR pwszSavedGameName[50];
            ZeroMemory( pwszSavedGameName, sizeof( WCHAR ) * 50 );
            for( unsigned int x = 0; x < uiNumSavedGames; x++ )
            {
                _snwprintf( pwszSavedGameName, 49, L"Game #%d", x );
                pMemoryArea->CreateSavedGame( pwszSavedGameName,
                                              NULL,
                                              0,
                                              NULL,
                                              "",
                                              FALSE );
            }
        }

        pMemoryArea->MapUDataToOrigLoc();
    }
}






// This function assumes you have UDATA Mapped to the root of the partition
// This is for character sorting,  specify TRUE or FALSE for english or japanese sorting
void CreateSortOrderGames( CMemoryArea* pMemoryArea, bool english )
{
    DWORD dwTitleIDStartNo = 0x00007000;

    CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"ZZ", 0, FALSE );
    
    // Create Saved Games in special sort order
    if( FAILED( pMemoryArea->MapUDataToTitleID( dwTitleIDStartNo - 1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CreateSortOrderGames():Failed to MapUDataToTitleID!! ID - '%d', Error - '0x%0.8X (%d)'", dwTitleIDStartNo - 1, GetLastError(), GetLastError() );

        return;
    }

    SYSTEMTIME sysTime;
    ZeroMemory( &sysTime, sizeof( sysTime ) );

    sysTime.wMonth = 1; sysTime.wDay = 1; sysTime.wYear = 2000; /**/ sysTime.wHour = 0; sysTime.wMinute = 59; sysTime.wSecond = 0;
    pMemoryArea->CreateSavedGame( L"5th Game", NULL, 0, &sysTime, "", FALSE );

    sysTime.wMonth = 2; sysTime.wDay = 1; sysTime.wYear = 2000; /**/ sysTime.wHour = 0; sysTime.wMinute = 0; sysTime.wSecond = 0;
    pMemoryArea->CreateSavedGame( L"10th Game", NULL, 0, &sysTime, "", FALSE );

    sysTime.wMonth = 1; sysTime.wDay = 1; sysTime.wYear = 2000; /**/ sysTime.wHour = 0; sysTime.wMinute = 0; sysTime.wSecond = 59;
    pMemoryArea->CreateSavedGame( L"3rd Game", NULL, 0, &sysTime, "", FALSE );

    sysTime.wMonth = 1; sysTime.wDay = 1; sysTime.wYear = 2000; /**/ sysTime.wHour = 1; sysTime.wMinute = 0; sysTime.wSecond = 0;
    pMemoryArea->CreateSavedGame( L"6th Game", NULL, 0, &sysTime, "", FALSE );

    sysTime.wMonth = 1; sysTime.wDay = 1; sysTime.wYear = 2099; /**/ sysTime.wHour = 0; sysTime.wMinute = 0; sysTime.wSecond = 0;
    pMemoryArea->CreateSavedGame( L"14th Game", NULL, 0, &sysTime, "", FALSE );

    sysTime.wMonth = 1; sysTime.wDay = 31; sysTime.wYear = 2000; /**/ sysTime.wHour = 0; sysTime.wMinute = 0; sysTime.wSecond = 0;
    pMemoryArea->CreateSavedGame( L"9th Game", NULL, 0, &sysTime, "", FALSE );

    sysTime.wMonth = 1; sysTime.wDay = 2; sysTime.wYear = 2000; /**/ sysTime.wHour = 0; sysTime.wMinute = 0; sysTime.wSecond = 0;
    pMemoryArea->CreateSavedGame( L"8th Game", NULL, 0, &sysTime, "", FALSE );

    sysTime.wMonth = 1; sysTime.wDay = 1; sysTime.wYear = 2000; /**/ sysTime.wHour = 23; sysTime.wMinute = 0; sysTime.wSecond = 0;
    pMemoryArea->CreateSavedGame( L"7th Game", NULL, 0, &sysTime, "", FALSE );

    sysTime.wMonth = 1; sysTime.wDay = 1; sysTime.wYear = 2000; /**/ sysTime.wHour = 0; sysTime.wMinute = 0; sysTime.wSecond = 1;
    pMemoryArea->CreateSavedGame( L"2nd Game", NULL, 0, &sysTime, "", FALSE );

    sysTime.wMonth = 12; sysTime.wDay = 1; sysTime.wYear = 2000; /**/ sysTime.wHour = 0; sysTime.wMinute = 0; sysTime.wSecond = 0;
    pMemoryArea->CreateSavedGame( L"11th Game", NULL, 0, &sysTime, "", FALSE );

    sysTime.wMonth = 1; sysTime.wDay = 1; sysTime.wYear = 2050; /**/ sysTime.wHour = 0; sysTime.wMinute = 0; sysTime.wSecond = 0;
    pMemoryArea->CreateSavedGame( L"13th Game", NULL, 0, &sysTime, "", FALSE );

    sysTime.wMonth = 1; sysTime.wDay = 1; sysTime.wYear = 2001; /**/ sysTime.wHour = 0; sysTime.wMinute = 0; sysTime.wSecond = 0;
    pMemoryArea->CreateSavedGame( L"12th Game", NULL, 0, &sysTime, "", FALSE );

    sysTime.wMonth = 1; sysTime.wDay = 1; sysTime.wYear = 2000; /**/ sysTime.wHour = 0; sysTime.wMinute = 0; sysTime.wSecond = 0;
    pMemoryArea->CreateSavedGame( L"1st Game", NULL, 0, &sysTime, "", FALSE );

    sysTime.wMonth = 1; sysTime.wDay = 1; sysTime.wYear = 2000; /**/ sysTime.wHour = 0; sysTime.wMinute = 1; sysTime.wSecond = 0;
    pMemoryArea->CreateSavedGame( L"4th Game", NULL, 0, &sysTime, "", FALSE );


    pMemoryArea->MapUDataToOrigLoc();

    
	if (english)
	{	
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"z",   2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"zz",  2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"A",   2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"AA",  2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"a",   2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"aa",  2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"A",   2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"AA",  2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"a",   2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"aa",  2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"B",   2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"b",   2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"Ab",  2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"1",   2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"01",  2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"10",  2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"A1",  2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"ba",  2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"!!",  2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"#A#", 2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L" A",  2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"A A", 2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"ZZ",  2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"z",   2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"zz",  2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"ZZ",  2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"Z",   2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"zz",  2, FALSE  );
	}
	else
	{
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"\x30ED\x30ED",	2, FALSE );		//last char of Katakana
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"\x30ED",			2, FALSE  );	//last char of Katakana
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"\x3041",			2, FALSE  );	//first char of Hirigana
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"\x3041\x3041",	2, FALSE  );	//first char of Hirigana
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"z",				2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"ZZ",				2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"a",				2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"Aa",				2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"\x30FC",			2, FALSE  );	//last char of Hirigana
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"\x30FC\x30FC",	2, FALSE  );	//last char of Hirigana
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"\x30A1",			2, FALSE  );	//first char of Katakana
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"\x30A1\x30A1",	2, FALSE  );	//first char of Katakana
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"1",				2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"01",				2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"10",				2, FALSE  );
  		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"\x3041" L"1",		2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"ba",				2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"!!",				2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"#A#",				2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"@"L"\x3088\x30E6",2, FALSE  );	//Tilda then Hirigana then Katakana
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"\x30E8\x3082",	2, FALSE  );	//Katakana then Hirigana
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"\x3082\x30E8",	2, FALSE  );	//Hirigana then Katakana
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"\x3088" L"z",		2, FALSE  );	//Hirigana then English
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"z" L"\x3088",		2, FALSE  );	//English then Hirigana
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"\x30E4" L"X",		2, FALSE  );	//Katakana then English
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"X" L"\x30E4",		2, FALSE  );	//English the Kataka
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"\x3093" L"F",		2, FALSE  );	//Hirigana then English
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"F" L"\x3093",		2, FALSE  );	//English then Hirigana
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"A9",				2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"B6",				2, FALSE  );
		CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"B8",				2, FALSE  );
	}
}


// This function assumes you have UDATA Mapped to the root of the partition
void CreateMetaVarGames( CMemoryArea* pMemoryArea )
{
    DWORD dwTitleIDStartNo = 0x00008000;

    LARGE_INTEGER liNumber;
    char pszImageDestName[50];
    char pszTitlePath[50];
    char pszSavedGamePath[50];
    
    ZeroMemory( pszImageDestName, 50 );
    ZeroMemory( pszTitlePath, 50 );
    ZeroMemory( pszSavedGamePath, 50 );


    // Create a Title without a localized TITLEMETA.XBX
    CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"TITLEMETA.XBX not localized", 0, FALSE );

    _snprintf( pszTitlePath, 49, "%c:\\%0.8X", pMemoryArea->GetUDataDrive(), dwTitleIDStartNo - 1 );
    
    pMemoryArea->CreateTitleMetaXbx( pszTitlePath, L"TITLEMETA.XBX not localized", L"", NULL );

    // Create a Title with MAX - 1 (62) char name (no spaces)
    CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"01234567890123456789012345678901234567890123456789012345678901", 0, FALSE );

    // Create a Title with MAX (63) char name (no spaces)
    CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"012345678901234567890123456789012345678901234567890123456789012", 0, FALSE );

    // Create a Title with MAX+1 (64) char name (no spaces)
    CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"0123456789012345678901234567890123456789012345678901234567890123", 0, FALSE );

    // Create a Title with MAX (63) char name (with spaces)
    CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"0 2 4 6 8 0 2 4 6 8 0 2 4 6 8 0 2 4 6 8 0 2 4 6 8 0 2 4 6 8 0 2", 0, FALSE );

    // Create a Title with MAX (63) char name (big chuncks)
    CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"012345678901234 678901234567890123456789012345 7890123456789012", 0, FALSE );

    // Create a Title with (0) char name
    CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"", 0, FALSE );

    // Create a Title with (1) char name
    CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"1", 0, FALSE );

    // Saved Game saveimage is at a higher level (saved game is missing saveimage.xbx)
    CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"Def Save Image / No Save Image", 0 );

    /*
    _snprintf( pszTitlePath, 49, "%c:\\%0.8X", pMemoryArea->GetUDataDrive(), dwTitleIDStartNo++ );

    // Create the directory for the Game
    if( !CreateDirectory( pszTitlePath, NULL ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the directory - '%s', Error - '0x%.8X (%d)'", pszTitlePath, GetLastError(), GetLastError() );

    if( FAILED( pMemoryArea->CreateTitleMetaXbx( pszTitlePath, L"Save Image Higher", NULL, NULL ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the titlemeta.xbx file!! TitlePath - '%hs'", pszTitlePath );
    
    if( FAILED( pMemoryArea->CopyGameImages( pszTitlePath, TRUE, TRUE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the copy the saved game images!! TitlePath - '%hs'" );
    */

    if( FAILED( pMemoryArea->MapUDataToTitleID( dwTitleIDStartNo - 1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to MapUDataToTitleID!! ID - '%d', Error - '0x%0.8X (%d)'", dwTitleIDStartNo - 1, GetLastError(), GetLastError() );
    }
    else
    {
        if( FAILED( pMemoryArea->CreateSavedGame( L"Missing Save Image", NULL, 0, NULL, NULL, FALSE ) ) )
            XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );
    }

    pMemoryArea->MapUDataToOrigLoc();

    // Saved Game saveimage is at a higher level (saved game also has saveimage.xbx)
    CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"1", 1 );

    //
    // Saved Game 'Missing' All Images
    //
    CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"All Images Missing", 0 );
    pMemoryArea->MapUDataToTitleID( dwTitleIDStartNo - 1 );

    char pszGameImage[MAX_PATH+1];
    char pszDefSaveImage[MAX_PATH+1];

    pszGameImage[MAX_PATH] = '\0';
    pszDefSaveImage[MAX_PATH] = '\0';

    _snprintf( pszGameImage,    MAX_PATH, "%c:\\%hs", pMemoryArea->GetUDataDrive(), MEMORY_AREA_TITLE_IMAGE_FILENAME );
    _snprintf( pszDefSaveImage, MAX_PATH, "%c:\\%hs", pMemoryArea->GetUDataDrive(), MEMORY_AREA_SAVEGAME_IMAGE_FILENAME );

    if( !DeleteFile( pszGameImage ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to delete the file!! File - '%hs', Error - '0x%0.8X (%d)'", pszGameImage, GetLastError(), GetLastError() );
    }

    if( !DeleteFile( pszDefSaveImage ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to delete the file!! File - '%hs', Error - '0x%0.8X (%d)'", pszDefSaveImage, GetLastError(), GetLastError() );
    }

    // saveimage.xbx is missing
    if( FAILED( pMemoryArea->CreateSavedGame( L"Save Image: Missing", NULL, 0, NULL, NULL, FALSE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );

    pMemoryArea->MapUDataToOrigLoc();

    //
    // Saved Game Varitions
    //
    SYSTEMTIME sysTime;
    ZeroMemory( &sysTime, sizeof( sysTime ) );

    CreateGenGame( pMemoryArea, dwTitleIDStartNo++, L"Saved Game Variations", 0 );
    pMemoryArea->MapUDataToTitleID( dwTitleIDStartNo - 1 );

    // TODO: All meta-data missing

    // Saved Game Time is 12:00am
    sysTime.wMonth = 1; sysTime.wDay = 1; sysTime.wYear = 2000; /**/ sysTime.wHour = 0; sysTime.wMinute = 0; sysTime.wSecond = 0;
    pMemoryArea->CreateSavedGame( L"Game Time: 12:00am", NULL, 0, &sysTime, "", FALSE );

    // Saved Game Time is 12:00pm
    sysTime.wMonth = 1; sysTime.wDay = 1; sysTime.wYear = 2000; /**/ sysTime.wHour = 12; sysTime.wMinute = 0; sysTime.wSecond = 0;
    pMemoryArea->CreateSavedGame( L"Game Time: 12:00pm", NULL, 0, &sysTime, "", FALSE );

    // saveimage.xbx is missing
    if( FAILED( pMemoryArea->CreateSavedGame( L"Save Image: Missing", NULL, 0, NULL, NULL, FALSE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );

    // saveimage.xbx is normal (64x64)
    if( FAILED( pMemoryArea->CreateSavedGame( L"Save Image: 64x64 (Normal)", NULL, 0, NULL, "", FALSE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );

    // saveimage.xbx is 32x32
    if( FAILED( pMemoryArea->CreateSavedGame( L"Save Image: 32x32 (Small)", NULL, 0, NULL, MEMCONFIGS_32X32_IMAGE_PATHINFO, FALSE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );

    // saveimage.xbx is 128x128
    if( FAILED( pMemoryArea->CreateSavedGame( L"Save Image: 128x128 (Larger)", NULL, 0, NULL, MEMCONFIGS_128X128_IMAGE_PATHINFO, FALSE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );

    // saveimage.xbx is 256x256
    if( FAILED( pMemoryArea->CreateSavedGame( L"Save Image: 256x256 (Larger)", NULL, 0, NULL, MEMCONFIGS_256X256_IMAGE_PATHINFO, FALSE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );

    // saveimage.xbx is 1024x1024
    if( FAILED( pMemoryArea->CreateSavedGame( L"Save Image: 1024x1024 (Larger)", NULL, 0, NULL, MEMCONFIGS_1024X1024_IMAGE_PATHINFO, FALSE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );

    // saveimage.xbx is 1 byte
    ZeroMemory( pszSavedGamePath, 50 );
    liNumber.QuadPart = 1;

    if( FAILED( pMemoryArea->CreateSavedGame( L"Save Image: 1 byte", pszSavedGamePath, 49, NULL, NULL, FALSE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );

    // Create a 1 byte image file
    _snprintf( pszImageDestName, 49, "%hs%hs", pszSavedGamePath, MEMORY_AREA_SAVEGAME_IMAGE_FILENAME );
    if( FAILED( pMemoryArea->CreateFileOfSize( pszImageDestName, liNumber ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create a 1 byte image file!!" );
    
    // saveimage.xbx is corrupt
    if( FAILED( pMemoryArea->CreateSavedGame( L"Save Image: Corrupt", NULL, 0, NULL, MEMCONFIGS_CORRUPT_IMAGE_PATHINFO, FALSE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );
    
    // savemeta.xbx is missing
    ZeroMemory( pszSavedGamePath, 50 );

    if( FAILED( pMemoryArea->CreateSavedGame( L"Save Meta: Missing", pszSavedGamePath, 49, NULL, "", FALSE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );

    _snprintf( pszImageDestName, 49, "%hs%hs", pszSavedGamePath, META_FILE_SAVEXBX_FILENAME );
    if( !DeleteFile( pszImageDestName ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to delete the savemeta.xbx file!!" );

    // savemeta.xbx is empty
    ZeroMemory( pszSavedGamePath, 50 );
    liNumber.QuadPart = 0;

    if( FAILED( pMemoryArea->CreateSavedGame( L"Save Meta: Missing", pszSavedGamePath, 49, NULL, "", FALSE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );

    _snprintf( pszImageDestName, 49, "%hs%hs", pszSavedGamePath, META_FILE_SAVEXBX_FILENAME );
    if( FAILED( pMemoryArea->CreateFileOfSize( pszImageDestName, liNumber ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create an empty savemeta.xbx file!!" );

    // Save Name is 0 chars
    if( FAILED( pMemoryArea->CreateSavedGame( L"", NULL, 0, NULL, "", FALSE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );

    // Save Name is 1 char
    if( FAILED( pMemoryArea->CreateSavedGame( L"1", NULL, 0, NULL, "", FALSE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );

    // Save Name is MAX - 1 (62) chars
    if( FAILED( pMemoryArea->CreateSavedGame( L"01234567890123456789012345678901234567890123456789012345678901", NULL, 0, NULL, "", FALSE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );

    // Save Name is MAX (63) chars
    if( FAILED( pMemoryArea->CreateSavedGame( L"012345678901234567890123456789012345678901234567890123456789012", NULL, 0, NULL, "", FALSE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );

    // Save Name is MAX + 1 (64) chars
    if( FAILED( pMemoryArea->CreateSavedGame( L"0123456789012345678901234567890123456789012345678901234567890123", NULL, 0, NULL, "", FALSE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );

    // BUGBUG: These will RIP
    /*
    // Save Name is LARGE (1023 chars)
    if( FAILED( pMemoryArea->CreateSavedGame( L"1023-chars0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789"
                                            L"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789"
                                            L"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789"
                                            L"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789"
                                            L"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789"
                                            L"01234567890123456789012", NULL, 0, NULL, "", FALSE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );

    // Save Name is HUGE (1024+ chars)
    if( FAILED( pMemoryArea->CreateSavedGame( L"1024-chars0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789"
                                            L"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789"
                                            L"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789"
                                            L"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789"
                                            L"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789"
                                            L"01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789", 
                                            NULL, 0, NULL, "", FALSE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );
    */

    // 1 block Saved Game
    if( FAILED( pMemoryArea->CreateSavedGame( L"Saved Game: 1 block", NULL, 0, NULL, NULL, FALSE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );

    // NOCOPY=1 Saved Game
    if( FAILED( pMemoryArea->CreateSavedGame( L"Saved Game: NoCopy=1", NULL, 0, NULL, "", TRUE ) ) )
        XDBGWRN( APP_TITLE_NAME_A, "CreateMetaVarGames():Failed to create the saved game!!" );

    // TODO: NOCOPY=0 Saved Game
    // TODO: NOCOPY=2 Saved Game
    // TODO: NOCOPY=LARGE (1023 chars)
    // TODO: NOCOPY=HUGE (1024+ chars)

    pMemoryArea->MapUDataToOrigLoc();
}


void CreateGamesAndSaves( CMemoryUnit* pMemoryUnit, unsigned int uiNumGames, unsigned int uiNumSaved )
{
    // Create the Game Titles
    WCHAR pwszSaveGameName[20];
    char pszGameTitle[9];
    
    ZeroMemory( pwszSaveGameName, sizeof( WCHAR ) * 20 );
    pszGameTitle[8] = '\0';
    DWORD dwXModifier = 0;
    DWORD dwNumTries = 0;
    for( unsigned int x = 0; x < uiNumGames; x++ )
    {
        sprintf( pszGameTitle, "%0.8X", x + dwXModifier );
        
        while( FAILED( pMemoryUnit->CreateGameTitle( pMemoryUnit->GetUDataDrive(), pszGameTitle ) ) )
        {
            ++dwXModifier;
            sprintf( pszGameTitle, "%0.8X", x + dwXModifier );

            if( ( ERROR_DISK_FULL == GetLastError() ) || ( dwNumTries++ == 100 ) )
            {
                // Restore the MU to it's orignal Mount location
                pMemoryUnit->Unmount();
                pMemoryUnit->Mount();

                return;
            }
        }

        // Mount the MU to our Game Title directory
        pMemoryUnit->Unmount();
        if( SUCCEEDED( pMemoryUnit->MapUDataToTitleID( pszGameTitle ) ) )
        {
            // Create the Saved Games for the Title
            for( unsigned int y = 0; y < uiNumSaved; y++ )
            {
                _snwprintf( pwszSaveGameName, 19, L"Save Game #%03d", y );
                if( FAILED( pMemoryUnit->CreateSavedGame( pwszSaveGameName, NULL, 0, NULL, "", FALSE ) ) )
                {
                    // Full

                    // Restore the MU to it's orignal Mount location
                    pMemoryUnit->Unmount();
                    pMemoryUnit->Mount();

                    return;
                }
            }
        }

        // Restore the MU to it's orignal Mount location
        pMemoryUnit->Unmount();
        pMemoryUnit->Mount();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\memorymenu.h ===
/*****************************************************
*** memorymenu.h
***
*** Header file for our XShell Format menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** January 10th, 2001
***
*****************************************************/

void FillDisk( char* );

#ifndef _MEMORYMENU_H_
#define _MEMORYMENU_H_

#include "menuscreen.h"  // Base menu type
#include "memoryunit.h"

// Sub-Menus
#include "muoptions.h"
#include "hdoptions.h"

class CMemoryMenu : public CMenuScreen
{
public:
    CMemoryMenu( CXItem* pParent );
    ~CMemoryMenu();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods
    HRESULT Init( IDirect3DDevice8* pD3DDevice, char* menuFileName );       // Initialize our font and settings

private:
    DWORD m_dwInsertedMUs;          // Bit mask of the MU's that are inserted
    DWORD m_dwMUInsertions;         // Used to determine which MU's were inserted since the last check
    DWORD m_dwMURemovals;           // Used to determine which MU's were removed since the last check
    CMemoryUnit m_MemoryUnits[8];   // Memory Units that can be inserted, or removed

    CMUOptions m_MenuMUOptions;     // MU Options Sub-Menu
    CHDOptions m_MenuHDOptions;     // HD Options Sub-Menu

    // Private Methods
    // void Leave( CXItem* pItem );    // This should be called whenever a user leaves this menu
};

#endif // _MEMORYMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\memconfigs.h ===
/*****************************************************
*** memconfigs.h
***
*** Header file for our library of functions that
*** will allows us to configure various memory
*** areas in different ways
***
*** by James N. Helm
*** June 20th, 2001
***
*****************************************************/

#ifndef _MEMCONFIGS_H_
#define _MEMCONFIGS_H_

#include "memoryarea.h"
#include "memoryunit.h"

HRESULT CreateMU_A( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_B( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_C( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_D( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_E( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_F( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_G( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_H( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_I( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_J( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_K( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_L( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_M( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_N( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_O( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_P( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_Q( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_R( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_S( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_T( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_U( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_V( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_W( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_X( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_Y( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_Z( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_AA( CMemoryUnit* pMemoryUnit );
HRESULT CreateMU_BB( CMemoryUnit* pMemoryUnit );

void CreateSortOrderGames( CMemoryArea* pMemoryArea, bool english );
void CreateMetaVarGames( CMemoryArea* pMemoryArea );
void CreateGamesAndSaves( CMemoryUnit* pMemoryUnit, unsigned int uiNumGames, unsigned int uiNumSaved );
void CreateGenGame( CMemoryArea* pMemoryArea, DWORD dwTitleID, WCHAR* pwszGameName, unsigned int uiNumSavedGames, BOOL bPrependLangCodeToName=TRUE );

#define MEMCONFIGS_32X32_IMAGE_FILENAME         "32x32image.xbx"
#define MEMCONFIGS_32X32_IMAGE_PATHINFO         FILE_DATA_DATA_DIRECTORY_A "\\" MEMCONFIGS_32X32_IMAGE_FILENAME
#define MEMCONFIGS_128X128_IMAGE_FILENAME       "128x128image.xbx"
#define MEMCONFIGS_128X128_IMAGE_PATHINFO       FILE_DATA_DATA_DIRECTORY_A "\\" MEMCONFIGS_128X128_IMAGE_FILENAME
#define MEMCONFIGS_256X256_IMAGE_FILENAME       "256x256image.xbx"
#define MEMCONFIGS_256X256_IMAGE_PATHINFO       FILE_DATA_DATA_DIRECTORY_A "\\" MEMCONFIGS_256X256_IMAGE_FILENAME
#define MEMCONFIGS_1024X1024_IMAGE_FILENAME     "1024x1024image.xbx"
#define MEMCONFIGS_1024X1024_IMAGE_PATHINFO     FILE_DATA_DATA_DIRECTORY_A "\\" MEMCONFIGS_1024X1024_IMAGE_FILENAME
#define MEMCONFIGS_CORRUPT_IMAGE_FILENAME       "corruptimage.xbx"
#define MEMCONFIGS_CORRUPT_IMAGE_PATHINFO       FILE_DATA_DATA_DIRECTORY_A "\\" MEMCONFIGS_CORRUPT_IMAGE_FILENAME

#endif //_MEMCONFIGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\PolyObject.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Contstructor
CPolyObject::CPolyObject()
: m_pVertexBuffer( NULL )
{
}

// Destructor
CPolyObject::~CPolyObject()
{
    // Destroy any memory, etc, that we have allocated
    CleanUp();
}


// Clean up any memory allocated, etc.
void CPolyObject::CleanUp()
{
    // Clean up our Vertex Buffer
    if( m_pVertexBuffer )
    {
        m_pVertexBuffer->Release();
        m_pVertexBuffer = NULL;
    }
}


// Initialize our data, including our vertext buffer
void CPolyObject::Initialize( IDirect3DDevice8* pD3DDevice )
{
    // Clean up anything that was previously allocated
    CleanUp();

    // Setup our vertices
    MYTEXVERTEX* pb = NULL;

    // Create our vertex buffer
    pD3DDevice->CreateVertexBuffer( sizeof( MYTEXVERTEX ) * 4, 0, 0, 0, &m_pVertexBuffer );

    m_pVertexBuffer->Lock( 0, 0, (BYTE**)&pb, 0 );

    pb[0].v.x = 0.0f;         pb[0].v.y = 0.0f;          pb[0].v.z = 0.1f; pb[0].fRHW = 0.9f; pb[0].diffuse = COLOR_WHITE; pb[0].tu = 0.0f;         pb[0].tv = 0.0f;
    pb[1].v.x = SCREEN_WIDTH; pb[1].v.y = 0.0f;          pb[1].v.z = 0.1f; pb[1].fRHW = 0.9f; pb[1].diffuse = COLOR_WHITE; pb[1].tu = SCREEN_WIDTH; pb[1].tv = 0.0f;
    pb[2].v.x = SCREEN_WIDTH; pb[2].v.y = SCREEN_HEIGHT; pb[2].v.z = 0.1f; pb[2].fRHW = 0.9f; pb[2].diffuse = COLOR_WHITE; pb[2].tu = SCREEN_WIDTH; pb[2].tv = SCREEN_HEIGHT;
    pb[3].v.x = 0.0f;         pb[3].v.y = SCREEN_HEIGHT; pb[3].v.z = 0.1f; pb[3].fRHW = 0.9f; pb[3].diffuse = COLOR_WHITE; pb[3].tu = 0.0f;         pb[3].tv = SCREEN_HEIGHT;

    m_pVertexBuffer->Unlock();
}


// Render the Poly to the screen
void CPolyObject::Render( IDirect3DDevice8* pD3DDevice )
{
    pD3DDevice->SetVertexShader( D3DFVF_MYTEXVERTEX );
    pD3DDevice->SetStreamSource( 0, m_pVertexBuffer, sizeof( MYTEXVERTEX ) );
    pD3DDevice->DrawPrimitive( D3DPT_TRIANGLEFAN, 0, 2 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\memorymenu.cpp ===
/*****************************************************
*** memorymenu.cpp
***
*** CPP file for our XShell Memory menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** January 10th, 2001
***
*** Modified
*** 03-16-2001 by James N. Helm
*****************************************************/

#include "stdafx.h"
#include "memorymenu.h"

extern CHardDrive    g_HardDrive;       // Xbox Hard Drive

// Constructors
CMemoryMenu::CMemoryMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_MenuMUOptions( NULL ),
m_MenuHDOptions( NULL ),
m_dwInsertedMUs( 0 ),
m_dwMUInsertions( 0 ),
m_dwMURemovals( 0 )
{
    XDBGWRN( APP_TITLE_NAME_A, "CMemoryMenu::CMemoryMenu(ex)" );

    m_uiNumItems = MEMORYMENU_ITEM_NUM_ITEMS;
    SetSelectedItem( 0 );

    // Initialize our Memory Units
    m_MemoryUnits[0].SetPortSlot( XDEVICE_PORT0, XDEVICE_TOP_SLOT );
    m_MemoryUnits[1].SetPortSlot( XDEVICE_PORT0, XDEVICE_BOTTOM_SLOT );
    m_MemoryUnits[2].SetPortSlot( XDEVICE_PORT1, XDEVICE_TOP_SLOT );
    m_MemoryUnits[3].SetPortSlot( XDEVICE_PORT1, XDEVICE_BOTTOM_SLOT );
    m_MemoryUnits[4].SetPortSlot( XDEVICE_PORT2, XDEVICE_TOP_SLOT );
    m_MemoryUnits[5].SetPortSlot( XDEVICE_PORT2, XDEVICE_BOTTOM_SLOT );
    m_MemoryUnits[6].SetPortSlot( XDEVICE_PORT3, XDEVICE_TOP_SLOT );
    m_MemoryUnits[7].SetPortSlot( XDEVICE_PORT3, XDEVICE_BOTTOM_SLOT );
}


// Destructor
CMemoryMenu::~CMemoryMenu()
{
    // Unmount any MU's that are still mounted
    for( unsigned int x = 0; x < 8; x++ )
    {
        if( m_MemoryUnits[x].IsMounted() )
        {
            m_MemoryUnits[x].Unmount();
        }
    }
}


// Draws a menu on to the screen
void CMemoryMenu::Action( CUDTexture* pTexture )
{
    // If the state has changed, update our texture and our previous mask
    if( XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT, &m_dwMUInsertions, &m_dwMURemovals ) || m_bUpdateTexture )
    {
        m_bUpdateTexture = TRUE;

        // Mount or Unmount our MU's
        for( unsigned int x = 0; x < ARRAYSIZE( g_wpszMUPortNames ); ++x )
        {
            // Check to see if the MU was removed
            if( m_dwMURemovals & g_dwMUBitMask[x] )
            {
                // Remove the MU from our Mask
                m_dwInsertedMUs = m_dwInsertedMUs & ( ~ g_dwMUBitMask[x] );

                // Unmount the MU
                m_MemoryUnits[x].Unmount();
            }

            // Check to see if the MU is inserted
            if( m_dwMUInsertions & g_dwMUBitMask[x] )
            {
                // Add the MU to our Mask
                m_dwInsertedMUs = m_dwInsertedMUs | g_dwMUBitMask[x];

                // Mount the MU
                m_MemoryUnits[x].Mount();
            }
        }
    }

    // Check to see if we should update the texture
    // If not, return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else // reset the texture flag to FALSE
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

    // Draw a box behind the currently highlighted choice
    // Check to see if the selector bar IS NOT on the XBox Hard Drive, and make sure the device is still plugged in
    if( ( !( m_dwInsertedMUs & g_dwMUBitMask[GetSelectedItem()] ) ) && ( GetSelectedItem() != MEMORYMENU_ITEM_XBOX_HARD_DRIVE ) )
    {
        // Determine if there is another item we can select
        SetSelectedItem( MEMORYMENU_ITEM_XBOX_HARD_DRIVE ); // Default to the Xbox Hard Drive
        
        for( int y = 0; y < ( XBOX_CONSOLE_NUM_PORTS * XBOX_CONTROLLER_NUM_SLOTS ); ++y )
        {
            if( m_dwInsertedMUs & g_dwMUBitMask[y] )
            {
                SetSelectedItem( y );
                break;
            }
        }
    }

    // Draw the selector bar
    float X1Pos = MENUBOX_SELECTOR_X1;
    float Y1Pos = MENUBOX_MAINAREA_Y1 + MENUBOX_MAINAREA_BORDERWIDTH_TOP + ( ( MENUBOX_ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * GetSelectedItem() ) - MENUBOX_SELECTOR_BORDER_WIDTH;
    float X2Pos = MENUBOX_SELECTOR_X2;
    float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * MENUBOX_SELECTOR_BORDER_WIDTH );

    pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, SCREEN_DEFAULT_SELECTOR_COLOR );

    // Draw the Menu items
    for( unsigned int x = 0; x < MEMORYMENU_ITEM_NUM_ITEMS; ++x )
    {
        DWORD dwColor;                  // Used to display the memory area in the proper color        
        WCHAR pwszAreaName[MAX_PATH];   // Used to display the name of the Area on the screen
        
        ZeroMemory( pwszAreaName, sizeof( WCHAR ) * MAX_PATH );


        // Calculate the position of the item on the menu
        float XPos = MENUBOX_MAINAREA_X1 + MENUBOX_MAINAREA_BORDERWIDTH_LEFT;
        float YPos = MENUBOX_MAINAREA_Y1 + MENUBOX_MAINAREA_BORDERWIDTH_TOP + ( ( MENUBOX_ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * x );

        //
        // Set the default colors for our options
        //

        // If the current item is the selected item, let's change it's color
        if( GetSelectedItem() == (int)x )
        //
        // Yes, the current Memory Area is selected
        //
        {
            dwColor = SCREEN_SELECTED_OPTION_COLOR;
        }
        else
        //
        // No, the Memory Area is not selected
        //
        {
            dwColor = SCREEN_ACTIVE_OPTION_COLOR;
        }

        // Check to see if we are dealing with the hard drive
        if( x != MEMORYMENU_ITEM_XBOX_HARD_DRIVE )
        //
        // No, we are dealing with a Memory Unit
        //
        {
            if( m_dwInsertedMUs & g_dwMUBitMask[x] )
            //
            // Yes, the MU is inserted
            //
            {
                // Check the format state of the MU
                if( !m_MemoryUnits[x].IsFormatted() )
                //
                // No, the MU is NOT formatted
                {
                    dwColor = SCREEN_UNFORMATTED_OPTION_COLOR;
                }
            }
            else
            //
            // No, the MU is not inserted
            //
            {
                dwColor = SCREEN_INACTIVE_OPTION_COLOR;
            }

            // Setup a buffer to hold the on-screen display for the MU
            int NumChars = 0;

            // Determine if we should put in place the drive letter & Disk Space
            if( m_MemoryUnits[x].IsMounted() )
            {
                // Set the color of the MU
                dwColor = SCREEN_MOUNTED_OPTION_COLOR;

                // Insert the Drive Letter in to our path variable
                NumChars = _snwprintf( pwszAreaName, MAX_PATH - 1, L"%c: - ", m_MemoryUnits[x].GetUDataDrive() );

                // Get the Free Space to display on the screen
                NumChars += _snwprintf( pwszAreaName + NumChars, ( MAX_PATH - 1 ) - NumChars, L"(%d/%d) ", m_MemoryUnits[x].GetFreeBlocks(), m_MemoryUnits[x].GetTotalBlocks() );
            }

            // Determine if we should draw the MU Name
            WCHAR pwszCurrentMUName[XBOX_MU_NAME_LENGTH+1];
            ZeroMemory( pwszCurrentMUName, sizeof( WCHAR ) * ( XBOX_MU_NAME_LENGTH + 1 ) );

            m_MemoryUnits[x].GetName( pwszCurrentMUName, XBOX_MU_NAME_LENGTH );

            if( pwszCurrentMUName[0] != '\0' )
            {
                NumChars += _snwprintf( pwszAreaName + NumChars, ( MAX_PATH - 1 ) - NumChars, L"(%s)", pwszCurrentMUName );
            }
            else // Draw the Generic Name
            {
                NumChars += _snwprintf( pwszAreaName + NumChars, ( MAX_PATH - 1 ) - NumChars, L"%s", g_wpszMUPortNames[x] );

                // Determine if we should display the 'not formatted' message
                // if( ( '\0' == m_acDriveLetters[x] ) && ( m_dwInsertedMUs & g_dwMUBitMask[x] ) )
                if( ( m_dwInsertedMUs & g_dwMUBitMask[x] ) && ( !m_MemoryUnits[x].IsFormatted() ) )
                {
                    NumChars += _snwprintf( pwszAreaName + NumChars, ( MAX_PATH - 1 ) - NumChars, L" (Not Formatted)" );
                }
            }
        }
        else
        //
        // Yes, we are dealing with the Xbox Hard Drive
        //
        {
            _snwprintf( pwszAreaName, ( MAX_PATH - 1 ), L"(%d/%d) %s", g_HardDrive.GetFreeBlocks(), g_HardDrive.GetTotalBlocks(), g_wpszMemoryMenuItems[x] );
        }
        
        // Draw the Memory Area name to our screen
        pTexture->DrawText( XPos, YPos, dwColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", pwszAreaName );
    }

    // Unlock our texture and restore our render target
    pTexture->Unlock();
}


// Handle any requests for the joystick (thumb-pad)
void CMemoryMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CMemoryMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = INPUT_KEYPRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = INPUT_KEYPRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            for( int x = GetSelectedItem() - 1; x >= 0; --x )
            {
                if( m_dwInsertedMUs & g_dwMUBitMask[x] )
                {
                    // Since we are changing the selection, mark our texture for updating
                    m_bUpdateTexture = TRUE;

                    SetSelectedItem( x );
                    break;
                }
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Check to see if there are any options below us
            if( GetSelectedItem() < ( MEMORYMENU_ITEM_NUM_ITEMS - 1 ) )
            {
                // Since we are changing the selection, mark our texture for updating
                m_bUpdateTexture = TRUE;
                
                // Look through the memory units (if necessary) and choose a new one if it
                // is inserted, and lower on the list
                for( int x = GetSelectedItem() + 1; x < MEMORYMENU_ITEM_NUM_ITEMS; ++x )
                {
                    // Check to see if we are dealing with the hard drive -- Special Case
                    if( x == MEMORYMENU_ITEM_XBOX_HARD_DRIVE )
                    //
                    // Yes, we are dealing with the Hard Drive
                    //
                    {
                        SetSelectedItem( x );

                        break;
                    }
                    else
                    //
                    // No, we are dealing with an MU
                    //
                    {
                        if( m_dwInsertedMUs & g_dwMUBitMask[x] )
                        {
                            SetSelectedItem( x );
                     
                            break;
                        }
                    }
                }
            }
            break;
        }
    }
}


// Handles input (of the BUTTONS) for the current menu
void CMemoryMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            switch( GetSelectedItem() )
            {
            case MEMORYMENU_ITEM_XBOX_HARD_DRIVE:
                {
                    Leave( &m_MenuHDOptions );
                }
                break;
            default:    // Memory Unit
                {
                    m_MenuMUOptions.SetMemoryUnit( &m_MemoryUnits[GetSelectedItem()] );
                    Leave( &m_MenuMUOptions );
                }
                break;
            }

            // Fill up the XDisk
            // FillDisk( FILE_DATA_DRIVE_A "\\" );

            // Refresh our Texture
            // m_bUpdateTexture = TRUE;

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                Leave( GetParent() );
            }
            break;
        }
    }
}


// Initialize the Menu
HRESULT CMemoryMenu::Init( IDirect3DDevice8* pD3DDevice, char* menuFileName )
{
    XDBGWRN( APP_TITLE_NAME_A, "CMemoryMenu::Init()" );

    CMenuScreen::Init( pD3DDevice, menuFileName );

    // Initialize our sub-menus
    m_MenuMUOptions.SetParent( this );
    m_MenuMUOptions.Init( pD3DDevice, MENU_MUOPTIONS_MENU_FILENAME_A );

    m_MenuHDOptions.SetParent( this );
    m_MenuHDOptions.Init( pD3DDevice, MENU_HDOPTIONS_MENU_FILENAME_A );

    return S_OK;
}


/*
// Should be called whenever a user leaves the menu
void CMemoryMenu::Leave( CXItem* pItem )
{
    // Default our selection to the top item when the user returns
    // SetSelectedItem( 0 );

    g_pCurrentScreen = pItem;
}
*/

// This will be called whenever the user enters this menu
void CMemoryMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    //
    // Update the MU's on our screen
    //

    // Unmount any previously mounted MU
    for( unsigned int x = 0; x < 8; ++x )
    {
        if( m_MemoryUnits[x].IsMounted() )
        {
            m_MemoryUnits[x].Unmount();
        }
    }

    // Mount any MU that is inserted
    m_dwInsertedMUs = XGetDevices( XDEVICE_TYPE_MEMORY_UNIT );
    for( unsigned int x = 0; x < 8; ++x )
    {
        if( m_dwInsertedMUs & g_dwMUBitMask[x] )
        {
            m_MemoryUnits[x].Mount();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\PolyObject.h ===
/******************************************************
** polyobject.h
** 
** A basic polygon object capable of rendering itself
**
** 03/09/2001
** by James N. Helm
******************************************************/

#ifndef _POLYOBJECT_H_
#define _POLYOBJECT_H_

class CPolyObject
{
public:
    // Constructors and Destructors
    CPolyObject();
    ~CPolyObject();

    // Public Properties
    
    // Public Methods
    void Initialize( IDirect3DDevice8* pD3DDevice );    // Setup our Vertex Buffer and Poly Points
    void Render( IDirect3DDevice8* pD3DDevice );        // Render the poly to the backbuffer

private:
    // Private Properties
    IDirect3DVertexBuffer8* m_pVertexBuffer;            // Vertex buffer for our Polygon

    // Private Methods
    void CleanUp();                                     // Clean up any memory we have allocated
};

#endif // _POLYOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\menuscreen.h ===
/*****************************************************
*** menuscreen.h
***
*** Header file for our XShell Generic menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** December 1st , 2000
***
*****************************************************/

#ifndef _MENUSCREEN_H_
#define _MENUSCREEN_H_

#include "screenitems.h"

class CMenuScreen : public CXItem
{
public:
    // Constructors and Destructors
    CMenuScreen( CXItem* pParent );
    virtual ~CMenuScreen();

    // Public Methods
    virtual void Action( CUDTexture* pTexture );
    virtual void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    virtual void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    virtual void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    virtual HRESULT      Init( IDirect3DDevice8* pD3DDevice, char* menuFileName );      // Initialize the Menu
    virtual void         Enter();                                                       // This should be called whenever the menu is entered or activated
    virtual unsigned int GetNumItems() { return m_uiNumItems; };                        // Return the number of menu items on our current screen
    virtual int          GetSelectedItem() const { return m_nSelectedItem; };           // Get the indext of the currently selected item on the screen
    virtual unsigned int GetFontHeightOfItem() const { return m_uiFontHeightOfItem; };  // The font height of a screen item
    virtual HRESULT      SetSelectedItem( int itemNumber );                             // Set the currently selected item on the screen

protected:
    CLinkedList< CScreenItem* >       m_ScreenItems;        // List of pointers to screen items that will be rendered

    int               m_nSelectedItem;                      // The currently selected item in the list
    unsigned int      m_uiFontHeightOfItem;                 // The font height of an item
    unsigned int      m_uiNumItems;                         // The number of items on the menu
    DWORD             m_keyPressDelayTimer;                 // Used to temper the speed of holding down the d-pad
    DWORD             m_keyPressDelayInterval;              // The current interval to delay before processing a keypress
    int               m_nJoystickDeadZone;                  // The dead zone for the joysticks

    // Methods
    virtual void    Leave( CXItem* pItem );                     // Should be called whenever a user deactivates this item
    virtual HRESULT ImportScreenItems( char* menuFileName );    // Add item info to the current screen
    virtual HRESULT AddTextItemFromFile( FILE* menuFile );      // Add a Text Item to our Screen from a file
    virtual HRESULT AddPanelItemFromFile( FILE* menuFile );     // Add a Panel Item to our Screen from a file
    virtual HRESULT AddHeaderItemFromFile( FILE* menuFile );    // Add a Header Item to our Screen from a file
    virtual HRESULT AddLineItemFromFile( FILE* menuFile );      // Add a Line Item to our Screen from a file
    virtual HRESULT AddOutlineItemFromFile( FILE* menuFile );   // Add a Outline Item to our Screen from a file
    virtual HRESULT AddBitmapItemFromFile( FILE* menuFile );    // Add a Bitmap Item to our Screen from a file
    virtual void CleanUp();                                     // Destroy any memory the menu may have allocated
};

#endif // _MENUSCREEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\menuscreen.cpp ===
/*****************************************************
*** menuscreen.cpp
***
*** CPP file for our XShell Generic menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** December 1st, 2000
***
*****************************************************/

#include "stdafx.h"
#include "menuscreen.h"

extern CXItem* g_pCurrentScreen;        // Pointer to the current menu object

// Constructor
CMenuScreen::CMenuScreen( CXItem* pParent )
: CXItem( pParent ),
m_nSelectedItem( 0 ),
m_uiFontHeightOfItem( 0 ),
m_uiNumItems( 0 ),
m_nJoystickDeadZone( INPUT_JOYSTICK_DEADZONE )
{
    m_ScreenItems.SetDeleteDataItem( TRUE );

    m_keyPressDelayTimer = GetTickCount();
}


// Destructor
CMenuScreen::~CMenuScreen()
{
    // Make sure we delete any memory we may have created
    CleanUp();
}


// Destroy any memory the menu may have allocated
void CMenuScreen::CleanUp()
{
    m_ScreenItems.EmptyList();
}


// Draws a menu on to the screen
void CMenuScreen::Action( CUDTexture* pTexture )
{
    pTexture->Lock();

    // Get our active D3D Device pointer
    IDirect3DDevice8* pD3DDevice = NULL;
    pTexture->GetTexture()->GetDevice( &pD3DDevice );

    // Draw the screen items
    m_ScreenItems.MoveTo( 0 ); // Start at the 1st Item
    for( unsigned int x = 0; x < m_ScreenItems.GetNumItems(); ++x )
    {
        m_ScreenItems.GetCurrentNode()->Render( pD3DDevice, pTexture );
        m_ScreenItems.MoveNext();
    }

    if( NULL != pD3DDevice )
    {
        pD3DDevice->Release();
        pD3DDevice = NULL;
    }

    pTexture->Unlock();
}


// Add the screen and text of the item that will be drawn on to the screen
// to our object
HRESULT CMenuScreen::ImportScreenItems( char* menuFileName )
{
    XDBGWRN( APP_TITLE_NAME_A, "CMenuScreen::ImportScreenItems()" );

    if( !menuFileName )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMenuScreen::ImportScreenItems():menuFileName not set!!" );

        return E_INVALIDARG;
    }

    FILE* menuFile = fopen( menuFileName, "r" );

    if( !menuFile )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMenuScreen::ImportScreenItems():fopen failed!! File - '%hs'", menuFileName );

        return E_FAIL;
    }

    HRESULT hr = S_OK;
    WCHAR itemType;
    BOOL bEOF = FALSE;

    while( !bEOF )
    {
        itemType = fgetwc( menuFile );
        if( feof( menuFile ) )
        {
            bEOF = TRUE;
            continue;
        }

        if( L't' == itemType )
        {
            hr = AddTextItemFromFile( menuFile );
        }
        else if( L'p' == itemType )
        {
            hr = AddPanelItemFromFile( menuFile );
        }
        else if( L'l' == itemType )
        {
            hr = AddLineItemFromFile( menuFile );
        }
        else if( L'h' == itemType )
        {
            hr = AddHeaderItemFromFile( menuFile );
        }
        else if( L'o' == itemType )
        {
            hr = AddOutlineItemFromFile( menuFile );
        }
        else if( L'i' == itemType )
        {
            hr = AddBitmapItemFromFile( menuFile );
        }

        // Move to the next line
        while( itemType = fgetwc( menuFile ) )
        {
            if( feof( menuFile ) )
            {
                bEOF = TRUE;
                break;
            }

            if( 10 == itemType )
            {
                break;
            }
        }

        // Check to see if there was a problem, and return if there was
        if( FAILED( hr ) )
        {
            fclose( menuFile );
            return hr;
        }
    }

    fclose( menuFile );

    return S_OK;
}


// Initialize the Menu
HRESULT CMenuScreen::Init( IDirect3DDevice8* pD3DDevice, char* menuFileName )
{
    XDBGWRN( APP_TITLE_NAME_A, "CMenuScreen::Init()" );

    // Clean up memory if necessary
    CleanUp();

    // Get our screen information
    ImportScreenItems( menuFileName );

    // Get the height of the font
    unsigned int decent;
    GetFontSize( &m_uiFontHeightOfItem, &decent );

    return S_OK;
}


// Add a text item to our current screen from a file
HRESULT CMenuScreen::AddTextItemFromFile( FILE* menuFile )
{
    CTextItem* pTextItem = new CTextItem;
    if( !pTextItem )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMenuScreen::AddTextItemFromFile():Out of memory!!" );

        return E_OUTOFMEMORY;
    }

    float fXPos, fYPos;
    DWORD dwFGColor, dwBGColor;
    WCHAR pwszText[SCREEN_ITEM_TEXT_LENGTH];

    ZeroMemory( pwszText, sizeof( WCHAR ) * SCREEN_ITEM_TEXT_LENGTH );

    fscanf( menuFile,   "%f", &fXPos );
    fscanf( menuFile,   "%f", &fYPos );
    fscanf( menuFile,   "%X", &dwFGColor );
    fscanf( menuFile,   "%X", &dwBGColor );
    fwscanf( menuFile, L"%s", pwszText );

    // Convert any "_" characters in to spaces
    WCHAR* pChar;
    while( pChar = wcsstr( pwszText, L"_" ) )
    {
        *pChar = L' ';
    }

    // Update the item with the information that we pulled from the file
    pTextItem->UpdateItem( pwszText, fXPos, fYPos, dwFGColor, dwBGColor );

    // Add the item to our list of Screen Items
    m_ScreenItems.AddNode( pTextItem );

    return S_OK;
}


// Add a panel item to our current screen
HRESULT CMenuScreen::AddPanelItemFromFile( FILE* menuFile )
{
    CPanelItem* pPanelItem = new CPanelItem;
    if( !pPanelItem )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMenuScreen::AddPanelItemFromFile():Out of memory!!" );

        return E_OUTOFMEMORY;
    }

    float fX1Pos, fY1Pos, fX2Pos, fY2Pos;
    DWORD dwColor;

    fscanf( menuFile,   "%f", &fX1Pos );
    fscanf( menuFile,   "%f", &fY1Pos );
    fscanf( menuFile,   "%f", &fX2Pos );
    fscanf( menuFile,   "%f", &fY2Pos );
    fscanf( menuFile,   "%x", &dwColor );

    // Update the item with the information that we pulled from the file
    pPanelItem->UpdateItem( fX1Pos, fY1Pos, fX2Pos, fY2Pos, dwColor );

    // Add the item to our list of Screen Items
    m_ScreenItems.AddNode( pPanelItem );

    return S_OK;
}


// Add a line to our current screen
HRESULT CMenuScreen::AddLineItemFromFile( FILE* menuFile )
{
    CLineItem* pLineItem = new CLineItem;
    if( !pLineItem )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMenuScreen::AddLineItemFromFile():Out of memory!!" );

        return E_OUTOFMEMORY;
    }

    float fX1Pos, fY1Pos, fX2Pos, fY2Pos, fWidth;
    DWORD dwColor;

    fscanf( menuFile,   "%f", &fX1Pos );
    fscanf( menuFile,   "%f", &fY1Pos );
    fscanf( menuFile,   "%f", &fX2Pos );
    fscanf( menuFile,   "%f", &fY2Pos );
    fscanf( menuFile,   "%f", &fWidth );
    fscanf( menuFile,   "%x", &dwColor );

    // Update the item with the information that we pulled from the file
    pLineItem->UpdateItem( fX1Pos, fY1Pos, fX2Pos, fY2Pos, fWidth, dwColor );

    // Add the item to our list of Screen Items
    m_ScreenItems.AddNode( pLineItem );

    return S_OK;
}


// Add a line to our current screen
HRESULT CMenuScreen::AddOutlineItemFromFile( FILE* menuFile )
{
    COutlineItem* pOutlineItem = new COutlineItem;
    if( !pOutlineItem )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMenuScreen::AddOutlineItemFromFile():Out of memory!!" );

        return E_OUTOFMEMORY;
    }

    float fX1Pos, fY1Pos, fX2Pos, fY2Pos, fWidth;
    DWORD dwColor;

    fscanf( menuFile,   "%f", &fX1Pos );
    fscanf( menuFile,   "%f", &fY1Pos );
    fscanf( menuFile,   "%f", &fX2Pos );
    fscanf( menuFile,   "%f", &fY2Pos );
    fscanf( menuFile,   "%f", &fWidth );
    fscanf( menuFile,   "%x", &dwColor );

    // Update the item with the information that we pulled from the file
    pOutlineItem->UpdateItem( fX1Pos, fY1Pos, fX2Pos, fY2Pos, fWidth, dwColor );

    // Add the item to our list of Screen Items
    m_ScreenItems.AddNode( pOutlineItem );

    return S_OK;
}


// Add a Bitmap Item to our Screen from a file
HRESULT CMenuScreen::AddBitmapItemFromFile( FILE* menuFile )
{
    CBitmapItem* pBitmapItem = new CBitmapItem;
    if( !pBitmapItem )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMenuScreen::AddBitmapItemFromFile():Out of memory!!" );

        return E_OUTOFMEMORY;
    }

    int x, y;
    char filename[MAX_PATH];
    char imagename[MAX_PATH];
    ZeroMemory( filename, MAX_PATH );
    ZeroMemory( imagename, MAX_PATH );

    fscanf( menuFile,   "%d", &x );
    fscanf( menuFile,   "%d", &y );
    fscanf( menuFile,   "%s", imagename );

    _snprintf( filename, MAX_PATH, "%s\\%s", FILE_DATA_IMAGE_DIRECTORY_A, imagename );

    // Update the item with the information that we pulled from the file
    pBitmapItem->UpdateItem( filename, x, y );

    // Add the item to our list of Screen Items
    m_ScreenItems.AddNode( pBitmapItem );

    return S_OK;

}

// Add a panel item to our current screen
HRESULT CMenuScreen::AddHeaderItemFromFile( FILE* menuFile )
{
    CTextItem* pHeaderItem = new CTextItem;
    if( !pHeaderItem )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMenuScreen::AddHeaderItemFromFile():Out of memory!!" );

        return E_OUTOFMEMORY;
    }

    float fXPos, fYPos;
    DWORD dwFGColor, dwBGColor;
    WCHAR pwszText[SCREEN_ITEM_TEXT_LENGTH];

    ZeroMemory( pwszText, sizeof( WCHAR ) * SCREEN_ITEM_TEXT_LENGTH );

    fscanf( menuFile,   "%f", &fXPos );
    fscanf( menuFile,   "%f", &fYPos );
    fscanf( menuFile,   "%X", &dwFGColor );
    fscanf( menuFile,   "%X", &dwBGColor );
    fwscanf( menuFile, L"%s", pwszText );

    // Convert any "_" characters in to spaces
    WCHAR* pChar;
    while( pChar = wcsstr( pwszText, L"_" ) )
    {
        *pChar = L' ';
    }

    // Update the item with the information that we pulled from the file
    pHeaderItem->UpdateItem( pwszText, fXPos, fYPos, dwFGColor, dwBGColor );

    // Add the item to our list of Screen Items
    m_ScreenItems.AddNode( pHeaderItem );

    return S_OK;
}


// Handles input (of the CONTROLS) for the current menu
void CMenuScreen::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = INPUT_KEYPRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = INPUT_KEYPRESS_REPEAT_DELAY;
    }

    // Handle Controls being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() > 0 )
                {
                    m_bUpdateTexture = TRUE;

                    SetSelectedItem( GetSelectedItem() - 1 );
                }
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( (unsigned int)GetSelectedItem() < ( GetNumItems() - 1 ) )
                {
                    m_bUpdateTexture = TRUE;

                    SetSelectedItem( GetSelectedItem() + 1 );
                }
            }
            break;
        }
    }
}


// Handles input (of the BUTTONS) for the current menu
void CMenuScreen::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                Leave( GetParent() );
            }
            break;
        }
    }
}


// Handle any requests for the joystick (thumb-pad)
void CMenuScreen::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Yxc
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Sets the currently selected item on our screen
HRESULT CMenuScreen::SetSelectedItem( int itemNumber )
{
    if( ( itemNumber < 0 ) || ( (unsigned int)itemNumber > GetNumItems() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMenuScreen::SetSelectedItem():Tried to select item out of range!!" );

        return E_INVALIDARG;
    }

    m_nSelectedItem = itemNumber;

    return S_OK;
}


// Should be called whenever a user enters or activates this menu
void CMenuScreen::Enter()
{
    // Also signal the texture to be updated when a user enters a menu
    m_bUpdateTexture = TRUE;
}


// Should be called whenever a user leaves the menu
void CMenuScreen::Leave( CXItem* pItem )
{
    g_pCurrentScreen = pItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\MUConfig.cpp ===
#include "stdafx.h"
#include "polyobject.h"
#include "rootmenu.h"
#include "time.h"

// Forward declarations
void Render();              // Render the video on to our screen and present it to the user
void CleanUp();             // Clean up memory, etc, when neccessary
BOOL Initialize();          // Initialize anything necessary for the MU Config program
BOOL InitializeD3D();       // Initalize D3D to be used by our application
void ProcessInput( void );  // Handle input and pass off to our Menus

// Globals
USBManager        g_USBDevices;                     // Handles all USB Device input/output
IDirect3DDevice8* g_pD3DDevice          = NULL;     // Pointer to our Direct3D Device Object
CPolyObject       g_mainDisplayPoly;                // Our main display (poly) object
CUDTexture        g_mainDisplayTexture;             // Out main display (texture) object
CXItem*           g_pCurrentScreen      = NULL;     // Pointer to the current menu object
CXItem*           g_pPrevScreen         = NULL;     // Used to determine when a user enters a new menu
extern XFONT*            g_pFont               = NULL;     // Our Default Font Pointer
CRootMenu         g_MenuRoot( NULL );				// Our root menu screen
CKeypadMenu       g_MenuKeypad( NULL );             // Virtual Keypad Menu to be used by all screens
CKeyboardMenu     g_MenuKeyboard( NULL );           // Virtual Keyboard Menu to be used by all screens
CHardDrive        g_HardDrive;                      // Xbox Hard Drive
CXSettings        g_XboxSettings;                   // Xbox Settings Object

void _cdecl main()
{
    XDBGWRN( APP_TITLE_NAME_A, "main() Entered..." );

    // Initialize the Application
    if( !Initialize() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "main():Failed to initialize!!" );

        return; // Should never return from main.  This is a bad situation
    }

    // Render Loop
    while( TRUE )
    {
        // If the user switched menus, make sure we call "Enter" for the new menu
        if( g_pPrevScreen != g_pCurrentScreen )
        {
            g_pPrevScreen = g_pCurrentScreen;
            g_pCurrentScreen->Enter();
        }

        // Process any actions on our texture
        g_pCurrentScreen->Action( &g_mainDisplayTexture );

        // Render the video on our screen and present it to the user
        Render();

        // Process any input from the user
        ProcessInput();
    }

    XDBGWRN( APP_TITLE_NAME_A, "main() Exiting." );
}

void Render()
{
    g_pD3DDevice->Clear( 0, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0 );
    g_pD3DDevice->BeginScene();

    // Render the main screen object here
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    g_pD3DDevice->SetTexture( 0, g_mainDisplayTexture.GetTexture() );
    g_mainDisplayPoly.Render( g_pD3DDevice );
    g_pD3DDevice->SetTexture( 0, NULL );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    g_pD3DDevice->EndScene();
    g_pD3DDevice->Present( NULL, NULL, NULL, NULL );
}


// Clean up memory, etc, when neccessary
void CleanUp()
{
    // Clean up our D3D Device object
    if( g_pD3DDevice )
    {
        g_pD3DDevice->Release();
        g_pD3DDevice = NULL;
    }

    if( g_pFont )
    {
        XFONT_Release( g_pFont );
        g_pFont = NULL;
    }
}


// Initialize anything necessary for the MU Config program
BOOL Initialize()
{
    // Make sure our random number generation is truly random
    srand( (unsigned int)time( NULL ) );

    // Set the file cache size
    XSetFileCacheSize( FILE_DATA_CACHE_SIZE );

    // Get any launch info and display it in to the debugger
    DWORD dwLDataType;
    LAUNCH_DATA lData;
    ZeroMemory( &lData, sizeof( lData ) );

    if( ERROR_SUCCESS == XGetLaunchInfo( &dwLDataType, &lData ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Received Launch Data:" );

        if( LDT_FROM_DASHBOARD == dwLDataType )
        {
            LD_FROM_DASHBOARD* pDashData = (LD_FROM_DASHBOARD*)&lData;
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DASHBOARD" );
            XDBGWRN( APP_TITLE_NAME_A, "  Context - '%d'", pDashData->dwContext );

        }
        else if( LDT_FROM_DEBUGGER_CMDLINE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from DEBUGGER CMDLINE" );
        }
        else if( LDT_TITLE == dwLDataType )
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from TITLE" );
        }
        else
        {
            XDBGWRN( APP_TITLE_NAME_A, "  Data from UNKNOWN" );
        }
    }

    // Initialize Direct3D
    if( !InitializeD3D() )
    {
        XDBGWRN( APP_TITLE_NAME_A, "Initialize():Failed to InitializeD3D!!" );

        return FALSE;
    }

    ////////////////////////////////////////
    // Setup and Initialize our Default FONT
    ////////////////////////////////////////
    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &g_pFont );

    if( g_pFont )
    {
        // XFONT_SetDrawingSurface( m_BackBuffer );
        XFONT_SetTextColor( g_pFont, SCREEN_DEFAULT_FOREGROUND_COLOR );
        XFONT_SetBkColor( g_pFont, SCREEN_DEFAULT_BACKGROUND_COLOR );
        XFONT_SetTextHeight( g_pFont, SCREEN_DEFAULT_FONT_HEIGHT );
        XFONT_SetTextAntialiasLevel( g_pFont, SCREEN_DEFAULT_FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( g_pFont, SCREEN_DEFAULT_FONT_STYLE );
    }
    else
    {
        XDBGWRN( APP_TITLE_NAME_A, "Init():Failed to Initialize our Font!!" );
    }

    // Create our display poly and our display texture
    g_mainDisplayPoly.Initialize( g_pD3DDevice );
    g_mainDisplayTexture.Initialize( g_pD3DDevice, NULL, 1024, 1024 );

    // Initialize our menus
    g_MenuRoot.SetParent( NULL );
    g_MenuRoot.Init( g_pD3DDevice, MENU_ROOT_MENU_FILENAME_A );

    g_MenuKeypad.SetParent( NULL );
    g_MenuKeypad.Init( g_pD3DDevice, MENU_KEYPAD_MENU_FILENAME_A );

    g_MenuKeyboard.SetParent( NULL );
    g_MenuKeyboard.Init( g_pD3DDevice, MENU_KEYBOARD_MENU_FILENAME_A );

	// Set the root menu
    g_pCurrentScreen = &g_MenuRoot;

    return TRUE;
}


// Initalize D3D to be used by our application
BOOL InitializeD3D()
{
    IDirect3D8* pD3D;
    HRESULT hr = S_OK;

    // Create our Direct3D Object
    pD3D = Direct3DCreate8( D3D_SDK_VERSION );
    if( NULL == pD3D )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Object!!" );

        return FALSE;
    }

    // Create our D3D Device Object
    D3DPRESENT_PARAMETERS d3dpp;
	ZeroMemory( &d3dpp, sizeof( d3dpp ) );

    d3dpp.BackBufferWidth                 = SCREEN_WIDTH;
    d3dpp.BackBufferHeight                = SCREEN_HEIGHT;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.MultiSampleType                 = D3DMULTISAMPLE_4_SAMPLES;
    d3dpp.BackBufferCount                 = 1;

    d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
    d3dpp.Windowed                        = FALSE;                   // Must be FALSE for Xbox
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.EnableAutoDepthStencil          = FALSE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
	d3dpp.FullScreen_RefreshRateInHz      = D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE; // D3DPRESENT_INTERVAL_IMMEDIATE;

    if ( FAILED ( hr = pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                           D3DDEVTYPE_HAL,
                                           NULL,
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                           &d3dpp,
                                           &g_pD3DDevice ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to create our D3D Device Object!!" );
    }

    // Release the D3D Object
    // It's ok to simply release this object, as we know we cannot be here if the D3D Object failed creation
    pD3D->Release();
    pD3D = NULL;

    // If the device failed to create, simply abort the rest of the D3D Initialization
    if( !g_pD3DDevice )
    {
        return FALSE;
    }

    // Create our Viewport
    D3DVIEWPORT8 D3DViewport;

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = SCREEN_WIDTH;
    D3DViewport.Height = SCREEN_HEIGHT;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( hr = g_pD3DDevice->SetViewport( &D3DViewport ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "InitializeD3D():Failed to set the D3D Viewport!!" );
    }

    // Set our Renderstates and our Texture Stage States
    //BUGBUG: Tweak these and remove the ones uneccessary
    g_pD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    g_pD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    g_pD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    g_pD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    g_pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE);
    g_pD3DDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
    g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );

    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    return TRUE;
}


// Handle input from the user
void ProcessInput( void )
{
    BOOL bFirstPress;
    BOOL bFirstPress2;
    BOOL bFirstXPress;
    BOOL bFirstYPress;
    BOOL bControlPressed = FALSE;   // Used to deal with the multiple controls mappings (A/START, B/BACK)
    BOOL bButtonPressed = FALSE;    // Used to deal with the multiple controls mappings (A/START, B/BACK)
    int  nThumbY = 0;
    int  nThumbX = 0;

    // Update the state of all controllers
    g_USBDevices.ProcessInput();

    // START CONTROL / A BUTTON
    bControlPressed = g_USBDevices.IsControlPressed( PORT_ANY, CONTROL_START, &bFirstPress );
    bButtonPressed = g_USBDevices.IsButtonPressed( PORT_ANY, BUTTON_A, INPUT_BUTTON_THRESHOLD, &bFirstPress2 );
    if( bControlPressed || bButtonPressed )
    {
        // Check to see if one of the buttons is a 'repeat' press.  If so, report FALSE for first press
        if( bControlPressed && ( !bFirstPress ) )
        {
            bFirstPress = FALSE;
        }
        else if( bButtonPressed && ( !bFirstPress2 ) )
        {
            bFirstPress = FALSE;
        }
        else
        {
            bFirstPress = TRUE;
        }

		// Rumble
		// g_USBDevices.Rumble( PORT_ANY, CONTROLLER_RUMBLE_SPEED, CONTROLLER_RUMBLE_MILLISECOND_TIME );

        // For the "Start" Button, we will send the "A" button signal to the menu, so that act identically
        g_pCurrentScreen->HandleInput( BUTTON_A, bFirstPress );
    }

    // BACK CONTROL / B BUTTON
    bControlPressed = g_USBDevices.IsControlPressed( PORT_ANY, CONTROL_BACK, &bFirstPress );
    bButtonPressed = g_USBDevices.IsButtonPressed( PORT_ANY, BUTTON_B, INPUT_BUTTON_THRESHOLD, &bFirstPress2 );
    if( bControlPressed || bButtonPressed )
    {
        // Check to see if one of the buttons is a 'repeat' press.  If so, report FALSE for first press
        if( bControlPressed && ( !bFirstPress ) )
        {
            bFirstPress = FALSE;
        }
        else if( bButtonPressed && ( !bFirstPress2 ) )
        {
            bFirstPress = FALSE;
        }
        else
        {
            bFirstPress = TRUE;
        }

		// Rumble
		// g_USBDevices.Rumble( PORT_ANY, CONTROLLER_RUMBLE_SPEED, CONTROLLER_RUMBLE_MILLISECOND_TIME );

        // For the "Back" Button, we will send the "B" button signal to the menu, so that act identically
        g_pCurrentScreen->HandleInput( BUTTON_B, bFirstPress );
    }

    // X BUTTON
    if( g_USBDevices.IsButtonPressed( PORT_ANY, BUTTON_X, INPUT_BUTTON_THRESHOLD, &bFirstPress ) )
    {
        g_pCurrentScreen->HandleInput( BUTTON_X, bFirstPress );
    }

    // Y BUTTON
    if( g_USBDevices.IsButtonPressed( PORT_ANY, BUTTON_Y, INPUT_BUTTON_THRESHOLD, &bFirstPress ) )
    {
        g_pCurrentScreen->HandleInput( BUTTON_Y, bFirstPress );
    }

    // BLACK BUTTON
    if( g_USBDevices.IsButtonPressed( PORT_ANY, BUTTON_BLACK, INPUT_BUTTON_THRESHOLD, &bFirstPress ) )
    {
        g_pCurrentScreen->HandleInput( BUTTON_BLACK, bFirstPress );
    }

    // WHITE BUTTON
    if( g_USBDevices.IsButtonPressed( PORT_ANY, BUTTON_WHITE, INPUT_BUTTON_THRESHOLD, &bFirstPress ) )
    {
        g_pCurrentScreen->HandleInput( BUTTON_WHITE, bFirstPress );
    }

    // LEFT TRIGGER BUTTON
    if( g_USBDevices.IsButtonPressed( PORT_ANY, BUTTON_LEFT_TRIGGER, INPUT_BUTTON_THRESHOLD, &bFirstPress ) )
    {
        g_pCurrentScreen->HandleInput( BUTTON_LEFT_TRIGGER, bFirstPress );
    }

    // UP DPAD
    if( g_USBDevices.IsControlPressed( PORT_ANY, CONTROL_DPAD_UP, &bFirstPress ) )
    {
        g_pCurrentScreen->HandleInput( CONTROL_DPAD_UP, bFirstPress );
    }

    // DOWN DPAD
    if( g_USBDevices.IsControlPressed( PORT_ANY, CONTROL_DPAD_DOWN, &bFirstPress ) )
    {
        g_pCurrentScreen->HandleInput( CONTROL_DPAD_DOWN, bFirstPress );
    }

    // LEFT DPAD
    if( g_USBDevices.IsControlPressed( PORT_ANY, CONTROL_DPAD_LEFT, &bFirstPress ) )
    {
        g_pCurrentScreen->HandleInput( CONTROL_DPAD_LEFT, bFirstPress );
    }

    // RIGHT DPAD
    if( g_USBDevices.IsControlPressed( PORT_ANY, CONTROL_DPAD_RIGHT, &bFirstPress ) )
    {
        g_pCurrentScreen->HandleInput( CONTROL_DPAD_RIGHT, bFirstPress );
    }

    // LEFT THUMB STICK
    nThumbY = g_USBDevices.GetJoystickY( PORT_ANY, JOYSTICK_LEFT, INPUT_JOYSTICK_DEADZONE, &bFirstYPress );
    nThumbX = g_USBDevices.GetJoystickX( PORT_ANY, JOYSTICK_LEFT, INPUT_JOYSTICK_DEADZONE, &bFirstXPress );
    if( ( nThumbY != 0 ) || ( nThumbX != 0 ) )
    {
        g_pCurrentScreen->HandleInput( JOYSTICK_LEFT, nThumbY, nThumbX, bFirstYPress, bFirstXPress );
    }

    // RIGHT THUMB STICK
    nThumbY = g_USBDevices.GetJoystickY( PORT_ANY, JOYSTICK_RIGHT, INPUT_JOYSTICK_DEADZONE, &bFirstYPress );
    nThumbX = g_USBDevices.GetJoystickX( PORT_ANY, JOYSTICK_RIGHT, INPUT_JOYSTICK_DEADZONE, &bFirstXPress );
    if( ( nThumbY != 0 ) || ( nThumbX != 0 ) )
    {
        g_pCurrentScreen->HandleInput( JOYSTICK_RIGHT, nThumbY, nThumbX, bFirstYPress, bFirstXPress );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\MUOptions.cpp ===
/*****************************************************
*** muoptions.cpp
***
*** CPP file for our Memory Unit Options menu class.
*** This menu class will allow you to perform various
*** operations on an MU.  (Format, etc)
***
*** by James N. Helm
*** March 29th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "muoptions.h"

extern void Render();                   // Render the video on to our screen and present it to the user
extern CKeypadMenu   g_MenuKeypad;      // Virtual Keypad Menu to be used by all screens
extern CKeyboardMenu g_MenuKeyboard;    // Virtual Keyboard Menu to be used by all screens
extern CHardDrive    g_HardDrive;       // Xbox Hard Drive

// Constructors
CMUOptions::CMUOptions( CXItem* pParent )
: CMenuScreen( pParent ),
m_pMemoryUnit( NULL ), 
m_bActionInitiated( FALSE ),
m_uiActionStage( 0 ),
m_dwNumTitles( 0 ),
m_dwNumSavedGames( 0 ),
m_dwSavedGameSize( 0 ),
m_dwFileSize( 0 ),
m_hThreadHandle( NULL ),
m_pwszValueBuffer( NULL ),
m_uiTopItemIndex( 0 ),
m_MenuGameTitles( NULL ),
m_MenuSaveGames( NULL )
{
    XDBGWRN( APP_TITLE_NAME_A, "CMUOptions::CMUOptions()" );

    m_uiNumItems = MUOPTIONSMENU_ITEM_NUM_ITEMS;
    SetSelectedItem( 0 );

    m_pwszValueBuffer = new WCHAR[MENU_MUOPTIONS_SAVEGAMENAME_SIZE];
    if( !m_pwszValueBuffer )
    {
        XDBGERR( APP_TITLE_NAME_A, "CMUOptions::CMUOptions():Failed to allocate memory!!" );
    }
    ZeroMemory( m_pwszValueBuffer, sizeof( WCHAR ) * MENU_MUOPTIONS_SAVEGAMENAME_SIZE );

    m_pwszSavedGameName = new WCHAR[MENU_MUOPTIONS_SAVEGAMENAME_SIZE];
    if( !m_pwszSavedGameName )
    {
        XDBGERR( APP_TITLE_NAME_A, "CMUOptions::CMUOptions():Failed to allocate memory!!" );
    }
    ZeroMemory( m_pwszSavedGameName, sizeof( WCHAR ) * MENU_MUOPTIONS_SAVEGAMENAME_SIZE );
}


// Destructor
CMUOptions::~CMUOptions()
{
    if( m_pwszValueBuffer )
    {
        delete[] m_pwszValueBuffer;
        m_pwszValueBuffer = NULL;
    }
}


// Draws a menu on to the screen
void CMUOptions::Action( CUDTexture* pTexture )
{
    // Check to see if we should update the texture
    // If not, return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else // reset the texture flag to FALSE
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

    DWORD dwItemColor = 0;
    if( m_pMemoryUnit->IsFormatted() )
    {
        // Draw a selector around the current item
        float X1Pos = MENUBOX_SELECTOR_X1;
        float Y1Pos = MENUBOX_MAINAREA_Y1 + MENUBOX_MAINAREA_BORDERWIDTH_TOP + ( ( MENUBOX_ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( GetSelectedItem() - m_uiTopItemIndex ) ) - MENUBOX_SELECTOR_BORDER_WIDTH;
        float X2Pos = MENUBOX_SELECTOR_X2;
        float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * MENUBOX_SELECTOR_BORDER_WIDTH );

        pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, SCREEN_DEFAULT_SELECTOR_COLOR );

        // Display the space information about the MU
        pTexture->DrawText( (float)MENUBOX_WINDOW_TITLE_X1 + GetStringPixelWidth( L"MU Options " ), MENUBOX_WINDOW_TITLE_Y1, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"(%d/%d)", m_pMemoryUnit->GetFreeBlocks(), m_pMemoryUnit->GetTotalBlocks() );

        dwItemColor = SCREEN_DEFAULT_FOREGROUND_COLOR;
    }
    else
    //
    // The MU is not formatted
    //
    {
        // Display the unformatted message
        pTexture->DrawText( (float)MENUBOX_WINDOW_TITLE_X1 + GetStringPixelWidth( L"MU Options " ), MENUBOX_WINDOW_TITLE_Y1, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"(unformatted)" );

        dwItemColor = SCREEN_INACTIVE_OPTION_COLOR;
    }

    // Draw the Menu Options
    for( unsigned int x = m_uiTopItemIndex; x < ( MUOPTIONS_MENU_NUM_ITEMS_TO_DISPLAY + m_uiTopItemIndex ); ++x )
    {
        // Make sure we don't try to access out of range items
        if( x == GetNumItems() )
        {
            break;
        }

        float XPos = MENUBOX_MAINAREA_X1 + MENUBOX_MAINAREA_BORDERWIDTH_LEFT;
        float YPos = MENUBOX_MAINAREA_Y1 + MENUBOX_MAINAREA_BORDERWIDTH_TOP + ( ( MENUBOX_ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( x - m_uiTopItemIndex ) );

        pTexture->DrawText( XPos, YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", g_wpszMUOptionsMenuItems[x] );
    }

    // Draw our processing message if necessary
    if( m_hThreadHandle )
    {
#define TEXT_BOX_BUFFER_SIZE    20

        pTexture->DrawBox( MENUBOX_MAINAREA_X1 + TEXT_BOX_BUFFER_SIZE, MENUBOX_MAINAREA_Y1 + TEXT_BOX_BUFFER_SIZE, MENUBOX_MAINAREA_X2 - TEXT_BOX_BUFFER_SIZE, MENUBOX_MAINAREA_Y2 - TEXT_BOX_BUFFER_SIZE, COLOR_BLACK );
        pTexture->DrawOutline( MENUBOX_MAINAREA_X1 + TEXT_BOX_BUFFER_SIZE, MENUBOX_MAINAREA_Y1 + TEXT_BOX_BUFFER_SIZE, MENUBOX_MAINAREA_X2 - TEXT_BOX_BUFFER_SIZE, MENUBOX_MAINAREA_Y2 - TEXT_BOX_BUFFER_SIZE, 2, COLOR_DARK_GREEN );
        pTexture->DrawText( SCREEN_X_CENTER - ( GetStringPixelWidth( L"Processing..." ) / 2 ), SCREEN_Y_CENTER, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"Processing..." );

        // Unlock our texture and restore our render target
        pTexture->Unlock();

        Render();

        // Start our thread on it's merry way
        ResumeThread( m_hThreadHandle );

        // Wait for the thread to exit
        WaitForSingleObject( m_hThreadHandle, INFINITE );

        CloseHandle( m_hThreadHandle );
        m_hThreadHandle = NULL;

        m_bUpdateTexture = TRUE;

        return;
    }

    // Unlock our texture and restore our render target
    pTexture->Unlock();

    // Take Action if necessary
    if( m_bActionInitiated )
    {
        m_bActionInitiated = FALSE;

        switch( GetSelectedItem() )
        {
        case MUOPTIONSMENU_ITEM_CREATE_TITLES_AND_SGAMES:
            {
                // Check to see if the user set a value
                if( '\0' == m_pwszValueBuffer[0] )
                {
                    // Set this to 0 (Important!!) so that other actions know when to execute
                    m_dwNumTitles = 0;

                    break;
                }

                WCHAR* pwszStopString = NULL;

                // Check to see if we are in the middle of this action
                // If not, store the number of titles.  If so, store the number of
                // Saved Games
                if( 0 == m_dwNumTitles )
                //
                // Store the number of Game Titles to create
                //
                {
                    // Store the number of titles
                    m_dwNumTitles = wcstol( m_pwszValueBuffer, &pwszStopString, 10 );

                    // Mark that we are still in the middle of a transaction
                    m_bActionInitiated = TRUE;
                    m_bUpdateTexture = TRUE;

                    // Prompt the user for the number of Saved Games
                    g_MenuKeypad.SetInfo( L"Enter # of Saved Games", m_pwszValueBuffer, MENU_MUOPTIONS_NUMBER_SIZE );
                    g_MenuKeypad.SetParent( this );

                    Leave( &g_MenuKeypad );
                }
                else
                //
                // Store the number of saved games to create
                //
                {
                    m_dwNumSavedGames = wcstol( m_pwszValueBuffer, &pwszStopString, 10 );

                    // Create the data
                    m_hThreadHandle = CreateThread( NULL,
                                                    0,
                                                    DataCreateThreadFunc,
                                                    (LPVOID)this,
                                                    CREATE_SUSPENDED,
                                                    NULL );

                    m_bUpdateTexture = TRUE;
                }
                break;
            }
        case MUOPTIONSMENU_ITEM_CREATE_SAVED_GAME:
            {
                // Check to see if the user set a value
                if( '\0' == m_pwszValueBuffer[0] )
                {
                    m_dwSavedGameSize = 0;
                    m_pwszSavedGameName[0] = 0;

                    break;
                }

                if( 0 == m_pwszSavedGameName[0] )
                {
                    // Store the value the user set
                    wcscpy( m_pwszSavedGameName, m_pwszValueBuffer );

                    // Mark that we are still in the middle of a transaction
                    m_bActionInitiated = TRUE;
                    m_bUpdateTexture = TRUE;

                    // Prompt the user for the Size of the Saved Game
                    g_MenuKeypad.SetInfo( L"Enter size of the Saved Game Fill File", m_pwszValueBuffer, MENU_HDOPTIONS_NUMBER_SIZE );
                    g_MenuKeypad.SetParent( this );

                    Leave( &g_MenuKeypad );
                }
                else
                {
                    WCHAR* pwszStopString = NULL;

                    // Convert the Game Size in to a useable number and launch our thread
                    m_dwSavedGameSize = wcstol( m_pwszValueBuffer, &pwszStopString, 10 );

                    // Create the data
                    m_hThreadHandle = CreateThread( NULL,
                                                    0,
                                                    DataCreateThreadFunc,
                                                    (LPVOID)this,
                                                    CREATE_SUSPENDED,
                                                    NULL );

                    m_bUpdateTexture = TRUE;
                }

                break;
            }
        case MUOPTIONSMENU_ITEM_SET_DATETIME_FOR_SAVED_GAME:
            {
                switch( m_uiActionStage )
                {
                case 1:
                    {
                        m_pMemoryUnit->ProcessGameTitles();
                        m_MenuGameTitles.SetInfo( m_pMemoryUnit->GetGameTitlePtr() );

                        Leave( &m_MenuGameTitles );

                        m_bActionInitiated = TRUE;
                        m_uiActionStage = 2;

                        break;
                    }
                case 2:
                    {
                        // TODO: See if the user canceled the previous menu

                        XDBGWRN( APP_TITLE_NAME_A, "CMUOptions::Action():Selected Game Title   - '%u'", m_MenuGameTitles.GetSelectedItem() );

                        for( unsigned int x = 0; x < m_pMemoryUnit->GetGameTitlePtr()->GetNumGames(); x++ )
                        {
                            XDBGWRN( APP_TITLE_NAME_A, "CMUOptions::Action():Number of Saved Games - '%u'", m_pMemoryUnit->GetGameTitlePtr()->GetGame( x )->GetNumSavedGames() );
                        }
                        
                        m_MenuSaveGames.SetInfo( m_pMemoryUnit->GetGameTitlePtr()->GetGame( m_MenuGameTitles.GetSelectedItem() ) );
                        Leave( &m_MenuSaveGames );
                        
                        break;
                    }
                }

                break;
            }
        case MUOPTIONSMENU_ITEM_CREATE_FILE:
            {
                // Check to see if the user set a value
                if( '\0' == m_pwszValueBuffer[0] )
                {
                    break;
                }

                WCHAR* pwszStopString = NULL;

                m_dwFileSize = wcstol( m_pwszValueBuffer, &pwszStopString, 10 );

                // Create the data
                m_hThreadHandle = CreateThread( NULL,
                                                0,
                                                DataCreateThreadFunc,
                                                (LPVOID)this,
                                                CREATE_SUSPENDED,
                                                NULL );

                m_bUpdateTexture = TRUE;

                break;
            }
        case MUOPTIONSMENU_ITEM_ERASE:
        case MUOPTIONSMENU_ITEM_CREATEMU_A:
        case MUOPTIONSMENU_ITEM_CREATEMU_B:
        case MUOPTIONSMENU_ITEM_CREATEMU_C:
        case MUOPTIONSMENU_ITEM_CREATEMU_D:
        case MUOPTIONSMENU_ITEM_CREATEMU_E:
        case MUOPTIONSMENU_ITEM_CREATEMU_F:
        case MUOPTIONSMENU_ITEM_CREATEMU_G:
        case MUOPTIONSMENU_ITEM_CREATEMU_H:
        case MUOPTIONSMENU_ITEM_CREATEMU_I:
        case MUOPTIONSMENU_ITEM_CREATEMU_J:
        case MUOPTIONSMENU_ITEM_CREATEMU_K:
        case MUOPTIONSMENU_ITEM_CREATEMU_L:
        case MUOPTIONSMENU_ITEM_CREATEMU_M:
        case MUOPTIONSMENU_ITEM_CREATEMU_N:
        case MUOPTIONSMENU_ITEM_CREATEMU_O:
        case MUOPTIONSMENU_ITEM_CREATEMU_P:
        case MUOPTIONSMENU_ITEM_CREATEMU_Q:
        case MUOPTIONSMENU_ITEM_CREATEMU_R:
        case MUOPTIONSMENU_ITEM_CREATEMU_S:
        case MUOPTIONSMENU_ITEM_CREATEMU_T:
        case MUOPTIONSMENU_ITEM_CREATEMU_U:
        case MUOPTIONSMENU_ITEM_CREATEMU_V:
        case MUOPTIONSMENU_ITEM_CREATEMU_W:
        case MUOPTIONSMENU_ITEM_CREATEMU_X:
        case MUOPTIONSMENU_ITEM_CREATEMU_Y:
        case MUOPTIONSMENU_ITEM_CREATEMU_Z:
        case MUOPTIONSMENU_ITEM_CREATEMU_AA:
		case MUOPTIONSMENU_ITEM_CREATEMU_BB:
            {
                // Perform the action
                m_hThreadHandle = CreateThread( NULL,
                                                0,
                                                DataCreateThreadFunc,
                                                (LPVOID)this,
                                                CREATE_SUSPENDED,
                                                NULL );

                m_bUpdateTexture = TRUE;

                break;
            }
        }
    }
}


// Handle any requests for the joystick (thumb-pad)
void CMUOptions::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CMUOptions::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // Make sure the system is not active
    if( ( m_hThreadHandle ) || ( !m_pMemoryUnit->IsFormatted() ) )
    {
        return;
    }

    // If the memory unit isn't formatted, don't accept any navigation input
    if( !m_pMemoryUnit->IsFormatted() )
    {
        return;
    }

    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = INPUT_KEYPRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = INPUT_KEYPRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            if( GetSelectedItem() > 0 )
            {
                m_bUpdateTexture = TRUE;

                SetSelectedItem( GetSelectedItem() - 1 );

                // Make sure we are displaying the correct items
                if( GetSelectedItem() < (int)m_uiTopItemIndex )
                {
                    m_uiTopItemIndex = GetSelectedItem();

                    // AdjustDisplayArrows();
                }
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            if( GetSelectedItem() < ( MUOPTIONSMENU_ITEM_NUM_ITEMS - 1 ) )
            {
                m_bUpdateTexture = TRUE;

                SetSelectedItem( GetSelectedItem() + 1 );

                // Make sure we are displaying the correct items
                if( GetSelectedItem() >= (int)( MUOPTIONS_MENU_NUM_ITEMS_TO_DISPLAY + m_uiTopItemIndex ) )
                {
                    m_uiTopItemIndex += 1;

                    // AdjustDisplayArrows();
                }
            }
            break;
        }
    }
}


// Handles input (of the BUTTONS) for the current menu
void CMUOptions::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( ( !bFirstPress ) || m_hThreadHandle )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            if( !m_pMemoryUnit->IsFormatted() )
            {
                // If the memory unit isn't formatted, don't accept "A" button input

                return;
            }

            // Refresh our Texture
            m_bUpdateTexture = TRUE;

            switch( GetSelectedItem() )
            {
            case MUOPTIONSMENU_ITEM_CREATE_TITLES_AND_SGAMES:
                {
                    // Prompt the user for the number of Game Titles
                    g_MenuKeypad.SetInfo( L"Enter # of Game Titles", m_pwszValueBuffer, MENU_MUOPTIONS_NUMBER_SIZE );
                    g_MenuKeypad.SetParent( this );
                    m_bActionInitiated = TRUE;

                    Leave( &g_MenuKeypad );
                    break;
                }
            case MUOPTIONSMENU_ITEM_CREATE_SAVED_GAME:
                {
                    g_MenuKeyboard.SetInfo( L"Enter the name of the Saved Game:", m_pwszValueBuffer, MENU_MUOPTIONS_SAVEGAMENAME_SIZE );
                    g_MenuKeyboard.SetParent( this );
                    m_bActionInitiated = TRUE;

                    Leave( &g_MenuKeyboard );
                    break;
                }
            case MUOPTIONSMENU_ITEM_SET_DATETIME_FOR_SAVED_GAME:
                {
                    m_bActionInitiated = TRUE;
                    m_uiActionStage = 1;

                    break;
                }
            case MUOPTIONSMENU_ITEM_CREATE_FILE:
                {
                    // Prompt the user for the size of the file
                    WCHAR pwszMUInfo[100];
                    ZeroMemory( pwszMUInfo, sizeof( WCHAR) * 100 );

                    swprintf( pwszMUInfo, L"(%d) blocks free; Enter Size of File (in blocks):", m_pMemoryUnit->GetFreeBlocks() );

                    g_MenuKeypad.SetInfo( pwszMUInfo, m_pwszValueBuffer, MENU_MUOPTIONS_NUMBER_SIZE );
                    g_MenuKeypad.SetParent( this );
                    m_bActionInitiated = TRUE;

                    Leave( &g_MenuKeypad );
                    break;
                }
            case MUOPTIONSMENU_ITEM_ERASE:
            case MUOPTIONSMENU_ITEM_CREATEMU_A:
            case MUOPTIONSMENU_ITEM_CREATEMU_B:
            case MUOPTIONSMENU_ITEM_CREATEMU_C:
            case MUOPTIONSMENU_ITEM_CREATEMU_D:
            case MUOPTIONSMENU_ITEM_CREATEMU_E:
            case MUOPTIONSMENU_ITEM_CREATEMU_F:
            case MUOPTIONSMENU_ITEM_CREATEMU_G:
            case MUOPTIONSMENU_ITEM_CREATEMU_H:
            case MUOPTIONSMENU_ITEM_CREATEMU_I:
            case MUOPTIONSMENU_ITEM_CREATEMU_J:
            case MUOPTIONSMENU_ITEM_CREATEMU_K:
            case MUOPTIONSMENU_ITEM_CREATEMU_L:
            case MUOPTIONSMENU_ITEM_CREATEMU_M:
            case MUOPTIONSMENU_ITEM_CREATEMU_N:
            case MUOPTIONSMENU_ITEM_CREATEMU_O:
            case MUOPTIONSMENU_ITEM_CREATEMU_P:
            case MUOPTIONSMENU_ITEM_CREATEMU_Q:
            case MUOPTIONSMENU_ITEM_CREATEMU_R:
            case MUOPTIONSMENU_ITEM_CREATEMU_S:
            case MUOPTIONSMENU_ITEM_CREATEMU_T:
            case MUOPTIONSMENU_ITEM_CREATEMU_U:
            case MUOPTIONSMENU_ITEM_CREATEMU_V:
            case MUOPTIONSMENU_ITEM_CREATEMU_W:
            case MUOPTIONSMENU_ITEM_CREATEMU_X:
            case MUOPTIONSMENU_ITEM_CREATEMU_Y:
            case MUOPTIONSMENU_ITEM_CREATEMU_Z:
            case MUOPTIONSMENU_ITEM_CREATEMU_AA:
			case MUOPTIONSMENU_ITEM_CREATEMU_BB:
                {
                    m_bActionInitiated = TRUE;

                    break;
                }
            }

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                Leave( GetParent() );
            }
            break;
        }
    case BUTTON_X:
        {
            // Refresh our Texture
            m_bUpdateTexture = TRUE;

            // Unformat the selected MU
            m_pMemoryUnit->Unformat();
            break;
        }
    case BUTTON_Y:
        {
            // Refresh our Texture
            m_bUpdateTexture = TRUE;

            // Unformat the selected MU
            m_pMemoryUnit->Format( TRUE );
            break;
        }
    case BUTTON_BLACK:
        {
            break;
        }
    case BUTTON_WHITE:
        {
            break;
        }
    }
}


// Initialize the Menu
HRESULT CMUOptions::Init( IDirect3DDevice8* pD3DDevice, char* menuFileName )
{
    XDBGWRN( APP_TITLE_NAME_A, "CMUOptions::Init()" );

    CMenuScreen::Init( pD3DDevice, menuFileName );

    m_MenuGameTitles.Init( pD3DDevice, MENU_GAMETITLE_MENU_FILENAME_A );
    m_MenuGameTitles.SetParent( this );

    m_MenuSaveGames.Init( pD3DDevice, MENU_SAVEGAME_MENU_FILENAME_A );
    m_MenuSaveGames.SetParent( this );

    return S_OK;
}


// Sets the local member to point at the proper memory unit
HRESULT CMUOptions::SetMemoryUnit( CMemoryUnit* pMemoryUnit )
{
    XDBGWRN( APP_TITLE_NAME_A, "CMUOptions::SetMemoryUnit()" );

    if( !pMemoryUnit )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CMUOptions::SetMemoryUnit():Invalid Argument passed in!!" );

        return E_INVALIDARG;
    }

    m_pMemoryUnit = pMemoryUnit;

    return S_OK;
}

DWORD WINAPI DataCreateThreadFunc( LPVOID lpParameter )
{
    CMUOptions* pMUOptions = (CMUOptions*)lpParameter;
    switch( pMUOptions->GetSelectedItem() )
    {
    case MUOPTIONSMENU_ITEM_CREATE_TITLES_AND_SGAMES:
        {
            // Create the Game Titles
            DWORD dwNumTries = 0;
            DWORD dwXModifier = 0;
            for( DWORD x = 0; x < pMUOptions->m_dwNumTitles; x++ )
            {
                char pszTitleID[9];
                pszTitleID[8] = '\0';
                sprintf( pszTitleID, "%0.8X", x + dwXModifier );

                while( FAILED( pMUOptions->m_pMemoryUnit->CreateGameTitle( pMUOptions->m_pMemoryUnit->GetUDataDrive(), pszTitleID ) ) )
                {
                    ++dwXModifier;
                    sprintf( pszTitleID, "%0.8X", x + dwXModifier );

                    if( ( ERROR_DISK_FULL == GetLastError() ) || ( dwNumTries++ == 100 ) )
                    {
                        break;
                    }
                }

                // Unmount the MU, and Mount it to our Title Drive
                pMUOptions->m_pMemoryUnit->Unmount();
                if( FAILED( pMUOptions->m_pMemoryUnit->MapUDataToTitleID( x + dwXModifier ) ) )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "CMUOptions::DataCreateThreadFunc():Failed to MapUDataToTitleID!! ID - '%d', Error - '0x%0.8X (%d)'", x + dwXModifier, GetLastError(), GetLastError() );
                }
                else
                {
                    // Create the Saved Games
                    WCHAR pwszSavedGameName[50];
                    for( DWORD y = 0; y < pMUOptions->m_dwNumSavedGames; y++ )
                    {
                        _snwprintf( pwszSavedGameName, 49, L"Saved Game %02d%c", y, '\0' );

                        SYSTEMTIME sysTime;
                        ZeroMemory( &sysTime, sizeof( sysTime ) );

                        sysTime.wMonth = ( rand() % 12 ) + 1;
                        sysTime.wDay = ( rand() % 28 ) + 1;
                        sysTime.wYear = ( rand() % 99 ) + 2001;
                        sysTime.wHour = rand() % 24;
                        sysTime.wMinute = rand() % 60;
                        sysTime.wSecond = rand() % 60;

                        pMUOptions->m_pMemoryUnit->CreateSavedGame( pwszSavedGameName,
                                                                    NULL,
                                                                    0,
                                                                    &sysTime,
                                                                    "",
                                                                    FALSE );
                    }
                }

                // Restore the proper Memory Unit location
                pMUOptions->m_pMemoryUnit->Unmount();
                pMUOptions->m_pMemoryUnit->Mount();
            }

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATE_SAVED_GAME:
        {
            // Create the Game Title to hold our Game
            char pszTitleID[9];
            pszTitleID[8] = '\0';

            // Create the Game Titles
            DWORD dwNumTries = 0;
            DWORD dwXModifier = 0;
            for( DWORD x = 0x00005000; x < 0x00005001; x++ )
            {
                sprintf( pszTitleID, "%0.8X", x + dwXModifier );

                while( FAILED( pMUOptions->m_pMemoryUnit->CreateGameTitle( pMUOptions->m_pMemoryUnit->GetUDataDrive(), pszTitleID ) ) )
                {
                    ++dwXModifier;
                    sprintf( pszTitleID, "%0.8X", x + dwXModifier );

                    if( ( ERROR_DISK_FULL == GetLastError() ) || ( dwNumTries++ == 100 ) )
                    {
                        break;
                    }
                }

                // Unmount the MU, and Mount it to our Title Drive
                pMUOptions->m_pMemoryUnit->Unmount();
                pMUOptions->m_pMemoryUnit->MapUDataToTitleID( pszTitleID );
            }

            char pszGamePath[MAX_PATH+1];
            pszGamePath[MAX_PATH] = 0;

            SYSTEMTIME sysTime;
            ZeroMemory( &sysTime, sizeof( sysTime ) );

            sysTime.wMonth = ( rand() % 12 ) + 1;
            sysTime.wDay = ( rand() % 28 ) + 1;
            sysTime.wYear = ( rand() % 99 ) + 2001;
            sysTime.wHour = rand() % 24;
            sysTime.wMinute = rand() % 60;
            sysTime.wSecond = rand() % 60;

            pMUOptions->m_pMemoryUnit->CreateSavedGame( pMUOptions->m_pwszValueBuffer,
                                                        pszGamePath,
                                                        MAX_PATH,
                                                        &sysTime,
                                                        "",
                                                        FALSE );

            // Create a file of a certain size within the Saved Game

            // If the user is settings the game to a block sized larger than possible, Max it out
            if( pMUOptions->m_dwSavedGameSize > pMUOptions->m_pMemoryUnit->GetFreeBlocks() )
            {
                pMUOptions->m_dwSavedGameSize = pMUOptions->m_pMemoryUnit->GetFreeBlocks();
            }

            strcat( pszGamePath, "\\" );

            pMUOptions->m_pMemoryUnit->FillArea( pszGamePath, pMUOptions->m_dwSavedGameSize );
            
            // Restore the proper Memory Unit location
            pMUOptions->m_pMemoryUnit->Unmount();
            pMUOptions->m_pMemoryUnit->Mount();

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATE_FILE:
        {
            // Create a file of the specified size
            char pszDirectory[4];
            ZeroMemory( pszDirectory, 4 );

            sprintf( pszDirectory, "%c:\\", pMUOptions->m_pMemoryUnit->GetUDataDrive() );
            pMUOptions->m_pMemoryUnit->FillArea( pszDirectory, pMUOptions->m_dwFileSize );

            break;
        }
    case MUOPTIONSMENU_ITEM_ERASE:
        {
            pMUOptions->m_pMemoryUnit->Erase();

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_A:
        {
            CreateMU_A( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_B:
        {
            CreateMU_B( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_C:
        {
            CreateMU_C( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_D:
        {
            CreateMU_D( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_E:
        {
            CreateMU_E( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_F:
        {
            CreateMU_F( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_G:
        {
            CreateMU_G( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_H:
        {
            CreateMU_H( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_I:
        {
            CreateMU_I( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_J:
        {
            CreateMU_J( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_K:
        {
            CreateMU_K( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_L:
        {
            CreateMU_L( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_M:
        {
            CreateMU_M( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_N:
        {
            CreateMU_N( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_O:
        {
            CreateMU_O( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_P:
        {
            CreateMU_P( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_Q:
        {
            CreateMU_Q( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_R:
        {
            CreateMU_R( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_S:
        {
            CreateMU_S( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_T:
        {
            CreateMU_T( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_U:
        {
            CreateMU_U( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_V:
        {
            CreateMU_V( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_W:
        {
            CreateMU_W( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_X:
        {
            CreateMU_X( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_Y:
        {
            CreateMU_Y( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_Z:
        {
            CreateMU_Z( pMUOptions->m_pMemoryUnit );

            break;
        }
    case MUOPTIONSMENU_ITEM_CREATEMU_AA:
        {
            CreateMU_AA( pMUOptions->m_pMemoryUnit );

            break;
        }
	case MUOPTIONSMENU_ITEM_CREATEMU_BB:
        {
            CreateMU_BB( pMUOptions->m_pMemoryUnit );

            break;
        }

    }

    // Set this to 0 (Important!!) so that other actions know when to execute
    pMUOptions->m_dwNumTitles = 0;
    pMUOptions->m_dwNumSavedGames = 0;
    pMUOptions->m_dwFileSize = 0;
    pMUOptions->m_pwszSavedGameName[0] = 0;
    pMUOptions->m_dwSavedGameSize = 0;

    pMUOptions->m_bUpdateTexture = TRUE;

    return 0;
}


// Should be called whenever a user leaves the menu
void CMUOptions::Leave( CXItem* pItem )
{
    // Call our base class leave
    CMenuScreen::Leave( pItem );
}

// This will be called whenever the user enters this menu
void CMUOptions::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\rootmenu.h ===
/*****************************************************
*** rootmenu.h
***
*** Header file for our root menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** March 28th, 2001
***
*****************************************************/

#ifndef _ROOTMENU_H_
#define _ROOTMENU_H_

// Base menu type
#include "menuscreen.h"

// Sub-menus
#include "memorymenu.h"
#include "stmenu.h"
#include "entrymenu.h"
#include "xbconfigmenu.h"

class CRootMenu : public CMenuScreen
{
public:
    CRootMenu( CXItem* pParent );
    ~CRootMenu();

    // Must be overridden for this to be a Item on our XShell program
    // void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods
    HRESULT Init( IDirect3DDevice8* pD3DDevice, char* menuFileName );		// Initialize our font and settings

private:
    // Private properties
    BOOL          m_bProcessing;                                            // Used to determine we are processing information
	// Sub-Menus
	CMemoryMenu   m_MenuMemory;												// Displays the memory areas available to mount/config (main menu)
    CSTMenu       m_MenuST;                                                 // Deal with Creating soundtracks
	CEntryMenu    m_MenuEntry;												// Reboot to the Dash to various entry points
	CXBConfigMenu m_MenuXBConfig;											// Allow the user to configure various Xbox options

    // Private Methods
    void InstallMUConfig();                                                 // Install MUConfig to the Hard Disk
    //void Leave( CXItem* pItem );											// This should be called whenever a user leaves this menu
};

#endif // _ROOTMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\MUOptions.h ===
/*****************************************************
*** muoptions.h
***
*** Header file for our Memory Unit Options menu
*** class. This menu class will allow you to perform
*** various operations on an MU.  (Format, etc)
***
*** by James N. Helm
*** March 29th, 2001
***
*****************************************************/

#ifndef _MUOPTIONS_H_
#define _MUOPTIONS_H_

#include "menuscreen.h"  // Base menu type
#include "memoryunit.h"
#include "memconfigs.h"
#include "gametitlemenu.h"
#include "savegamemenu.h"

class CMUOptions : public CMenuScreen
{
public:
    CMUOptions( CXItem* pParent );
    ~CMUOptions();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();                                       // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed,
                      BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed,
                      BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick,
                      int nThumbY,
                      int nThumbX,
                      BOOL bFirstYPress,
                      BOOL bFirstXPress );

    // Public Methods
    HRESULT Init( IDirect3DDevice8* pD3DDevice, char* menuFileName );       // Initialize our font and settings
    HRESULT SetMemoryUnit( CMemoryUnit* pMemoryUnit );                      // Sets the local member to point at the proper memory unit

private:
    BOOL            m_bActionInitiated;     // Used to track when a user is entering data from a virtual keyboard
    unsigned int    m_uiActionStage;        // Used for multi-stage actions (Actions that require two menus, etc)
    CMemoryUnit*    m_pMemoryUnit;          // Memory Unit that this class should act upon
    WCHAR*          m_pwszValueBuffer;      // Buffer to hold info from our Keypad / Keyboard functions
    unsigned int    m_uiTopItemIndex;       // Index of the top item being displayed

                    
    DWORD           m_dwNumTitles;          // Used to store the number of Titles the user wishes to create
    DWORD           m_dwNumSavedGames;      // Used to store the number of Saved Games the user wishes to create
    WCHAR*          m_pwszSavedGameName;    // Used to store our Saved Game Name
    DWORD           m_dwSavedGameSize;      // Used to store the desired size of the Saved Game
    DWORD           m_dwFileSize;           // Used to create saved game data of a specific size
    HANDLE          m_hThreadHandle;        // Handle to our thread

    CGameTitleMenu  m_MenuGameTitles;       // List out all the Game Titles and allow the user to select one
    CSaveGameMenu   m_MenuSaveGames;        // List out all the Saved Games for a specific title and allow the user to select one

    // Private Methods
    void Leave( CXItem* pItem );            // This should be called whenever a user leaves this menu

    static friend DWORD WINAPI DataCreateThreadFunc( LPVOID lpParameter );
};

#define MUOPTIONS_MENU_NUM_ITEMS_TO_DISPLAY    9

#endif // _MUOPTIONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\rootmenu.cpp ===
/*****************************************************
*** rootmenu.cpp
***
*** CPP file for our root menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** March 28th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "rootmenu.h"

extern void Render();               // Render the video on to our screen and present it to the user
extern CHardDrive   g_HardDrive;    // Xbox Hard Drive

// Constructors and Destructors
CRootMenu::CRootMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_MenuMemory( NULL ),
m_MenuST( NULL ),
m_MenuEntry( NULL ),
m_MenuXBConfig( NULL )
{
	m_uiNumItems = ROOTMENU_ITEM_NUM_ITEMS;
	SetSelectedItem( 0 );
}

// Destructor
CRootMenu::~CRootMenu()
{
}

void CRootMenu::Action( CUDTexture* pTexture )
{
	// Check the "dirty" flag, and draw our items
	if( !m_bUpdateTexture )
	{
		return;
	}

	pTexture->Lock();

	// Call our base call method to handle generic input
	CMenuScreen::Action( pTexture );

    if( m_bProcessing )
    {
        m_bProcessing = FALSE;

        WCHAR pwszProcText[] = L"Installing...";

        float XPos = SCREEN_X_CENTER - ( GetStringPixelWidth( pwszProcText ) / 2.0f );
        float YPos = SCREEN_Y_CENTER - ( m_uiFontHeightOfItem / 2.0f );;

		pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", pwszProcText );
        pTexture->Unlock();

        Render();

        switch( GetSelectedItem() )
        {
            case ROOTMENU_ITEM_INSTALL_MUCONFIG:
            {
                // Intall files to the hard disk
                InstallMUConfig();

                break;
            }
        }
        
        return;
    }

	// Draw our selector, if necessary
	if( GetNumItems() > 0 )
	{
        float X1Pos = MENUBOX_SELECTOR_X1;
        float Y1Pos = MENUBOX_MAINAREA_Y1 + MENUBOX_MAINAREA_BORDERWIDTH_TOP + ( ( MENUBOX_ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * GetSelectedItem() ) - MENUBOX_SELECTOR_BORDER_WIDTH;
        float X2Pos = MENUBOX_SELECTOR_X2;
        float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * MENUBOX_SELECTOR_BORDER_WIDTH );

        pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, SCREEN_DEFAULT_SELECTOR_COLOR );
	}

    // Draw our menu items
	for( unsigned int x = 0; x < ROOTMENU_ITEM_NUM_ITEMS; x++ )
	{
        float XPos = MENUBOX_MAINAREA_X1 + MENUBOX_MAINAREA_BORDERWIDTH_LEFT;
        float YPos = MENUBOX_MAINAREA_Y1 + MENUBOX_MAINAREA_BORDERWIDTH_TOP + ( ( MENUBOX_ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * x );

		pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", g_wpszRootMenuItems[x] );
	}

    pTexture->Unlock();
}

void CRootMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            switch( GetSelectedItem() )
            {
            case ROOTMENU_ITEM_MEMORY:
                {
                    Leave( &m_MenuMemory );

                    break;
                }
            case ROOTMENU_ITEM_SOUNDTRACKS:
                {
                    Leave( &m_MenuST );

                    break;
                }
            case ROOTMENU_ITEM_XDASH_ENTRY_POINTS:
                {
					Leave( &m_MenuEntry );

                    break;
                }
			case ROOTMENU_ITEM_XBOX_CONFIGURATION:
				{
					Leave( &m_MenuXBConfig );

					break;
				}
            case ROOTMENU_ITEM_INSTALL_MUCONFIG:
                {
                    m_bProcessing = TRUE;
                    m_bUpdateTexture = TRUE;

                    break;
                }
            }

            // If we are on a menu, let's navigate there
            if( GetParent() )
            {
                Leave( GetParent() );
            }
            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                Leave( GetParent() );
            }
            break;
        }
    }
}

void CRootMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = INPUT_KEYPRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = INPUT_KEYPRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() > 0 )
                {
                    m_bUpdateTexture = TRUE;

                    SetSelectedItem( GetSelectedItem() - 1 );
                }
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() < ( ROOTMENU_ITEM_NUM_ITEMS - 1 ) )
                {
                    m_bUpdateTexture = TRUE;

                    SetSelectedItem( GetSelectedItem() + 1 );
                }
            }
            break;
        }
    }
}


void CRootMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}

// Initialize our font and settings
HRESULT CRootMenu::Init( IDirect3DDevice8* pD3DDevice, char* menuFileName )
{
    XDBGWRN( APP_TITLE_NAME_A, "CRootMenu::Init()" );

	// Call our base class method to handle the generic menu stuff
	CMenuScreen::Init( pD3DDevice, menuFileName );

	// Initialize our sub-menus
	m_MenuMemory.SetParent( this );
    m_MenuMemory.Init( pD3DDevice, MENU_MEMORY_MENU_FILENAME_A );

    m_MenuST.SetParent( this );
    m_MenuST.Init( pD3DDevice, MENU_ST_MENU_FILENAME_A );

	m_MenuEntry.SetParent( this );
	m_MenuEntry.Init( pD3DDevice, MENU_ENTRY_MENU_FILENAME_A );

	m_MenuXBConfig.SetParent( this );
	m_MenuXBConfig.Init( pD3DDevice, MENU_XBCONFIG_MENU_FILENAME_A );

    return S_OK;
}

// Install MU Config to the Hard Disk
void CRootMenu::InstallMUConfig()
{
    XDBGWRN( APP_TITLE_NAME_A, "CRootMenu::InstallMUConfig():Installing..." );

    // Create the MUConfig Directory on the E Drive
    g_HardDrive.UnMapDrive( 'E' );
    if( !NT_SUCCESS( g_HardDrive.MapDrive( 'E', "\\Device\\Harddisk0\\Partition1\\devkit" ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CRootMenu::InstallMUConfig():Failed to map the E Drive to Devkit!!" );

        return;
    }

    // Create the destination directory
    if( !CreateDirectory( "e:\\muconfig", NULL ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CRootMenu::InstallMUConfig():Failed to Create the MUConfig directory!!" );
        g_HardDrive.UnMapDrive( 'E' );
        
        return;
    }

    // Copy the contents of the CD/DVD to the Hard Disk
    g_HardDrive.CopyDirs( "d:", "e:\\muconfig" );

    // Rename the XBE to be more meaningful
    MoveFile( "e:\\muconfig\\default.xbe", "e:\\muconfig\\muconfig.xbe" );

    g_HardDrive.UnMapDrive( 'E' );
}

/*
// Called whenever this menu is entered / activated
void CRootMenu::Enter()
{
}

// This should be called whenever a user leaves this menu
void CRootMenu::Leave( CXItem* pItem )
{
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\savegamemenu.cpp ===
/*****************************************************
*** savegamemenu.cpp
***
*** CPP file for our Game Title menu class.  This
*** menu will list all of the Saved Games for a
*** specified Game Title, and allow the user to
*** select one
***
*** by James N. Helm
*** June 17th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "savegamemenu.h"

// extern BOOL                 g_bDisplayUpArrow;      // Used to determine if we should render the Up Arrow
// extern BOOL                 g_bDisplayDownArrow;    // Used to determine if we should render the Down Arrow
extern XFONT*                g_pFont;

// Constructors
CSaveGameMenu::CSaveGameMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_uiTopItemIndex( 0 ),
m_pGameTitle( NULL )
{
    XDBGTRC( APP_TITLE_NAME_A, "CSaveGameMenu::CSaveGameMenu(ex)" );

    m_uiNumItems = 0;
    SetSelectedItem( 0 );
}


// Destructor
CSaveGameMenu::~CSaveGameMenu()
{
}

// Draws a menu on to the screen
void CSaveGameMenu::Action( CUDTexture* pTexture )
{
    // Only update the texture if we need to, otherwise return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Update our Font Height
    unsigned int uiDefaultFontHeight = m_uiFontHeightOfItem;
    XFONT_SetTextHeight( g_pFont, SAVE_GAME_MENU_ITEM_FONT_HEIGHT );
    m_uiFontHeightOfItem = SAVE_GAME_MENU_ITEM_FONT_HEIGHT;

    // Let our base menu class draw all the items pulled from the MNU file
    CMenuScreen::Action( pTexture );

    if( GetNumItems() != 0 )
    {
        // Draw a box behind the currently highlighted choice
        float X1Pos = MENUBOX_SELECTOR_X1;
        float Y1Pos = MENUBOX_MAINAREA_Y1 + MENUBOX_MAINAREA_BORDERWIDTH_TOP + ( ( MENUBOX_ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( GetSelectedItem() - m_uiTopItemIndex ) ) - MENUBOX_SELECTOR_BORDER_WIDTH;
        float X2Pos = MENUBOX_SELECTOR_X2;
        float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * MENUBOX_SELECTOR_BORDER_WIDTH );
    
        pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, SCREEN_DEFAULT_SELECTOR_COLOR );

        //
        // Draw our Menu Items
        //

        for( unsigned int x = m_uiTopItemIndex; x < ( SAVE_GAME_MENU_NUM_ITEMS_TO_DISPLAY + m_uiTopItemIndex ); x++ )
        {
            // Make sure we don't try to access out of range items
            if( x == GetNumItems() )
            {
                break;
            }

            float XPos = MENUBOX_MAINAREA_X1 + MENUBOX_MAINAREA_BORDERWIDTH_LEFT;
            float YPos = MENUBOX_MAINAREA_Y1 + MENUBOX_MAINAREA_BORDERWIDTH_TOP + ( ( MENUBOX_ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( x - m_uiTopItemIndex ) );

            pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%hs (%ls)", m_pGameTitle->GetSavedGameID( x ), m_pGameTitle->GetSavedGameName( x ) );
        }
    }

    // Correct our Font Height
    m_uiFontHeightOfItem = uiDefaultFontHeight;
    XFONT_SetTextHeight( g_pFont, uiDefaultFontHeight );

    // Unlock the texture
    pTexture->Unlock();
}


// Handle any requests for the joystick (thumb-pad)
void CSaveGameMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CSaveGameMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() > 0 )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    // g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() - 1 );

                    // Make sure we are displaying the correct items
                    if( GetSelectedItem() < (int)m_uiTopItemIndex )
                    {
                        m_uiTopItemIndex = GetSelectedItem();

                        // AdjustDisplayArrows();
                    }
                }
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( ( (unsigned int)GetSelectedItem() + 1 ) < GetNumItems() )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    // g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() + 1 );

                    // Make sure we are displaying the correct items
                    if( GetSelectedItem() >= (int)( SAVE_GAME_MENU_NUM_ITEMS_TO_DISPLAY + m_uiTopItemIndex ) )
                    {
                        m_uiTopItemIndex += 1;

                        // AdjustDisplayArrows();
                    }
                }
            }
            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CSaveGameMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                // Play the Select Sound
                // g_Sounds.PlaySelectSound();

                m_bUpdateTexture = TRUE;
            }

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                // g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }

            break;
        }
    case BUTTON_Y:
        {
            break;
        }
    }
}


// Initialize the Menu
HRESULT CSaveGameMenu::Init( IDirect3DDevice8* pD3DDevice, char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CSaveGameMenu::Init()" );

    HRESULT hr = CMenuScreen::Init( pD3DDevice, menuFileName );

    return hr;
}


// Sets the Xbox Game object the menu should use
void CSaveGameMenu::SetInfo( CGameTitle* pGameTitle )
{
    if( NULL == pGameTitle )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CSaveGameMenu::SetInfo():Invalid parameter passed in!!" );

        return;
    }

    m_pGameTitle = pGameTitle;
    m_uiNumItems = m_pGameTitle->GetNumSavedGames();

    if( GetNumItems() > 0 )
    {
        SetSelectedItem( 0 );
    }
}


// Should be called whenever a user leaves the menu
void CSaveGameMenu::Leave( CXItem* pItem )
{
    // Call our base class Leave
    CMenuScreen::Leave( pItem );

    // g_bDisplayUpArrow = FALSE;
    // g_bDisplayDownArrow = FALSE;

    // Make sure we set that we have no items
    m_pGameTitle = NULL;
    m_uiNumItems = 0;
    m_uiTopItemIndex = 0;
}

// This will be called whenever the user enters this menu
void CSaveGameMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Set our selected item to the top of the menu
    if( GetNumItems() > 0 )
    {
        SetSelectedItem( 0 );
        m_uiTopItemIndex = 0;
    }

    // Make sure the proper arrows are displayed
    // AdjustDisplayArrows();
}


/*
// TODO: Implement the arrows
// Adjust the UP and DOWN arrows on the screen
void CSaveGameMenu::AdjustDisplayArrows()
{
    // Decide if we need to turn on the Up Arrow
    if( 0 == m_uiTopItemIndex )
    //
    // We can turn off the Up Arrow, because there is nothing above us
    //
    {
        g_bDisplayUpArrow = FALSE;
    }
    else
    //
    // We have to turn on the Up Arrow, because a menu choice is above us
    //
    {
        g_bDisplayUpArrow = TRUE;
    }

    // Decide if we need to turn on the Down Arrow
    if( ( m_uiTopItemIndex + SAVE_GAME_MENU_NUM_ITEMS_TO_DISPLAY ) == GetNumItems() )
    //
    // We can turn off the Down arrow, because nothing is below us
    //
    {
        g_bDisplayDownArrow = FALSE;
    }
    else
    //
    // We have to turn on the Down Arrow, because there are menu choices below us
    //
    {
        g_bDisplayDownArrow = TRUE;
    }
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\screenitem.cpp ===
/*****************************************************
*** screenitem.cpp
***
*** CPP file for our abstract base class for a
*** generic screen item.
*** 
*** by James N. Helm
*** January 13th, 2001
*** 
*****************************************************/

#include "stdafx.h"
#include "screenitem.h"

// Constructor
CScreenItem::CScreenItem()
{
};

// Destructor
CScreenItem::~CScreenItem()
{ 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\screenitem.h ===
/*****************************************************
*** screenitem.h
***
*** Header file for our abstract base class for a
*** generic screen item.
*** 
*** by James N. Helm
*** January 13th, 2001
*** 
*****************************************************/

#ifndef _SCREENITEM_H_
#define _SCREENITEM_H_

class CScreenItem
{
public:
    // Constructors and Destructors
    CScreenItem();
    virtual ~CScreenItem();

    // Every screen item should know how to render itself
    virtual void Render( IDirect3DDevice8* pD3DDevice, CUDTexture* pTexture ) = 0;

    virtual BOOL operator < ( const CScreenItem& item ) { return FALSE; };
    virtual BOOL operator > ( const CScreenItem& item ) { return FALSE; };
    virtual BOOL operator == ( const CScreenItem& item ) { return FALSE; };

protected:
};

#endif // _SCREENITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\savegamemenu.h ===
/*****************************************************
*** savegamemenu.h
***
*** Header file for our Game Title menu class.  This
*** menu will list all of the Saved Games for a
*** specified Game Title, and allow the user to
*** select one
***
*** by James N. Helm
*** June 17th, 2001
***
*****************************************************/

#ifndef _SAVEGAMEMENU_H_
#define _SAVEGAMEMENU_H_

#include "menuscreen.h"

class CSaveGameMenu : public CMenuScreen
{
public:
    CSaveGameMenu( CXItem* pParent );
    ~CSaveGameMenu();

    // Must be overridden for this to be a Item on our XShell program
    void Enter();                                       // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );                // Called each frame -- renders screen, and performs other necessary actions
                 
    void HandleInput( enum BUTTONS buttonPressed,       // Handles Button input for this screen
                      BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed,     // Handles Control input for this screen
                      BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick,           // Handles Joystick input for this screen
                      int nThumbY,
                      int nThumbX,
                      BOOL bFirstYPress,
                      BOOL bFirstXPress );

    // Public Methods
    HRESULT Init( IDirect3DDevice8* pD3DDevice, // Initialize our font and settings
                  char* menuFileName );
    void    Leave( CXItem* pItem );             // Should be called whenever a user deactivates this item
    void    SetInfo( CGameTitle* pGameTitle );  // Sets the Xbox Game object the menu should use

private:
    // Private Properties
    unsigned int    m_uiTopItemIndex;           // Index of the top item being displayed
    CGameTitle*     m_pGameTitle;               // Pointer to our Game Title Object

    // Private Methods
    // void AdjustDisplayArrows();                     // Adjust the UP and DOWN arrows on the screen
};

#define SAVE_GAME_MENU_ITEM_FONT_HEIGHT        SCREEN_DEFAULT_FONT_HEIGHT
#define SAVE_GAME_MENU_NUM_ITEMS_TO_DISPLAY    9

#endif // _SAVEGAMEMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\xfontfuncs.cpp ===
#include "stdafx.h"
#include "xfontfuncs.h"

extern XFONT* g_pFont;

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int GetStringPixelWidth( IN WCHAR* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!!\n" );

        return -1;
    }

    unsigned int outlen = 0;        // Return value

    XFONT_GetTextExtent( g_pFont, string, length, &outlen );

    return outlen;
}


// Get the width of the char*
int GetStringPixelWidth( IN char* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetStringPixelWidth( char* ):Invalid pointer passed in!!\n" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}


// Get the size of the current font
void GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " GetFontSize():Invalid arguments passed!!\n" );

        return;
    }

    XFONT_GetFontMetrics( g_pFont, pheight, pdecent );
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, " TruncateStringToFit():Invalid argument!!\n" );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\XFontFuncs.h ===
#ifndef _XFONTFUNCS_H_
#define _XFONTFUNCS_H_

// Get the pixel width of a string
int GetStringPixelWidth( IN WCHAR* string,
                         IN int length = -1 );

// Get the pixel width of a char*
int GetStringPixelWidth( IN char* string,
                         IN int length = -1 );

// Get the size of the currently selected font
void GetFontSize( unsigned int* pheight,
                  unsigned int* pdecent );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( char* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( WCHAR* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

#endif // _XFONTFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define XFONT_TRUETYPE

#include <xapip.h>
#include <xboxp.h>
#include <xdbg.h>
#include <xfont.h>
#include <stdio.h>
#include <profilep.h>

// Libs
#include "usbmanager.h"
#include "harddrive.h"
#include "xsettings.h"
#include "linkedlist.h"
#include "bitmapfile.h"

#include "xfontfuncs.h"
#include "udtexture.h"
#include "xitem.h"
#include "menuscreen.h"
#include "keypadmenu.h"
#include "keyboardmenu.h"
#include "constants.h"

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\screenitems.h ===
/*****************************************************
*** screenitems.h
***
*** Header file for our screen item classes.
*** This file will contain the definition for all
*** types of screen items
*** 
*** by James N. Helm
*** January 13th, 2001
*** 
*****************************************************/

#ifndef _SCREENITEMS_H_
#define _SCREENITEMS_H_

#include "screenitem.h"

/*****************************************************
/* CTextItem()
/****************************************************/
class CTextItem : public CScreenItem
{
public:
    // Constructors and Destructors
    CTextItem();
    ~CTextItem();

    // Must create this for all CScreenItem classes
    void Render( IDirect3DDevice8* pD3DDevice, CUDTexture* pTexture );

    // Allow the user to update the item
    void UpdateItem( WCHAR* pwszText, float fXPos, float fYPos, DWORD dwFGColor, DWORD dwBGColor );

private:
    WCHAR* m_pwszText;
    float m_fXPos;
    float m_fYPos;
    DWORD m_dwFGColor;
    DWORD m_dwBGColor;
};


/*****************************************************
/* CPanelItem()
/****************************************************/
class CPanelItem : public CScreenItem
{
public:
    // Constructors and Destructors
    CPanelItem();
    ~CPanelItem();

    // Must create this for all CScreenItem classes
    void Render( IDirect3DDevice8* pD3DDevice, CUDTexture* pTexture );

    // Allow the user to update the item
    void UpdateItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, DWORD dwColor );

private:
        float m_fX1Pos;
        float m_fY1Pos;
        float m_fX2Pos;
        float m_fY2Pos;
        DWORD m_dwColor;
};


/*****************************************************
/* CLineItem()
/****************************************************/
class CLineItem : public CScreenItem
{
public:
    // Constructors and Destructors
    CLineItem();
    ~CLineItem();

    // Must create this for all CScreenItem classes
    void Render( IDirect3DDevice8* pD3DDevice, CUDTexture* pTexture );

    // Allow the user to update the item
    void UpdateItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, float fWidth, DWORD dwColor );

private:
        float m_fX1Pos;
        float m_fY1Pos;
        float m_fX2Pos;
        float m_fY2Pos;
        float m_fWidth;
        DWORD m_dwColor;
};


/*****************************************************
/* COutlineItem()
/****************************************************/
class COutlineItem : public CScreenItem
{
public:
    // Constructors and Destructors
    COutlineItem();
    ~COutlineItem();

    // Must create this for all CScreenItem classes
    void Render( IDirect3DDevice8* pD3DDevice, CUDTexture* pTexture );

    // Allow the user to update the item
    void UpdateItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, float fWidth, DWORD dwColor );

private:
        float m_fX1Pos;
        float m_fY1Pos;
        float m_fX2Pos;
        float m_fY2Pos;
        float m_fWidth;
        DWORD m_dwColor;
};


/*****************************************************
/* CBitmapItem()
/****************************************************/
class CBitmapItem : public CScreenItem
{
public:
    // Constructors and Destructors
    CBitmapItem();
    ~CBitmapItem();

    // Must create this for all CScreenItem classes
    void Render( IDirect3DDevice8* pD3DDevice, CUDTexture* pTexture );

    // Allow the user to update the item
    void UpdateItem( char* pszFilename, int nXPos, int nYPos );

private:
    BitmapFile m_Bitmap;

    char* m_pszFilename;
    int m_nXPos;
    int m_nYPos;
};

#endif //_SCREENITEMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\stmenu.h ===
/*****************************************************
*** stmenu.h
***
*** Header file for our Soundtracks menu
*** class. This menu class will allow you to perform
*** various soundtrack operations.
***
*** by James N. Helm
*** April 4th, 2001
***
*****************************************************/

#ifndef _STMENU_H_
#define _STMENU_H_

#include "menuscreen.h"  // Base menu type

class CSTMenu : public CMenuScreen
{
public:
    CSTMenu( CXItem* pParent );
    ~CSTMenu();

    // Must be overridden for this to be a Item on our XShell program
    // void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods
    HRESULT Init( IDirect3DDevice8* pD3DDevice, char* menuFileName );       // Initialize our font and settings

private:
    BOOL         m_bActionInitiated;            // Used to track when a user is entering data from a virtual keyboard
    WCHAR*       m_pwszValueBuffer;             // Buffer to hold info from our Keypad / Keyboard functions
	WCHAR        m_pwszTrackName[MENU_ST_TRACKNAME_SIZE];	// Used to hold our Named Track

    DWORD        m_dwNumSoundtracks;            // Used to store the number of Soundtracks the user wishes to create
    DWORD        m_dwNumTracks;                 // Used to store the number of Tracks the user wishes to create
	DWORD        m_dwTrackLength;				// Used to hold how long a track should be
    DWORD        m_dwCurrentST;                 // Used to store the current Soundtrack ID the user is working with
    HANDLE       m_hThreadHandle;               // Handle to our thread

    CRITICAL_SECTION m_CritSec;                 // Critical Section used to protect Shared Memory
    BOOL         m_bUsingDashSTFuncs;           // Used to determine if we are using the Dash ST functions

    // Private Methods
    // void Leave( CXItem* pItem );                                        // This should be called whenever a user leaves this menu
    BOOL BeginUseDashSTFuncs();
    BOOL EndUseDashSTFuncs();

    void EnterCritSection();
    void LeaveCritSection();

    static friend DWORD WINAPI DataCreateThreadFunc( LPVOID lpParameter );
};

#endif // _MUOPTIONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\STMenu.cpp ===
/*****************************************************
*** stmenu.cpp
***
*** CPP file for our Soundtrack menu class.
*** This menu class will allow you to perform various
*** operations with Soundtracks.
***
*** by James N. Helm
*** April 3rd, 2001
***
*****************************************************/

#include "stdafx.h"
#include "stmenu.h"

extern CKeypadMenu   g_MenuKeypad;      // Virtual Keypad Menu to be used by all screens
extern CKeyboardMenu g_MenuKeyboard;    // Virtual Keyboard Menu to be used by all screens
extern CHardDrive    g_HardDrive;       // Xbox Hard Drive

// Constructors
CSTMenu::CSTMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_bActionInitiated( FALSE ),
m_dwNumSoundtracks( 0 ),
m_dwNumTracks( 0 ),
m_dwCurrentST( 0 ),
m_dwTrackLength( 0 ),
m_hThreadHandle( NULL ),
m_pwszValueBuffer( NULL )
{
    XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::CSTMenu()" );

    m_uiNumItems = STMENU_ITEM_NUM_ITEMS;
    SetSelectedItem( 0 );

    m_pwszValueBuffer = new WCHAR[MENU_ST_SOUNDTRACKNAME_SIZE];
    if( !m_pwszValueBuffer )
    {
        XDBGERR( APP_TITLE_NAME_A, "CSTMenu::CSTMenu():Failed to allocate memory!!" );
    }

	ZeroMemory( m_pwszTrackName, sizeof( WCHAR ) * MENU_ST_TRACKNAME_SIZE );

    InitializeCriticalSection( &m_CritSec );
}


// Destructor
CSTMenu::~CSTMenu()
{
    if( m_pwszValueBuffer )
    {
        delete[] m_pwszValueBuffer;
        m_pwszValueBuffer = NULL;
    }

    DeleteCriticalSection( &m_CritSec );
}


// Draws a menu on to the screen
void CSTMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should update the texture
    // If not, return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else // reset the texture flag to FALSE
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

    DWORD dwItemColor = 0;

    // Draw a selector around the current item
    float X1Pos = MENUBOX_SELECTOR_X1;
    float Y1Pos = MENUBOX_MAINAREA_Y1 + MENUBOX_MAINAREA_BORDERWIDTH_TOP + ( ( MENUBOX_ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * GetSelectedItem() ) - MENUBOX_SELECTOR_BORDER_WIDTH;
    float X2Pos = MENUBOX_SELECTOR_X2;
    float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * MENUBOX_SELECTOR_BORDER_WIDTH );

    pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, SCREEN_DEFAULT_SELECTOR_COLOR );

    // Display the number of soundtracks available, but only if our thread is not active
    if( !m_hThreadHandle )
    {
        BeginUseDashSTFuncs();

        DWORD dwNumSTs = DashGetSoundtrackCount();

        pTexture->DrawText( (float)MENUBOX_WINDOW_TITLE_X1 + GetStringPixelWidth( L"Soundtracks " ), MENUBOX_WINDOW_TITLE_Y1, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"(%d/100)", dwNumSTs );

        EndUseDashSTFuncs();
    }

    // Draw the Menu Options
    for( unsigned int x = 0; x < STMENU_ITEM_NUM_ITEMS; ++x )
    {
        float XPos = MENUBOX_MAINAREA_X1 + MENUBOX_MAINAREA_BORDERWIDTH_LEFT;
        float YPos = MENUBOX_MAINAREA_Y1 + MENUBOX_MAINAREA_BORDERWIDTH_TOP + ( ( MENUBOX_ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * x );

        DWORD dwItemColor = SCREEN_ACTIVE_OPTION_COLOR;

        // Check to see if the option is disabled
        if( ( 0 == m_dwCurrentST ) && ( STMENU_ITEM_ADD_NAMED_TRACK_TO_SOUNDTRACK == x ) )
        {
            dwItemColor = SCREEN_INACTIVE_OPTION_COLOR;
        }

        pTexture->DrawText( XPos, YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", g_wpszSTMenuItems[x] );
    }

    // Draw the current Soundtrack (if any)
    EnterCritSection();
    pTexture->DrawText( MENUBOX_WINDOW_FOOTER_X1, MENUBOX_WINDOW_FOOTER_Y1, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"Current Soundtrack ID (0 if NONE): %d", m_dwCurrentST );
    LeaveCritSection();

    // Draw our processing message if necessary
    if( m_hThreadHandle )
    {
#define TEXT_BOX_BUFFER_SIZE    20

        pTexture->DrawBox( MENUBOX_MAINAREA_X1 + TEXT_BOX_BUFFER_SIZE, MENUBOX_MAINAREA_Y1 + TEXT_BOX_BUFFER_SIZE, MENUBOX_MAINAREA_X2 - TEXT_BOX_BUFFER_SIZE, MENUBOX_MAINAREA_Y2 - TEXT_BOX_BUFFER_SIZE, COLOR_BLACK );
        pTexture->DrawOutline( MENUBOX_MAINAREA_X1 + TEXT_BOX_BUFFER_SIZE, MENUBOX_MAINAREA_Y1 + TEXT_BOX_BUFFER_SIZE, MENUBOX_MAINAREA_X2 - TEXT_BOX_BUFFER_SIZE, MENUBOX_MAINAREA_Y2 - TEXT_BOX_BUFFER_SIZE, 2, COLOR_DARK_GREEN );
        pTexture->DrawText( SCREEN_X_CENTER - ( GetStringPixelWidth( L"Processing..." ) / 2 ), SCREEN_Y_CENTER, SCREEN_DEFAULT_FOREGROUND_COLOR, SCREEN_DEFAULT_BACKGROUND_COLOR, L"Processing..." );

        // Check to see if the thread is done
        DWORD dwExitCode = 0;
        GetExitCodeThread( m_hThreadHandle, &dwExitCode );

        if( STILL_ACTIVE != dwExitCode )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::Action():Thread Exit Code - '%d'", dwExitCode );

            // Our thread has stopped, close it, and reset the handle
            CloseHandle( m_hThreadHandle );
            m_hThreadHandle = NULL;
        }

        m_bUpdateTexture = TRUE;

        // Start our thread on it's merry way
        ResumeThread( m_hThreadHandle );
    }

    // Unlock our texture and restore our render target
    pTexture->Unlock();

    // Take Action if necessary
    if( m_bActionInitiated )
    {
        m_bActionInitiated = FALSE;

        switch( GetSelectedItem() )
        {
        case STMENU_ITEM_CREATE_SMALL_SOUNDTRACKS_AND_TRACKS:
        case STMENU_ITEM_CREATE_SOUNDTRACKS_AND_TRACKS:
            {
                // Check to see if the user set a value
                if( '\0' == m_pwszValueBuffer[0] )
                {
                    // Set this to 0 (Important!!) so that other actions know when to execute
                    m_dwNumSoundtracks = 0;
					m_dwTrackLength = 0;
					m_dwNumTracks = 0;

                    break;
                }

                WCHAR* pwszStopString = NULL;

				// Check to see what we've stored, and process the next item

                // Check to see if we are in the middle of this action
                // If not, store the number of Soundtracks.  If so, store the number of
                // Tracks
                if( 0 == m_dwNumSoundtracks )
                //
                // Store the number of Soundtracks to create, and prompt for
				// the number of tracks per soundtrack
                //
                {
                    // Store the number of Soundtracks
                    m_dwNumSoundtracks = wcstol( m_pwszValueBuffer, &pwszStopString, 10 );

                    // Mark that we are still in the middle of a transaction
                    m_bActionInitiated = TRUE;
                    m_bUpdateTexture = TRUE;

                    // Prompt the user for the number of Tracks
                    g_MenuKeypad.SetInfo( L"Enter # of Tracks", m_pwszValueBuffer, MENU_ST_NUMBER_SIZE );
                    g_MenuKeypad.SetParent( this );

                    Leave( &g_MenuKeypad );
                }
                else
				//
				// Check to see if we have already recieved the Number of Tracks from the user,
				// and if so, ask for the track length
				//
				{
					if( 0 == m_dwNumTracks )
					//
					// Store the number of Tracks the user would like, and
					// prompt them for the track length
					//
					{
						m_dwNumTracks = wcstol( m_pwszValueBuffer, &pwszStopString, 10 );

						// Create the data
						m_hThreadHandle = CreateThread( NULL,
														0,
														DataCreateThreadFunc,
														(LPVOID)this,
														CREATE_SUSPENDED,
														NULL );

						m_bUpdateTexture = TRUE;

                        /*
						// Mark that we are still in the middle of a transaction
						m_bActionInitiated = TRUE;
						m_bUpdateTexture = TRUE;

						// Prompt the user for the Track Length
						g_MenuKeypad.SetInfo( L"Enter the Length of the Tracks (seconds)", m_pwszValueBuffer, MENU_ST_NUMBER_SIZE );
						g_MenuKeypad.SetParent( this );

						Leave( &g_MenuKeypad );
                        */
					}
					else
					//
					// Store the Length of the tracks the user wishes to use
					//
					{
						m_dwTrackLength = wcstol( m_pwszValueBuffer, &pwszStopString, 10 );

						m_dwTrackLength *= 1000;	// Convert seconds in to milliseconds

						// Create the data
						m_hThreadHandle = CreateThread( NULL,
														0,
														DataCreateThreadFunc,
														(LPVOID)this,
														CREATE_SUSPENDED,
														NULL );

						m_bUpdateTexture = TRUE;
					}
				}

                break;
            }
        case STMENU_ITEM_CREATE_NAMED_SOUNDTRACK:
            {
                // Check to see if the user set a value
                if( '\0' == m_pwszValueBuffer[0] )
                {
                    break;
                }

                // Create the data
                m_hThreadHandle = CreateThread( NULL,
                                                0,
                                                DataCreateThreadFunc,
                                                (LPVOID)this,
                                                CREATE_SUSPENDED,
                                                NULL );

                m_bUpdateTexture = TRUE;

                break;

            }
        case STMENU_ITEM_ADD_NAMED_TRACK_TO_SOUNDTRACK:
            {
                // Check to see if the user set a value
                if( ( '\0' == m_pwszValueBuffer[0] ) || ( 0 == m_dwCurrentST ) )
                {
					m_dwTrackLength = 0;

                    break;
                }

				if( L'\0' == m_pwszTrackName[0] )
				//
				// Store the Current track name and
				// prompt the user for the Track Length
				//
				{
					wcscpy( m_pwszTrackName, m_pwszValueBuffer );

					// Mark that we are still in the middle of a transaction
					m_bActionInitiated = TRUE;
					m_bUpdateTexture = TRUE;

					// Prompt the user for the Track Length
					g_MenuKeypad.SetInfo( L"Enter the Length of the Track (seconds)", m_pwszValueBuffer, MENU_ST_NUMBER_SIZE );
					g_MenuKeypad.SetParent( this );

					Leave( &g_MenuKeypad );
				}
				else
				//
				// We have the track length information, store it, and process the data
				//
				{
					WCHAR* pwszStopString = NULL;

					m_dwTrackLength = wcstol( m_pwszValueBuffer, &pwszStopString, 10 );

					m_dwTrackLength *= 1000;	// Convert seconds in to milliseconds

					// Create the data
					m_hThreadHandle = CreateThread( NULL,
													0,
													DataCreateThreadFunc,
													(LPVOID)this,
													CREATE_SUSPENDED,
													NULL );

					m_bUpdateTexture = TRUE;
				}

                break;

            }
		case STMENU_ITEM_CREATE_SORTING:
		case STMENU_ITEM_CREATE_SORTING_JAP:
        case STMENU_ITEM_REMOVE_ALL_SOUNDTRACKS:
            {
                // Create the data
                m_hThreadHandle = CreateThread( NULL,
                                                0,
                                                DataCreateThreadFunc,
                                                (LPVOID)this,
                                                CREATE_SUSPENDED,
                                                NULL );

                m_bUpdateTexture = TRUE;

                break;
            }
        }
    }
}


// Handle any requests for the joystick (thumb-pad)
void CSTMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CSTMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // Make sure the system is not working
    if( m_hThreadHandle )
    {
        return;
    }

    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = INPUT_KEYPRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = INPUT_KEYPRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            if( GetSelectedItem() > 0 )
            {
                m_bUpdateTexture = TRUE;
                
                SetSelectedItem( GetSelectedItem() - 1 );

                if( ( 0 == m_dwCurrentST ) && ( STMENU_ITEM_ADD_NAMED_TRACK_TO_SOUNDTRACK == GetSelectedItem() ) )
                {
                    SetSelectedItem( GetSelectedItem() - 1 );
                }
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            if( GetSelectedItem() < ( STMENU_ITEM_NUM_ITEMS - 1 ) )
            {
                m_bUpdateTexture = TRUE;

                SetSelectedItem( GetSelectedItem() + 1 );

                if( ( 0 == m_dwCurrentST ) && ( STMENU_ITEM_ADD_NAMED_TRACK_TO_SOUNDTRACK == GetSelectedItem() ) )
                {
                    SetSelectedItem( GetSelectedItem() + 1 );
                }
            }
            break;
        }
    }
}


// Handles input (of the BUTTONS) for the current menu
void CSTMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( ( !bFirstPress ) || m_hThreadHandle )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Refresh our Texture
            m_bUpdateTexture = TRUE;

            switch( GetSelectedItem() )
            {
            case STMENU_ITEM_CREATE_SMALL_SOUNDTRACKS_AND_TRACKS:
            case STMENU_ITEM_CREATE_SOUNDTRACKS_AND_TRACKS:
                {
                    // Prompt the user for the number of Soundtracks
                    g_MenuKeypad.SetInfo( L"Enter # of Soundtracks", m_pwszValueBuffer, MENU_ST_NUMBER_SIZE );
                    g_MenuKeypad.SetParent( this );
                    m_bActionInitiated = TRUE;

                    Leave( &g_MenuKeypad );
                    break;
                }
            case STMENU_ITEM_CREATE_NAMED_SOUNDTRACK:
                {
                    g_MenuKeyboard.SetInfo( L"Enter the name of the Soundtrack:", m_pwszValueBuffer, MENU_ST_SOUNDTRACKNAME_SIZE );
                    g_MenuKeyboard.SetParent( this );
                    m_bActionInitiated = TRUE;

                    Leave( &g_MenuKeyboard );
                    break;
                }
            case STMENU_ITEM_ADD_NAMED_TRACK_TO_SOUNDTRACK:
                {
                    // Check to make sure the user has selected "Create new soundtrack"
                    if( 0 != m_dwCurrentST )
                    {
                        g_MenuKeyboard.SetInfo( L"Enter the name of the track:", m_pwszValueBuffer, MENU_ST_TRACKNAME_SIZE );
                        g_MenuKeyboard.SetParent( this );
                        m_bActionInitiated = TRUE;

                        Leave( &g_MenuKeyboard );
                    }
                    break;
                }

			case STMENU_ITEM_CREATE_SORTING:
			case STMENU_ITEM_CREATE_SORTING_JAP:
            case STMENU_ITEM_REMOVE_ALL_SOUNDTRACKS:
                {
                    m_bActionInitiated = TRUE;

                    break;
                }
            }

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                Leave( GetParent() );
            }
            break;
        }
    case BUTTON_X:
        {
            break;
        }
    case BUTTON_Y:
        {
            break;
        }
    case BUTTON_BLACK:
        {
            break;
        }
    case BUTTON_WHITE:
        {
            break;
        }
    }
}


// Initialize the Menu
HRESULT CSTMenu::Init( IDirect3DDevice8* pD3DDevice, char* menuFileName )
{
    XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::Init()" );

    CMenuScreen::Init( pD3DDevice, menuFileName );

    return S_OK;
}


void CreateTrackForST( DWORD dwSoundtrackID, BOOL bUseSmallTracks )
{
    char pszTrackIDText[30];

    if( bUseSmallTracks )
    {
        strcpy( pszTrackIDText, "SMTracks" );
    }
    else
    {
        strcpy( pszTrackIDText, "Tracks" );
    }

    char pszINIBuffer[MAX_PATH+1];
    ZeroMemory( pszINIBuffer, MAX_PATH+1 );

    // Get the number of tracks from the INI file
    GetPrivateProfileStringA( pszTrackIDText, "NumTracks", "0", pszINIBuffer, MAX_PATH, FILE_TRACKINI_LOCATION_A );
    unsigned long ulNumTracks = strtoul( pszINIBuffer, NULL, 10 );
    if( 0 == ulNumTracks )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CreateTrackForST():Failed to get the number of tracks!!" );

        return;
    }

    XDBGTRC( APP_TITLE_NAME_A, "CreateTrackForST():NumTracks - '%d'", ulNumTracks );
    
    // Look up a random track
    unsigned int uiTrackNum = rand() % ( ulNumTracks );
    char pszTrackNameIndex[20+1];
    char pszTrackLengthIndex[20+1];
    WCHAR pwszTrackName[MAX_PATH+1];

    ZeroMemory( pszTrackNameIndex, 20+1 );
    ZeroMemory( pszTrackLengthIndex, 20+1 );
    ZeroMemory( pwszTrackName, sizeof( WCHAR ) * ( MAX_PATH+1 ) );
    ZeroMemory( pszINIBuffer, MAX_PATH+1 );

    _snprintf( pszTrackNameIndex, 20, "%hs%uName", pszTrackIDText, uiTrackNum );
    _snprintf( pszTrackLengthIndex, 20, "%hs%uLength", pszTrackIDText, uiTrackNum );

    XDBGTRC( APP_TITLE_NAME_A, "CreateTrackForST():pszTrackNameIndex - '%hs'", pszTrackNameIndex );
    XDBGTRC( APP_TITLE_NAME_A, "CreateTrackForST():pszTrackLengthIndex - '%hs'", pszTrackLengthIndex );

    // Get the track name and length
    GetPrivateProfileStringA( pszTrackIDText, pszTrackNameIndex, "Def Name", pszINIBuffer, MAX_PATH, FILE_TRACKINI_LOCATION_A );
    _snwprintf( pwszTrackName, MAX_PATH, L"%hs", pszINIBuffer );
    ZeroMemory( pszINIBuffer, MAX_PATH+1 );
    GetPrivateProfileStringA( pszTrackIDText, pszTrackLengthIndex, "0", pszINIBuffer, MAX_PATH, FILE_TRACKINI_LOCATION_A );
    DWORD dwTrackLength = strtoul( pszINIBuffer, NULL, 10 );

    XDBGTRC( APP_TITLE_NAME_A, "CreateTrackForST():pwszTrackName - '%ls'", pwszTrackName );
    XDBGTRC( APP_TITLE_NAME_A, "CreateTrackForST():dwTrackLength - '%d'", dwTrackLength );
    
    // Add the track to the ST DB
    DWORD dwSongID = DashGetNewSongId( dwSoundtrackID );
    // Create the Track
    if( !DashAddSongToSoundtrack( dwSoundtrackID, dwSongID, dwTrackLength * 1000, pwszTrackName ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CreateTrackForST():Failed to add song to soundtrack!! - '%ls', Length - '%d'", pwszTrackName, dwTrackLength * 1000 );
    }
    else
    {
        // Copy the file to represent the song
        char pszSourceMusicFile[MAX_PATH+1];
        char pszMusicFile[MAX_PATH+1];
        
        ZeroMemory( pszMusicFile, MAX_PATH+1 );
        ZeroMemory( pszSourceMusicFile, MAX_PATH+1 );

        _snprintf( pszMusicFile, MAX_PATH, "%c:\\%s\\music\\%.4X\\%.8X.WMA", FILE_DATA_TDATA_DRIVE_LETTER_A, FILE_DATA_XDASH_TITLEID, dwSoundtrackID, dwSongID );
        _snprintf( pszSourceMusicFile, MAX_PATH, FILE_WMATRACK_LOCATION_A, pszTrackIDText, uiTrackNum );

        if( !CopyFile( pszSourceMusicFile, pszMusicFile, FALSE ) )
        {
            XDBGWRN( APP_TITLE_NAME_A, "CreateTrackForST():Failed to copy the file!! Source - '%hs', Dest - '%hs'", pszSourceMusicFile, pszMusicFile );
        }
        else
        {
            SetFileAttributes( pszMusicFile, FILE_ATTRIBUTE_NORMAL );
        }
    }
}


void CreateMusicFile( char* pszMusicFile )
{
    if( NULL == pszMusicFile )
    {
        return;
    }

    char pszSourceMusicFile[MAX_PATH+1];
    ZeroMemory( pszSourceMusicFile, MAX_PATH+1 );
    _snprintf( pszSourceMusicFile, MAX_PATH, FILE_WMATRACK_LOCATION_A, "Track", 1 );

    if( !CopyFile( pszSourceMusicFile, pszMusicFile, FALSE ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CreateMusicFile():Failed to copy the file!! Source - '%hs', Dest - '%hs'", pszSourceMusicFile, pszMusicFile );
    }
    else
    {
        SetFileAttributes( pszMusicFile, FILE_ATTRIBUTE_NORMAL );
    }
}

DWORD WINAPI DataCreateThreadFunc( LPVOID lpParameter )
{
    CSTMenu* pSTMenu = (CSTMenu*)lpParameter;

    pSTMenu->BeginUseDashSTFuncs();

    switch( pSTMenu->GetSelectedItem() )
    {
    case STMENU_ITEM_CREATE_SMALL_SOUNDTRACKS_AND_TRACKS:
    case STMENU_ITEM_CREATE_SOUNDTRACKS_AND_TRACKS:
        {
            BOOL bUseSmallTracks = FALSE;
            if( STMENU_ITEM_CREATE_SMALL_SOUNDTRACKS_AND_TRACKS == pSTMenu->GetSelectedItem() )
            {
                bUseSmallTracks = TRUE;
            }

            WCHAR pwszSoundtrack[MENU_ST_SOUNDTRACKNAME_SIZE];
            WCHAR pwszTrack[MENU_ST_TRACKNAME_SIZE];

            // Create the Soundtracks
            DWORD dwNumSTs = DashGetSoundtrackCount();
            for( DWORD x = 0; x < pSTMenu->m_dwNumSoundtracks; x++ )
            {
                ZeroMemory( pwszSoundtrack, sizeof( WCHAR ) * MENU_ST_SOUNDTRACKNAME_SIZE );

                DWORD dwNumSTs = DashGetSoundtrackCount();

                _snwprintf( pwszSoundtrack, MENU_ST_SOUNDTRACKNAME_SIZE - 1, L"Test Soundtrack %d", ( ++dwNumSTs ) );

                // Create the Soundtrack and store the ST ID
                if( !DashAddSoundtrack( pwszSoundtrack, &pSTMenu->m_dwCurrentST ) )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%ls'", pwszSoundtrack );

                    // Break out of the loop early
                    break;
                }

                // Create Track for Soundtrack
                for( DWORD y = 0; y < pSTMenu->m_dwNumTracks; y++ )
                {
                    CreateTrackForST( pSTMenu->m_dwCurrentST, bUseSmallTracks );
                }
            }

            // Set this to zero, so the user doesn't try to create Tracks
            pSTMenu->m_dwCurrentST = 0;

            break;
        }
    case STMENU_ITEM_CREATE_NAMED_SOUNDTRACK:
        {
            // Create the Soundtrack and store the ST ID
            if( !DashAddSoundtrack( pSTMenu->m_pwszValueBuffer, &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }

            break;
        }
    case STMENU_ITEM_ADD_NAMED_TRACK_TO_SOUNDTRACK:
        {
            // Create the Track using the current ST ID
            DWORD dwSongID = DashGetNewSongId( pSTMenu->m_dwCurrentST );

            // Create the Track
            if( !DashAddSongToSoundtrack( pSTMenu->m_dwCurrentST, dwSongID, pSTMenu->m_dwTrackLength, pSTMenu->m_pwszValueBuffer ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to add song to soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
            }
            else
            {
                // Create a file to represent the song
                char pszMusicFile[MAX_PATH+1];
                ZeroMemory( pszMusicFile, MAX_PATH+1 );

                _snprintf( pszMusicFile, MAX_PATH, "%c:\\%s\\music\\%.4X\\%.8X.WMA", FILE_DATA_TDATA_DRIVE_LETTER_A, FILE_DATA_XDASH_TITLEID, pSTMenu->m_dwCurrentST, dwSongID );
                CreateMusicFile( pszMusicFile );
            }
    
            break;
        }
	case STMENU_ITEM_CREATE_SORTING:
		{
            // Create the Soundtrack and store the ST ID
            if( !DashAddSoundtrack( L"Z", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }

			// Create the Soundtrack and store the ST ID
            if( !DashAddSoundtrack( L"zZ", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }

            if( !DashAddSoundtrack( L"Ba", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }

			// Create the Soundtrack and store the ST ID
            if( !DashAddSoundtrack( L"bA", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            } 
			if( !DashAddSoundtrack( L"AA", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }

			// Create the Soundtrack and store the ST ID
            if( !DashAddSoundtrack( L"a", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            } 
			if( !DashAddSoundtrack( L"y", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }

			// Create the Soundtrack and store the ST ID
            if( !DashAddSoundtrack( L"A!", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }
            if( !DashAddSoundtrack( L"Yx", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }

			// Create the Soundtrack and store the ST ID
            if( !DashAddSoundtrack( L"$6", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }
			if( !DashAddSoundtrack( L"Z*", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }

			// Create the Soundtrack and store the ST ID
            if( !DashAddSoundtrack( L"#A#", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }
			if( !DashAddSoundtrack( L"Z1", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }

			// Create the Soundtrack and store the ST ID
            if( !DashAddSoundtrack( L"5Y", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }
			if( !DashAddSoundtrack( L"@k@", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }
			if( !DashAddSoundtrack( L"b&b", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }


            break;
        }



	case STMENU_ITEM_CREATE_SORTING_JAP:
		{
           // Create the Soundtrack and store the ST ID
			if( !DashAddSoundtrack( L"\x3088" L"z", &pSTMenu->m_dwCurrentST ) )	//Hirigana then English
			{
					XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
					XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
			}
			if( !DashAddSoundtrack( L"z" L"\x3088", &pSTMenu->m_dwCurrentST ) )	//English then Hirigana
			{
					XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
					XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
			}
			if( !DashAddSoundtrack( L"\x30E4" L"X", &pSTMenu->m_dwCurrentST ) )	//Katakana then English
			{
					XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
					XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
			}
			if( !DashAddSoundtrack( L"X" L"\x30E4", &pSTMenu->m_dwCurrentST ) )	//English the Kataka
			{
					XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
					XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
			}
			if( !DashAddSoundtrack( L"\x3093" L"F", &pSTMenu->m_dwCurrentST ) )	//Hirigana then English
			{
					XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
					XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
			}
			if( !DashAddSoundtrack( L"F" L"\x3093", &pSTMenu->m_dwCurrentST ) )	//English then Hirigana
			{
					XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
					XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
			}
			if( !DashAddSoundtrack( L"A9", &pSTMenu->m_dwCurrentST ) )
			{
					XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
					XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
			}
			if( !DashAddSoundtrack( L"B6", &pSTMenu->m_dwCurrentST ) )
			{
					XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
					XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
			}
			if( !DashAddSoundtrack( L"B8", &pSTMenu->m_dwCurrentST ) )
			{
					XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
					XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
			}
			
			// Create the Soundtrack and store the ST ID
            if( !DashAddSoundtrack( L"\x30ED\x30ED", &pSTMenu->m_dwCurrentST ) ) //last char of Katakana
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }

			// Create the Soundtrack and store the ST ID
            if( !DashAddSoundtrack( L"\x30ED", &pSTMenu->m_dwCurrentST ) )  //last char of Katakana
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }

            if( !DashAddSoundtrack( L"\x3041", &pSTMenu->m_dwCurrentST ) )  //first char of Hirigana
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }

			// Create the Soundtrack and store the ST ID
            if( !DashAddSoundtrack( L"\x3041\x3041", &pSTMenu->m_dwCurrentST ) )  //first char of Hirigana
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            } 
			if( !DashAddSoundtrack( L"z", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }

			// Create the Soundtrack and store the ST ID
            if( !DashAddSoundtrack( L"ZZ", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            } 
			if( !DashAddSoundtrack( L"Aa", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }

			// Create the Soundtrack and store the ST ID
            if( !DashAddSoundtrack( L"\x30FC", &pSTMenu->m_dwCurrentST ) )  //last char of Hirigana
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }
            if( !DashAddSoundtrack( L"\x30FC\x30FC", &pSTMenu->m_dwCurrentST ) )  //last char of Hirigana
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }

			// Create the Soundtrack and store the ST ID
            if( !DashAddSoundtrack( L"\x30A1", &pSTMenu->m_dwCurrentST ) )  //first char of katakana
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }
			if( !DashAddSoundtrack( L"\x30A1\x30A1", &pSTMenu->m_dwCurrentST ) )  //first char of katakana
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }

			// Create the Soundtrack and store the ST ID
            if( !DashAddSoundtrack( L"\x3041" L"1", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }
			if( !DashAddSoundtrack( L"01", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }

			// Create the Soundtrack and store the ST ID
            if( !DashAddSoundtrack( L"!!", &pSTMenu->m_dwCurrentST ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }
			// Create the Soundtrack and store the ST ID
            if( !DashAddSoundtrack( L"@"L"\x3088\x30E6", &pSTMenu->m_dwCurrentST ) ) //@ then Hirigana then Katakana
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }
						// Create the Soundtrack and store the ST ID
            if( !DashAddSoundtrack( L"\x30E8\x3082", &pSTMenu->m_dwCurrentST ) ) //Katakana then Hirigana
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }
						// Create the Soundtrack and store the ST ID
            if( !DashAddSoundtrack(L"\x3082\x30E8", &pSTMenu->m_dwCurrentST ) )  //Hirigana then Katakana
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to create Soundtrack!! - '%S'", pSTMenu->m_pwszValueBuffer );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }

            break;
        }



    case STMENU_ITEM_REMOVE_ALL_SOUNDTRACKS:
        {
            HANDLE hSTHandle = NULL;
            XSOUNDTRACK_DATA stData;
            ZeroMemory( &stData, sizeof( stData ) );

            // Get the number of Soundtracks
            DWORD dwNumSTs = DashGetSoundtrackCount();
            
            XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():dwNumSTs - '%d'", dwNumSTs );

            // Check to see if there are any soundtracks.  If not, leave
            if( 0 == dwNumSTs )
            {
                break;
            }

            // Create a buffer to hold all of the ST Id's
            DWORD* pdwSTIDs = new DWORD[dwNumSTs];
            // Make sure our allocation succeeded
            if( !pdwSTIDs )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to allocated memory!!" );

                break;
            }

            unsigned int uiCounter = 0;

            pSTMenu->EndUseDashSTFuncs();  // Must call this before XFindFirstSoundtrack and XFindNextSoundtrack will work

            hSTHandle = XFindFirstSoundtrack( &stData );
            if( INVALID_HANDLE_VALUE != hSTHandle )
            {
                // Enumerate through the soundtracks and store the ID info
                pdwSTIDs[uiCounter++] = stData.uSoundtrackId;

                // Find the rest of the soundtracks
                while( XFindNextSoundtrack( hSTHandle, &stData ) )
                {
                    pdwSTIDs[uiCounter++] = stData.uSoundtrackId;
                }

                // Close our handle to the soundtracks
                XFindClose( hSTHandle );

                unsigned int uiNumDeleted = 0;

                // Now that we are done with FindFirst/Next, we can re-activate this
                pSTMenu->BeginUseDashSTFuncs();

                // Remove the soundtracks
                for( unsigned int x = 0; x < dwNumSTs; x++ )
                {
                    if( !DashDeleteSoundtrack( pdwSTIDs[x] ) )
                    {
                        XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to delete soundtrack - '%d'!!", pdwSTIDs[x] );
                        XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
                    }
                    else
                    {
                        uiNumDeleted++;
                    }
                }

                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Found   %d soundtracks", dwNumSTs );
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Deleted %d soundtracks", uiNumDeleted );
            }
            else
            //
            // We failed to find a soundtrack
            //
            {
                XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to find a Soundtrack!! - '0x%.8X', '%d'", GetLastError(), GetLastError() );

                // Make sure we don't call close on this
                hSTHandle = NULL;
            }

            // Clean up memory
            if( pdwSTIDs )
            {
                delete[] pdwSTIDs;
                pdwSTIDs = NULL;
            }

            // Make sure we don't have an ST active
            pSTMenu->EnterCritSection();
            pSTMenu->m_dwCurrentST = 0;
            pSTMenu->LeaveCritSection();

            break;
        }
    }

    // Reset these two variables so that menu's know where they are in certain processes
    pSTMenu->EnterCritSection();
    pSTMenu->m_dwNumSoundtracks = 0;
    pSTMenu->m_dwNumTracks = 0;
	pSTMenu->m_dwTrackLength = 0;
	ZeroMemory( pSTMenu->m_pwszTrackName, sizeof( WCHAR ) * MENU_ST_TRACKNAME_SIZE );
    pSTMenu->LeaveCritSection();

    // Stop using the Soundtrack APIs
    pSTMenu->EndUseDashSTFuncs();

    return 0;
}


// Signal that we will begin using the Dash ST funcs
BOOL CSTMenu::BeginUseDashSTFuncs()
{
    // Enter our critical section since we will access shared memory
    EnterCritSection();

    // Check to see if somebody is using the Dash Soundtrack APIs
    if( m_bUsingDashSTFuncs )
    {
        LeaveCritSection();

        return FALSE;
    }

    // Map the TDATA directory to the Dashboard Directory
    g_HardDrive.MapTDataToTitleID( FILE_DATA_XDASH_TITLEID );

    BOOL fReturn = DashBeginUsingSoundtracks();

    // Begin using the Dash Sountrack APIs -- Try to open the ST DB file
    if( !fReturn )
    //
    // No, we failed to open the ST DB file
    //
    {
        // Map the TDATA directory back to the Original Location
        g_HardDrive.MapTDataToTitleID( FILE_DATA_CONFIG_TITLEID );

        XDBGWRN( APP_TITLE_NAME_A, "CSTMenu::DataCreateThreadFunc():Failed to Begin Using Soundtracks!!" );
    }
    else
    //
    // Yes, we opened the ST DB file
    //
    {
        m_bUsingDashSTFuncs = TRUE;
    }

    // Leave our critical section
    LeaveCritSection();

    return fReturn;
}


// Signal that we will stop using the Dash ST funcs
BOOL CSTMenu::EndUseDashSTFuncs()
{
    // Enter our critical section since we will access shared memory
    EnterCritSection();

    // Check to make sure somebody is using the Dash ST Funcs
    if( m_bUsingDashSTFuncs )
    {
        // Stop using the Dash Soundtrack APIs
        DashEndUsingSoundtracks();

        // Map the TDATA directory back to the Original Location
        g_HardDrive.MapTDataToTitleID( FILE_DATA_CONFIG_TITLEID );
    }

    m_bUsingDashSTFuncs = FALSE;

    // Leave our critical section
    LeaveCritSection();

    return TRUE;
}


void CSTMenu::EnterCritSection()
{
    // Enter our critical section since we will access shared memory
    EnterCriticalSection( &m_CritSec );
}

void CSTMenu::LeaveCritSection()
{
    // Leave our critical section
    LeaveCriticalSection( &m_CritSec );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\sndtrk\bootmbr.h ===
#define X86BOOTCODE_SIZE 512


unsigned char x86BootCode[] = {
51,192,142,208,188,0,124,251,80,7,80,31,252,190,27,124,
191,27,6,80,87,185,229,1,243,164,203,189,190,7,177,4,
56,110,0,124,9,117,19,131,197,16,226,244,205,24,139,245,
131,198,16,73,116,25,56,44,116,246,160,181,7,180,7,139,
240,172,60,0,116,252,187,7,0,180,14,205,16,235,242,136,
78,16,232,70,0,115,42,254,70,16,128,126,4,11,116,11,
128,126,4,12,116,5,160,182,7,117,210,128,70,2,6,131,
70,8,6,131,86,10,0,232,33,0,115,5,160,182,7,235,
188,129,62,254,125,85,170,116,11,128,126,16,0,116,200,160,
183,7,235,169,139,252,30,87,139,245,203,191,5,0,138,86,
0,180,8,205,19,114,35,138,193,36,63,152,138,222,138,252,
67,247,227,139,209,134,214,177,6,210,238,66,247,226,57,86,
10,119,35,114,5,57,70,8,115,28,184,1,2,187,0,124,
139,78,2,139,86,0,205,19,115,81,79,116,78,50,228,138,
86,0,205,19,235,228,138,86,0,96,187,170,85,180,65,205,
19,114,54,129,251,85,170,117,48,246,193,1,116,43,97,96,
106,0,106,0,255,118,10,255,118,8,106,0,104,0,124,106,
1,106,16,180,66,139,244,205,19,97,97,115,14,79,116,11,
50,228,138,86,0,205,19,235,214,97,249,195,73,110,118,97,
108,105,100,32,112,97,114,116,105,116,105,111,110,32,116,97,
98,108,101,0,69,114,114,111,114,32,108,111,97,100,105,110,
103,32,111,112,101,114,97,116,105,110,103,32,115,121,115,116,
101,109,0,77,105,115,115,105,110,103,32,111,112,101,114,97,
116,105,110,103,32,115,121,115,116,101,109,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,44,68,99,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,85,170
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\screenitems.cpp ===
/*****************************************************
*** screenitems.cpp
***
*** CPP file for our screen item classes.
*** This file will contain the definition for all
*** types of screen items
***
*** by James N. Helm
*** January 13th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "screenitems.h"

/*****************************************************
/* CTextItem()
/****************************************************/

// Constructor
CTextItem::CTextItem() :
CScreenItem(),
m_pwszText( NULL ),
m_fXPos( 0.0f ),
m_fYPos( 0.0f ),
m_dwFGColor( 0L ),
m_dwBGColor( 0L )
{
}

// Destructor
CTextItem::~CTextItem()
{
    // Clean up our allocated memory
    if( m_pwszText )
    {
        delete[] m_pwszText;
        m_pwszText = NULL;
    }
}

// Allows the user to update the information for the Text Item
void CTextItem::UpdateItem( WCHAR* pwszText, float fXPos, float fYPos, DWORD dwFGColor, DWORD dwBGColor )
{
    // Ensure we were passed a valid pointer
    if( !pwszText )
    {
        XDBGWRN( APP_TITLE_NAME_A, " CTextItem()::UpdateItem():pwszText was invalid!!" );

        return;
    }

    // If we have already set a text item, lets clear the memory so we can allocate new memory
    if( m_pwszText )
    {
        delete[] m_pwszText;
        m_pwszText = NULL;
    }

    // Create new memory and copy the string that was passed in by the user
    m_pwszText = _wcsdup( pwszText );

    // Check to see if we could allocate memory -- If not, assert!!
    if( !m_pwszText )
    {
        XDBGWRN( APP_TITLE_NAME_A, " CTextItem()::UpdateItem():Couldn't allocate memory!!" );
    }

    // Set our other parameters
    m_fXPos = fXPos;
    m_fYPos = fYPos;
    m_dwFGColor = dwFGColor;
    m_dwBGColor = dwBGColor;
}


// Used to render itself to the screen
void CTextItem::Render( IDirect3DDevice8* pD3DDevice, CUDTexture* pTexture )
{
    pTexture->DrawText( m_fXPos, m_fYPos, m_dwFGColor, m_dwBGColor, L"%s", m_pwszText );
}

/*****************************************************
/* CPanelItem()
/****************************************************/

// Constructor
CPanelItem::CPanelItem() :
CScreenItem(),
m_fX1Pos( 0.0f ),
m_fY1Pos( 0.0f ),
m_fX2Pos( 0.0f ),
m_fY2Pos( 0.0f ),
m_dwColor( 0L )
{
}

// Destructor
CPanelItem::~CPanelItem()
{
}

// Allows the user to update the information for the Panel Item
void CPanelItem::UpdateItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, DWORD dwColor )
{
    m_fX1Pos = fX1Pos;
    m_fY1Pos = fY1Pos;
    m_fX2Pos = fX2Pos;
    m_fY2Pos = fY2Pos;
    m_dwColor = dwColor;
}

// Used to render itself to the screen
void CPanelItem::Render( IDirect3DDevice8* pD3DDevice, CUDTexture* pTexture )
{
    pTexture->DrawBox( m_fX1Pos, m_fY1Pos, m_fX2Pos, m_fY2Pos, m_dwColor );
}


/*****************************************************
/* CLineItem()
/****************************************************/
// Constructor
CLineItem::CLineItem() :
CScreenItem(),
m_fX1Pos( 0.0f ),
m_fY1Pos( 0.0f ),
m_fX2Pos( 0.0f ),
m_fY2Pos( 0.0f ),
m_fWidth( 0.0f ),
m_dwColor( 0L )
{
}

// Destructor
CLineItem::~CLineItem()
{
}

// Allows the user to update the information for the Outline Item
void CLineItem::UpdateItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, float fWidth, DWORD dwColor )
{
    m_fX1Pos = fX1Pos;
    m_fY1Pos = fY1Pos;
    m_fX2Pos = fX2Pos;
    m_fY2Pos = fY2Pos;
    m_fWidth = fWidth;
    m_dwColor = dwColor;
}

// Used to render itself to the screen
void CLineItem::Render( IDirect3DDevice8* pD3DDevice, CUDTexture* pTexture )
{
    pTexture->DrawLine( m_fX1Pos, m_fY1Pos, m_fX2Pos, m_fY2Pos, m_fWidth, m_dwColor );
}


/*****************************************************
/* COutlineItem()
/****************************************************/
// Constructor
COutlineItem::COutlineItem() :
CScreenItem(),
m_fX1Pos( 0.0f ),
m_fY1Pos( 0.0f ),
m_fX2Pos( 0.0f ),
m_fY2Pos( 0.0f ),
m_fWidth( 0.0f ),
m_dwColor( 0L )
{
}

// Destructor
COutlineItem::~COutlineItem()
{
}

// Allows the user to update the information for the Outline Item
void COutlineItem::UpdateItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, float fWidth, DWORD dwColor )
{
    m_fX1Pos = fX1Pos;
    m_fY1Pos = fY1Pos;
    m_fX2Pos = fX2Pos;
    m_fY2Pos = fY2Pos;
    m_fWidth = fWidth;
    m_dwColor = dwColor;
}

// Used to render itself to the screen
void COutlineItem::Render( IDirect3DDevice8* pD3DDevice, CUDTexture* pTexture )
{
    pTexture->DrawOutline( m_fX1Pos, m_fY1Pos, m_fX2Pos, m_fY2Pos, m_fWidth, m_dwColor );
}


/*****************************************************
/* CBitmapItem()
/****************************************************/
// Constructor
CBitmapItem::CBitmapItem() :
CScreenItem(),
m_pszFilename( NULL ),
m_nXPos( 0 ),
m_nYPos( 0 )
{
}

// Destructor
CBitmapItem::~CBitmapItem()
{
    // Clean up our memory
    if( m_pszFilename )
    {
        delete[] m_pszFilename;
        m_pszFilename = NULL;
    }
}

// Allows the user to update the information for the Outline Item
void CBitmapItem::UpdateItem( char* pszFilename, int nXPos, int nYPos )
{
    // Ensure we were passed a valid pointer
    if( !pszFilename )
    {
        XDBGWRN( APP_TITLE_NAME_A, " CBitmapItem()::UpdateItem():pszFilename was invalid!!" );

        return;
    }

    // If we have already set a text item, lets clear the memory so we can allocate new memory
    if( m_pszFilename )
    {
        delete[] m_pszFilename;
        m_pszFilename = NULL;
    }

    // Create new memory and copy the string that was passed in by the user
    m_pszFilename = _strdup( pszFilename );

    // Check to see if we could allocate memory -- If not, assert!!
    if( !m_pszFilename )
    {
        XDBGWRN( APP_TITLE_NAME_A, " CBitmapItem()::UpdateItem():Couldn't allocate memory!!" );

        return;
    }

    m_nXPos = nXPos;
    m_nYPos = nYPos;

    m_Bitmap.read( m_nXPos, m_nYPos, m_pszFilename );
}

// Used to render itself to the screen
void CBitmapItem::Render( IDirect3DDevice8* pD3DDevice, CUDTexture* pTexture )
{
    m_Bitmap.render( pD3DDevice, pTexture->GetTextureSurface() );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\sndtrk\draw.cpp ===
/*--
Copyright (c) 2000 Microsoft Corporation - Xbox SDK

Module Name:

    draw.cpp

Abstract:

    Simple sample for drawing text on the screen.

Revision History:

    Derived from a DX8 sample.
--*/

#include <xtl.h>

#include "d3d8.h"
#include "bitfont.h"

//------------------------------------------------------------------------------
// Draw
//
// Handy little D3D encapsulation for simple 2D drawing.

class Draw
{
private:

    static IDirect3DDevice8* m_pDevice;

    IDirect3DSurface8* m_pBackBuffer;

    BitFont m_font;

public:

    Draw(INT width = 640, INT height = 480);

    ~Draw();

    VOID FillRect(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);

    VOID DrawText(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);

    VOID Present();

    BOOL IsValid() { return m_pDevice != NULL; }
};

//------------------------------------------------------------------------------
// Draw::m_pDevice
//
// Instantiate static class member, initialized to NULL.

IDirect3DDevice8* Draw::m_pDevice;

//------------------------------------------------------------------------------
// Draw constructor

Draw::Draw(INT width, INT height)
{
    m_pBackBuffer = NULL;

    // If we're invoked multiple times, we inherit the old mode (largely
    // because we don't support multiple mode sets on Xbox yet):

    if (m_pDevice == NULL)
    {
        // Create D3D 8.
    
        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (pD3D == NULL)
            return;
    
        // Set the screen mode.
    
        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));
    
        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;
        d3dpp.hDeviceWindow             = NULL;
    
        // Create the device.
    
        if (pD3D->CreateDevice
        (
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            NULL,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &m_pDevice
        ) != S_OK)
        {
            pD3D->Release();

            return;
        }
    
        // Now we no longer need the D3D interface so let's free it.
    
        pD3D->Release();
    }

    m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer);
}

//------------------------------------------------------------------------------
// Draw::~Draw

Draw::~Draw()
{
    if (m_pBackBuffer)
        m_pBackBuffer->Release();
}

//------------------------------------------------------------------------------
// Draw::FillRect

VOID Draw::FillRect(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    D3DRECT rect;

    if (m_pDevice != NULL)
    {
        rect.x1 = x;
        rect.y1 = y;
        rect.x2 = x + width;
        rect.y2 = y + height;

        m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
    }
}

//------------------------------------------------------------------------------
// Draw::DrawText

VOID Draw::DrawText(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    if (m_pBackBuffer != NULL)
    {
        m_font.DrawText(m_pBackBuffer, string, x, y, flags, foregroundColor,
                        backgroundColor);
    }
}

//------------------------------------------------------------------------------
// Draw::Present
//
// Make the current back-buffer visible

VOID Draw::Present()
{
    if (m_pDevice != NULL)
    {
        m_pDevice->Present(NULL, NULL, NULL, NULL);
    }
}

//------------------------------------------------------------------------------
// Test

extern "C" VOID DrawMessage(LPCWSTR pcszText, int iProgPercent)
{
    Draw draw;

    draw.FillRect(0, 0, 640, 480, 0x000080);            // Draw border in dark blue
    draw.FillRect(20, 20, 600, 440, 0);                 // Fill interior with black
    draw.DrawText(pcszText, 100, 100, 0xbbbbff);
    
    if (-1 != iProgPercent)
    {
        //
        // Draw progress bar background
        //

        draw.FillRect(215, 220, 210, 40, 0x000080);
        
        //
        // Draw progress bar
        //

        draw.FillRect(220, 225, 2 * min(iProgPercent, 100), 30, 0xbbbbff);
    }
    draw.Present();                                     // Show the buffer
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\xbconfigmenu.h ===
/*****************************************************
*** xbconfigmenu.h
***
*** Header file for our Xbox Config menu
*** class. This menu class will allow you to change
*** various options on the Xbox
***
*** by James N. Helm
*** May 10th, 2001
***
*****************************************************/

#ifndef _XBCONFIGMENU_H_
#define _XBCONFIGMENU_H_

#include "menuscreen.h"     // Base menu type

// Sub-Menus
#include "gameregionmenu.h" // Set Xbox Game Region
#include "dvdregionmenu.h"  // Set Xbox DVD Region
#include "avregionmenu.h"   // Set Xbox AV Region

class CXBConfigMenu : public CMenuScreen
{
public:
    CXBConfigMenu( CXItem* pParent );
    ~CXBConfigMenu();

    // Must be overridden for this to be a Item on our XShell program
    // void Enter();   // Called whenever this menu is entered / activated
    void Action( CUDTexture* pTexture );
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress );

    // Public Methods
    HRESULT Init( IDirect3DDevice8* pD3DDevice, char* menuFileName );       // Initialize our font and settings

private:
    CGameRegionMenu m_MenuGameRegion;                                       // Allow the user to set the Xbox Game Region
    CDVDRegionMenu  m_MenuDVDRegion;                                        // Allow the user to set the Xbox DVD Region
    CAVRegionMenu   m_MenuAVRegion;                                         // Allow the user to set the Xbox AV Region
    BOOL            m_bXboxReset;                                           // Used to determine if the user has reset the Xbox
    BOOL            m_bCDriveCorrupt;                                       // Used to determine if the user has corrupted the C Drive
    BOOL            m_bYDriveCorrupt;                                       // Used to determine if the user has corrupted the Y Drive
    BOOL            m_bTimeZoneReset;                                       // Used to determine if the user has Reset the TimeZone
    BOOL            m_bLanguageReset;                                       // Used to determine if the user has Reset the Language
    BOOL            m_bClockReset;                                          // Used to determine if the user has Reset the Clock

    unsigned int    m_uiTopItemIndex;                                       // Index of the top item being displayed
    unsigned int    m_uiNumItemsToDisplay;                                  // Used to hold the number of items to display on our menu

    // Private Methods
    // void Leave( CXItem* pItem );                                        // This should be called whenever a user leaves this menu
};

#define MUOPTIONS_MENU_NUM_ITEMS_TO_DISPLAY    9

#endif // _XBCONFIGMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\MUConfig\xbconfigmenu.cpp ===
/*****************************************************
*** xbconfigmenu.cpp
***
*** CPP file for our Xbox Config menu
*** class. This menu class will allow you to change
*** various options on the Xbox
***
*** by James N. Helm
*** May 10th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "xbconfigmenu.h"

extern CXSettings g_XboxSettings;   // Xbox Settings Object
extern CHardDrive g_HardDrive;      // Xbox Hard Drive

// Constructors
CXBConfigMenu::CXBConfigMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_MenuGameRegion( NULL ),
m_MenuAVRegion( NULL ),
m_MenuDVDRegion( NULL ),
m_bXboxReset( FALSE ),
m_bCDriveCorrupt( FALSE ),
m_bYDriveCorrupt( FALSE ),
m_bTimeZoneReset( FALSE ),
m_bLanguageReset( FALSE ),
m_bClockReset( FALSE ),
m_uiTopItemIndex( 0 ),
m_uiNumItemsToDisplay( MUOPTIONS_MENU_NUM_ITEMS_TO_DISPLAY )
{
    XDBGWRN( APP_TITLE_NAME_A, "CXBConfigMenu::CXBConfigMenu()" );

    m_uiNumItems = XBCONFIGMENU_ITEM_NUM_ITEMS;
    SetSelectedItem( 0 );
}


// Destructor
CXBConfigMenu::~CXBConfigMenu()
{
}

// Draws a menu on to the screen
void CXBConfigMenu::Action( CUDTexture* pTexture )
{
    // Check to see if our settings have changed
    g_XboxSettings.LoadSettings();

    if( g_XboxSettings.SettingsHaveChanged() )
    {
        m_bUpdateTexture = TRUE;
    }

    // Check to see if we should update the texture
    // If not, return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else // reset the texture flag to FALSE
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

    DWORD dwItemColor = 0;

    // Draw a selector around the current item
    float X1Pos = MENUBOX_SELECTOR_X1;
    float Y1Pos = MENUBOX_MAINAREA_Y1 + MENUBOX_MAINAREA_BORDERWIDTH_TOP + ( ( MENUBOX_ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( GetSelectedItem() - m_uiTopItemIndex ) ) - MENUBOX_SELECTOR_BORDER_WIDTH;
    float X2Pos = MENUBOX_SELECTOR_X2;
    float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * MENUBOX_SELECTOR_BORDER_WIDTH );

    pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, SCREEN_DEFAULT_SELECTOR_COLOR );

    // Draw the Menu Options
    for( unsigned int x = m_uiTopItemIndex; x < ( m_uiNumItemsToDisplay + m_uiTopItemIndex ); ++x )
    {
        // Make sure we don't try to access out of range items
        if( x == GetNumItems() )
        {
            break;
        }

        float XPos = MENUBOX_MAINAREA_X1 + MENUBOX_MAINAREA_BORDERWIDTH_LEFT;
        float YPos = MENUBOX_MAINAREA_Y1 + MENUBOX_MAINAREA_BORDERWIDTH_TOP + ( ( MENUBOX_ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( x - m_uiTopItemIndex ) );

        DWORD dwItemColor = SCREEN_ACTIVE_OPTION_COLOR;

        pTexture->DrawText( XPos, YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L"%s", g_wpszXBConfigMenuItems[x] );

        switch( x )
        {
        case XBCONFIGMENU_ITEM_RESET_XBOX_TO_DEFAULTS:
            {
                if( m_bXboxReset )
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (TRUE)" );
                }
                else
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (FALSE)" );
                }

                break;
            }
        case XBCONFIGMENU_ITEM_RESET_CLOCK:
            {
                if( m_bClockReset )
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (TRUE)" );
                }
                else
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (FALSE)" );
                }

                break;
            }
        case XBCONFIGMENU_ITEM_RESET_TIMEZONE:
            {
                if( m_bTimeZoneReset )
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (TRUE)" );
                }
                else
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (FALSE)" );
                }

                break;
            }
        case XBCONFIGMENU_ITEM_RESET_LANGUAGE:
            {
                if( m_bLanguageReset )
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (TRUE)" );
                }
                else
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (FALSE)" );
                }

                break;
            }
        case XBCONFIGMENU_ITEM_SET_GAME_REGION:
            {
                pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (%d)", g_XboxSettings.GetGameRegion() );

                break;
            }
        case XBCONFIGMENU_ITEM_SET_DVD_REGION:
            {
                pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (%d)", g_XboxSettings.GetDVDRegion() );

                break;
            }
        case XBCONFIGMENU_ITEM_SET_AV_REGION:
            {
                pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (%d)", g_XboxSettings.GetAVRegion() );

                break;
            }
        case XBCONFIGMENU_ITEM_DISPLAY_RECKEY:
            {
                UCHAR pszRecKey[RECOVERY_KEY_LEN+1];
                ZeroMemory( pszRecKey, RECOVERY_KEY_LEN+1 );
                
                g_XboxSettings.GetHDRecoveryKey( pszRecKey, RECOVERY_KEY_LEN );

                pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (%hs)", pszRecKey );
                
                break;
            }
        case XBCONFIGMENU_ITEM_CLEAR_REFERB:
            {
                NTSTATUS status;
                XBOX_REFURB_INFO refurbInfo;

                status = ExReadWriteRefurbInfo(&refurbInfo, sizeof(refurbInfo), FALSE);
                if( !NT_SUCCESS(status) )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "CXBConfigMenu::Action():Failed to Read the RefurbInfo!! Error - '0x%0.8X (%d)'", status, status );
                }
                else
                {
                    SYSTEMTIME systime;
                    FileTimeToSystemTime((FILETIME*) &refurbInfo.FirstSetTime, &systime);

                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (SC:%u %d/%d/%d %d %02d:%02d:%02d.%03d)", refurbInfo.PowerCycleCount, systime.wMonth, systime.wDay, systime.wYear, systime.wDayOfWeek, systime.wHour, systime.wMinute, systime.wSecond, systime.wMilliseconds );
                }

                break;
            }
        case XBCONFIGMENU_ITEM_CORRUPT_CDRIVE:
            {
                if( m_bCDriveCorrupt )
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (Corrupt)" );
                }
                else
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (Healthly)" );
                }

                break;
            }
        case XBCONFIGMENU_ITEM_CORRUPT_YDRIVE:
            {
                if( m_bYDriveCorrupt )
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (Corrupt)" );
                }
                else
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (Healthly)" );
                }

                break;
            }
        case XBCONFIGMENU_ITEM_TOGGLE_DTS:
            {
                if( g_XboxSettings.GetDTS() )
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (Enabled)" );
                }
                else
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (Disabled)" );
                }

                break;
            }
        case XBCONFIGMENU_ITEM_TOGGLE_DOLBY:
            {
                if( g_XboxSettings.GetDolbyDigital() )
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (Enabled)" );
                }
                else
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (Disabled)" );
                }

                break;
            }
        case XBCONFIGMENU_ITEM_TOGGLE_1080I:
            {
                if( g_XboxSettings.Get1080i() )
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (Enabled)" );
                }
                else
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (Disabled)" );
                }

                break;
            }
        case XBCONFIGMENU_ITEM_TOGGLE_720P:
            {
                if( g_XboxSettings.Get720p() )
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (Enabled)" );
                }
                else
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (Disabled)" );
                }

                break;
            }
        case XBCONFIGMENU_ITEM_TOGGLE_480P:
            {
                if( g_XboxSettings.Get480p() )
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (Enabled)" );
                }
                else
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (Disabled)" );
                }

                break;
            }
        case XBCONFIGMENU_ITEM_TOGGLE_PAL60:
            {
                if( g_XboxSettings.GetPAL60() )
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (Enabled)" );
                }
                else
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (Disabled)" );
                }

                break;
            }
        case XBCONFIGMENU_ITEM_TOGGLE_WIDESCREEN:
            {
                if( g_XboxSettings.GetWidescreen() )
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (Enabled)" );
                }
                else
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (Disabled)" );
                }

                break;
            }
        case XBCONFIGMENU_ITEM_TOGGLE_LETTERBOX:
            {
                if( g_XboxSettings.GetLetterbox() )
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (Enabled)" );
                }
                else
                {
                    pTexture->DrawText( XPos + GetStringPixelWidth( g_wpszXBConfigMenuItems[x] ), YPos, dwItemColor, SCREEN_DEFAULT_BACKGROUND_COLOR, L" (Disabled)" );
                }

                break;
            }
        }
    }

    // Unlock our texture and restore our render target
    pTexture->Unlock();
}


// Handle any requests for the joystick (thumb-pad)
void CXBConfigMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CXBConfigMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = INPUT_KEYPRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = INPUT_KEYPRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            if( GetSelectedItem() > 0 )
            {
                m_bUpdateTexture = TRUE;
                
                SetSelectedItem( GetSelectedItem() - 1 );

                // Make sure we are displaying the correct items
                if( GetSelectedItem() < (int)m_uiTopItemIndex )
                {
                    m_uiTopItemIndex = GetSelectedItem();
                }
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            if( (unsigned int)GetSelectedItem() < ( GetNumItems() - 1 ) )
            {
                m_bUpdateTexture = TRUE;

                SetSelectedItem( GetSelectedItem() + 1 );

                // Make sure we are displaying the correct items
                if( GetSelectedItem() >= (int)( m_uiNumItemsToDisplay + m_uiTopItemIndex ) )
                {
                    m_uiTopItemIndex += 1;
                }
            }
            break;
        }
    }
}


// Handles input (of the BUTTONS) for the current menu
void CXBConfigMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Refresh our Texture
            m_bUpdateTexture = TRUE;

            switch( GetSelectedItem() )
            {
            case XBCONFIGMENU_ITEM_RESET_XBOX_TO_DEFAULTS:
                {
                    m_bClockReset = TRUE;
                    m_bTimeZoneReset = TRUE;
                    m_bLanguageReset = TRUE;

					// Reset all of the Xbox settings to the their default values
                    if( FAILED( g_XboxSettings.ResetAllToDefaults() ) )
                    {
                        XDBGWRN( APP_TITLE_NAME_A, "CXBConfigMenu::HandleInput():Failed to Reset all settings to their initial state!!" );
                    }
                    else
                    {
                        m_bXboxReset = TRUE;
                        XDBGWRN( APP_TITLE_NAME_A, "CXBConfigMenu::HandleInput():Success!!  Reset the Xbox Config Sector!!" );
                    }

                    break;
                }
            case XBCONFIGMENU_ITEM_RESET_CLOCK:
                {
                    m_bClockReset = TRUE;

                    //
                    // Set the Clock to a very early date
                    //
                    SYSTEMTIME sysTime;
                    ZeroMemory( &sysTime, sizeof( sysTime ) );

                    sysTime.wHour = 0;
                    sysTime.wMinute = 0;
                    sysTime.wSecond = 0;
                    sysTime.wMilliseconds = 0;
                    sysTime.wMonth = 1;
                    sysTime.wDay = 1;
                    sysTime.wDayOfWeek = 0;
                    sysTime.wYear = 1980;

                    XapiSetLocalTime(&sysTime);

                    break;
                }
            case XBCONFIGMENU_ITEM_RESET_TIMEZONE:
                {
                    m_bTimeZoneReset = TRUE;

                    TIME_ZONE_INFORMATION tzinfo;
                    ZeroMemory( &tzinfo, sizeof( tzinfo ) );

                    XapipSetTimeZoneInformation(&tzinfo);

                    break;
                }
            case XBCONFIGMENU_ITEM_RESET_LANGUAGE:
                {
                    m_bLanguageReset = TRUE;

                    g_XboxSettings.SetLanguage( 0 );

                    break;
                }
            case XBCONFIGMENU_ITEM_SET_GAME_REGION:
                {
					// Allow the user to set the Xbox Game Region
                    Leave( &m_MenuGameRegion );

                    break;
                }
            case XBCONFIGMENU_ITEM_SET_DVD_REGION:
                {
                    m_bXboxReset = FALSE;

					// Allow the user to set the Xbox DVD Region
                    Leave( &m_MenuDVDRegion );

                    break;
                }
            case XBCONFIGMENU_ITEM_SET_AV_REGION:
                {
					// Allow the user to set the Xbox AV Region
                    Leave( &m_MenuAVRegion );

                    break;
                }
            case XBCONFIGMENU_ITEM_CHANGE_HDKEY:
                {
                    UCHAR puRandomKey[XBOX_KEY_LENGTH];
                    ZeroMemory( puRandomKey, XBOX_KEY_LENGTH * sizeof( UCHAR ) );

                    // Change the HD Key Randomly
                    for( unsigned int x = 0; x < XBOX_KEY_LENGTH; x++ )
                    {
                        int iResult = rand() % 255;
                        puRandomKey[x] = (UCHAR)iResult;
                    }

                    g_XboxSettings.SetHDKey( puRandomKey );

                    break;
                }
            case XBCONFIGMENU_ITEM_RESET_HDKEY:
                {
                    UCHAR puZeroKey[XBOX_KEY_LENGTH];
                    ZeroMemory( puZeroKey, XBOX_KEY_LENGTH * sizeof( UCHAR ) );

                    g_XboxSettings.SetHDKey( puZeroKey );

                    break;
                }
            case XBCONFIGMENU_ITEM_CLEAR_REFERB:
                {
                    NTSTATUS status;
                    XBOX_REFURB_INFO refurbInfo;

                    ZeroMemory( &refurbInfo, sizeof( refurbInfo ) );

                    status = ExReadWriteRefurbInfo(&refurbInfo, sizeof(refurbInfo), TRUE);
                    if( !NT_SUCCESS(status) )
                    {
                        XDBGWRN( APP_TITLE_NAME_A, "CXBConfigMenu::HandleInput():Failed to Clear the RefurbInfo!! Error - '0x%0.8X (%d)'", status, status );
                    }

                    break;
                }
            case XBCONFIGMENU_ITEM_CORRUPT_CDRIVE:
                {
                    OBJECT_STRING oCPart;

                    RtlInitObjectString( &oCPart, FILE_DATA_CDRIVE_PARTITION );

                    // Corrupt the C Partition
                    if( !g_HardDrive.CorruptPartition( &oCPart ) )
                    {
                        XDBGWRN( APP_TITLE_NAME_A, "CXBConfigMenu::HandleInput():Failed to corrupt the C Partition!! Partition - '%hs', Error - '0x%0.8X (%d)'", FILE_DATA_CDRIVE_PARTITION, GetLastError(), GetLastError() );
                    }
                    else
                    {
                        m_bCDriveCorrupt = TRUE;
                    }

                    break;
                }
            case XBCONFIGMENU_ITEM_CORRUPT_YDRIVE:
                {
                    OBJECT_STRING oYPart;

                    RtlInitObjectString( &oYPart, FILE_DATA_YDRIVE_PARTITION );

                    // Corrupt the C Partition
                    if( !g_HardDrive.CorruptPartition( &oYPart ) )
                    {
                        XDBGWRN( APP_TITLE_NAME_A, "CXBConfigMenu::HandleInput():Failed to corrupt the Y Partition!! Partition - '%hs', Error - '0x%0.8X (%d)'", FILE_DATA_CDRIVE_PARTITION, GetLastError(), GetLastError() );
                    }
                    else
                    {
                        m_bYDriveCorrupt = TRUE;
                    }

                    break;
                }
            case XBCONFIGMENU_ITEM_TOGGLE_DTS:
                {
                    m_bXboxReset = FALSE;

                    g_XboxSettings.SetDTS( !g_XboxSettings.GetDTS() );

                    break;
                }
            case XBCONFIGMENU_ITEM_TOGGLE_DOLBY:
                {
                    m_bXboxReset = FALSE;

                    g_XboxSettings.SetDolbyDigital( !g_XboxSettings.GetDolbyDigital() );

                    break;
                }
            case XBCONFIGMENU_ITEM_TOGGLE_1080I:
                {
                    m_bXboxReset = FALSE;

                    g_XboxSettings.Set1080i( !g_XboxSettings.Get1080i() );

                    break;
                }
            case XBCONFIGMENU_ITEM_TOGGLE_720P:
                {
                    m_bXboxReset = FALSE;

                    g_XboxSettings.Set720p( !g_XboxSettings.Get720p() );

                    break;
                }
            case XBCONFIGMENU_ITEM_TOGGLE_480P:
                {
                    m_bXboxReset = FALSE;

                    g_XboxSettings.Set480p( !g_XboxSettings.Get480p() );

                    break;
                }
            case XBCONFIGMENU_ITEM_TOGGLE_PAL60:
                {
                    m_bXboxReset = FALSE;

                    g_XboxSettings.SetPAL60( !g_XboxSettings.GetPAL60() );

                    break;
                }
            case XBCONFIGMENU_ITEM_TOGGLE_WIDESCREEN:
                {
                    m_bXboxReset = FALSE;

                    g_XboxSettings.SetWidescreen( !g_XboxSettings.GetWidescreen() );

                    break;
                }
            case XBCONFIGMENU_ITEM_TOGGLE_LETTERBOX:
                {
                    m_bXboxReset = FALSE;

                    g_XboxSettings.SetLetterbox( !g_XboxSettings.GetLetterbox() );

                    break;
                }
            }

            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                Leave( GetParent() );
            }
            break;
        }
    case BUTTON_X:
        {
            break;
        }
    case BUTTON_Y:
        {
            break;
        }
    case BUTTON_BLACK:
        {
            break;
        }
    case BUTTON_WHITE:
        {
            break;
        }
    }
}


// Initialize the Menu
HRESULT CXBConfigMenu::Init( IDirect3DDevice8* pD3DDevice, char* menuFileName )
{
    XDBGWRN( APP_TITLE_NAME_A, "CXBConfigMenu::Init()" );

    CMenuScreen::Init( pD3DDevice, menuFileName );

    // Sub-Menu Initialization
    m_MenuGameRegion.SetParent( this );
    m_MenuGameRegion.Init( pD3DDevice, MENU_GAMEREGION_MENU_FILENAME_A );

    m_MenuDVDRegion.SetParent( this );
    m_MenuDVDRegion.Init( pD3DDevice, MENU_DVDREGION_MENU_FILENAME_A );

    m_MenuAVRegion.SetParent( this );
    m_MenuAVRegion.Init( pD3DDevice, MENU_AVREGION_MENU_FILENAME_A );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\sndtrk\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const CHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL,
            D3DLOCK_NOSYSLOCK | D3DLOCK_RAWDATA) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    PVOID pBits = Swizzler_GetUnswizzledBits(&lockRect, &desc);
    if (pBits == NULL)
    {
        assert(FALSE);
        pSurface->UnlockRect();
        return;
    }

    PVOID pBitsOld = lockRect.pBits;
    lockRect.pBits = pBits;

    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    lockRect.pBits = pBitsOld;
    Swizzler_SwizzleFromBits(pBits, &lockRect, &desc);

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree   
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\sndtrk\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const CHAR* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\sndtrk\xboxvideo.h ===
/*****************************************************
*** xboxvideo.h
***
*** Header file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#ifndef _XBOXVIDEO_H_
#define _XBOXVIDEO_H_

#include "constants.h"

// Macros
#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) XDBGWRN( APP_TITLE_NAME_A, #code "File %s Line %d, Failed: %d", __LINE__, __FILE__, _ret__); } while (0);

#define NUM_VB_VERTS            100

// XBox configuration
class CXBoxVideo
{
public:
    // Constructors and Destructors
    CXBoxVideo( void );
    ~CXBoxVideo( void );

    // Public Properties

    // Public Methods
    void Initialize( int width,                         // Initialize D3D for this screen -- height and width default
                     int height );
    
    void DeInitialize( void );                          // Free our objects
    void ClearScreen( DWORD color );                    // Clear the current screen
    
    void DrawBox( float x1,                             // Draw a box on the screen
                  float y1,
                  float x2,
                  float y2,
                  DWORD color );

    void DrawBitBlt( float fx,                          // Draw the inputed bit array to the screen
                     float fy,
                     ULONG ulWidth,
                     ULONG ulHeight,
                     const DWORD* pData );
    
    void DrawClearRect( float x1,                       // Draw a clear rectangle to the screen
                        float y1,
                        float x2,
                        float y2,
                        DWORD color );

    HRESULT DrawLine( float x1,                         // Draw a line on the screen
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    void DrawOutline( float x1,                         // Draw an outline at the current location with a specific border size
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    int DrawText( float x1,                             // Prints formatted text, using the default font size and color
                  float y1,
                  DWORD fgcolor,
                  DWORD bgcolor,
                  const TCHAR* format,
                  ... );

    int GetStringPixelWidth( IN LPCWSTR string,         // Get the pixel width of a string
                             IN int length = -1 );

    int GetStringPixelWidth( IN char* string,           // Get the pixel width of a char*
                             IN int length /*=-1*/ ); 

    void GetFontSize( unsigned int* pheight,            // Get the size of the currently selected font
                      unsigned int* pdecent );

    void LightenImage( int nWidth,                      // Lighten the image specified by "pBits"
                       int nHeight,
                       DWORD* pBits,
                       DWORD dwAddto );
    void DarkenImage( int nWidth,                       // Darken the image specified by "pBits"
                      int nHeight,
                      DWORD* pBits,
                      DWORD dwSubtract );

    HRESULT TruncateStringToFit( char* pString,         // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    HRESULT TruncateStringToFit( WCHAR* pString,        // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    IDirect3DDevice8* GetD3DDevicePtr() { return m_Device; }; // Return the D3DDevice pointer to the caller

    void ShowScreen();                                  // Display the current backbuffer on the screen

    HRESULT GetTransform( D3DTRANSFORMSTATETYPE State,  // Get the D3D Transform
                          D3DMATRIX* pMatrix );         // Set the D3D Transform

    HRESULT SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix );

    HRESULT SetVertexShader( DWORD Handle );            // Set the D3D Vertex Shader
    HRESULT GetVertexShader( DWORD* pHandle );          // Get the D3D Vertex Shader



private:
    // Vertext structure
    struct MYVERTEX
    {
	    D3DXVECTOR3 v;
	    float       fRHW;
	    D3DCOLOR    cDiffuse;
    };

    // Private Properties
    IDirect3DDevice8* m_Device;
    IDirect3DSurface8* m_BackBuffer;
    IDirect3DVertexBuffer8* m_VertexBuffer;
    int m_ScreenWidth; 
    int m_ScreenHeight;
    
    // Font Properties
    XFONT* m_Font;
    float m_FontWidth;
    float m_FontHeight;
    DWORD m_FontColor;
    DWORD m_FontBgColor;

    // Private Methods
};

#endif // _XBOXVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\sndtrk\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#include <xtl.h>

#define APP_TITLE_NAME_A                        "Recovery"

// Screen Dimensions
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2 )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2 )

// Progress Bar Dimensions
#define PROGRESS_WIDTH                           200.0f
#define PROGRESS_HEIGHT                           32.0f
#define PROGRESS_BORDER_OUTER_OFFSET             7.0f
#define PROGRESS_BORDER_GAP                      3.0f
#define PROGRESS_BORDER_WIDTH                    5
#define PROGRESS_X1                               (SCREEN_X_CENTER - (PROGRESS_WIDTH / 2))
#define PROGRESS_X2                               (SCREEN_X_CENTER + (PROGRESS_WIDTH / 2))
#define PROGRESS_Y1                               264.0f
#define PROGRESS_Y2                               (PROGRESS_Y1 + PROGRESS_HEIGHT)

// Launcher Menu Item Information
#define MENU_LAUNCH_MACHINENAME_X1              SCREEN_X_CENTER             // This is not used, it is calculated
#define MENU_LAUNCH_MACHINENAME_Y1              ( SCREEN_HEIGHT - 65.0f )
#define MENU_LAUNCH_NUMXBES_Y1                  MENUBOX_MAINAREA_Y1 - 28.0f
#define MENU_LAUNCH_MACHINENAME_FONTHEIGHT      28
#define MENU_LAUNCH_TOP_BORDER_SIZE             10.0f
#define MENU_LAUNCH_UPARROW_X1                  113     // Bitmaps, use int
#define MENU_LAUNCH_UPARROW_Y1                  106     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_X1                113     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_Y1                380     // Bitmaps, use int

// Menubox constants
#define MENUBOX_MAINAREA_X1                      99.0f
#define MENUBOX_MAINAREA_Y1                     134.0f
#define MENUBOX_MAINAREA_X2                     535.0f
#define MENUBOX_MAINAREA_Y2                     375.0f

#define MENUBOX_SELECTBAR_X1                    MENUBOX_MAINAREA_X1
#define MENUBOX_SELECTBAR_X2                    ( MENUBOX_MAINAREA_X2 + 1 )

#define MENUBOX_TEXT_TOP_BORDER                   16.0f
#define MENUBOX_TEXT_BOTTOM_BORDER                0.0f
#define MENUBOX_TEXT_LSIDE_BORDER                 8.0f
#define MENUBOX_TEXT_RSIDE_BORDER                 8.0f

#define MENUBOX_TEXTAREA_X1                     ( MENUBOX_MAINAREA_X1 + MENUBOX_TEXT_LSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y1                     ( MENUBOX_MAINAREA_Y1 + MENUBOX_TEXT_TOP_BORDER )
#define MENUBOX_TEXTAREA_X2                     ( MENUBOX_MAINAREA_X2 - MENUBOX_TEXT_RSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y2                     ( MENUBOX_MAINAREA_Y2 - MENUBOX_TEXT_BOTTOM_BORDER )

#define MENUBOX_BUILDNUM_Y1                     ( MENUBOX_TEXTAREA_Y2 - 22.0f )

// Behaviour constants
#define KEY_PRESS_INITIAL_DELAY                 400         // milliseconds
#define KEY_PRESS_REPEAT_DELAY                  50
#define EXECUTABLE_DIRECTORY_POLL_INTERVAL      5000        // 5 seconds
#define CLEAR_SCREEN_PAUSE_MS                   250         // milliseconds

// Font info
#define FONT_DEFAULT_HEIGHT                     20
#define FONT_DEFAULT_WIDTH                      8
#define FONT_ALIAS_LEVEL                        4
#define FONT_DEFAULT_STYLE                      XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"

// Screen Item Constants
#define SCREEN_ITEM_TEXT_LENGTH                 40

// Colors
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_LIGHT_YELLOW                      0xFFDFF77F
#define COLOR_YELLOW                            0xFFFFFF00
#define COLOR_LIGHT_GRAY                        0xFFC8C8C8
#define COLOR_DARK_GRAY                         0xFF828282
#define COLOR_LIME_GREEN                        0xFF9BD351
#define COLOR_BRIGHT_GREEN                      0xFF73C034
#define COLOR_MEDIUM_GREEN                      0xFF57932E
#define COLOR_DARK_GREEN2                       0xFF357515
#define COLOR_DARK_GREEN                        0xFF2C531E

#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_TEXT_FG_COLOR            COLOR_LIGHT_YELLOW
#define SCREEN_DEFAULT_TEXT_BG_COLOR            SCREEN_DEFAULT_BACKGROUND_COLOR

// Menu Item constants
#define ITEM_SELECTOR_BORDER_SPACE              2
#define ITEM_VERT_SPACING                       7.0f
#define ITEM_SELECTOR_COLOR                     COLOR_LIME_GREEN
#define ITEM_XBELIST_FONT_HEIGHT                17 // 18

// Keypad and Keyboard location information
#define KEYBOARD_TOPROW_Y1                      225
#define KEYPAD_TOPROW_Y1                        225
#define MENU_DISPSET_BUTTON_Y1                  211

// File path and location constants
#define FILE_DATA_DRIVE                        L"d:"
#define FILE_DATA_DRIVE_A                       "d:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\recmedia"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\recmedia"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\recmedia"

// Display Settings
enum XBoxDisplaySettings
{
    DISPLAY_SETTING_NONE        = 0,
    DISPLAY_SETTING_MONITOR     = 1,
    DISPLAY_SETTING_NTSC_M      = 2,
    DISPLAY_SETTING_NTSC_J,
    DISPLAY_SETTING_PAL_M       = 4,
    DISPLAY_SETTING_PAL_A,              // PAL B, D, G, H, I
    DISPLAY_SETTING_PAL_N,
    DISPLAY_SETTING_PAL_NC,
    DISPLAY_SETTING_NTSC_M_COMP = 10,
    DISPLAY_SETTING_PAL_M_COMP  = 12
};

// Joystick Dead Zone
#define JOYSTICK_DEAD_ZONE                      20000

enum DisplaySettings
{
    ENUM_DISPSET_TEXT_MONITOR = 0,
    ENUM_DISPSET_TEXT_NTSC_SV,
    ENUM_DISPSET_TEXT_NTSC_C,
    ENUM_DISPSET_TEXT_PAL_SV,
    ENUM_DISPSET_TEXT_PAL_C    
};

// Display Settings
static WCHAR* g_wpszDISPLAYSETTINGS[] = {
    L"Monitor",
    L"NTSC (S-Video)",
    L"NTSC (Composite)",
    L"PAL (S-Video)",
    L"PAL (Composite)"
};

// Screen item locations
#define ITEM_MACHINENAME_DATA_X                 ( ( ( MENUBOX_SELECTBAR_X2 - MENUBOX_SELECTBAR_X1 ) / 2.0f ) + MENUBOX_SELECTBAR_X1 - 17.0F )

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\sndtrk\sndtrpch.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntos.h>
#include <stdio.h>
#include <xtl.h>
#include <stdio.h>
#define XDBG_COMPILE_LEVEL XDBG_TRACE
#include <xdbg.h>
#define XFONT_TRUETYPE
#include <xfont.h>



#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
#define CONSTANT_OBJECT_STRING(s)   { sizeof( s ) - sizeof( OCHAR ), sizeof( s ), s }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\sndtrk\imagefile.h ===
#ifndef __ImageFile_H
#define __ImageFile_H

#include "constants.h"

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;

class BitmapFile {
private:
	int ImageSize;
	DWORD *pixels;
	int xpos, ypos;

	// Bitmap File Header
	WORD Type;
	DWORD FileSize;
	WORD Reserved1;
	WORD Reserved2;
	DWORD OffBits;
	
	// Bitmap Info Header
	DWORD InfoSize;
	DWORD Width;
	DWORD Height;
	WORD Planes;
	WORD BitCount;
	DWORD Compression;
	DWORD SizeImage;
	DWORD XPelsPerMeter;
	DWORD YPelsPerMeter;
	DWORD ClrUsed;
	DWORD ClrImportant;

public:
	BitmapFile(void);
	~BitmapFile(void);
	
	void write(char *file, int imageWidth, int imageHeight, DWORD *pixels);
	int imagesize(char *file);
	void read(int xloc, int yloc, char *file);
	bool render(IDirect3DDevice8 *d3dDevice);

    DWORD GetWidth() { return Width; };         // Get the Width of the bitmap file
    DWORD GetHeight() { return Height; };       // Get the Height of the bitmap file
    int   GetXPos() { return xpos; };           // Get the X Position of the bitmap file
    int   GetYPos() { return ypos; };           // Get the Y Position of the bitmap file
    void  SetXPos( int x ) { xpos = x; };       // Set the X Position of the bitmap file
    void  SetYPos( int y ) { ypos = y; };       // Set the Y Position of the bitmap file
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\sndtrk\sndtrstr.h ===
#pragma once

static const PWSTR RStrings[] =
{
    L"Xbox version %hs",
    L"Xbox recovery has failed", L"because of an unexpected error (%d).",
    L"Press any gamepad button to begin recovery.", L"(Warning: Hard disk will be erased.)",
    L"Preparing the hard disk...",
    L"Copying files to the hard disk...",
    L"Please remove the recovery CD and", L"press any gamepad button to reboot.",
};

enum RECOVSTR_INDEX
{
    RS_BUILD_NUMBER_FORMAT = 0,
    RS_FAILURE_LINE1,
    RS_FAILURE_LINE2_FORMAT,
    RS_GAMEPAD_BEGIN_LINE1,
    RS_GAMEPAD_BEGIN_LINE2,
    RS_PREPARING,
    RS_COPYING,
    RS_GAMEPAD_END_LINE1,
    RS_GAMEPAD_END_LINE2,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\sndtrk\main.cpp ===
#include "sndtrpch.h"
#include "sndtrstr.h"
#include "xboxverp.h"
#include "xboxp.h"
#include "xboxvideo.h"
#include "imagefile.h"
#include "dashst.h"



typedef struct {

    PCWSTR Name;
    PCWSTR Songs[MAX_SONGS];
    DWORD  Ids[MAX_SONGS];
    DWORD  Lengths[MAX_SONGS];


} CREATE_STRUCT, *PCREATE_STRUCT;


CREATE_STRUCT g_Soundtracks[] = {

    {L"Racing Tunes", {L"Ham", L"Take Care of the Lonely", L"Lead Head", L"Beauty Queen"}, {0x00000007, 0x00000009, 0x00000008, 0x00000006}, {203000,177000,216000,242000}},
    {L"Fighting Mix", {L"Breath of Giants", L"Journey", L"Wilderness", NULL}, {0x00010003, 0x00010004, 0x00010005},{81000,331000,364000}},
    {NULL},
};





VOID
pCreateDatabase (
    VOID
    )
{

    UINT i;
    UINT u;
    UINT song;
    DWORD val;

    DashBeginUsingSoundtracks ();
    DashGetNewSongId (0); // not creating a 0 id file.
    DashGetNewSongId (0); // Becky was here.
    DashGetNewSongId (0); // and here.

    XDBGWRN ("Soundtracks", "Creating soundtracks");

    for (i = 0; g_Soundtracks[i].Name; i++) {

        DashAddSoundtrack ((PWSTR) g_Soundtracks[i].Name, &val);




        XDBGWRN ("Soundtracks", "Creating songs for soundtrack.");
        for (u = 0; g_Soundtracks[i].Songs[u]; u++) {


            DashGetNewSongId (0);
            DashAddSongToSoundtrack (val, g_Soundtracks[i].Ids[u],  g_Soundtracks[i].Lengths[u], (PWSTR) g_Soundtracks[i].Songs[u]);

        }
    }

    DashEndUsingSoundtracks ();






    return;
}






VOID
DrawMessage(LPCWSTR pcszTextLine1, LPCWSTR pcszTextLine2, int iProgPercent);

CXBoxVideo* g_pVideo;
BitmapFile* g_pBackgroundBitmap;


VOID
DrawMessage(LPCWSTR pcszTextLine1, LPCWSTR pcszTextLine2, int iProgPercent)
{
    ASSERT(g_pVideo && g_pBackgroundBitmap && pcszTextLine1);

    g_pVideo->ClearScreen(COLOR_BLACK);
    g_pBackgroundBitmap->render(g_pVideo->GetD3DDevicePtr());

    g_pVideo->DrawText(SCREEN_X_CENTER,
                       MENUBOX_TEXTAREA_Y1,
                       SCREEN_DEFAULT_TEXT_FG_COLOR,
                       SCREEN_DEFAULT_TEXT_BG_COLOR,
                       pcszTextLine1);

    if (NULL != pcszTextLine2)
    {
        g_pVideo->DrawText(SCREEN_X_CENTER,
                           MENUBOX_TEXTAREA_Y1 + FONT_DEFAULT_HEIGHT + ITEM_VERT_SPACING,
                           SCREEN_DEFAULT_TEXT_FG_COLOR,
                           SCREEN_DEFAULT_TEXT_BG_COLOR,
                           pcszTextLine2);
    }

    if (-1 != iProgPercent)
    {
        //
        // Draw progress bar background
        //

        g_pVideo->DrawBox(PROGRESS_X1 - PROGRESS_BORDER_OUTER_OFFSET,
                          PROGRESS_Y1 - PROGRESS_BORDER_OUTER_OFFSET,
                          PROGRESS_X2 + PROGRESS_BORDER_OUTER_OFFSET,
                          PROGRESS_Y2 + PROGRESS_BORDER_OUTER_OFFSET,
                          COLOR_BRIGHT_GREEN);

        //
        // Draw progress bar bkgnd
        //

        g_pVideo->DrawBox(PROGRESS_X1 - PROGRESS_BORDER_GAP,
                          PROGRESS_Y1 - PROGRESS_BORDER_GAP,
                          PROGRESS_X2 + PROGRESS_BORDER_GAP,
                          PROGRESS_Y2 + PROGRESS_BORDER_GAP,
                          COLOR_BLACK);

        //
        // Draw progress bar
        //

        g_pVideo->DrawBox(PROGRESS_X1,
                          PROGRESS_Y1,
                          PROGRESS_X1 + ((PROGRESS_WIDTH / 100) * min(iProgPercent, 100)),
                          PROGRESS_Y2,
                          SCREEN_DEFAULT_TEXT_FG_COLOR);
    }

    WCHAR szBuildString[64];
    wsprintfW(szBuildString, RStrings[RS_BUILD_NUMBER_FORMAT], VER_PRODUCTVERSION_STR);
    g_pVideo->DrawText(SCREEN_X_CENTER,
                       MENUBOX_BUILDNUM_Y1,
                       SCREEN_DEFAULT_TEXT_FG_COLOR,
                       SCREEN_DEFAULT_TEXT_BG_COLOR,
                       szBuildString);

    g_pVideo->ShowScreen();

}

// Threshold for analog buttons
#define XINPUT_ANALOGBUTTONTHRESHOLD 20

VOID
WaitForAnyButton()
{
    BOOL fButtonPressed = FALSE;
    static DWORD dwPads = 0;
    DWORD dwInsertions, dwRemovals;
    int i;

    while (!fButtonPressed)
    {
        if (XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals))
        {
            dwPads |= dwInsertions;
            dwPads &= ~dwRemovals;
        }

        for (i = 0; i < XGetPortCount(); i++)
        {
            if ((1 << i) & dwPads)
            {
                HANDLE hPad = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0 + i, XDEVICE_NO_SLOT, NULL);

                if (NULL != hPad)
                {
                    XINPUT_STATE State;

                    //
                    // BUGBUG: remove this sleep once XInput works properly!
                    //

                    Sleep(20);

                    if (ERROR_SUCCESS == XInputGetState(hPad, &State))
                    {
                        if ((0 != State.Gamepad.wButtons) ||
                            (State.Gamepad.bAnalogButtons[0] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                            (State.Gamepad.bAnalogButtons[1] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                            (State.Gamepad.bAnalogButtons[2] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                            (State.Gamepad.bAnalogButtons[3] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                            (State.Gamepad.bAnalogButtons[4] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                            (State.Gamepad.bAnalogButtons[5] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                            (State.Gamepad.bAnalogButtons[6] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                            (State.Gamepad.bAnalogButtons[7] > XINPUT_ANALOGBUTTONTHRESHOLD))
                        {
                            fButtonPressed = TRUE;
                        }
                    }

                    XInputClose(hPad);
                }
            }

            if (fButtonPressed)
            {
                break;
            }
        }
    }
}





void __cdecl main()
{
    unsigned int i;
    WCHAR szText[128];
    DWORD dwVideoFlags = 0;
    DWORD length;
    HANDLE h;
    XSOUNDTRACK_DATA data;
    WCHAR buf[MAX_PATH];
    DWORD val;
    HANDLE h2;

    DWORD st1, st2;
    static XDEVICE_PREALLOC_TYPE deviceTypes[] = {
                                    {XDEVICE_TYPE_GAMEPAD, 4},
                                    {XDEVICE_TYPE_MEMORY_UNIT, 2}
                                    };


    //
    // Initialize core peripheral port support
    //
    XInitDevices(2, deviceTypes);



    g_pVideo = new CXBoxVideo;
    g_pBackgroundBitmap = new BitmapFile;

    if ((NULL == g_pVideo) || (NULL == g_pBackgroundBitmap))
    {
        XDBGWRN("RECOVERY", "Couldn't allocate video objects");
        Sleep(INFINITE);
    }

    g_pBackgroundBitmap->read(0, 0, FILE_DATA_IMAGE_DIRECTORY_A "\\backgrnd.bmp");

    g_pVideo->Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );

    g_pVideo->ClearScreen(COLOR_BLACK);
    g_pBackgroundBitmap->render(g_pVideo->GetD3DDevicePtr());
    g_pVideo->ShowScreen();


    DrawMessage(RStrings[RS_GAMEPAD_BEGIN_LINE1], RStrings[RS_GAMEPAD_BEGIN_LINE2], -1);


    DrawMessage (L"Creating DB.", L"", -1);
    DeleteFile ("T:\\Music\\st.db");
    WaitForAnyButton ();
    pCreateDatabase ();
#if 0



    DrawMessage (L"Testing Soundtracks.",L"", -1);
    DashBeginUsingSoundtracks ();
    if (!DashAddSoundtrack (L"Soundtrack 1", &st1)) {
        XDBGWRN ("TEST", "Failed to add st1.");
    }
    if (!DashAddSoundtrack (L"Soundtrack 2", &st2)) {
        XDBGWRN ("TEST", "Failed to add st2.");
    }
    val = DashGetNewSongId ();
    if (!DashAddSongToSoundtrack (st1, val, L"Song 1")) {
        XDBGWRN ("TEST", "Failed to add Song1.");
    }
    val = DashGetNewSongId ();
    if (!DashAddSongToSoundtrack (st1, val, L"Song 2")) {
        XDBGWRN ("TEST", "Faield to add Song2.");
    }
    val = DashGetNewSongId ();
    if (!DashAddSongToSoundtrack (st2, val, L"Song 3")) {
        XDBGWRN ("TEST", "Failed to add Song3.");
    }

    val = DashGetNewSongId ();
    if (!DashAddSongToSoundtrack (st2, val, L"Song 4")) {
        XDBGWRN ("TEST", "Failed to add Song4.");
    }

    val = DashGetNewSongId ();
    if (!DashAddSongToSoundtrack (st2, val, L"Song 5")) {
        XDBGWRN ("TEST", "Failed to add Song5.");
    }

    val = DashGetNewSongId ();
    if (!DashAddSongToSoundtrack (st2, val, L"Song 6")) {
        XDBGWRN ("TEST", "Failed to add Song6.");
    }

    val = DashGetNewSongId ();
    if (!DashAddSongToSoundtrack (st2, val, L"Song 7")) {
        XDBGWRN ("TEST", "Failed to add Song7.");
    }

    val = DashGetNewSongId ();
    if (!DashAddSongToSoundtrack (st2, val, L"Song 8")) {
        XDBGWRN ("TEST", "Failed to add Song8.");
    }

    val = DashGetNewSongId ();
    if (!DashAddSongToSoundtrack (st2, val, L"Song 9")) {
        XDBGWRN ("TEST", "Failed to add Song9.");
    }


    val = DashGetNewSongId ();
    if (!DashAddSongToSoundtrack (st2, val, L"Song 10")) {
        XDBGWRN ("TEST", "Failed to add Song10.");
    }

    val = DashGetNewSongId ();
    if (!DashAddSongToSoundtrack (st2, val, L"Song 11")) {
        XDBGWRN ("TEST", "Failed to add Song11.");
    }

    val = DashGetNewSongId ();
    if (!DashAddSongToSoundtrack (st2, val, L"Song 12")) {
        XDBGWRN ("TEST", "Failed to add Song12.");
    }

    if (!DashSwapSoundtracks (st1, st2)) {
        XDBGWRN ("TEST", "FAiled to swap soundtracks");
    }

    if (!DashEditSoundtrackName (st1, L"Alpha")) {
        XDBGWRN ("TEST", "Failed to edit st1.");
    }

    if (!DashEditSoundtrackName (st2, L"Beta")) {
        XDBGWRN ("TEST", "Failed to edit st2.");
    }

    if (!DashEditSongName (st1, 0, L"Song the first.")) {
        XDBGWRN ("TEST", "Faield to edit song.");
    }

    if (!DashEditSongName (st1, 1, L"Song the second.")) {
        XDBGWRN ("TEST", "Failed to edit song.");
    }

    if (!DashSwapSongs (st1, 0, 1)) {
        XDBGWRN ("TEST", "Failed to swap songs.");
    }

    if (!DashSwapSongs (st2, 0, 8)) {
        XDBGWRN ("TEST", "Failed to swap songs.");
    }

    if (!DashDeleteSongFromSoundtrack (st2, 0)) {
        XDBGWRN ("TEST", "Failed to delete song.");
    }

    if (!DashDeleteSoundtrack (st1)) {
        XDBGWRN ("TEST", "Unable to delete soundtrack.");
    }

#endif




    XDBGWRN ("TEST", "There are %u soundtracks in the datbase.", DashGetSoundtrackCount ());

//    DashEndUsingSoundtracks ();

    WaitForAnyButton ();
    DrawMessage (L"Testing Soundtracks.", L"", -1);
    h = XFindFirstSoundtrack (&data);
    if (h != INVALID_HANDLE_VALUE) {
        do {
            XDBGWRN ("Soundtrack Test", "Found soundtrack %ws with %u songs. Length, %u:%u", data.szName, data.uSongCount, data.uSoundtrackLength / 60000, data.uSoundtrackLength % 60000);

            for (i = 0; i < data.uSongCount; i++) {
                if (!XGetSoundtrackSongInfo (data.uSoundtrackId, i, &val, &length, buf, MAX_PATH)) {
                    XDBGWRN ("Soundtrack Test", "Could not get data for index %i.", i);
                }
                else {
                    XDBGWRN ("Soundtrack Test", "Found song with name %ws val %u, length: %u:%u", buf, val, length / 60000, length % 60000);
                    h2 = XOpenSoundtrackSong (val, FALSE);
                    if (h2 == INVALID_HANDLE_VALUE) {
                        XDBGWRN ("Soundtrack Test", "Unable to open song %u.", val);
                    }
                    else {
                        CloseHandle (h2);
                        XDBGWRN ("Soundtrack Test", "Song %ws successfuly opened.", buf);
                    }
                }
            }


        } while (XFindNextSoundtrack (h, &data));


        XFindClose (h);



    }

    DrawMessage (L"Done.", L"", -1);
    WaitForAnyButton ();
    WaitForAnyButton ();




}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\sndtrk\imagefile.cpp ===
#include "sndtrpch.h"
#include "imagefile.h"

//////////////////////////////////////////////////////////////////////
// .BMP File format functions

BitmapFile::BitmapFile() {
	xpos = 0;
	ypos = 0;

	// Initialize Bitmap File Header
	Type	  = 19778;
	FileSize  = 192056;	//check this
	Reserved1 = 0;
	Reserved2 = 0;
	OffBits	  = 54;	//check this

	// Initialize Bitmap Info Header
	InfoSize	  = 40;
	Width		  = 0;
	Height		  = 0;
	Planes		  = 1;
	BitCount	  = 24;
	Compression	  = 0;
	SizeImage	  = 0;
	XPelsPerMeter = 2834;
	YPelsPerMeter = 2834;
	ClrUsed		  = 0;
	ClrImportant  = 0;
}

BitmapFile::~BitmapFile() {
    if( pixels )
    {
	    delete [] pixels;
        pixels = NULL;
    }
}

void BitmapFile::write(char *file, int imageWidth, int imageHeight, DWORD *pixels) {
	FILE *output;

	Width     = imageWidth;
	Height	  = imageHeight;
	ImageSize = imageWidth * imageHeight;

	//open the new bitmap file
	output = fopen(file, "wb");

	// Write the Bitmap File header information
	fwrite(&Type, sizeof(WORD), 1, output);
	fwrite(&FileSize, sizeof(DWORD), 1, output);
	fwrite(&Reserved1, sizeof(WORD), 1, output);
	fwrite(&Reserved2, sizeof(WORD), 1, output);
	fwrite(&OffBits, sizeof(DWORD), 1, output);

	//Write the Bitmap Info header information
	fwrite(&InfoSize, sizeof(DWORD), 1, output);
	fwrite(&Width, sizeof(DWORD), 1, output);
	fwrite(&Height, sizeof(DWORD), 1, output);
	fwrite(&Planes, sizeof(WORD), 1, output);
	fwrite(&BitCount, sizeof(WORD), 1, output);
	fwrite(&Compression, sizeof(DWORD), 1, output);
	fwrite(&SizeImage, sizeof(DWORD), 1, output);
	fwrite(&XPelsPerMeter, sizeof(DWORD), 1, output);
	fwrite(&YPelsPerMeter, sizeof(DWORD), 1, output);
	fwrite(&ClrUsed, sizeof(DWORD), 1, output);
	fwrite(&ClrImportant, sizeof(DWORD), 1, output);

	fclose(output);
}

int BitmapFile::imagesize(char *file) {
	FILE *input;
	input = fopen(file, "rb");

	// Read the Bitmap File header information
	fread(&Type, sizeof(WORD), 1, input);
	fread(&FileSize, sizeof(DWORD), 1, input);
	fread(&Reserved1, sizeof(WORD), 1, input);
	fread(&Reserved2, sizeof(WORD), 1, input);
	fread(&OffBits, sizeof(DWORD), 1, input);

	//Read the Bitmap Info header information
	fread(&InfoSize, sizeof(DWORD), 1, input);
	fread(&Width, sizeof(DWORD), 1, input);
	fread(&Height, sizeof(DWORD), 1, input);

	fclose(input);

	return (Width * Height);
}

void BitmapFile::read(int xloc, int yloc, char *file) {
	FILE *input;
	xpos = xloc;
	ypos = yloc;

	//open the new bitmap file
	input = fopen(file, "rb");
    if( !input )
    {
        XDBGWRN( APP_TITLE_NAME_A, "BitmapFile::read():fopen failed!! - '%s'\n", file );
        return;
    }

	// Read the Bitmap File header information
	fread(&Type, sizeof(WORD), 1, input);
	fread(&FileSize, sizeof(DWORD), 1, input);
	fread(&Reserved1, sizeof(WORD), 1, input);
	fread(&Reserved2, sizeof(WORD), 1, input);
	fread(&OffBits, sizeof(DWORD), 1, input);

	//Read the Bitmap Info header information
	fread(&InfoSize, sizeof(DWORD), 1, input);
	fread(&Width, sizeof(DWORD), 1, input);
	fread(&Height, sizeof(DWORD), 1, input);
	fread(&Planes, sizeof(WORD), 1, input);
	fread(&BitCount, sizeof(WORD), 1, input);
	fread(&Compression, sizeof(DWORD), 1, input);
	fread(&SizeImage, sizeof(DWORD), 1, input);
	fread(&XPelsPerMeter, sizeof(DWORD), 1, input);
	fread(&YPelsPerMeter, sizeof(DWORD), 1, input);
	fread(&ClrUsed, sizeof(DWORD), 1, input);
	fread(&ClrImportant, sizeof(DWORD), 1, input);

	ImageSize = Width * Height;
	pixels = new DWORD[ImageSize];

	float remainer = (float)Width / 4;
	float delta = remainer - (int)remainer;

	BYTE blue, green, red;
	for(int y = (int)Height - 1; y >= 0 ; y--)
	{
		for(int x = 0; x < (int)Width; x++)
		{
			fread(&blue, sizeof(BYTE), 1, input);
			fread(&green, sizeof(BYTE), 1, input);
			fread(&red, sizeof(BYTE), 1, input);
			int position = (y * (int)Width) + x;
			pixels[position] = (0xff << 24) | (red << 16) | (green << 8) | (blue);
		}
		
		//account for the extra bytes in bitmap files
		if(delta == 0.25f) fseek(input, 1, SEEK_CUR);
		else if(delta == 0.50f) fseek(input, 2, SEEK_CUR);
		else if(delta == 0.75f) fseek(input, 3, SEEK_CUR);
	}

	fclose(input);
}

bool BitmapFile::render(IDirect3DDevice8 *d3dDevice) {
	HRESULT hr;
	IDirect3DSurface8 *backBuffer;
	D3DLOCKED_RECT backBufferInfo;
	hr = d3dDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &backBuffer);
	if( FAILED( hr ))
	{
		XDBGWRN( APP_TITLE_NAME_A, "BitmapFile::render():Failed to get the backbuffer\n" );
		return false;
	}

	RECT container;
	container.top = ypos;
	container.left = xpos;
	container.bottom = ypos + Height;
	container.right = xpos + Width;	

	hr = backBuffer->LockRect(&backBufferInfo, &container, 0);
	if( FAILED( hr ))
	{
		XDBGWRN( APP_TITLE_NAME_A, "BitmapFile::render():Failed to lock the backbuffer\n" );
        backBuffer->Release();
		return false;
	}

	int destPitch = backBufferInfo.Pitch;
	int sourcePitch = Width * 4;
	BYTE *s = (BYTE*)pixels;
	BYTE *p = (BYTE*)backBufferInfo.pBits;
	for(int y = 0; y < (int)Height; y++)
	{
		memcpy(p, s, sourcePitch);
		s += sourcePitch;
		p += destPitch;
	}

	backBuffer->UnlockRect();
    backBuffer->Release();
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\sndtrk\xboxvideo.cpp ===
/*****************************************************
*** xboxvideo.cpp
***
*** CPP file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
***
*** by James N. Helm
*** November 1st, 2000
***
*****************************************************/

#include "sndtrpch.h"
#include "xboxvideo.h"

// Constructor
CXBoxVideo::CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::CXBoxVideo()" );

    m_Device = NULL;
    m_BackBuffer = NULL;
    m_VertexBuffer = NULL;

    // Font properties
    m_Font = NULL;
    m_FontWidth = FONT_DEFAULT_WIDTH;
    m_FontHeight = FONT_DEFAULT_HEIGHT;
    m_FontColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
    m_FontBgColor = SCREEN_DEFAULT_TEXT_BG_COLOR;

    m_ScreenWidth = SCREEN_WIDTH;       // Default the screen width to 640
    m_ScreenHeight = SCREEN_HEIGHT;     // Default the screen height to 480
}

// Destructor
CXBoxVideo::~CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::~CXBoxVideo()" );

    if( m_Device )
    {
        m_Device->Release();
        m_Device = NULL;
    }

    if( m_BackBuffer )
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_VertexBuffer )
    {
        m_VertexBuffer->Release();
        m_VertexBuffer = NULL;
    }
}

// Clear the screen
void CXBoxVideo::ClearScreen( DWORD color )
{
    if( FAILED( m_Device->Clear( 0, NULL, D3DCLEAR_TARGET, color, 1.0f, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXboxVideo::ClearScreen():Failed to clear the screen!!" );
    }
}


// Draw the inputed bit array to the screen
//
// Parameters:
//      fx - the upper left x coordinate on screen
//      fy - the upper left y coordinate on screen
//      ulWidth - the width of the bitmap
//      ulHeight - the height of the bitmap
//      pData - a pointer to the array of pixel values
void CXBoxVideo::DrawBitBlt( float fx, float fy, ULONG ulWidth, ULONG ulHeight, const DWORD* pData )
{
    // Check to make sure we received a valid pointer
    if( !pData )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawBitBlt():pData not a valid pointer!" );

        return;
    }

    // Draw the bitmap on the screen, pixel by pixel
	for ( ULONG y = 0; y < ulHeight; y++ )
	{
		for ( ULONG x = 0; x < ulWidth; x++ )
		{
			if ( 0 != pData[y * ulWidth + x] )
			{
				DrawLine( fx + x, fy + y, fx + x, fy + y, 1.0f, pData[y * ulWidth + x] );
			}
		}
	}
}

// Draw a box on the screen
void CXBoxVideo::DrawBox( float x1, float y1, float x2, float y2, DWORD color )
{
	MYVERTEX* pb;
	float maxx, minx;
	float maxy, miny;

	CHECK( m_Device->BeginScene() );
	CHECK( m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * 4, (BYTE**)&pb, 0 ) );
	
	if( IsBadWritePtr( pb, 128 ) )
	{
		XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawBox(): Lockreturned '%p', which is BAD!", pb );

		return;
	}

	if( x1 < x2 )
    {
		minx = x1;
		maxx = x2;
	}
    else
    {
		minx = x2;
		maxx = x1;
	}

	if( y1 < y2 )
    {
		miny = y1;
		maxy = y2;
	}
    else
    {
		miny = y2;
		maxy = y1;
	}

	if( x1 == x2 )
    {
		maxx++;
	}

	pb[0].v.x = minx; pb[0].v.y = miny; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
	pb[1].v.x = maxx; pb[1].v.y = miny; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
	pb[2].v.x = maxx; pb[2].v.y = maxy; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
	pb[3].v.x = minx; pb[3].v.y = maxy; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = color;

	m_VertexBuffer->Unlock();

	m_Device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
	m_Device->EndScene();
}


// Draw a clear rectangle to the screen
void CXBoxVideo::DrawClearRect( float x1, float y1, float x2, float y2, DWORD color )
{
	D3DRECT rect;

	if ( m_Device )
	{
		if( x1 < x2 )
        {
			rect.x1 = (long)x1;
			rect.x2 = (long)x2 + 1;
		}
        else
        {
			rect.x1 = (long)x2;
			rect.x2 = (long)x1 + 1;
		}

		if( y1 < y2 )
        {
			rect.y1 = (long)y1;
			rect.y2 = (long)y2 + 1;
		}
        else
        {
			rect.y1 = (long)y2;
			rect.y2 = (long)y1 + 1;
		}

		m_Device->Clear( 1, &rect, D3DCLEAR_TARGET, color, 0, 0 );
	}
}

// Draw a line to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      color          --- the RGBA color to draw the box with
HRESULT CXBoxVideo::DrawLine( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    HRESULT hr = S_OK;     // Return code for D3D functions that are called, and for the function
	MYVERTEX* pb;   // Vertex information

    // Set the line width
    if( FAILED( hr = m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Failed: m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth )! - '%d'", hr );
    }

    // Before any rendering can be done, this must be called
	if( FAILED( hr = m_Device->BeginScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->BeginScene()! - '%d'", hr );
    }

    // Locks a range of vertex data and obtains a pointer to the vertex buffer memory.
	if( FAILED( hr = m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * NUM_VB_VERTS, (BYTE**)&pb, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Lock()! - '%d'", hr );
    }

    pb[0].v.x = x1;  pb[0].v.y = y1; pb[0].v.z = .1f;  pb[0].fRHW = .9f;  pb[0].cDiffuse = color;
	pb[1].v.x = x2;  pb[1].v.y = y2; pb[1].v.z = .1f;  pb[1].fRHW = .9f;  pb[1].cDiffuse = color;

    // Unlock the vertext data
	if( FAILED( hr = m_VertexBuffer->Unlock() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Unlock()! - '%d'", hr );

        return hr;
    }

    // Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams
    if( FAILED( hr = m_Device->DrawPrimitive( D3DPT_LINELIST, 0, 1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->DrawPrimitive()! - '%d'", hr );
    }

    // Once rendering is complete, this must be called
    // We should try this, even on a failure, in case BeginScene() was successful
    // We'll report it to the debugger, but will not return the fail/success code to the
    // caller
	if( FAILED( m_Device->EndScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->EndScene()! - '%d'", hr );
    }

    return hr;
}

// Draw an outline to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      borderSize     --- width in pixels of the border
//      color          --- the RGBA color to draw the box with
void CXBoxVideo::DrawOutline( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    // Draw the box on the screen
    DrawLine( x1, y1, x1, y2, fLineWidth, color );     // Left Line
    DrawLine( x1, y2, x2, y2, fLineWidth, color );     // Bottom Line
    DrawLine( x2, y2, x2, y1, fLineWidth, color );     // Right Line
    DrawLine( x2, y1, x1, y1, fLineWidth, color );     // Top Line
}


// DeInitialize our Screen by freeing our objects
void CXBoxVideo::DeInitialize( void )
{
    if( m_BackBuffer)
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_Device )
    {
	    m_Device->Release();
        m_Device = NULL;
    }
}

// Prints formatted text using the default font to the screen
// Set colors to 0 to use default color
int CXBoxVideo::DrawText( float x1, float y1, DWORD fgcolor, DWORD bgcolor, const TCHAR* format, ... )
{
    if( !m_Font )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():The font is not set!!" );
        return -1;
    }

	int i;                  // Return Value
	HRESULT hr;             // Return Value for XFONT
	va_list v;              // Argument List
	TCHAR wstr[256];        // Honkin Buffer
    DWORD currentFGColor;   // Current FG Color
    DWORD currentBGColor;   // Current FG Color

    // Set our FONT colors if the user wishes to
    if( fgcolor || bgcolor )
    {
        // Set the foreground color if the user wants to
        if( fgcolor )
        {
            XFONT_SetTextColor( fgcolor );
        }

        // Set the background color if the user wants to
        if( bgcolor )
        {
            XFONT_SetBkColor( bgcolor );
        }
    }

	va_start( v, format );
	i = wvsprintf( wstr, format, v );

    // Print the Text to the backbuffer
    hr = XFONT_TextOut( wstr, i, (long)x1, (long)y1 );

    // If we have a valid font object, check the HRESULT
    if( FAILED( hr ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():XFONT_TextOut failed!!  HRESULT: %x", hr );
    }

	va_end( v );
	
    return i;
}

// Get the size of the current font
void CXBoxVideo::GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():The font is not set!!" );

        return;
    }

    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():Invalid arguments passed!!" );

        return;
    }

    XFONT_GetFontMetrics( pheight, pdecent );
}

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int CXBoxVideo::GetStringPixelWidth( IN LPCWSTR string, IN int length /*=-1*/ )
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):The font is not set!!" );

        return -1;
    }

    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!" );

        return -1;
    }

	unsigned int outlen = 0;        // Return value

	XFONT_GetTextExtent( string, length, &outlen );
	
    return outlen;
}

// Get the width of the char*
int CXBoxVideo::GetStringPixelWidth( IN char* string, IN int length /*=-1*/ )
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( char* ):Invalid pointer passed in!" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}

// Get a D3D Transform
HRESULT CXBoxVideo::GetTransform( D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix )
{
    return m_Device->GetTransform( State, pMatrix );
}

// Get the D3D Vertex Shader
HRESULT CXBoxVideo::GetVertexShader( DWORD* pHandle )
{
    return m_Device->GetVertexShader( pHandle );
}

// Lighten the image specified by "pBits"
void CXBoxVideo::LightenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwAddto )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwAddto];
		pshufw mm0, mm0, 01000100b
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		paddusb mm1, mm0 ;//add, saturating to 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop
	}
}

// Darken the image specified by "pBits"
void CXBoxVideo::DarkenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwSubtract )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwSubtract];
		pshufw mm0, mm0, 01000100b ;;//propegate "subtract" into both dwords of mm0
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		psubusb mm1, mm0 ;//subtract, saturating to 0 or 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop
	}
}

// Initialize D3D for this screen
void CXBoxVideo::Initialize( int width = SCREEN_WIDTH, int height = SCREEN_HEIGHT )
{
    IDirect3D8* pD3D = NULL;
    m_ScreenWidth = width;
    m_ScreenHeight = height;

	if ( m_Device == NULL )
	{
        // Create D3D 8.
		if( FAILED( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize(): Failed to create pD3D!" );
			return;
        }

        // Set the screen mode.
		D3DPRESENT_PARAMETERS d3dpp;
		ZeroMemory( &d3dpp, sizeof( d3dpp ) );

		d3dpp.BackBufferWidth                 = width;
		d3dpp.BackBufferHeight                = height;
		d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
		d3dpp.BackBufferCount                 = 1;

        d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
		d3dpp.Windowed                        = FALSE;                   // Must be false for Xbox
		d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
        d3dpp.EnableAutoDepthStencil          = FALSE; // TRUE;
        d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;

		// Create the m_Device.
		if ( FAILED ( pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                          D3DDEVTYPE_HAL,
                                          NULL,      // Ignored on Xbox
                                          D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                          &d3dpp,
                                          &m_Device ) ) )
		{
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to CreateDevice!" );
			pD3D->Release();

			return;
		}

		// Now we no longer need the D3D interface so let's free it.
		pD3D->Release();
	}

    if( FAILED( m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) Failed!!" );
    }

    // Create our vertex buffer
	if( FAILED( m_Device->CreateVertexBuffer( sizeof( MYVERTEX ) * NUM_VB_VERTS, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to create the Vertex Buffer!!" );
    }

    // Set the stream source
	m_Device->SetStreamSource( 0, m_VertexBuffer, sizeof( MYVERTEX ) );

    // Set our initial vertex shader that is compatible with our 2D scene
	if( FAILED( m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) Failed!!" );
    }

    // Setup matricies
    // Setup our identity matrix
    D3DMATRIX mat;
    mat._11 = mat._22 = mat._33 = mat._44 = 1.0f;
    mat._12 = mat._13 = mat._14 = mat._41 = 0.0f;
    mat._21 = mat._23 = mat._24 = mat._42 = 0.0f;
    mat._31 = mat._32 = mat._34 = mat._43 = 0.0f;

    // World Matrix
    // The world matrix controls the position and orientation
    // of the polygons in world space. We'll use it later to
    // spin the triangle.
    D3DMATRIX WorldMatrix = mat;

    // Set the transforms for our 3D world
    if( FAILED( m_Device->SetTransform( D3DTS_WORLD, &WorldMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the World Matrix!!" );
    }

    // View Matrix
    // The view matrix defines the position and orientation of
    // the camera. Here, we are just moving it back along the z-
    // axis by 10 units.
    D3DMATRIX ViewMatrix = mat;
    ViewMatrix._43 = 10.0f;

    if( FAILED( m_Device->SetTransform( D3DTS_VIEW, &ViewMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the View Matrix!!" );
    }

    // Projection Matrix
    // The projection matrix defines how the 3-D scene is "projected"
    // onto the 2-D render target surface.

    // Set up a very simple projection that scales x and y
    // by 2, and translates z by -1.0.
    D3DXMATRIX ProjectionMatrix; //  = mat;
    D3DXMatrixPerspectiveFovLH( &ProjectionMatrix, 1.57f, 640.0f/480.0f, 0.001f, 30.0f );

    if( FAILED( m_Device->SetTransform( D3DTS_PROJECTION, &ProjectionMatrix ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the Projection Matrix!!" );
    }

    // Viewport
    D3DVIEWPORT8 D3DViewport;    // Direct3D Viewport

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = width;  // rect.right - rect.left;
    D3DViewport.Height = height; // rect.bottom - rect.top;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( m_Device->SetViewport( &D3DViewport ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set the viewport!!" );
    }

    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &m_Font );

	if( m_Font )
    {
	    if( FAILED( m_Device->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &m_BackBuffer ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->GetBackBuffer() Failed!!" );
        }

        XFONT_SelectFont( m_Font );
        XFONT_SetDrawingSurface( m_BackBuffer );
        XFONT_SetTextColor( SCREEN_DEFAULT_TEXT_FG_COLOR );
        XFONT_SetTextAlignment( XFONT_CENTER );
        XFONT_SetBkColor( SCREEN_DEFAULT_TEXT_BG_COLOR );
        XFONT_SetTextHeight( FONT_DEFAULT_HEIGHT );
        XFONT_SetTextAntialiasLevel( FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( FONT_DEFAULT_STYLE );
    }
}


// Set a D3D Transform
HRESULT CXBoxVideo::SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix )
{
    return m_Device->SetTransform( State, pMatrix );
};

// Display the current backbuffer on to the screen
void CXBoxVideo::ShowScreen()
{
	if( m_Device )
    {
		m_Device->Present( NULL, NULL, NULL, NULL );
	}
}


// Set the D3D Vertex Shader
HRESULT CXBoxVideo::SetVertexShader( DWORD Handle )
{
    return m_Device->SetVertexShader( Handle );
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\images\imagepch.h ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    imagepch.h

Abstract:

    precompiled header for usb manager library.

--*/

#ifndef _IMAGEPCH_H_
#define _IMAGEPCH_H_

#define IMAGES_APP_TITLE_NAME_A     "IMGS"

#include <xtl.h>
#include <stdio.h>
#include <xdbg.h>

#endif // _IMAGEPCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\images\bitmapfile.cpp ===
#include "imagepch.h"
#include "bitmapfile.h"

//////////////////////////////////////////////////////////////////////
// .BMP File format functions

BitmapFile::BitmapFile() 
:
m_dwImageSize( 0 ),
m_pdwPixels( NULL ),
m_iXpos( 0 ),
m_iYpos( 0 ),
//
// Initalize Bitmap File Header
m_wType( 19778 ),
m_dwFileSize( 192056 ), //check this
m_wReserved1( 0 ),
m_wReserved2( 0 ),
m_dwOffBits( 54 ), //check this
//
// Initialize Bitmap Info Header
m_dwInfoSize( 40 ),
m_dwWidth( 0 ),
m_dwHeight( 0 ),
m_wPlanes( 1 ),
m_wBitCount( 24 ),
m_dwCompression( 0 ),
m_dwSizeImage( 0 ),
m_dwXPelsPerMeter( 2834 ),
m_dwYPelsPerMeter( 2834 ),
m_dwClrUsed( 0 ),
m_dwClrImportant( 0 )
{
}

BitmapFile::~BitmapFile()
{
    // Clean up memory, etc
    CleanUp();
}


// Destory any allocated memory, etc
void BitmapFile::CleanUp()
{
    if( m_pdwPixels )
    {
        delete [] m_pdwPixels;
        m_pdwPixels = NULL;
    }
}


void BitmapFile::write( char* pszFile, int iImageWidth, int iImageHeight, DWORD* pdwPixels )
{
    FILE* pfOutput;

    m_dwWidth     = iImageWidth;
    m_dwHeight    = iImageHeight;
    m_dwImageSize = iImageWidth * iImageHeight;

    //open the new bitmap file
    pfOutput = fopen( pszFile, "wb" );
    if( !pfOutput )
    {
        XDBGWRN( IMAGES_APP_TITLE_NAME_A, " BitmapFile::write():Failed to open the file!!" );

        return;
    }

    // Write the Bitmap File header information
    fwrite( &m_wType, sizeof( WORD ), 1, pfOutput );
    fwrite( &m_dwFileSize, sizeof( DWORD ), 1, pfOutput );
    fwrite( &m_wReserved1, sizeof( WORD ), 1, pfOutput );
    fwrite( &m_wReserved2, sizeof( WORD ), 1, pfOutput );
    fwrite( &m_dwOffBits, sizeof( DWORD ), 1, pfOutput );

    // Write the Bitmap Info header information
    fwrite( &m_dwInfoSize, sizeof( DWORD ), 1, pfOutput );
    fwrite( &m_dwWidth, sizeof( DWORD ), 1, pfOutput );
    fwrite( &m_dwHeight, sizeof( DWORD ), 1, pfOutput );
    fwrite( &m_wPlanes, sizeof( WORD ), 1, pfOutput );
    fwrite( &m_wBitCount, sizeof( WORD ), 1, pfOutput );
    fwrite( &m_dwCompression, sizeof( DWORD ), 1, pfOutput );
    fwrite( &m_dwSizeImage, sizeof( DWORD ), 1, pfOutput );
    fwrite( &m_dwXPelsPerMeter, sizeof( DWORD ), 1, pfOutput );
    fwrite( &m_dwYPelsPerMeter, sizeof( DWORD ), 1, pfOutput );
    fwrite( &m_dwClrUsed, sizeof( DWORD ), 1, pfOutput );
    fwrite( &m_dwClrImportant, sizeof( DWORD ), 1, pfOutput );

    fclose( pfOutput );
}

int BitmapFile::imagesize( char* pszFile )
{
    FILE* pfInput;
    pfInput = fopen( pszFile, "rb" );
    if( !pfInput )
    {
        XDBGWRN( IMAGES_APP_TITLE_NAME_A, " BitmapFile::imagesize():Failed to open the file!!" );

        return -1;
    }

    // Read the Bitmap File header information
    fread( &m_wType, sizeof( WORD ), 1, pfInput );
    fread( &m_dwFileSize, sizeof( DWORD ), 1, pfInput );
    fread( &m_wReserved1, sizeof( WORD ), 1, pfInput );
    fread( &m_wReserved2, sizeof( WORD ), 1, pfInput );
    fread( &m_dwOffBits, sizeof( DWORD ), 1, pfInput );

    //Read the Bitmap Info header information
    fread( &m_dwInfoSize, sizeof( DWORD ), 1, pfInput );
    fread( &m_dwWidth, sizeof( DWORD ), 1, pfInput );
    fread( &m_dwHeight, sizeof( DWORD ), 1, pfInput );

    fclose( pfInput );

    return ( m_dwWidth * m_dwHeight );
}


// Read the BMP and the alpha mask for the BMP
void BitmapFile::readWithAlpha( int iXloc, int iYloc, char* pszFile, char* pszAlphaFile )
{
    read( iXloc, iYloc, pszFile );
    readAlpha( pszAlphaFile );
}


// Read the alpha mask for the BMP
void BitmapFile::readAlpha( char* pszFile )
{
    if( NULL == pszFile )
    {
        XDBGWRN( IMAGES_APP_TITLE_NAME_A, " BitmapFile::readAlpha():Invalid argument(s) passed in!!" );

        return;
    }

    //open the new bitmap file
    FILE* pfInput = fopen( pszFile, "rb" );
    if( NULL == pfInput )
    {
        XDBGWRN( IMAGES_APP_TITLE_NAME_A, " BitmapFile::readAlpha():fopen failed!! - '%hs'", pszFile );

        return;
    }

    WORD wType, wReserved1, wReserved2, wPlanes, wBitCount;
    DWORD dwFileSize, dwOffBits, dwInfoSize, dwWidth, dwHeight, dwCompression, dwSizeImage, dwXPelsPerMeter;
    DWORD dwYPelsPerMeter, dwClrUsed, dwClrImportant;


    // Read the Bitmap File header information
    fread( &wType, sizeof( WORD ), 1, pfInput );
    fread( &dwFileSize, sizeof( DWORD ), 1, pfInput );
    fread( &wReserved1, sizeof( WORD ), 1, pfInput );
    fread( &wReserved2, sizeof( WORD ), 1, pfInput );
    fread( &dwOffBits, sizeof( DWORD ), 1, pfInput );

    //Read the Bitmap Info header information
    fread( &dwInfoSize, sizeof( DWORD ), 1, pfInput );
    fread( &dwWidth, sizeof( DWORD ), 1, pfInput );
    fread( &dwHeight, sizeof( DWORD ), 1, pfInput );
    fread( &wPlanes, sizeof( WORD ), 1, pfInput );
    fread( &wBitCount, sizeof( WORD ), 1, pfInput );
    fread( &dwCompression, sizeof( DWORD ), 1, pfInput );
    fread( &dwSizeImage, sizeof( DWORD ), 1, pfInput );
    fread( &dwXPelsPerMeter, sizeof( DWORD ), 1, pfInput );
    fread( &dwYPelsPerMeter, sizeof( DWORD ), 1, pfInput );
    fread( &dwClrUsed, sizeof( DWORD ), 1, pfInput );
    fread( &dwClrImportant, sizeof( DWORD ), 1, pfInput );

    if( m_dwImageSize != ( m_dwWidth * m_dwHeight ) )
    {
        XDBGWRN( IMAGES_APP_TITLE_NAME_A, " BitmapFile::readAlpha():Alpha BMP and Original BMP not the same size!!" );

        return;
    }

    float fRemainer = (float)dwWidth / 4;
    float fDelta = fRemainer - (int)fRemainer;

    BYTE bBlue, bGreen, bRed;
    for( int y = (int)dwHeight - 1; y >= 0 ; y-- )
    {
        for( int x = 0; x < (int)dwWidth; x++ )
        {
            fread( &bBlue, sizeof( BYTE ), 1, pfInput );
            fread( &bGreen, sizeof( BYTE ), 1, pfInput );
            fread( &bRed, sizeof( BYTE ), 1, pfInput );
            int iPosition = ( y * (int)dwWidth ) + x;
            m_pdwPixels[iPosition] = ( m_pdwPixels[iPosition] & 0x00FFFFFF ) | ( bBlue << 24 );
        }

        //account for the extra bytes in bitmap files
        if( fDelta == 0.25f )
        {
            fseek( pfInput, 1, SEEK_CUR );
        }
        else if( fDelta == 0.50f )
        {
            fseek( pfInput, 2, SEEK_CUR );
        }
        else if( fDelta == 0.75f )
        {
            fseek( pfInput, 3, SEEK_CUR );
        }
    }

    fclose( pfInput );
}


void BitmapFile::read( int iXloc, int iYloc, char* pszFile )
{
    FILE* pfInput;
    m_iXpos = iXloc;
    m_iYpos = iYloc;

    // Clean up any memory if necessary
    CleanUp();

    //open the new bitmap file
    pfInput = fopen( pszFile, "rb" );

    if( !pfInput )
    {
        XDBGWRN( IMAGES_APP_TITLE_NAME_A, " BitmapFile::read():fopen failed!!" );

        return;
    }

    // Read the Bitmap File header information
    fread( &m_wType, sizeof( WORD ), 1, pfInput );
    fread( &m_dwFileSize, sizeof( DWORD ), 1, pfInput );
    fread( &m_wReserved1, sizeof( WORD ), 1, pfInput );
    fread( &m_wReserved2, sizeof( WORD ), 1, pfInput );
    fread( &m_dwOffBits, sizeof( DWORD ), 1, pfInput );

    //Read the Bitmap Info header information
    fread( &m_dwInfoSize, sizeof( DWORD ), 1, pfInput );
    fread( &m_dwWidth, sizeof( DWORD ), 1, pfInput );
    fread( &m_dwHeight, sizeof( DWORD ), 1, pfInput );
    fread( &m_wPlanes, sizeof( WORD ), 1, pfInput );
    fread( &m_wBitCount, sizeof( WORD ), 1, pfInput );
    fread( &m_dwCompression, sizeof( DWORD ), 1, pfInput );
    fread( &m_dwSizeImage, sizeof( DWORD ), 1, pfInput );
    fread( &m_dwXPelsPerMeter, sizeof( DWORD ), 1, pfInput );
    fread( &m_dwYPelsPerMeter, sizeof( DWORD ), 1, pfInput );
    fread( &m_dwClrUsed, sizeof( DWORD ), 1, pfInput );
    fread( &m_dwClrImportant, sizeof( DWORD ), 1, pfInput );

    m_dwImageSize = m_dwWidth * m_dwHeight;

    m_pdwPixels = new DWORD[m_dwImageSize];

    float fRemainer = (float)m_dwWidth / 4;
    float fDelta = fRemainer - (int)fRemainer;

    BYTE bBlue, bGreen, bRed;
    for( int y = (int)m_dwHeight - 1; y >= 0 ; y-- )
    {
        for( int x = 0; x < (int)m_dwWidth; x++ )
        {
            fread( &bBlue, sizeof( BYTE ), 1, pfInput );
            fread( &bGreen, sizeof( BYTE ), 1, pfInput );
            fread( &bRed, sizeof( BYTE ), 1, pfInput );
            int iPosition = ( y * (int)m_dwWidth ) + x;
            m_pdwPixels[iPosition] = ( 0xff << 24 ) | ( bRed << 16 ) | ( bGreen << 8 ) | ( bBlue );
        }

        //account for the extra bytes in bitmap files
        if( fDelta == 0.25f )
        {
            fseek( pfInput, 1, SEEK_CUR );
        }
        else if( fDelta == 0.50f )
        {
            fseek( pfInput, 2, SEEK_CUR );
        }
        else if( fDelta == 0.75f )
        {
            fseek( pfInput, 3, SEEK_CUR );
        }
    }

    fclose( pfInput );
}


// Render the image to the back buffer
BOOL BitmapFile::render( IDirect3DDevice8* pD3DDevice, IDirect3DSurface8* pD3DSurface/*=NULL*/ )
{
    HRESULT hr;
    BOOL fRelease = FALSE;
    D3DLOCKED_RECT surfaceInfo;
    RECT container;

    if( !pD3DSurface )
    {
        // Get the back buffer
        hr = pD3DDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &pD3DSurface );
        fRelease = TRUE;
    }

    container.top    = m_iYpos;
    container.left   = m_iXpos;
    container.bottom = m_iYpos + m_dwHeight;
    container.right  = m_iXpos + m_dwWidth;

    // Lock our surface so we can write to it
    hr = pD3DSurface->LockRect( &surfaceInfo, &container, 0 );

    int iDestPitch = surfaceInfo.Pitch;
    int iSourcePitch = m_dwWidth * 4;
    // BYTE* pbS = (BYTE*)m_pdwPixels;
    // BYTE* pbP = (BYTE*)surfaceInfo.pBits;
    DWORD* pdwS = m_pdwPixels;
    DWORD* pdwP = (DWORD*)surfaceInfo.pBits;
    for( int y = 0; y < (int)m_dwHeight; y++ )
    {
        for( int x = 0; x < (int)m_dwWidth; x++ )
        {
            switch (pdwS[x] & 0xff000000) 
			{
            case 0xff000000:
                pdwP[x] = pdwS[x]; //  | 0xFF000000;
                break;
            case 0:
                break;
            default: 
				{
					DWORD dwDst = pdwP[x];
					float fAlpha = (float)(pdwS[x] >> 24) / 255.0f;
					float fRed = (float)((pdwS[x] & 0xff0000) >> 16) * fAlpha + (float)((dwDst & 0xff0000) >> 16) * (1.0f - fAlpha);
					float fGreen = (float)((pdwS[x] & 0xff00) >> 8) * fAlpha + (float)((dwDst & 0xff00) >> 8) * (1.0f - fAlpha);
					float fBlue = (float)(pdwS[x] & 0xff) * fAlpha + (float)(dwDst & 0xff) * (1.0f - fAlpha);
					pdwP[x] = (0xff << 24) | ((BYTE)fRed << 16) | ((BYTE)fGreen << 8) | (BYTE)fBlue;
					break;
				}
            }

			// pdwP[x] = pdwS[x];
        }
        
        pdwS += iSourcePitch >> 2;
        pdwP += iDestPitch >> 2;
    }

    // Unlock our surface
    pD3DSurface->UnlockRect();

    // Release our Surface
    if( fRelease )
    {
        pD3DSurface->Release();
        pD3DSurface = NULL;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\inc\bitmapfile.h ===
#ifndef _BITMAPFILE_H_
#define _BITMAPFILE_H_

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;

class BitmapFile 
{
public:
    // Constructors and Destructor
	BitmapFile(void);
	~BitmapFile(void);
	
    // Public Methods
	void write( char* pszFile,
                int iImageWidth,
                int iImageHeight,
                DWORD* pdwPixels );
	
    int imagesize( char* pszFile );
    void readWithAlpha( int iXloc,                          // Read the BMP and the alpha mask for the BMP
                        int iYloc,
                        char* pszFile,
                        char* pszAlphaFile );
	void read( int iXloc,
               int iYloc,
               char* pszFile );
	BOOL render( IDirect3DDevice8* pD3DDevice,              // Render to a specified surface, or default to the back buffer
                 IDirect3DSurface8* pD3DSurface = NULL );

    DWORD GetWidth() { return m_dwWidth; };                 // Get the Width of the bitmap file
    DWORD GetHeight() { return m_dwHeight; };               // Get the Height of the bitmap file
    int   GetXPos() { return m_iXpos; };                    // Get the X Position of the bitmap file
    int   GetYPos() { return m_iYpos; };                    // Get the Y Position of the bitmap file
    void  SetXPos( int iX ) { m_iXpos = iX; };              // Set the X Position of the bitmap file
    void  SetYPos( int iY ) { m_iYpos = iY; };              // Set the Y Position of the bitmap file

private:
    // Private Properties
	DWORD   m_dwImageSize;
	DWORD*  m_pdwPixels;
	int     m_iXpos;
    int     m_iYpos;

	// Bitmap File Header
	WORD    m_wType;
	DWORD   m_dwFileSize;
	WORD    m_wReserved1;
	WORD    m_wReserved2;
	DWORD   m_dwOffBits;
	
	// Bitmap Info Header
	DWORD   m_dwInfoSize;
	DWORD   m_dwWidth;
	DWORD   m_dwHeight;
	WORD    m_wPlanes;
	WORD    m_wBitCount;
	DWORD   m_dwCompression;
	DWORD   m_dwSizeImage;
	DWORD   m_dwXPelsPerMeter;
	DWORD   m_dwYPelsPerMeter;
	DWORD   m_dwClrUsed;
	DWORD   m_dwClrImportant;

    // Private Methods
    void CleanUp();                     // Destory any allocated memory, etc
    void readAlpha( char* pszFile );    // Read the alpha mask for the BMP
};

#endif // _BITMAPFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\inc\gametitles.h ===
/*****************************************************
*** gametitles.h
***
*** Header file for our game title classes.  These
*** classes will enumerate and store information
*** about all of the Game Titles, and their Saved
*** games on the Xbox
***
*** by James N. Helm
*** June 16th, 2001
***
*****************************************************/

#ifndef _GAMETITLES_H_
#define _GAMETITLES_H_

#include "linkedlist.h"

class CMemoryArea;

class CSavedGame
{
public:
    // Constructors and Destructor
    CSavedGame();
    ~CSavedGame();

    // Public Methods
    HRESULT Init( XGAME_FIND_DATA* gameData );  // Initialize the Saved Game object and populate it's data
    WCHAR* GetName();                           // Get a pointer to the name of the saved game
    char* GetDirectory();                       // Get a pointer to the Saved Game directory
    DWORD GetBlockSize();                       // Returns the Block size of the Saved Game
    char* GetGameID();                          // Get a pointer to the Game ID of the Saved Game

    BOOL operator < ( const CSavedGame& item ) { return FALSE; };
    BOOL operator > ( const CSavedGame& item ) { return FALSE; };
    BOOL operator == ( const CSavedGame& item ) { return FALSE; };

    // Public Properties

private:
    // Private Methods

    // Private Properties
    WCHAR* m_pwszName;          // The name of the Saved Game
    DWORD m_dwBlockSize;        // The size of the Saved Game in Blocks
    char* m_pszGameID;          // The Game ID of the Saved Game
    char* m_pszGameDirectory;   // The directory of the Saved Game
    SYSTEMTIME m_GameDate;      // The Date/Time information of the Saved Game
};


class CGameTitle
{
public:
    // Constructors and Destructor
    CGameTitle();
    ~CGameTitle();

    // Public Methods
    HRESULT Init( char* pszDirectory,                       // Initialize our Game Title
                  CMemoryArea* pMemoryArea );
    DWORD GetNumSavedGames();                               // Returns the number of saved games for the game title
    DWORD GetBlockSize();                                   // Get the total block size of the Game Title
    WCHAR* GetName();                                       // Get a pointer to the name of the Game Title
    char* GetDirectory();                                   // Get a pointer to the directory of the Game Title
    char* GetTitleID();                                     // Get a pointer to the title ID of the Game Title
    WCHAR* GetSavedGameName( unsigned int uiIndex );        // Get the name of a Saved Game
    char* GetSavedGameID( unsigned int uiIndex );           // Get the ID of a Saved Game
    DWORD GetSavedGameBlockSize( unsigned int uiIndex );    // Get the block size of a Saved Game

    BOOL operator < ( const CGameTitle& item ) { return FALSE; };
    BOOL operator > ( const CGameTitle& item ) { return FALSE; };
    BOOL operator == ( const CGameTitle& item ) { return FALSE; };

    // Public Properties

private:
    // Private Methods
    HRESULT ProcessSavedGames( char* pszTitleID,            // Process the Saved Games for the specified Game Title
                               CMemoryArea* pMemoryArea );

    // Private Properties
    CLinkedList< CSavedGame* >  m_SavedGameList;    // List of pointers to Saved Games
    WCHAR* m_pwszName;                              // Name of the Game Title
    DWORD m_dwBlockSize;                            // Block size of the Game Title
    char* m_pszTitleID;                             // Game Title ID
    char* m_pszDirectory;                           // Directory for our Game Title
};

#define GAME_TITLE_XBX_FILENAME     "titlemeta.xbx"
#define GAME_TITLE_MAX_NAME         40
#define GAME_TITLE_NAME_TOKEN_W     L"TitleName="

class CXboxGames
{
public:
    // Constructors and Destructor
    CXboxGames();
    ~CXboxGames();

    // Public Methods
    HRESULT Init( char* pszDirectory,               // Initialize the list starting at the specified directory
                  CMemoryArea* pMemoryArea );
    CGameTitle* GetGame( unsigned int uiIndex );    // Get a pointer to a game at the specified index
    DWORD GetNumGames();                            // Get the number of Games on the Xbox
    // Public Properties

private:
    // Private Methods

    // Private Properties
    CLinkedList< CGameTitle* >  m_GameList;     // List of pointers to GameTitles
};

#endif // _GAMETITLES_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\inc\memoryunit.h ===
/*****************************************************
*** memoryunit.h
***
*** Header file for our Memory Unit class.
*** This class will contain functions and information
*** pertaining to an Xbox Memory Unit
***
*** by James N. Helm
*** March 28th, 2001
***
*****************************************************/

#ifndef _MEMORYUNIT_H_
#define _MEMORYUNIT_H_

#include "memoryarea.h"

class CMemoryUnit : public CMemoryArea
{
public:
    // Contructor and Destructors
    CMemoryUnit();
    ~CMemoryUnit();

    // Public Methods
    HRESULT Format( BOOL bMount=FALSE );                    // Format the Memory Unit
    HRESULT Unformat();                                     // Unformat the Memory Unit
    HRESULT Mount( BOOL bAsGameTitle=FALSE );               // Mount the Memory Unit
    HRESULT Unmount();                                      // Unmount the Memory Unit
    HRESULT Name( WCHAR* wpszName );                        // Name the Memory Unit
    HRESULT RefreshName();                                  // Refresh the name of the Memory Unit (it could change)
    HRESULT GetName( WCHAR* wpszNameBuffer,                 // Get the name of the MU
                     unsigned int uiBufSize );
    WCHAR* GetNamePtr() { return m_pwszMUName; };           // Get the name pointer of the MU
    DWORD GetFreeBlocks();                                  // Get the number of blocks that are free on the MU
    DWORD GetTotalBlocks();                                 // Get the total number of blocks on the MU
    DWORD GetPort() { return m_dwPort; };                   // Get the port of the MU
    DWORD GetSlot() { return m_dwSlot; };                   // Get the slot of the MU
    BOOL IsFormatted() { return m_bFormatted; };            // Returns the format state of the MU
    BOOL IsMounted() { return m_bMounted; };                // Returns the mount state of the MU
    BOOL IsNamed();                                         // Used to determine if the MU is named
    HRESULT SetPortSlot( DWORD dwPort,                      // Set the port and the slot this MU will be on
                         DWORD dwSlot );
    HRESULT MapUDataToOrigLoc();                            // Map the UDATA drive back to it's original location
    HRESULT MapUDataToTitleID( char* pszTitleID );          // Map the UDATA drive letter to the specified Title ID and Mount the MU
    HRESULT MapUDataToTitleID( WCHAR* pwszTitleID );        // Map the UDATA drive letter to the specified Title ID and Mount the MU
    HRESULT MapUDataToTitleID( DWORD dwTitleID );           // Map the UDATA drive letter to the specified Title ID and Mount the MU
    unsigned int GetIndex();                                // Get the Index of the current MU

private:
    // char    m_cDriveLetter;                                 // The drive letter the MU is mounted on
    WCHAR*  m_pwszMUName;                                   // The name of the MU
    BOOL    m_bMounted;                                     // When the MU is mounted, this is set to TRUE
    BOOL    m_bFormatted;                                   // Used to determine if the MU is formatted
    DWORD   m_dwPort;                                       // The port the MU is on (XDEVICE_PORT0 through XDEVICE_PORT3)
    DWORD   m_dwSlot;                                       // The slot of the Controller the MU is in (XDEVICE_TOP_SLOT or XDEVICE_BOTTOM_SLOT)

    // Private Methods
    HRESULT ProcessMountedMU();                             // Process a mounted MU (Get the name, etc)
};

#define MEMORY_UNIT_NAME_PATTERN    L"Memory Unit"

#endif // _MEMORYUNIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\inc\memoryarea.h ===
/*****************************************************
*** memoryarea.h
***
*** Header file for our Memory Area class.
*** This class will allow you to perform certain
*** actions that pertain to a memory area on the
*** Xbox, such as erase, create game titles, etc.
***
*** by James N. Helm
*** March 30th, 2001
***
*****************************************************/

#ifndef _MEMORYAREA_H_
#define _MEMORYAREA_H_

#include "gametitles.h"

class CMemoryArea
{
public:
    CMemoryArea();
    virtual ~CMemoryArea();

    // Public Methods
    virtual HRESULT AdjustFileSize( char* pszFileName,                              // Adjusts the file size by the specified amount
                                    LARGE_INTEGER liNumBytes );
    virtual HRESULT CopyGameImages( char* pszTitleDir,                              // Copy the Game images in to the title directory
                                    BOOL bCopyTitleImage=TRUE,
                                    BOOL bCopyDefSaveImage=TRUE );
    virtual HRESULT CreateTitleMetaXbx( char* pszGamePath,                          // Create a Title Meta XBX file for the specified game title
                                        WCHAR* pwszGameName,
                                        WCHAR* pwszLangCode,
                                        WCHAR* pwszMissingLangCode,
                                        BOOL bPrependLangCodeToName=TRUE );
    virtual HRESULT CreateGameTitle( char cDriveLetter,                             // Create a Game Title in the specified directory
                                     char* pszTitleDir,
                                     WCHAR* pwszGameName=NULL,
                                     BOOL bPrependLangCodeToName=TRUE );
    virtual HRESULT CreateSavedGame( IN WCHAR* pwszSavedGameName,                   // Create a Saved Game in the currently mapped UDATA directory
                                     OUT char* pszGamePath,
                                     IN unsigned int cbBuffSize,
                                     IN SYSTEMTIME* pSysTimeGameDate,
                                     IN char* pszSaveImage,
                                     IN BOOL bNoCopyGame );
    virtual DWORD   CreateZeroByteFile( char* pszFileName );                        // Create a file of zero bytes
    virtual HRESULT CreateFileOfSize( char* pszFileName,                            // Creates a file of a specified size
                                      LARGE_INTEGER liNumBytes );
    
    virtual void    CopyDirs( char* pszSource,                                      // Copy files from one directory to another
                              char* pszDest );
    virtual BOOL    CorruptPartition( POBJECT_STRING VolumePath );                  // Corrupt the specified partition by blanking out the initial page
    virtual BOOL    DeleteDirectory( char* pszPath );                               // Delete a directory and all files within
    virtual void    Erase( char cDriveLetter = '\0' );                              // Clear the Memory Area of all data
    virtual DWORD   GetMAFileSize( char* pszFileName );                             // This function will get the file size of the file, and return it to the caller
    virtual DWORD   GetFreeBlocks();                                                // Get the number of blocks that are free on the Memory Area
    virtual DWORD   GetTotalBlocks();                                               // Get the total number of blocks on the Memory Area
    virtual char    GetUDataDrive() { return m_cUDataDriveLetter; };                // Get the Drive letter of UDATA
    virtual void    SetUDataDrive( char cDrive ) { m_cUDataDriveLetter = cDrive; }; // Set the UDATA Drive Letter
    virtual BOOL    FileExists( char* pszFileName );                                // Will return TRUE if a file exists, otherise FALSE
    virtual void    FillArea( char* pszDirectory,                                   // Fill the Memory Area with a specified Number of Blocks worth of data
                              unsigned int uiNumBlocks );
    virtual HRESULT CreateFragTempFiles();                                          // Creates temporary files to use during fragmentations
    virtual HRESULT FragmentTree( char* pszStartDirectory );                        // Will fragment the specified directory, and all directories within
    virtual HRESULT FragmentDirectory( char* pszDirPath );                          // Fragments all files in a given directory
    virtual HRESULT FragmentFile( char* pszFilePath,                                // Fragments an individual file
                                  char* pszFileName );


    virtual DWORD MapDrive( char cDriveLetter,                                      // Map a drive to a partiticular drive letter
                            char* pszPartition );
    virtual DWORD UnMapDrive( char cDriveLetter );                                  // Un-map a drive from the specified drive letter
    virtual HRESULT GetDefaultName( WCHAR* pwszBuffer,                              // Used to get the Memory Area default name
                                    ULONG ulBufferLen );
    virtual WCHAR* GetDefaultNamePtr() { return m_pwszDefaultName; };               // Get the pointer to our default name

    CXboxGames* GetGameTitlePtr() { return &m_GameTitles; };                        // Get a pointer to our Game Title Object
    virtual void ProcessGameTitles();                                               // Will search the memory area and populate the GameTitles object

    virtual HRESULT MapUDataToOrigLoc() = 0;                                        // Map the UDATA drive to it's orignal location
    virtual HRESULT MapUDataToTitleID( char* pszTitleID ) = 0;                      // Map the UDATA drive letter to the specified Title ID
    virtual HRESULT MapUDataToTitleID( WCHAR* pwszTitleID ) = 0;                    // Map the UDATA drive letter to the specified Title ID
    virtual HRESULT MapUDataToTitleID( DWORD dwTitleID ) = 0;                       // Map the UDATA drive letter to the specified Title ID

    virtual void SetAbortProcess( BOOL bSetting );                                  // Used to set whether or not the current process should be aborted
    virtual BOOL GetAbortProcess();                                                 // Used to get the state of our current process


protected:
    // Private Properties
    WCHAR*              m_pwszDefaultName;                                          // Used to hold the default MA name
    char                m_cUDataDriveLetter;                                        // UDATA Drive letter for the current area
    CXboxGames          m_GameTitles;                                               // Handles interaction with Game Titles and Saved Games
    CRITICAL_SECTION    m_ProcessCritSec;                                           // Critical Section to protect our process abort memory
    BOOL                m_bAbortProcess;                                            // Aborts long running process such as Fragmentation

    // Private Methods
    HRESULT CalcSpace( DWORD* pdwTotalBlocks,                                       // Retreives block information for the current MU
                       DWORD* pdwFreeBlocks );
    HRESULT SetDefaultName( WCHAR* pwszName );                                      // Used to set the Default name of the Memory Area
};

#define MEMORY_AREA_DATA_DIRECTORY_A                "d:\\data"

#define MEMORY_AREA_TITLE_META_FILENAME             "titlemeta.xbx"
#define MEMORY_AREA_TITLE_META_TITLENAME_TOKEN      L"TitleName="
#define MEMORY_AREA_TITLE_IMAGE_FILENAME            "titleimage.xbx"
#define MEMORY_AREA_TITLE_IMAGE_PATHINFO            MEMORY_AREA_DATA_DIRECTORY_A "\\" MEMORY_AREA_TITLE_IMAGE_FILENAME
#define MEMORY_AREA_SAVEGAME_IMAGE_FILENAME         "saveimage.xbx"
#define MEMORY_AREA_SAVEGAME_IMAGE_PATHINFO         MEMORY_AREA_DATA_DIRECTORY_A "\\" MEMORY_AREA_SAVEGAME_IMAGE_FILENAME
#define MEMORY_AREA_DEFSAVE_IMAGE_FILENAME          "defsave.xbx"
#define MEMORY_AREA_DEFSAVE_IMAGE_PATHINFO          MEMORY_AREA_DATA_DIRECTORY_A "\\" MEMORY_AREA_DEFSAVE_IMAGE_FILENAME

#define MEMORY_AREA_FRAG_NUM_FILES                  2000
#define MEMORY_AREA_FRAG_FILE_DIR                   "c:\\devkit\\xdk_frag_files"
#define MEMORY_AREA_FRAG_FILL_FILENAME              MEMORY_AREA_FRAG_FILE_DIR "\\xdk_fill_file.xdk"
#define MEMORY_AREA_FRAG_FILE_PATTERN               "xdk_file_"

#define MEMORY_AREA_UNICODE_SIGNATURE               L'\xFEFF'

#define MEMORY_AREA_BLOCK_SIZE_MAX_NUM_LOW_PART     262143
#define MEMORY_AREA_BLOCK_SIZE_IN_BYTES             16384


// Meta Data Constants
enum MemAreaLangCodes
{
    ENUM_MEMAREA_LANGUAGECODE_DEFAULT,
    ENUM_MEMAREA_LANGUAGECODE_ENGLISH,
    ENUM_MEMAREA_LANGUAGECODE_JAPANESE,
    ENUM_MEMAREA_LANGUAGECODE_GERMAN,
    ENUM_MEMAREA_LANGUAGECODE_ITALIAN,
    ENUM_MEMAREA_LANGUAGECODE_FRENCH,
    ENUM_MEMAREA_LANGUAGECODE_SPANISH,

    ENUM_MEMAREA_LANGUAGECODE_NUM_ITEMS
};

static WCHAR* g_wpszMemAreaLanguageCodes[] = {
    L"[default]",
    L"[EN]",
    L"[JA]",
    L"[DE]",
    L"[IT]",
    L"[FR]",
    L"[ES]"
};

#endif // _MEMORYAREA_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\inc\harddrive.h ===
/*****************************************************
*** harddrive.h
***
*** Header file for our Hard Drive class.
*** This class will contain functions and information
*** pertaining to the Xbox Hard Drive
***
*** by James N. Helm
*** April 2nd, 2001
***
*****************************************************/

#ifndef _HARDDRIVE_H_
#define _HARDDRIVE_H_

#include "memoryarea.h"
#include "dashst.h"

class CHardDrive : public CMemoryArea
{
public:
    // Contructor and Destructors
    CHardDrive();
    ~CHardDrive();

    // Public Methods
    char GetTDataDrive() { return m_cTDataDriveLetter; };                   // Get the Drive letter of TDATA
    void SetTDataDrive( char cDrive ) { m_cTDataDriveLetter = cDrive; };    // Set the TDATA Drive letter
    HRESULT CreateSavedGame( IN WCHAR* pwszSavedGameName,                   // Create a Saved Game
                             OUT char* pszGamePath,
                             IN unsigned int cbBuffSize,
                             IN SYSTEMTIME* pSysTimeGameDate,
                             IN char* pszSaveImage,
                             IN BOOL bNoCopyGame );
    HRESULT RemoveAllSoundtracks();                                         // Remove all of the Soundtracks that live on the hard drive
    HRESULT RemoveAllNicknames();                                           // Remove all of the Nicknames that live on the hard drive

    HRESULT MapUDataToOrigLoc();                                            // Map the UDATA drive to it's orignal location
    HRESULT MapUDataToTitleID( char* pszTitleID );                          // Map the UDATA drive letter to the specified Title ID
    HRESULT MapUDataToTitleID( WCHAR* pwszTitleID );                        // Map the UDATA drive letter to the specified Title ID
    HRESULT MapUDataToTitleID( DWORD dwTitleID );                           // Map the UDATA drive letter to the specified Title ID

    HRESULT MapTDataToOrigLoc();                                            // Map the TDATA drive to it's orignal location
    HRESULT MapTDataToTitleID( char* pszTitleID );                          // Map the TDATA drive letter to the specified Title ID
    HRESULT MapTDataToTitleID( WCHAR* pwszTitleID );                        // Map the TDATA drive letter to the specified Title ID
    HRESULT MapTDataToTitleID( DWORD dwTitleID );                           // Map the TDATA drive letter to the specified Title ID

private:
    char m_cTDataDriveLetter;                                               // Drive letter for our TDATA

    ANSI_STRING m_ostTDataDrive;                                            // Used to create our link to the TDATA directory
    ANSI_STRING m_ostTDataPath;                                             // Used to create our link to the TDATA directory
    ANSI_STRING m_ostUDataDrive;                                            // Used to create our link to the UDATA directory
    ANSI_STRING m_ostUDataPath;                                             // Used to create our link to the UDATA directory
};

// Hard drive specific defines
#define HARDDRIVE_NICKNAME_FILENAME     "NICKNAME.XBN"
#define HARDDRIVE_NAME_PATTERN         L"Xbox Hard Disk"

#define HARDDRIVE_TDATA_DRIVE_LETTER_A      'V'
#define HARDDRIVE_TDATA_PATH_A              "\\Device\\Harddisk0\\partition1\\tdata"
#define HARDDRIVE_UDATA_DRIVE_LETTER_A      'X'
#define HARDDRIVE_UDATA_PATH_A              "\\Device\\Harddisk0\\partition1\\udata"

#endif // _HARDDRIVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\inc\wavemedia.h ===
/*****************************************************
*** wavemedia.h
***
*** H file for a WAV file media object.  This class
*** will allow a user to specify the DirectSound
*** pointer, and a WAV file name, and will allow
*** the user to playback the sound
***
*** by James N. Helm
*** May 25th, 2001
***
*****************************************************/

#ifndef _WAVEMEDIA_H_
#define _WAVEMEDIA_H_

#define WAVEM_APP_TITLE_NAME_A  "WAVM"

class CWaveMedia
{
public:
    // Constructors and Destructors
    CWaveMedia();
    ~CWaveMedia();

    // Public Properties
    // Public Methods
    BOOL IsPlaying();                           // Returns TRUE if the sound is currently playing
    void Play();                                // Play the sound
    void Stop();                                // Stop playing the sound
    void ResetToBeginning();                    // Reset the current playback pointer to the beginning of a sound
    void SetVolume( LONG lVolume );             // Set the volume of the Wave object
    
    BOOL Init( LPDIRECTSOUND pDSound,           // Initialize the Wave Media Object
               char* pszWaveFileName,
               LONG lDefaultVolume = 0 );

    void CleanUp();                             // Used to cleanup (de-initialize) the object

private:
    // Private Properties
    LPDIRECTSOUND       m_pDSound;              // Pointer to the Direct Sound object
	LPDIRECTSOUNDBUFFER m_pDSoundBuffer;        // Pointer to the local DSound buffer
	XFileMediaObject*   m_pFMOFile;             // Pointer to our XFileMediaObject file
    XMEDIAPACKET        m_xmp;                  // XMedia Packet
    char*               m_pszWaveFileName;      // Wave File Name
    LONG                m_lVolume;              // Default Volume this wav will be played at
    BOOL                m_bInitialized;         // Used to determine if this object was initialized

    // Private Methods
    BOOL ProcessWaveFile();                     // Load the WAV file in to our local DSound Buffer
};

#endif // _WAVEMEDIA_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\inc\usbmanager.h ===
/*

Copyright (c) 2001 Microsoft Corporation

Module Name:

    UsbManager.h

Abstract:


Author:

    Josh Poley (jpoley)
    Jim Helm (jimhelm)

Environment:

    Xbox

Revision History:
    07-20-2000  Created
    11-01-2000  Modified JNH -- Removed uneeded launcher and socket code
    06-01-2001  Modified JNH -- Added Remote Control support

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == _XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

class USBManager;

#ifndef _USBMANAGER_H_
#define _USBMANAGER_H_

#define ARRAYSIZE(a)            (sizeof(a) / sizeof(a[0]))
#define BREAK_INTO_DEBUGGER     _asm { int 3 }
#define USBM_APP_TITLE_NAME_A   "USBM"

#include "..\..\..\..\inc\xboxp.h"

// Buttons
// #define NUM_REMOTE_BUTTONS      27

static WORD g_aRemoteButtons[] =
{
    0xAD5,
    0xAE2,
    0xAEA,
    0xAE3,
    0xADD,
    0xAE0,
    0xAE6,
    0xADF,
    0xAE5,
    0xAC3,
    0xAF7,
    0xAD8,
    0xAA6,
    0xAA9,
    0xA0B,
    0xAA8,
    0xAA7,
    0xACF,
    0xACE,
    0xACD,
    0xACC,
    0xACB,
    0xACA,
    0xAC9,
    0xAC8,
    0xAC7,
    0xAC6
};

#define REMOTE_BUTTON_REPEAT_THRESHOLD      200 // milliseconds

enum REMOTE_BUTTONS
{
    REMOTE_BUTTON_MIN           = 0,
    REMOTE_BUTTON_POWER         = 0, // = 0xAD5,
    REMOTE_BUTTON_REVERSE,           // = 0xAE2,
    REMOTE_BUTTON_PLAY,              // = 0xAEA,
    REMOTE_BUTTON_FORWARD,           // = 0xAE3,
    REMOTE_BUTTON_SKIPBACK,          // = 0xADD,
    REMOTE_BUTTON_STOP,              // = 0xAE0,
    REMOTE_BUTTON_PAUSE,             // = 0xAE6,
    REMOTE_BUTTON_SKIPFORWARD,       // = 0xADF,
    REMOTE_BUTTON_GUIDE,             // = 0xAE5,
    REMOTE_BUTTON_INFO,              // = 0xAC3,
    REMOTE_BUTTON_MENU,              // = 0xAF7,
    REMOTE_BUTTON_REPLAY,            // = 0xAD8,
    REMOTE_BUTTON_UP,                // = 0xAA6,
    REMOTE_BUTTON_LEFT,              // = 0xAA9,
    REMOTE_BUTTON_OK,                // = 0xA0B,
    REMOTE_BUTTON_RIGHT,             // = 0xAA8,
    REMOTE_BUTTON_DOWN,              // = 0xAA7,
    REMOTE_BUTTON_0,                 // = 0xACF,
    REMOTE_BUTTON_1,                 // = 0xACE,
    REMOTE_BUTTON_2,                 // = 0xACD,
    REMOTE_BUTTON_3,                 // = 0xACC,
    REMOTE_BUTTON_4,                 // = 0xACB,
    REMOTE_BUTTON_5,                 // = 0xACA,
    REMOTE_BUTTON_6,                 // = 0xAC9,
    REMOTE_BUTTON_7,                 // = 0xAC8,
    REMOTE_BUTTON_8,                 // = 0xAC7,
    REMOTE_BUTTON_9,                 // = 0xAC6

    REMOTE_BUTTON_MAX
};

enum BUTTONS
{
    BUTTON_MIN = 0,
    BUTTON_A   = 0,
    BUTTON_B,
    BUTTON_X,
    BUTTON_Y,
    BUTTON_BLACK,
    BUTTON_WHITE,
    BUTTON_LEFT_TRIGGER,
    BUTTON_RIGHT_TRIGGER,

    BUTTON_MAX
};

enum CONTROLS
{
    CONTROL_MIN     = 0,
    CONTROL_DPAD_UP = 0,
    CONTROL_DPAD_DOWN,
    CONTROL_DPAD_LEFT,
    CONTROL_DPAD_RIGHT,
    CONTROL_START,
    CONTROL_BACK,
    CONTROL_LEFT_THUMB,
    CONTROL_RIGHT_THUMB,

    CONTROL_MAX
};

// Ports
enum PORTS
{
    PORT_ANY = -1,
    PORT_MIN = 0,
    PORT_1 = 0,
    PORT_2,
    PORT_3,
    PORT_4,

    PORT_MAX
};

// Joysticks
enum JOYSTICK
{
    JOYSTICK_ANY = -1,
    JOYSTICK_MIN = 0,
    JOYSTICK_LEFT = 0,
    JOYSTICK_RIGHT,

    JOYSTICK_MAX
};

// Parameters
#define FALSE_ON_REPEAT     TRUE
#define TRUE_ON_REPEAT      FALSE

enum
{
    SLOT_CONTROLLER = 0,
    SLOT_TOP,
    SLOT_BOTTOM,

    SLOT_MAX
};

class CControllerState
{
public:
    // Constructors and Destructors
    CControllerState()
    {
        for( unsigned int port = 0; port < XGetPortCount(); ++port )
        {
            for( unsigned int button = 0; button < BUTTON_MAX; ++button )
            {
                nButtonPress[port][button] = 0;
            }

            for( unsigned int control = 0; control < CONTROL_MAX; ++control )
            {
                bControlPressed[port][control] = FALSE;
            }

            for( unsigned int joystick = 0; joystick < JOYSTICK_MAX; ++joystick )
            {
                sThumbX[port][joystick] = 0;
                sThumbY[port][joystick] = 0;
            }

            for( unsigned int remotebutton = 0; remotebutton < REMOTE_BUTTON_MAX; ++ remotebutton )
            {
                m_bRemoteButtonPress[port][remotebutton] = FALSE;
            }

            dwControllerState[port] = 0;
        }
    };

    ~CControllerState(){};

    // Public Properties
    BOOL m_bRemoteButtonPress[XGetPortCount()][REMOTE_BUTTON_MAX];
    BYTE nButtonPress[XGetPortCount()][BUTTON_MAX];
    BOOL bControlPressed[XGetPortCount()][CONTROL_MAX];
    SHORT sThumbX[XGetPortCount()][JOYSTICK_MAX];
    SHORT sThumbY[XGetPortCount()][JOYSTICK_MAX];
    DWORD dwControllerState[XGetPortCount()];
private:
};

class USBDevice
{
public:
    PXPP_DEVICE_TYPE m_type; // XDEVICE type

public:
    USBDevice()
    {
        m_type = NULL;
    }

    ~USBDevice()
    {
        m_type = NULL;
    }

public:
    virtual void Insert( unsigned port, unsigned slot ) = 0;
    virtual void Remove( void ) = 0;
};


class DeviceRemote : public USBDevice
{
public:
    HANDLE m_hRemote;

public:
    DeviceRemote()
    {
        m_type = XDEVICE_TYPE_IR_REMOTE;
        m_hRemote = NULL;
    }

    DeviceRemote( unsigned port, unsigned slot )
    {
        m_type = XDEVICE_TYPE_IR_REMOTE;
        m_hRemote = NULL;

        Insert( port, slot );
    }

    ~DeviceRemote()
    {
        if( m_hRemote )
        {
            Remove();
        }
    }

public:
    void Insert( unsigned port, unsigned slot )
    {
        m_hRemote = XInputOpen( XDEVICE_TYPE_IR_REMOTE, port, XDEVICE_NO_SLOT, NULL );
        if( NULL == m_hRemote )
        {
            XDBGWRN( USBM_APP_TITLE_NAME_A, "DeviceRemote::Insert():Problem Opening Device!! Port - '%d', Error - '%d'", port, GetLastError() );
        }
    }

    void Remove( void )
    {
        XInputClose( m_hRemote );
        m_hRemote = NULL;
    }
};


class DeviceDuke : public USBDevice
{
public:
    HANDLE m_hDuke;
    XINPUT_POLLING_PARAMETERS* m_pPollingParameters;

public:
    DeviceDuke()
    {
        m_type = XDEVICE_TYPE_GAMEPAD;
        m_pPollingParameters = NULL;
        m_hDuke = NULL;
    }

    DeviceDuke( unsigned port, unsigned slot, XINPUT_POLLING_PARAMETERS *p )
    {
        m_type = XDEVICE_TYPE_GAMEPAD;
        m_pPollingParameters = p;
        m_hDuke = NULL;

        Insert( port, slot );
    }

    ~DeviceDuke()
    {
        if( m_hDuke )
        {
            Remove();
        }
    }

public:
    void Insert( unsigned port, unsigned slot )
    {
        m_hDuke = XInputOpen( XDEVICE_TYPE_GAMEPAD, port, 0, m_pPollingParameters );
        if( NULL == m_hDuke )
        {
            XDBGWRN( USBM_APP_TITLE_NAME_A, "DeviceDuke::Insert():Problem Opening Device!! Port - '%d', Error - '%d'", port, GetLastError() );
        }
    }

    void Remove( void )
    {
        XInputClose( m_hDuke );
        m_hDuke = 0;
    }
};

typedef struct _RUMBLE_INFO
{
    int nPort;
    WORD wForce;
    int nMilliseconds;
    USBManager* pUSBManager;
} RUMBLE_INFO, *PRUMBLE_INFO;

class USBManager
{
public:
    USBDevice *devices[XGetPortCount()][SLOT_MAX];
    DWORD packetNum[XGetPortCount()][SLOT_MAX];
    XINPUT_POLLING_PARAMETERS pollingParameters;
    XINPUT_STATE m_state;

public:
    USBManager();
    ~USBManager();

public:
    // Calling this will update the controller state objects with the latest info
    void ProcessInput( void );

    // Calling this will check to see if controllers we added or removed
    void CheckForHotplugs( void );

    // This will allow you to determine if a remote control button is 'depressed'.  If an address to a BOOLean
    // variable is provided, it will return whether or not it's the 'first' press of the button
    BOOL IsRemoteButtonPressed( int port, enum REMOTE_BUTTONS button, BOOL* bFirstPress=NULL );

    // This will allow you to determine if a button is 'depressed'.  If an address to a BOOLean
    // variable is provided, it will return whether or not it's the 'first' press of the button
    BOOL IsButtonPressed( int port, enum BUTTONS button, int nThreshold=0, BOOL* bFirstPress=NULL );

    // This will allow you to determine if a control is 'depressed'.  If an address to a BOOLean
    // variable is provided, it will return whether or not it's the 'first' press of the control
    BOOL IsControlPressed( int port, enum CONTROLS control, BOOL* bFirstPress=NULL );

    // This will allow you to get the value of the X or Y axis, adjusting for a "dead zone".
    // If a dead zone is passed in, the call will return '0' unless the value of the X or Y axis
    // is greater than the dead zone value.  If an address to a BOOLean variable is provided, it
    // will return whether or not it's the 'first' press of the joystick
    int  GetJoystickX( int port, enum JOYSTICK, int deadZone=0, BOOL* bFirstPress=NULL );
    int  GetJoystickY( int port, enum JOYSTICK, int deadZone=0, BOOL* bFirstPress=NULL );

    // Calling this will determine if there was movement for any item on a controller
    // Will return TRUE if any button or thumbstick has changed since last poll
    BOOL MovementDetected( int port, int deadZone=0 );

    // Will send a rumble command to the specified device
    void Rumble( int port, WORD wForce, int nMilliseconds );

private:
    CControllerState m_ControllerState;
    CControllerState m_PrevControllerState;

    HANDLE m_hThreads[4];
    RUMBLE_INFO m_RumbleInfo[4];

    static friend DWORD WINAPI RumbleThread( LPVOID lpParameter );
};

#endif // _USBMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\inc\xitem.h ===
/*****************************************************
*** xitem.h
***
*** Header file for our abstract base class for a
*** generic screen of our XDash Config program.
***
*** by James N. Helm
*** November 2nd, 2000
***
*** Modified
*** 12/03/2000 - by James N. Helm for XShell
*** 03/09/2001 - by James N. Helm for MU Config
*** 06/22/2001 - by James N. Helm for MU Config
***              Added Set/Get Title functions and
***              property
*****************************************************/

#ifndef _XDCITEM_H_
#define _XDCITEM_H_

#include "udtexture.h"

#define XITEM_TITLE_SIZE    100

class CXItem
{
public:
    // Constructors and Destructors
    CXItem( CXItem* pParent );
    virtual ~CXItem();

    // Functions that MUST be overridden
    virtual void Action( CUDTexture* pTexture ) = 0;
    virtual void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress ) = 0;
    virtual void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress ) = 0;
    virtual void HandleInput( enum JOYSTICK joystick, int nThumbLY, int nThumbLX, BOOL bFirstYPress, BOOL bFirstXPress ) = 0;
    
    virtual void Enter() = 0;                       // Should be called whenever the menu becomes active
    virtual void Leave( CXItem* pItem ) = 0;        // Should be called whenever user is leaving the menu

    virtual CXItem* GetParent() const { return m_pParent; };
    virtual void SetParent( CXItem* pParent ) { m_pParent = pParent; };
    virtual HRESULT SetTitle( WCHAR* pwszTitle );       // Set the Title name of the object
    virtual WCHAR* GetTitle() { return m_pwszTitle; };  // Get the Title of the object

    virtual CXItem* GetItemPtr( enum XShellMenuIds menuID ) { return NULL; };  // Items can override this as needed

protected:
    BOOL m_bUpdateTexture;          // An item can use this to determine if the texture should be updated
    WCHAR* m_pwszTitle;             // Used to hold the object title

private:
    CXItem* m_pParent;              // Pointer to the parent screen of this item
};

#endif // _XDCITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\inc\udtexture.h ===
/*****************************************************
*** udtexture.h
***
*** Header file for our udtexture class.  This class
*** will hold a texture and allow the user to perform
*** certain actions on this texture, like writing
*** text, etc
*** 
*** by James N. Helm
*** January 24th, 2001
*** 
*** Modified
*** 03/09/2001 - James N. Helm
*****************************************************/

#ifndef _UDTEXTURE_H_
#define _UDTEXTURE_H_

#include "xfont.h"

typedef struct _UDTEXTURE_VERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    cDiffuse;
} UDTEXTURE_VERTEX;

#define D3DFVF_UDTEXTURE_VERTEX     ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE )

class CUDTexture
{
public:
    // Constructors and Destructors
    CUDTexture( void );
    ~CUDTexture( void );

    // Public Properties

    // Public Methods
    void Initialize( IDirect3DDevice8* pDevice,             // Initialize our texture and create our surface 
                     char* pszFileName,
                     int iTextureWidth,
                     int iTextureHeight );

    void CleanUp();                                         // Clean up any memory we have allocated
    
    void Clear( DWORD dwColor );                            // Clear the current Texture, setting the background to specified color
    
    void DrawBox( float fX1,                                // Draw a box on the screen
                  float fY1,
                  float fX2,
                  float fY2,
                  DWORD dwColor );

    void DrawClearRect( float fX1,                          // Draw a clear rectangle to the screen
                        float fY1,
                        float fX2,
                        float fY2,
                        DWORD dwColor );

    void DrawLine( float fX1,                               // Draw a line on the screen
                   float fY1,
                   float fX2,
                   float fY2,
                   float fLineWidth,
                   DWORD dwColor );

    void DrawOutline( float fX1,                            // Draw an outline at the current location with a specific border size
                      float fY1,
                      float fX2,
                      float fY2,
                      float fLineWidth,
                      DWORD dwColor );

    void DrawText( XFONT* pXFont,                           // Prints formatted text, using the default font size, in the specified font
                   float fX1,
                   float fY1,
                   DWORD dwFGColor,
                   DWORD dwBGColor,
                   const WCHAR* pwszFormat,
                   ... );

    void DrawText( float fX1,                               // Prints formatted text, using the default font size
                   float fY1,
                   DWORD dwFGColor,
                   DWORD dwBGColor,
                   const WCHAR* pwszFormat,
                   ... );

    void Lock();                                            // Lock the texture surface so that we can render on to it
    void Unlock();                                          // Unlock the texture surface after we have rendered on to it

    IDirect3DTexture8* GetTexture() { return m_pTexture; };                 // Get the address of the texture
    IDirect3DSurface8* GetTextureSurface() { return m_pTextureSurface; };   // Get the address of the texture surface

private:
    // Private Properties
    IDirect3DDevice8*       m_pD3DDevice;               // Direct 3D Device Pointer
    IDirect3DTexture8*      m_pTexture;                 // Actual texture being worked on
    IDirect3DSurface8*      m_pTextureSurface;          // Surface of the texture -- can render to this
    IDirect3DSurface8*      m_pCurrentRenderTarget;     // Used to store the render target that is set outside the texture
    IDirect3DVertexBuffer8* m_pVertexBuffer;            // Vertex Buffer used for our Primitive calls
    IDirect3DVertexBuffer8* m_pCurrentVBuffer;          // Used to store Vertex Buffer that is set outside the texture
    UINT                    m_uiCurrentStride;          // Used to store the stride of the VB that is set outside the texture
    D3DLOCKED_RECT          m_d3dlr;                    // Rect structure used in our "lock"
    int                     m_iTextureWidth;            // Width of the Texture
    int                     m_iTextureHeight;           // Height of the Texture
    unsigned int            m_uiTextureLockedRef;       // Used to determine if our texture is locked
    
    // Private Methods
};

#endif // _UDTEXTURE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\inc\linkedlist.h ===
/*****************************************************
*** linkedlist.h
***
*** Header file for our linked list class.  This class
*** will allow the user to create a linked list using
*** any type of item.
***
*** by James N. Helm
*** October 31st, 2000
***
*****************************************************/

#ifndef _LINKEDLIST_H_
#define _LINKEDLIST_H_

#define LINKEDLIST_APP_TITLE_NAME_A     "LIST"

#include <xtl.h>
#include <..\..\..\..\inc\xdbg.h>

template <class T> class CLinkedList
{
public:
    // Constructors and Destructors
    CLinkedList( void );
    ~CLinkedList( void );

    // Public Properties

    // Public Methods
    HRESULT AddNode( const T& item );                                           // Add a node to our linked list
    HRESULT DelNode( unsigned int uiIndex );                                    // Delete a node from our list by using an index
    HRESULT DelCurrentNode();                                                   // Delete the node at the current index
    HRESULT EmptyList( void );                                                  // Empty all of the items out of our list
    HRESULT MoveTo( unsigned int uiIndex );                                     // Move to the specified item in our list via index
    BOOL MoveFirst();                                                           // Move to the first element in our list
    BOOL MoveLast();                                                            // Move to the last element in our list
    BOOL MoveNext();                                                            // Move to the next item in the list
    BOOL MovePrev();                                                            // Move to the prev item in the list
    unsigned int GetNumItems( void ) const;                                     // Get the number of items in our list
    void SetSortedList( BOOL bSorted ) { m_bSorted = bSorted; };                // Set this to have the list apply an insertion sort
    void SetDeleteDataItem( BOOL bDelItem ) { m_bDeleteDataItem = bDelItem; };  // Set this if the list needs to delete the dataitem
    T& GetCurrentNode() const;                                                  // Get a data item from the current node in our list
    T& GetNode( unsigned int uiIndex ) const;                                   // Get a data item from our list by using an index
    unsigned int GetCurrentIndex() const { return m_uicCurrentItemIndex; };     // Get the index of the current item within our list
    T& operator[]( unsigned int uiIndex ) const;                                // Get a data item from our list by using an index

private:
    // Node of our linked list
    struct _LISTNODE
    {
        T dataItem;
        struct _LISTNODE* pNext;
        struct _LISTNODE* pPrev;
    };

    // Private Properties
    unsigned int m_uicNumItems;         // Number of items in the list
    struct _LISTNODE* m_pHead;          // Head of our list
    struct _LISTNODE* m_pLast;          // Last Node of our list
    struct _LISTNODE* m_pCurrent;       // Points at the current item in the list
    unsigned int m_uicCurrentItemIndex; // Index of the item that is currently being pointed at
    BOOL m_bDeleteDataItem;             // This needs to be TRUE if you are passing in a structure / item that was 'new'ed
    BOOL m_bSorted;                     // Used to determine if the list should be sorted

    // Private Methods
    HRESULT AddSorted( const T& item );
    HRESULT AddUnsorted( const T& item );
};


// Default Constructor.  Properties are initialized here
template< class T > CLinkedList< T >::CLinkedList( void )
: m_uicNumItems( 0 ),
  m_pHead( NULL ),
  m_pLast( NULL),
  m_pCurrent( NULL ),
  m_uicCurrentItemIndex( 0 ),
  m_bDeleteDataItem( FALSE),
  m_bSorted( FALSE )
{
}


// Destructor.  Memory cleanup is performed here
template< class T > CLinkedList< T >::~CLinkedList( void )
{
    // Empty all items from our list
    EmptyList();
}


// Add a node to our list in sorted order
template< class T > HRESULT CLinkedList< T >::AddSorted( const T& item )
{
    // Item to be added to our list
    struct _LISTNODE* pNewItem = new struct _LISTNODE;

    if( !pNewItem )
    {
        XDBGWRN( LINKEDLIST_APP_TITLE_NAME_A, " CLinkedList():AddSorted():Could not allocate memory!!" );

        return E_OUTOFMEMORY;
    }

    pNewItem->dataItem = item;
    pNewItem->pNext = NULL;
    pNewItem->pPrev = NULL;

    // Check to see if we have a head node.  If not, add the item there
    if( !m_pHead )
    {
        XDBGTRC( LINKEDLIST_APP_TITLE_NAME_A, " CLinkedList():AddSorted():Adding Head" );

        m_pCurrent = m_pLast = m_pHead = pNewItem;
        m_uicCurrentItemIndex = 0;  // Points at the head node

    }
    else // Add the node in the proper location of our list (sorted order)
    {
        struct _LISTNODE* pCurrent = m_pHead;
        struct _LISTNODE* pPrev = m_pHead;

        // Check to see if it's the head node that's replaced
        if( *(pNewItem->dataItem) < *(m_pHead->dataItem) )
        {
            XDBGTRC( LINKEDLIST_APP_TITLE_NAME_A, " CLinkedList():AddSorted():Replacing Head Node" );
            pNewItem->pNext = m_pHead;
            m_pHead->pPrev = pNewItem;
            m_pHead = pNewItem;
        }
        else // Add it to the middle, or the end of the list
        {
            while( pCurrent )
            {
                // If the item is not greater than the current item, we should insert it right before
                // the current item
                if( *(pNewItem->dataItem) < *(pCurrent->dataItem) )
                {
                    XDBGTRC( LINKEDLIST_APP_TITLE_NAME_A, " CLinkedList():AddSorted():Adding Middle" );
                    pPrev->pNext = pNewItem;            // Set the previous item's next pointer to our new item
                    pNewItem->pNext = pCurrent;         // Set the new item's next pointer to our current item
                    pNewItem->pPrev = pPrev;            // Set our new item's previous pointer to the previous node
                    pCurrent->pPrev = pNewItem;         // Set the current item's previous pointer to our new node

                    break;  // We no longer need to traverse the list
                }

                pPrev = pCurrent;
                pCurrent = pCurrent->pNext;
            }

            // If pCurrent is NULL, we need to add our new node at the end of the list
            if( NULL == pCurrent )
            {
                XDBGTRC( LINKEDLIST_APP_TITLE_NAME_A, " CLinkedList():AddSorted():Adding Last" );
                m_pLast->pNext = pNewItem;  // Add the new node to our list
                pNewItem->pPrev = m_pLast;  // Update the new nodes previous pointer
                m_pLast = pNewItem;         // Update our pLast pointer to point at the new last node
            }
        }
    }

    // Increment the number of items in our list
    ++m_uicNumItems;

    return S_OK;
}

// Add a node to our list without sorting it
template< class T > HRESULT CLinkedList< T >::AddUnsorted( const T& item )
{
    // Item to be added to our list
    struct _LISTNODE* pNewItem = new struct _LISTNODE;

    if( !pNewItem )
    {
        XDBGWRN( LINKEDLIST_APP_TITLE_NAME_A, " CLinkedList():AddUnsorted():Could not allocate memory!!" );

        return E_OUTOFMEMORY;
    }

    pNewItem->dataItem = item;
    pNewItem->pNext = NULL;
    pNewItem->pPrev = NULL;

    // Check to see if we have a head node.  If not, add the item there
    if( !m_pHead )
    {
        m_pCurrent = m_pLast = m_pHead = pNewItem;
        m_uicCurrentItemIndex = 0;  // Points at the head node

    }
    else // Add the node to the end of our list
    {
        m_pLast->pNext = pNewItem;  // Add the new node to our list
        pNewItem->pPrev = m_pLast;  // Update the new nodes previous pointer
        m_pLast = pNewItem;         // Update our pLast pointer to point at the new last node
    }

    // Increment the number of items in our list
    ++m_uicNumItems;

    return S_OK;
}

// Add a node to our list
template< class T > HRESULT CLinkedList< T >::AddNode( const T& item )
{
    if( m_bSorted )
        return AddSorted( item );
    else
        return AddUnsorted( item );
}


// Delete the node at the current index
template< class T > HRESULT CLinkedList< T >::DelCurrentNode()
{
    return DelNode( GetCurrentIndex() );
}


// Delete a node from our list
template< class T > HRESULT CLinkedList< T >::DelNode( unsigned int uiIndex )
{
    // Make sure our index is valid.  If not, break in to the debugger
    if( uiIndex >= GetNumItems() )
    {
        return E_INVALIDARG;
    };

    struct _LISTNODE* pPrevNode = m_pHead;
    struct _LISTNODE* pSearchNode = m_pHead;

    // If we have a valid index, delete the referenced node
    for( unsigned int x = 0; x < uiIndex; ++x )
    {
        pPrevNode = pSearchNode;
        pSearchNode = pSearchNode->pNext;
    }

    // Deal with the head of the list
    if( pSearchNode == m_pHead )
    {
        // Check to see if it's the last node, and update our
        // our pointers
        if( m_pLast == m_pHead )
            m_pCurrent = m_pLast = m_pHead = NULL;
        else if( m_pCurrent == m_pHead ) // Deal with the 'Current' pointer if we have to
            m_pCurrent = m_pHead = m_pHead->pNext;       // If head is the only node, m_pHead->pNext will be NULL
        else // Only deal with the head node
            m_pHead = m_pHead->pNext;       // If head is the only node, m_pHead->pNext will be NULL

        // Check to see if our current point still points at anything, and if not,
        // make sure we set the Item Index to 0
        if( !m_pCurrent )
            m_uicCurrentItemIndex = 0;

        // Check to see if the new head node points at anything, and if so,
        // make sure the pPrev pointer is NULL
        if( m_pHead )
            m_pHead->pPrev = NULL;
    }
    else if( pSearchNode == m_pLast )   // Delete the last node in our list
    {
        // Check to see if our current node is pointing at the last node, and deal with it
        if( m_pCurrent == m_pLast )
        {
            m_pCurrent = m_pLast = pPrevNode;
            m_pCurrent->pNext = NULL;           // Set our next pointer to NULL
            --m_uicCurrentItemIndex;            // Decrement our current item index since we were pointing at the last node
        }
        else // Only deal with the last node pointer, and don't worry about the current node pointer
            m_pLast = pPrevNode;
    }
    else // Not the head node or the last node ( middle node! )
    {

        // Check to see if our current node is this node, and if so,
        // move it along as well
        if( pSearchNode == m_pCurrent )
        {
            // Set our list to skip over the node we'll delete, and set our current pointer to the same item
            m_pCurrent = pPrevNode->pNext = pSearchNode->pNext;
        }
        else // Don't worry about the current node pointer, simply skip the node we'll delete
        {
            // Set our list to skip over the node we'll delete
            pPrevNode->pNext = pSearchNode->pNext;
        }
    }

    if( m_bDeleteDataItem )
    {
        delete pSearchNode->dataItem;
        pSearchNode->dataItem = NULL;
    }

    // Delete the node
    delete pSearchNode;
    pSearchNode = NULL;

    // Decrement our number of items counter
    --m_uicNumItems;

    return S_OK;
}


// Empty all the items from our list
template< class T > HRESULT CLinkedList< T >::EmptyList( void )
{
    HRESULT hr = S_OK;

    // Call our "DelNode" function until we are out of items
    while( GetNumItems() > 0 )
    {
        if( FAILED( hr = DelNode( 0 ) ) )
        {
            XDBGWRN( LINKEDLIST_APP_TITLE_NAME_A, "CLinkedList::EmptyList():Failed to delete node!!" );
        }
    }

    return hr;
}


// Get a data item from the current node in our list
template< class T > T& CLinkedList< T >::GetCurrentNode() const
{
    if( !m_pCurrent )
    {
        // This will only happen if the current pointer isn't pointing at a node
        // shame on the developer!!
        XDBGWRN( LINKEDLIST_APP_TITLE_NAME_A, "CLinkedList GetCurrentNode():BREAKING IN TO THE DEBUGGER!!" );
        XDBGWRN( LINKEDLIST_APP_TITLE_NAME_A, "CLinkedList GetCurrentNode()No node at the current pointer!!" );

        throw;
    }

    return m_pCurrent->dataItem;
}


// Get a data item from our list by using an index value
template< class T > T& CLinkedList< T >::GetNode( unsigned int uiIndex ) const
{
    // Make sure our index is valid.  If not, return an error
    if( uiIndex >= GetNumItems() )
    {
        XDBGWRN( LINKEDLIST_APP_TITLE_NAME_A, "CLinkedList GetNode():BREAKING IN TO THE DEBUGGER!!" );
        XDBGWRN( LINKEDLIST_APP_TITLE_NAME_A, "CLinkedList GetNode()No node at the specified index!!" );

        throw;
    };

    struct _LISTNODE* pSearchNode = m_pHead;

    // If we have a valid index, find the node in the list
    for( unsigned int x = 0; x < uiIndex; ++x )
    {
        pSearchNode = pSearchNode->pNext;
    }

    // Return the requested node to the user
    return pSearchNode->dataItem;
}


// Move to the specified item in our list via index
template< class T > HRESULT CLinkedList< T >::MoveTo( unsigned int uiIndex )
{
    // Make sure our index is valid.  If not, return an error
    if( uiIndex >= GetNumItems() )
    {
        return E_INVALIDARG;
    };

    struct _LISTNODE* pSearchNode = m_pHead;

    // If we have a valid index, find the node in the list
    for( unsigned int x = 0; x < uiIndex; ++x )
    {
        pSearchNode = pSearchNode->pNext;
    }

    // Set our current pointer to the node we found and update our index
    m_pCurrent = pSearchNode;
    m_uicCurrentItemIndex = uiIndex;

    return S_OK;
}


// Move to the first element in our list
template< class T > BOOL CLinkedList< T >::MoveFirst()
{
    if( GetNumItems() < 0 )
        return FALSE;

    m_pCurrent = m_pHead;
    m_uicCurrentItemIndex = 0;

    return TRUE;
}


// Move to the last element in our list
template< class T > BOOL CLinkedList< T >::MoveLast()
{
    if( GetNumItems() < 0 )
        return FALSE;

    m_pCurrent = m_pLast;
    m_uicCurrentItemIndex = GetNumItems() - 1;

    return TRUE;
}


// Move to the next item in the list
template< class T > BOOL CLinkedList< T >::MoveNext()
{
    if( m_pCurrent->pNext )
    {
        m_pCurrent = m_pCurrent->pNext;
        ++m_uicCurrentItemIndex;

        return TRUE;
    }

    return FALSE;
}


// Move to the prev item in the list
template< class T > BOOL CLinkedList< T >::MovePrev()
{
    if( m_pCurrent->pPrev )
    {
        m_pCurrent = m_pCurrent->pPrev;
        --m_uicCurrentItemIndex;

        return TRUE;
    }

    return FALSE;
}


// Get a data item from our list by using an index value
template< class T > T& CLinkedList< T >::operator[]( unsigned int uiIndex ) const
{
    return GetNode( uiIndex );
}


// Get a the number of items in our list
template< class T > unsigned int CLinkedList< T >::GetNumItems( void ) const
{
    return m_uicNumItems;
}


#endif // _LINKEDLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\inc\xsettings.h ===
/*****************************************************
*** xsettings.h
***
*** Header file for our XSettings class.
*** This is class which will hold the settings
*** that live on the Xbox.
***
*** by James N. Helm
*** December 2nd, 2000
***
*****************************************************/

#ifndef _XSETTINGS_H_
#define _XSETTINGS_H_

#include <xconfig.h>
#include <PerBoxData.h>
#include <ntddscsi.h>
#include <cryptkeys.h>
#include <av.h>
#include <winsockp.h>

struct TZDATE {
    BYTE month;
    BYTE day;
    BYTE dayofweek;
    BYTE hour;
};

#define countof(n) (sizeof (n) / sizeof (n[0]))

struct TZINFO {
    const char* dispname;
    SHORT dltflag;
    SHORT bias;
    SHORT stdbias;
    SHORT dltbias;
    const WCHAR* stdname;
    struct TZDATE stddate;
    const WCHAR* dltname;
    struct TZDATE dltdate;
};

// Display Settings
enum XboxDisplaySettings
{
    XSETTINGS_DISPLAY_SETTING_NONE    = 0,
    XSETTINGS_DISPLAY_SETTING_NTSC_M  = AV_STANDARD_NTSC_M | AV_FLAGS_60Hz,
    XSETTINGS_DISPLAY_SETTING_NTSC_J  = AV_STANDARD_NTSC_J | AV_FLAGS_60Hz,
    XSETTINGS_DISPLAY_SETTING_PAL_I   = AV_STANDARD_PAL_I  | AV_FLAGS_50Hz,
};

// DVD Regions
enum XboxDVDRegions
{
    XSETTINGS_DVD_REGION0 = 0,
    XSETTINGS_DVD_REGION1,
    XSETTINGS_DVD_REGION2,
    XSETTINGS_DVD_REGION3,
    XSETTINGS_DVD_REGION4,
    XSETTINGS_DVD_REGION5,
    XSETTINGS_DVD_REGION6,
};

#define SETTINGS_FACTORY_SERIAL_NUM_SIZE        12
#define SETTINGS_FACTORY_ETHERNET_SIZE          6
#define SETTINGS_FACTORY_RESERVED1_SIZE         2
#define SETTINGS_FACTORY_ONLINEKEY_SIZE         16
#define SETTINGS_USER_TZSTDNAME_SIZE            XC_TZNAMELEN
#define SETTINGS_USER_TZDLTNAME_SIZE            XC_TZNAMELEN
#define SETTINGS_USER_TZSTDDATE_SIZE            sizeof( XBOX_TIMEZONE_DATE )
#define SETTINGS_USER_TZDLTDATE_SIZE            sizeof( XBOX_TIMEZONE_DATE )
#define SETTINGS_USER_RESERVED_SIZE             2
#define SETTINGS_ENC_CHECKSUM_SIZE              20
#define SETTINGS_ENC_CONFOUNDER_SIZE            8
#define SETTINGS_ENC_HDKEY_SIZE                 XBOX_KEY_LENGTH

const UCHAR SETTINGS_EEPROM_DEVKIT_KEY[] = {
    0x7B,
    0x35,
    0xA8,
    0xB7,
    0x27,
    0xED,
    0x43,
    0x7A,
    0xA0,
    0xBA,
    0xFB,
    0x8F,
    0xA4,
    0x38,
    0x61,
    0x80
};


class CXSettings
{
public:
    // Constructors and Destructors
    CXSettings();
    ~CXSettings();

    // Public Methods
    HRESULT Init();                                         // Initialize our object
    HRESULT LoadSettings();                                 // Load / Update the current settings with those from the Config Sector
    BOOL    SettingsHaveChanged();                          // Will compare the latest settings to the previous settings, and determine if they have changed
    HRESULT SetIPAddress( char* IPAddress );                // Set the IP Address on the Xbox
    HRESULT SetIPAddress( WCHAR* IPAddress );               // Set the IP Address on the Xbox
    HRESULT SetDebugIPAddress( char* IPAddress );           // Set the Debug IP Address on the Xbox
    HRESULT SetDebugIPAddress( WCHAR* IPAddress );          // Set the Debug IP Address on the Xbox
	HRESULT SetPrimaryDNS( char* IPAddress );				// Set the Primary DNS Address on the Xbox
	HRESULT SetPrimaryDNS( WCHAR* IPAddress );				// Set the Primary DNS Address on the Xbox
	HRESULT SetSecondaryDNS( char* IPAddress );				// Set the Secondary DNS Address on the Xbox
	HRESULT SetSecondaryDNS( WCHAR* IPAddress );			// Set the Secondary DNS Address on the Xbox
    HRESULT SetSubnetMask( char* SubnetMask );              // Set the SubnetMask on the Xbox
    HRESULT SetSubnetMask( WCHAR* SubnetMask );             // Set the SubnetMask on the Xbox
    HRESULT SetGateway( char* Gateway );                    // Set the Gateway on the Xbox
    HRESULT SetGateway( WCHAR* Gateway );                   // Set the Gateway on the Xbox
    HRESULT SetMachineName( char* MachineName );            // Set the MachineName on the Xbox
    HRESULT SetMachineName( WCHAR* MachineName );           // Set the MachineName on the Xbox
    HRESULT SetAVRegion( DWORD dwAVRegion );                // Set the Xbox AV Region
    HRESULT SetDVDRegion( DWORD dwDVDRegion );              // Set the Xbox DVD Region
    HRESULT SetGameRegion( DWORD dwGameRegion );            // Set the Xbox Game Region     [ENCRYPTED]
    HRESULT SetHDKey( UCHAR* puszHDKeyBuff );               // Set the Xbox HD Key          [ENCRYPTED]
    HRESULT SetLanguage( DWORD dwLanguage );                // Set the language
    HRESULT SetDTS( BOOL bEnable );                         // Enable or Disable DTS
    HRESULT SetDolbyDigital( BOOL bEnable );                // Enable or Disable Dolby Digital
    HRESULT Set1080i( BOOL bEnable );                       // Enable or Disable 1080i
    HRESULT Set720p( BOOL bEnable );                        // Enable or Disable 720p
    HRESULT Set480p( BOOL bEnable );                        // Enable or Disable 480p
    HRESULT SetPAL60( BOOL bEnable );                       // Enable or Disable PAL 60
    HRESULT SetWidescreen( BOOL bEnable );                  // Enable or Disable Widescreen
    HRESULT SetLetterbox( BOOL bEnable );                   // Enable or Disable Letterbox
    HRESULT SetTimeZoneInfo( unsigned int uiIndex );        // Set the Time Zone information

    HRESULT ResetAllToDefaults();							// Reset ALL Xbox Settings to their Initial State values

    DWORD GetNewGlobalChecksum();                           // Get a checksum for ALL of the settings
    DWORD GetNewFactoryChecksum();                          // Get a checksum for the Factory settings
    DWORD GetNewUserChecksum();                             // Get a checksum for the User settings
    DWORD GetNewEncryptedChecksum();                        // Get a checksum for the Encrypted settings

    // Accessors
    DWORD GetAVRegion();                                    // Get the Xbox AV Region
    DWORD GetGameRegion();                                  // Get the Xbox Game Region
    DWORD GetDVDRegion();                                   // Get the Xbox DVD Region
    DWORD GetLanguage();                                    // Get the Xbox Language
    char* GetIPAddress();                                   // Get the Xbox IP address
    char* GetDebugIPAddress();                              // Get the Xbox Debug IP address
	char* GetPrimaryDNS();									// Get the Xbox Primary DNS address
	char* GetSecondaryDNS();								// Get the Xbox Secondary DNS address
    char* GetSubnetMask();                                  // Get the Xbox Subnet mask
    char* GetGateway();                                     // Get the Xbox Default Gateway
    char* GetMachineName();                                 // Get the Xbox Machine Name
    BOOL GetDTS();                                          // Get the state of DTS
    BOOL GetDolbyDigital();                                 // Get the state of Dolby Digital
    BOOL Get1080i();                                        // Get the state of 1080i
    BOOL Get720p();                                         // Get the state of 720p
    BOOL Get480p();                                         // Get the state of 480p
    BOOL GetPAL60();                                        // Get the state of PAL 60
    BOOL GetWidescreen();                                   // Get the state of Widescreen
    BOOL GetLetterbox();                                    // Get the state of Letterbox
    unsigned int GetCurrentTimeZoneIndex();                 // Get the Index of the current timezone in the EEPROM
    TZINFO* GetCurrentTimeZoneInfo();                       // Get the currently set Time Zone information from the EEPROM
    TZINFO* GetTimeZoneInfo( unsigned int uiIndex );        // Get the Xbox Time Zone Information for a specified index
    void GetHDRecoveryKey( OUT UCHAR* pucBuffer,            // Returns the recovery key generated from the current HD Key
                           IN ULONG cbBufferSize );


    // Factory Settings Accessors
    ULONG GetFactoryChecksum();
    void GetFactorySerialNumber( OUT UCHAR* pucBuffer,
                                 IN ULONG cbBufferSize );
    void GetFactoryEthernetAddr( OUT UCHAR* pucBuffer,
                                 IN ULONG cbBufferSize );
    void GetFactoryReserved1( OUT UCHAR* pucBuffer,
                              IN ULONG cbBufferSize );
    void GetFactoryOnlineKey( OUT UCHAR* pucBuffer,
                              IN ULONG cbBufferSize );
    ULONG GetFactoryAVRegion();
    ULONG GetFactoryReserved2();

    // User Settings Accessors
    ULONG GetUserChecksum();
    ULONG GetUserTimeZoneBias();
    void GetUserTimeZoneStdName( OUT WCHAR* pwszBuffer,
                                 IN ULONG cbBufferSize );
    void GetUserTimeZoneDltName( OUT WCHAR* pwszBuffer,
                                 IN ULONG cbBufferSize );
    void GetUserTimeZoneStdDate( OUT XBOX_TIMEZONE_DATE* pTZStdDateBuffer,
                                 IN ULONG cbBufferSize );
    void GetUserTimeZoneDltDate( OUT XBOX_TIMEZONE_DATE* pTZDltDateBuffer,
                                 IN ULONG cbBufferSize );
    void GetUserReserved( OUT ULONG* pulBuffer,
                          IN ULONG cbBufferSize );
    ULONG GetUserTimeZoneStdBias();
    ULONG GetUserTimeZoneDltBias();
    ULONG GetUserLanguage();
    ULONG GetUserVideoFlags();
    ULONG GetUserAudioFlags();
    ULONG GetUserParentalControlGames();
    ULONG GetUserParentalControlPassword();
    ULONG GetUserParentalControlMovies();
    ULONG GetUserOnlineIpAddress();
    ULONG GetUserOnlineDnsAddress();
    ULONG GetUserOnlineDefaultGatewayAddress();
    ULONG GetUserOnlineSubnetMask();
    ULONG GetUserMiscFlags();
    ULONG GetUserDvdRegion();

    // Encrypted Settings Accessors
    void GetEncChecksum( OUT UCHAR* pucBuffer,
                         IN ULONG cbBufferSize );
    void GetEncConfounder( OUT UCHAR* pucBuffer,
                           IN ULONG cbBufferSize );
    void GetEncHDKey( OUT UCHAR* pucBuffer,
                      IN ULONG cbBufferSize );
    ULONG GetEncGameRegion();

private:
    // Private Properties
    EEPROM_LAYOUT               m_AllSettings;          // All EEPROM Settings
    EEPROM_LAYOUT               m_PrevAllSettings;      // All Previous EEPROM Settings
    XNetConfigParams            m_XNetConfigParams;     // All XNet configuration settings

    XBOX_USER_SETTINGS*         m_pUserSettings;        // All Configuration Settings
    XBOX_FACTORY_SETTINGS*      m_pFactorySettings;     // Xbox Factory Settings
    XBOX_ENCRYPTED_SETTINGS*    m_pEncSettings;         // Xbox Encrypted Settings

    char* m_pszIPAddress;                               // The IP Address of the Xbox in string form
    char* m_pszDebugIPAddress;                          // The Debug IP Address of the Xbox in string form
    char* m_pszPrimaryDNS;                              // The Primary DNS address of the Xbox in string form
    char* m_pszSecondaryDNS;                            // The Secondary DNS address of the Xbox in string form
    char* m_pszSubnetMask;                              // The Subnet Mask of the Xbox in string form
    char* m_pszGateway;                                 // The Gateway of the Xbox in string form
    char* m_pszDisplaySetting;                          // The Display Setting in string form
    char* m_pszMachineName;                             // The Machine Name of the Xbox
    BOOL bInitialized;                                  // Ensure we don't initialize twice

    // Private Methods
    
    void TZDateToSysTime(const struct TZDATE* tzdate,   // Convert a timezone date into a system time date
                         SYSTEMTIME* systime);
    BOOL ParseIPAddress( /*[in]*/char* szIPAddr,        // Convert a string IP to a DWORD
                         /*[out]*/DWORD& dwIPAddr );
    char* StringFromIPAddress( DWORD dwIPAddr );        // Returns a string formatted IP Address
	BOOL XboxNameExistsOnNet( char* pszName );          // Returns TRUE if the Xbox Name was found on the network
};
#define XSETTINGS_APP_TITLE_NAME_A              "XSET"
#define XSETTINGS_MACHINE_NAME                  ( XC_MAX_OS + 1 )   // 1 greater than the largest normal value

#define XSETTINGS_IPADDRESS_LENGTH              15
#define XSETTINGS_MACHINENAME_LENGTH            20
#define XSETTINGS_DISPLAYSETTING_TEXT_LENGTH    20

#define _TIMEDISPLAY(x) x

#define XSETTINGS_TIMEZONECOUNT (sizeof(g_timezoneinfo) / sizeof(g_timezoneinfo[0]))

static struct TZINFO g_timezoneinfo[] = {
    {
      _TIMEDISPLAY("GMT-12 Tokelau"),
      0,
      720,
      0,
      0,
      L"IDLW", // L"Dateline Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT-11 Samoa"),
      0,
      660,
      0,
      0,
      L"NT", // L"Samoa Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT-10 Hawaii"),
      0,
      600,
      0,
      0,
      L"HST", // L"Hawaiian Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT-09 Alaska"),
      1,
      540,
      0,
      -60,
      L"YST", // L"Alaskan Standard Time",
      { 10, 5, 0, 2 },
      L"YDT", // L"Alaskan Daylight Time",
      {  4, 1, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT-08 Pacific"),
      1,
      480,
      0,
      -60,
      L"PST", // L"Pacific Standard Time",
      { 10, 5, 0, 2 },
      L"PDT", // L"Pacific Daylight Time",
      {  4, 1, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT-07 Arizona"),
      0,
      420,
      0,
      0,
      L"MST", // L"US Mountain Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT-07 Mountain"),
      1,
      420,
      0,
      -60,
      L"MST", // L"Mountain Standard Time",
      { 10, 5, 0, 2 },
      L"MST", // L"Mountain Daylight Time",
      {  4, 1, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT-06 Central America"),
      0,
      360,
      0,
      0,
      L"CAST", // L"Central America Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT-06 Central"),
      1,
      360,
      0,
      -60,
      L"CST", // L"Central Standard Time",
      { 10, 5, 0, 2 },
      L"CDT", // L"Central Daylight Time",
      {  4, 1, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT-06 Mexico City"),
      1,
      360,
      0,
      -60,
      L"MST", // L"Mexico Standard Time",
      { 10, 5, 0, 2 },
      L"MDT", // L"Mexico Daylight Time",
      {  4, 1, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT-06 Saskatchewan"),
      0,
      360,
      0,
      0,
      L"CCST", // L"Canada Central Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT-05 Eastern"),
      1,
      300,
      0,
      -60,
      L"EST", // L"Eastern Standard Time",
      { 10, 5, 0, 2 },
      L"EDT", // L"Eastern Daylight Time",
      {  4, 1, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT-05 Indiana"),
      0,
      300,
      0,
      0,
      L"EST", // L"US Eastern Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT-05 Bogota"),
      0,
      300,
      0,
      0,
      L"SPST", // L"SA Pacific Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT-04 Atlantic"),
      1,
      240,
      0,
      -60,
      L"AST", // L"Atlantic Standard Time",
      { 10, 5, 0, 2 },
      L"ADT", // L"Atlantic Daylight Time",
      {  4, 1, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT-04 Caracas"),
      0,
      240,
      0,
      0,
      L"SWST", // L"SA Western Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT-04 Santiago"),
      1,
      240,
      0,
      -60,
      L"PSST", // L"Pacific SA Standard Time",
      {  3, 2, 6, 0 },
      L"PSDT", // L"Pacific SA Daylight Time",
      { 10, 2, 6, 0 },
    },

    {
      _TIMEDISPLAY("GMT-03:30 Newfoundland"),
      1,
      210,
      0,
      -60,
      L"NST", // L"Newfoundland Standard Time",
      { 10, 5, 0, 2 },
      L"NDT", // L"Newfoundland Daylight Time",
      {  4, 1, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT-03 Brasilia"),
      1,
      180,
      0,
      -60,
      L"ESST", // L"E. South America Standard Time",
      {  2, 2, 0, 2 },
      L"ESDT", // L"E. South America Daylight Time",
      { 10, 3, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT-03 Buenos Aires"),
      0,
      180,
      0,
      0,
      L"SEST", // L"SA Eastern Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT-03 Greenland"),
      1,
      180,
      0,
      -60,
      L"GST", // L"Greenland Standard Time",
      { 10, 5, 0, 2 },
      L"GDT", // L"Greenland Daylight Time",
      {  4, 1, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT-02 Mid-Atlantic"),
      1,
      120,
      0,
      -60,
      L"MAST", // L"Mid-Atlantic Standard Time",
      {  9, 5, 0, 2 },
      L"MADT", // L"Mid-Atlantic Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT-01 Azores"),
      1,
      60,
      0,
      -60,
      L"AST", // L"Azores Standard Time",
      { 10, 5, 0, 3 },
      L"ADT", // L"Azores Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT-01 Cape Verde Is."),
      0,
      60,
      0,
      0,
      L"WAT", // L"Cape Verde Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+00 Casablanca"),
      0,
      0,
      0,
      0,
      L"GST", // L"Greenwich Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+00 London"),
      1,
      0,
      0,
      -60,
      L"GMT", // L"GMT Standard Time",
      { 10, 5, 0, 2 },
      L"BST", // L"GMT Daylight Time",
      {  3, 5, 0, 1 },
    },

    {
      _TIMEDISPLAY("GMT+01 Berlin"),
      1,
      -60,
      0,
      -60,
      L"WEST", // L"W. Europe Standard Time",
      { 10, 5, 0, 3 },
      L"WEDT", // L"W. Europe Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT+01 Belgrade"),
      1,
      -60,
      0,
      -60,
      L"CEST", // L"Central Europe Standard Time",
      { 10, 5, 0, 3 },
      L"CEDT", // L"Central Europe Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT+01 Paris"),
      1,
      -60,
      0,
      -60,
      L"RST", // L"Romance Standard Time",
      { 10, 5, 0, 3 },
      L"RDT", // L"Romance Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT+01 Sarajevo"),
      1,
      -60,
      0,
      -60,
      L"SCST", // L"Central European Standard Time",
      { 10, 5, 0, 3 },
      L"SCDT", // L"Central European Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT+01 W. Central Africa"),
      0,
      -60,
      0,
      0,
      L"WAST", // L"W. Central Africa Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+02 Athens"),
      1,
      -120,
      0,
      -60,
      L"GTST", // L"GTB Standard Time",
      { 10, 5, 0, 3 },
      L"GTDT", // L"GTB Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT+02 Bucharest"),
      1,
      -120,
      0,
      -60,
      L"EEST", // L"E. Europe Standard Time",
      {  9, 5, 0, 1 },
      L"EEDT", // L"E. Europe Daylight Time",
      {  3, 5, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+02 Cairo"),
      1,
      -120,
      0,
      -60,
      L"EST", // L"Egypt Standard Time",
      {  9, 5, 3, 2 },
      L"EDT", // L"Egypt Daylight Time",
      {  5, 1, 5, 2 },
    },

    {
      _TIMEDISPLAY("GMT+02 Pretoria"),
      0,
      -120,
      0,
      0,
      L"SAST", // L"South Africa Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+02 Helsinki"),
      1,
      -120,
      0,
      -60,
      L"FLST", // L"FLE Standard Time",
      { 10, 5, 0, 4 },
      L"FLDT", // L"FLE Daylight Time",
      {  3, 5, 0, 3 },
    },

    {
      _TIMEDISPLAY("GMT+02 Jerusalem"),
      0,
      -120,
      0,
      0,
      L"JST", // L"Jerusalem Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+03 Baghdad"),
      1,
      -180,
      0,
      -60,
      L"AST", // L"Arabic Standard Time",
      { 10, 1, 0, 4 },
      L"ADT", // L"Arabic Daylight Time",
      {  4, 1, 0, 3 },
    },

    {
      _TIMEDISPLAY("GMT+03 Kuwait"),
      0,
      -180,
      0,
      0,
      L"AST", // L"Arab Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+03 Moscow"),
      1,
      -180,
      0,
      -60,
      L"RST", // L"Russian Standard Time",
      { 10, 5, 0, 3 },
      L"RDT", // L"Russian Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT+03 Nairobi"),
      0,
      -180,
      0,
      0,
      L"EAST", // L"E. Africa Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+03:30 Tehran"),
      1,
      -210,
      0,
      -60,
      L"IST", // L"Iran Standard Time",
      {  9, 4, 2, 2 },
      L"IDT", // L"Iran Daylight Time",
      {  3, 1, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT+04 Abu Dhabi"),
      0,
      -240,
      0,
      0,
      L"AST", // L"Arabian Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+04 Baku"),
      1,
      -240,
      0,
      -60,
      L"CST", // L"Caucasus Standard Time",
      { 10, 5, 0, 3 },
      L"CDT", // L"Caucasus Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT+04:30 Kabul"),
      0,
      -270,
      0,
      0,
      L"AST", // L"Afghanistan Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+05 Ekaterinburg"),
      1,
      -300,
      0,
      -60,
      L"EST", // L"Ekaterinburg Standard Time",
      { 10, 5, 0, 3 },
      L"EDT", // L"Ekaterinburg Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT+05 Islamabad"),
      0,
      -300,
      0,
      0,
      L"WAST", // L"West Asia Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+05:30 New Delhi"),
      0,
      -330,
      0,
      0,
      L"IST", // L"India Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+05:45 Kathmandu"),
      0,
      -345,
      0,
      0,
      L"NST", // L"Nepal Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+06 Almaty"),
      1,
      -360,
      0,
      -60,
      L"NCST", // L"N. Central Asia Standard Time",
      { 10, 5, 0, 3 },
      L"NCDT", // L"N. Central Asia Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT+06 Dhaka"),
      0,
      -360,
      0,
      0,
      L"CAST", // L"Central Asia Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+06 Sri Lanka"),
      0,
      -360,
      0,
      0,
      L"SRST", // L"Sri Lanka Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+06:30 Yangon"),
      0,
      -390,
      0,
      0,
      L"MST", // L"Myanmar Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+07 Bangkok"),
      0,
      -420,
      0,
      0,
      L"SAST", // L"SE Asia Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+07 Krasnoyarsk"),
      1,
      -420,
      0,
      -60,
      L"NAST", // L"North Asia Standard Time",
      { 10, 5, 0, 3 },
      L"NADT", // L"North Asia Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT+08 Beijing"),
      0,
      -480,
      0,
      0,
      L"CST", // L"China Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+08 Irkutsk"),
      1,
      -480,
      0,
      -60,
      L"NEST", // L"North Asia East Standard Time",
      { 10, 5, 0, 3 },
      L"NEDT", // L"North Asia East Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT+08 Singapore"),
      0,
      -480,
      0,
      0,
      L"MPST", // L"Malay Peninsula Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+08 Perth"),
      0,
      -480,
      0,
      0,
      L"AWST", // L"W. Australia Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+08 Taipei"),
      0,
      -480,
      0,
      0,
      L"TST", // L"Taipei Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+09 Tokyo"),
      0,
      -540,
      0,
      0,
      L"TST", // L"Tokyo Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+09 Seoul"),
      0,
      -540,
      0,
      0,
      L"KST", // L"Korea Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+09 Yakutsk"),
      1,
      -540,
      0,
      -60,
      L"YST", // L"Yakutsk Standard Time",
      { 10, 5, 0, 3 },
      L"YDT", // L"Yakutsk Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT+09:30 Adelaide"),
      1,
      -570,
      0,
      -60,
      L"ACST", // L"Cen. Australia Standard Time",
      {  3, 5, 0, 2 },
      L"ACDT", // L"Cen. Australia Daylight Time",
      { 10, 5, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT+09:30 Darwin"),
      0,
      -570,
      0,
      0,
      L"ACST", // L"AUS Central Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+10 Brisbane"),
      0,
      -600,
      0,
      0,
      L"AEST", // L"E. Australia Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+10 Sydney"),
      1,
      -600,
      0,
      -60,
      L"AEST", // L"AUS Eastern Standard Time",
      {  3, 5, 0, 2 },
      L"AEDT", // L"AUS Eastern Daylight Time",
      { 10, 5, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT+10 Guam"),
      0,
      -600,
      0,
      0,
      L"WPST", // L"West Pacific Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+10 Hobart"),
      1,
      -600,
      0,
      -60,
      L"TST", // L"Tasmania Standard Time",
      {  3, 5, 0, 2 },
      L"TDT", // L"Tasmania Daylight Time",
      { 10, 1, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT+10 Vladivostok"),
      1,
      -600,
      0,
      -60,
      L"VST", // L"Vladivostok Standard Time",
      { 10, 5, 0, 3 },
      L"VDT", // L"Vladivostok Daylight Time",
      {  3, 5, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT+11 Solomon Islands"),
      0,
      -660,
      0,
      0,
      L"CPST", // L"Central Pacific Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+12 Auckland"),
      1,
      -720,
      0,
      -60,
      L"NZST", // L"New Zealand Standard Time",
      {  3, 3, 0, 2 },
      L"NZDT", // L"New Zealand Daylight Time",
      { 10, 1, 0, 2 },
    },

    {
      _TIMEDISPLAY("GMT+12 Fiji Islands"),
      0,
      -720,
      0,
      0,
      L"FST", // L"Fiji Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+13 Nuku'alofa"),
      0,
      -780,
      0,
      0,
      L"TST", // L"Tonga Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },

    {
      _TIMEDISPLAY("GMT+14 Kiribati"),
      0,
      -840,
      0,
      0,
      L"KST", // L"Kiribati Standard Time",
      {  0, 0, 0, 0 },
      NULL,
      {  0, 0, 0, 0 },
    },
};



#endif // _XSETTINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\memoryareas\memarpch.h ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    memarpch.h

Abstract:

    precompiled header for usb manager library.

--*/

#ifndef _MEMARPCH_H_
#define _MEMARPCH_H_

#define MEMAREA_APP_TITLE_NAME_A    "MEMA"

#include <ntos.h>
#include <xapip.h>
#include <xtl.h>
#include <xboxp.h>
#include <xdbg.h>
#include <stdio.h>

#endif // _MEMARPCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\memoryareas\gametitles.cpp ===
/*****************************************************
*** gametitles.cpp
***
*** CPP file for our game title classes.  These
*** classes will enumerate and store information
*** about all of the Game Titles, and their Saved
*** games on the Xbox
***
*** by James N. Helm
*** June 16th, 2001
***
*****************************************************/

#include "memarpch.h"
#include "memoryarea.h"
#include "gametitles.h"

////////////////
////////////////
// Saved Game //
////////////////
////////////////

// Constructor
CSavedGame::CSavedGame()
: m_pwszName( NULL ),
m_dwBlockSize( 0 ),
m_pszGameID( NULL ),
m_pszGameDirectory( NULL )
{
    ZeroMemory( &m_GameDate, sizeof( m_GameDate ) );
}

// Destructor
CSavedGame::~CSavedGame()
{
    if( NULL != m_pwszName )
    {
        delete[] m_pwszName;
        m_pwszName = NULL;
    }

    if( NULL != m_pszGameID )
    {
        delete[] m_pszGameID;
        m_pszGameID = NULL;
    }

    if( NULL != m_pszGameDirectory )
    {
        delete[] m_pszGameDirectory;
        m_pszGameDirectory = NULL;
    }
}


// Initialize the Saved Game object and populate it's data
HRESULT CSavedGame::Init( XGAME_FIND_DATA* pGameData )
{
    if( NULL == pGameData )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CSavedGame::Init():Invalid parameter passed in!!" );

        return E_INVALIDARG;
    }

    //
    // Store the base Game Information
    //

    //
    // Handle the Saved Game name
    //
    if( NULL != m_pwszName )
    {
        delete[] m_pwszName;
        m_pwszName = NULL;
    }

    m_pwszName = new WCHAR[wcslen(pGameData->szSaveGameName)+1];
    if( NULL == m_pwszName )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CSavedGame::Init():Failed to allocate memory!!" );

        return E_OUTOFMEMORY;
    }

    wcscpy( m_pwszName, pGameData->szSaveGameName );

    //
    // Handle the Saved Game Directory
    //
    if( NULL != m_pszGameDirectory )
    {
        delete[] m_pszGameDirectory;
        m_pszGameDirectory = NULL;
    }

    m_pszGameDirectory = new char[strlen(pGameData->szSaveGameDirectory)+1];
    if( NULL == m_pszGameDirectory )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CSavedGame::Init():Failed to allocate memory!!" );

        return E_OUTOFMEMORY;
    }

    strcpy( m_pszGameDirectory, pGameData->szSaveGameDirectory );

    //
    // Handle the Date/Time information
    //
    HRESULT hr = S_OK;
    if( !FileTimeToSystemTime( &pGameData->wfd.ftLastWriteTime, &m_GameDate ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CSavedGame::Init():Failed to convert FileTimeToSystemTime!! Error - '0x%.8X (%d)'", GetLastError(), GetLastError() );

        hr = E_FAIL;
    }

    // Get the Game ID by parsing the Game Directory
    if( NULL != m_pszGameID )
    {
        delete[] m_pszGameID;
        m_pszGameID = NULL;
    }

    char* pszIDPointer = strrchr( m_pszGameDirectory, '\\' );
    if( NULL == pszIDPointer )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CSavedGame::Init():Failed to Get the Title ID!!" );

        return E_FAIL;
    }

    pszIDPointer++;
    m_pszGameID = new char[strlen( pszIDPointer )+1];
    if( NULL == m_pszGameID )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CSavedGame::Init():Failed to Allocate memory!!" );

        return E_OUTOFMEMORY;
    }

    strcpy( m_pszGameID, pszIDPointer );

    // TODO: Get the Game Block Size by navigating the directory and totaling the size of all files

    return hr;
}


// Get a pointer to the name of the saved game
WCHAR* CSavedGame::GetName()
{
    if( NULL == m_pwszName )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CSavedGame::GetName():Returning a NULL pointer!!" );
    }

    return m_pwszName;
}


// Get a pointer to the Saved Game directory
char* CSavedGame::GetDirectory()
{
    if( NULL == m_pszGameDirectory )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CSavedGame::GetDirectory():Returning a NULL pointer!!" );
    }

    return m_pszGameDirectory;
}


// Returns the Block size of the Saved Game
DWORD CSavedGame::GetBlockSize()
{
    return m_dwBlockSize;
}


// Get a pointer to the Game ID of the Saved Game
char* CSavedGame::GetGameID()
{
    if( NULL == m_pszGameID )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CSavedGame::GetGameID():Returning a NULL pointer!!" );
    }

    return m_pszGameID;
}


////////////////
////////////////
// Game Title //
////////////////
////////////////

// Constructor
CGameTitle::CGameTitle()
: m_pwszName( NULL ),
m_dwBlockSize( 0 ),
m_pszTitleID( NULL ),
m_pszDirectory( NULL )
{
    // Make sure if we empty our list we clean up properly
    m_SavedGameList.SetDeleteDataItem( TRUE );
}


// Destructor
CGameTitle::~CGameTitle()
{
    if( NULL != m_pszTitleID )
    {
        delete[] m_pszTitleID;
        m_pszTitleID = NULL;
    }

    if( NULL != m_pszDirectory )
    {
        delete[] m_pszDirectory;
        m_pszDirectory = NULL;
    }

    if( NULL != m_pwszName )
    {
        delete[] m_pwszName;
        m_pwszName = NULL;
    }
}


// Initialize our Game Title
HRESULT CGameTitle::Init( char* pszDirectory, CMemoryArea* pMemoryArea )
{
    if( NULL == pszDirectory )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CGameTitle::Init():Invalid argument passed in!!" );

        return E_INVALIDARG;
    }

    //
    // Handle the directory
    //
    if( NULL != m_pszDirectory )
    {
        delete[] m_pszDirectory;
        m_pszDirectory = NULL;
    }

    m_pszDirectory = new char[strlen( pszDirectory )+1];
    if( NULL == m_pszDirectory )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CGameTitle::Init():Failed to allocate memory!!" );

        return E_OUTOFMEMORY;
    }

    strcpy( m_pszDirectory, pszDirectory );

    //
    // Handle the Title ID
    //
    if( NULL != m_pszTitleID )
    {
        delete[] m_pszTitleID;
        m_pszTitleID = NULL;
    }

    char* pszIDPointer = strrchr( m_pszDirectory, '\\' );
    if( NULL == pszIDPointer )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CGameTitle::Init():Failed to Get the Title ID!!" );

        return E_FAIL;
    }

    pszIDPointer++;
    m_pszTitleID = new char[strlen( pszIDPointer )+1];
    if( NULL == m_pszTitleID )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CGameTitle::Init():Failed to Allocate memory!!" );

        return E_OUTOFMEMORY;
    }

    strcpy( m_pszTitleID, pszIDPointer );

    //
    // Handle the Saved Games
    //
    HRESULT hr = ProcessSavedGames( m_pszTitleID, pMemoryArea );
    if( FAILED( hr ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CGameTitle::Init():Failed to ProcessSavedGames!! Error - '0x%.8X (%d)'", hr, hr );
    }

    // Get the Game Name
    if( NULL != m_pwszName )
    {
        delete[] m_pwszName;
        m_pwszName = NULL;
    }

    char pszFileName[MAX_PATH+1];
    ZeroMemory( pszFileName, MAX_PATH+1 );

    _snprintf( pszFileName, MAX_PATH, "%s\\%s", m_pszDirectory, GAME_TITLE_XBX_FILENAME );

    FILE* pfTitleMeta = fopen( pszFileName, "rb" );
    if( NULL == pfTitleMeta )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CGameTitle::Init():Failed to open the Game Name file!! File - '%hs', Error - '0x%.8X (%d)'", pszFileName, GetLastError(), GetLastError() );

        return E_FAIL;
    }

    WCHAR pwszBuffer[MAX_PATH+1];
    ZeroMemory( pwszBuffer, sizeof( WCHAR ) * ( MAX_PATH+1 ) );

    while( fgetws( pwszBuffer, MAX_PATH, pfTitleMeta ) )
    {
        WCHAR* pwszStringLoc = wcsstr( pwszBuffer, GAME_TITLE_NAME_TOKEN_W );
        if( NULL != pwszStringLoc )
        {
            // Adjust our pointer to skip the token
            pwszStringLoc = pwszStringLoc + wcslen( GAME_TITLE_NAME_TOKEN_W );

            // Allocate memory for our buffer
            m_pwszName = new WCHAR[wcslen( pwszStringLoc ) - 1];    // We don't need to allocate space for the null, since this string has a CR at the end, we'll use that
            if( NULL == m_pwszName )
            {
                XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CGameTitle::Init():Failed to Allocate memory!!" );

                hr = E_FAIL;

                break;
            }
            else
            {
                m_pwszName[wcslen( pwszStringLoc ) - 2] = L'\0';
                wcsncpy( m_pwszName, pwszStringLoc, wcslen( pwszStringLoc ) - 2 );

                break;
            }
        }
    }

    XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CGameTitle::Init():Game Name - '%ls'", m_pwszName );

    fclose( pfTitleMeta );
    pfTitleMeta = NULL;

    // TODO: Get the Game Block Size

    return hr;
}


// Returns the number of saved games for the game title
DWORD CGameTitle::GetNumSavedGames()
{
    return m_SavedGameList.GetNumItems();
}


// Get the total block size of the Game Title
DWORD CGameTitle::GetBlockSize()
{
    return m_dwBlockSize;
}


// Get a pointer to the name of the Game Title
WCHAR* CGameTitle::GetName()
{
    if( NULL == m_pwszName )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CGameTitle::GetName():Returning a NULL pointer!!" );
    }

    return m_pwszName;
}


// Get a pointer to the directory of the Game Title
char* CGameTitle::GetDirectory()
{
    if( NULL == m_pszDirectory )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CGameTitle::GetDirectory():Returning a NULL pointer!!" );
    }

    return m_pszDirectory;
}


// Get a pointer to the title ID of the Game Title
char* CGameTitle::GetTitleID()
{
    if( NULL == m_pszTitleID )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CGameTitle::GetTitleID():Returning a NULL pointer!!" );
    }

    return m_pszTitleID;
}


// Get the name of a Saved Game
WCHAR* CGameTitle::GetSavedGameName( unsigned int uiIndex )
{
    if( uiIndex >= m_SavedGameList.GetNumItems() )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CGameTitle::GetSavedGameName():Invalid Index passed in! Arg - '%u', MAX - '%u'", uiIndex, m_SavedGameList.GetNumItems() - 1 );

        return NULL;
    }

    return m_SavedGameList.GetNode( uiIndex )->GetName();
}


// Get the ID of a Saved Game
char* CGameTitle::GetSavedGameID( unsigned int uiIndex )
{
    if( uiIndex >= m_SavedGameList.GetNumItems() )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CGameTitle::GetSavedGameID():Invalid Index passed in! Arg - '%u', MAX - '%u'", uiIndex, m_SavedGameList.GetNumItems() - 1 );

        return NULL;
    }

    return m_SavedGameList.GetNode( uiIndex )->GetGameID();
}


// Get the block size of a Saved Game
DWORD CGameTitle::GetSavedGameBlockSize( unsigned int uiIndex )
{
    if( uiIndex >= m_SavedGameList.GetNumItems() )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CGameTitle::GetSavedGameBlockSize():Invalid Index passed in! Arg - '%u', MAX - '%u'", uiIndex, m_SavedGameList.GetNumItems() - 1 );

        return NULL;
    }

    return m_SavedGameList.GetNode( uiIndex )->GetBlockSize();
}


// Process the Saved Games for the specified Game Title
HRESULT CGameTitle::ProcessSavedGames( char* pszTitleID, CMemoryArea* pMemoryArea )
{
    if( NULL == pszTitleID )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CGameTitle::ProcessSavedGames():Invalid Argument Passed In!!" );

        return E_INVALIDARG;
    }

    m_SavedGameList.EmptyList();

    // Map the proper UData Drive
    pMemoryArea->MapUDataToTitleID( pszTitleID );

    char pszGameDrive[4];
    pszGameDrive[3] = '\0';

    sprintf( pszGameDrive, "%c:\\", pMemoryArea->GetUDataDrive() );

    // Use FindFirst / Next Saved Game to fill our Saved Game Data
    XGAME_FIND_DATA gameFindData;
    ZeroMemory( &gameFindData, sizeof( gameFindData ) );

    HANDLE hGame = XFindFirstSaveGame( pszGameDrive,
                                       &gameFindData );
    if( INVALID_HANDLE_VALUE == hGame )
    {
        if( ERROR_FILE_NOT_FOUND == GetLastError() )
        {
            // There are no Saved Games, so this is OK
            return S_OK;
        }

        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CGameTitle::ProcessSavedGames():Failed to find a Saved Game!! Error - '0x%.8X (%d)'", GetLastError(), GetLastError() );

        return E_FAIL;
    }

    do
    {
        CSavedGame* pSavedGame = new CSavedGame;
        if( NULL == pSavedGame )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CGameTitle::ProcessSavedGames():Failed to allocate memory!!" );

            // Try the next one, but it will fail as well
            continue;
        }

        pSavedGame->Init( &gameFindData );

        m_SavedGameList.AddNode( pSavedGame );
    } while( XFindNextSaveGame( hGame, &gameFindData ) );

    XFindClose( hGame );

    // Remap the U Drive to the proper location
    pMemoryArea->MapUDataToOrigLoc();

    return S_OK;
}


////////////////
////////////////
// Xbox Games //
////////////////
////////////////

// Constructors
CXboxGames::CXboxGames()
{
    // Make sure we clean up after ourselves
    m_GameList.SetDeleteDataItem( TRUE );
}


// Destructor
CXboxGames::~CXboxGames()
{
}


// Initialize the list starting at the specified directory
HRESULT CXboxGames::Init( char* pszDirectory, CMemoryArea* pMemoryArea )
{
    if( NULL == pszDirectory )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CXboxGames::Init():Invalid arg passed in!!" );

        return E_INVALIDARG;
    }

    // Make sure our Game list is empty
    m_GameList.EmptyList();

    char pszBuf[MAX_PATH+1];
    ZeroMemory( pszBuf, MAX_PATH+1 );

    // BUGBUG: What if there is a trailing slash?
    _snprintf( pszBuf, MAX_PATH, "%hs\\*.*", pszDirectory );

    char* apszDirectories[4096];
    for( unsigned int x = 0; x < 4096; x++ )
    {
        apszDirectories[x] = NULL;
    }

    unsigned int uiNumDirs = 0;
    WIN32_FIND_DATA wfd;
    ZeroMemory( &wfd, sizeof( wfd ) );

    HANDLE hFile = FindFirstFile( pszBuf, &wfd );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CXboxGames::Init():Failed to find first file!! Pattern - '%hs', Error - '0x%.8X (%d)'", pszBuf, GetLastError(), GetLastError() );

        // BUGBUG: This might not be a failure.  There could be no titles!
        return E_FAIL;
    }

    do
    {
        // Skip the . and .. directories
        if ( wfd.cFileName[0] == '.' )
        {
            continue;
        }

        ZeroMemory( pszBuf, MAX_PATH+1 );
        _snprintf( pszBuf, MAX_PATH, "%s\\%s", pszDirectory, wfd.cFileName );

        // Check to see if we are dealing with a directory
        if( wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            apszDirectories[uiNumDirs] = new char[strlen( pszBuf ) + 1];
            if( NULL == apszDirectories[uiNumDirs] )
            {
                XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CXboxGames::Init():Failed to allocate memory!!" );

                continue;
            }

            strcpy( apszDirectories[uiNumDirs], pszBuf );

            uiNumDirs++;
        }
    } while( FindNextFile( hFile, &wfd ) );

    FindClose( hFile );

    // Process the directories we found
    for( unsigned int x = 0; x < uiNumDirs; x++ )
    {
        // Create a Game Title Object
        CGameTitle* pGameTitle = new CGameTitle;
        if( NULL == pGameTitle )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CXboxGames::Init():Failed to allocate memory!!" );

            // We'll try, but the next one will fail too
            continue;
        }
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CXboxGames::Init():apszDirectories[x] - '%hs'", apszDirectories[x] );
        pGameTitle->Init( apszDirectories[x], pMemoryArea );

        m_GameList.AddNode( pGameTitle );

        // Clean up any memory we allocated
        delete[] apszDirectories[x];
        apszDirectories[x] = NULL;
    }

    return S_OK;
}


// Get a pointer to a game at the specified index
CGameTitle* CXboxGames::GetGame( unsigned int uiIndex )
{
    if( uiIndex >= m_GameList.GetNumItems() )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CXboxGames::GetGame():Invalid Index passed in! Arg - '%u', MAX - '%u'", uiIndex, m_GameList.GetNumItems() - 1 );

        return NULL;
    }

    return m_GameList.GetNode( uiIndex );
}


// Returns the number of Games on the Xbox
DWORD CXboxGames::GetNumGames()
{
    return m_GameList.GetNumItems();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\memoryareas\harddrive.cpp ===
/*****************************************************
*** harddrive.cpp
***
*** CPP file for our Hard Drive class.
*** This class will contain functions and information
*** pertaining to the Xbox Hard Drive
***
*** by James N. Helm
*** April 2nd, 2001
***
*****************************************************/

#include "memarpch.h"
#include "harddrive.h"

// Contructors
CHardDrive::CHardDrive()
: CMemoryArea()
{
    SetTDataDrive( HARDDRIVE_TDATA_DRIVE_LETTER_A );
    SetUDataDrive( HARDDRIVE_UDATA_DRIVE_LETTER_A );

    MapDrive( GetTDataDrive(), HARDDRIVE_TDATA_PATH_A );
    MapDrive( GetUDataDrive(), HARDDRIVE_UDATA_PATH_A );

    SetDefaultName( HARDDRIVE_NAME_PATTERN );
}


// Destructor
CHardDrive::~CHardDrive()
{
    UnMapDrive( GetTDataDrive() );
    UnMapDrive( GetUDataDrive() );
}


// Map the TDATA drive to it's orignal location
HRESULT CHardDrive::MapTDataToOrigLoc()
{
    UnMapDrive( GetTDataDrive() );
    MapDrive( GetTDataDrive(), HARDDRIVE_TDATA_PATH_A );

    return S_OK;
}


// Map the TDATA drive letter to the specified Title ID
HRESULT CHardDrive::MapTDataToTitleID( char* pszTitleID )
{
    if( NULL == pszTitleID )
    {
        return E_INVALIDARG;
    }

    // Make sure the Title Directory has been created
    char pszBuffer[MAX_PATH+1];
    ZeroMemory( pszBuffer, MAX_PATH+1 );
    _snprintf( pszBuffer, MAX_PATH, "%c:\\%hs", GetTDataDrive(), pszTitleID );

    // We don't care if this fails
    CreateDirectory( pszBuffer, NULL );

    ZeroMemory( pszBuffer, MAX_PATH+1 );
    _snprintf( pszBuffer, MAX_PATH, "%hs\\%hs", HARDDRIVE_TDATA_PATH_A, pszTitleID );

    // Map the TDATA Drive to the new Title ID Directory
    UnMapDrive( 'T' );

    HRESULT hr = S_OK;
    if( !NT_SUCCESS( MapDrive( 'T', pszBuffer ) ) )
    {
        hr = E_FAIL;
    }

    return hr;
}


// Map the TDATA drive letter to the specified Title ID
HRESULT CHardDrive::MapTDataToTitleID( WCHAR* pwszTitleID )
{
    if( NULL == pwszTitleID )
    {
        return E_INVALIDARG;
    }

    // Make sure the Title Directory has been created
    char pszBuffer[MAX_PATH+1];
    ZeroMemory( pszBuffer, MAX_PATH+1 );
    _snprintf( pszBuffer, MAX_PATH, "%c:\\%ls", GetTDataDrive(), pwszTitleID );

    // We don't care if this fails
    CreateDirectory( pszBuffer, NULL );

    ZeroMemory( pszBuffer, MAX_PATH+1 );
    _snprintf( pszBuffer, MAX_PATH, "%hs\\%ls", HARDDRIVE_TDATA_PATH_A, pwszTitleID );

    // Map the TDATA Drive to the new Title ID Directory
    UnMapDrive( 'T' );

    HRESULT hr = S_OK;
    if( !NT_SUCCESS( MapDrive( 'T', pszBuffer ) ) )
    {
        hr = E_FAIL;
    }

    return hr;
}


// Map the TDATA drive letter to the specified Title ID
HRESULT CHardDrive::MapTDataToTitleID( DWORD dwTitleID )
{
    // Make sure the Title Directory has been created
    char pszBuffer[MAX_PATH+1];
    ZeroMemory( pszBuffer, MAX_PATH+1 );
    _snprintf( pszBuffer, MAX_PATH, "%c:\\%.8X", GetTDataDrive(), dwTitleID );

    // We don't care if this fails
    CreateDirectory( pszBuffer, NULL );

    ZeroMemory( pszBuffer, MAX_PATH+1 );
    _snprintf( pszBuffer, MAX_PATH, "%hs\\%.8X", HARDDRIVE_TDATA_PATH_A, dwTitleID );

    // Map the TDATA Drive to the new Title ID Directory
    UnMapDrive( 'T' );

    HRESULT hr = S_OK;
    if( !NT_SUCCESS( MapDrive( 'T', pszBuffer ) ) )
    {
        hr = E_FAIL;
    }

    return hr;
}


// Map the UDATA drive letter to the specified Title ID
HRESULT CHardDrive::MapUDataToTitleID( char* pszTitleID )
{
    if( NULL == pszTitleID )
    {
        return E_INVALIDARG;
    }

    // Make sure the Title Directory has been created
    char pszBuffer[MAX_PATH+1];
    ZeroMemory( pszBuffer, MAX_PATH+1 );
    _snprintf( pszBuffer, MAX_PATH, "%c:\\%hs", GetUDataDrive(), pszTitleID );

    // We don't care if this fails
    CreateDirectory( pszBuffer, NULL );

    ZeroMemory( pszBuffer, MAX_PATH+1 );
    _snprintf( pszBuffer, MAX_PATH, "%hs\\%hs", HARDDRIVE_UDATA_PATH_A, pszTitleID );

    // Map the UDATA Drive to the new Title ID Directory
    UnMapDrive( 'U' );

    HRESULT hr = S_OK;
    if( !NT_SUCCESS( MapDrive( 'U', pszBuffer ) ) )
    {
        hr = E_FAIL;
    }

    return hr;
}


// Map the UDATA drive letter to the specified Title ID
HRESULT CHardDrive::MapUDataToTitleID( WCHAR* pwszTitleID )
{
    if( NULL == pwszTitleID )
    {
        return E_INVALIDARG;
    }

    // Make sure the Title Directory has been created
    char pszBuffer[MAX_PATH+1];
    ZeroMemory( pszBuffer, MAX_PATH+1 );
    _snprintf( pszBuffer, MAX_PATH, "%c:\\%ls", GetUDataDrive(), pwszTitleID );

    // We don't care if this fails
    CreateDirectory( pszBuffer, NULL );

    ZeroMemory( pszBuffer, MAX_PATH+1 );
    _snprintf( pszBuffer, MAX_PATH, "%hs\\%ls", HARDDRIVE_UDATA_PATH_A, pwszTitleID );

    // Map the UDATA Drive to the new Title ID Directory
    UnMapDrive( 'U' );

    HRESULT hr = S_OK;
    if( !NT_SUCCESS( MapDrive( 'U', pszBuffer ) ) )
    {
        hr = E_FAIL;
    }

    return hr;
}


// Create a Saved Game
HRESULT CHardDrive::CreateSavedGame( IN WCHAR* pwszSavedGameName,
                                     OUT char* pszGamePath,
                                     IN unsigned int cbBuffSize,
                                     IN SYSTEMTIME* pSysTimeGameDate,
                                     IN char* pszSaveImage,
                                     IN BOOL bNoCopyGame )
{
    char cDrive = GetUDataDrive();
    SetUDataDrive( 'U' );
    HRESULT hr = CMemoryArea::CreateSavedGame( pwszSavedGameName,
                                               pszGamePath,
                                               cbBuffSize,
                                               pSysTimeGameDate,
                                               pszSaveImage,
                                               bNoCopyGame );
    SetUDataDrive( cDrive );

    return hr;
}


// Map the UDATA drive to it's orignal location
HRESULT CHardDrive::MapUDataToOrigLoc()
{
    UnMapDrive( GetUDataDrive() );
    MapDrive( GetUDataDrive(), HARDDRIVE_UDATA_PATH_A );

    return S_OK;
}


// Map the UDATA drive letter to the specified Title ID
HRESULT CHardDrive::MapUDataToTitleID( DWORD dwTitleID )
{
    // Make sure the Title Directory has been created
    char pszBuffer[MAX_PATH+1];
    ZeroMemory( pszBuffer, MAX_PATH+1 );
    _snprintf( pszBuffer, MAX_PATH, "%c:\\%.8X", GetUDataDrive(), dwTitleID );

    // We don't care if this fails
    CreateDirectory( pszBuffer, NULL );

    ZeroMemory( pszBuffer, MAX_PATH+1 );
    _snprintf( pszBuffer, MAX_PATH, "%hs\\%.8X", HARDDRIVE_UDATA_PATH_A, dwTitleID );

    // Map the UDATA Drive to the new Title ID Directory
    UnMapDrive( 'U' );

    HRESULT hr = S_OK;
    if( !NT_SUCCESS( MapDrive( 'U', pszBuffer ) ) )
    {
        hr = E_FAIL;
    }

    return hr;
}


// Remove all of the Soundtracks that live on the hard drive
HRESULT CHardDrive::RemoveAllSoundtracks()
{
    HRESULT hr = S_OK;

    BOOL bReturn = DashBeginUsingSoundtracks();
    if( !bReturn )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CHardDrive::RemoveAllSoundtracks():Failed to open the ST DB!! Error - '0x%.8X'", GetLastError() );

        return E_FAIL;
    }

    // Get the number of soundtracks from the DB
    DWORD dwNumSTs = DashGetSoundtrackCount();
    XDBGTRC( MEMAREA_APP_TITLE_NAME_A, "CHardDrive::RemoveAllSoundtracks():Number of Soundtracks - '%d'", dwNumSTs );

    // Check to see if there are any soundtracks, if not, clean up and leave
    if( 0 == dwNumSTs )
    {
        DashEndUsingSoundtracks();

        return hr;
    }

    // Create an array of ST IDs so we can delete them
    DWORD* pdwSTIDs = new DWORD[dwNumSTs];
    if( !pdwSTIDs )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CHardDrive::RemoveAllSoundtracks():Failed to allocate memory for our ST IDs!!" );
    }

    // Must call this before we use the XFindFirst and XFindNext Soundtrack functions
    DashEndUsingSoundtracks();

    unsigned int uiCounter = 0; // Used to track the current index of our ST IDs
    XSOUNDTRACK_DATA stData;
    ZeroMemory( &stData, sizeof( XSOUNDTRACK_DATA ) );

    HANDLE hSTHandle = XFindFirstSoundtrack( &stData );
    if( INVALID_HANDLE_VALUE != hSTHandle )
    {
        // Enumerate through the soundtracks and store the ID info
        pdwSTIDs[uiCounter++] = stData.uSoundtrackId;

        // Find the rest of the soundtracks
        while( XFindNextSoundtrack( hSTHandle, &stData ) )
        {
            pdwSTIDs[uiCounter++] = stData.uSoundtrackId;
        }

        // Close our handle to the soundtracks
        XFindClose( hSTHandle );
    }

    // Reopen the Soundtrack Database so the Dashboard can use it
    bReturn = DashBeginUsingSoundtracks();
    if( !bReturn )
    //
    // We failed to open the ST DB, do NOT try to remove any of them
    //
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CHardDrive::RemoveAllSoundtracks():Failed to open the ST DB!! Error - '0x%.8X'", GetLastError() );

        hr = E_FAIL;
    }
    else
    //
    // We opened the ST DB successfully, let's remove the Soundtracks
    //
    {
        // Remove the soundtracks
        for( unsigned int x = 0; x < dwNumSTs; x++ )
        {
            if( !DashDeleteSoundtrack( pdwSTIDs[x] ) )
            {
                XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CHardDrive::RemoveAllSoundtracks():Failed to delete soundtrack - '%d'!!", pdwSTIDs[x] );
                XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CHardDrive::RemoveAllSoundtracks():Error - '%d, 0x%.8X'", GetLastError(), GetLastError() );
            }
        }
    }


    ///////////
    // Clean up
    ///////////
    if( pdwSTIDs )
    {
        delete[] pdwSTIDs;
        pdwSTIDs = NULL;
    }

    DashEndUsingSoundtracks();

    return hr;
}


// Remove all of the Nicknames that live on the hard drive
HRESULT CHardDrive::RemoveAllNicknames()
{
    HRESULT hr = S_OK;

    char pszFullNickPath[MAX_PATH];
    ZeroMemory( pszFullNickPath, MAX_PATH );

    sprintf( pszFullNickPath, "%c:\\%s", HARDDRIVE_UDATA_DRIVE_LETTER_A, HARDDRIVE_NICKNAME_FILENAME );

    if( !DeleteFile( pszFullNickPath ) )
    {
        // Check to make sure the file existed.  If it did not, then there really is no error
        if( ERROR_FILE_NOT_FOUND != GetLastError() )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CHardDrive::RemoveAllNicknames():Failed to remove the nicknames!! - '0x%.8X (%d)'!!", GetLastError(), GetLastError() );

            hr = E_FAIL;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\memoryareas\memoryarea.cpp ===
/*****************************************************
*** memoryarea.cpp
***
*** CPP file for our Memory Area class.
*** This class will allow you to perform certain
*** actions that pertain to a memory area on the
*** Xbox, such as erase, create game titles, etc.
***
*** by James N. Helm
*** March 30th, 2001
***
*****************************************************/

#include "memarpch.h"
#include "memoryarea.h"

// Constructor
CMemoryArea::CMemoryArea()
: m_pwszDefaultName( NULL ),
m_bAbortProcess( FALSE )
{
    SetUDataDrive( '\0' );

    // Initialize our Critical Section
    InitializeCriticalSection( &m_ProcessCritSec );
}

// Destructor
CMemoryArea::~CMemoryArea()
{
    if( m_pwszDefaultName )
    {
        delete[] m_pwszDefaultName;
        m_pwszDefaultName = NULL;
    }

    // Cleanup our Critical Section
    DeleteCriticalSection( &m_ProcessCritSec );
}


// Clear the Memory Area of all data
void CMemoryArea::Erase( char cDriveLetter/*='\0'*/ )
{
    char pszDir[4];
    ZeroMemory( pszDir, 4 );

    if( '\0' == cDriveLetter )
    //
    // The user did not specify a drive letter, assume the local UDATA drive letter
    //
    {
        sprintf( pszDir, "%c:", GetUDataDrive() );
    }
    else
    //
    // The user specified a drive letter, use that one instead
    //
    {
        sprintf( pszDir, "%c:", cDriveLetter );
    }

    if( !DeleteDirectory( pszDir ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::Erase():Failed to delete the directory - '%s'!!", pszDir );
    }
};


// Create a Title Meta XBX file for the specified game title
// pwszGameName and pwszLangCode can be NULL
HRESULT CMemoryArea::CreateTitleMetaXbx( char* pszGamePath, WCHAR* pwszGameName, WCHAR* pwszLangCode, WCHAR* pwszMissingLangCode, BOOL bPrependLangCodeToName/*=TRUE*/ )
{
    if( NULL == pszGamePath )
    {
        return E_INVALIDARG;
    }

    char pszFilePath[MAX_PATH+1];
    ZeroMemory( pszFilePath, MAX_PATH+1 );

    _snprintf( pszFilePath, MAX_PATH, "%s\\%s", pszGamePath, MEMORY_AREA_TITLE_META_FILENAME );

    HANDLE hMetaXbxFile = CreateFile( pszFilePath,
                                      GENERIC_WRITE,
                                      0,
                                      NULL,
                                      CREATE_ALWAYS,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL );
    if( INVALID_HANDLE_VALUE == hMetaXbxFile )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CreateTitleMetaXbx():Failed to create the file - '%hs', Error - '0x%0.8X (%d)'", pszFilePath, GetLastError(), GetLastError() );

        return E_FAIL;
    }

    DWORD dwBytesWritten;
    WCHAR wpszGenBuffer[MAX_PATH+1];
    ZeroMemory( wpszGenBuffer, sizeof( WCHAR ) * ( MAX_PATH + 1 ) );

    //
    // Write the UNICODE signature to the file
    //
    HRESULT hr = S_OK;
    int iNumBytesInBuffer = _snwprintf( wpszGenBuffer, MAX_PATH, L"%c", MEMORY_AREA_UNICODE_SIGNATURE );

    if( !WriteFile( hMetaXbxFile,
                    wpszGenBuffer,
                    iNumBytesInBuffer * sizeof( WCHAR ),
                    &dwBytesWritten,
                    NULL ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CreateTitleMetaXbx():Failed to write to the file - '%ls', Error - '0x%0.8X (%d)'!!", wpszGenBuffer, GetLastError(), GetLastError() );

        hr = E_FAIL;
        goto cleanup;
    }

    if( NULL == pwszLangCode )
    {
        //
        // Write out our data to the file, for all languages
        //
        for( unsigned int x = 0; x < ENUM_MEMAREA_LANGUAGECODE_NUM_ITEMS; x++ )
        {
            if( ( NULL == pwszMissingLangCode ) || ( 0 != wcscmp( pwszMissingLangCode, g_wpszMemAreaLanguageCodes[x] ) ) )
            {
                if( NULL == pwszGameName )
                {
                    if( bPrependLangCodeToName )
                    {
                        iNumBytesInBuffer = _snwprintf( wpszGenBuffer, MAX_PATH, L"%ls\r\n%ls%ls:Test Game %c%c\r\n", g_wpszMemAreaLanguageCodes[x], MEMORY_AREA_TITLE_META_TITLENAME_TOKEN, g_wpszMemAreaLanguageCodes[x], ( rand() % 74 ) + 48, ( rand() % 74 ) + 48 );
                    }
                    else
                    {
                        iNumBytesInBuffer = _snwprintf( wpszGenBuffer, MAX_PATH, L"%ls\r\n%lsTest Game %c%c\r\n", g_wpszMemAreaLanguageCodes[x], MEMORY_AREA_TITLE_META_TITLENAME_TOKEN, ( rand() % 74 ) + 48, ( rand() % 74 ) + 48 );
                    }
                }
                else
                {
                    if( bPrependLangCodeToName )
                    {
                        iNumBytesInBuffer = _snwprintf( wpszGenBuffer, MAX_PATH, L"%ls\r\n%ls%ls:%ls\r\n", g_wpszMemAreaLanguageCodes[x], MEMORY_AREA_TITLE_META_TITLENAME_TOKEN, g_wpszMemAreaLanguageCodes[x], pwszGameName );
                    }
                    else
                    {
                        iNumBytesInBuffer = _snwprintf( wpszGenBuffer, MAX_PATH, L"%ls\r\n%ls%ls\r\n", g_wpszMemAreaLanguageCodes[x], MEMORY_AREA_TITLE_META_TITLENAME_TOKEN, pwszGameName );
                    }
                }

                if( !WriteFile( hMetaXbxFile,
                                wpszGenBuffer,
                                iNumBytesInBuffer * sizeof( WCHAR ),
                                &dwBytesWritten,
                                NULL ) )
                {
                    XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CreateTitleMetaXbx():Failed to write to the file - '%ls', Error - '0x%0.8X (%d)'!!", wpszGenBuffer, GetLastError(), GetLastError() );

                    hr = E_FAIL;
                    goto cleanup;
                }
            }
        }
    }
    else
    {
        //
        // Write out our data for the specified lang code, ONLY
        //
        if( NULL == pwszGameName )
        {
            if( bPrependLangCodeToName )
            {
                iNumBytesInBuffer = _snwprintf( wpszGenBuffer, MAX_PATH, L"%ls\r\n%ls%ls:Test Game %c%c\r\n", pwszLangCode, MEMORY_AREA_TITLE_META_TITLENAME_TOKEN, pwszLangCode, ( rand() % 74 ) + 48, ( rand() % 74 ) + 48 );
            }
            else
            {
                iNumBytesInBuffer = _snwprintf( wpszGenBuffer, MAX_PATH, L"%ls\r\n%lsTest Game %c%c\r\n", pwszLangCode, MEMORY_AREA_TITLE_META_TITLENAME_TOKEN, ( rand() % 74 ) + 48, ( rand() % 74 ) + 48 );
            }
        }
        else
        {
            if( bPrependLangCodeToName )
            {
                iNumBytesInBuffer = _snwprintf( wpszGenBuffer, MAX_PATH, L"%ls\r\n%ls%ls:%ls\r\n", pwszLangCode, MEMORY_AREA_TITLE_META_TITLENAME_TOKEN, pwszLangCode, pwszGameName );
            }
            else
            {
                iNumBytesInBuffer = _snwprintf( wpszGenBuffer, MAX_PATH, L"%ls\r\n%ls%ls\r\n", pwszLangCode, MEMORY_AREA_TITLE_META_TITLENAME_TOKEN, pwszGameName );
            }
        }

        if( !WriteFile( hMetaXbxFile,
                        wpszGenBuffer,
                        iNumBytesInBuffer * sizeof( WCHAR ),
                        &dwBytesWritten,
                        NULL ) )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CreateTitleMetaXbx():Failed to write to the file - '%ls', Error - '0x%0.8X (%d)'!!", wpszGenBuffer, GetLastError(), GetLastError() );

            hr = E_FAIL;
            goto cleanup;
        }
    }

cleanup:

    CloseHandle( hMetaXbxFile );
    hMetaXbxFile = INVALID_HANDLE_VALUE;

    return hr;
}


// Create a Game Title in the specified directory
HRESULT CMemoryArea::CreateGameTitle( char cDriveLetter, char* pszTitleDir, WCHAR* pwszGameName/*=NULL*/, BOOL bPrependLangCodeToName/*=TRUE*/ )
{
    // Check to make sure we were passed a file TitleDir
    if( !pszTitleDir )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CreateGameTitle():Invalid parameter!!" );

        return E_INVALIDARG;
    }

    char pszTitlePath[MAX_PATH];
    ZeroMemory( pszTitlePath, MAX_PATH );

    _snprintf( pszTitlePath, MAX_PATH, "%c:\\%s", cDriveLetter, pszTitleDir );

    // Create the directory for the Game
    if( !CreateDirectory( pszTitlePath, NULL ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CreateGameTitle():Failed to create the directory - '%s', Error - '0x%.8X (%d)'", pszTitlePath, GetLastError(), GetLastError() );

        return E_FAIL;
    }

    HRESULT hr = CreateTitleMetaXbx( pszTitlePath, pwszGameName, NULL, NULL, bPrependLangCodeToName );
    if( FAILED( hr ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CreateGameTitle():Failed to create the titlemeta.xbx file!! TitlePath - '%hs', Error - '0x%0.8X (%d)'!!", pszTitlePath, hr, hr );
    }

    hr = CopyGameImages( pszTitlePath );
    if( FAILED( hr ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CreateGameTitle():Failed to copy the saved game images!! TitlePath - '%hs', Error - '0x%0.8X (%d)'!!", pszTitlePath, hr, hr );
    }

    return S_OK;
}


// Copy the Game images in to the title directory
HRESULT CMemoryArea::CopyGameImages( char* pszTitleDir, BOOL bCopyTitleImage/*=TRUE*/, BOOL bCopyDefSaveImage/*=TRUE*/ )
{
    char pszDestFilePath[MAX_PATH+1];

    if( bCopyTitleImage )
    {
        ZeroMemory( pszDestFilePath, MAX_PATH+1 );
        _snprintf( pszDestFilePath, MAX_PATH, "%s\\%s", pszTitleDir, MEMORY_AREA_TITLE_IMAGE_FILENAME );

        // Copy the Game Title image to the correct location
        if( !CopyFile( MEMORY_AREA_TITLE_IMAGE_PATHINFO, pszDestFilePath, FALSE ) )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CopyGameImages():Failed to copy the file!! Source - '%hs', Dest - '%hs', Error - '0x%0.8X (%d)'!!", MEMORY_AREA_TITLE_IMAGE_PATHINFO, pszDestFilePath, GetLastError(), GetLastError() );
        }
        else
        {
            SetFileAttributes( pszDestFilePath, FILE_ATTRIBUTE_NORMAL );
        }
    }

    if( bCopyDefSaveImage )
    {
        ZeroMemory( pszDestFilePath, MAX_PATH+1 );
        _snprintf( pszDestFilePath, MAX_PATH, "%s\\%s", pszTitleDir, MEMORY_AREA_SAVEGAME_IMAGE_FILENAME );

        // Copy the Default Save Image to the correct location
        if( !CopyFile( MEMORY_AREA_DEFSAVE_IMAGE_PATHINFO, pszDestFilePath, FALSE ) )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CopyGameImages():Failed to copy the file!! Source - '%hs', Dest - '%hs', Error - '0x%0.8X (%d)'!!", MEMORY_AREA_DEFSAVE_IMAGE_PATHINFO, pszDestFilePath, GetLastError(), GetLastError() );
        }
        else
        {
            SetFileAttributes( pszDestFilePath, FILE_ATTRIBUTE_NORMAL );
        }
    }

    return S_OK;
}


// Create a Saved Game in the specified directory
HRESULT CMemoryArea::CreateSavedGame( IN WCHAR* pwszSavedGameName,
                                      OUT char* pszGamePath,
                                      IN unsigned int cbBuffSize,
                                      IN SYSTEMTIME* pSysTimeGameDate,
                                      IN char* pszSaveImage,
                                      IN BOOL bNoCopyGame )
{
    // Check to make sure we were passed a file TitleDir
    if( NULL == pwszSavedGameName )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CreateSavedGame():Invalid parameter!!" );

        return E_INVALIDARG;
    }

    char pszDriveInfo[4];
    pszDriveInfo[3] = '\0';
    // sprintf( pszDriveInfo, "%c:\\", cDriveLetter );
    sprintf( pszDriveInfo, "%c:\\", GetUDataDrive() );

    unsigned int uiBufSize = 0;
    char* pszGameBuffer;
    if( NULL == pszGamePath )
    {
        pszGameBuffer = new char[MAX_PATH+1];
        if( NULL == pszGameBuffer )
        {
            // TODO: Warn about failure and clean up!!
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CreateSavedGame():Failed to allocate memory!!" );
        }

        ZeroMemory( pszGameBuffer, MAX_PATH+1 );
        uiBufSize = MAX_PATH;
    }
    else
    {
        pszGameBuffer = pszGamePath;
        uiBufSize = cbBuffSize;
    }

    DWORD dwCreateFlags = 0;
    if( bNoCopyGame )
    {
        dwCreateFlags = XSAVEGAME_NOCOPY;
    }

    DWORD dwReturn = XCreateSaveGame( pszDriveInfo,
                                      pwszSavedGameName,
                                      OPEN_ALWAYS,
                                      dwCreateFlags,
                                      pszGameBuffer,
                                      uiBufSize );

    if( ERROR_SUCCESS != dwReturn )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CreateSavedGame():Failed to Create the Saved Game!! Error - '0x%.8X (%d)'", dwReturn, dwReturn );
    }
    else
    {
        if( NULL != pszSaveImage )
        {
            // Copy the Save Game image in to the directory
            char pszDestFilePath[MAX_PATH];

            ZeroMemory( pszDestFilePath, MAX_PATH );
            _snprintf( pszDestFilePath, MAX_PATH, "%s%s", pszGameBuffer, MEMORY_AREA_SAVEGAME_IMAGE_FILENAME );

            if( 0 == strcmp( "", pszSaveImage ) )
            //
            // Use the default image info
            //
            {
                // Copy the Game Title image to the correct location
                if( !CopyFile( MEMORY_AREA_SAVEGAME_IMAGE_PATHINFO, pszDestFilePath, FALSE ) )
                {
                    XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CreateSavedGame():Failed to copy the file!! Source - '%hs', Dest - '%hs', Error - '0x%0.8X (%d)'!!", MEMORY_AREA_SAVEGAME_IMAGE_PATHINFO, pszDestFilePath, GetLastError(), GetLastError() );
                }
                else
                {
                    SetFileAttributes( pszDestFilePath, FILE_ATTRIBUTE_NORMAL );
                }
            }
            else
            //
            // Use the passed in image info
            //
            {
                // Copy the Game Title image to the correct location
                if( !CopyFile( pszSaveImage, pszDestFilePath, FALSE ) )
                {
                    XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CreateSavedGame():Failed to copy the file!! Source - '%hs', Dest - '%hs', Error - '0x%0.8X (%d)'!!", pszSaveImage, pszDestFilePath, GetLastError(), GetLastError() );
                }
                else
                {
                    SetFileAttributes( pszDestFilePath, FILE_ATTRIBUTE_NORMAL );
                }
            }
        }

        // Set the Date of the Saved Game if necessary
        if( NULL != pSysTimeGameDate )
        {
            pszGameBuffer[strlen(pszGameBuffer) - 1] = '\0';

            // Set the Date / Time of the directory
            HANDLE hDir = CreateFile( pszGameBuffer, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL );

            if( INVALID_HANDLE_VALUE == hDir )
            {
                XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CreateSavedGame():Failed to open the Save Game Directory - '%s', Error - '0x%0.8X (%d)'", pszGameBuffer, GetLastError(), GetLastError() );
            }
            else
            //
            // The handle is valid, Set the file date and time
            //
            {
                FILETIME fileTime;

                if( !SystemTimeToFileTime( pSysTimeGameDate, &fileTime ) )
                {
                    XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CreateSavedGame():SystemTimeToFileTime Failed!! Error - '0x%0.8X (%d)'", GetLastError(), GetLastError() );
                }

                if( !SetFileTime( hDir, &fileTime, &fileTime, &fileTime ) )
                {
                    XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CreateSavedGame():Failed to Set Filetime for '%hs', Error - '0x%0.8X (%d)'", pszGameBuffer, GetLastError(), GetLastError() );
                }

                CloseHandle( hDir );
            }
        }
    }

    return S_OK;
}


// Corrupt the specified partition by blanking out the initial page
BOOL CMemoryArea::CorruptPartition( POBJECT_STRING VolumePath )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE VolumeHandle;
    DWORD dwNumBytesWritten;
    BYTE pbData[PAGE_SIZE];
    BOOL bReturn = TRUE;

    ZeroMemory( pbData, PAGE_SIZE );

    //
    // Open the volume for read/write access.
    //

    InitializeObjectAttributes(&ObjectAttributes, VolumePath,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenFile(&VolumeHandle, SYNCHRONIZE | FILE_READ_DATA |
        FILE_WRITE_DATA, &ObjectAttributes, &IoStatusBlock, 0,
        FILE_SYNCHRONOUS_IO_ALERT | FILE_NO_INTERMEDIATE_BUFFERING);

    if (!NT_SUCCESS(status)) {
        SetLastError(RtlNtStatusToDosError(status));
        
        return FALSE;
    }

    //
    // Write 0's to the volume
    //
    if( !WriteFile( VolumeHandle,
                    &pbData,
                    PAGE_SIZE,
                    &dwNumBytesWritten,
                    NULL ) )
    {
        bReturn = FALSE;
    }

    NtClose(VolumeHandle);

    return bReturn;
}


// Get the number of blocks that are free on the Memory Area
DWORD CMemoryArea::GetFreeBlocks()
{
    DWORD dwTotalBlocks, dwFreeBlocks;

    if( FAILED( CalcSpace( &dwTotalBlocks, &dwFreeBlocks ) ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::GetFreeBlocks():CalcSpace failed!!" );
    }

    return dwFreeBlocks;
}


// Get the total number of blocks on the Memory Area
DWORD CMemoryArea::GetTotalBlocks()
{
    DWORD dwTotalBlocks, dwFreeBlocks;

    if( FAILED( CalcSpace( &dwTotalBlocks, &dwFreeBlocks ) ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::GetTotalBlocks():CalcSpace failed!!" );
    }

    return dwTotalBlocks;
}


// Fill the Memory Area with a specified Number of Blocks worth of data
#define MEMORY_AREA_FILL_FILE_PATTERN  "xdk_data_"
void CMemoryArea::FillArea( char* pszDirectory, unsigned int uiNumBlocks )
{
    // Check to make sure we are going to fill the proper directory
    if( !pszDirectory )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FillArea():Invalid Directory passed in!!" );

        return;
    }

    // Check to make sure we can create the files
    if( uiNumBlocks > GetTotalBlocks() )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FillArea():Too many blocks specified!  Specified - '%d', Max - '%d'", uiNumBlocks, GetFreeBlocks() );

        return;
    }

    unsigned int uiCounter = 0;
    LARGE_INTEGER liBlockInformation;       // Convert the user passed in blocks to bytes
    liBlockInformation.QuadPart = 0;

    if( MEMORY_AREA_BLOCK_SIZE_MAX_NUM_LOW_PART < uiNumBlocks )
    {
        uiCounter = uiNumBlocks / MEMORY_AREA_BLOCK_SIZE_MAX_NUM_LOW_PART;
        uiNumBlocks = uiNumBlocks - ( uiCounter * MEMORY_AREA_BLOCK_SIZE_MAX_NUM_LOW_PART );
        liBlockInformation.LowPart = (DWORD)MEMORY_AREA_BLOCK_SIZE_MAX_NUM_LOW_PART * (DWORD)MEMORY_AREA_BLOCK_SIZE_IN_BYTES;
    }

    char pszFilePath[MAX_PATH+1];
    ZeroMemory( pszFilePath, MAX_PATH+1 );

    // For each "high part" of the QuadWord, we should create a huge file
    unsigned int uiModifier = 0;
    for( unsigned int x = 0; x < uiCounter; ++x )
    {
        _snprintf( pszFilePath, MAX_PATH, "%s%s%d.xdk", pszDirectory, MEMORY_AREA_FILL_FILE_PATTERN, x + uiModifier );
        while( FileExists( pszFilePath ) )
        {
            _snprintf( pszFilePath, MAX_PATH, "%s%s%d.xdk", pszDirectory, MEMORY_AREA_FILL_FILE_PATTERN, x + (++uiModifier) );

            if( 4096 == uiModifier )
            {
                XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FillArea():Unable to create a unique (large) file!!" );

                return;
            }
        }

        HRESULT hr = CreateFileOfSize( pszFilePath, liBlockInformation );
        if( FAILED( hr ) )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FillArea():CreateFileOfSize Failed!! - '0x%0.8X (%d)'", hr, hr );
        }
    }

    //
    // Create a file for the smaller block size
    //

    liBlockInformation.LowPart = uiNumBlocks * MEMORY_AREA_BLOCK_SIZE_IN_BYTES;

    _snprintf( pszFilePath, MAX_PATH, "%s%s%d.xdk", pszDirectory, MEMORY_AREA_FILL_FILE_PATTERN, x + (++uiModifier) );
    while( FileExists( pszFilePath ) )
    {
        _snprintf( pszFilePath, MAX_PATH, "%s%s%d.xdk", pszDirectory, MEMORY_AREA_FILL_FILE_PATTERN, x + (++uiModifier) );

        if( 4096 == uiModifier )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FillArea():Unable to create a unique (small) file!!" );

            return;
        }
    }

    HRESULT hr = CreateFileOfSize( pszFilePath, liBlockInformation );
    if( FAILED( hr ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FillArea():CreateFileOfSize Failed!! - '0x%0.8X (%d)'", hr, hr );
    }
}


// Creates a file of a specified size
HRESULT CMemoryArea::CreateFileOfSize( char* pszFileName, LARGE_INTEGER liNumBytes )
{
    if( NULL == pszFileName )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CreateFileOfSize():Invalid parameter passed in!! ");

        return E_INVALIDARG;
    }

    HANDLE hFile = CreateFile( pszFileName,
                               GENERIC_WRITE,
                               0,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL );

    if( INVALID_HANDLE_VALUE == hFile )
    //
    // We did not create the file, inform the user and do not proceed
    //
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CreateFileOfSize():Could not create the file - %s, Error - '0x%.8X (%d)'!!", pszFileName, GetLastError(), GetLastError() );

        return E_FAIL;
    }

    // Set the file pointer to be as large as the free space on the disk
    if( !SetFilePointerEx( hFile, liNumBytes, NULL, FILE_CURRENT ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CreateFileOfSize():Failed to set the File Pointer - '0x%.8X (%d)'", GetLastError(), GetLastError() );
    }

    // Set the END OF FILE to the new location
    if( !SetEndOfFile( hFile ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CreateFileOfSize():Failed to Set EOF - '0x%.8X (%d)'", GetLastError(), GetLastError() );
    }

    // Close the file
    CloseHandle( hFile );
    hFile = NULL;

    return S_OK;
}


// Adjusts the file size by the specified amount
HRESULT CMemoryArea::AdjustFileSize( char* pszFileName, LARGE_INTEGER liNumBytes )
{
    if( NULL == pszFileName )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::AdjustFileSize():Invalid parameter passed in!! ");

        return E_INVALIDARG;
    }

    HANDLE hFile = CreateFile( pszFileName,
                               GENERIC_WRITE,
                               0,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL );

    if( INVALID_HANDLE_VALUE == hFile )
    //
    // We did not create the file, inform the user and do not proceed
    //
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::AdjustFileSize():Could not create the file - %s, Error - '0x%.8X (%d)'!!", pszFileName, GetLastError(), GetLastError() );

        return E_FAIL;
    }

    // Figure out how to adjust our file
    LARGE_INTEGER liFileSize;
    ZeroMemory( &liFileSize, sizeof( liFileSize ) );

    if( !GetFileSizeEx( hFile, &liFileSize ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::AdjustFileSize():Failed to get the File Size - '%s', '0x%.8X (%d)'", pszFileName, GetLastError(), GetLastError() );
    }

    LARGE_INTEGER liAdjustFileSize;
    liAdjustFileSize.QuadPart = liFileSize.QuadPart + liNumBytes.QuadPart;

    HRESULT hr = S_OK;
    // Set the file pointer to be as large as the free space on the disk
    if( !SetFilePointerEx( hFile, liAdjustFileSize, NULL, FILE_BEGIN ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::AdjustFileSize():Failed to set the File Pointer - '0x%.8X (%d)'", GetLastError(), GetLastError() );

        hr = E_FAIL;
    }

    // Set the END OF FILE to the new location
    if( !SetEndOfFile( hFile ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::AdjustFileSize():Failed to Set EOF - '0x%.8X (%d)'", GetLastError(), GetLastError() );

        hr = E_FAIL;
    }

    // Close the file
    CloseHandle( hFile );
    hFile = NULL;

    return hr;
}


// Retreives block information for the current MU
HRESULT CMemoryArea::CalcSpace( DWORD* pdwTotalBlocks, DWORD* pdwFreeBlocks )
{
    *pdwTotalBlocks = 0;
    *pdwFreeBlocks = 0;

    ULARGE_INTEGER uliFreeBytesAvailable, uliTotalNumBytes, uliTotalNumFreeBytes;

    char pszDirectory[4];   // Used to hold the directory, which will always be the root
    ZeroMemory( pszDirectory, 4 );
    sprintf( pszDirectory, "%c:\\", GetUDataDrive());

    // Get the disk space information for the MU -- If there was a problem, return 0
    if( !GetDiskFreeSpaceEx( pszDirectory, &uliFreeBytesAvailable, &uliTotalNumBytes, &uliTotalNumFreeBytes ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CalcSpace():Failed to 'GetDiskFreeSpaceEx'!! - '%s', '0x%.8X (%d)'", pszDirectory, GetLastError(), GetLastError() );

        return E_FAIL;
    }

    // Calculate the block sizes, and store the values in our parameters
    *pdwTotalBlocks = (DWORD)( uliTotalNumBytes.QuadPart / MEMORY_AREA_BLOCK_SIZE_IN_BYTES );
    *pdwFreeBlocks  = (DWORD)( uliTotalNumFreeBytes.QuadPart / MEMORY_AREA_BLOCK_SIZE_IN_BYTES );

    return S_OK;
}


// Copy files from one directory to another
void CMemoryArea::CopyDirs( char* pszSource, char* pszDest )
{
    if( NULL == pszSource || NULL == pszDest )
    {
        return;
    }

    char pszBuf[MAX_PATH+1];
    char pszNewDest[MAX_PATH+1];

    ZeroMemory( pszBuf, MAX_PATH+1 );
    ZeroMemory( pszNewDest, MAX_PATH+1 );

    sprintf( pszBuf, "%s\\*.*", pszSource );

    WIN32_FIND_DATA fd;
    HANDLE h = FindFirstFile( pszBuf, &fd );
    if ( h != INVALID_HANDLE_VALUE )
    //
    // Valid handle value -- There must be files or sub-directories
    //
    {
        // Create the destination directory
        if( !CreateDirectory( pszDest, NULL ) )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CopyDirs():Failed to Create Destination Dir - '%hs', Error - '0x%0.8X (%d)'", pszDest, GetLastError(), GetLastError() );
        }

        do
        {
            // Skip over "." and ".." directories
            if( fd.cFileName[0] == '.' )
            {
                continue;
            }

            _snprintf( pszBuf, MAX_PATH, "%s\\%s", pszSource, fd.cFileName );
            _snprintf( pszNewDest, MAX_PATH, "%s\\%s", pszDest, fd.cFileName );

            // If it's a directory, copy that entire directory
            if ( ( fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) != 0 )
            {
                CopyDirs( pszBuf, pszNewDest );
            }
            else
            {
                // Copy the file
                if( !CopyFile( pszBuf, pszNewDest, FALSE ) )
                {
                    XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CopyDirs():Failed to Copy the File.  Source - '%hs', Dest - '%hs', Error - '0x%0.8X (%d)'", pszBuf, pszNewDest, GetLastError(), GetLastError() );
                }
                else
                {
                    SetFileAttributes( pszNewDest, FILE_ATTRIBUTE_NORMAL );
                }
            }
        }
        while ( FindNextFile( h, &fd ) );

        FindClose( h );
        h = INVALID_HANDLE_VALUE;
    }
    else
    //
    // Invalid handle value -- FindFirstFile failed!
    //
    {
        // If we didn't find a file, that's OK
        if( ERROR_FILE_NOT_FOUND != GetLastError() )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CopyDirs():FindFirstFile Failed - '%s', Error - '0x%0.8X (%d)'", pszBuf, GetLastError(), GetLastError() );
        }
    }
}


// Delete a directory and all files within
BOOL CMemoryArea::DeleteDirectory( char* pszPath )
{
    // DO NOT use a trailing slash

    char pszBuf[MAX_PATH+1];
    ZeroMemory( pszBuf, MAX_PATH+1 );

    sprintf( pszBuf, "%s\\*.*", pszPath );

    WIN32_FIND_DATA fd;
    HANDLE h = FindFirstFile( pszBuf, &fd );
    if ( h != INVALID_HANDLE_VALUE )
    //
    // Valid handle value -- There must be files or sub-directories
    //
    {
        do
        {
            // Skip over "." and ".." directories
            // BUGBUG: Skip over Dash directories on the TDATA drive
            // BUGBUG: We should NOT skip these while we are in the launcher -- We can allow ALL data to be nuked
            // if ( ( fd.cFileName[0] == '.' ) ||
            //      ( ( strcmp( fd.cFileName, FILE_DATA_XDASH_TITLEID  ) == 0 ) && ( FILE_DATA_TDATA_DRIVE_LETTER_A == pszPath[0] ) ) )

            if( fd.cFileName[0] == '.' )
            {
                continue;
            }


            _snprintf( pszBuf, MAX_PATH, "%s\\%s", pszPath, fd.cFileName );

            if ( ( fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) != 0 )
            {
                if ( !DeleteDirectory( pszBuf ) )
                {
                    return FALSE;
                }
            }
            else
            {
                if ( !DeleteFile( pszBuf ) )
                {
                    return FALSE;
                }
            }
        }
        while ( FindNextFile( h, &fd ) );

        FindClose( h );
        h = NULL;
    }
    else
    //
    // Invalid handle value -- FindFirstFile failed!
    //
    {
        // If we didn't find a file, the directory is already deleted!
        if( ERROR_FILE_NOT_FOUND != GetLastError() )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::DeleteDirectory():FindFirstFile Failed - '%s', Error - '0x%.8X (%d)'", pszBuf, GetLastError(), GetLastError() );
        }
    }

    BOOL fReturn;

    // Check to see if we are dealing with a rool level directory
    if( ( strlen( pszPath ) == 2 ) && ( pszPath[1] == ':' ) )
    //
    // Yes we are dealing with a root level directory, keep the directory
    //
    {
        fReturn = TRUE;
    }
    else
    //
    // No we are not dealing with a root level directory, remove the directory
    //
    {
        fReturn = RemoveDirectory( pszPath ) != FALSE;
    }

    return fReturn;
}


// Will fragment the specified directory, and all directories within
HRESULT CMemoryArea::FragmentTree( char* pszStartDirectory )
{
    if( NULL == pszStartDirectory )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FragmentTree():Inavlid parameter passed in!!" );

        return E_INVALIDARG;
    }

    if( GetAbortProcess() == TRUE )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FragmentTree():Aborting process..." );

        return S_OK;
    }

    // Fragment the current directory
    if( FAILED( FragmentDirectory( pszStartDirectory ) ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FragmentTree():Failed to fragment the directory!! - '%s'", pszStartDirectory );
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FragmentTree():Make sure it is a valid directory!!" );
    }

    char pszSearchPath[MAX_PATH];
    WIN32_FIND_DATA findData;

    ZeroMemory( pszSearchPath, MAX_PATH );
    ZeroMemory( &findData, sizeof( findData ) );

    // If the user passed a trailing '\', we should not append another one
    if( '\\' == pszStartDirectory[strlen(pszStartDirectory) - 1] )
    {
        _snprintf( pszSearchPath, MAX_PATH - 1, "%s*", pszStartDirectory );
    }
    else
    {
        _snprintf( pszSearchPath, MAX_PATH - 1, "%s\\*", pszStartDirectory );
    }

    HANDLE hFile = FindFirstFile( pszSearchPath, &findData );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        if( ERROR_FILE_NOT_FOUND == GetLastError() )
        {
            // This is ok, as there are no files in the tree

            return S_OK;
        }
        else
        {
            // We should always find at least one file on the root.  Nothing should really
            // erase the TDATA and UDATA directories, etc
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FragmentTree():Invalid Handle Value returned!! - '%s', Error - '0x%.8X (%d)'", pszSearchPath, GetLastError(), GetLastError() );

            return E_FAIL;
        }
    }

    do
    {
        if( FILE_ATTRIBUTE_DIRECTORY & findData.dwFileAttributes )
        {
            char pszFullDirPath[MAX_PATH];
            ZeroMemory( pszFullDirPath, MAX_PATH );

            // If the user passed a trailing '\', we should not append another one
            if( '\\' == pszStartDirectory[strlen(pszStartDirectory) - 1] )
            {
                _snprintf( pszFullDirPath, MAX_PATH - 1, "%s%s", pszStartDirectory, findData.cFileName );
            }
            else
            {
                _snprintf( pszFullDirPath, MAX_PATH - 1, "%s\\%s", pszStartDirectory, findData.cFileName );
            }

            if( FAILED( FragmentTree( pszFullDirPath ) ) )
            {
                XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FragmentTree():Failed to fragment the directory!! - '%s'", pszFullDirPath );
            }
        }
    } while( FindNextFile( hFile, &findData ) && ( GetAbortProcess() == FALSE ) );

    // Close our file handle
    FindClose( hFile );
    hFile = NULL;

    return S_OK;
}


// Fragments all files in a given directory
HRESULT CMemoryArea::FragmentDirectory( char* pszDirPath )
{
    if( NULL == pszDirPath )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FragmentDirectory():Invalid argument passed in!!" );

        return E_INVALIDARG;
    }

    char pszSearchPath[MAX_PATH];
    WIN32_FIND_DATA findData;

    ZeroMemory( pszSearchPath, MAX_PATH );
    ZeroMemory( &findData, sizeof( findData ) );

    // If the user passed a trailing '\', we should not append another one
    if( '\\' == pszDirPath[strlen(pszDirPath) - 1] )
    {
        _snprintf( pszSearchPath, MAX_PATH - 1, "%s*", pszDirPath );
    }
    else
    {
        _snprintf( pszSearchPath, MAX_PATH - 1, "%s\\*", pszDirPath );
    }

    // Create a linked list object to hold our file names
    // and specify that the memory will need to be deleted when
    // the object is destroyed
    CLinkedList< char* > fileNames;
    fileNames.SetDeleteDataItem( TRUE );

    // Create a list of all files in the directory
    HANDLE hFile = FindFirstFile( pszSearchPath, &findData );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        if( ERROR_FILE_NOT_FOUND == GetLastError() )
        {
            // This is ok, as there are no files in this directory

            return S_OK;
        }
        else
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FragmentDirectory():Invalid Handle Value returned!! - '%s', '0x%.8X (%d)'", pszSearchPath, GetLastError(), GetLastError() );

            return E_FAIL;
        }
    }

    do
    {
        // Skip the entry if it is a directory
        if( FILE_ATTRIBUTE_DIRECTORY & findData.dwFileAttributes )
        {
            continue;
        }

        // Add the filename to our list
        int iFileNameLength = strlen( findData.cFileName );
        char* pszFName = new char[iFileNameLength + 1]; // We don't need to free this memory, as the linked list class will take care of it for us
        if( NULL == pszFName )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FragmentDirectory():Failed to allocate memory!!" );

            // BUGBUG: Should probably exit the function at this point, as I doubt
            // any other allocations will succeed
            continue;
        }

        strcpy( pszFName, findData.cFileName );
        fileNames.AddNode( pszFName );
    } while( ( FindNextFile( hFile, &findData ) ) && ( GetAbortProcess() == FALSE ) );

    // Close our file handle
    FindClose( hFile );
    hFile = NULL;

    if( ( fileNames.GetNumItems() > 0 ) && ( GetAbortProcess() == FALSE )  )
    {
        // Make sure we are at the beginning of our list
        fileNames.MoveTo( 0 );

        // Loop on each file and Call FragmentFile
        for( unsigned int x = 0; ( x < fileNames.GetNumItems() ) && ( GetAbortProcess() == FALSE ); ++x )
        {
            HRESULT hr = FragmentFile( pszDirPath, fileNames.GetCurrentNode() );
            // Check to see if we encountered something unexpected
            // if so, try the opertation again, otherwise, check for failure
            if( E_UNEXPECTED == hr )
            {
                // TODO: Turn this in to a TRACE, instead of a WARNING
                XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FragmentDirectory():Encountered something unexpected, trying again!!" );

                if( FAILED( FragmentFile( pszDirPath, fileNames.GetCurrentNode() ) ) )
                {
                    XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FragmentDirectory():FragmentFile failed for - '%s', '%s'", pszDirPath, fileNames.GetCurrentNode() );
                }
            }
            else
            {
                if( FAILED( hr ) )
                {
                    XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FragmentDirectory():FragmentFile failed for - '%s', '%s'", pszDirPath, fileNames.GetCurrentNode() );
                }
            }

            fileNames.MoveNext();
        }
    }

    return S_OK;
}


// Fragments an individual file
HRESULT CMemoryArea::FragmentFile( char* pszFilePath, char* pszFileName )
{
    if( ( NULL == pszFilePath ) || ( NULL == pszFileName ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FragmentFile():Invalid argument passed in!!" );

        return E_INVALIDARG;
    }

    // Make sure the Z drive is clear (cache drive) before beginning
    DeleteDirectory( "z:" );

    char pszSourceFilePath[MAX_PATH];
    char pszDestFilePath[MAX_PATH];

    ZeroMemory( pszSourceFilePath, MAX_PATH );
    ZeroMemory( pszDestFilePath, MAX_PATH );

    // If the user passed a trailing '\', we should not append another one
    if( '\\' == pszFilePath[strlen(pszFilePath) - 1] )
    {
        _snprintf( pszSourceFilePath, MAX_PATH - 1, "%s%s", pszFilePath, pszFileName );
    }
    else
    {
        _snprintf( pszSourceFilePath, MAX_PATH - 1, "%s\\%s", pszFilePath, pszFileName );
    }
    _snprintf( pszDestFilePath, MAX_PATH - 1, "z:\\%s", pszFileName );

    // Move the file to the Z drive
    if( !MoveFileEx( pszSourceFilePath,
                     pszDestFilePath,
                     MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FragmentFile():Failed to move the file!!\n  Source - '%s'\n  Dest - '%s', Error - '0x%.8X (%d)'", pszSourceFilePath, pszDestFilePath, GetLastError(), GetLastError() );

        return E_FAIL;
    }

    DWORD dwFileSize = GetMAFileSize( pszDestFilePath );
    if( 0xFFFFFFFF == dwFileSize )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FragmentFile():Failed to obtain the size of our file!! - '%s', Error - '0x%.8X (%d)'", pszDestFilePath, GetLastError(), GetLastError() );

        return E_FAIL;
    }


    // Fill the drive's remaining space
    DWORD dwBlocksFree = GetFreeBlocks();
    LARGE_INTEGER liFileSizeToCreate;
    liFileSizeToCreate.QuadPart = dwBlocksFree * MEMORY_AREA_BLOCK_SIZE_IN_BYTES;

    CreateFileOfSize( MEMORY_AREA_FRAG_FILL_FILENAME, liFileSizeToCreate );

    //
    // Shrink our files to cause fragmentation
    //
    static DWORD dwCurrentFile = 0; // Tracks the current file we are shrinking, so we can always be rotating through our files
    DWORD dwNumFilesToAdjust = ( dwFileSize / MEMORY_AREA_BLOCK_SIZE_IN_BYTES ) + 1;
    char pszShrinkFileName[MAX_PATH];
    for( unsigned int uiBlockCount = 0; uiBlockCount < dwNumFilesToAdjust; uiBlockCount++ )
    {
        ZeroMemory( pszShrinkFileName, MAX_PATH );
        _snprintf( pszShrinkFileName, MAX_PATH - 1, "%s\\%s%d.xdk", MEMORY_AREA_FRAG_FILE_DIR, MEMORY_AREA_FRAG_FILE_PATTERN, dwCurrentFile++ );
        if( MEMORY_AREA_FRAG_NUM_FILES == dwCurrentFile )
        {
            dwCurrentFile = 0;
        }

        // Adjust the size of a file by negative 1 block
        LARGE_INTEGER liAdjustSize;
        liAdjustSize.QuadPart = MEMORY_AREA_BLOCK_SIZE_IN_BYTES * -1;
        if( FAILED( AdjustFileSize( pszShrinkFileName, liAdjustSize ) ) )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FragmentFile():Failed to adjust our file, performing cleanup!! - '%s', '0x%.8X (%d)'", pszShrinkFileName, GetLastError(), GetLastError() );

            // Delete our frag file directory, and our temp filler file
            DeleteDirectory( MEMORY_AREA_FRAG_FILE_DIR );

            // Move the file back over from the cache partition
            if( !MoveFileEx( pszDestFilePath,
                             pszSourceFilePath,
                             MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH ) )
            {
                XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FragmentFile():Failed to move the file back!!\n  Source - '%s'\n  Dest - '%s'", pszDestFilePath, pszSourceFilePath );
            }

            // Re-create our frag temp files (as if we just started the fragmentation process)
            CreateFragTempFiles();

            // Set our static file pointer to file #1
            dwCurrentFile = 0;

            return E_UNEXPECTED;
        }
    }

    // Attempt to Move the file back to the Local Drive
    if( !MoveFileEx( pszDestFilePath,
                     pszSourceFilePath,
                     MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FragmentFile():Failed to move the file back!!\n  Source - '%s'\n  Dest - '%s'", pszDestFilePath, pszSourceFilePath );
    }

    // Remove the file we created as filler space
    if( !DeleteFile( MEMORY_AREA_FRAG_FILL_FILENAME ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FragmentFile():Failed to delete our filler file!! - '%s', Error - '0x%.8X (%d)'", MEMORY_AREA_FRAG_FILL_FILENAME, GetLastError(), GetLastError() );
    }

    return S_OK;
}


// This function will get the file size of the file, and return it to the caller
DWORD CMemoryArea::GetMAFileSize( char* pszFileName )
{
    if( NULL == pszFileName )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::GetMAFileSize():Invalid parameter passed in!!" );

        return 0xFFFFFFFF;
    }

    DWORD dwFileSize = 0;   // Return value for our function

    // Open the file to get its size
    HANDLE hFile = CreateFile( pszFileName,
                               GENERIC_READ,
                               0,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::GetMAFileSize():Unable to open the file to get its size!! - '%s', Error - '0x%.8X (%d)'", pszFileName, GetLastError(), GetLastError() );

        return 0xFFFFFFFF;
    }
    else
    {
        // Get the size of the file we are dealing with
        dwFileSize = GetFileSize( hFile, NULL );

        CloseHandle( hFile );
        hFile = NULL;

        // If we failed to get the file size, we should exit the function, as we couldn't complete the
        // fragmentation
        if( 0xFFFFFFFF == dwFileSize )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::GetMAFileSize():Failed to obtain the size of our file!! - '%s', Error - '0x%.8X (%d)'", pszFileName, GetLastError(), GetLastError() );
        }
    }

    return dwFileSize;
}


// Will return TRUE if a file exists, otherise FALSE
BOOL CMemoryArea::FileExists( char* pszFileName )
{
    if( NULL == pszFileName )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FileExists():Invalid parameter passed in!!" );

        return FALSE;
    }

    BOOL bReturn = FALSE;

    // Attempt to open the file to see if the file exists
    HANDLE hFile = CreateFile( pszFileName,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL );

    if( INVALID_HANDLE_VALUE == hFile )
    {
        if( ( ERROR_FILE_NOT_FOUND != GetLastError() ) && ( ERROR_NOT_READY != GetLastError() ) && ( ERROR_PATH_NOT_FOUND != GetLastError() ) && ( ERROR_UNRECOGNIZED_VOLUME != GetLastError() ) )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::FileExists():CreateFile failed!! - '%s', '0x%.8X (%d)'", pszFileName, GetLastError(), GetLastError() );
        }
    }
    else
    {
        bReturn = TRUE;

        CloseHandle( hFile );
        hFile = NULL;
    }

    return bReturn;
}


// Create 0 byte file
DWORD CMemoryArea::CreateZeroByteFile( char* pszFileName )
{
    if( NULL == pszFileName )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CreateZeroByteFile():Invalid parameter passed in!!" );

        return E_INVALIDARG;
    }

    // Create the file
    HANDLE hFile = CreateFile( pszFileName,
                               GENERIC_WRITE,
                               0,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL );

    if( INVALID_HANDLE_VALUE == hFile )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CCertReqs::Req10_2_01():Failed to create the file!! - '%s', Error - '0x%.8X (%d)'", pszFileName, GetLastError(), GetLastError() );

        return GetLastError();
    }
    else
    {
        CloseHandle( hFile );
        hFile = NULL;
    }

    return S_OK;
}


// Map a drive to a partiticular drive letter
DWORD CMemoryArea::MapDrive( char cDriveLetter, char* pszPartition )
{
    ASSERT( pszPartition != NULL );

    char pszDrive[20];
    ZeroMemory( pszDrive, 20 );

    sprintf( pszDrive, "\\??\\%c:", cDriveLetter );

    ANSI_STRING ostDrive, ostPath;

    RtlInitObjectString( &ostDrive, pszDrive );
    RtlInitObjectString( &ostPath, pszPartition );
    NTSTATUS status = IoCreateSymbolicLink( &ostDrive, &ostPath );

    return RtlNtStatusToDosError( status );
}


// Un-map a drive from the specified drive letter
DWORD CMemoryArea::UnMapDrive( char cDriveLetter )
{
    char pszDrive[20];
    ZeroMemory( pszDrive, 20 );

    sprintf( pszDrive, "\\??\\%c:", cDriveLetter );

    ANSI_STRING ostDrive;

    RtlInitObjectString( &ostDrive, pszDrive );
    NTSTATUS status = IoDeleteSymbolicLink(&ostDrive);

    return RtlNtStatusToDosError( status );
}


// Creates temporary files to use during fragmentations
HRESULT CMemoryArea::CreateFragTempFiles()
{
    //
    // Create a directory that contains our frag files
    //

    // Make sure our directory is cleared out
    DeleteDirectory( MEMORY_AREA_FRAG_FILE_DIR );

    // Use a root-level directory so it's not picked up in our traversals
    if( !CreateDirectory( MEMORY_AREA_FRAG_FILE_DIR, NULL ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::CreateFragTempFiles():Failed to create the directory!! - '%hs', Error - '0x%0.8X (%d)'", MEMORY_AREA_FRAG_FILE_DIR, GetLastError(), GetLastError() );
    }

    // Create file entries in the directory
    LARGE_INTEGER liByteSizeOfFiles;

    char pszFileName[MAX_PATH];
    DWORD dwNumBlocksFree = GetFreeBlocks();
    DWORD dwBlocksPerFile = dwNumBlocksFree / MEMORY_AREA_FRAG_NUM_FILES;
    liByteSizeOfFiles.QuadPart = dwBlocksPerFile * MEMORY_AREA_BLOCK_SIZE_IN_BYTES;
    for( unsigned int x = 0; ( x < MEMORY_AREA_FRAG_NUM_FILES ) && ( GetAbortProcess() != TRUE ); x++ )
    {
        ZeroMemory( pszFileName, MAX_PATH );
        _snprintf( pszFileName, MAX_PATH - 1, "%s\\%s%d.xdk", MEMORY_AREA_FRAG_FILE_DIR, MEMORY_AREA_FRAG_FILE_PATTERN, x );

        CreateFileOfSize( pszFileName, liByteSizeOfFiles );
    }

    return S_OK;
}


// Used to set the Default name of the Memory Area
HRESULT CMemoryArea::SetDefaultName( WCHAR* pwszName )
{
    if( NULL == pwszName )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::SetDefaultName():Invalid parameter passed in!!" );

        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    if( m_pwszDefaultName )
    {
        delete[] m_pwszDefaultName;
        m_pwszDefaultName = NULL;
    }

    m_pwszDefaultName = new WCHAR[wcslen( pwszName ) + 1];
    if( NULL != m_pwszDefaultName )
    {
        wcscpy( m_pwszDefaultName, pwszName );
    }
    else
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::SetDefaultName():Failed to allocate memory!!" );

        hr = E_FAIL;
    }

    return hr;
}


// Used to get the Memory Area default name
HRESULT CMemoryArea::GetDefaultName( WCHAR* pwszBuffer, ULONG ulBufferLen )
{
    if( NULL == pwszBuffer )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::GetDefaultName():Invalid parameter passed in!!" );

        ZeroMemory( pwszBuffer, sizeof( WCHAR ) * ulBufferLen );

        return E_INVALIDARG;
    }

    if( NULL == m_pwszDefaultName )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::GetDefaultName():Default name was never set!!" );

        ZeroMemory( pwszBuffer, sizeof( WCHAR ) * ulBufferLen );

        return E_FAIL;
    }

    ASSERT( ulBufferLen >= ( wcslen( m_pwszDefaultName ) + 1 ) );

    ZeroMemory( pwszBuffer, sizeof( WCHAR ) * ulBufferLen );
    wcscpy( pwszBuffer, m_pwszDefaultName );

    return S_OK;
}


// Will search the memory area and populate the GameTitles object
void CMemoryArea::ProcessGameTitles()
{
    if( '\0' == GetUDataDrive() )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryArea::ProcessGameTitles():Can't process titles for Memory Area -- No UData Drive!!" );

        return;
    }

    // Get the Game Title Info for this MU
    char pszDir[3];
    pszDir[2] = '\0';
    sprintf( pszDir, "%c:", GetUDataDrive() );
    m_GameTitles.Init( pszDir, this );
}


// Used to set whether or not the current process should be aborted
void CMemoryArea::SetAbortProcess( BOOL bSetting )
{
    EnterCriticalSection( &m_ProcessCritSec );
    
    m_bAbortProcess = bSetting;
    
    LeaveCriticalSection( &m_ProcessCritSec );
}


// Used to get the state of our current process
BOOL CMemoryArea::GetAbortProcess()
{
    BOOL bReturnVal;
    
    EnterCriticalSection( &m_ProcessCritSec );
    
    bReturnVal = m_bAbortProcess;
    
    LeaveCriticalSection( &m_ProcessCritSec );

    return bReturnVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\wavemedia\wavempch.h ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    wavempch.h

Abstract:

    precompiled header for usb manager library.

--*/

#ifndef _WAVEMPCH_H_
#define _WAVEMPCH_H_

#include <xtl.h>
#include <xdbg.h>

#endif // _WAVEMPCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\menus\menuspch.h ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    menuspch.h

Abstract:

    precompiled header for usb manager library.

--*/

#ifndef _MENUSPCH_H_
#define _MENUSPCH_H_

#define MENUS_APP_TITLE_NAME_A     "MENU"

#include <xtl.h>
#include <stdio.h>
#include <xdbg.h>

#endif // _MENUSPCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\menus\xitem.cpp ===
/*****************************************************
*** xitem.cpp
***
*** CPP file for our abstract base class for a
*** generic screen of our XDash Config program.
*** 
*** by James N. Helm
*** November 2nd, 2000
***
*** Modified
*** 12/03/2000 - by James N. Helm for XShell
*** 03/09/2001 - by James N. Helm for MU Config
*** 06/22/2001 - by James N. Helm for MU Config
***              Added Set/Get Title functions and
***              property
*****************************************************/

#include "menuspch.h"
#include "xitem.h"

// Constructor
CXItem::CXItem( CXItem* pParent ) :
m_pParent( NULL ),
m_bUpdateTexture( TRUE ),
m_pwszTitle( NULL )
{
    SetParent( pParent );

    m_pwszTitle = new WCHAR[XITEM_TITLE_SIZE];
    if( NULL == m_pwszTitle )
    {
        XDBGWRN( MENUS_APP_TITLE_NAME_A, "CXItem::CXItem():Failed to allocate memory!!" );
    }
    else
    {
        SetTitle( L"Default Name" );
    }
};

// Destructor
CXItem::~CXItem()
{
    if( NULL != m_pwszTitle )
    {
        delete[] m_pwszTitle;
        m_pwszTitle = NULL;
    }
}


// Set the Title of the menu
HRESULT CXItem::SetTitle( WCHAR* pwszTitle )
{
    if( !pwszTitle )
    {
        XDBGWRN( MENUS_APP_TITLE_NAME_A, "CXItem::SetTitle():Invalid argument passed in!!" );

        return E_INVALIDARG;
    }

    ZeroMemory( m_pwszTitle, sizeof( WCHAR ) * XITEM_TITLE_SIZE );
    lstrcpyn( m_pwszTitle, pwszTitle, XITEM_TITLE_SIZE );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\menus\udtexture.cpp ===
/*****************************************************
*** udtexture.cpp
***
*** CPP file for our udtexture class.  This class
*** will hold a texture and allow the user to perform
*** certain actions on this texture, like writing
*** text, etc
*** 
*** by James N. Helm
*** January 24th, 2001
***
*** Modified
*** 03/09/2001 - James N. Helm
*****************************************************/
#include "menuspch.h"
#include "udtexture.h"

extern XFONT *g_pFont;

// Constructor
CUDTexture::CUDTexture( void ) :
m_pD3DDevice( NULL ),
m_pTexture( NULL ),
m_pTextureSurface( NULL ),
m_pCurrentRenderTarget( NULL ),
m_pVertexBuffer( NULL ),
m_pCurrentVBuffer( NULL ),
m_uiCurrentStride( 0 ),
m_iTextureWidth( 0 ),
m_iTextureHeight( 0 ),
m_uiTextureLockedRef( 0 )
{
    XDBGTRC( MENUS_APP_TITLE_NAME_A, "CUDTexture::CUDTexture()" );
}


// Destructor
CUDTexture::~CUDTexture( void )
{
    XDBGTRC( MENUS_APP_TITLE_NAME_A, "CUDTexture::~CUDTexture()" );

    // CleanUp any memory we have allocated
    CleanUp();
}

// Clean up any memory we have allocated
void CUDTexture::CleanUp()
{
    // Release our surface if needed
    if( NULL != m_pTextureSurface )
    {
        m_pTextureSurface->Release();
        m_pTextureSurface = NULL;
    }

    // Release our Vertex Buffer
    if( m_pVertexBuffer )
    {
        m_pVertexBuffer->Release();
        m_pVertexBuffer = NULL;
    }

    // Release our texture if needed
    if( NULL != m_pTexture )
    {
        m_pTexture->Release();
        m_pTexture = NULL;
    }

    if( NULL != m_pD3DDevice )
    {
        // m_pD3DDevice->Release();
        m_pD3DDevice = NULL;
    }
}


// Clear the texture
void CUDTexture::Clear( DWORD dwColor )
{
    // Clear the texture here
    m_pD3DDevice->Clear( 0, NULL, D3DCLEAR_TARGET, dwColor, 1.0f, 0 );
}


// Draw a box on to the texture
void CUDTexture::DrawBox( float fX1, float fY1, float fX2, float fY2, DWORD dwColor )
{
    UDTEXTURE_VERTEX* pb = NULL;

    m_pVertexBuffer->Lock( 0, 0, (BYTE**)&pb, 0 );

	pb[0].v.x = fX1; pb[0].v.y = fY1; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = dwColor;
	pb[1].v.x = fX2; pb[1].v.y = fY1; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = dwColor;
	pb[2].v.x = fX2; pb[2].v.y = fY2; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = dwColor;
	pb[3].v.x = fX1; pb[3].v.y = fY2; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = dwColor;

    m_pVertexBuffer->Unlock();

    // Make sure that edge antialiasing is off for this call!
    DWORD dwEdgeCurrentState = 0;

    m_pD3DDevice->GetRenderState( D3DRS_EDGEANTIALIAS, &dwEdgeCurrentState );
    m_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, FALSE );

    // Draw the box
    m_pD3DDevice->DrawPrimitive( D3DPT_TRIANGLEFAN, 0, 2 );

    // Restore the Edge Antialiasing state
    m_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, dwEdgeCurrentState );
}


// Draw a clear rectangle to the texture
void CUDTexture::DrawClearRect( float fX1, float fY1, float fX2, float fY2, DWORD dwColor )
{
	D3DRECT rect;

    rect.x1 = (long)fX1; 
	rect.x2 = (long)fX2 + 1;

    rect.y1 = (long)fY1;
	rect.y2 = (long)fY2 + 1;

    m_pD3DDevice->Clear( 1, &rect, D3DCLEAR_TARGET, dwColor, 0, 0 );
}


// Draw a line to the texture
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      color          --- the RGBA color to draw the box with
void CUDTexture::DrawLine( float fX1, float fY1, float fX2, float fY2, float fLineWidth, DWORD dwColor )
{
    // Set the line width
    m_pD3DDevice->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth );

    UDTEXTURE_VERTEX* pb = NULL;

    m_pVertexBuffer->Lock( 0, 0, (BYTE**)&pb, 0 );

    pb[0].v.x = fX1;  pb[0].v.y = fY1; pb[0].v.z = .1f;  pb[0].fRHW = .9f;  pb[0].cDiffuse = dwColor;
	pb[1].v.x = fX2;  pb[1].v.y = fY2; pb[1].v.z = .1f;  pb[1].fRHW = .9f;  pb[1].cDiffuse = dwColor;

    m_pVertexBuffer->Unlock();

    m_pD3DDevice->DrawPrimitive( D3DPT_LINELIST, 0, 1 );
}


// Draw an outline to the texture
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      borderSize     --- width in pixels of the border
//      color          --- the RGBA color to draw the box with
void CUDTexture::DrawOutline( float fX1, float fY1, float fX2, float fY2, float fLineWidth, DWORD dwColor )
{
    // Draw the box on the Texture
    DrawLine( fX1, fY1, fX1, fY2, fLineWidth, dwColor );     // Left Line
    DrawLine( fX1, fY2, fX2, fY2, fLineWidth, dwColor );     // Bottom Line
    DrawLine( fX2, fY2, fX2, fY1, fLineWidth, dwColor );     // Right Line
    DrawLine( fX2, fY1, fX1, fY1, fLineWidth, dwColor );     // Top Line
}


// Prints formatted text using the default font to the texture
void CUDTexture::DrawText( float fX1, float fY1, DWORD dwFGColor, DWORD dwBGColor, const WCHAR* pwszFormat, ... )
{
	va_list ArgList;        // Argument List
    WCHAR wpszStr[256];     // Honkin Buffer

    va_start( ArgList, pwszFormat );

    XFONT_SetTextColor( g_pFont, dwFGColor );
    XFONT_SetBkColor( g_pFont, dwBGColor );

    // Create the formated string to place on to the surface
    int i = wvsprintfW( wpszStr, pwszFormat, ArgList );

    XFONT_TextOut( g_pFont, m_pTextureSurface, wpszStr, i, (long)fX1, (long)fY1 );

	va_end( ArgList );
}


// Prints formatted text using the default font to the texture
void CUDTexture::DrawText( XFONT* pXFont, float fX1, float fY1, DWORD dwFGColor, DWORD dwBGColor, const WCHAR* pwszFormat, ... )
{
    if( NULL == pXFont )
        pXFont = g_pFont;

	va_list ArgList;        // Argument List
    WCHAR wpszStr[256];     // Honkin Buffer

    va_start( ArgList, pwszFormat );

    XFONT_SetTextColor( pXFont, dwFGColor );
    XFONT_SetBkColor( pXFont, dwBGColor );

    // Create the formated string to place on to the surface
    int i = wvsprintfW( wpszStr, pwszFormat, ArgList );

    XFONT_TextOut( pXFont, m_pTextureSurface, wpszStr, i, (long)fX1, (long)fY1 );

	va_end( ArgList );
}


// Lock the texture surface so that we can render on to it
void CUDTexture::Lock()
{
    ++m_uiTextureLockedRef; // Increment our Reference count
    if( m_uiTextureLockedRef > 1 )
    {
        // Return if we've been previously locked
        return;
    }

    // Get the current render target so that we can replace it
    // after we render to our texture
    m_pD3DDevice->GetRenderTarget( &m_pCurrentRenderTarget );

    // Get the current stream source and stride so that we can replace it
    // after we finish rendering to our texture
    m_pD3DDevice->GetStreamSource( 0, &m_pCurrentVBuffer, &m_uiCurrentStride );

    if( m_pTextureSurface )
    {
        // Set our Texture surface to be our render target for all our primitive calls
        m_pD3DDevice->SetRenderTarget( m_pTextureSurface, NULL );

        // Set our stream source to be from our Vertex Buffer
        m_pD3DDevice->SetStreamSource( 0, m_pVertexBuffer, sizeof( UDTEXTURE_VERTEX ) );

        m_pD3DDevice->SetVertexShader( D3DFVF_UDTEXTURE_VERTEX );
    }
}


// Unlock the texture surface after we have rendered to it
void CUDTexture::Unlock()
{
    if( m_uiTextureLockedRef > 0 )
    {
        --m_uiTextureLockedRef; // Decrement our Reference count

        // If we are not at 0, we should return, otherwise clean up
        if( m_uiTextureLockedRef > 0 )
        {
            return;
        }
    }
    else // We must not have been locked, so simply return
    {
        return;
    }

    // Restore the original render target
    if( m_pCurrentRenderTarget )
    {
        m_pD3DDevice->SetRenderTarget( m_pCurrentRenderTarget, NULL );
        
        m_pCurrentRenderTarget->Release();
        m_pCurrentRenderTarget = NULL;
    }

    // Restore the original stream source
    if( m_pCurrentVBuffer )
    {
        m_pD3DDevice->SetStreamSource( 0, m_pCurrentVBuffer, m_uiCurrentStride );

        m_pCurrentVBuffer->Release();
        m_pCurrentVBuffer = NULL;
    }
}


// Initialize D3D for this screen
void CUDTexture::Initialize( IDirect3DDevice8* pD3DDevice, char* pszFileName=NULL, int iTextureWidth=512, int iTextureHeight=512 )
{
    XDBGTRC( MENUS_APP_TITLE_NAME_A, "CUDTexture::Initialize()" );

    // Make sure we don't leak
    CleanUp();

    // pD3DDevice->AddRef();
    m_pD3DDevice = pD3DDevice;
    m_iTextureWidth = iTextureWidth;
    m_iTextureHeight = iTextureHeight;

    /////////////////////
    // Create our texture
    /////////////////////
    if( NULL != pszFileName )
    {
        XDBGTRC( MENUS_APP_TITLE_NAME_A, "CUDTexture::Initialize():Create Texture From File..." );
        D3DXCreateTextureFromFileExA( m_pD3DDevice, 
                                      pszFileName,
                                      D3DX_DEFAULT,    // width
                                      D3DX_DEFAULT,    // height
                                      D3DX_DEFAULT,    // mips number
                                      0,
                                      D3DFMT_A8R8G8B8,
                                      D3DPOOL_MANAGED,
                                      D3DX_FILTER_LINEAR,
                                      D3DX_FILTER_LINEAR,
                                      0,
                                      NULL,
                                      NULL,
                                        &m_pTexture );
    }
    else
    {
        XDBGTRC( MENUS_APP_TITLE_NAME_A, "CUDTexture::Initialize():User Created Texture..." );
        m_pD3DDevice->CreateTexture( m_iTextureWidth,
                                     m_iTextureHeight,
                                     0,
                                     D3DUSAGE_RENDERTARGET,
                                     D3DFMT_LIN_A8R8G8B8, //D3DFMT_LIN_X8R8G8B8,
                                     0,
                                     &m_pTexture );
    }

    ///////////////////////////////
    // Get our surface from texture
    ///////////////////////////////
    XDBGTRC( MENUS_APP_TITLE_NAME_A, "CUDTexture::Initialize():Moving the Texture Surface to Video Memory..." );
    m_pTexture->MoveResourceMemory( D3DMEM_VIDEO );

    XDBGTRC( MENUS_APP_TITLE_NAME_A, "CUDTexture::Initialize():Getting the Texture Surface..." );
    m_pTexture->GetSurfaceLevel( 0, &m_pTextureSurface );


    ///////////////////////////////
    // Create a Vertex Buffer for
    // our Primitive Calls
    ///////////////////////////////
    XDBGTRC( MENUS_APP_TITLE_NAME_A, "CUDTexture::Initialize():Creating our Vertex Buffer..." );
    m_pD3DDevice->CreateVertexBuffer( sizeof( UDTEXTURE_VERTEX ) * 4, 0, 0, 0, &m_pVertexBuffer );

    XDBGTRC( MENUS_APP_TITLE_NAME_A, "CUDTexture::Initialize():Done Initialization." );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\wavemedia\wavemedia.cpp ===
/*****************************************************
*** wavemedia.cpp
***
*** CPP file for a WAV file media object.  This class
*** will allow a user to specify the DirectSound
*** pointer, and a WAV file name, and will allow
*** the user to playback the sound
***
*** by James N. Helm
*** May 25th, 2001
***
*****************************************************/

#include "wavempch.h"
#include "wavemedia.h"

// Constructor
CWaveMedia::CWaveMedia()
: m_pDSound( NULL ),
m_pDSoundBuffer( NULL ),
m_pFMOFile( NULL ),
m_pszWaveFileName( NULL ),
m_lVolume( 0 ),
m_bInitialized( FALSE )
{
    // Zero Out our local object memory
    ZeroMemory( &m_xmp, sizeof( XMEDIAPACKET ) );
}

// Destructor
CWaveMedia::~CWaveMedia()
{
    CleanUp();
}


// Used to cleanup (de-initialize) the object
void CWaveMedia::CleanUp()
{
    XDBGWRN( WAVEM_APP_TITLE_NAME_A, "CWaveMedia::CleanUp()" );

    // Clean up the Wave File name store locally
    if( m_pszWaveFileName )
    {
        delete[] m_pszWaveFileName;
        m_pszWaveFileName = NULL;
    }

    // Clean up our DSound buffer if it was allocated
    if( m_pDSoundBuffer )
    {
        m_pDSoundBuffer->Release();
        m_pDSoundBuffer = NULL;
    }

    // Clean up our WAV Data
    if( m_xmp.pvBuffer )
    {
        delete[] m_xmp.pvBuffer;
        m_xmp.pvBuffer = NULL;
    }
    
    // Release the DSound object
    if( m_pDSound )
    {
        m_pDSound->Release();
        m_pDSound = NULL;
    }

    m_bInitialized = FALSE;
}


// Initialize the Wave Media Object
BOOL CWaveMedia::Init( LPDIRECTSOUND pDSound, char* pszWaveFileName, LONG lDefaultVolume/*=0*/ )
{
    if( m_bInitialized )
    {
        XDBGWRN( WAVEM_APP_TITLE_NAME_A, "CWaveMedia::Init():Already Initialized!!" );

        return FALSE;
    }

    if( !pDSound || !pszWaveFileName )
    {
        XDBGWRN( WAVEM_APP_TITLE_NAME_A, "CWaveMedia::Init():Parameters were invalid!!" );

        return FALSE;
    }

    m_bInitialized = TRUE;

    m_pDSound = pDSound;
    m_pDSound->AddRef();

    int iStrLen = strlen( pszWaveFileName );
    m_pszWaveFileName = new char[iStrLen + 1];
    if( !m_pszWaveFileName )
    {
        XDBGWRN( WAVEM_APP_TITLE_NAME_A, "CWaveMedia::Init():Failed to allocate memory for our WAV File Name!!" );

        return FALSE;
    }
    else
    {
        ZeroMemory( m_pszWaveFileName, iStrLen + 1 );
        strcpy( m_pszWaveFileName, pszWaveFileName );
    }

    m_lVolume = lDefaultVolume;

    BOOL bReturn;
    if( bReturn = ProcessWaveFile() )
    {
        SetVolume( m_lVolume );
    }

    return bReturn;
}


// Load the WAV file in to a local DSound Buffer
BOOL CWaveMedia::ProcessWaveFile()
{
    DSBUFFERDESC    dsbd;
	LPCWAVEFORMATEX pWfx = NULL;

    ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );

    // Create the File Media Object
    if( FAILED( XWaveFileCreateMediaObject( m_pszWaveFileName, &pWfx, &m_pFMOFile ) ) )
    {
        XDBGWRN( WAVEM_APP_TITLE_NAME_A, "CWaveMedia::ProcessWaveFile():XWaveFileCreateMediaObject Failed!!" );

        return FALSE;
    }

    dsbd.dwSize = sizeof( DSBUFFERDESC );
	dsbd.lpwfxFormat = (LPWAVEFORMATEX) pWfx;

    // Create the DSound Buffer
    if( FAILED( m_pDSound->CreateSoundBuffer( &dsbd, &m_pDSoundBuffer, NULL ) ) )
    {
        XDBGWRN( WAVEM_APP_TITLE_NAME_A, "CWaveMedia::ProcessWaveFile():CreateSoundBuffer Failed!!" );

        return FALSE;
    }

    // Get the length of the media file
    if( FAILED( m_pFMOFile->GetLength( &m_xmp.dwMaxSize ) ) )
    {
        XDBGWRN( WAVEM_APP_TITLE_NAME_A, "CWaveMedia::ProcessWaveFile():GetLength Failed!!" );

        return FALSE;
    }

	//
	// Create a buffer of the size of the length
	//
    m_xmp.pvBuffer = new BYTE[ m_xmp.dwMaxSize ];
    if( !m_xmp.pvBuffer )
    {
        XDBGWRN( WAVEM_APP_TITLE_NAME_A, "CWaveMedia::ProcessWaveFile():Failed to allocate memory for our Buffer!!" );

        return FALSE;
    }

	//
	// Precache out the buffer data
	//
    if( FAILED( m_pFMOFile->Process( NULL, &m_xmp ) ) )
    {
        XDBGWRN( WAVEM_APP_TITLE_NAME_A, "CWaveMedia::ProcessWaveFile():Process Failed!!" );

        return FALSE;
    }

    //
    // Set the buffer data
    //
    if( FAILED( m_pDSoundBuffer->SetBufferData( m_xmp.pvBuffer, m_xmp.dwMaxSize ) ) )
    {
        XDBGWRN( WAVEM_APP_TITLE_NAME_A, "CWaveMedia::ProcessWaveFile():SetBufferData Failed!!" );

        return FALSE;
    }


    return TRUE;
}


// Returns TRUE if the sound is currently playing
BOOL CWaveMedia::IsPlaying()
{
    if( FALSE == m_bInitialized )
    {
        XDBGWRN( WAVEM_APP_TITLE_NAME_A, "CWaveMedia::IsPlaying():Cannot play sound until object is initialized!!" );

        return FALSE;
    }

    DWORD dwSoundStatus = 0;

    HRESULT hr = m_pDSoundBuffer->GetStatus( &dwSoundStatus );
    if( FAILED( hr ) )
    {
        XDBGWRN( WAVEM_APP_TITLE_NAME_A, "CWaveMedia::IsPlaying():There was a problem getting the status of the sound!!" );

        return FALSE;
    }

    BOOL bReturn = FALSE;
    // Check to see if the sound is still playing
    if( dwSoundStatus & DSBSTATUS_PLAYING )
    {
        return TRUE;
    }

    return bReturn;
}


// Set the volume of the WAV file
void CWaveMedia::SetVolume( LONG lVolume )
{
    if( FALSE == m_bInitialized )
    {
        XDBGWRN( WAVEM_APP_TITLE_NAME_A, "CWaveMedia::SetVolume():Cannot set the volume until object is initialized!!" );

        return;
    }

    m_lVolume = lVolume;

    HRESULT hr = m_pDSoundBuffer->SetVolume( m_lVolume ); 
    if( FAILED( hr ) )
    {
        XDBGWRN( WAVEM_APP_TITLE_NAME_A, "CWaveMedia::SetVolume():Failed to set the volume for the sound!! Vol - '%d', Error - '0x%.8X (%d)'", m_lVolume, hr, hr );
    }
}


// Play the WAV file
void CWaveMedia::Play()
{
    if( FALSE == m_bInitialized )
    {
        XDBGWRN( WAVEM_APP_TITLE_NAME_A, "CWaveMedia::Play():Cannot play sound until object is initialized!!" );

        return;
    }

    ResetToBeginning();
    m_pDSoundBuffer->Play( 0, 0, 0 );
}


// Stop Playing the WAV file
void CWaveMedia::Stop()
{
    if( FALSE == m_bInitialized )
    {
        XDBGWRN( WAVEM_APP_TITLE_NAME_A, "CWaveMedia::Stop():Cannot stop sound until object is initialized!!" );

        return;
    }

    m_pDSoundBuffer->Stop();
}


// Reset the WAV File Play pointer to the beginning of the wave
void CWaveMedia::ResetToBeginning()
{
    if( FALSE == m_bInitialized )
    {
        XDBGWRN( WAVEM_APP_TITLE_NAME_A, "CWaveMedia::ResetToBeginning():Cannot ResetToBeginning sound until object is initialized!!" );

        return;
    }

    m_pDSoundBuffer->SetCurrentPosition( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\usbmanager\usbpch.h ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    usbpch.h

Abstract:

    precompiled header for usb manager library.

--*/

#ifndef _USBPCH_H_
#define _USBPCH_H_

#include <xtl.h>
#include <xboxp.h>
#include <xdbg.h>

#endif // _USBPCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\memoryareas\memoryunit.cpp ===
/*****************************************************
*** memoryunit.cpp
***
*** CPP file for our Memory Unit class.
*** This class will contain functions and information
*** pertaining to an Xbox Memory Unit
***
*** by James N. Helm
*** March 28th, 2001
***
*****************************************************/

#include "memarpch.h"
#include "memoryunit.h"

// Contructors and Destructor
CMemoryUnit::CMemoryUnit()
: CMemoryArea(),
m_pwszMUName( NULL ),
m_bMounted( FALSE ),
m_bFormatted( FALSE ),
m_dwPort( 0 ),
m_dwSlot( 0 )
{
}


CMemoryUnit::~CMemoryUnit()
{
    // If we have set the name, let's clean up the memory
    if( m_pwszMUName )
    {
        delete[] m_pwszMUName;
        m_pwszMUName = NULL;
    }
}


// Format the Memory Unit
HRESULT CMemoryUnit::Format( BOOL bMount/*=FALSE*/ )
{
    // Format the MU
    ANSI_STRING ostMU;
    char pszMU[64];
    ostMU.Length = 0;
    ostMU.MaximumLength = 63;
    ostMU.Buffer = pszMU;

    // Check to see if the MU is mounted.  If it is, we MUST unmount it BEFORE we format it
    if( IsMounted() )
    {
        if( FAILED( Unmount() ) )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::Format():Failed to Unmount the MU!!" );

            return E_FAIL;
        }
    }

    // Open the MU
    BOOL bFormatSuccessful = FALSE;
    if( NT_SUCCESS( MU_CreateDeviceObject( m_dwPort, m_dwSlot, &ostMU ) ) )
    //
    // We created the device object, begin the format
    //
    {
        // Perform the format
        bFormatSuccessful = XapiFormatFATVolume( &ostMU );

        // Close the MU
        MU_CloseDeviceObject( m_dwPort, m_dwSlot );
    }
    else
    //
    // There was a problem creating the device object
    //
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::Format():Failed to MU_CreateDeviceObject the MU!! - '%d', '%d'", m_dwPort, m_dwSlot );
    }

    if( !bFormatSuccessful )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::Format():The Format Failed!!" );

        return E_FAIL;
    }

    // Check to see if our MU should be mounted, and if so, Mount it
    if( bMount )
    {
        if( FAILED( Mount() ) )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::Format():Failed to Mount the newly formatted MU!!" );
        }
    }

    return S_OK;
}


#define EXTRA_SIZE 4096
#define SECTOR_MASK 0xFFFFFF000
#define TEST_BUFFER_SIZE (4096*2)    //8KB
#define MU_MEDIA_OFFSET  0

// Unformat the Memory Unit
HRESULT CMemoryUnit::Unformat()
{
    OBJECT_ATTRIBUTES oa;
    HANDLE hVolume;
    IO_STATUS_BLOCK statusBlock;
    ANSI_STRING ostMU;
    unsigned char* pBuffer1;
    char pszMU[64];
    ostMU.Length = 0;
    ostMU.MaximumLength = 63;
    ostMU.Buffer = pszMU;
    HRESULT hr = S_OK;          // Return value

    // Unmount the MU if it is currently mounted
    if( IsMounted() )
    {
        if( FAILED( Unmount() ) )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::Unformat():Failed to Unmount the MU!!" );

            return E_FAIL;
        }
    }


    // Open the MU
    if( NT_SUCCESS( MU_CreateDeviceObject( m_dwPort, m_dwSlot, &ostMU ) ) )
    //
    // The device object was created successfully
    //
    {
        unsigned char* pTemp = pBuffer1 = (unsigned char*) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, TEST_BUFFER_SIZE+EXTRA_SIZE );

        pBuffer1 = (unsigned char*)((ULONG) pBuffer1 & SECTOR_MASK);
        pBuffer1 += EXTRA_SIZE;

        //
        // fill the buffer with a pattern
        //
        memset( pBuffer1, 0xFF, TEST_BUFFER_SIZE );

        InitializeObjectAttributes(&oa, (POBJECT_STRING) &ostMU, OBJ_CASE_INSENSITIVE, NULL, NULL);

        NTSTATUS status = NtOpenFile(&hVolume,
                                     SYNCHRONIZE | GENERIC_ALL,
                                     &oa,
                                     &statusBlock,
                                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                                     FILE_NO_INTERMEDIATE_BUFFERING | FILE_SYNCHRONOUS_IO_ALERT);

        if( NT_SUCCESS( status ) )
        //
        // We opened the file (volume) successfully, let's "unformat" it by writing our data to it
        //
        {
            LARGE_INTEGER offset;
            offset.QuadPart = MU_MEDIA_OFFSET;

            status = NtWriteFile(hVolume,
                                 0,
                                 NULL,
                                 NULL,
                                 &statusBlock,
                                 pBuffer1,
                                 TEST_BUFFER_SIZE,
                                 &offset );

            //
            // Dismount the file system
            //
            NtFsControlFile(hVolume, NULL, NULL, NULL, &statusBlock,
                FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0);


            //
            //  Close the volume
            //
            NtClose(hVolume);

            // Free our allocated memory
            LocalFree( pTemp );
        }
        else
        //
        // We failed to open the file (volume)
        //
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::Unformat():Failed NtOpenFile!!" );

            hr = E_FAIL;
        }

        // Close the MU
        MU_CloseDeviceObject( m_dwPort, m_dwSlot );
    }
    else
    //
    // We failed to create the Device object, we can't unformat the MU
    //
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::Unformat():Failed to MU_CreateDeviceObject the MU!! - '%d', '%d'", m_dwPort, m_dwSlot );

        hr = E_FAIL;
    }

    return hr;
}


// Mount the Memory Unit
HRESULT CMemoryUnit::Mount( BOOL bAsGameTitle/*=FALSE*/ )
{
    // If the MU is already mounted, unmount it
    if( IsMounted() )
    {
        if( FAILED( Unmount() ) )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::Mount():Failed to Unmount the MU!!" );

            return E_FAIL;
        }
    }

    // Mount the MU
    DWORD dwReturnVal = 0;
    if( !bAsGameTitle )
        dwReturnVal = XMountMURoot( m_dwPort, m_dwSlot, &m_cUDataDriveLetter );
    else
        dwReturnVal = XMountMU( m_dwPort, m_dwSlot, &m_cUDataDriveLetter );

    if( ERROR_SUCCESS != dwReturnVal )
    //
    // There was a problem mounting the MU
    //
    {
        // Check to see if the failure was the result of an unformatted MU
        // If so, mark this MU as Unformatted
        if( ERROR_UNRECOGNIZED_VOLUME == dwReturnVal )
        //
        // Yes, the MU was unformatted, which caused the Mount Failure
        //
        {
            XDBGTRC( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::Mount():Failed to Mount the MU, it was unformatted!! - '0x%0.8X (%d)'", dwReturnVal, dwReturnVal );

            m_bFormatted = FALSE;
        }
        else
        //
        // There was an error trying to mount, other than "not formatted"
        //
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::Mount():Failed to Mount the MU!! - '0x%0.8X (%d)'", dwReturnVal, dwReturnVal );
        }


        return E_FAIL;
    }
    else
    //
    // The MU was mounted successfully
    //
    {
        m_bMounted = TRUE;
        m_bFormatted = TRUE;
    }

    HRESULT hr = ProcessMountedMU();

    return hr;
}


// Unmount the Memory Unit
HRESULT CMemoryUnit::Unmount()
{
    // Verify the MU was mounted, if not, bail
    if( !IsMounted() )
    {
        return E_ABORT;
    }

    // Unmount the MU
    DWORD dwReturnVal = XUnmountMU( m_dwPort, m_dwSlot );
    if( ERROR_SUCCESS != dwReturnVal )
    //
    // There was a problem unmounting the MU
    //
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::Unmount():Failed to Unmount the MU!! - '%X'", dwReturnVal );

        return E_FAIL;
    }
    else
    //
    // The MU was unmounted successfully
    {
        m_bMounted = FALSE;
        m_bFormatted = FALSE;
    }

    // Clear out the MU Name
    if( m_pwszMUName )
    {
        delete[] m_pwszMUName;
        m_pwszMUName = NULL;
    }

    // Reset the MU Drive Letter
    m_cUDataDriveLetter = '\0';

    return S_OK;
}


// Refresh the name of the Memory Unit (it could change)
HRESULT CMemoryUnit::RefreshName()
{
    // If we have set the name, let's clean up the memory
    if( m_pwszMUName )
    {
        delete[] m_pwszMUName;
        m_pwszMUName = NULL;
    }

    // Get the name of the MU
    WCHAR pwszMUName[MAX_MUNAME + 1];
    ZeroMemory( pwszMUName, sizeof( WCHAR ) * MAX_MUNAME + 1 );

    DWORD dwReturnVal = XMUNameFromDriveLetter( m_cUDataDriveLetter, pwszMUName, MAX_MUNAME );
    if( ERROR_SUCCESS != dwReturnVal )
    // There was a problem getting the MU Name
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::RefreshName():Failed to Get the MU Name!! - '0x%08X (%d)'", dwReturnVal, dwReturnVal );
    }
    else    // We got the MU Name, let's copy it to our own memory
    {
        unsigned int uiStrLen = wcslen( pwszMUName );
        m_pwszMUName = new WCHAR[uiStrLen + 1];
        if( NULL == m_pwszMUName )
        {
            XDBGERR( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::RefreshName():Failed to Allocate Memory!!" );
            return E_FAIL;
        }

        wcscpy( m_pwszMUName, pwszMUName );
    }

    return S_OK;
}

// Name the Memory Unit
HRESULT CMemoryUnit::Name( WCHAR* wpszName )
{
    if( !wpszName )
    {
        return E_INVALIDARG;
    }

    if( wcslen( wpszName ) >= MAX_MUNAME )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::Name():Name to long!! Length - '%d', Max Length - '%d'", wcslen( wpszName ), MAX_MUNAME - 1 );

        return E_INVALIDARG;
    }

    // If we have set the name, let's clean up the memory
    if( m_pwszMUName )
    {
        delete[] m_pwszMUName;
        m_pwszMUName = NULL;
    }

    // Write the MU Name to the Drive Letter
    HRESULT hr = S_OK;

    DWORD dwRetVal = XMUWriteNameToDriveLetter( GetUDataDrive(), wpszName );
    if( ERROR_SUCCESS != dwRetVal )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::Name():Failed to Write the MU Name!! - '0x%X.8'", dwRetVal );

        hr = E_FAIL;
    }
    else
    {
        unsigned int uiStrLen = wcslen( wpszName );
        m_pwszMUName = new WCHAR[uiStrLen + 1];
        if( NULL == m_pwszMUName )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::Name():Failed to allocate memory!!" );

            hr = E_OUTOFMEMORY;
        }
        else
        {
            m_pwszMUName[uiStrLen] = '\0';

            wcscpy( m_pwszMUName, wpszName );
        }
    }

    return hr;
}


// Get the total number of blocks on the MU
DWORD CMemoryUnit::GetTotalBlocks()
{
    // Check to see if the MU is mounted, if not, return 0
    if( !IsMounted() )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::GetTotalBlocks():The MU was not mounted -- Cannot retrieve space information!!" );

        return 0;
    }

    return CMemoryArea::GetTotalBlocks();
}


// Get the number of blocks that are free on the MU
DWORD CMemoryUnit::GetFreeBlocks()
{
    // Check to see if the MU is mounted, if not, return 0
    if( !IsMounted() )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::GetFreeBlocks():The MU was not mounted -- Cannot retrieve space information!!" );

        return 0;
    }

    return CMemoryArea::GetFreeBlocks();
}


// Get the current MU Name
HRESULT CMemoryUnit::GetName( WCHAR* wpszNameBuffer, unsigned int uiBufSize )
{
    // Check to make sure a valid parameter was passed in
    if( !wpszNameBuffer )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::GetName():Invalid parameter passed in!!" );

        return E_INVALIDARG;
    }

    // Set the return buffer to Nothing
    wpszNameBuffer[0] = L'\0';

    // Check to make sure this MU has a name, otherwise do nothing and return
    if( m_pwszMUName )
    //
    // Yes, this MU has a name
    //
    {
        // Copy the current name to the callers buffer (lstrcpynW always null
        // terminates the buffer unlike wcsncpy)
        lstrcpynW( wpszNameBuffer, m_pwszMUName, uiBufSize );
    }

    return S_OK;
}


// Set the port and the slot this MU will be on
HRESULT CMemoryUnit::SetPortSlot( DWORD dwPort, DWORD dwSlot )
{
    // Check to make sure the parameters are withing the valid range
    if( ( dwPort < XDEVICE_PORT0 ) ||
        ( dwPort > XDEVICE_PORT3 ) ||
        ( ( dwSlot != XDEVICE_TOP_SLOT ) && ( dwSlot != XDEVICE_BOTTOM_SLOT ) ) )
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::SetPortSlot():Invalid parameter!!" );

        return E_INVALIDARG;
    }

    // We add 4 characters to fit the space, number/letter combo, and the NULL
    unsigned int uiStrLen = wcslen( MEMORY_UNIT_NAME_PATTERN ) + 4;
    WCHAR* pwszDefName = new WCHAR[uiStrLen];
    if( NULL != pwszDefName )
    {
        ZeroMemory( pwszDefName, sizeof( WCHAR ) * uiStrLen );

        swprintf( pwszDefName, L"%ls %c%c", MEMORY_UNIT_NAME_PATTERN, ( dwPort + 1 ) + '0', XDEVICE_TOP_SLOT == dwSlot ? 'A' : 'B' );

        XDBGTRC( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::SetPortSlot():Default Name - '%ls'", pwszDefName );

        HRESULT hr = SetDefaultName( pwszDefName );
        if( FAILED( hr ) )
        {
            XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::SetPortSlot():Failed to set the default name!! - '%s', '0x%.8X (%d)'", pwszDefName, hr, hr );
        }

        // Clean up
        delete[] pwszDefName;
        pwszDefName = NULL;
    }
    else
    //
    // We failed to allocate memory for our Temp Default Name var
    //
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::SetPortSlot():Failed to allocate memory for our Default Name!!" );
    }

    m_dwPort = dwPort;
    m_dwSlot = dwSlot;

    return S_OK;
}

// Used to determine if the MU is named
BOOL CMemoryUnit::IsNamed()
{
    if( ( NULL != m_pwszMUName ) && ( L'\0' != m_pwszMUName[0] ) )
    {
        return TRUE;
    }

    return FALSE;
}


// Get the Index of the current MU
unsigned int CMemoryUnit::GetIndex()
{
    return ( ( m_dwPort * 2 ) + ( m_dwSlot ) );
}


// Process a mounted MU (Get the name, etc)
HRESULT CMemoryUnit::ProcessMountedMU()
{
    // Get the name of the MU
    WCHAR pwszMUName[MAX_MUNAME + 1];
    ZeroMemory( pwszMUName, sizeof( WCHAR ) * MAX_MUNAME + 1 );

    DWORD dwReturnVal = XMUNameFromDriveLetter( m_cUDataDriveLetter, pwszMUName, MAX_MUNAME );
    if( ERROR_SUCCESS != dwReturnVal )
    // There was a problem getting the MU Name
    {
        XDBGWRN( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::ProcessMountedMU():Failed to Get the MU Name!! - '0x%.8X (%d)'", dwReturnVal, dwReturnVal );
    }
    else    // We got the MU Name, let's copy it to our own memory
    {
        unsigned int uiStrLen = wcslen( pwszMUName );
        m_pwszMUName = new WCHAR[uiStrLen + 1];
        if( NULL == m_pwszMUName )
        {
            XDBGERR( MEMAREA_APP_TITLE_NAME_A, "CMemoryUnit::ProcessMountedMU():Failed to Allocate Memory!!" );

            return E_FAIL;
        }

        wcscpy( m_pwszMUName, pwszMUName );
    }

    return S_OK;
}


// Map the UDATA drive to it's orignal location
HRESULT CMemoryUnit::MapUDataToOrigLoc()
{
    Unmount();
    Mount();

    return S_OK;
}


// Map the UDATA drive letter to the specified Title ID and Mount the MU
HRESULT CMemoryUnit::MapUDataToTitleID( char* pszTitleID )
{
    if( NULL == pszTitleID )
    {
        return E_INVALIDARG;
    }

    // Store our current Title ID, so we can set this to be correct when we are finished
    DWORD dwOriginalTitleID = XeImageHeader()->Certificate->TitleID;

    // Convert the passed in String to a DWORD
    DWORD dwTitleID = strtoul( pszTitleID, NULL, 16 );
    XeImageHeader()->Certificate->TitleID = dwTitleID;

    // Mount the MU as the Title
    HRESULT hr = Mount( TRUE );

    // Set the TitleID back to it's original value
    XeImageHeader()->Certificate->TitleID = dwOriginalTitleID;

    return hr;
}


// Map the UDATA drive letter to the specified Title ID and Mount the MU
HRESULT CMemoryUnit::MapUDataToTitleID( WCHAR* pwszTitleID )
{
    if( NULL == pwszTitleID )
    {
        return E_INVALIDARG;
    }

    // Store our current Title ID, so we can set this to be correct when we are finished
    DWORD dwOriginalTitleID = XeImageHeader()->Certificate->TitleID;

    // Convert the passed in String to a DWORD
    DWORD dwTitleID = wcstoul( pwszTitleID, NULL, 16 );
    XeImageHeader()->Certificate->TitleID = dwTitleID;

    // Mount the MU as the Title
    HRESULT hr = Mount( TRUE );

    // Set the TitleID back to it's original value
    XeImageHeader()->Certificate->TitleID = dwOriginalTitleID;

    return hr;
}


// Map the UDATA drive letter to the specified Title ID and Mount the MU
HRESULT CMemoryUnit::MapUDataToTitleID( DWORD dwTitleID )
{
    // Store our current Title ID, so we can set this to be correct when we are finished
    DWORD dwOriginalTitleID = XeImageHeader()->Certificate->TitleID;

    XeImageHeader()->Certificate->TitleID = dwTitleID;

    HRESULT hr = Mount( TRUE );

    // Set the TitleID back to it's original value
    XeImageHeader()->Certificate->TitleID = dwOriginalTitleID;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\usbmanager\usbmanager.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.cpp

Abstract:


Author:

    Josh Poley (jpoley)

Environment:

    Xbox

Revision History:
    07-20-2000  Created
    01-13-2000  Modified   JNH

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#include "usbpch.h"
#include "usbmanager.h"

// Threshold for analog buttons
#define XINPUT_ANALOGBUTTONTHRESHOLD 32

DWORD XIDMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
};

DWORD XMUMasks[] = {
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_TOP_MASK,
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT3_BOTTOM_MASK
};


USBManager::USBManager()
{
    DWORD insertions;
    // DWORD insertions2;
    unsigned i, j;
    unsigned port;
    // unsigned slot;

    //Initialize core peripheral port support
    XInitDevices( 0, NULL );

    pollingParameters.fAutoPoll       = 1;
    pollingParameters.fInterruptOut   = 0;
    pollingParameters.ReservedMBZ1    = 0;
    pollingParameters.bInputInterval  = 8;
    pollingParameters.bOutputInterval = 8;
    pollingParameters.ReservedMBZ2    = 0;

    if( ARRAYSIZE( XIDMasks ) != XGetPortCount() )
    {
        XDBGWRN( USBM_APP_TITLE_NAME_A, "USBManager::USBManager():XIDMasks != XGetPortCount!!" );
        XDBGWRN( USBM_APP_TITLE_NAME_A, "USBManager::USBManager():Will break in to debugger in 60 seconds..." );

        Sleep( 60000 );
        BREAK_INTO_DEBUGGER;
    }

    // initialize
    for( i = 0; i < XGetPortCount(); ++i )
    {
        for( j = 0; j < SLOT_MAX; ++j )
        {
            devices[i][j] = NULL;
            packetNum[i][j] = 1234;
        }
    }

    // look for game pads
    insertions = XGetDevices( XDEVICE_TYPE_GAMEPAD );
    for( i = 0; i < XGetPortCount(); ++i )
    {
        port = i % XGetPortCount();
        if( insertions & XIDMasks[i] )
        {
            XDBGTRC( USBM_APP_TITLE_NAME_A, "USBManager::USBManager():GAMEPAD found on port - '%d'", port );

            devices[i][0] = new DeviceDuke(port, 0, &pollingParameters);

            // Make sure there wasn't a problem inserting the Duke
            if( !((DeviceDuke*)devices[i][0])->m_hDuke )
            {
                delete (DeviceDuke*)devices[i][0];
                devices[i][0] = NULL;
            }
        }
    }

    // look for remote control
    insertions = XGetDevices( XDEVICE_TYPE_IR_REMOTE );
    for( i = 0; i < XGetPortCount(); ++i )
    {
        port = i % XGetPortCount();
        if( insertions & XIDMasks[i] )
        {
            XDBGTRC( USBM_APP_TITLE_NAME_A, "USBManager::USBManager():REMOTE found on port - '%d'", port );
            devices[i][0] = new DeviceRemote( port, 0 );

            // Make sure there wasn't a problem inserting the Remote
            if( !((DeviceRemote*)devices[i][0])->m_hRemote )
            {
                XDBGWRN( USBM_APP_TITLE_NAME_A, "USBManager::USBManager():REMOTE insert problem on port - '%d'", port );

                delete (DeviceRemote*)devices[i][0];
                devices[i][0] = NULL;
            }
        }
    }

    // Initialize our Thread Handles (for our Rumble Thread)
    for( i = 0; i < 4; i++ )
    {
        m_hThreads[i] = NULL;
    }

    ZeroMemory( &m_RumbleInfo[0], sizeof( m_RumbleInfo[0] ) * 4 );
}


USBManager::~USBManager()
{
    unsigned i, j;

    for(i=0; i<XGetPortCount(); i++)
    {
        for(j=0; j<SLOT_MAX; j++)
        {
            if(devices[i][j] != NULL)
            {
                if( XDEVICE_TYPE_GAMEPAD == devices[i][j]->m_type )
                {
                    XDBGTRC( USBM_APP_TITLE_NAME_A, "USBManager::~USBManager():GAMEPAD being deleted from port - '%d'", i );

                    delete (DeviceDuke*)devices[i][j];
                }
                else if( XDEVICE_TYPE_IR_REMOTE == devices[i][j]->m_type )
                {
                    XDBGTRC( USBM_APP_TITLE_NAME_A, "USBManager::~USBManager():REMOTE being deleted from port - '%d'", i );

                    delete (DeviceRemote*)devices[i][j];
                }

                devices[i][j] = NULL;
            }
        }
    }
}


void USBManager::CheckForHotplugs( void )
{
    DWORD addDuke, removeDuke;
    DWORD addRemote, removeRemote;
    // unsigned slot;
    unsigned port;
    unsigned i;

    // check for game controllers (insert & removal)
    XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &addDuke, &removeDuke );

    for( i=0; i < XGetPortCount(); i++ )
    {
        port = i % XGetPortCount();

        if( removeDuke & XIDMasks[i] )
        {
            XDBGTRC( USBM_APP_TITLE_NAME_A, "USBManager::USBManager():GAMEPAD removed from port - '%d'", port );

            delete (DeviceDuke*)devices[i][0];
            devices[i][0] = NULL;
        }

        if( addDuke & XIDMasks[i] )
        {
            XDBGTRC( USBM_APP_TITLE_NAME_A, "USBManager::USBManager():GAMEPAD added to port - '%d'", port );

            devices[i][0] = new DeviceDuke( port, 0, &pollingParameters );

            // Make sure there wasn't a problem inserting the Duke
            if( !((DeviceDuke*)devices[i][0])->m_hDuke )
            {
                delete (DeviceDuke*)devices[i][0];
                devices[i][0] = NULL;
            }
        }
    }

    // Check for Remote Control (insert & removal)
    XGetDeviceChanges( XDEVICE_TYPE_IR_REMOTE, &addRemote, &removeRemote );

    for( i=0; i < XGetPortCount(); i++ )
    {
        port = i % XGetPortCount();

        if( removeRemote & XIDMasks[i] )
        {
            XDBGTRC( USBM_APP_TITLE_NAME_A, "USBManager::USBManager():REMOTE removed from port - '%d'", port );

            delete (DeviceRemote*)devices[i][0];
            devices[i][0] = NULL;
        }

        if( addRemote & XIDMasks[i] )
        {
            XDBGTRC( USBM_APP_TITLE_NAME_A, "USBManager::USBManager():REMOTE found on port - '%d'", i );

            devices[i][0] = new DeviceRemote( port, 0 );

            // Make sure there wasn't a problem inserting the Duke
            if( !((DeviceRemote*)devices[i][0])->m_hRemote )
            {
                XDBGWRN( USBM_APP_TITLE_NAME_A, "USBManager::USBManager():REMOTE insert problem on port - '%d'", i );

                delete (DeviceRemote*)devices[i][0];
                devices[i][0] = NULL;
            }
        }
    }
}

BOOL USBManager::IsControlPressed( int port, enum CONTROLS control, BOOL* bFirstPress /*=NULL*/)
{
    // Make sure we have a duke at the current location, otherwise return FALSE
    if( port != PORT_ANY )
    {
        if( ( devices[port][SLOT_CONTROLLER] == NULL ) || ( devices[port][SLOT_CONTROLLER]->m_type != XDEVICE_TYPE_GAMEPAD ) )
        {
            return FALSE;
        }

        if( m_ControllerState.bControlPressed[port][control] )
        {
            // If the user gave us a valid address let's return
            // whether or not it's the first press of the item
            if( bFirstPress)
            {
                // If the previous X value was also greater than the deadZone, return
                // FALSE for bFirstPress
                if( m_PrevControllerState.bControlPressed[port][control] )
                {
                    *bFirstPress = FALSE;
                }
                else // This must be the first press
                {
                    *bFirstPress = TRUE;
                }
            }

            // Return the value of the control
            // This is always TRUE
            return m_ControllerState.bControlPressed[port][control];
        }
    }
    else    // Check to see if the user wants to find out for ANY port
    {
        for( unsigned int locPort = 0; locPort < XGetPortCount(); ++locPort )
        {
            // If there is no Duke at the current port, skip over it
            if( devices[locPort][SLOT_CONTROLLER] == NULL )
            {
                continue;
            }

            if( m_ControllerState.bControlPressed[locPort][control] )
            {
                // If the user gave us a valid address let's return
                // whether or not it's the first press of the item
                if( bFirstPress)
                {
                    // If the previous X value was also greater than the deadZone, return
                    // FALSE for bFirstPress
                    if( m_PrevControllerState.bControlPressed[locPort][control] )
                    {
                        *bFirstPress = FALSE;
                    }
                    else // This must be the first press
                    {
                        *bFirstPress = TRUE;
                    }
                }

                // Return the value of the control
                // This is always TRUE
                return m_ControllerState.bControlPressed[locPort][control];
            }
        }
    }

    // If the button wasn't pressed, let's return FALSE
    return FALSE;
}


// Will return TRUE if any button or thumbstick has changed since last poll
BOOL USBManager::MovementDetected( int port, int deadZone /*=0*/ )
{
    if( port != PORT_ANY )
    {
        if( devices[port][SLOT_CONTROLLER] == NULL )
        {
            return FALSE;
        }

        ZeroMemory( &m_state, sizeof( m_state ) );

        // Get the state of the current controller
        XInputGetState( ( (DeviceDuke*)devices[port][0])->m_hDuke, &m_state);

        // Check the buttons
        for( unsigned button = 0; button < BUTTON_MAX; ++button)
        {
            if( IsButtonPressed( port, (enum BUTTONS)button ) )
            {
                return TRUE;
            }
        }

        // Check the controls
        for( unsigned control = 0; control < CONTROL_MAX; ++control)
        {
            if( IsControlPressed( port, (enum CONTROLS)control ) )
            {
                return TRUE;
            }
        }

        // Check the Joysticks
        for( unsigned joystick = 0; joystick < JOYSTICK_MAX; ++joystick )
        {
            if( 0 != GetJoystickX( port, (enum JOYSTICK)joystick, deadZone ) )
            {
                return TRUE;
            }

            if( 0 != GetJoystickY( port, (enum JOYSTICK)joystick, deadZone ) )
            {
                return TRUE;
            }
        }

        // Check the remote
        for( unsigned remote = 0; remote < REMOTE_BUTTON_MAX; ++remote )
        {
            if( IsRemoteButtonPressed( port, (enum REMOTE_BUTTONS)remote ) )
            {
                return TRUE;
            }
        }
    }
    else    // Check to see if the user wants to find out for ANY port
    {
        ZeroMemory( &m_state, sizeof( m_state ) );

        for( unsigned int x = 0; x < XGetPortCount(); ++x )
        {
            if( devices[x][0] == NULL )
            {
                continue;
            }

            if( devices[x][0]->m_type == XDEVICE_TYPE_GAMEPAD )
            {
                // Get the state of the current controller
                XInputGetState( ( (DeviceDuke*)devices[x][0] )->m_hDuke, &m_state );

                // Check the buttons
                for( unsigned button = 0; button < BUTTON_MAX; ++button )
                {
                    if( IsButtonPressed( x, (enum BUTTONS)button ) )
                    {
                        return TRUE;
                    }
                }

                // Check the controls
                for( unsigned control = 0; control < CONTROL_MAX; ++control )
                {
                    if( IsControlPressed( x, (enum CONTROLS)control ) )
                    {
                        return TRUE;
                    }
                }

                // Check the Joysticks
                for( unsigned joystick = 0; joystick < JOYSTICK_MAX; ++joystick )
                {
                    if( 0 != GetJoystickX( x, (enum JOYSTICK)joystick, deadZone ) )
                    {
                        return TRUE;
                    }

                    if( 0 != GetJoystickY( x, (enum JOYSTICK)joystick, deadZone ) )
                    {
                        return TRUE;
                    }
                }
            }
            else if( devices[x][0]->m_type == XDEVICE_TYPE_IR_REMOTE )
            {
                // Get the state of the current remote
                XInputGetState( ( (DeviceRemote*)devices[x][0] )->m_hRemote, &m_state );

                // Check the remote
                for( unsigned remote = 0; remote < REMOTE_BUTTON_MAX; ++remote )
                {
                    if( IsRemoteButtonPressed( x, (enum REMOTE_BUTTONS)remote ) )
                    {
                        return TRUE;
                    }
                }
            }
        }
    }

    return FALSE;
}


// Will return the X value of the joystick passed in
int USBManager::GetJoystickX( int port, enum JOYSTICK joystick, int deadZone /*=0*/, BOOL* bFirstPress /*=NULL*/ )
{
    // Make sure we have a duke at the current location, otherwise return 0
    if( port != PORT_ANY )
    {
        if( ( devices[port][SLOT_CONTROLLER] == NULL ) || ( devices[port][SLOT_CONTROLLER]->m_type != XDEVICE_TYPE_GAMEPAD ) )
        {
            return 0;
        }

        // If the current stick is moved, process the request and return the value!
        if( abs( m_ControllerState.sThumbX[port][joystick] ) > deadZone )
        {
            // Determine if the user wishes to know if this is the first time the joystick
            // pressed, or if it's a repeat press
            if( bFirstPress)
            {
                // If the previous X value was also greater than the deadZone, return
                // FALSE for bFirstPress
                if( abs( m_PrevControllerState.sThumbX[port][joystick] ) > deadZone )
                {
                    *bFirstPress = FALSE;
                }
                else // This must be the first press
                {
                    *bFirstPress = TRUE;
                }
            }

            // Return the value we got from the joystick
            return m_ControllerState.sThumbX[port][joystick];
        }
    }
    else    // Check to see if the user wants to find out for ANY port
    {
        for( unsigned int locPort = 0; locPort < XGetPortCount(); ++locPort )
        {
            // If there is no Duke in this port, skip to the next port
            if( devices[locPort][SLOT_CONTROLLER] == NULL )
            {
                continue;
            }

            // If the current stick is moved, process the request and return the value!
            if( abs( m_ControllerState.sThumbX[locPort][joystick] ) > deadZone )
            {
                // Determine if the user wishes to know if this is the first time the joystick
                // pressed, or if it's a repeat press
                if( bFirstPress)
                {
                    // If the previous Y value was also greater than the deadZone, return
                    // FALSE for bFirstPress
                    if( abs( m_PrevControllerState.sThumbX[locPort][joystick] ) > deadZone )
                    {
                        *bFirstPress = FALSE;
                    }
                    else // This must be the first press
                    {
                        *bFirstPress = TRUE;
                    }
                }

                // Return the value we got from the joystick
                return m_ControllerState.sThumbX[locPort][joystick];
            }
        }
    }

    // Return 0 if the joystick was not pushed past the dead zone
    return 0;
}


// Will return the Y value of the joystick passed in
int USBManager::GetJoystickY( int port, enum JOYSTICK joystick, int deadZone /*=0*/, BOOL* bFirstPress /*=NULL*/ )
{
    // Make sure we have a duke at the current location, otherwise return 0
    if( port != PORT_ANY )
    {
        if( ( devices[port][SLOT_CONTROLLER] == NULL ) || ( devices[port][SLOT_CONTROLLER]->m_type != XDEVICE_TYPE_GAMEPAD ) )
        {
            return 0;
        }

        // If the current stick is moved, process the request and return the value!
        if( abs( m_ControllerState.sThumbY[port][joystick] ) > deadZone )
        {
            // Determine if the user wishes to know if this is the first time the joystick
            // pressed, or if it's a repeat press
            if( bFirstPress)
            {
                // If the previous Y value was also greater than the deadZone, return
                // FALSE for bFirstPress
                if( abs( m_PrevControllerState.sThumbY[port][joystick] ) > deadZone )
                {
                    *bFirstPress = FALSE;
                }
                else // This must be the first press
                {
                    *bFirstPress = TRUE;
                }
            }

            // Return the value we got from the joystick
            return m_ControllerState.sThumbY[port][joystick];
        }
    }
    else    // Check to see if the user wants to find out for ANY port
    {
        for( unsigned int locPort = 0; locPort < XGetPortCount(); ++locPort )
        {
            // If there is no Duke in this port, skip to the next port
            if( devices[locPort][SLOT_CONTROLLER] == NULL )
            {
                continue;
            }

            // If the current stick is moved, process the request and return the value!
            if( abs( m_ControllerState.sThumbY[locPort][joystick] ) > deadZone )
            {
                // Determine if the user wishes to know if this is the first time the joystick
                // pressed, or if it's a repeat press
                if( bFirstPress)
                {
                    // If the previous Y value was also greater than the deadZone, return
                    // FALSE for bFirstPress
                    if( abs( m_PrevControllerState.sThumbY[locPort][joystick] ) > deadZone )
                    {
                        *bFirstPress = FALSE;
                    }
                    else // This must be the first press
                    {
                        *bFirstPress = TRUE;
                    }
                }

                // Return the value we got from the joystick
                return m_ControllerState.sThumbY[locPort][joystick];
            }
        }
    }

    // Return 0 if the joystick was not pushed past the dead zone
    return 0;
}


// Will return TRUE if a remote button is depressed, or FALSE if it is not
BOOL USBManager::IsRemoteButtonPressed( int port, enum REMOTE_BUTTONS button, BOOL* bFirstPress /*=NULL*/ )
{
    // Make sure we have a remote at the current location, otherwise return FALSE
    if( port != PORT_ANY )
    {
        // Check to make sure a remote control device is plugged in to this port
        if( ( devices[port][SLOT_CONTROLLER] == NULL ) || ( devices[port][SLOT_CONTROLLER]->m_type != XDEVICE_TYPE_IR_REMOTE ) )
        {
            return FALSE;
        }

        if( m_ControllerState.m_bRemoteButtonPress[port][button] )
        {
            // If the user gave us the address of a BOOLean variable, we should return to them
            // whether or not this is the first time the button was pressed, or if it's a repeat
            // press
            if( bFirstPress )
            {
                // If in the previous state the button was pressed, return 'FALSE' for bFirstPress
                if( m_PrevControllerState.m_bRemoteButtonPress[port][button] )
                {
                    *bFirstPress = FALSE;
                }
                else // Otherwise, if the Prev value was FALSE, we need to notify the user it's the first press
                {
                    *bFirstPress = TRUE;
                }
            }
        }

        // Return the value of the button
        // This can be 'TRUE' or 'FALSE'
        return m_ControllerState.m_bRemoteButtonPress[port][button];
    }
    else    // Check to see if the user wants to find out for ANY port
    {
        for( unsigned int locPort = 0; locPort < XGetPortCount(); ++locPort )
        {
            // If there is no Duke in this port, skip to the next port
            if( ( devices[locPort][SLOT_CONTROLLER] == NULL ) || ( devices[locPort][SLOT_CONTROLLER]->m_type != XDEVICE_TYPE_IR_REMOTE ) )
            {
                continue;
            }

            // If the button is depressed, determine if the user wishes to know
            // if it's a repeat press
            if( m_ControllerState.m_bRemoteButtonPress[locPort][button] )
            {
                // If the user gave us the address of a BOOLean variable, we should return to them
                // whether or not this is the first time the button was pressed, or if it's a repeat
                // press
                if( bFirstPress )
                {
                    // If in the previous state the button was pressed, return 'FALSE' for bFirstPress
                    if( m_PrevControllerState.m_bRemoteButtonPress[locPort][button] )
                    {
                        *bFirstPress = FALSE;
                    }
                    else // Otherwise, if the Prev value was FALSE, we need to notify the user it's the first press
                    {
                        *bFirstPress = TRUE;
                    }
                }

                // Since a button was pressed, return early out of our loop
                return TRUE;
            }
        }
    }

    // If no button was pressed, let's return FALSE;
    return FALSE;
}


// Will return TRUE if a button is depressed, or FALSE if it is not
BOOL USBManager::IsButtonPressed( int port, enum BUTTONS button, int nThreshold /*=0*/, BOOL* bFirstPress /*=NULL*/ )
{
    // Make sure we have a duke at the current location, otherwise return FALSE
    if( port != PORT_ANY )
    {
        if( ( devices[port][SLOT_CONTROLLER] == NULL ) || ( devices[port][SLOT_CONTROLLER]->m_type != XDEVICE_TYPE_GAMEPAD ) )
        {
            return FALSE;
        }

        if( m_ControllerState.nButtonPress[port][button] > nThreshold )
        {
            // If the user gave us the address of a BOOLean variable, we should return to them
            // whether or not this is the first time the button was pressed, or if it's a repeat
            // press
            if( bFirstPress )
            {
                // If in the previous state the button was pressed, return 'FALSE' for bFirstPress
                if( m_PrevControllerState.nButtonPress[port][button] > nThreshold )
                {
                    *bFirstPress = FALSE;
                }
                else // Otherwise, if the Prev value was FALSE, we need to notify the user it's the first press
                {
                    *bFirstPress = TRUE;
                }
            }
        }

        // Return the value of the button
        // This can be 'TRUE' or 'FALSE'
        return (m_ControllerState.nButtonPress[port][button] > nThreshold);
    }
    else    // Check to see if the user wants to find out for ANY port
    {
        for( unsigned int locPort = 0; locPort < XGetPortCount(); ++locPort )
        {
            // If there is no Duke in this port, skip to the next port
            if( devices[locPort][SLOT_CONTROLLER] == NULL )
            {
                continue;
            }

            // If the button is depressed, determine if the user wishes to know
            // if it's a repeat press
            if( m_ControllerState.nButtonPress[locPort][button] > nThreshold )
            {
                // If the user gave us the address of a BOOLean variable, we should return to them
                // whether or not this is the first time the button was pressed, or if it's a repeat
                // press
                if( bFirstPress )
                {
                    // If in the previous state the button was pressed, return 'FALSE' for bFirstPress
                    if( m_PrevControllerState.nButtonPress[locPort][button] > nThreshold )
                    {
                        *bFirstPress = FALSE;
                    }
                    else // Otherwise, if the Prev value was FALSE, we need to notify the user it's the first press
                    {
                        *bFirstPress = TRUE;
                    }
                }

                // Since a button was pressed, return early out of our loop
                return TRUE;
            }
        }
    }

    // If no button was pressed, let's return FALSE;
    return FALSE;
}


// Will accecpt a port and rumble the Controller for a certain amount of time
void USBManager::Rumble( int port, WORD wForce, int nMilliseconds )
{
    if( PORT_ANY == port )
    //
    // Send the command to call controllers plugged in
    //
    {
        for( unsigned int locPort = 0; locPort < XGetPortCount(); ++locPort )
        {
            if( ( devices[locPort][SLOT_CONTROLLER] != NULL ) && ( devices[locPort][SLOT_CONTROLLER]->m_type == XDEVICE_TYPE_GAMEPAD ) )
            {
                // Check to make sure our thread isn't already running
                DWORD dwExitCode;
                GetExitCodeThread( m_hThreads[locPort], &dwExitCode );
                if( STILL_ACTIVE != dwExitCode )
                {
                    // Insert the information in to our Structure
                    m_RumbleInfo[locPort].nPort = locPort;
                    m_RumbleInfo[locPort].wForce = wForce;
                    m_RumbleInfo[locPort].nMilliseconds = nMilliseconds;
                    m_RumbleInfo[locPort].pUSBManager = this;

                    // Create the thread
                    m_hThreads[locPort] = CreateThread( NULL,
                                                        0,
                                                        RumbleThread,
                                                        (LPVOID)&m_RumbleInfo[locPort],
                                                        0, // CREATE_SUSPENDED,
                                                        NULL );
                }
            }
        }
    }
    else
    //
    // Send the command to the specified controller if it exists
    //
    {
        // Make sure the controller is plugged in
        if( ( devices[port][SLOT_CONTROLLER] == NULL ) || ( devices[port][SLOT_CONTROLLER]->m_type != XDEVICE_TYPE_GAMEPAD ) )
        {
            return;
        }

        // Check to make sure our thread isn't already running
        DWORD dwExitCode;
        GetExitCodeThread( m_hThreads[port], &dwExitCode );
        if( STILL_ACTIVE != dwExitCode )
        {
            // Insert the information in to our Structure
            m_RumbleInfo[port].nPort = port;
            m_RumbleInfo[port].wForce = wForce;
            m_RumbleInfo[port].nMilliseconds = nMilliseconds;
            m_RumbleInfo[port].pUSBManager = this;

            // Create the thread
            m_hThreads[port] = CreateThread( NULL,
                                             0,
                                             RumbleThread,
                                             (LPVOID)&m_RumbleInfo[port],
                                             0, // CREATE_SUSPENDED,
                                             NULL );
        }
    }
}


void USBManager::ProcessInput( void )
{
    // Store the previous state
    m_PrevControllerState = m_ControllerState;

    // Check to see if any devices were added or removed
    CheckForHotplugs();

    for( unsigned int port = 0; port < XGetPortCount(); ++port )
    {
        // Make sure a duke is plugged in
        if( devices[port][SLOT_CONTROLLER] == NULL )
        {
            continue;
        }

        if( devices[port][SLOT_CONTROLLER]->m_type == XDEVICE_TYPE_GAMEPAD )
        {
            ZeroMemory( &m_state, sizeof( m_state ) );

            XInputGetState( ( (DeviceDuke*)devices[port][SLOT_CONTROLLER] )->m_hDuke, &m_state );

            // Packet Number
            m_ControllerState.dwControllerState[port] = m_state.dwPacketNumber;

            // Check the buttons
            for( unsigned button = 0; button < BUTTON_MAX; ++button)
            {
                m_ControllerState.nButtonPress[port][button] = m_state.Gamepad.bAnalogButtons[button];
            }

            // Check the controls
            for( unsigned control = 0; control < CONTROL_MAX; ++control)
            {
                m_ControllerState.bControlPressed[port][control] = !!( m_state.Gamepad.wButtons & ( 1 << control ) );
            }

            // Check the Joysticks
            m_ControllerState.sThumbX[port][JOYSTICK_LEFT] = m_state.Gamepad.sThumbLX;
            m_ControllerState.sThumbY[port][JOYSTICK_LEFT] = m_state.Gamepad.sThumbLY;
            m_ControllerState.sThumbX[port][JOYSTICK_RIGHT] = m_state.Gamepad.sThumbRX;
            m_ControllerState.sThumbY[port][JOYSTICK_RIGHT] = m_state.Gamepad.sThumbRY;

            // Check the remote control
            for( unsigned remote = 0; remote < REMOTE_BUTTON_MAX; ++remote )
            {
                m_ControllerState.m_bRemoteButtonPress[port][remote] = FALSE;
            }
        }
        else if( devices[port][SLOT_CONTROLLER]->m_type == XDEVICE_TYPE_IR_REMOTE )
        {
            XINPUT_STATE_INTERNAL state;
            ZeroMemory( &state, sizeof( state ) );

            XInputGetState( ( (DeviceRemote*)devices[port][SLOT_CONTROLLER] )->m_hRemote, (PXINPUT_STATE)&state );

            // Packet Number
            m_ControllerState.dwControllerState[port] = state.dwPacketNumber;

            // Check the buttons
            for( unsigned button = 0; button < BUTTON_MAX; ++button)
            {
                m_ControllerState.nButtonPress[port][button] = FALSE;
            }

            // Check the controls
            for( unsigned control = 0; control < CONTROL_MAX; ++control)
            {
                m_ControllerState.bControlPressed[port][control] = FALSE;
            }

            // Check the Joysticks
            for( unsigned joystick = 0; joystick < JOYSTICK_MAX; ++joystick )
            {
                m_ControllerState.sThumbX[port][joystick] = 0;
                m_ControllerState.sThumbY[port][joystick] = 0;
            }

            // Check the remote control
            for( unsigned remote = 0; remote < REMOTE_BUTTON_MAX; ++remote )
            {
                // BUGBUG: The remote always reports the button is being pressed, even if it is not
                // If this can be fixed, we can change this code for the better
                if( ( state.IrRemote.wKeyCode == g_aRemoteButtons[remote] ) && ( REMOTE_BUTTON_REPEAT_THRESHOLD < state.IrRemote.wTimeDelta ) )
                {
                    m_ControllerState.m_bRemoteButtonPress[port][remote] = TRUE;
                }
                else
                {
                    m_ControllerState.m_bRemoteButtonPress[port][remote] = FALSE;
                }
            }
        }
    }
}


DWORD WINAPI RumbleThread( LPVOID lpParameter )
{
    PRUMBLE_INFO pRumbleInfo = (PRUMBLE_INFO)lpParameter;

    // Send the Rumble Command
    XINPUT_FEEDBACK Feedback;
    ZeroMemory( &Feedback, sizeof( Feedback ) );

    Feedback.Rumble.wLeftMotorSpeed = pRumbleInfo->wForce;
    Feedback.Rumble.wRightMotorSpeed = pRumbleInfo->wForce;

    XInputSetState( ((DeviceDuke*)(pRumbleInfo->pUSBManager->devices[pRumbleInfo->nPort][SLOT_CONTROLLER]))->m_hDuke, &Feedback );

    Sleep( pRumbleInfo->nMilliseconds );

    int nSleepTime = 0;
    while( ERROR_IO_PENDING == Feedback.Header.dwStatus )
    {
        nSleepTime += 100;
        Sleep( 100 );
    }

    Feedback.Rumble.wLeftMotorSpeed = 0;
    Feedback.Rumble.wRightMotorSpeed = 0;

    // Make sure the controller is still inserted, and stop the rumble
    if( pRumbleInfo->pUSBManager->devices[pRumbleInfo->nPort][SLOT_CONTROLLER] )
    {
        XInputSetState( ((DeviceDuke*)(pRumbleInfo->pUSBManager->devices[pRumbleInfo->nPort][SLOT_CONTROLLER]))->m_hDuke, &Feedback );

        while( ERROR_IO_PENDING == Feedback.Header.dwStatus )
        {
            Sleep( 100 );
        };
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashconfig\clockmenuscreen.h ===
/*****************************************************
*** clockmenuscreen.h
***
*** Header file for our XDash CFG Clock menu class.
*** This clock menu contains a list of time and 
*** date objects that will be manipulated
*** 
*** by James N. Helm
*** November 2nd, 2000
*** 
*****************************************************/

#ifndef _CLOCKMENUSCREEN_H_
#define _CLOCKMENUSCREEN_H_

#include "xdcitem.h"
#include "xboxvideo.h"
#include "usbmanager.h"

enum CLOCKITEMS
{
    MONTH,
    DAY,
    YEAR,
    HOUR,
    MINUTE,
    SECOND
};

// Months of the year
static const WCHAR* g_apszMonths[12] = {
    L"January",
    L"February",
    L"March",
    L"April",
    L"May",
    L"June",
    L"July",
    L"August",
    L"September",
    L"October",
    L"November",
    L"December"
};

#define NUM_CLOCK_ITEMS     6

class CClockMenuScreen : public CXDCItem
{
public:
    CClockMenuScreen();
    CClockMenuScreen( CXDCItem* pParent, WCHAR* pwszTitle, WCHAR* pwszDescription );
    ~CClockMenuScreen();

    void Action( CXBoxVideo* Screen );
    void HandleInput( enum BUTTONS buttonPressed, bool bFirstPress );

    HRESULT SetSelectedItem( unsigned int itemNumber );                 // Set the currently selected item
    WCHAR* GetItemDescription( unsigned int itemIndex ) const;          // Get the description of an item
    unsigned int GetNumItems() const { return m_uicNumItems; };         // Return the number of menu items on our current screen
    unsigned int GetSelectedItem() const { return m_uiSelectedItem; };  // Get the indext of the currently selected item on the screen


private:
    SYSTEMTIME m_sysUserTime;                   // Holds the current / user selected time
    bool m_fUserAdjustedTime;                   // Used to determine if the user has selected a new time
    WCHAR m_Items[NUM_CLOCK_ITEMS][20];         // Descriptions of each of the clock items
    unsigned int m_uicNumItems;                 // Num of items that are on the current screen
    int m_uiSelectedItem;                       // The currently selected item on the screen

};

#endif // _CLOCKMENUSCREEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashconfig\clockmenuscreen.cpp ===
/*****************************************************
*** clockmenuscreen.cpp
***
*** CPP file for our XDash CFG Clock menu class.
*** This clock menu contains a list of time and 
*** date objects that will be manipulated
*** 
*** by James N. Helm
*** November 2nd, 2000
*** 
*****************************************************/

#include "clockmenuscreen.h"
#include "videoconstants.h"

extern CXDCItem* g_pCurrentScreen;  // Pointer to the current menu object

// Constructor
CClockMenuScreen::CClockMenuScreen()
: CXDCItem()
{
    m_fUserAdjustedTime = false;
    m_uicNumItems = NUM_CLOCK_ITEMS;

    wsprintf( m_Items[0], L"Month" );
    wsprintf( m_Items[1], L"Day" );
    wsprintf( m_Items[2], L"Year" );
    wsprintf( m_Items[3], L"Hour" );
    wsprintf( m_Items[4], L"Minute" );
    wsprintf( m_Items[5], L"Second" );

    // Must be done after populating the above array
    SetSelectedItem( 0 );

    ZeroMemory( &m_sysUserTime, sizeof( SYSTEMTIME ) );
    GetSystemTime( &m_sysUserTime ); // Get the current time
}

// Constructor
CClockMenuScreen::CClockMenuScreen( CXDCItem* pParent, WCHAR* pwszTitle, WCHAR* pwszDescription )
: CXDCItem( pParent, pwszTitle, pwszDescription )
{
    m_fUserAdjustedTime = false;
    m_uicNumItems = NUM_CLOCK_ITEMS;

    wsprintf( m_Items[0], L"Month" );
    wsprintf( m_Items[1], L"Day" );
    wsprintf( m_Items[2], L"Year" );
    wsprintf( m_Items[3], L"Hour" );
    wsprintf( m_Items[4], L"Minute" );
    wsprintf( m_Items[5], L"Second" );

    // Must be done after populating the above array
    SetSelectedItem( 0 );

    ZeroMemory( &m_sysUserTime, sizeof( SYSTEMTIME ) );
    GetSystemTime( &m_sysUserTime ); // Get the current time
}

// Destructor
CClockMenuScreen::~CClockMenuScreen()
{
}


// Draws a menu on to the screen
void CClockMenuScreen::Action( CXBoxVideo* pScreen )
{
    unsigned int nStringWidth       = 0;
    float fFontHeight               = 0.0;
    int datePixelSize               = 0;
    int timePixelSize               = 0;
    int spacePixelSize              = 0;

    float date1_x1, date2_x1, date3_x1;         // X1 Positions of each date field
    float date1_x2, date2_x2, date3_x2;         // X2 Positions of each date field
    float time1_x1, time2_x1, time3_x1;         // X1 Positions of each time field
    float time1_x2, time2_x2, time3_x2;         // X1 Positions of each time field

    pScreen->GetFontSize( 0, &fFontHeight, 0, 0 );

    if( false == m_fUserAdjustedTime )
    {
        GetSystemTime( &m_sysUserTime ); // Get the current time
    }

    spacePixelSize = pScreen->GetStringPixelWidth( L" " );

    date1_x1 = (float)SCREEN_X_CENTER - ( pScreen->GetStringPixelWidth( L"September 00 0000" ) / 2 );
    date2_x1 = date1_x1 + pScreen->GetStringPixelWidth( L"September " );
    date3_x1 = date2_x1 + pScreen->GetStringPixelWidth( L"00 " );

    date1_x2 = date1_x1 + pScreen->GetStringPixelWidth( L"September" );
    date2_x2 = date2_x1 + pScreen->GetStringPixelWidth( L"00" );
    date3_x2 = date3_x1 + pScreen->GetStringPixelWidth( L"0000" );

    time1_x1 = (float)SCREEN_X_CENTER - ( pScreen->GetStringPixelWidth( L"00 : 00 : 00" ) / 2 );
    time2_x1 = time1_x1 + pScreen->GetStringPixelWidth( L"00 : " );
    time3_x1 = time2_x1 + pScreen->GetStringPixelWidth( L"00 : " );

    time1_x2 = time1_x1 + pScreen->GetStringPixelWidth( L"00" );
    time2_x2 = time2_x1 + pScreen->GetStringPixelWidth( L"00" );
    time3_x2 = time3_x1 + pScreen->GetStringPixelWidth( L"00" );

    // Display the Title
    pScreen->DrawText( (float)SCREEN_X_CENTER - ( pScreen->GetStringPixelWidth( GetTitle() ) / 2 ), MENU_TITLE_Y, MENU_TITLE_FG_COLOR, MENU_TITLE_BG_COLOR, GetTitle() );

    // Draw date and time on screen
    //   Month
    pScreen->DrawText( date1_x1, MENU_OPTION1_Y, MENU_ITEM_FG_COLOR, MENU_ITEM_BG_COLOR, g_apszMonths[m_sysUserTime.wMonth] );
    //   Day
    pScreen->DrawText( date2_x1, MENU_OPTION1_Y, MENU_ITEM_FG_COLOR, MENU_ITEM_BG_COLOR, L"%02d", m_sysUserTime.wDay );
    //   Year
    pScreen->DrawText( date3_x1, MENU_OPTION1_Y, MENU_ITEM_FG_COLOR, MENU_ITEM_BG_COLOR, L"%d", m_sysUserTime.wYear );

    //   Hour
    pScreen->DrawText( time1_x1, MENU_OPTION1_Y + ( fFontHeight + MENU_VERT_SPACING ), MENU_ITEM_FG_COLOR, MENU_ITEM_BG_COLOR, L"%02d : ", m_sysUserTime.wHour );
    //   Minute
    pScreen->DrawText( time2_x1, MENU_OPTION1_Y + ( fFontHeight + MENU_VERT_SPACING ), MENU_ITEM_FG_COLOR, MENU_ITEM_BG_COLOR, L"%02d : ", m_sysUserTime.wMinute );
    //   Second
    pScreen->DrawText( time3_x1, MENU_OPTION1_Y + ( fFontHeight + MENU_VERT_SPACING ), MENU_ITEM_FG_COLOR, MENU_ITEM_BG_COLOR, L"%02d", m_sysUserTime.wSecond );
    
    // Highlight current choice
    switch( GetSelectedItem() )
    {
    case MONTH:
        {
            pScreen->DrawOutline( date1_x1 - MENU_HIGHLIGHT_BORDER, MENU_OPTION1_Y - MENU_HIGHLIGHT_BORDER, date1_x2 + MENU_HIGHLIGHT_BORDER, MENU_OPTION1_Y + fFontHeight + MENU_HIGHLIGHT_BORDER, MENU_HIGHLIGHT_BORDER_WIDTH, HIGHLIGHT_BOX_COLOR );
            break;
        }
    case DAY:
        {
            pScreen->DrawOutline( date2_x1 - MENU_HIGHLIGHT_BORDER, MENU_OPTION1_Y - MENU_HIGHLIGHT_BORDER, date2_x2 + MENU_HIGHLIGHT_BORDER, MENU_OPTION1_Y + fFontHeight + MENU_HIGHLIGHT_BORDER, MENU_HIGHLIGHT_BORDER_WIDTH, HIGHLIGHT_BOX_COLOR );
            break;
        }
    case YEAR:
        {
            pScreen->DrawOutline( date3_x1 - MENU_HIGHLIGHT_BORDER, MENU_OPTION1_Y - MENU_HIGHLIGHT_BORDER, date3_x2 + MENU_HIGHLIGHT_BORDER, MENU_OPTION1_Y + fFontHeight + MENU_HIGHLIGHT_BORDER, MENU_HIGHLIGHT_BORDER_WIDTH, HIGHLIGHT_BOX_COLOR );
            break;
        }
    case HOUR:
        {
            pScreen->DrawOutline( time1_x1 - MENU_HIGHLIGHT_BORDER, MENU_OPTION1_Y + ( fFontHeight + MENU_VERT_SPACING ) - MENU_HIGHLIGHT_BORDER, time1_x2 + MENU_HIGHLIGHT_BORDER, MENU_OPTION1_Y + ( fFontHeight * 2 ) + MENU_VERT_SPACING + MENU_HIGHLIGHT_BORDER, MENU_HIGHLIGHT_BORDER_WIDTH, HIGHLIGHT_BOX_COLOR );
            break;
        }
    case MINUTE:
        {
            pScreen->DrawOutline( time2_x1 - MENU_HIGHLIGHT_BORDER, MENU_OPTION1_Y + ( fFontHeight + MENU_VERT_SPACING ) - MENU_HIGHLIGHT_BORDER, time2_x2 + MENU_HIGHLIGHT_BORDER, MENU_OPTION1_Y + ( fFontHeight * 2 ) + MENU_VERT_SPACING + MENU_HIGHLIGHT_BORDER, MENU_HIGHLIGHT_BORDER_WIDTH, HIGHLIGHT_BOX_COLOR );
            break;
        }
    case SECOND:
        {
            pScreen->DrawOutline( time3_x1 - MENU_HIGHLIGHT_BORDER, MENU_OPTION1_Y + ( fFontHeight + MENU_VERT_SPACING ) - MENU_HIGHLIGHT_BORDER, time3_x2 + MENU_HIGHLIGHT_BORDER, MENU_OPTION1_Y + ( fFontHeight * 2 ) + MENU_VERT_SPACING + MENU_HIGHLIGHT_BORDER, MENU_HIGHLIGHT_BORDER_WIDTH, HIGHLIGHT_BOX_COLOR );
            break;
        }
    }
}

// Handles input for the current menu
void CClockMenuScreen::HandleInput( enum BUTTONS buttonPressed, bool bFirstPress )
{
    // DebugPrint( "CMenuScreen::HandleInput()\n" );

    // If it's a repeat button press, bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
            }
            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                SetSelectedItem( 0 );
                g_pCurrentScreen = GetParent();
            }
            break;
        }
    case BUTTON_C:
        {
            break;
        }
    case BUTTON_D:
        {
            break;
        }
    case BUTTON_E:
        {
            break;
        }
    case BUTTON_F:
        {
            break;
        }
    case BUTTON_7:
        {
            break;
        }
    case BUTTON_8:
        {
            break;
        }
    case BUTTON_9:
        {
            break;
        }
    case BUTTON_10:
        {
            break;
        }
    case DPAD_TOP:
        {
            m_fUserAdjustedTime = true;
            switch( GetSelectedItem() )
            {
            case MONTH:
                {
                    if( 11 == m_sysUserTime.wMonth )
                    {
                        m_sysUserTime.wMonth = 0;
                    }
                    else
                    {
                        ++m_sysUserTime.wMonth;
                    }
                    break;
                }
            case DAY:
                {
                    if( 31 == m_sysUserTime.wDay )
                    {
                        m_sysUserTime.wDay = 1;
                    }
                    else
                    {
                        ++m_sysUserTime.wDay;
                    }
                    break;
                }
            case YEAR:
                {
                    if( 2032 == m_sysUserTime.wYear )
                    {
                        m_sysUserTime.wYear = 2000;
                    }
                    else
                    {
                        ++m_sysUserTime.wYear;
                    }
                    break;
                }
            case HOUR:
                {
                    if( 23 == m_sysUserTime.wHour )
                    {
                        m_sysUserTime.wHour = 0;
                    }
                    else
                    {
                        ++m_sysUserTime.wHour;
                    }
                    break;
                }
            case MINUTE:
                {
                    if( 59 == m_sysUserTime.wMinute )
                    {
                        m_sysUserTime.wMinute = 0;
                    }
                    else
                    {
                        ++m_sysUserTime.wMinute;
                    }
                    break;
                }
            case SECOND:
                {
                    if( 59 == m_sysUserTime.wSecond )
                    {
                        m_sysUserTime.wSecond = 0;
                    }
                    else
                    {
                        ++m_sysUserTime.wSecond;
                    }
                    break;
                }
            };
            break;
        }
    case DPAD_BOTTOM:
        {
            m_fUserAdjustedTime = true;
            switch( GetSelectedItem() )
            {
            case MONTH:
                {
                    if( 0 == m_sysUserTime.wMonth )
                    {
                        m_sysUserTime.wMonth = 11;
                    }
                    else
                    {
                        --m_sysUserTime.wMonth;
                    }
                    break;
                }
            case DAY:
                {
                    if( 1 == m_sysUserTime.wDay )
                    {
                        m_sysUserTime.wDay = 31;
                    }
                    else
                    {
                        --m_sysUserTime.wDay;
                    }
                    break;
                }
            case YEAR:
                {
                    if( 2000 == m_sysUserTime.wYear )
                    {
                        m_sysUserTime.wYear = 2032;
                    }
                    else
                    {
                        --m_sysUserTime.wYear;
                    }
                    break;
                }
            case HOUR:
                {
                    if( 0 == m_sysUserTime.wHour )
                    {
                        m_sysUserTime.wHour = 23;
                    }
                    else
                    {
                        --m_sysUserTime.wHour;
                    }
                    break;
                }
            case MINUTE:
                {
                    if( 0 == m_sysUserTime.wMinute )
                    {
                        m_sysUserTime.wMinute = 59;
                    }
                    else
                    {
                        --m_sysUserTime.wMinute;
                    }
                    break;
                }
            case SECOND:
                {
                    if( 0 == m_sysUserTime.wSecond )
                    {
                        m_sysUserTime.wSecond = 59;
                    }
                    else
                    {
                        --m_sysUserTime.wSecond;
                    }
                    break;
                }
            };
            break;
        }
    case DPAD_LEFT:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() <= 0 )
                {
                    SetSelectedItem( GetNumItems() - 1 );
                }
                else
                {
                    SetSelectedItem( GetSelectedItem() - 1 );
                }
            }
            break;
        }
    case DPAD_RIGHT:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() >= GetNumItems() - 1 )
                {
                    SetSelectedItem( 0 );
                }
                else
                {
                    SetSelectedItem( GetSelectedItem() + 1 );
                }
            }
            break;
        }
    }
}

// Get the description of a sub-item on our screen
WCHAR* CClockMenuScreen::GetItemDescription( unsigned int itemIndex ) const
{
    if( ( itemIndex < 0 ) || ( itemIndex >= GetNumItems() ) )
    {
        DebugPrint( "CXDCItem::GetItemDescription(): index out of range - '%d'\n", itemIndex );
        return NULL;
    }

    return (WCHAR*)m_Items[itemIndex];
}

// Sets the currently selected item on our screen
HRESULT CClockMenuScreen::SetSelectedItem( unsigned int itemNumber )
{
    if( ( itemNumber < 0 ) || ( itemNumber >= GetNumItems() ) )
    {
        DebugPrint( "CClockMenuScreen::SetSelectedItem(): Tried to select item out of range! - '%d', MAX - '%d'\n", itemNumber, GetNumItems() - 1 );
        return E_INVALIDARG;
    }

    m_uiSelectedItem = itemNumber;

    SetFooterText( GetItemDescription( m_uiSelectedItem ) );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashconfig\maformatcommand.cpp ===
/*****************************************************
*** maformatcommand.cpp
***
*** CPP file for our XDash CFG Memory Area Format
*** command option.
*** This option will allow the user to format (clean)
*** a Memory Area of all of it's data when a user
*** selects "A"
*** 
*** by James N. Helm
*** November 3rd, 2000
*** 
*****************************************************/

#include "maformatcommand.h"
#include "videoconstants.h"

extern CXDCItem* g_pCurrentScreen;  // Pointer to the current menu object

// Constructor
CMAFormatCommand::CMAFormatCommand()
: CXDCItem()
{
    m_uicNumItems = NUM_MEMORY_AREAS;

    wsprintf( m_Items[XDISK], L"XDisk - Hard drive of the XBox" );
    wsprintf( m_Items[MU1],   L"Memory Unit 1 - Controller 1 Slot 1" );
    wsprintf( m_Items[MU2],   L"Memory Unit 2 - Controller 1 Slot 2" );
    wsprintf( m_Items[MU3],   L"Memory Unit 3 - Controller 2 Slot 1" );
    wsprintf( m_Items[MU4],   L"Memory Unit 4 - Controller 2 Slot 2" );
    wsprintf( m_Items[MU5],   L"Memory Unit 5 - Controller 3 Slot 1" );
    wsprintf( m_Items[MU6],   L"Memory Unit 6 - Controller 3 Slot 2" );
    wsprintf( m_Items[MU7],   L"Memory Unit 7 - Controller 4 Slot 1" );
    wsprintf( m_Items[MU8],   L"Memory Unit 8 - Controller 4 Slot 2" );

    // Must be done after populating the above array
    SetSelectedItem( 0 );
}

// Constructor
CMAFormatCommand::CMAFormatCommand( CXDCItem* pParent, WCHAR* pwszTitle, WCHAR* pwszDescription )
: CXDCItem( pParent, pwszTitle, pwszDescription )
{
    m_uicNumItems = NUM_MEMORY_AREAS;

    wsprintf( m_Items[XDISK], L"XDisk - Hard drive of the XBox" );
    wsprintf( m_Items[MU1],   L"Memory Unit 1 - Controller 1 Slot 1" );
    wsprintf( m_Items[MU2],   L"Memory Unit 2 - Controller 1 Slot 2" );
    wsprintf( m_Items[MU3],   L"Memory Unit 3 - Controller 2 Slot 1" );
    wsprintf( m_Items[MU4],   L"Memory Unit 4 - Controller 2 Slot 2" );
    wsprintf( m_Items[MU5],   L"Memory Unit 5 - Controller 3 Slot 1" );
    wsprintf( m_Items[MU6],   L"Memory Unit 6 - Controller 3 Slot 2" );
    wsprintf( m_Items[MU7],   L"Memory Unit 7 - Controller 4 Slot 1" );
    wsprintf( m_Items[MU8],   L"Memory Unit 8 - Controller 4 Slot 2" );

    // Must be done after populating the above array
    SetSelectedItem( 0 );
}

// Destructor
CMAFormatCommand::~CMAFormatCommand()
{
}


// Draws a menu on to the screen
void CMAFormatCommand::Action( CXBoxVideo* pScreen )
{
    unsigned int nStringWidth       = 0;
    float fFontHeight               = 0.0;

    pScreen->GetFontSize( 0, &fFontHeight, 0, 0 );

    // Display the Title
    pScreen->DrawText( (float)SCREEN_X_CENTER - ( pScreen->GetStringPixelWidth( GetTitle() ) / 2 ), MENU_TITLE_Y, MENU_TITLE_FG_COLOR, MENU_TITLE_BG_COLOR, GetTitle() );

    // Draw the items on the screen
    // If we have any items on the screen, let's draw them

    // Draw a box behind the currently highlighted choice
    float fX1, fY1, fX2, fY2;
    fX1 = SCREEN_X_CENTER - ( pScreen->GetStringPixelWidth( g_apszMemoryAreas[GetSelectedItem()] ) / 2.0f ) - MENU_HIGHLIGHT_BORDER;
    fY1 = MENU_OPTION1_Y + ( ( fFontHeight + MENU_VERT_SPACING ) * GetSelectedItem() ) - MENU_HIGHLIGHT_BORDER;
    fX2 = SCREEN_X_CENTER + ( pScreen->GetStringPixelWidth( g_apszMemoryAreas[GetSelectedItem()] ) / 2.0f ) + MENU_HIGHLIGHT_BORDER;
    fY2 = MENU_OPTION1_Y + ( fFontHeight * ( GetSelectedItem() + 1 ) ) + ( MENU_VERT_SPACING * GetSelectedItem() ) + MENU_HIGHLIGHT_BORDER;

    pScreen->DrawOutline( fX1, fY1, fX2, fY2, MENU_HIGHLIGHT_BORDER_WIDTH, HIGHLIGHT_BOX_COLOR );

    // Draw the items on the menu
    for( unsigned int x = 0; x < GetNumItems(); ++x )
    {
        pScreen->DrawText( SCREEN_X_CENTER - ( pScreen->GetStringPixelWidth( g_apszMemoryAreas[x] ) / 2.0f ), MENU_OPTION1_Y + ( ( fFontHeight + MENU_VERT_SPACING ) * x ), MENU_ITEM_FG_COLOR, MENU_ITEM_BG_COLOR, g_apszMemoryAreas[x] );
    }
}

// Handles input for the current menu
void CMAFormatCommand::HandleInput( enum BUTTONS buttonPressed, bool bFirstPress )
{
    // DebugPrint( "CMenuScreen::HandleInput()\n" );

    // If it's a repeat button press, bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                SetFooterText( L"Loser" );
            }
            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                SetSelectedItem( 0 );
                g_pCurrentScreen = GetParent();
            }
            break;
        }
    case BUTTON_C:
        {
            break;
        }
    case BUTTON_D:
        {
            break;
        }
    case BUTTON_E:
        {
            break;
        }
    case BUTTON_F:
        {
            break;
        }
    case BUTTON_7:
        {
            break;
        }
    case BUTTON_8:
        {
            break;
        }
    case BUTTON_9:
        {
            break;
        }
    case BUTTON_10:
        {
            break;
        }
    case DPAD_TOP:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() <= 0 )
                {
                    SetSelectedItem( GetNumItems() - 1 );
                }
                else
                {
                    SetSelectedItem( GetSelectedItem() - 1 );
                }
            }
            break;
        }
    case DPAD_BOTTOM:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() >= GetNumItems() - 1 )
                {
                    SetSelectedItem( 0 );
                }
                else
                {
                    SetSelectedItem( GetSelectedItem() + 1 );
                }
            }
            break;
        }
    case DPAD_LEFT:
        {
            break;
        }
    case DPAD_RIGHT:
        {
            break;
        }
    }
}

// Get the description of a sub-item on our screen
WCHAR* CMAFormatCommand::GetItemDescription( unsigned int itemIndex ) const
{
    if( ( itemIndex < 0 ) || ( itemIndex >= GetNumItems() ) )
    {
        DebugPrint( "CMAFormatCommand::GetItemDescription(): index out of range - '%d', MAX - '%d'\n", itemIndex, GetNumItems() - 1 );
        return NULL;
    }

    return (WCHAR*)m_Items[itemIndex];
}

// Sets the currently selected item on our screen
HRESULT CMAFormatCommand::SetSelectedItem( unsigned int itemNumber )
{
    if( ( itemNumber < 0 ) || ( itemNumber >= GetNumItems() ) )
    {
        DebugPrint( "CMAFormatCommand::SetSelectedItem(): Tried to select item out of range! - '%d', MAX - '%d'\n", itemNumber, GetNumItems() - 1 );
        return E_INVALIDARG;
    }

    m_uiSelectedItem = itemNumber;

    SetFooterText( GetItemDescription( m_uiSelectedItem ) );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\xsettings\xsettings.cpp ===
/*****************************************************
*** xsettings.cpp
***
*** CPP file for our XSettings class.
*** This is class which will hold the settings
*** that live on the Xbox.
***
*** by James N. Helm
*** December 2nd, 2000
***
*****************************************************/

#include "xsetpch.h"
#include "xsettings.h"

DWORD Crc32Checksum(const VOID* buf, DWORD bufsize);    // Computer a CRC32 Checksum
BOOL HDSetPassword( BYTE* password, DWORD dwLen );      // Set the password of the Hard Drive

//
// Functions for dealing with the encrypted section of the EEPROM
//

//
// The EEPROM encrypted section is unencrypted if the hard drive key field is all 0's
//
inline BOOL IsEEPROMEncryptedSectionUnencrypted(const XBOX_ENCRYPTED_SETTINGS* encryptedSection)
{
    /*
    // Use the HDKey to determine if we are encrypted
    const UCHAR* hdkey = encryptedSection->HDKey;
    for (INT i=0; i < XBOX_KEY_LENGTH; i++)
        if (hdkey[i] != 0) return FALSE;
    */

    // Use the Confounder to determine if we are encrypted
    const UCHAR* confounder = encryptedSection->Confounder;
    for (INT i=0; i < 8; i++)
        if (confounder[i] != 0) return FALSE;

    return TRUE;
}

//
// Decrypted the encrypted section of the EEPROM
//
static DWORD DecryptEEPROMEncryptedSection(XBOX_ENCRYPTED_SETTINGS* encryptedSection)
{
    if (IsEEPROMEncryptedSectionUnencrypted(encryptedSection))
        return ERROR_SUCCESS;

    #define RC4_CONFOUNDER_LEN FIELD_SIZE(XBOX_ENCRYPTED_SETTINGS, Confounder)

    UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
    UCHAR LocalKey[XC_SERVICE_DIGEST_SIZE];
    UCHAR Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];
    UCHAR* Data;
    ULONG DataSize;
    XBOX_ENCRYPTED_SETTINGS EncryptedSettings;
    UCHAR* EepromKey = (UCHAR*) *XboxEEPROMKey;

    EncryptedSettings = *encryptedSection;
    Data = EncryptedSettings.HDKey;
    DataSize = EEPROM_ENCRYPTED_SECTION_SIZE - FIELD_OFFSET(XBOX_ENCRYPTED_SETTINGS, HDKey);
    memcpy(Confounder, EncryptedSettings.Confounder, RC4_CONFOUNDER_LEN);

    //
    // HMAC the checksum into the key
    //
    XcHMAC(
        EepromKey,
        XBOX_KEY_LENGTH,
        EncryptedSettings.Checksum,
        XC_SERVICE_DIGEST_SIZE,
        NULL,
        0,
        LocalKey);

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key(Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey);

    //
    // Decrypt confounder and data
    //
    XcRC4Crypt(Rc4KeyStruct, RC4_CONFOUNDER_LEN, Confounder);
    XcRC4Crypt(Rc4KeyStruct, DataSize, Data);

    //
    // Now verify the checksum.
    //
    XcHMAC(
        EepromKey,
        XBOX_KEY_LENGTH,
        Confounder,
        RC4_CONFOUNDER_LEN,
        Data,
        DataSize,
        Checksum);

    //
    // Decrypt is successful only if checksum matches
    //
    if (memcmp(Checksum, EncryptedSettings.Checksum, XC_SERVICE_DIGEST_SIZE) != 0)
        return ERROR_INVALID_PASSWORD;

    memset(encryptedSection, 0, sizeof(*encryptedSection));
    memcpy(encryptedSection->HDKey, EncryptedSettings.HDKey, XBOX_KEY_LENGTH);
    encryptedSection->GameRegion = EncryptedSettings.GameRegion;
    return ERROR_SUCCESS;
}

//
// Encrypt the encrypted section of the EEPROM
//
static DWORD EncryptEEPROMEncryptedSection(XBOX_ENCRYPTED_SETTINGS* encryptedSection)
{
    if (!IsEEPROMEncryptedSectionUnencrypted(encryptedSection))
        return ERROR_SUCCESS;

    UCHAR Confounder[RC4_CONFOUNDER_LEN] = { 0x4c,0x70,0x33,0xcb,0x5b,0xb5,0x97,0xd2 };
    UCHAR LocalKey[XC_SERVICE_DIGEST_SIZE];
    UCHAR Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];
    UCHAR* Data;
    ULONG DataSize;
    UCHAR* EepromKey = (UCHAR*) *XboxEEPROMKey;

    Data = encryptedSection->HDKey;
    DataSize = EEPROM_ENCRYPTED_SECTION_SIZE - FIELD_OFFSET(XBOX_ENCRYPTED_SETTINGS, HDKey);

    //
    // Create the header - the confounder & checksum
    //
    memset(encryptedSection->Checksum, 0, sizeof(encryptedSection->Checksum));
    memcpy(encryptedSection->Confounder, Confounder, sizeof(encryptedSection->Confounder));

    //
    // Checksum everything but the checksum
    //
    XcHMAC(EepromKey,
           XBOX_KEY_LENGTH,
           encryptedSection->Confounder,
           RC4_CONFOUNDER_LEN,
           Data,
           DataSize,
           encryptedSection->Checksum);

    //
    // HMAC the checksum into the key
    //
    XcHMAC(EepromKey,
           XBOX_KEY_LENGTH,
           encryptedSection->Checksum,
           XC_SERVICE_DIGEST_SIZE,
           NULL,
           0,
           LocalKey);

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key(Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey);

    //
    // Encrypt everything but the checksum
    //
    XcRC4Crypt(Rc4KeyStruct, RC4_CONFOUNDER_LEN, encryptedSection->Confounder);
    XcRC4Crypt(Rc4KeyStruct, DataSize, Data);

    return ERROR_SUCCESS;
}

//
// Make sure the encrypted section of the EEPROM is encrypted or decrypted
//
static DWORD EncryptDecryptEEPROMEncryptedSection(BOOL encrypted)
{
    EEPROM_LAYOUT eepromData;
    XBOX_ENCRYPTED_SETTINGS* encryptedSection;
    ULONG type, length;
    DWORD err;

    //
    // Read the existing content of the encrypted section
    //
    err = XQueryValue(XC_MAX_ALL, &type, &eepromData, sizeof(eepromData), &length);
    if (err != ERROR_SUCCESS) return err;

    encryptedSection = (XBOX_ENCRYPTED_SETTINGS*) eepromData.EncryptedSection;
    if (encrypted) {
        // If the current content is already encrypted, do nothing
        if (!IsEEPROMEncryptedSectionUnencrypted(encryptedSection))
            return ERROR_SUCCESS;
        err = EncryptEEPROMEncryptedSection(encryptedSection);
    } else {
        if (IsEEPROMEncryptedSectionUnencrypted(encryptedSection))
            return ERROR_SUCCESS;
        err = DecryptEEPROMEncryptedSection(encryptedSection);
    }

    XDBGWRN("EEPROM", "%scrypting the encrypted section of the EEPROM", encrypted ? "En" : "De");

    if (err == ERROR_SUCCESS) {
        err = XSetValue(XC_MAX_ALL, REG_BINARY, &eepromData, sizeof(eepromData));
    }

    if (err != ERROR_SUCCESS) {
        XDBGWRN("EEPROM", "Failed to update EEPROM content (error = %d)",  err);
    }
    return err;
}

// Constructor
CXSettings::CXSettings()
: bInitialized( FALSE ),
m_pUserSettings( NULL ),
m_pFactorySettings( NULL ),
m_pEncSettings( NULL ),
m_pszIPAddress( NULL ),
m_pszDebugIPAddress( NULL ),
m_pszPrimaryDNS( NULL ),
m_pszSecondaryDNS( NULL ),
m_pszSubnetMask( NULL ),
m_pszGateway( NULL ),
m_pszDisplaySetting( NULL ),
m_pszMachineName( NULL )
{
    XDBGTRC( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::CXSettings()" );

    m_pszMachineName = new char[XSETTINGS_MACHINENAME_LENGTH + 1];
    m_pszDisplaySetting = new char[XSETTINGS_DISPLAYSETTING_TEXT_LENGTH + 1];
    if( ( !m_pszMachineName ) || ( !m_pszDisplaySetting ) )
        XDBGERR( XSETTINGS_APP_TITLE_NAME_A, "***CXSettings::CXSettings():Failed to allocate memory!!" );
    else
    {
        ZeroMemory( m_pszMachineName, XSETTINGS_MACHINENAME_LENGTH + 1 );
        ZeroMemory( m_pszDisplaySetting, XSETTINGS_DISPLAYSETTING_TEXT_LENGTH + 1 );
    }

    // Clear out our Memory
    ZeroMemory( &m_AllSettings, sizeof( m_AllSettings ) );
    ZeroMemory( &m_PrevAllSettings, sizeof( m_PrevAllSettings ) );

    m_pUserSettings = (XBOX_USER_SETTINGS*)m_AllSettings.UserConfigSection;
    m_pFactorySettings = (XBOX_FACTORY_SETTINGS*)m_AllSettings.FactorySection;
    m_pEncSettings = (XBOX_ENCRYPTED_SETTINGS*)m_AllSettings.EncryptedSection;

    if( FAILED( Init() ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::CXSettings():Failed to Initialized and Load Settings!!" );
    }
}  


// Destructor
CXSettings::~CXSettings()
{
    XDBGTRC( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::~CXSettings()" );

    if( m_pszIPAddress != NULL )
    {
        delete[] m_pszIPAddress;
        m_pszIPAddress = NULL;
    }
    
    if( m_pszDebugIPAddress != NULL  )
    {
        delete[] m_pszDebugIPAddress;
        m_pszDebugIPAddress = NULL;
    }

	if( m_pszPrimaryDNS != NULL  )
	{
		delete[] m_pszPrimaryDNS;
		m_pszPrimaryDNS = NULL;
	}

	if( m_pszSecondaryDNS != NULL  )
	{
		delete[] m_pszSecondaryDNS;
		m_pszSecondaryDNS = NULL;
	}
    
    if( m_pszSubnetMask != NULL  )
    {
        delete[] m_pszSubnetMask;
        m_pszSubnetMask = NULL;
    }

    if( m_pszGateway != NULL  )
    {
        delete[] m_pszGateway;
        m_pszGateway = NULL;
    }
    
    if( m_pszMachineName != NULL  )
    {
        delete[] m_pszMachineName;
        m_pszMachineName = NULL;
    }

    if( m_pszDisplaySetting != NULL  )
    {
        delete[] m_pszDisplaySetting;
        m_pszDisplaySetting = NULL;
    }
}


// Initialize our object
HRESULT CXSettings::Init()
{
    XDBGTRC( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::Init()" );

    HRESULT hr = S_OK;

    /////////////////////////
    // Initialize EEPROM Key
    /////////////////////////
    if( 0 == memcmp( XboxEEPROMKey, (void*)"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", XBOX_KEY_LENGTH ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "Init():EEPROM Key was all Zeros... changing" );

        memcpy( (void*)XboxEEPROMKey, SETTINGS_EEPROM_DEVKIT_KEY, XBOX_KEY_LENGTH );
    }

    // Load our settings in to our variables
    if( FAILED( hr = LoadSettings() ) )
        XDBGERR( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::Init():LoadSettings() failed!! - '%X'", hr );

    return hr;
}


// Get the Xbox IP address
char* CXSettings::GetIPAddress()
{
    // Free our memory
    if( m_pszIPAddress )
    {
        delete[] m_pszIPAddress;
        m_pszIPAddress = NULL;
    }

    // Get the new IP Address
    m_pszIPAddress = StringFromIPAddress( m_XNetConfigParams.ina.s_addr );

    return m_pszIPAddress;
}

// Get the Xbox Debug IP address
char* CXSettings::GetDebugIPAddress()
{
    // Free our memory
    if( m_pszDebugIPAddress )
    {
        delete[] m_pszDebugIPAddress;
        m_pszDebugIPAddress = NULL;
    }

    // Get the Debug IP Address
    m_pszDebugIPAddress = StringFromIPAddress( (ULONG)DmTell(DMTELL_GETDBGIP, NULL) );

    return m_pszDebugIPAddress;
}


// Get the Xbox Subnet mask
char* CXSettings::GetSubnetMask()
{
    // Free our memory
    if( m_pszSubnetMask )
    {
        delete[] m_pszSubnetMask;
        m_pszSubnetMask = NULL;
    }

    // Get the new Subnet Mask
    m_pszSubnetMask = StringFromIPAddress( m_XNetConfigParams.inaMask.s_addr );
    
    return m_pszSubnetMask;
}


// Get the Xbox Subnet mask
char* CXSettings::GetGateway()
{
    // Free our memory
    if( m_pszGateway )
    {
        delete[] m_pszGateway;
        m_pszGateway = NULL;
    }

    // Get the new Gateway Address
    m_pszGateway = StringFromIPAddress( m_XNetConfigParams.inaGateway.s_addr );
    
    return m_pszGateway;
}

// Get the Xbox Primary DNS address
char* CXSettings::GetPrimaryDNS()
{
    // Free our memory
    if( m_pszPrimaryDNS )
    {
        delete[] m_pszPrimaryDNS;
        m_pszPrimaryDNS = NULL;
    }

    // Get the new Gateway Address
    m_pszPrimaryDNS = StringFromIPAddress( m_XNetConfigParams.inaDnsPrimary.s_addr );
    
    return m_pszPrimaryDNS;
}


// Get the Xbox Secondary DNS address
char* CXSettings::GetSecondaryDNS()
{
    // Free our memory
    if( m_pszSecondaryDNS )
    {
        delete[] m_pszSecondaryDNS;
        m_pszSecondaryDNS = NULL;
    }

    // Get the new Gateway Address
    m_pszSecondaryDNS = StringFromIPAddress( m_XNetConfigParams.inaDnsSecondary.s_addr );
    
    return m_pszSecondaryDNS;
}


// Get the Xbox Machine name
char* CXSettings::GetMachineName()
{
    // Zero out the machine name
    DWORD mnSize = XSETTINGS_MACHINENAME_LENGTH + 1;
    ZeroMemory( m_pszMachineName, mnSize );

    // Get Machine Name
    if( FAILED( DmGetXboxName( m_pszMachineName, &mnSize ) ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::GetMachineName():failed to get the Machine Name!!" );
    }

    return m_pszMachineName;
}


// Will compare the latest settings to the previous settings, and determine if they have changed
BOOL CXSettings::SettingsHaveChanged()
{
    // Check the Settings
    if( 0 != memcmp( &m_PrevAllSettings, &m_AllSettings, sizeof( m_PrevAllSettings ) ) )
    {
        XDBGTRC( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SettingsHaveChanged():Settings Changed!!" );

        return TRUE;
    }

    return FALSE;
}


// Load the settings in to our variables from the settings file
HRESULT CXSettings::LoadSettings()
{
    XDBGTRC( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::LoadSettings()" );

    // Store the previous settings
    memcpy( &m_PrevAllSettings, &m_AllSettings, sizeof( m_PrevAllSettings ) );

    // Get ALL EEPROM Settings
    DWORD dwType;
    HRESULT hr = S_OK;
    if( FAILED( XQueryValue( XC_MAX_ALL, &dwType, &m_AllSettings, sizeof( m_AllSettings ), NULL ) ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::LoadSettings():failed to get All EEPROM Settings!! - '0x%.8X (%d)'", hr, hr );

        hr = E_FAIL;
    }

    // Get XNet config settings
    XNetLoadConfigParams(&m_XNetConfigParams);

    // The in-memory representation of the encrypted section is always unencrypted
    if( DecryptEEPROMEncryptedSection( m_pEncSettings ) != ERROR_SUCCESS )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::LoadSettings():Failed to decrypt the EEPROM!!" );
        
        hr = E_FAIL;
    }

    return hr;
}


// Enable or Disable 1080i
HRESULT CXSettings::Set1080i( BOOL bEnable )
{
    DWORD dw1080iSetting = m_pUserSettings->VideoFlags;

    if( bEnable )
    {
        dw1080iSetting |= AV_FLAGS_HDTV_1080i;
    }
    else
    {
        dw1080iSetting &= ~AV_FLAGS_HDTV_1080i;
    }

    // Store the DTS Setting in to the Xbox EEPROM
    HRESULT hr = S_OK;
    if( FAILED( hr = XSetValue( XC_VIDEO_FLAGS, REG_DWORD, &dw1080iSetting, sizeof( dw1080iSetting ) ) ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::Set1080i():Failed to set 1080i!! - '0x%.8X (%d)'", hr, hr );
    }

    // Load the updated settings
    HRESULT hr2 = S_OK;
    if( FAILED( hr2 = LoadSettings() ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::Set1080i():There was a problem reloading the settings!! - '0x.8X (%d)'", hr2, hr2 );
    }

    return hr;
}


// Enable or Disable 720p
HRESULT CXSettings::Set720p( BOOL bEnable )
{
    DWORD dw720pSetting = m_pUserSettings->VideoFlags;

    if( bEnable )
    {
        dw720pSetting |= AV_FLAGS_HDTV_720p;
    }
    else
    {
        dw720pSetting &= ~AV_FLAGS_HDTV_720p;
    }

    // Store the DTS Setting in to the Xbox EEPROM
    HRESULT hr = S_OK;
    if( FAILED( hr = XSetValue( XC_VIDEO_FLAGS, REG_DWORD, &dw720pSetting, sizeof( dw720pSetting ) ) ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::Set720p():Failed to set 720p!! - '0x%.8X (%d)'", hr, hr );
    }

    // Load the updated settings
    HRESULT hr2 = S_OK;
    if( FAILED( hr2 = LoadSettings() ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::Set720p():There was a problem reloading the settings!! - '0x.8X (%d)'", hr2, hr2 );
    }

    return hr;
}


// Enable or Disable 480p
HRESULT CXSettings::Set480p( BOOL bEnable )
{
    DWORD dw480pSetting = m_pUserSettings->VideoFlags;

    if( bEnable )
    {
        dw480pSetting |= AV_FLAGS_HDTV_480p;
    }
    else
    {
        dw480pSetting &= ~AV_FLAGS_HDTV_480p;
    }

    // Store the DTS Setting in to the Xbox EEPROM
    HRESULT hr = S_OK;
    if( FAILED( hr = XSetValue( XC_VIDEO_FLAGS, REG_DWORD, &dw480pSetting, sizeof( dw480pSetting ) ) ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::Set480p():Failed to set 480p!! - '0x%.8X (%d)'", hr, hr );
    }

    // Load the updated settings
    HRESULT hr2 = S_OK;
    if( FAILED( hr2 = LoadSettings() ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::Set480p():There was a problem reloading the settings!! - '0x.8X (%d)'", hr2, hr2 );
    }

    return hr;
}


// Enable or Disable PAL 60
HRESULT CXSettings::SetPAL60( BOOL bEnable )
{
    DWORD dwVideoSetting = m_pUserSettings->VideoFlags;

    if( bEnable )
    {
        dwVideoSetting |= AV_FLAGS_60Hz;
    }
    else
    {
        dwVideoSetting &= ~AV_FLAGS_60Hz;
    }

    // Store the DTS Setting in to the Xbox EEPROM
    HRESULT hr = S_OK;
    if( FAILED( hr = XSetValue( XC_VIDEO_FLAGS, REG_DWORD, &dwVideoSetting, sizeof( dwVideoSetting ) ) ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetPAL60():Failed to set PAL60!! - '0x%.8X (%d)'", hr, hr );
    }

    // Load the updated settings
    HRESULT hr2 = S_OK;
    if( FAILED( hr2 = LoadSettings() ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetPAL60():There was a problem reloading the settings!! - '0x.8X (%d)'", hr2, hr2 );
    }

    return hr;
}


// Enable or Disable Widescreen
HRESULT CXSettings::SetWidescreen( BOOL bEnable )
{
    DWORD dwVideoSetting = m_pUserSettings->VideoFlags;

    dwVideoSetting &= ~(AV_FLAGS_WIDESCREEN | AV_FLAGS_LETTERBOX);

    if( bEnable )
    {
        dwVideoSetting |= AV_FLAGS_WIDESCREEN;
    }

    // Store the DTS Setting in to the Xbox EEPROM
    HRESULT hr = S_OK;
    if( FAILED( hr = XSetValue( XC_VIDEO_FLAGS, REG_DWORD, &dwVideoSetting, sizeof( dwVideoSetting ) ) ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetWidescreen():Failed to set Widescreen!! - '0x%.8X (%d)'", hr, hr );
    }

    // Load the updated settings
    HRESULT hr2 = S_OK;
    if( FAILED( hr2 = LoadSettings() ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetWidescreen():There was a problem reloading the settings!! - '0x.8X (%d)'", hr2, hr2 );
    }

    return hr;
}


// Enable or Disable Letterbox
HRESULT CXSettings::SetLetterbox( BOOL bEnable )
{
    DWORD dwVideoSetting = m_pUserSettings->VideoFlags;

    dwVideoSetting &= ~(AV_FLAGS_WIDESCREEN | AV_FLAGS_LETTERBOX);

    if( bEnable )
    {
        dwVideoSetting |= AV_FLAGS_LETTERBOX;
    }

    // Store the DTS Setting in to the Xbox EEPROM
    HRESULT hr = S_OK;
    if( FAILED( hr = XSetValue( XC_VIDEO_FLAGS, REG_DWORD, &dwVideoSetting, sizeof( dwVideoSetting ) ) ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetLetterbox():Failed to set Letterbox!! - '0x%.8X (%d)'", hr, hr );
    }

    // Load the updated settings
    HRESULT hr2 = S_OK;
    if( FAILED( hr2 = LoadSettings() ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetLetterbox():There was a problem reloading the settings!! - '0x.8X (%d)'", hr2, hr2 );
    }

    return hr;
}


// Enable or Disable DTS
HRESULT CXSettings::SetDTS( BOOL bEnable )
{
    DWORD dwAudioSetting = m_pUserSettings->AudioFlags;

    if( bEnable )
    {
        dwAudioSetting |= XC_AUDIO_FLAGS_ENABLE_DTS;
    }
    else
    {
        dwAudioSetting &= ~XC_AUDIO_FLAGS_ENABLE_DTS;
    }

    // Store the DTS Setting in to the Xbox EEPROM
    HRESULT hr = S_OK;
    if( FAILED( hr = XSetValue( XC_AUDIO_FLAGS, REG_DWORD, &dwAudioSetting, sizeof( dwAudioSetting ) ) ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetDTS():Failed to set DTS!! - '0x%.8X (%d)'", hr, hr );
    }

    // Load the updated settings
    HRESULT hr2 = S_OK;
    if( FAILED( hr2 = LoadSettings() ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetDTS( ):There was a problem reloading the settings!! - '0x.8X (%d)'", hr2, hr2 );
    }

    return hr;
}

// Enable or Disable Dolby Digital
HRESULT CXSettings::SetDolbyDigital( BOOL bEnable )
{
    DWORD dwAudioSetting = m_pUserSettings->AudioFlags;

    if( bEnable )
    {
        dwAudioSetting |= XC_AUDIO_FLAGS_ENABLE_AC3;
    }
    else
    {
        dwAudioSetting &= ~XC_AUDIO_FLAGS_ENABLE_AC3;
    }

    // Store the AC3 Setting in to the Xbox EEPROM
    HRESULT hr = S_OK;
    if( FAILED( hr = XSetValue( XC_AUDIO_FLAGS, REG_DWORD, &dwAudioSetting, sizeof( dwAudioSetting ) ) ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetDolbyDigital():Failed to set AC3!! - '0x%.8X (%d)'", hr, hr );
    }

    // Load the updated settings
    HRESULT hr2 = S_OK;
    if( FAILED( hr2 = LoadSettings() ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetDolbyDigital( ):There was a problem reloading the settings!! - '0x.8X (%d)'", hr2, hr2 );
    }

    return hr;
}



// This method will convert the address in to a char* and then
// set it in to the EEPROM
HRESULT CXSettings::SetDebugIPAddress( WCHAR* IPAddress )
{
    XDBGTRC( XSETTINGS_APP_TITLE_NAME_A, "CIPMenu::SetDebugIPAddress( WCHAR* )" );

    if( !IPAddress )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetDebugIPAddress( WCHAR ):Invalid arg!!" );

        return E_INVALIDARG;
    }

    char locIPAddress[XSETTINGS_IPADDRESS_LENGTH + 1];
    ZeroMemory( locIPAddress, XSETTINGS_IPADDRESS_LENGTH + 1 );

    _snprintf( locIPAddress, XSETTINGS_IPADDRESS_LENGTH, "%S", IPAddress );
    HRESULT hr = SetDebugIPAddress( locIPAddress );

    return hr;
}


// Set the Debug IP Address on the Xbox
HRESULT CXSettings::SetDebugIPAddress( char* IPAddress )
{
    XDBGTRC( XSETTINGS_APP_TITLE_NAME_A, "CIPMenu::SetDebugIPAddress( char* )" );

    if( !IPAddress )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetDebugIPAddress( char ):Invalid arg!!" );

        return E_INVALIDARG;
    }

    DWORD dwAddress = 0L;

    // Convert IP Address in to a DWORD
    if( !ParseIPAddress( IPAddress, dwAddress ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetDebugIPAddress( char ):IP Address not valid!!" );

        return E_INVALIDARG;
    }

    // Store the valid address in to the Xbox EEPROM
    DmTell(DMTELL_SETDBGIP, (PVOID)dwAddress);

    // Load the updated settings
    if( FAILED( LoadSettings() ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetDebugIPAddress( char ):There was a problem reloading the settings!!" );
    }

    // Determine if the user set DHCP (blank Debug IP), and adjust the other variables accordingly
    if( ( '\0' == GetDebugIPAddress()[0] ) && ( '\0' == GetIPAddress()[0] ) )
    {
        if( FAILED( SetSubnetMask( "\0" ) ) )
        {
            XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetDebugIPAddress( char ):Failed to set Subnet Mask to '\\0'!!" );
        }

        if( FAILED( SetGateway( "\0" ) ) )
        {
            XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetDebugIPAddress( char ):Failed to set Gateway to '\\0'!!" );
        }
    }

    // Load the updated settings after we set the Subnet mask and the gateway
    if( FAILED( LoadSettings() ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetDebugIPAddress( char ):There was a problem reloading the settings!!" );
    }

    return S_OK;
}


// This method will convert the address in to a char* and then
// set it in to the EEPROM
HRESULT CXSettings::SetIPAddress( WCHAR* IPAddress )
{
    XDBGTRC( XSETTINGS_APP_TITLE_NAME_A, "CIPMenu::SetIPAddress( WCHAR* )" );

    if( !IPAddress )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetIPAddress( WCHAR ):Invalid arg!!" );

        return E_INVALIDARG;
    }

    char locIPAddress[XSETTINGS_IPADDRESS_LENGTH + 1];
    ZeroMemory( locIPAddress, XSETTINGS_IPADDRESS_LENGTH + 1 );

    _snprintf( locIPAddress, XSETTINGS_IPADDRESS_LENGTH, "%S", IPAddress );
    HRESULT hr = SetIPAddress( locIPAddress );

    return hr;
}


// Set the IP Address on the Xbox
HRESULT CXSettings::SetIPAddress( char* IPAddress )
{
    XDBGTRC( XSETTINGS_APP_TITLE_NAME_A, "CIPMenu::SetIPAddress( char* )" );

    if( !IPAddress )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetIPAddress( char ):Invalid arg!!" );
        return E_INVALIDARG;
    }

    DWORD dwAddress = 0L;

    // Convert IP Address in to a DWORD
    if( !ParseIPAddress( IPAddress, dwAddress ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetIPAddress( char ):IP Address not valid!!" );

        return E_INVALIDARG;
    }

    // Store the valid address in the xnet config sector
    XNetConfigParams xncp;
    XNetLoadConfigParams(&xncp);
    xncp.ina.s_addr = dwAddress;
    XNetSaveConfigParams(&xncp);

    // Store the valid address in to the Xbox EEPROM (for backward compat)
    HRESULT hr = S_OK;
    if( FAILED( hr = XSetValue( XC_ONLINE_IP_ADDRESS, REG_DWORD, &dwAddress, sizeof( dwAddress ) ) ) )
    {
        XDBGERR( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetIPAddress( char ):Failed to set IP Address in the EEPROM!! - (0x%X)", hr );

        return hr;
    }

    // Load the updated settings
    if( FAILED( LoadSettings() ) )
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetIPAddress( char ):There was a problem reloading the settings!!" );

    // Determine if the user set DHCP (blank IP), and adjust the other variables accordingly
    if( ( '\0' == GetDebugIPAddress()[0] ) && ( '\0' == GetIPAddress()[0] ) )
    {
        if( FAILED( SetSubnetMask( "\0" ) ) )
        {
            XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetIPAddress( char ):Failed to set Subnet Mask to '\\0'!!" );
        }

        if( FAILED( SetGateway( "\0" ) ) )
        {
            XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetIPAddress( char ):Failed to set Gateway to '\\0'!!" );
        }

        if( FAILED( SetPrimaryDNS( "\0" ) ) )
        {
            XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetPrimaryDNS( char ):Failed to set Primary DNS to '\\0'!!" );
        }

        if( FAILED( SetSecondaryDNS( "\0" ) ) )
        {
            XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetSecondaryDNS( char ):Failed to set Secondary DNS to '\\0'!!" );
        }
    }

    // Load the updated settings after we set the Subnet mask and the gateway
    if( FAILED( LoadSettings() ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetIPAddress( char ):There was a problem reloading the settings!!" );
    }

    return hr;
}



// This method will convert the address in to a char* and then
// set it in to the EEPROM
HRESULT CXSettings::SetPrimaryDNS( WCHAR* IPAddress )
{
    XDBGTRC( XSETTINGS_APP_TITLE_NAME_A, "CIPMenu::SetPrimaryDNS( WCHAR* )" );

    if( !IPAddress )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetPrimaryDNS( WCHAR ):Invalid arg!!" );

        return E_INVALIDARG;
    }

    char locIPAddress[XSETTINGS_IPADDRESS_LENGTH + 1];
    ZeroMemory( locIPAddress, XSETTINGS_IPADDRESS_LENGTH + 1 );

    _snprintf( locIPAddress, XSETTINGS_IPADDRESS_LENGTH, "%S", IPAddress );
    HRESULT hr = SetPrimaryDNS( locIPAddress );

    return hr;
}


// Set the Primary DNS Address on the Xbox
HRESULT CXSettings::SetPrimaryDNS( char* IPAddress )
{
    XDBGTRC( XSETTINGS_APP_TITLE_NAME_A, "CIPMenu::SetPrimaryDNS( char* )" );

    if( !IPAddress )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetPrimaryDNS( char ):Invalid arg!!" );
        return E_INVALIDARG;
    }

    DWORD dwAddress = 0L;

    // Convert IP Address in to a DWORD
    if( !ParseIPAddress( IPAddress, dwAddress ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetPrimaryDNS( char ):IP Address not valid!!" );

        return E_INVALIDARG;
    }

    // Store the valid address in the xnet config sector
    XNetConfigParams xncp;
    XNetLoadConfigParams(&xncp);
    xncp.inaDnsPrimary.s_addr = dwAddress;
    XNetSaveConfigParams(&xncp);

    // Load the updated settings
    if( FAILED( LoadSettings() ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetPrimaryDNS( char ):There was a problem reloading the settings!!" );
    }

    return S_OK;
}

// This method will convert the address in to a char* and then
// set it in to the EEPROM
HRESULT CXSettings::SetSecondaryDNS( WCHAR* IPAddress )
{
    XDBGTRC( XSETTINGS_APP_TITLE_NAME_A, "CIPMenu::SetSecondaryDNS( WCHAR* )" );

    if( !IPAddress )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetSecondaryDNS( WCHAR ):Invalid arg!!" );

        return E_INVALIDARG;
    }

    char locIPAddress[XSETTINGS_IPADDRESS_LENGTH + 1];
    ZeroMemory( locIPAddress, XSETTINGS_IPADDRESS_LENGTH + 1 );

    _snprintf( locIPAddress, XSETTINGS_IPADDRESS_LENGTH, "%S", IPAddress );
    HRESULT hr = SetSecondaryDNS( locIPAddress );

    return hr;
}


// Set the Secondary DNS Address on the Xbox
HRESULT CXSettings::SetSecondaryDNS( char* IPAddress )
{
    XDBGTRC( XSETTINGS_APP_TITLE_NAME_A, "CIPMenu::SetSecondaryDNS( char* )" );

    if( !IPAddress )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetSecondaryDNS( char ):Invalid arg!!" );
        return E_INVALIDARG;
    }

    DWORD dwAddress = 0L;

    // Convert IP Address in to a DWORD
    if( !ParseIPAddress( IPAddress, dwAddress ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetSecondaryDNS( char ):IP Address not valid!!" );

        return E_INVALIDARG;
    }

    // Store the valid address in the xnet config sector
    XNetConfigParams xncp;
    XNetLoadConfigParams(&xncp);
    xncp.inaDnsSecondary.s_addr = dwAddress;
    XNetSaveConfigParams(&xncp);

    // Load the updated settings
    if( FAILED( LoadSettings() ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetSecondaryDNS( char ):There was a problem reloading the settings!!" );
    }

    return S_OK;
}


// Set the SubnetMask on the Xbox
HRESULT CXSettings::SetSubnetMask( WCHAR* SubnetMask )
{
    if( !SubnetMask )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetSubnetMask( WCHAR ):Invalid arg!!" );

        return E_INVALIDARG;
    }

    char locSubnetMask[XSETTINGS_IPADDRESS_LENGTH + 1];
    ZeroMemory( locSubnetMask, XSETTINGS_IPADDRESS_LENGTH + 1 );

    _snprintf( locSubnetMask, XSETTINGS_IPADDRESS_LENGTH, "%S", SubnetMask );
    HRESULT hr = SetSubnetMask( locSubnetMask );

    return hr;
}


// Set the SubnetMask on the Xbox
HRESULT CXSettings::SetSubnetMask( char* SubnetMask )
{
    if( !SubnetMask )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetSubnetMask( char ):Invalid arg!!" );

        return E_INVALIDARG;
    }

    DWORD dwAddress = 0L;

    // Convert IP Address in to a DWORD
    if( !ParseIPAddress( SubnetMask, dwAddress ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetSubnetMask( char ):Subnet Mask not valid!!" );

        return E_INVALIDARG;
    }

    // Store the valid address in the xnet config sector
    XNetConfigParams xncp;
    XNetLoadConfigParams(&xncp);
    xncp.inaMask.s_addr = dwAddress;
    XNetSaveConfigParams(&xncp);

    // Store the valid address in to the Xbox EEPROM (for backward compat)
    HRESULT hr = S_OK;
    if( FAILED( hr = XSetValue( XC_ONLINE_SUBNET_ADDRESS, REG_DWORD, &dwAddress, sizeof( dwAddress ) ) ) )
    {
        XDBGERR( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetSubnetMask( char ):Subnet Mask not saved in the EEPROM!! - (0x%X)", hr );

		return hr;
    }

    // Load the updated settings
    if( FAILED( LoadSettings() ) )
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetSubnetMask( char ):There was a problem reloading the settings!!" );

    return hr;
}


// Set the Gateway on the Xbox
HRESULT CXSettings::SetGateway( WCHAR* Gateway )
{
    if( !Gateway )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetGateway( WCHAR ):Invalid arg!!" );

        return E_INVALIDARG;
    }

    char locGateway[XSETTINGS_IPADDRESS_LENGTH + 1];
    ZeroMemory( locGateway, XSETTINGS_IPADDRESS_LENGTH + 1 );

    _snprintf( locGateway, XSETTINGS_IPADDRESS_LENGTH, "%S", Gateway );
    HRESULT hr = SetGateway( locGateway );

    return hr;
}


// Set the Gateway on the Xbox
HRESULT CXSettings::SetGateway( char* Gateway )
{
    if( !Gateway )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetGateway( char ):Invalid arg!!" );

        return E_INVALIDARG;
    }

    DWORD dwAddress = 0L;

    // Convert IP Address in to a DWORD
    if( !ParseIPAddress( Gateway, dwAddress ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetGateway( char ):Gateway not valid!!" );

        return E_INVALIDARG;
    }

    // Store the valid address in the xnet config sector
    XNetConfigParams xncp;
    XNetLoadConfigParams(&xncp);
    xncp.inaGateway.s_addr = dwAddress;
    XNetSaveConfigParams(&xncp);

    // Store the valid address in to the Xbox EEPROM (for backward compat)
    HRESULT hr = S_OK;
    if( FAILED( hr = XSetValue( XC_ONLINE_DEFAULT_GATEWAY_ADDRESS, REG_DWORD, &dwAddress, sizeof( dwAddress ) ) ) )
    {
        XDBGERR( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetGateway( char ):Gateway not saved in the EEPROM!!" );

        return hr;
    }

    // Load the updated settings
    if( FAILED( LoadSettings() ) )
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetGateway( char ):There was a problem reloading the settings!!" );

    return hr;
}


// Set the Gateway on the Xbox
HRESULT CXSettings::SetMachineName( WCHAR* MachineName )
{
    if( !MachineName )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetMachineName( WCHAR ):Invalid arg!!" );

        return E_INVALIDARG;
    }

    char locMachineName[XSETTINGS_MACHINENAME_LENGTH + 1];
    ZeroMemory( locMachineName, XSETTINGS_MACHINENAME_LENGTH + 1 );

    _snprintf( locMachineName, XSETTINGS_MACHINENAME_LENGTH, "%S", MachineName );
    HRESULT hr = SetMachineName( locMachineName );

    return hr;
}


// Set the MachineName on the Xbox
HRESULT CXSettings::SetMachineName( char* MachineName )
{
    if( !MachineName )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetMachineName():Invalid arg!!" );

        return E_INVALIDARG;
    }

    if( XboxNameExistsOnNet( MachineName ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetMachineName():Machine Name Exists on the Network!!" );
        
        return E_FAIL;
    }

    HRESULT hr = S_OK;
    if( FAILED( hr = DmSetXboxName( MachineName ) ) )
        XDBGERR( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetMachineName():Failed to set the name!!" );

    return hr;
}


// Functions from config.cpp of XApp

// Converts an IP Address from a string to a DWORD
BOOL CXSettings::ParseIPAddress( char* szIPAddr, DWORD& dwIPAddr )
{
	if ( szIPAddr[0] == 0 )
	{
		dwIPAddr = 0;
		return TRUE;
	}

	unsigned int b1, b2, b3, b4;
	if ( sscanf( szIPAddr, "%d.%d.%d.%d", &b1, &b2, &b3, &b4 ) != 4 || b1 > 255 || b2 > 255 || b3 > 255 || b4 > 255 )
		return FALSE;

	dwIPAddr = (b4 << 24) | (b3 << 16) | (b2 << 8) | b1;

	return TRUE;
}


HRESULT CXSettings::SetHDKey( UCHAR* puszHDKeyBuff )
{
    if( NULL == puszHDKeyBuff )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetHDKey()Invalid parameter passed in!!" );

        return E_INVALIDARG;
    }

    // Make sure the encrypted section of the EEPROM is unencrypted
    DWORD err = EncryptDecryptEEPROMEncryptedSection(FALSE);
    if (err != ERROR_SUCCESS)
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetHDKey()Failed to Decrypt the EEPROM!!" );

        return E_FAIL;
    }

    // Unlock the Hard Drive
    HRESULT hr = UnlockXboxHardDrive( NULL, 0 );
    if( FAILED( hr ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetHDKey()Failed to Unlock the Hard Drive!!" );
    }

    if( SUCCEEDED( hr ) )
    {
        // Set the HDKey to the user passed in value
        memcpy( m_pEncSettings->HDKey, puszHDKeyBuff, XBOX_KEY_LENGTH );

        // Write the EEPROM data back to store the new key
        NTSTATUS status = ExSaveNonVolatileSetting( XC_MAX_ALL, REG_BINARY, &m_AllSettings, EEPROM_TOTAL_MEMORY_SIZE );
        if ( !NT_SUCCESS( status ) )
        {
            XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetHDKey()Failed to write the EEPROM data!!" );

            hr = E_FAIL;
        }
    }
    
    if( SUCCEEDED( hr ) )
    {
        //
        // Compute Key to use to lock hard drive
        //
        BYTE FinalHardDriveKey[XC_SERVICE_DIGEST_SIZE];

        XcHMAC( m_pEncSettings->HDKey, XBOX_KEY_LENGTH,
                (LPBYTE)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
                (LPBYTE)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
                FinalHardDriveKey );

        HDSetPassword( FinalHardDriveKey, XC_SERVICE_DIGEST_SIZE );
    }

    // Encrypt the EEPROM
    err = EncryptDecryptEEPROMEncryptedSection( TRUE );
    if (err != ERROR_SUCCESS)
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetHDKey()Failed to Encrypt the EEPROM!!" );

        hr = E_FAIL;
    }

    // Load the updated settings
    if( FAILED( LoadSettings() ) )
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetHDKey():There was a problem reloading the settings!!" );

    return hr;
}


// Set the Xbox Game Region
HRESULT CXSettings::SetGameRegion( DWORD dwGameRegion )
{
    // Make sure the encrypted section of the EEPROM is unencrypted
    DWORD err = EncryptDecryptEEPROMEncryptedSection(FALSE);
    if (err != ERROR_SUCCESS)
        return E_FAIL;

    // Store the Game Region to the Xbox EEPROM
    HRESULT hr = XSetValue( XC_FACTORY_GAME_REGION, REG_DWORD, &dwGameRegion, sizeof( dwGameRegion ) );
    if( FAILED( hr ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetGameRegion():Game Region not saved in to the EEPROM!! Region - '%d' - '0x%0.8X (%d)'", dwGameRegion, hr, hr );
    }

    // Encrypt the EEPROM Encrypted Section
    err = EncryptDecryptEEPROMEncryptedSection( TRUE );
    if (err != ERROR_SUCCESS)
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetGameRegion():Failed to Encrypt the EEPROM!!" );

        hr = E_FAIL;
    }

    // Load the updated settings
    if( FAILED( LoadSettings() ) )
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetGameRegion():There was a problem reloading the settings!!" );

    return hr;
}


// Get the Xbox Game Region
DWORD CXSettings::GetGameRegion()
{
    return m_pEncSettings->GameRegion;
}

// Set the Xbox AV Region
HRESULT CXSettings::SetAVRegion( DWORD dwAVRegion )
{
    // Store the Display Setting to the Xbox EEPROM
    HRESULT hr = S_OK;
    if( FAILED( hr = XSetValue( XC_FACTORY_AV_REGION, REG_DWORD, &dwAVRegion, sizeof( dwAVRegion) ) ) )
        XDBGERR( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetAVRegion():AV region not saved in to the EEPROM!! Region - '%d', Error - '0x%0.8X (%d)'", dwAVRegion, hr, hr );

    // Load the updated settings
    if( FAILED( LoadSettings() ) )
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetAVRegion():There was a problem reloading the settings!!" );

    return hr;
}

// Get the Xbox AV Region
DWORD CXSettings::GetAVRegion()
{
    return m_pFactorySettings->AVRegion;
}


// Set the Xbox Language
HRESULT CXSettings::SetLanguage( DWORD dwLanguage )
{
    // Store the Languageto the Xbox EEPROM
    HRESULT hr = XSetValue( XC_LANGUAGE, REG_DWORD, &dwLanguage, sizeof( dwLanguage ) );
    if( FAILED( hr ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetLanguage():Language not saved in to the EEPROM!! - '0x%.8X'", hr );

		return hr;
    }

    // Load the updated settings
    if( FAILED( LoadSettings() ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetLanguage():There was a problem reloading the settings!!" );
    }

    return S_OK;
}

// Get the Xbox Language
DWORD CXSettings::GetLanguage()
{
    return m_pUserSettings->Language;
}


// Set the Time Zone information
HRESULT CXSettings::SetTimeZoneInfo( unsigned int uiIndex )
{
    if ( uiIndex >= XSETTINGS_TIMEZONECOUNT )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetTimeZoneInfo():Invalid index passed in!! Index - '%u', Max - '%u'", uiIndex, XSETTINGS_TIMEZONECOUNT - 1 );

        return E_INVALIDARG;
    }

    TIME_ZONE_INFORMATION tzinfo;
    ZeroMemory( &tzinfo, sizeof( tzinfo ) );

    const struct TZINFO* srcinfo = &g_timezoneinfo[uiIndex];

    tzinfo.Bias = srcinfo->bias;
    tzinfo.StandardBias = srcinfo->stdbias;
    tzinfo.DaylightBias = srcinfo->dltbias;

    wcsncpy(tzinfo.StandardName, srcinfo->stdname, countof(tzinfo.StandardName));
    wcsncpy(tzinfo.DaylightName,
            srcinfo->dltname ? srcinfo->dltname : srcinfo->stdname,
            countof(tzinfo.DaylightName));

    TZDateToSysTime(&srcinfo->stddate, &tzinfo.StandardDate);
    TZDateToSysTime(&srcinfo->dltdate, &tzinfo.DaylightDate);

    XapipSetTimeZoneInformation(&tzinfo);

    // Load the updated settings
    if( FAILED( LoadSettings() ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetTimeZoneInfo():There was a problem reloading the settings!!" );
    }

    return S_OK;
}

// Convert a timezone date into a system time date
void CXSettings::TZDateToSysTime(const struct TZDATE* tzdate, SYSTEMTIME* systime)
{
    systime->wMonth = tzdate->month;
    systime->wDay = tzdate->day;
    systime->wDayOfWeek = tzdate->dayofweek;
    systime->wHour = tzdate->hour;
}

// Get the Index of the current timezone in the EEPROM
unsigned int CXSettings::GetCurrentTimeZoneIndex()
{
    int iBestMatch, iBestResult;
    iBestMatch = iBestResult = -1;
    WCHAR pwszNameBuf[40];
    ZeroMemory( pwszNameBuf, sizeof( WCHAR ) * 40 );
    for (unsigned int uiIndex = 0; uiIndex < XSETTINGS_TIMEZONECOUNT; uiIndex++ )
    {
        const struct TZINFO* srcinfo = &g_timezoneinfo[uiIndex];
        if( srcinfo->bias == GetUserTimeZoneBias() )
        {
            int iMatch = 1;
            if( srcinfo->stdbias == GetUserTimeZoneStdBias() &&
                srcinfo->dltbias == GetUserTimeZoneDltBias() )
            {
                 iMatch++;

                // Compare only the first 4 characters of the time zone name
                // because that's what we store in the EEPROM.
                // If everything matches, no need to continue searching.
                GetUserTimeZoneStdName( pwszNameBuf, 39 );
                if( wcsncmp( srcinfo->stdname, pwszNameBuf, 4 ) == 0 )
                {
                    return uiIndex;
                }
            }

            if ( iMatch > iBestMatch )
            {
                iBestMatch = iMatch;
                iBestResult = uiIndex;
            }
        }
    }

    return iBestResult;
}


// Get the currently set Time Zone information from the EEPROM
TZINFO* CXSettings::GetCurrentTimeZoneInfo()
{
    unsigned int uiCurrentTZIndex = GetCurrentTimeZoneIndex();

    return &g_timezoneinfo[uiCurrentTZIndex];
}


// Get the Xbox Time Zone Information for a specified index
TZINFO* CXSettings::GetTimeZoneInfo( unsigned int uiIndex )
{
    if( uiIndex >= XSETTINGS_TIMEZONECOUNT )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::GetTimeZoneInfo():Requested invalid index!! Index - '%u', Max - '%u'", uiIndex, XSETTINGS_TIMEZONECOUNT - 1 );

        return NULL;
    }

    return &g_timezoneinfo[uiIndex];
}


// Get the state of 1080i
BOOL CXSettings::Get1080i()
{
    if( ( m_pUserSettings->VideoFlags & AV_FLAGS_HDTV_1080i ) > 0 )
    {
        return TRUE;
    }

    return FALSE;
}

// Get the state of 720p
BOOL CXSettings::Get720p()
{
    if( ( m_pUserSettings->VideoFlags & AV_FLAGS_HDTV_720p ) > 0 )
    {
        return TRUE;
    }

    return FALSE;
}


// Get the state of 480p
BOOL CXSettings::Get480p()
{
    if( ( m_pUserSettings->VideoFlags & AV_FLAGS_HDTV_480p ) > 0 )
    {
        return TRUE;
    }

    return FALSE;
}

// Get the state of PAL 60
BOOL CXSettings::GetPAL60()
{
    if( ( m_pUserSettings->VideoFlags & AV_FLAGS_60Hz ) > 0 )
    {
        return TRUE;
    }

    return FALSE;
}


// Get the state of Widescreen
BOOL CXSettings::GetWidescreen()
{
    if( ( m_pUserSettings->VideoFlags & AV_FLAGS_WIDESCREEN ) > 0 )
    {
        return TRUE;
    }

    return FALSE;
}


// Get the state of Letterbox
BOOL CXSettings::GetLetterbox()
{
    if( ( m_pUserSettings->VideoFlags & AV_FLAGS_LETTERBOX ) > 0 )
    {
        return TRUE;
    }

    return FALSE;
}


// Get the state of DTS
BOOL CXSettings::GetDTS()
{
    if( ( m_pUserSettings->AudioFlags & XC_AUDIO_FLAGS_ENABLE_DTS ) > 0 )
    {
        return TRUE;
    }

    return FALSE;
}


// Get the state of Dolby Digital
BOOL CXSettings::GetDolbyDigital()
{
    if( ( m_pUserSettings->AudioFlags & XC_AUDIO_FLAGS_ENABLE_AC3 ) > 0 )
    {
        return TRUE;
    }

    return FALSE;
}



// Set the Xbox DVD Region
HRESULT CXSettings::SetDVDRegion( DWORD dwDVDRegion )
{
    //
    // Set the AV Region in to the EEPROM
    //
    HRESULT hr = S_OK;
    if( FAILED( hr = XSetValue( XC_DVD_REGION, REG_DWORD, &dwDVDRegion, sizeof( dwDVDRegion) ) ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetDVDRegion():DVD region not saved in to the EEPROM!! Region - '%d', Error - '0x%0.8X (%d)'", dwDVDRegion, hr, hr );
    }

    // Load the updated settings
    if( FAILED( LoadSettings() ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::SetDVDRegion():There was a problem reloading the settings!!" );
    }

    return hr;
}


// Get the Xbox DVD Region
DWORD CXSettings::GetDVDRegion()
{
    return m_pUserSettings->DvdRegion;
}


// Returns the recovery key generated from the current HD Key
void CXSettings::GetHDRecoveryKey( OUT UCHAR* pucBuffer, IN ULONG cbBufferSize )
{
    if( NULL == pucBuffer )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::GetHDRecoveryKey():Invalid parameter passed in!!" );

        return;
    }

    ASSERT( cbBufferSize >= RECOVERY_KEY_LEN );

    ComputeRecoveryKey((LPBYTE)m_pEncSettings->HDKey, (char*)pucBuffer);
}

// Resets all values on the Xbox back to their "Default" state
HRESULT CXSettings::ResetAllToDefaults()
{
    //
    // Reset all User Configuration Data
    //
	XBOX_USER_SETTINGS  UserSettings;	// All User Configuration Settings
	ZeroMemory( &UserSettings, sizeof( UserSettings ) );

    DWORD dwType;
    HRESULT hr = S_OK;
    if( FAILED( hr = XSetValue( XC_MAX_OS, 0, &UserSettings, sizeof( UserSettings ) ) ) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::ResetAllToDefaults():failed to reset!! - '0x%0.8X'", hr );
    }

    //
    // Clear the Refurb sector
    //
    NTSTATUS status;
    XBOX_REFURB_INFO refurbInfo;

    ZeroMemory( &refurbInfo, sizeof( refurbInfo ) );

    status = ExReadWriteRefurbInfo(&refurbInfo, sizeof(refurbInfo), TRUE);
    if( !NT_SUCCESS(status) )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::ResetAllToDefaults():Failed to Clear the RefurbInfo!! Error - '0x%0.8X (%d)'", status, status );
    }

    //
    // Set the Clock to a very early date
    //
    SYSTEMTIME sysTime;
    ZeroMemory( &sysTime, sizeof( sysTime ) );

    sysTime.wHour = 0;
    sysTime.wMinute = 0;
    sysTime.wSecond = 0;
    sysTime.wMilliseconds = 0;
    sysTime.wMonth = 1;
    sysTime.wDay = 1;
    sysTime.wDayOfWeek = 0;
    sysTime.wYear = 1980;

    XapiSetLocalTime(&sysTime);

	return hr;
}


// Converts an IP Address from a DWORD to a string
char* CXSettings::StringFromIPAddress( DWORD dwIPAddr )
{
	if ( dwIPAddr == 0l )
    {
        char* szBuf = new char[1];
        szBuf[0] = '\0';
		
        return szBuf;
    }

	BYTE b4 = (BYTE)( dwIPAddr >> 24 );
	BYTE b3 = (BYTE)( dwIPAddr >> 16 );
	BYTE b2 = (BYTE)( dwIPAddr >> 8 );
	BYTE b1 = (BYTE)dwIPAddr;

	char* szBuf = new char[XSETTINGS_IPADDRESS_LENGTH + 1];
    szBuf[XSETTINGS_IPADDRESS_LENGTH] = '\0';
	_snprintf( szBuf, XSETTINGS_IPADDRESS_LENGTH, "%d.%d.%d.%d", b1, b2, b3, b4 );

	return szBuf;
}

typedef struct _NM {
	BYTE bRequest;
	BYTE cchName;
	char szName[256];
} NM;

// If the Xbox name is found on the network, this will return TRUE, otherwise FALSE
BOOL CXSettings::XboxNameExistsOnNet( char* pszName )
{
	struct sockaddr_in sinU;
    NM nm;
	SOCKET s;
	int cRetries;
	BOOL f;
    const DWORD dwRetry = 750;  // Number of milliseconds to sleep when searching for an Xbox Name

    // return TRUE;

	s = socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );
	if( INVALID_SOCKET == s )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::XboxNameExistsOnNet():Invalid Socket!!" );

		return FALSE;
    }
	
    f = TRUE;
	
    if(0 != setsockopt( s, SOL_SOCKET, SO_BROADCAST, (char*)&f, sizeof f ) )
    {
		closesocket( s );

        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::XboxNameExistsOnNet():setsockopt did not return 0!!" );
		
        return FALSE;
	}
	
    sinU.sin_family = AF_INET;
	sinU.sin_port = htons( 0x2db );     // Debugger Port
	sinU.sin_addr.s_addr = htonl( INADDR_BROADCAST );

    nm.cchName = strlen( pszName );
    strncpy( nm.szName, pszName, 256 );
    nm.bRequest = 1;

    f = FALSE;
	for(cRetries = 3; !f && cRetries--; ) {
        DWORD tickTry = GetTickCount() + dwRetry;
		if(sendto(s, (char *)&nm, nm.cchName + 2, 0,
			(struct sockaddr *)&sinU, sizeof sinU) == nm.cchName + 2)
		{
			int fSel;

            do {
                int tickRetry;

                tickRetry = tickTry - GetTickCount();
                if(tickRetry <= 0)
                    fSel = 0;
                else {
			        fd_set fds;
			        struct timeval tv;

			        FD_ZERO(&fds);
			        FD_SET(s, &fds);
			        tv.tv_sec = tickRetry / 1000;
			        tv.tv_usec = (tickRetry % 1000) * 1000;
			        fSel = select(0, &fds, NULL, NULL, &tv);
                }
			    if(fSel > 0) {
				    NM nmT;
				    int cbAddr = sizeof sinU;
				    /* Got some data, is it for us? */
				    if(recvfrom(s, (char *)&nmT, sizeof nmT, 0,
						    (struct sockaddr *)&sinU, &cbAddr) <= 0)
					    fSel = -1;
				    else {
					    if(nmT.bRequest == 2 && nmT.cchName == nm.cchName &&
							!_strnicmp(nm.szName, nmT.szName, nm.cchName))
                        {
						    /* Got it! */
                            f = TRUE;
                            fSel = 0;
						    break;
                        }
				    }
			    }
                if(fSel < 0) {
				    /* Error, need to sleep */
				    Sleep(tickRetry);
                    fSel = 0;
                }
            } while(fSel);
		} else {
			int err = WSAGetLastError();

            XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::XboxNameExistsOnNet():Send Failed with Error - '%d'!!", err );

            /* Send failed, need to sleep */
			Sleep(dwRetry);
		}
	}

	closesocket(s);
	
    if( cRetries < 0 )
    {
        XDBGTRC( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::XboxNameExistsOnNet():'%s' not found after %d tries!!", nm.szName, 3 );
        
        return FALSE;
    }

    /* We have our answer */
	return TRUE;
}


//
// Factory Settings Accessors
//

ULONG CXSettings::GetFactoryChecksum()
{
    return m_pFactorySettings->Checksum;
}

void CXSettings::GetFactorySerialNumber( OUT UCHAR* pucBuffer, IN ULONG cbBufferSize )
{
    if( NULL == pucBuffer )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::GetFactorySerialNumber():Invalid parameter passed in!!" );

        return;
    }

    ASSERT( cbBufferSize >= SETTINGS_FACTORY_SERIAL_NUM_SIZE );

    memcpy( pucBuffer, m_pFactorySettings->SerialNumber, SETTINGS_FACTORY_SERIAL_NUM_SIZE );
}

void CXSettings::GetFactoryEthernetAddr( OUT UCHAR* pucBuffer, IN ULONG cbBufferSize )
{
    if( NULL == pucBuffer )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::GetFactoryEthernetAddr():Invalid parameter passed in!!" );

        return;
    }

    ASSERT( cbBufferSize >= SETTINGS_FACTORY_ETHERNET_SIZE );

    memcpy( pucBuffer, m_pFactorySettings->EthernetAddr, SETTINGS_FACTORY_ETHERNET_SIZE );
}

void CXSettings::GetFactoryReserved1( OUT UCHAR* pucBuffer, IN ULONG cbBufferSize )
{
    if( NULL == pucBuffer )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::GetFactoryReserved1():Invalid parameter passed in!!" );

        return;
    }

    ASSERT( cbBufferSize >= SETTINGS_FACTORY_RESERVED1_SIZE );

    memcpy( pucBuffer, m_pFactorySettings->Reserved1, SETTINGS_FACTORY_RESERVED1_SIZE );
}

void CXSettings::GetFactoryOnlineKey( OUT UCHAR* pucBuffer, IN ULONG cbBufferSize )
{
    if( NULL == pucBuffer )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::GetFactoryOnlineKey():Invalid parameter passed in!!" );

        return;
    }

    ASSERT( cbBufferSize >= SETTINGS_FACTORY_ONLINEKEY_SIZE );

    memcpy( pucBuffer, m_pFactorySettings->OnlineKey, SETTINGS_FACTORY_ONLINEKEY_SIZE );
}

ULONG CXSettings::GetFactoryAVRegion()
{
    return m_pFactorySettings->AVRegion;
}

ULONG CXSettings::GetFactoryReserved2()
{
    return m_pFactorySettings->Reserved2;
}


//
// User Settings Accessors
//

ULONG CXSettings::GetUserChecksum()
{
    return m_pUserSettings->Checksum;
}

ULONG CXSettings::GetUserTimeZoneBias()
{
    return m_pUserSettings->TimeZoneBias;
}

void CXSettings::GetUserTimeZoneStdName( OUT WCHAR* pwszBuffer, IN ULONG cbBufferSize )
{
    if( NULL == pwszBuffer )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::GetUserTimeZoneStdName():Invalid parameter passed in!!" );

        return;
    }

    ASSERT( cbBufferSize >= ( (XC_TZNAMELEN+1) * sizeof( WCHAR ) ) );
    XboxTimeZoneNameToWstr(m_pUserSettings->TimeZoneStdName, pwszBuffer);
}

void CXSettings::GetUserTimeZoneDltName( OUT WCHAR* pwszBuffer, IN ULONG cbBufferSize )
{
    if( NULL == pwszBuffer )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::GetUserTimeZoneDltName():Invalid parameter passed in!!" );

        return;
    }

    ASSERT( cbBufferSize >= ( (XC_TZNAMELEN+1) * sizeof( WCHAR ) ) );
    XboxTimeZoneNameToWstr(m_pUserSettings->TimeZoneDltName, pwszBuffer);
}

void CXSettings::GetUserTimeZoneStdDate( OUT XBOX_TIMEZONE_DATE* pTZStdDateBuffer, IN ULONG cbBufferSize )
{
    if( NULL == pTZStdDateBuffer )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::GetUserTimeZoneStdDate():Invalid parameter passed in!!" );

        return;
    }

    ASSERT( cbBufferSize >= SETTINGS_USER_TZSTDDATE_SIZE );

    memcpy( pTZStdDateBuffer, &m_pUserSettings->TimeZoneStdDate, SETTINGS_USER_TZSTDDATE_SIZE );
}

void CXSettings::GetUserTimeZoneDltDate( OUT XBOX_TIMEZONE_DATE* pTZDltDateBuffer, IN ULONG cbBufferSize )
{
    if( NULL == pTZDltDateBuffer )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::GetUserTimeZoneDltDate():Invalid parameter passed in!!" );

        return;
    }

    ASSERT( cbBufferSize >= SETTINGS_USER_TZDLTDATE_SIZE );

    memcpy( pTZDltDateBuffer, &m_pUserSettings->TimeZoneDltDate, SETTINGS_USER_TZDLTDATE_SIZE );
}

void CXSettings::GetUserReserved( OUT ULONG* pulBuffer, IN ULONG cbBufferSize )
{
    if( NULL == pulBuffer )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::GetUserReserved():Invalid parameter passed in!!" );

        return;
    }

    ASSERT( cbBufferSize >= ( SETTINGS_USER_RESERVED_SIZE * sizeof( ULONG ) ) );

    memcpy( pulBuffer, m_pUserSettings->Reserved2, SETTINGS_USER_RESERVED_SIZE * sizeof( ULONG ) );
}

ULONG CXSettings::GetUserTimeZoneStdBias()
{
    return m_pUserSettings->TimeZoneStdBias;
}

ULONG CXSettings::GetUserTimeZoneDltBias()
{
    return m_pUserSettings->TimeZoneDltBias;
}

ULONG CXSettings::GetUserLanguage()
{
    return m_pUserSettings->Language;
}

ULONG CXSettings::GetUserVideoFlags()
{
    return m_pUserSettings->VideoFlags;
}

ULONG CXSettings::GetUserAudioFlags()
{
    return m_pUserSettings->AudioFlags;
}

ULONG CXSettings::GetUserParentalControlGames()
{
    return m_pUserSettings->ParentalControlGames;
}

ULONG CXSettings::GetUserParentalControlPassword()
{
    return m_pUserSettings->ParentalControlPassword;
}

ULONG CXSettings::GetUserParentalControlMovies()
{
    return m_pUserSettings->ParentalControlMovies;
}

ULONG CXSettings::GetUserOnlineIpAddress()
{
    return m_pUserSettings->OnlineIpAddress;
}

ULONG CXSettings::GetUserOnlineDnsAddress()
{
    return m_pUserSettings->OnlineDnsAddress;
}

ULONG CXSettings::GetUserOnlineDefaultGatewayAddress()
{
    return m_pUserSettings->OnlineDefaultGatewayAddress;
}

ULONG CXSettings::GetUserOnlineSubnetMask()
{
    return m_pUserSettings->OnlineSubnetMask;
}

ULONG CXSettings::GetUserMiscFlags()
{
    return m_pUserSettings->MiscFlags;
}

ULONG CXSettings::GetUserDvdRegion()
{
    return m_pUserSettings->DvdRegion;
}


//
// Encrypted Settings Accessors
//

void CXSettings::GetEncChecksum( OUT UCHAR* pucBuffer, IN ULONG cbBufferSize )
{
    if( NULL == pucBuffer )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::GetEncChecksum():Invalid parameter passed in!!" );

        return;
    }

    ASSERT( cbBufferSize >= SETTINGS_ENC_CHECKSUM_SIZE );

    memcpy( pucBuffer, m_pEncSettings->Checksum, SETTINGS_ENC_CHECKSUM_SIZE );
}

void CXSettings::GetEncConfounder( OUT UCHAR* pucBuffer, IN ULONG cbBufferSize )
{
    if( NULL == pucBuffer )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::GetEncConfounder():Invalid parameter passed in!!" );

        return;
    }

    ASSERT( cbBufferSize >= SETTINGS_ENC_CONFOUNDER_SIZE );

    memcpy( pucBuffer, m_pEncSettings->Confounder, SETTINGS_ENC_CONFOUNDER_SIZE );
}

void CXSettings::GetEncHDKey( OUT UCHAR* pucBuffer, IN ULONG cbBufferSize )
{
    if( NULL == pucBuffer )
    {
        XDBGWRN( XSETTINGS_APP_TITLE_NAME_A, "CXSettings::GetEncHDKey():Invalid parameter passed in!!" );

        return;
    }

    ASSERT( cbBufferSize >= SETTINGS_ENC_HDKEY_SIZE );

    memcpy( pucBuffer, m_pEncSettings->HDKey, SETTINGS_ENC_HDKEY_SIZE );
}

ULONG CXSettings::GetEncGameRegion()
{
    return m_pEncSettings->GameRegion;
}


// Get a checksum for ALL of the settings
DWORD CXSettings::GetNewGlobalChecksum()
{
    return Crc32Checksum( (VOID*)&m_AllSettings, sizeof( m_AllSettings ) );
}


// Get a checksum for the Factory settings
DWORD CXSettings::GetNewFactoryChecksum()
{
    return Crc32Checksum( (VOID*)m_pFactorySettings, sizeof( XBOX_FACTORY_SETTINGS ) );
}


// Get a checksum for the User settings
DWORD CXSettings::GetNewUserChecksum()
{
    return Crc32Checksum( (VOID*)m_pUserSettings, sizeof( XBOX_USER_SETTINGS ) );
}


// Get a checksum for the Encrypted settings
DWORD CXSettings::GetNewEncryptedChecksum()
{
    return Crc32Checksum( (VOID*)m_pEncSettings, sizeof( XBOX_ENCRYPTED_SETTINGS ) );
}



//
// TODO: Move these to a library
//

//
// 32 bit ANSI X3.66 CRC checksum table - polynomial 0xedb88320
//
static const DWORD Crc32Table[] = {
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

DWORD Crc32Checksum(const VOID* buf, DWORD bufsize)
{
    DWORD checksum = 0xffffffff;
    const BYTE* p = (const BYTE*) buf;

    while (bufsize--)
        checksum = Crc32Table[(checksum ^ *p++) & 0xff] ^ (checksum >> 8);

    return ~checksum;
}

/*
// Set the password of the Hard Drive
BOOL HDSetPassword( BYTE* password, DWORD dwLen )
{
    NTSTATUS status;
    HANDLE h;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    OBJECT_STRING name;
    ULONG AtaPassThroughSize;
    ATA_PASS_THROUGH AtaPassThrough;
    IDE_SECURITY_DATA SecurityData;
    BOOL fReturn;
    DWORD cbBytes;

    RtlInitObjectString(&name, "\\Device\\Harddisk0\\Partition0");
    InitializeObjectAttributes(&obja, &name, 0, NULL, 0);

    status = NtOpenFile(&h, GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, &obja, &iosb,
        FILE_SHARE_WRITE | FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(status)) {

        RtlZeroMemory(&AtaPassThrough, sizeof(ATA_PASS_THROUGH));
        RtlZeroMemory(&SecurityData, sizeof(IDE_SECURITY_DATA));

        AtaPassThrough.IdeReg.bHostSendsData = TRUE;
        AtaPassThrough.IdeReg.bCommandReg = IDE_COMMAND_SECURITY_SET_PASSWORD;
        AtaPassThrough.DataBufferSize = sizeof(IDE_SECURITY_DATA);
        AtaPassThrough.DataBuffer = &SecurityData;
        SecurityData.Maximum = TRUE;
        SecurityData.Master = FALSE;

        RtlCopyMemory(SecurityData.Password, password, dwLen);

        fReturn = DeviceIoControl(h, IOCTL_IDE_PASS_THROUGH,
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &cbBytes, NULL);

        if (!fReturn) {
            XDBGTRC("HDSetPassword", "API error!");
            return FALSE;
        } else if (AtaPassThrough.IdeReg.bCommandReg & 1) {
            XDBGTRC("HDSetPassword", "IDE error!");
            return FALSE;
        }

        NtClose(h);
    }

    return TRUE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashconfig\maformatcommand.h ===
/*****************************************************
*** maformatcommand.h
***
*** H file for our XDash CFG Memory Area Format
*** command option.
*** This option will allow the user to format (clean)
*** a Memory Area of all of it's data when a user
*** selects "A"
*** 
*** by James N. Helm
*** November 3rd, 2000
*** 
*****************************************************/

#ifndef _MAFORMATCOMMAND_H_
#define _MAFORMATCOMMAND_H_

#include "xdcitem.h"
#include "xboxvideo.h"
#include "usbmanager.h"

#define NUM_MEMORY_AREAS    9

enum MEMAREAS
{
    XDISK,
    MU1,
    MU2,
    MU3,
    MU4,
    MU5,
    MU6,
    MU7,
    MU8
};

// Memory Areas
static const WCHAR* g_apszMemoryAreas[NUM_MEMORY_AREAS] = {
    L"XDisk",
    L"Memory Unit 1",
    L"Memory Unit 2",
    L"Memory Unit 3",
    L"Memory Unit 4",
    L"Memory Unit 5",
    L"Memory Unit 6",
    L"Memory Unit 7",
    L"Memory Unit 8"
};

class CMAFormatCommand : public CXDCItem
{
public:
    CMAFormatCommand();
    CMAFormatCommand( CXDCItem* pParent, WCHAR* pwszTitle, WCHAR* pwszDescription );
    ~CMAFormatCommand();

    void Action( CXBoxVideo* Screen );
    void HandleInput( enum BUTTONS buttonPressed, bool bFirstPress );

    HRESULT SetSelectedItem( unsigned int itemNumber );                 // Set the currently selected item
    WCHAR* GetItemDescription( unsigned int itemIndex ) const;          // Get the description of an item
    unsigned int GetNumItems() const { return m_uicNumItems; };         // Return the number of menu items on our current screen
    unsigned int GetSelectedItem() const { return m_uiSelectedItem; };  // Get the indext of the currently selected item on the screen


private:
    WCHAR m_Items[NUM_MEMORY_AREAS][40];        // Descriptions of each of the Memory Areas
    unsigned int m_uicNumItems;                 // Num of items that are on the current screen
    int m_uiSelectedItem;                       // The currently selected item on the screen
};

#endif // _MAFORMATCOMMAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashconfig\linkedlist.h ===
/*****************************************************
*** linkedlist.h
***
*** Header file for our linked list class.  This class
*** will allow the user to create a linked list using
*** any type of item.
***
*** by James N. Helm
*** October 31st, 2000
*** 
*****************************************************/

#ifndef _LINKEDLIST_H_
#define _LINKEDLIST_H_

#define BREAK_INTO_DEBUGGER _asm { int 3 }

template <class T> class CLinkedList
{
public:
    // Constructors and Destructors
    CLinkedList( void );
    ~CLinkedList( void );

    // Public Properties

    // Public Methods
    HRESULT AddNode( const T& item );                               // Add a node to our linked list
    HRESULT DelNode( unsigned int uiIndex );                        // Delete a node from our list by using an index
    HRESULT EmptyList( void );                                      // Empty all of the items out of our list
    unsigned int GetNumItems( void ) const;                         // Get the number of items in our list
    T& GetNode( unsigned int uiIndex ) const;                       // Get a data item from our list by using an index
    T& operator[]( unsigned int uiIndex ) const;                    // Get a data item from our list by using an index

private:
    // Node of our linked list
    struct _LISTNODE
    {
        T dataItem;
        struct _LISTNODE* pNext;
    };

    // Private Properties
    unsigned int m_uicNumItems;         // Number of items in the list
    struct _LISTNODE* m_pHead;

    // Private Methods

};

// Default Constructor.  Properties are initialized here
template< class T > CLinkedList< T >::CLinkedList( void )
{
    m_uicNumItems = 0;
    m_pHead = NULL;
}

// Destructor.  Memory cleanup is performed here
template< class T > CLinkedList< T >::~CLinkedList( void )
{
    // Empty all items from our list
    EmptyList();
}

// Add a node to our list
template< class T > HRESULT CLinkedList< T >::AddNode( const T& item )
{
    // Item to be added to our list
    struct _LISTNODE* pNewItem = new struct _LISTNODE;

    if( !pNewItem )
    {
        DebugPrint( "*** ERROR: CLinkedList():AddNode(): Could not allocate memory!!\n" );
        return E_OUTOFMEMORY;
    }

    pNewItem->dataItem = item;
    pNewItem->pNext = NULL;

    // Check to see if we have a head node.  If not, add the item there
    if( !m_pHead )
    {
        m_pHead = pNewItem;
    }
    else // Add the node to the end of our list
    {
        struct _LISTNODE* pSearchNode = m_pHead;
        
        // Traverse to the end of our list
        while( pSearchNode->pNext )
        {
            pSearchNode = pSearchNode->pNext;
        }

        pSearchNode->pNext = pNewItem;
    }

    // Increment the number of items in our list
    ++m_uicNumItems;

    return S_OK;
}

// Delete a node from our list
template< class T > HRESULT CLinkedList< T >::DelNode( unsigned int uiIndex )
{
    // Make sure our index is valid.  If not, break in to the debugger
    if( ( uiIndex < 0 ) || ( uiIndex >= GetNumItems() ) )
    {
        return E_INVALIDARG;
    };

    struct _LISTNODE* pPrevNode = m_pHead;
    struct _LISTNODE* pSearchNode = m_pHead;

    // If we have a valid index, delete the referenced node
    for( unsigned int x = 0; x < uiIndex; ++x )
    {
        pPrevNode = pSearchNode;
        pSearchNode = pSearchNode->pNext;
    }

    // Deal with the head of the list
    if( pSearchNode == m_pHead )
    {
        m_pHead = m_pHead->pNext;
    }
    else // Not the head node
    {
        // Set our list to skip over the node we'll delete
        pPrevNode->pNext = pSearchNode->pNext;
    }

    // Delete the node
    delete pSearchNode;
    pSearchNode = NULL;

    // Decrement our counter
    --m_uicNumItems;

    return S_OK;
}

// Empty all the items from our list
template< class T > HRESULT CLinkedList< T >::EmptyList( void )
{
    // If there is at least one node in our list, let's clean it up
    if( m_pHead )
    {
        struct _LISTNODE* pSearchNode = m_pHead;
        while( pSearchNode->pNext )
        {
            m_pHead = pSearchNode->pNext;
            delete pSearchNode;
            pSearchNode = m_pHead;
        }

        if( m_pHead )
        {
            delete m_pHead;
            m_pHead = NULL;
            pSearchNode = NULL;
        }
    }

    // Set our item count to zero
    m_uicNumItems = 0;

    return S_OK;
}

// Get a data item from our list by using an index value
template< class T > T& CLinkedList< T >::GetNode( unsigned int uiIndex ) const
{
    // Make sure our index is valid.  If not, break in to the debugger
    if( ( uiIndex < 0 ) || ( uiIndex >= GetNumItems() ) )
    {
        DebugPrint( "CLinkedList GetNode(): index '%d' out of range! MAX - '%d'\n", uiIndex, GetNumItems() );
        BREAK_INTO_DEBUGGER;
    };

    struct _LISTNODE* pSearchNode = m_pHead;

    // If we have a valid index, return a reference to the node
    for( unsigned int x = 0; x < uiIndex; ++x )
    {
        pSearchNode = pSearchNode->pNext;
    }

    return pSearchNode->dataItem;
}

// Get a data item from our list by using an index value
template< class T > T& CLinkedList< T >::operator[]( unsigned int uiIndex ) const
{
    return GetNode( uiIndex );
}

// Get a the number of items in our list
template< class T > unsigned int CLinkedList< T >::GetNumItems( void ) const
{
    return m_uicNumItems;
}

#endif // _LINKEDLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashconfig\menuscreen.cpp ===
/*****************************************************
*** menuscreen.cpp
***
*** CPP file for our XDash CFG Generic menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
*** 
*** by James N. Helm
*** November 2nd, 2000
*** 
*****************************************************/

#include "stdafx.h"
#include "menuscreen.h"

extern CXDCItem* g_pCurrentScreen;  // Pointer to the current menu object

// Constructor
CMenuScreen::CMenuScreen()
: CXDCItem(),
m_uicNumItems( 0 ),
m_uiSelectedItem( -1 )
{
}

// Constructor
CMenuScreen::CMenuScreen( CXDCItem* pParent, WCHAR* pwszTitle, WCHAR* pwszDescription )
: CXDCItem( pParent, pwszTitle, pwszDescription ),
m_uicNumItems( 0 ),
m_uiSelectedItem( -1 )
{
}

// Destructor
CMenuScreen::~CMenuScreen()
{
}

// Draws a menu on to the screen
void CMenuScreen::Action( CXBoxVideo* pScreen )
{
    unsigned int nStringWidth = 0;
    float fFontHeight = 0.0;

    pScreen->GetFontSize( 0, &fFontHeight, 0, 0 );

    // Display the Title
    pScreen->DrawText( (float)SCREEN_X_CENTER - ( pScreen->GetStringPixelWidth( GetTitle() ) / 2 ), MENU_TITLE_Y, MENU_TITLE_FG_COLOR, MENU_TITLE_BG_COLOR, GetTitle() );

    // If we have any items on the screen, let's draw them
    if( GetNumItems() > 0 )
    {
        // Draw a box behind the currently highlighted choice
        float fX1, fY1, fX2, fY2;
        fX1 = SCREEN_X_CENTER - ( pScreen->GetStringPixelWidth( GetItemTitle( GetSelectedItem() ) ) / 2.0f ) - MENU_HIGHLIGHT_BORDER;
        fY1 = MENU_OPTION1_Y + ( ( fFontHeight + MENU_VERT_SPACING ) * GetSelectedItem() ) - MENU_HIGHLIGHT_BORDER;
        fX2 = SCREEN_X_CENTER + ( pScreen->GetStringPixelWidth( GetItemTitle( GetSelectedItem() ) ) / 2.0f ) + MENU_HIGHLIGHT_BORDER;
        fY2 = MENU_OPTION1_Y + ( fFontHeight * ( GetSelectedItem() + 1 ) ) + ( MENU_VERT_SPACING * GetSelectedItem() ) + MENU_HIGHLIGHT_BORDER;

        pScreen->DrawOutline( fX1, fY1, fX2, fY2, MENU_HIGHLIGHT_BORDER_WIDTH, HIGHLIGHT_BOX_COLOR );

        // Draw the items on the menu
        for( unsigned int x = 0; x < GetNumItems(); ++x )
        {
            pScreen->DrawText( SCREEN_X_CENTER - ( pScreen->GetStringPixelWidth( GetItemTitle( x ) ) / 2.0f ), MENU_OPTION1_Y + ( ( fFontHeight + MENU_VERT_SPACING ) * x ), MENU_ITEM_FG_COLOR, MENU_ITEM_BG_COLOR, GetItemTitle( x ) );
        }
    }
}

// Add a pointer to an item that lives on this screen
void CMenuScreen::AddItem( CXDCItem* pScreen )
{
    // If we were not passed a valid pointer, notify the user and bail
    if( !pScreen )
    {
        DebugPrint( "CMenuScreen::AddItem(): pScreen was not a valid pointer!\n" );
        return;
    }

    // Add the pointer to our list
    m_Items.AddNode( pScreen );

    // Increment the number of items on our screen
    ++m_uicNumItems;

    // If this is our first item, let's set our selected item to it (item 0)
    if( 1 == m_uicNumItems )
    {
        SetSelectedItem( 0 );
    };
}

// Get the description of a sub-item on our screen
WCHAR* CMenuScreen::GetItemDescription( unsigned int itemIndex ) const
{
    if( ( itemIndex < 0 ) || ( itemIndex >= GetNumItems() ) )
    {
        DebugPrint( "CMenuScreen::GetItemDescription(): index out of range - '%d', MAX - '%d'\n", itemIndex, GetNumItems() - 1 );
        return NULL;
    }

    return m_Items[itemIndex]->GetDescription();
}

// Get the title of a sub-item on our screen
WCHAR* CMenuScreen::GetItemTitle( unsigned int itemIndex ) const
{
    if( ( itemIndex < 0 ) || ( itemIndex >= GetNumItems() ) )
    {
        DebugPrint( "CMenuScreen::GetItemTitle(): index out of range - '%d', MAX - '%d'\n", itemIndex, GetNumItems() - 1 );
        return NULL;
    }

    return m_Items[itemIndex]->GetTitle();
}

// Handles input for the current menu
void CMenuScreen::HandleInput( enum BUTTONS buttonPressed, bool bFirstPress )
{
    // DebugPrint( "CMenuScreen::HandleInput()\n" );

    // If it's a repeat button press, bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                g_pCurrentScreen = m_Items[GetSelectedItem()];
            }
            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                SetSelectedItem( 0 );
                g_pCurrentScreen = GetParent();
            }
            break;
        }
    case BUTTON_C:
        {
            break;
        }
    case BUTTON_D:
        {
            break;
        }
    case BUTTON_E:
        {
            break;
        }
    case BUTTON_F:
        {
            break;
        }
    case BUTTON_7:
        {
            break;
        }
    case BUTTON_8:
        {
            break;
        }
    case BUTTON_9:
        {
            break;
        }
    case BUTTON_10:
        {
            break;
        }
    case DPAD_TOP:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() <= 0 )
                {
                    SetSelectedItem( GetNumItems() - 1 );
                }
                else
                {
                    SetSelectedItem( GetSelectedItem() - 1 );
                }
            }
            break;
        }
    case DPAD_BOTTOM:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() >= GetNumItems() - 1 )
                {
                    SetSelectedItem( 0 );
                }
                else
                {
                    SetSelectedItem( GetSelectedItem() + 1 );
                }
            }
            break;
        }
    case DPAD_LEFT:
        {
            break;
        }
    case DPAD_RIGHT:
        {
            break;
        }
    }
}

// Sets the currently selected item on our screen
HRESULT CMenuScreen::SetSelectedItem( unsigned int itemNumber )
{
    if( ( itemNumber < 0 ) || ( itemNumber >= GetNumItems() ) )
    {
        DebugPrint( "CMenuScreen::SetSelectedItem(): Tried to select item out of range! - '%d', MAX - '%d'\n", itemNumber, GetNumItems() - 1 );
        return E_INVALIDARG;
    }

    m_uiSelectedItem = itemNumber;
    SetFooterText( GetItemDescription( m_uiSelectedItem ) );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\tools\xsettings\xsetpch.h ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    xsetpch.h

Abstract:

    precompiled header for usb manager library.

--*/

#ifndef _XSETPCH_H_
#define _XSETPCH_H_

#include <xapip.h>
#include <xboxp.h>
#include <xtl.h>
#include <dm.h>
#include <xdbg.h>
#include <xbdm.h>
#include <stdio.h>

#endif // _XSETPCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashconfig\rebootcommand.h ===
/*****************************************************
*** rebootcommand.h
***
*** H file for our XDash CFG Reboot XBox option
*** This option will reboot the XBox when the user
*** selects "A"
*** 
*** by James N. Helm
*** November 3rd, 2000
*** 
*****************************************************/

#ifndef _REBOOTCOMMAND_H_
#define _REBOOTCOMMAND_H_

#include "xdcitem.h"
#include "xboxvideo.h"
#include "usbmanager.h"

class CRebootCommand : public CXDCItem
{
public:
    CRebootCommand();
    CRebootCommand( CXDCItem* pParent, WCHAR* pwszTitle, WCHAR* pwszDescription );
    ~CRebootCommand();

    void Action( CXBoxVideo* Screen );
    void HandleInput( enum BUTTONS buttonPressed, bool bFirstPress );

private:
};

#endif // _REBOOTCOMMAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashconfig\menuscreen.h ===
/*****************************************************
*** menuscreen.h
***
*** Header file for our XDash CFG Generic menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
*** 
*** by James N. Helm
*** November 2nd, 2000
*** 
*****************************************************/

#ifndef _MENUSCREEN_H_
#define _MENUSCREEN_H_

#include "xdcitem.h"
#include "xboxvideo.h"
#include "usbmanager.h"

class CMenuScreen : public CXDCItem
{
public:
    // Constructors and Destructors
    CMenuScreen();
    CMenuScreen( CXDCItem* pParent, WCHAR* pwszTitle, WCHAR* pwszDescription );
    ~CMenuScreen();

    // Must be overridden for this to be a Item on our XDashConfig program
    virtual void Action( CXBoxVideo* Screen );
    virtual void HandleInput( enum BUTTONS buttonPressed, bool bFirstPress );

    // Public Methods
    virtual void AddItem( CXDCItem* pScreen );                                  // Add an item to the current screen
    virtual WCHAR* GetItemDescription( unsigned int itemIndex ) const;          // Get the description of an item on our screen
    virtual WCHAR* GetItemTitle( unsigned int itemIndex ) const;                // Get the title of an item on our screen
    virtual unsigned int GetNumItems() const { return m_uicNumItems; };         // Return the number of menu items on our current screen
    virtual unsigned int GetSelectedItem() const { return m_uiSelectedItem; };  // Get the indext of the currently selected item on the screen
    virtual HRESULT SetSelectedItem( unsigned int itemNumber );                 // Set the currently selected item on the screen

private:
    CLinkedList< CXDCItem* > m_Items;   // Items that live underneath this menu
    unsigned int m_uicNumItems;         // Num of items that are on the current screen
    int m_uiSelectedItem;               // The currently selected item on the screen


};

#endif // _MENUSCREEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashconfig\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

//#include <ntos.h>
#include <xtl.h>
#include <xfont.h>
#include <stdio.h>

#include "videoconstants.h"
#include "xboxvideo.h"
#include "usbmanager.h"
#include "linkedlist.h"
#include "xdcitem.h"

// Menus and Commands
#include "menuscreen.h"
#include "rebootcommand.h"
#include "clockmenuscreen.h"
#include "maformatcommand.h"

#define TITLE_NAME      L"XDash Config"

#define BREAK_INTO_DEBUGGER     _asm { int 3 }
#define ARRAYSIZE(a)            (sizeof(a) / sizeof(a[0]))
#define DATA_DRIVE              L"t:"
#define DATA_PATH               DATA_DRIVE L"\\media"

extern "C" {ULONG DebugPrint(PCHAR Format, ...);}

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashconfig\rebootcommand.cpp ===
/*****************************************************
*** rebootcommand.cpp
***
*** CPP file for our XDash CFG Reboot XBox option
*** This option will reboot the XBox when the user
*** selects "A"
*** 
*** by James N. Helm
*** November 3rd, 2000
*** 
*****************************************************/

#include "rebootcommand.h"
#include "videoconstants.h"

extern CXDCItem* g_pCurrentScreen;  // Pointer to the current menu object

// Constructor
CRebootCommand::CRebootCommand()
: CXDCItem()
{
}

// Constructor
CRebootCommand::CRebootCommand( CXDCItem* pParent, WCHAR* pwszTitle, WCHAR* pwszDescription )
: CXDCItem( pParent, pwszTitle, pwszDescription )
{
}

// Destructor
CRebootCommand::~CRebootCommand()
{
}


// Draws a menu on to the screen
void CRebootCommand::Action( CXBoxVideo* pScreen )
{
    // Reboot the XBox
    XLaunchNewImage( NULL, NULL );
}

// Handles input for the current menu
void CRebootCommand::HandleInput( enum BUTTONS buttonPressed, bool bFirstPress )
{
    // No input needs to be handled, as the XBox will reboot.
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashconfig\xboxvideo.cpp ===
/*****************************************************
*** xboxvideo.cpp
***
*** CPP file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#include "xboxvideo.h"

// Constructor
CXBoxVideo::CXBoxVideo( void )
{
    DebugPrint( "CXBoxVideo::CXBoxVideo()\n" );

    m_Device = NULL;
    m_BackBuffer = NULL;
    m_VertexBuffer = NULL;

    // Font properties
    m_Font = NULL;
    m_FontWidth = DEFAULT_FONT_WIDTH;
    m_FontHeight = DEFAULT_FONT_HEIGHT;
    m_FontColor = DEFAULT_FONT_FG_COLOR;
    m_FontBgColor = DEFAULT_FONT_BG_COLOR;

    m_ScreenWidth = DEFAULT_SCREEN_WIDTH;       // Default the screen width to 640
    m_ScreenHeight = DEFAULT_SCREEN_HEIGHT;     // Default the screen height to 480
}

// Destructor
CXBoxVideo::~CXBoxVideo( void )
{
    DebugPrint( "CXBoxVideo::~CXBoxVideo()\n" );
}

// Clear the screen
void CXBoxVideo::ClearScreen( void )
{
    // DebugPrint( "CXBoxVideo::Clear()\n" );

	DrawClearRect( 0.0f, 0.0f, m_ScreenWidth - 1.0f, m_ScreenHeight - 1.0f, DEFAULT_SCREEN_BG_CLEAR );
}

// Draw the inputed bit array to the screen
//
// Parameters:
//      fx - the upper left x coordinate on screen
//      fy - the upper left y coordinate on screen
//      ulWidth - the width of the bitmap
//      ulHeight - the height of the bitmap
//      pData - a pointer to the array of pixel values
void CXBoxVideo::DrawBitBlt( float fx, float fy, ULONG ulWidth, ULONG ulHeight, const DWORD* pData )
{
    // DebugPrint( "CXBoxVideo::DrawBitBlt()\n" );

    // Check to make sure we received a valid pointer
    if( !pData )
    {
        DebugPrint( "CXBoxVideo::DrawBitBlt(): pData not a valid pointer!\n" );
        return;
    }

    // Draw the bitmap on the screen, pixel by pixel
	for ( ULONG y = 0; y < ulHeight; y++ )
	{
		for ( ULONG x = 0; x < ulWidth; x++ )
		{
			if ( 0 != pData[y * ulWidth + x] )
			{
				DrawLine( fx + x, fy + y, fx + x, fy + y, 1, pData[y * ulWidth + x] );
			}
		}
	}
}

// Draw a box on the screen
void CXBoxVideo::DrawBox( float x1, float y1, float x2, float y2, DWORD color )
{
    // DebugPrint( "CXBoxVideo::DrawBox()\n" );

	MYVERTEX* pb;
	float maxx, minx;
	float maxy, miny;

	CHECK( m_Device->BeginScene() );
	CHECK( m_VertexBuffer->Lock( 0, 128, (BYTE**)&pb, 0 ) );
	
	if( IsBadWritePtr( pb, 128 ) )
	{
		DebugPrint("CXBoxVideo::DrawBox(): Lock returned '%p', which is BAD!\n", pb);
		return;
	}

	if( x1 < x2 )
    {
		minx = x1;
		maxx = x2;
	}
    else
    {
		minx = x2;
		maxx = x1;
	}

	if( x1 < x2 )
    {
		miny = y1;
		maxy = y2;
	}
    else
    {
		miny = y2;
		maxy = y1;
	}

	if( x1 == x2 )
    {
		maxx++;
	}

	pb[0].v.x = minx; pb[0].v.y = miny; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
	pb[1].v.x = maxx; pb[1].v.y = miny; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
	pb[2].v.x = maxx; pb[2].v.y = maxy; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
	pb[3].v.x = minx; pb[3].v.y = maxy; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = color;

	m_VertexBuffer->Unlock();

	m_Device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
	m_Device->EndScene();
}

// Draw a clear rectangle to the screen
void CXBoxVideo::DrawClearRect( float x1, float y1, float x2, float y2, DWORD color ) 
{
    // DebugPrint( "CXBoxVideo::DrawClearRect()\n" );

	D3DRECT rect;

	if ( m_Device )
	{
		if( x1 < x2 )
        {
			rect.x1 = (long)x1; 
			rect.x2 = (long)x2 + 1;
		}
        else
        {
			rect.x1 = (long)x2; 
			rect.x2 = (long)x1 + 1;
		}

		if( y1 < y2 )
        {
			rect.y1 = (long)y1;
			rect.y2 = (long)y2 + 1;
		}
        else
        {
			rect.y1 = (long)y2;
			rect.y2 = (long)y1 + 1;
		}

		m_Device->Clear( 1, &rect, D3DCLEAR_TARGET, color, 0, 0 );
	}
}

// Draw a line to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      color          --- the RGBA color to draw the box with
HRESULT CXBoxVideo::DrawLine( float x1, float y1, float x2, float y2, unsigned int uiLineWidth, DWORD color )
{
    // DebugPrint( "CXBoxVideo::DrawLine()\n" );

    // Hack because below D3D code did not work
	// DrawClearRect( x1, y1, x2, y2, color );

    HRESULT hr;     // Return code for D3D functions that are called, and for the function
	MYVERTEX* pb;   // Vertex information

    // Enable drawing of the last pixel in the target
    hr = m_Device->SetRenderState( D3DRS_LASTPIXEL, FALSE );
	if( D3D_OK != hr )
    {
        DebugPrint( "CXBoxVideo::DrawLine(): Problem calling m_Device->SetRenderState( FALSE )! - '%d'\n", hr );
    }

    if( SUCCEEDED( hr ) )
    {
        // Before any rendering can be done, this must be called
        hr = m_Device->BeginScene();
	    if( D3D_OK != hr )
        {
            DebugPrint( "CXBoxVideo::DrawLine(): Problem calling m_Device->BeginScene()! - '%d'\n", hr );
        }
    }

    if( SUCCEEDED( hr ) )
    {
        // Locks a range of vertex data and obtains a pointer to the vertex buffer memory.
	    hr = m_VertexBuffer->Lock( 0, 128, (BYTE**)&pb, 0 );
	    if( D3D_OK != hr )
        {
            DebugPrint( "CXBoxVideo::DrawLine(): Problem calling m_VertexBuffer->Lock()! - '%d'\n", hr );
        }
    }

    if( SUCCEEDED( hr ) )
    {
        // Verifies that the calling process has write access to the specified range of memory
	    if( IsBadWritePtr( pb, 128 ) )
	    {
		    DebugPrint("CXBoxVideo::DrawLine():m_VertexBuffer->Lock() returned '%p', which is BAD!\n", pb);
            hr = E_FAIL;
	    }
    }

    if( SUCCEEDED( hr ) )
    {
        // Setup the vertext values with our passed in numbers
	    pb[0].v.x = x1  ; pb[0].v.y = y1  ; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
	    pb[1].v.x = x2  ; pb[1].v.y = y2  ; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;

        /*
        pb[1].v.x = x1  ; pb[1].v.y = y1  ; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
	    pb[2].v.x = x2  ; pb[2].v.y = y2  ; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
        */

        // Unlock the vertext data
	    hr = m_VertexBuffer->Unlock();
	    if( D3D_OK != hr )
        {
            DebugPrint( "CXBoxVideo::DrawLine(): Problem calling m_VertexBuffer->Unlock()! - '%d'\n", hr );
            return hr;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        // Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams
    	hr = m_Device->DrawPrimitive( D3DPT_LINESTRIP, 0, 1 );
	    if( D3D_OK != hr )
        {
            DebugPrint( "CXBoxVideo::DrawLine(): Problem calling m_Device->DrawPrimitive()! - '%d'\n", hr );
        }
    }

    // Once rendering is complete, this must be called
    // We should try this, even on a failure, in case BeginScene() was successful
    // We'll report it to the debugger, but will not return the fail/success code to the
    // caller
	if( D3D_OK != m_Device->EndScene() )
    {
        DebugPrint( "CXBoxVideo::DrawLine(): Problem calling m_Device->EndScene()! - '%d'\n", hr );
    }
    
    // Disable drawing of the last pixel in the target
	if( D3D_OK != m_Device->SetRenderState( D3DRS_LASTPIXEL, TRUE ) )
    {
        DebugPrint( "CXBoxVideo::DrawLine(): Problem calling m_Device->SetRenderState( TRUE )! - '%d'\n", hr );
    }

    return hr;
}

// Draw an outline to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      borderSize     --- width in pixels of the border
//      color          --- the RGBA color to draw the box with
void CXBoxVideo::DrawOutline( float x1, float y1, float x2, float y2, unsigned int uiLineWidth, DWORD color )
{
    DrawLine( x1, y1, x2, y1, uiLineWidth, color );     // Top Line
    DrawLine( x2, y1, x2, y2, uiLineWidth, color );     // Right Line
    DrawLine( x1, y2, x2, y2, uiLineWidth, color );     // Bottom Line
    DrawLine( x1, y1, x1, y2, uiLineWidth, color );     // Left Line
}


// DeInitialize our Screen by freeing our objects
void CXBoxVideo::DeInitialize( void )
{
    // DebugPrint( "CXBoxVideo::DeInitialize()\n" );

    m_BackBuffer->Release();
	m_Device->Release();
}

// Prints formatted text using the default font to the screen
// Set colors to 0 to use default color
int CXBoxVideo::DrawText( float x1, float y1, DWORD fgcolor, DWORD bgcolor, const TCHAR* format, ... )
{
    // DebugPrint( "CXBoxVideo::DrawText()\n" );

	int i;                  // Return Value
	HRESULT hr;             // Return Value for XFONT
	va_list v;              // Argument List
	TCHAR wstr[256];        // Honkin Buffer
    DWORD currentFGColor;   // Current FG Color
    DWORD currentBGColor;   // Current FG Color

    // Set our FONT colors if the user wishes to
    if( fgcolor || bgcolor )
    {
        // Get our current Font Colors
        GetFontSize( 0, 0, &currentFGColor, &currentBGColor );

        // Set the foreground color if the user wants to
        if( fgcolor )
        {
            XFONT_SetTextColor( fgcolor );
        }

        // Set the background color if the user wants to
        if( bgcolor )
        {
            XFONT_SetBkColor( bgcolor );
        }
    }

	va_start( v, format );
	i = wvsprintf( wstr, format, v );

    // Print the Text to the backbuffer
	if( m_Font )
    {
        hr = XFONT_TextOut( wstr, i, (long)x1, (long)y1 );
    }

    // If we have a valid font object, check the HRESULT
	if( m_Font )
    {
        if( hr )
        {
            DebugPrint( "CXBoxVideo::DrawText(): XFONT_TextOut HRESULT: %x\n", hr );
        }
    }

    // Set the colors back to the original if needed
    if( fgcolor || bgcolor )
    {
        // Set the foreground color back to the original if necessary
        if( fgcolor )
        {
            XFONT_SetTextColor( currentFGColor );
        }

        // Set the background color back to the original if necessary
        if( bgcolor )
        {
            XFONT_SetBkColor( currentBGColor );
        }
    }

	va_end( v );
	
    return i;
}

// Get the size of the current font
void CXBoxVideo::GetFontSize( OPTIONAL OUT float* pwidth,
                              OPTIONAL OUT float* pheight,
                              OPTIONAL OUT DWORD* pfgcolor,
                              OPTIONAL OUT DWORD* pbgcolor	)
{
    // DebugPrint( "CXBoxVideo::GetFontSize()\n" );
	
    if( pwidth )
    {
        *pwidth = m_FontWidth;
    }

	if( pheight )
    {
        *pheight = m_FontHeight;
    }

	if( pfgcolor )
    {
        *pfgcolor = m_FontColor;
    }

	if( pbgcolor )
    {
        *pbgcolor = m_FontBgColor;
    }
}

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int CXBoxVideo::GetStringPixelWidth( IN LPCWSTR string, IN int length /*=-1*/ ) 
{
    // DebugPrint( "CXBoxVideo::GetStringPixelWidth()\n" );
    if( !string )
    {
        DebugPrint( "CXBoxVideo::GetStringPixelWidth(): Invalid pointer passed in!\n" );
        return -1;
    }

	unsigned int outlen = 0;        // Return value

	XFONT_GetTextExtent( string, length, &outlen );
	
    return outlen;
}

// Initialize D3D for this screen
void CXBoxVideo::Initialize( int width = DEFAULT_SCREEN_WIDTH, int height = DEFAULT_SCREEN_HEIGHT )
{
    // DebugPrint( "CXBoxVideo::Initialize()\n" );

    HWND hwnd = NULL;
    m_ScreenWidth = width;
    m_ScreenHeight = height;

	if (m_Device == NULL)
	{
		// Create D3D 8.
		IDirect3D8 *pD3D = Direct3DCreate8( D3D_SDK_VERSION );
		
        if ( !pD3D )
        {
            DebugPrint( "CXBoxVideo::Initialize(): Failed to create pD3D!\n" );
			return;
        }

		// Set the screen mode.
		D3DPRESENT_PARAMETERS d3dpp;
		ZeroMemory( &d3dpp, sizeof( d3dpp ) );

		d3dpp.BackBufferWidth            = width;
		d3dpp.BackBufferHeight           = height;
		d3dpp.BackBufferFormat           = D3DFMT_X8R8G8B8;
		d3dpp.BackBufferCount            = 1;
		d3dpp.Windowed                   = false;    // Must be false for Xbox
		d3dpp.EnableAutoDepthStencil     = true;
        //d3dpp.AutoDepthStencilFormat     = D3DFMT_D24X8;
        d3dpp.AutoDepthStencilFormat     = D3DFMT_D24S8;
		d3dpp.SwapEffect                 = D3DSWAPEFFECT_DISCARD;
		d3dpp.FullScreen_RefreshRateInHz = 60;	//or 72?
		d3dpp.hDeviceWindow              = hwnd;   // Ignored on Xbox

		// Create the m_Device.
		if ( S_OK != pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                         D3DDEVTYPE_HAL,
                                         hwnd,                                 // Ignored on Xbox
                                         D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                         &d3dpp,
                                         &m_Device ) )
		{
            DebugPrint( "CXBoxVideo::Initialize(): Failed to CreateDevice!\n" );
			pD3D->Release();

			return;
		}

		// Now we no longer need the D3D interface so let's free it.
		pD3D->Release();
	}

	m_Device->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &m_BackBuffer );

    m_Device->SetRenderState( D3DRS_LIGHTING, FALSE );
    m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
	m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );

	m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE );

	m_Device->CreateVertexBuffer( sizeof( MYVERTEX ) * 4, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer );

	m_Device->SetStreamSource( 0, m_VertexBuffer, sizeof( MYVERTEX ) );

    // Open Courier Font
    XFONT_OpenBitmapFont( FONT_COUR_FILENAME, 4096, &m_Font );

	if( !m_Font )
    {
        DebugPrint( "CXBoxVideo::Initialize(): Failed to open font '%ws'\n", FONT_COUR_FILENAME );

        // Open Arial Font
		XFONT_OpenBitmapFont( FONT_ARIAL_FILENAME, 4096, &m_Font );

        if( !m_Font )
        {
            DebugPrint( "CXBoxVideo::Initialize(): Failed to open font '%ws'\n", FONT_ARIAL_FILENAME );
            DebugPrint( "CXBoxVideo::Initialize(): No font loaded!!\n" );
        }
	}

	if( m_Font )
    {
        XFONT_SelectFont( m_Font );
    }

	if( m_Font )
    {
        XFONT_SetTextColor( DEFAULT_FONT_FG_COLOR );
    }

	if( m_Font )
    {
        XFONT_SetBkColor( DEFAULT_FONT_BG_COLOR );
    }

	if( m_Font )
    {
        XFONT_SetDrawingSurface( m_BackBuffer );
    }
}

// Set the font dimensions
void CXBoxVideo::SetFontSize( float width, float height, DWORD color, DWORD bkcolor )
{
    // DebugPrint( "CXBoxVideo::SetFontSize()\n" );

	m_FontWidth = width;
    m_FontHeight = height; 
	m_FontColor = color;
	m_FontBgColor = bkcolor;

	if( m_Font)
    {
        XFONT_SetTextColor( m_FontColor );
        XFONT_SetBkColor( m_FontBgColor );
    }
}

// Display the current backbuffer on to the screen
void CXBoxVideo::ShowScreen()
{
    // DebugPrint( "CXBoxVideo::ShowScreen()\n" );

#ifdef _UseDxConio_
    xDisplayConsole();
#endif

	if( m_Device )
    {
		m_Device->Present( NULL, NULL, NULL, NULL );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashconfig\usbmanager.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#include "usbmanager.h"

DWORD XIDMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
};

DWORD XMUMasks[] = {
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_TOP_MASK,
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT3_BOTTOM_MASK
};


USBManager::USBManager()
{
    DWORD insertions, insertions2;
    unsigned i, j;
    unsigned port, slot;

    //Initialize core peripheral port support
    XInitDevices(0,NULL);

    pollingParameters.fAutoPoll = 1;
    pollingParameters.fInterruptOut = 0;
    pollingParameters.ReservedMBZ1 = 0;
    pollingParameters.bInputInterval = 8;  
    pollingParameters.bOutputInterval = 8;
    pollingParameters.ReservedMBZ2 = 0;

    // make sure the usb schema has not changed on us
    // ASSERT(ARRAYSIZE(XIDMasks) == XGetPortCount());
    if( ARRAYSIZE( XIDMasks ) != XGetPortCount() )
    {
        DebugPrint( "USBManager::USBManager(): XIDMasks != XGetPortCount!\n" );
        BREAK_INTO_DEBUGGER;
    }
    
    // initialize
    for(i=0; i<XGetPortCount(); i++)
    {
        for(j=0; j<SLOT_MAX; j++)
        {
            devices[i][j] = NULL;
            packetNum[i][j] = 1234;
        }
    }

    // look for game pads
    insertions = XGetDevices(XDEVICE_TYPE_GAMEPAD);
    //DebugPrint("USBMGR: XID: - %X\n", insertions);
    for(i=0; i<XGetPortCount(); i++)
    {
        port = i%XGetPortCount();
        if(insertions & XIDMasks[i])
        {
            //DebugPrint("USBMGR: Inserted XID %d\n", i);
            devices[i][0] = new DeviceDuke(port, 0, &pollingParameters); 
        }
    }

    // check for mus
    insertions = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);
    //DebugPrint("USBMGR: XMU: - %X\n", insertions);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
    {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(insertions & XMUMasks[i])
        {
            //DebugPrint("USBMGR: Inserted XMU %d (ec: %lu)\n", port, err);
            devices[i][slot] = new DeviceMU(port, slot);
        }
    }

    
    // check for hawks
    insertions = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
    insertions2 = XGetDevices(XDEVICE_TYPE_VOICE_HEADPHONE);
    if(insertions == insertions2)
    {
        //DebugPrint("USBMGR: OK!\n");
    }
    else
    {
        //DebugPrint("USBMGR: CRAP!\n");
    }
    //DebugPrint("USBMGR: XHAWK: %X %X\n", removals, insertions);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
    {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(insertions & XMUMasks[i])
        {
            //DebugPrint("USBMGR: Inserted XHAWK [%d][%d]\n", port, slot);
            devices[port][slot] = new DeviceHawk(port, slot);
        }
    }
}


USBManager::~USBManager()
{
    unsigned i, j;

    for(i=0; i<XGetPortCount(); i++)
    {
        for(j=0; j<SLOT_MAX; j++)
        {
            if(devices[i][j] != NULL)
            {
                if(XDEVICE_TYPE_GAMEPAD == devices[i][j]->type) delete (DeviceDuke*)devices[i][j];
                else if(XDEVICE_TYPE_MEMORY_UNIT == devices[i][j]->type) delete (DeviceMU*)devices[i][j];
                else if(XDEVICE_TYPE_VOICE_MICROPHONE == devices[i][j]->type) delete (DeviceHawk*)devices[i][j];
                devices[i][j] = NULL;
            }
        }
    }
}


void USBManager::CheckForHotplugs( void )
{
    DWORD addDuke, removeDuke;
    DWORD addMU, removeMU;
    DWORD addHawk, removeHawk, addHawk2, removeHawk2;
    unsigned slot, port;
    unsigned i, j;

    // check for mu removals
    XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT, &addMU, &removeMU );
    for( i = 0; i < ARRAYSIZE( XMUMasks ); i++ )
    {
        slot = i < XGetPortCount() ? 1 : 2;
        port = i % XGetPortCount();
        
        if( removeMU & XMUMasks[i] )
        {
            //DebugPrint("***USBMGR: Removed XMU [%d][%d]\n", port, slot);
            delete (DeviceMU*)devices[i][slot];
            devices[i][slot] = NULL;
        }
    }

    // check for xhawk removals
    XGetDeviceChanges( XDEVICE_TYPE_VOICE_MICROPHONE, &addHawk, &removeHawk );
    XGetDeviceChanges( XDEVICE_TYPE_VOICE_HEADPHONE, &addHawk2, &removeHawk2 );
    
    if( ( removeHawk == removeHawk ) && ( addHawk == addHawk2 ) )
    {
        //DebugPrint("USBMGR: OK!\n");
    }
    else
    {
        //DebugPrint("USBMGR: CRAP!\n");
    }

    for(i = 0; i < ARRAYSIZE( XMUMasks ); i++ )
    {
        slot = i < XGetPortCount() ? 1 : 2;
        port = i % XGetPortCount();
        
        if( removeHawk & XMUMasks[i] )
        {
            //DebugPrint("***USBMGR: Removed HAWK [%d][%d]\n", port, slot);
            delete (DeviceHawk*)devices[port][slot];
            devices[port][slot] = NULL;
        }
    }

    // check for game controllers (insert & removal)
    XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &addDuke, &removeDuke );

    //DebugPrint("USBMGR: XID: %X %X\n", removals, insertions);
    for( i=0; i < XGetPortCount(); i++ )
    {
        port = i % XGetPortCount();
        
        if( removeDuke & XIDMasks[i] )
        {
            //DebugPrint("USBMGR: Removed XID [%d][0]\n", i);
            delete (DeviceDuke*)devices[i][0];
            devices[i][0] = NULL;
            /*
            // close any devices in slots
            if(devices[i][1] != INVALID_HANDLE_VALUE)
            {
                XUnmountMU(XMUPortFromDriveLetter((WCHAR)devices[i][1]), XMUSlotFromDriveLetter((WCHAR)devices[i][1]));
                devices[i][1] = INVALID_HANDLE_VALUE;
            }
            if(devices[i][2] != INVALID_HANDLE_VALUE)
            {
                XUnmountMU(XMUPortFromDriveLetter((WCHAR)devices[i][2]), XMUSlotFromDriveLetter((WCHAR)devices[i][2]));
                devices[i][2] = INVALID_HANDLE_VALUE;
            }
                */
        }
        if( addDuke & XIDMasks[i] )
        {
            //DebugPrint("USBMGR: Inserted XID [%d][0]\n", i);
            devices[i][0] = new DeviceDuke( port, 0, &pollingParameters );
        }
    }

    // check for mu insertions
    for( i = 0; i < ARRAYSIZE( XMUMasks ); i++ )
    {
        slot = i < XGetPortCount() ? 1 : 2;
        port = i % XGetPortCount();
        
        if( addMU & XMUMasks[i] )
        {
            //DebugPrint("USBMGR: Inserted XMU [%d][%d] = %wc:\\\n", port, slot, drive);
            devices[i][slot] = new DeviceMU( port, slot );
        }
    }

    // check for xhawk insertions
    for( i = 0; i < ARRAYSIZE( XMUMasks ); i++ )
    {
        slot = i < XGetPortCount() ? 1 : 2;
        port = i % XGetPortCount();
        
        if( addHawk & XMUMasks[i] )
        {
            //DebugPrint("USBMGR: Inserted XHAWK [%d][%d]\n", port, slot);
            devices[i][slot] = new DeviceHawk(port, slot); 
        }
    }
}

// Will return TRUE if a particular DPAD direction is pressed
bool USBManager::IsDPadPressed( int port, unsigned int direction, BOOL bFalseOnRepeat /*=false*/ )
{
    // Make sure we have a duke at the current location, otherwise return false
    // Make sure we have a duke at the current location, otherwise return false
    if( port != PORT_ANY )
    {
        if( devices[port][0] == NULL )
        {
            // DebugPrint( "USBManager::IsDPadPressed(): Requested info for non-existing Duke!\n" );
            return false;
        }
    }

    XINPUT_STATE state;
    memset( &state, 0, sizeof( XINPUT_STATE ) );

    // Check to see if the user wants to find out for ANY port
    if( port == PORT_ANY )
    {
        for( unsigned int x = 0; x < NUM_XBOX_PORTS; ++x )
        {
            // If there is no Duke at the current port, skip over it
            if( devices[x][0] == NULL )
            {
                continue;
            }

            XInputGetState( ( (DeviceDuke*)devices[x][0] )->duke, &state );

            if( state.Gamepad.wButtons & ( 1 << ( direction - DPAD_TOP ) ) )
            {
                // A button is pressed, check to see if it's a repeated press or a first time press,
                // if the user cares about it
                if( bFalseOnRepeat && ( true == g_ControllerState.bDPadPressed[x][direction - DPAD_TOP] ) )
                {
                    return false;
                }
                else
                {
                    g_ControllerState.bDPadPressed[x][direction - DPAD_TOP] = true;
                    return true;
                }
            }
            else
            {
                g_ControllerState.bDPadPressed[x][direction - DPAD_TOP] = false;
            }

            // Clear out our state variable
            memset( &state, 0, sizeof( XINPUT_STATE ) );
        }
    }
    else // Only check one port
    {
        XInputGetState( ( (DeviceDuke*)devices[port][0] )->duke, &state );

        if( state.Gamepad.wButtons & ( 1 << ( direction - DPAD_TOP ) ) )
        {
            // A button is pressed, check to see if it's a repeated press or a first time press,
            // if the user cares about it
            if( bFalseOnRepeat && ( true == g_ControllerState.bDPadPressed[port][direction - DPAD_TOP] ) )
            {
                return false;
            }
            else
            {
                g_ControllerState.bDPadPressed[port][direction - DPAD_TOP] = true;
                return true;
            }
        }
        else
        {
            g_ControllerState.bDPadPressed[port][direction - DPAD_TOP] = false;
        }
    }

    // If the button wasn't pressed, let's return false
    return false;
}

// Will return TRUE if a button is depressed, or FALSE if it is not
bool USBManager::IsButtonPressed( int port, unsigned int button, BOOL bFalseOnRepeat /*=false*/ )
{
    // Make sure we have a duke at the current location, otherwise return false
    if( port != PORT_ANY )
    {
        if( devices[port][0] == NULL )
        {
            // DebugPrint( "USBManager::IsButtonPressed(): Requested info for non-existing Duke!\n" );
            return false;
        }
    }

    XINPUT_STATE state;
    memset( &state, 0, sizeof( XINPUT_STATE ) );

    // Check to see if the user wants to find out for ANY port
    if( port == PORT_ANY )
    {
        for( unsigned int x = 0; x < NUM_XBOX_PORTS; ++x )
        {
            // If there is no Duke in this port, skip to the next port
            if( devices[x][0] == NULL )
            {
                continue;
            }

            XInputGetState( ( (DeviceDuke*)devices[x][0] )->duke, &state );

            if( state.Gamepad.bAnalogButtons[button] )
            {
                // A button is pressed, check to see if it's a repeated press or a first time press,
                // if the user cares about it
                if( bFalseOnRepeat && ( true == g_ControllerState.bButtonPressed[x][button] ) )
                {
                    return false;
                }
                else
                {
                    g_ControllerState.bButtonPressed[x][button] = true;
                    return true;
                }
            }
            else
            {
                g_ControllerState.bButtonPressed[x][button] = false;
            }

            // Clear out our state variable
            memset( &state, 0, sizeof( XINPUT_STATE ) );
        }
    }
    else    // Check one port only
    {
        // Get the state of the Duke at the specified port
        XInputGetState( ( (DeviceDuke*)devices[port][0] )->duke, &state );

        if( state.Gamepad.bAnalogButtons[button] )
        {
            // A button is pressed, check to see if it's a repeated press or a first time press,
            // if the user cares about it
            if( bFalseOnRepeat && ( true == g_ControllerState.bButtonPressed[port][button] ) )
            {
                return false;
            }
            else
            {
                g_ControllerState.bButtonPressed[port][button] = true;
                return true;
            }
        }
        else
        {
            g_ControllerState.bButtonPressed[port][button] = false;
        }
    }

    // If the button wasn't pressed, let's return false
    return false;
}

void USBManager::ProcessInput( void )
{
    CheckForHotplugs();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashconfig\videoconstants.h ===
#ifndef _VIDEOCONSTANTS_H_
#define _VIDEOCONSTANTS_H_

#define SCREEN_WIDTH                    640
#define SCREEN_HEIGHT                   480
#define SCREEN_X_CENTER                 SCREEN_WIDTH / 2
#define SCREEN_Y_CENTER                 SCREEN_HEIGHT / 2

// Locations
#define HEADER_BOTTOM_Y_POSITION        35.0f
#define HEADER_LINE_Y_POSITION          HEADER_BOTTOM_Y_POSITION
#define HEADER_TEXT_X_POSITION          10.0f
#define FOOTER_TOP_Y_POSITION           SCREEN_HEIGHT - 35.0f
#define FOOTER_LINE_Y_POSITION          FOOTER_TOP_Y_POSITION
#define FOOTER_TEXT_X_POSITION          10.0f
#define MENU_TITLE_Y                    50.0f
#define MENU_OPTION1_Y                  100.0f
#define MENU_HIGHLIGHT_BORDER           2
#define MENU_HIGHLIGHT_BORDER_WIDTH     1
#define MENU_VERT_SPACING               10.0f
#define HEADER_LINE_WIDTH               1
#define FOOTER_LINE_WIDTH               1

// Colors
#define WHITE                           0xFFFFFFFF
#define BLACK                           0xFF000000
#define RED                             0xFFFF0000
#define LIGHT_GREEN                     0xFF90EE90
#define GREEN                           0xFF00FF00
#define LIGHT_BLUE                      0xFFADD8E6
#define NAVY_BLUE                       0xFF000080
#define BLUE                            0xFF0000FF
#define MEDIUM_BLUE                     0xFF0000CD
#define YELLOW                          0xFFFFFF00
#define CYAN                            0xFF00FFFF
#define BROWN                           0xFFA52A2A
#define HOT_PINK                        0xFFFF69B4

#define BACKGROUND_COLOR                BLACK
#define DEFAULT_TEXT_FG_COLOR           YELLOW
#define DEFAULT_TEXT_BG_COLOR           BACKGROUND_COLOR

#define MENU_TITLE_FG_COLOR             GREEN
#define MENU_TITLE_BG_COLOR             DEFAULT_TEXT_BG_COLOR
#define MENU_ITEM_FG_COLOR              DEFAULT_TEXT_FG_COLOR
#define MENU_ITEM_BG_COLOR              DEFAULT_TEXT_BG_COLOR
#define HEADER_TEXT_FG_COLOR            YELLOW
#define HEADER_TEXT_BG_COLOR            DEFAULT_TEXT_BG_COLOR
#define HEADER_BG_COLOR                 NAVY_BLUE
#define HEADER_LINE_COLOR               RED
#define FOOTER_TEXT_FG_COLOR            YELLOW
#define FOOTER_TEXT_BG_COLOR            DEFAULT_TEXT_BG_COLOR
#define FOOTER_BG_COLOR                 NAVY_BLUE
#define FOOTER_LINE_COLOR               RED
#define HIGHLIGHT_BOX_COLOR             WHITE

#endif // _VIDEOCONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashconfig\usbmanager.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    UsbManager.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-20-2000  Created
    11-01-2000  Modified JNH -- Removed uneeded launcher and socket code

Notes:
    What's inside the HANDLE from XInputOpen (HANDLE == _XID_OPEN_DEVICE*):
        PXID_DEVICE_NODE    XidNode;
        PXID_OPEN_DEVICE    NextOpenDevice;
        LONG                OutstandingPoll;
        ULONG               PacketNumber;
        PVOID               InterruptInEndpointHandle;
        PVOID               InterruptOutEndpointHandle;
        LONG                OpenCount;
        UCHAR               Report[XID_MAXIMUM_REPORT_SIZE-2];
        UCHAR               ReportForUrb[XID_MAXIMUM_REPORT_SIZE];
        URB                 Urb;
        URB_CLOSE_ENDPOINT  CloseUrb;
        UCHAR               MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        UCHAR               ClosePending:1;
        UCHAR               EndpointsOpen:1;
        UCHAR               EndpointsPendingClose:1;
        UCHAR               DeletePending:1;
        UCHAR               AutoPoll:1;
        UCHAR               Pad:3;

*/

#ifndef _USBMANAGER_H_
#define _USBMANAGER_H_

//#include <xbox.h>
#include <xtl.h>

extern "C" {ULONG DebugPrint(PCHAR Format, ...);}

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define BREAK_INTO_DEBUGGER     _asm { int 3 }

#define NUM_XBOX_PORTS      4

#define NUM_DUKE_BUTTONS    14

// DPAD
/*
#define DPAD_TOP            0
#define DPAD_BOTTOM         1
#define DPAD_LEFT           2
#define DPAD_RIGHT          3
*/

// Buttons
enum BUTTONS
{
    BUTTON_A,
    BUTTON_B,
    BUTTON_C,
    BUTTON_D,
    BUTTON_E,
    BUTTON_F,
    BUTTON_7,
    BUTTON_8,
    BUTTON_9,
    BUTTON_10,
    DPAD_TOP,           // If you change these, make sure "IsDPadPressed" still functions
    DPAD_BOTTOM,
    DPAD_LEFT,
    DPAD_RIGHT
};

// Ports
enum PORTS
{
    PORT_ANY = -1,
    PORT_1 = 0,
    PORT_2,
    PORT_3,
    PORT_4
};

// Parameters
#define FALSE_ON_REPEAT     true
#define TRUE_ON_REPEAT      false

enum
{
    SLOT_CONTROLLER,
    SLOT_TOP,
    SLOT_BOTTOM,
    SLOT_MAX
};

class CControllerState
{
public:
    // Constructors and Destructors
    CControllerState()
    {
        for( unsigned int y = 0; y < NUM_XBOX_PORTS; ++y )
        {
            for( unsigned int x = 0; x < NUM_DUKE_BUTTONS; ++x )
            {
                bButtonPressed[y][x] = false;
            }

            for( x = 0; x < 4; ++x )
            {
                bDPadPressed[y][x] = false;
            }
        }
    };
    
    ~CControllerState(){};

    // Public Properties
    bool bButtonPressed[NUM_XBOX_PORTS][NUM_DUKE_BUTTONS];
    bool bDPadPressed[NUM_XBOX_PORTS][4];
private:
};

class USBDevice
{
public:
    PXPP_DEVICE_TYPE type; // XDEVICE type

public:
    USBDevice()
    {
        type = NULL;
    }
    
    ~USBDevice()
    {
        type = NULL;
    }

public:
    virtual void Insert( unsigned port, unsigned slot ) = 0;
    virtual void Remove( void ) = 0;
};

class DeviceDuke : public USBDevice
{
public:
    HANDLE duke;
    XINPUT_POLLING_PARAMETERS *pollingParameters;

public:
    DeviceDuke()
    {
        type = XDEVICE_TYPE_GAMEPAD;
        pollingParameters = NULL;
        duke = NULL;
    }

    DeviceDuke( unsigned port, unsigned slot, XINPUT_POLLING_PARAMETERS *p )
    {
        type = XDEVICE_TYPE_GAMEPAD;
        pollingParameters = p;
        duke = NULL;
        Insert( port, slot );
    }

    ~DeviceDuke()
    {
        if( duke )
        {
            Remove();
        }
    }

public:
    void Insert( unsigned port, unsigned slot )
    {
        /*DebugPrint("USBDevice: Insert duke\n");*/
        duke = XInputOpen( XDEVICE_TYPE_GAMEPAD, port, 0, pollingParameters );
    }

    void Remove( void )
    {
        /*DebugPrint("USBDevice: Remove duke\n");*/
        XInputClose( duke );
        duke = 0;
    }
};

class DeviceMU : public USBDevice
{
public:
    WCHAR drive;

public:
    DeviceMU()
    {
        type = XDEVICE_TYPE_MEMORY_UNIT;
        drive = 0;
    }
    
    DeviceMU( unsigned port, unsigned slot )
    {
        type = XDEVICE_TYPE_MEMORY_UNIT;
        drive = 0;
        Insert(port, slot);
    }

    ~DeviceMU()
    {
        if( drive )
        {
            Remove();
        }
    }

public:
    void Insert( unsigned port, unsigned slot )
    {
        /*DebugPrint("USBDevice: Insert MU\n");*/
        XMountMU( port, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT, &drive );
    }

    void Remove( void )
    {
        /*DebugPrint("USBDevice: Remove MU\n");*/
        XUnmountMU( XMUPortFromDriveLetter( drive ), XMUSlotFromDriveLetter( drive ) );
        drive = 0;
    }
};

class DeviceHawk : public USBDevice
{
public:
    XMediaObject *microphone;
    XMediaObject *headphone;

public:
    DeviceHawk()
    {
        type = XDEVICE_TYPE_VOICE_MICROPHONE;
        microphone = headphone = NULL;
    }
    
    DeviceHawk( unsigned port, unsigned slot )
    {
        type = XDEVICE_TYPE_VOICE_MICROPHONE;
        microphone = headphone = NULL;
        Insert(port, slot);
    }

    ~DeviceHawk()
    {
        if( microphone || headphone )
        {
            Remove();
        }
    }

public:
    void Insert(unsigned port, unsigned slot)
    {
        /*DebugPrint("USBDevice: Insert HAWK\n");*/
        XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_MICROPHONE, port, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT, NULL, &microphone);
        XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_HEADPHONE, port, slot==1?XDEVICE_TOP_SLOT:XDEVICE_BOTTOM_SLOT, NULL, &headphone);
    }

    void Remove(void)
    { 
        /*DebugPrint("USBDevice: Remove HAWK\n");*/
        if( microphone )
        {
            DebugPrint("microphone->Release()...");
            microphone->Release();
            DebugPrint("...microphone->Release()\n");
        } 

        if( headphone )
        {
            DebugPrint("headphone->Release()...");
            headphone->Release();  DebugPrint("...headphone->Release()\n");
        } 

        microphone = headphone = NULL; 
        /*DebugPrint("USBDevice: Remove HAWK\n");*/
    }
};

class USBManager
{
public:
    USBDevice *devices[XGetPortCount()][SLOT_MAX];
    DWORD packetNum[XGetPortCount()][SLOT_MAX];
    XINPUT_POLLING_PARAMETERS pollingParameters;

public:
    USBManager();
    ~USBManager();

public:
    void ProcessInput( void );
    void CheckForHotplugs( void );
    bool IsButtonPressed( int port, unsigned int button, BOOL bFalseOnRepeat = false );
    bool IsDPadPressed( int port, unsigned int direction, BOOL bFalseOnRepeat = false );

private:
    CControllerState g_ControllerState;
};

#endif // _USBMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\bootsequence\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashconfig\xboxvideo.h ===
/*****************************************************
*** xboxvideo.h
***
*** Header file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#ifndef _XBOXVIDEO_H_
#define _XBOXVIDEO_H_

#include <xtl.h>
#include <xfont.h>

extern "C" {ULONG DebugPrint(PCHAR Format, ...);}

// Macros
#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) DebugPrint(#code "File %s Line %d, Failed: %d\n", __LINE__, __FILE__, _ret__); } while (0);

// XBox configuration
#define TITLE_DRIVE             L"t:"
#define MEDIA_PATH              TITLE_DRIVE L"\\media"

// Screen defaults
#define DEFAULT_SCREEN_WIDTH    640
#define DEFAULT_SCREEN_HEIGHT   480
#define DEFAULT_SCREEN_BG_CLEAR 0xFF000000

// Fonts
#define FONT_COUR_FILENAME      MEDIA_PATH L"\\cour.xft"
#define FONT_ARIAL_FILENAME     MEDIA_PATH L"\\arialb16.xft"
#define DEFAULT_FONT_WIDTH      8
#define DEFAULT_FONT_HEIGHT     15
#define DEFAULT_FONT_FG_COLOR   0xFF00FF00
#define DEFAULT_FONT_BG_COLOR   0xFF000000

class CXBoxVideo
{
public:
    // Constructors and Destructors
    CXBoxVideo( void );
    ~CXBoxVideo( void );

    // Public Properties

    // Public Methods
    void Initialize( int width,                         // Initialize D3D for this screen -- height and width default
                     int height );
    
    void DeInitialize( void );                          // Free our objects
    void ClearScreen( void );                           // Clear the current screen
    
    void DrawBox( float x1,                             // Draw a box on the screen
                  float y1,
                  float x2,
                  float y2,
                  DWORD color );
    
    void DrawBitBlt( float fx,                          // Draw the inputed bit array to the screen
                     float fy,
                     ULONG ulWidth,
                     ULONG ulHeight,
                     const DWORD* pData );
    
    void DrawClearRect( float x1,                       // Draw a clear rectangle to the screen
                        float y1,
                        float x2,
                        float y2,
                        DWORD color );

    HRESULT DrawLine( float x1,                         // Draw a line on the screen
                      float y1,
                      float x2,
                      float y2,
                      unsigned int uiLineWidth,
                      DWORD color );

    void DrawOutline( float x1,                         // Draw an outline at the current location with a specific border size
                      float y1,
                      float x2,
                      float y2,
                      unsigned int uiLineWidth,
                      DWORD color );

    int DrawText( float x1,                             // Prints formatted text, using the default font size and color
                  float y1,
                  DWORD fgcolor,
                  DWORD bgcolor,
                  const TCHAR* format,
                  ... );

    int GetStringPixelWidth( IN LPCWSTR string,         // Get the pixel width of a string
                             IN int length = -1 );

    void GetFontSize( OPTIONAL OUT float* pwidth,       // Get the size of the currently selected font
                      OPTIONAL OUT float* pheight,
                      OPTIONAL OUT DWORD* pfgcolor,
                      OPTIONAL OUT DWORD* pbgcolor );

    void SetFontSize( float width,                      // Set the font dimensions
                      float height,
                      DWORD col,
                      DWORD bkcol );

    void ShowScreen();                                  // Display the current backbuffer on the screen

private:
    // Vertext structure
    struct MYVERTEX
    {
	    D3DXVECTOR3 v;
	    float       fRHW;
	    D3DCOLOR    cDiffuse;
    };

    // Private Properties
    IDirect3DDevice8* m_Device;
    IDirect3DSurface8* m_BackBuffer;
    IDirect3DVertexBuffer8* m_VertexBuffer;
    int m_ScreenWidth; 
    int m_ScreenHeight;
    
    // Font Properties
    XFONT* m_Font;
    float m_FontWidth;
    float m_FontHeight;
    DWORD m_FontColor;
    DWORD m_FontBgColor;

    // Private Methods
};

#endif // _XBOXVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashconfig\xdashconfig.cpp ===
#include "stdafx.h"

// Forward declarations
// void DisplayMemStats( void );
HRESULT DrawScreen(void );
HRESULT DrawBackground( void );
HRESULT DrawFooter( void );
HRESULT DrawHeader( void );
HRESULT ProcessInput( void );
HRESULT SetupMenusAndItems( void );
HRESULT XDashCfgCleanUp( void );
HRESULT XDashCfgInit( void );

// Menus are created here
CMenuScreen g_RootMenu             ( NULL,               L"Root",               L"Root Menu of the XDash Config Program" );

// Root Items
CMenuScreen g_ConfigMenu           ( &g_RootMenu,        L"Configuration",      L"Configure various items on the XBox" );
CMenuScreen g_RebootMenu           ( &g_RootMenu,        L"Reboot",             L"Reboot the XBox to various XDash entry points" );
CMenuScreen g_MemoryMenu           ( &g_RootMenu,        L"Memory Management",  L"Manage memory area of the XBox" );

// Config Items
CClockMenuScreen g_ClockManagement ( &g_ConfigMenu,      L"Clock Management",   L"Configure Time and Date settings on the XBox" );

// Reboot Menu Items
CRebootCommand g_RebootXbox        ( &g_RebootMenu,      L"Reboot XBox",        L"Reboots the XBox as if the user had pressed 'Power'" );

// Memory Management
CMAFormatCommand g_MAFormat        ( &g_ConfigMenu,      L"Format Memory Area", L"Formats a Memory Area on the XBox" );

// Other globals
CXBoxVideo Screen;                                              // Screen object where all text / info is displayed
USBManager  Controllers;                                        // Used to determine what buttons / direction the user is pressing
CXDCItem* g_pCurrentScreen = NULL;                              // Pointer to the current menu object

void __stdcall wWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow )
{
    DebugPrint( "***** XDashConfig(): wWinMain()\n" );

    XDashCfgInit();

    do
    {
        DrawScreen();
        ProcessInput();
    } while( !Controllers.IsButtonPressed( PORT_ANY, BUTTON_F ) );

    XDashCfgCleanUp();

    // Reboot the XBox
    DebugPrint( "***** XDashConfig(): Rebooting...\n" );
    XLaunchNewImage( NULL, NULL );

    DebugPrint( "***** XDashConfig(): wWinMain()\n" );
}

// Draw our screen
HRESULT DrawScreen( void )
{
    // DebugPrint( "  DrawScreen()\n" );

    Screen.ClearScreen();   // Clear the screen
    DrawBackground();       // Draw our background
    DrawHeader();           // Draw the screen header
    g_pCurrentScreen->Action( &Screen );
    DrawFooter();
    Screen.ShowScreen();    // Move the screen from the backbuffer to the foreground

    return S_OK;
}

// Draw the background of our application
HRESULT DrawBackground( void )
{
    // DebugPrint( "  DrawBackground()\n" );

    Screen.DrawBox( 0.0f, 0.0f, (float)SCREEN_WIDTH, (float)SCREEN_HEIGHT, (DWORD)BACKGROUND_COLOR );

    return S_OK;
}

// Initialize our application - video, sound, etc
HRESULT XDashCfgInit( void )
{
    DebugPrint( "  XDashCfgInit()\n" );

    // Setup Menus and Items
    SetupMenusAndItems();

    g_pCurrentScreen = &g_RootMenu;

    // Initialize our drawing routines (d3d, etc)
    Screen.Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );

    return S_OK;
}

// Clean up our application (close drivers, etc)
HRESULT XDashCfgCleanUp( void )
{
    DebugPrint( "  XDashCfgCleanUp()\n" );

    Screen.DeInitialize();

    return S_OK;
}

// Draw the header information on our screen
HRESULT DrawHeader( void )
{
    float fFontHeight = 0.0;
    float fHeaderTextYPos = 0.0;

    Screen.GetFontSize( 0, &fFontHeight, 0, 0 );
    fHeaderTextYPos = ( HEADER_BOTTOM_Y_POSITION / 2 ) - ( fFontHeight / 2 );

    // Fill the header background with the appropriate color
    Screen.DrawBox( 0, 0, SCREEN_WIDTH, HEADER_BOTTOM_Y_POSITION, HEADER_BG_COLOR );

    // Draw a header bar with the title and time
    Screen.DrawText( HEADER_TEXT_X_POSITION, fHeaderTextYPos, HEADER_TEXT_FG_COLOR, HEADER_TEXT_BG_COLOR, TITLE_NAME );
    Screen.DrawLine( 0, HEADER_LINE_Y_POSITION, SCREEN_WIDTH, HEADER_LINE_Y_POSITION, HEADER_LINE_WIDTH, HEADER_LINE_COLOR );

    SYSTEMTIME sysTime;
    ZeroMemory( &sysTime, sizeof( SYSTEMTIME ) );
    WCHAR timeString[255];

    GetSystemTime( &sysTime );
    wsprintf( timeString, L"%02d / %02d / %d  %02d : %02d : %02d", sysTime.wMonth, sysTime.wDay, sysTime.wYear, sysTime.wHour, sysTime.wMinute, sysTime.wSecond );
    Screen.DrawText( SCREEN_WIDTH - Screen.GetStringPixelWidth( timeString ) - MENU_VERT_SPACING, fHeaderTextYPos, HEADER_TEXT_FG_COLOR, HEADER_TEXT_BG_COLOR, timeString );

    return S_OK;
}

// Draw the footer information on our screen
HRESULT DrawFooter( void )
{
    float fFontHeight = 0.0;
    float fFooterTextYPos = 0.0;

    Screen.GetFontSize( 0, &fFontHeight, 0, 0 );
    fFooterTextYPos = ( FOOTER_TOP_Y_POSITION - ( ( SCREEN_HEIGHT - FOOTER_TOP_Y_POSITION ) / 2 ) ) - ( fFontHeight / 2 );

    // Fill the footer background with the appropriate color
    Screen.DrawBox( 0, FOOTER_TOP_Y_POSITION, SCREEN_WIDTH, SCREEN_HEIGHT, FOOTER_BG_COLOR );

    // Draw the description for the currently highlighted item
    Screen.DrawLine( 0, FOOTER_LINE_Y_POSITION, SCREEN_WIDTH, FOOTER_LINE_Y_POSITION, FOOTER_LINE_WIDTH, FOOTER_LINE_COLOR );
    if( g_pCurrentScreen->GetFooterText() )
    {
        Screen.DrawText( FOOTER_TEXT_X_POSITION, fFooterTextYPos, FOOTER_TEXT_FG_COLOR, FOOTER_TEXT_BG_COLOR, g_pCurrentScreen->GetFooterText() );
    }

    return S_OK;
}

/*
// Output the current memory usage to the Debugger
void DisplayMemStats( void )
{
    unsigned int pageSize = 4096;
    MM_STATISTICS mmStats;
    memset(&mmStats, 0, sizeof(MM_STATISTICS));
    mmStats.Length = sizeof(MM_STATISTICS);
    MmQueryStatistics(&mmStats);
    DebugPrint( "Memory Status----------------------------------------------------------------\r\n" );
    DebugPrint( "   Total:       %12lu B\r\n", mmStats.TotalPhysicalPages * pageSize );
    DebugPrint( "   Available:   %12lu B\r\n", mmStats.AvailablePages * pageSize );
    DebugPrint( "   Cache:       %12lu B\r\n", mmStats.CachePagesCommitted * pageSize );
    DebugPrint( "   Pool:        %12lu B\r\n", mmStats.PoolPagesCommitted * pageSize );
    DebugPrint( "   Stack:       %12lu B\r\n", mmStats.StackPagesCommitted * pageSize );
    DebugPrint( "   Image:       %12lu B\r\n", mmStats.ImagePagesCommitted * pageSize );
}
*/

// Handle input from the user
HRESULT ProcessInput( void )
{
    bool bButtonPressed;
    bool bFirstPress;

    // Check to see if anything was removed or inserted
    Controllers.CheckForHotplugs();

    // Handle the user making a selection with the A Button
    bFirstPress = Controllers.IsButtonPressed( PORT_ANY, BUTTON_A, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_A, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_pCurrentScreen->HandleInput( BUTTON_A, bFirstPress );
    }

    // Handle the user making a selection with the B Button
    bFirstPress = Controllers.IsButtonPressed( PORT_ANY, BUTTON_B, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsButtonPressed( PORT_ANY, BUTTON_B, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_pCurrentScreen->HandleInput( BUTTON_B, bFirstPress );
    }


    // Handle the user pressing UP on the DPad
    bFirstPress = Controllers.IsDPadPressed( PORT_ANY, DPAD_TOP, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsDPadPressed( PORT_ANY, DPAD_TOP, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_pCurrentScreen->HandleInput( DPAD_TOP, bFirstPress );
    }


    // Handle the user pressing DOWN on the DPad
    bFirstPress = Controllers.IsDPadPressed( PORT_ANY, DPAD_BOTTOM, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsDPadPressed( PORT_ANY, DPAD_BOTTOM, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_pCurrentScreen->HandleInput( DPAD_BOTTOM, bFirstPress );
    }

    // Handle the user pressing LEFT on the DPad
    bFirstPress = Controllers.IsDPadPressed( PORT_ANY, DPAD_LEFT, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsDPadPressed( PORT_ANY, DPAD_LEFT, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_pCurrentScreen->HandleInput( DPAD_LEFT, bFirstPress );
    }

    // Handle the user pressing RIGHT on the DPad
    bFirstPress = Controllers.IsDPadPressed( PORT_ANY, DPAD_RIGHT, FALSE_ON_REPEAT );
    bButtonPressed = Controllers.IsDPadPressed( PORT_ANY, DPAD_RIGHT, TRUE_ON_REPEAT );
    if( bButtonPressed )
    {
        g_pCurrentScreen->HandleInput( DPAD_RIGHT, bFirstPress );
    }

    return S_OK;
}

// Setup our Menus and Items for our application
HRESULT SetupMenusAndItems( void )
{
    // Setup the Root Menu
    g_RootMenu.AddItem( &g_ConfigMenu );
    g_RootMenu.AddItem( &g_RebootMenu );
    g_RootMenu.AddItem( &g_MemoryMenu );

    // Setup the Configuration Menu
    g_ConfigMenu.AddItem( &g_ClockManagement );

    // Setup the Reboot Menu
    g_RebootMenu.AddItem( &g_RebootXbox );

    // Memory Management
    g_MemoryMenu.AddItem( &g_MAFormat );

    return S_OK;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashconfig\xdcitem.h ===
/*****************************************************
*** xdcitem.h
***
*** Header file for our abstract base class for a
*** generic screen of our XDash Config program.
*** 
*** by James N. Helm
*** November 2nd, 2000
*** 
*****************************************************/

#ifndef _XDCITEM_H_
#define _XDCITEM_H_

#include "xboxvideo.h"
#include "usbmanager.h"
#include "linkedlist.h"

class CXDCItem
{
public:
    // Constructors and Destructors
    CXDCItem();
    CXDCItem( CXDCItem* pParent, WCHAR* pwszTitle, WCHAR* pwszDescription );
    ~CXDCItem(); 

    // Function that MUST be overridden
    virtual void Action( CXBoxVideo* Screen ) = 0;
    virtual void HandleInput( enum BUTTONS buttonPressed, bool bRepeatPress ) = 0;

    virtual WCHAR* GetDescription() const { return m_pwszDescription; };
    virtual WCHAR* GetFooterText() const { return m_pwszFooterText; };
    virtual WCHAR* GetTitle() const { return m_pwszTitle; };
    virtual CXDCItem* GetParent() const { return m_pParent; };
    
    virtual void SetDescription( const WCHAR* pwszDescription );
    virtual void SetFooterText( const WCHAR* pwszFooterText );
    virtual void SetParent( CXDCItem* pParent ) { m_pParent = pParent; };
    virtual void SetTitle( const WCHAR* pwszTitle );

private:
    WCHAR* m_pwszDescription;           // The Description of the screen
    WCHAR* m_pwszFooterText;            // Text that should be displayed in the XDashConfig footer
    WCHAR* m_pwszTitle;                 // The title of our current screen
    CXDCItem* m_pParent;                // Pointer to the parent screen of this item
};

#endif // _XDCITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\games\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\bootsequence\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
#define AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_

#if _MSC_VER > 1000
    #pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN         // Exclude rarely-used stuff from Windows headers
#endif

#ifndef UNICODE
    #define _UNICODE
    #define UNICODE
#endif




// Exclude rarely-used stuff from Windows headers
#define NTLEANANDMEAN
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_IA64_) && defined(_M_IX86)
#define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MRX000)
#define _MIPS_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_ALPHA)
#define _ALPHA_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_PPC)
#define _PPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_M68K)
#define _68K_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MPPC)
#define _MPPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_M_IX86) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <stdio.h>
#include <xtl.h>
#include <profilep.h>

#include "stepslog.h"
#include "xdashteststeps.h"
#include "commontest.h"
#include "environments.h"

extern "C"
{
        ULONG DebugPrint(PCHAR Format, ...);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\bootsequence\tests.h ===
#ifndef _tests_h
#define _tests_h

namespace xdashboot
{
    #define VARIATION_BUFFER_SIZE  1024

    /*

    Copyright (c) 2000 Microsoft Corporation

    Module Name:

        Tests.h

    Abstract:



    Author:

        Jim Helm (jimhelm)

    Environment:

        XBox

    Revision History:
        10-18-2000  Created

    */

    //
    //  Boot Sequence Tests
    //

    //    01234567890123456789012345678901
    DWORD Test1Here                       ( HANDLE hLog, CStepsLog* pStepsLog );

}; // namespace

#endif // _tests_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashconfig\xdcitem.cpp ===
/*****************************************************
*** xdcitem.cpp
***
*** CPP file for our abstract base class for a
*** generic screen of our XDash Config program.
*** 
*** by James N. Helm
*** November 2nd, 2000
*** 
*****************************************************/

#include "xdcitem.h"

// Constructor
CXDCItem::CXDCItem() :
m_pwszDescription( NULL ),
m_pwszFooterText( NULL ),
m_pParent( NULL ),
m_pwszTitle( NULL )
{
};


CXDCItem::CXDCItem( CXDCItem* pParent, WCHAR* pwszTitle, WCHAR* pwszDescription ) :
m_pwszDescription( NULL ),
m_pwszFooterText( NULL ),
m_pParent( NULL ),
m_pwszTitle( NULL )
{
    if( !pwszTitle || !pwszDescription )
    {
        DebugPrint( "CXDCItem::CXDCItem(): Invalid Parameters!!\n" );
        return;
    }

    SetParent( pParent );
    SetTitle( pwszTitle );
    SetDescription( pwszDescription );
};

// Destructor
CXDCItem::~CXDCItem()
{ 
    // Clean up the memory for the description if it's used
    if( m_pwszDescription )
    {
        delete[] m_pwszDescription;
        m_pwszDescription = NULL;
    }

    // Clean up the memory for the title if it's used
    if( m_pwszTitle )
    {
        delete[] m_pwszTitle;
        m_pwszTitle = NULL;
    }

    // Clean up the memory for the footertext if it's used
    if( m_pwszFooterText )
    {
        delete[] m_pwszFooterText;
        m_pwszFooterText = NULL;
    }
}

// Set the description of our current item
void CXDCItem::SetDescription( const WCHAR* pwszDescription )
{
    if( !pwszDescription )
    {
        DebugPrint( "CXDCItem::SetDescription(): pwszDescription was not a valid pointer!\n" );
        return;
    }

    if( m_pwszDescription )
    {
        delete[] m_pwszDescription;
        m_pwszDescription = NULL;
    }

    m_pwszDescription = _wcsdup( pwszDescription );
}

// Set the title of our current item
void CXDCItem::SetTitle( const WCHAR* pwszTitle )
{
    if( !pwszTitle )
    {
        DebugPrint( "CXDCItem::SetTitle(): pwszTitle was not a valid pointer!\n" );
        return;
    }

    if( m_pwszTitle )
    {
        delete[] m_pwszTitle;
        m_pwszTitle = NULL;
    }

    m_pwszTitle = _wcsdup( pwszTitle );
    if( !m_pwszTitle )
    {
        DebugPrint( "CXDCItem::SetTitle(): could not allocate memory!\n" );
    }
}

// Set the footer text of our current item
void CXDCItem::SetFooterText( const WCHAR* pwszFooterText )
{
    if( !pwszFooterText )
    {
        DebugPrint( "CXDCItem::SetFooterText(): pwszFooterText was not a valid pointer!\n" );
        return;
    }

    if( m_pwszFooterText )
    {
        delete[] m_pwszFooterText;
        m_pwszFooterText = NULL;
    }

    m_pwszFooterText = _wcsdup( pwszFooterText );
    if( !m_pwszFooterText )
    {
        DebugPrint( "CXDCItem::SetFooterText(): could not allocate memory!\n" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\bootsequence\tests.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    Tests.cpp

Abstract:


Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-18-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "tests.h"

namespace xdashboot
{
    /***********************
    ************************
    *** Begin Test Cases ***
    ************************
    ***********************/


    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD Test1Here( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This case verifies that 
        //////////////////////////////////////////////////////////////////////////

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( L"Step 1" );
        pStepsLog->AddStep( L"Step 2" );
        pStepsLog->AddStep( L"Step 3" );
        pStepsLog->AddStep( L"Step 4" );

        // For every screen in the XDash
        _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
        _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Variation Here", xlogVariationNum );

        // Log the test case variation to our Steps File
        pStepsLog->AddVariation( stepsVariation );

        TESTCASE( xlogVariation )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };
}; // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\bootsequence\xdashboot.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    XDashBoot.h

Abstract:



Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-18-2000  Created

*/
#ifndef _XDASHBOOT_H_
#define _XDASHBOOT_H_

#define COMPONENT_NAME_W    L"XDashBoot"
#define COMPONENT_NAME_A    "XDashBoot"
#define DLL_NAME_W          L"XDashBoot"
#define DLL_NAME_A          "XDashBoot"

typedef DWORD ( *APITEST_FUNC )( HANDLE hLog, CStepsLog* pStepsLog );

#endif // _XDASHBOOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\games\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
#define AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_

#if _MSC_VER > 1000
    #pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN         // Exclude rarely-used stuff from Windows headers
#endif

#ifndef UNICODE
    #define _UNICODE
    #define UNICODE
#endif

// Exclude rarely-used stuff from Windows headers
#define NTLEANANDMEAN
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_IA64_) && defined(_M_IX86)
#define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MRX000)
#define _MIPS_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_ALPHA)
#define _ALPHA_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_PPC)
#define _PPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_M68K)
#define _68K_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MPPC)
#define _MPPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_M_IX86) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <stdio.h>
#include <xtl.h>
#include <profilep.h>

#include "stepslog.h"
#include "xdashteststeps.h"
#include "commontest.h"
#include "environments.h"

extern "C"
{
        ULONG DebugPrint(PCHAR Format, ...);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\bootsequence\xdashboot.cpp ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    XDashBoot.cpp

Abstract:

    The DLL exports two of the mandatory APIs: StartTest and EndTest.
    TESTINI.INI must be modified correctly so that the
    harness will load and call StartTest/EndTest.

    Please see "x-box test harness.doc" for more information.

Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10/18/2000  Created

*/


#include <xlog.h>
#include "stdafx.h"
#include "XDashBoot.h"
#include "tests.h"

namespace xdashboot
{
    static BOOL printSteps = true;

    /*

    Routine Description:


    Arguments:

        HANDLE hLog - to the logging object
        CStepsLog* pStepsLog - Object used to log our test steps

    Return Value:

        DWORD

    */
    DWORD XDashBootRunAll( HANDLE hLog, CStepsLog* pStepsLog )
    {
        struct APIFUNCT
        {
            APITEST_FUNC f;
            WCHAR *name;
            char *aname;
        };

        #define BUILTAPISTRUCT(n) { n , L#n , #n }

        // Define all the API tests
        APIFUNCT testlist[] =
        {
            /*
            */
            BUILTAPISTRUCT( Test1Here )
            /*
            */
        };

        // Run the suite of tests

        // run each test
        for( size_t j = 0; j < ARRAYSIZE( testlist ); j++ )
        {
            xSetFunctionName(hLog, testlist[j].aname);
            DebugPrint( "%s: Entering test = '%ws()'\n", COMPONENT_NAME_A, testlist[j].name );

            // Log the testcase name to our steps log
            pStepsLog->SetCaseName( testlist[j].name );
            testlist[j].f( hLog, pStepsLog );

            // Log the test case (if the user wishes to)
            if ( printSteps )
            {
                pStepsLog->LogTestCase();
            }

            // Clear out the log for our next test
            pStepsLog->ClearTestCase();
        }

        return 0;
    }
}; // namespace


/*

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

*/
VOID WINAPI XDashBootStartTest( HANDLE hLog )
{
    using namespace xdashboot;

    // test settings
    const int buffLen = 1024;
    
    char* ownerAlias     = new char[buffLen];
    char* componentMajor = new char[buffLen];
    char* componentMinor = new char[buffLen];
    char* stepsFileName  = new char[buffLen];
    int HTMLLogFormat    = 0;

    if( ownerAlias && componentMajor && componentMinor && stepsFileName )
    {
        // Object used to log our steps
        CStepsLog StepsLog;

        // Pull out internal INI file settings
        GetProfileStringA( DLL_NAME_A,   "Owner",           "Owner",          ownerAlias,     buffLen );
        GetProfileStringA( DLL_NAME_A,   "ComponentMajor",  "ComponentMajor", componentMajor, buffLen );
        GetProfileStringA( DLL_NAME_A,   "ComponentMinor",  "ComponentMinor", componentMinor, buffLen );
        GetProfileStringA( DLL_NAME_A,   "StepsFile",       "StepsFile",      stepsFileName,  buffLen );
        printSteps = GetProfileIntA( DLL_NAME_A, "PrintSteps", 0 );
        HTMLLogFormat = GetProfileIntA( DLL_NAME_A, "HTMLStepsLog", 1 );

        // Set the format for our STEPS log file
        StepsLog.SetHTMLLogFormat( HTMLLogFormat );

        xSetOwnerAlias( hLog, ownerAlias );
        xSetComponent( hLog, componentMajor, componentMinor );
        DebugPrint( "%s: **************************************************************\n", COMPONENT_NAME_A );
        DebugPrint( "%s: Entering %sStartTest()\n", COMPONENT_NAME_A, COMPONENT_NAME_A );
        DebugPrint( "%s: Internal INI Settings:\n", COMPONENT_NAME_A );
        DebugPrint( "   Owner           = '%s'\n", ownerAlias );
        DebugPrint( "   Component Major = '%s'\n", componentMajor );
        DebugPrint( "   Component Minor = '%s'\n", componentMinor );

        // Open our Steps Log File
        if (printSteps)
        {
            StepsLog.OpenLog( stepsFileName );
        }

        XDashBootRunAll( hLog, &StepsLog );

        if ( printSteps )
        {
            // Close our Steps Log File
            StepsLog.CloseLog();
        }

        DebugPrint( "%s: Leaving %sStartTest()\n", COMPONENT_NAME_A, COMPONENT_NAME_A );
        DebugPrint( "%s: **************************************************************\n", COMPONENT_NAME_A );
        xSetOwnerAlias( hLog, NULL );
    }
    else // Memory allocation failed
    {
        DebugPrint( "**ERROR: XDashNavStartTest():Could not allocate memory!!" );
    }

    if( ownerAlias )
    {
        delete[] ownerAlias;
        ownerAlias = NULL;
    }

    if( componentMajor )
    {
        delete[] componentMajor;
        componentMajor = NULL;
    }
    
    if( componentMinor )
    {
        delete[] componentMinor;
        componentMinor = NULL;
    }
    
    if( stepsFileName )
    {
        delete[] componentMinor;
        componentMinor = NULL;
    }
}


/*

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

*/
VOID WINAPI XDashBootEndTest(void)
{
}


#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( xdashboot )
#pragma data_seg()

BEGIN_EXPORT_TABLE( xdashboot )
    EXPORT_TABLE_ENTRY( "StartTest", XDashBootStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XDashBootEndTest )
END_EXPORT_TABLE( xdashboot )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\games\tests.h ===
#ifndef _TESTS_H_
#define _TESTS_H_

namespace xdashgames
{
    #define VARIATION_BUFFER_SIZE  1024

    /*

    Copyright (c) 2000 Microsoft Corporation

    Module Name:

        Tests.h

    Abstract:



    Author:

        Jim Helm (jimhelm)

    Environment:

        XBox

    Revision History:
        10-18-2000  Created

    */

    //
    //  Games Area Tests
    //

    //    01234567890123456789012345678901

    DWORD Test1Here                       ( HANDLE hLog, CStepsLog* pStepsLog );

}; // namespace

#endif // _TESTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\games\xdashgames.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    XDashGames.h

Abstract:



Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-16-2000  Created

*/
#ifndef _XDASHGAMES_H_
#define _XDASHGAMES_H_

#define COMPONENT_NAME_W    L"XDashGames"
#define COMPONENT_NAME_A    "XDashGames"
#define DLL_NAME_W          L"XDashGames"
#define DLL_NAME_A          "XDashGames"

typedef DWORD ( *APITEST_FUNC )( HANDLE hLog, CStepsLog* pStepsLog );

#endif // _XDASHGAMES_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\games\tests.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    Tests.cpp

Abstract:


Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-18-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "tests.h"

namespace xdashgames 
{
    /***********************
    ************************
    *** Begin Test Cases ***
    ************************
    ***********************/


    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD Test1Here( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This case verifies that 
        //////////////////////////////////////////////////////////////////////////

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( L"Step 1" );
        pStepsLog->AddStep( L"Step 2" );
        pStepsLog->AddStep( L"Step 3" );

        _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
        _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Variation Here", xlogVariationNum );

        // Log the test case variation to our Steps File
        pStepsLog->AddVariation( stepsVariation );

        TESTCASE( xlogVariation )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };
}; // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\inc\environments.h ===
#ifndef _ENVIRONMENTS_H
#define _ENVIRONMENTS_H


// This structure will hold a list of Memory Devices (areas)
// with the first element being a device to Copy From, and the
// second element being the device to Copy To.
typedef struct _CopyFromToMD {
    enum MemoryAreasWithinList FromMD;
    enum MemoryAreasWithinList ToMD;
} CopyFromToMD;


// Types of devices that can be plugged in to the Xbox
enum DeviceTypes
{
    DEVICE_EMPTY,
    DEVICE_DUKE,
    DEVICE_MU,
    DEVICE_HAWK,
    DEVICE_MAX
};


// State of the Xbox tray
enum TrayStates
{
    TRAY_CLOSED,
    TRAY_OPEN,
    TRAY_MAX
};

// Media types that can be inserted in the Xbox tray
enum MediaTypes
{
    MEDIA_EMPTY,
    MEDIA_DVD_XBOX_GAME_RATED_NR,
    MEDIA_DVD_XBOX_GAME_RATED_ADULTS,
    MEDIA_DVD_XBOX_GAME_RATED_MATURE,
    MEDIA_DVD_XBOX_GAME_RATED_TEEN,
    MEDIA_DVD_XBOX_GAME_RATED_EVERYONE,
    MEDIA_DVD_XBOX_GAME_RATED_CHILDHOOD,
    MEDIA_DVD_XBOX_GAME_MULTIDISK_1,
    MEDIA_DVD_XBOX_GAME_MULTIDISK_2,
    MEDIA_DVD_MOVIE_NOREGION,
    MEDIA_DVD_MOVIE_REGION1_RATED_NR,
    MEDIA_DVD_MOVIE_REGION1_RATED_NC17,
    MEDIA_DVD_MOVIE_REGION1_RATED_R,
    MEDIA_DVD_MOVIE_REGION1_RATED_PG13,
    MEDIA_DVD_MOVIE_REGION1_RATED_PG,
    MEDIA_DVD_MOVIE_REGION1_RATED_G,
    MEDIA_DVD_MOVIE_REGION2,
    MEDIA_DVD_MOVIE_REGION3,
    MEDIA_DVD_MOVIE_REGION4,
    MEDIA_DVD_MOVIE_REGION5,
    MEDIA_DVD_MOVIE_REGION6,
    MEDIA_CD_AUDIO,
    MEDIA_MAX
};

// Video Output types
enum VideoTypes
{
    VIDEO_TV_43NORMAL,
    VIDEO_TV_43WIDESCREEN,
    VIDEO_TV_HDTV,
    VIDEO_MAX
};

// Audio Output types
enum AudioTypes
{
    AUDIO_NORMAL,
    AUDIO_PCM,
    AUDIO_RAW,
    AUDIO_MAX
};

// Network Connection State
enum NetworkCableState
{
    NETWORK_CABLE_UNPLUGGED,
    NETWORK_CABLE_ATTACHED,
    NETWORK_MAX
};

// Describes the ports on the available devices (if any)
struct Device
{
    int slots[4];
    Device(int a=DEVICE_EMPTY, int b=DEVICE_EMPTY, int c=DEVICE_EMPTY, int d=DEVICE_EMPTY) { slots[0] = a; slots[1] = b; slots[2] = c; slots[3] = d; };
};

struct XBOXPorts
{
    Device ports[4];
    XBOXPorts(Device a=DEVICE_EMPTY, Device b=DEVICE_EMPTY, Device c=DEVICE_EMPTY, Device d=DEVICE_EMPTY) { ports[0] = a; ports[1] = b; ports[2] = c; ports[3] = d; };
};


struct environment
{
    enum EnvironmentDesc description;
    int trayState;
    XBOXPorts PortConfig;
    int mediaType;
    int videoType;
    int audioType;
    int networkCable;
};

static XBOXPorts XboxPortConfigs[] =
{
    // No MU's installed
    XBOXPorts( Device(DEVICE_EMPTY), Device(DEVICE_EMPTY), Device(DEVICE_EMPTY), Device(DEVICE_EMPTY) ),
    XBOXPorts( Device(DEVICE_DUKE),  Device(DEVICE_EMPTY), Device(DEVICE_EMPTY), Device(DEVICE_EMPTY) ),
    XBOXPorts( Device(DEVICE_EMPTY), Device(DEVICE_DUKE),  Device(DEVICE_EMPTY), Device(DEVICE_EMPTY) ),
    XBOXPorts( Device(DEVICE_EMPTY), Device(DEVICE_EMPTY), Device(DEVICE_DUKE),  Device(DEVICE_EMPTY) ),
    XBOXPorts( Device(DEVICE_EMPTY), Device(DEVICE_EMPTY), Device(DEVICE_EMPTY), Device(DEVICE_DUKE)  ),
    XBOXPorts( Device(DEVICE_DUKE),  Device(DEVICE_DUKE),  Device(DEVICE_EMPTY), Device(DEVICE_EMPTY) ),
    XBOXPorts( Device(DEVICE_DUKE),  Device(DEVICE_EMPTY), Device(DEVICE_DUKE),  Device(DEVICE_EMPTY) ),
    XBOXPorts( Device(DEVICE_DUKE),  Device(DEVICE_EMPTY), Device(DEVICE_EMPTY), Device(DEVICE_DUKE)  ),
    XBOXPorts( Device(DEVICE_EMPTY), Device(DEVICE_DUKE),  Device(DEVICE_DUKE),  Device(DEVICE_EMPTY) ),
    XBOXPorts( Device(DEVICE_EMPTY), Device(DEVICE_DUKE),  Device(DEVICE_EMPTY), Device(DEVICE_DUKE)  ),
    XBOXPorts( Device(DEVICE_EMPTY), Device(DEVICE_EMPTY), Device(DEVICE_DUKE),  Device(DEVICE_DUKE)  ),
    XBOXPorts( Device(DEVICE_EMPTY), Device(DEVICE_DUKE),  Device(DEVICE_DUKE),  Device(DEVICE_DUKE)  ),
    XBOXPorts( Device(DEVICE_DUKE),  Device(DEVICE_EMPTY), Device(DEVICE_DUKE),  Device(DEVICE_DUKE)  ),
    XBOXPorts( Device(DEVICE_DUKE),  Device(DEVICE_DUKE),  Device(DEVICE_EMPTY), Device(DEVICE_DUKE)  ),
    XBOXPorts( Device(DEVICE_DUKE),  Device(DEVICE_DUKE),  Device(DEVICE_DUKE),  Device(DEVICE_EMPTY) ),

    // Single MU's installed
    XBOXPorts( Device(DEVICE_DUKE, DEVICE_MU),  Device(DEVICE_EMPTY),            Device(DEVICE_EMPTY),            Device(DEVICE_EMPTY)           ),
    XBOXPorts( Device(DEVICE_EMPTY),            Device(DEVICE_DUKE, DEVICE_MU),  Device(DEVICE_EMPTY),            Device(DEVICE_EMPTY)           ),
    XBOXPorts( Device(DEVICE_EMPTY),            Device(DEVICE_EMPTY),            Device(DEVICE_DUKE, DEVICE_MU),  Device(DEVICE_EMPTY)           ),
    XBOXPorts( Device(DEVICE_EMPTY),            Device(DEVICE_EMPTY),            Device(DEVICE_EMPTY),            Device(DEVICE_DUKE, DEVICE_MU) ),
    XBOXPorts( Device(DEVICE_DUKE, DEVICE_MU, DEVICE_EMPTY),  Device(DEVICE_DUKE, DEVICE_MU, DEVICE_EMPTY),  Device(DEVICE_DUKE, DEVICE_MU, DEVICE_EMPTY),  Device(DEVICE_DUKE, DEVICE_MU, DEVICE_EMPTY) ),
    XBOXPorts( Device(DEVICE_DUKE, DEVICE_EMPTY, DEVICE_MU),  Device(DEVICE_DUKE, DEVICE_EMPTY, DEVICE_MU),  Device(DEVICE_DUKE, DEVICE_EMPTY, DEVICE_MU),  Device(DEVICE_DUKE, DEVICE_EMPTY, DEVICE_MU) ),

    // Multiple MU's installed
    XBOXPorts( Device(DEVICE_DUKE, DEVICE_MU, DEVICE_MU),  Device(DEVICE_DUKE, DEVICE_MU, DEVICE_MU),  Device(DEVICE_DUKE, DEVICE_MU, DEVICE_MU),  Device(DEVICE_DUKE, DEVICE_MU, DEVICE_MU) ),
    XBOXPorts( Device(DEVICE_DUKE, DEVICE_MU, DEVICE_MU),  Device(DEVICE_EMPTY),                       Device(DEVICE_EMPTY),                       Device(DEVICE_EMPTY)                      ),
    XBOXPorts( Device(DEVICE_EMPTY),                       Device(DEVICE_DUKE, DEVICE_MU, DEVICE_MU),  Device(DEVICE_EMPTY),                       Device(DEVICE_EMPTY)                      ),
    XBOXPorts( Device(DEVICE_EMPTY),                       Device(DEVICE_EMPTY),                       Device(DEVICE_DUKE, DEVICE_MU, DEVICE_MU),  Device(DEVICE_EMPTY)                      ),
    XBOXPorts( Device(DEVICE_EMPTY),                       Device(DEVICE_EMPTY),                       Device(DEVICE_EMPTY),                       Device(DEVICE_DUKE, DEVICE_MU, DEVICE_MU) ),
};

// Describes the various hardware ports on the XBox
// and it's controllers
static const int gc_nNUM_XBOX_PORTS = 4;
static const int gc_nNUM_DUKE_SLOTS = 2;


// Used to reference specific duke and mu configurations for a port.
// If the Duke and MU array changes, you *MUST* update this list
enum PortConfigurationsWithinList
{
    EMPTY,
    DUKE_E_E,
    DUKE_M_E,
    DUKE_E_M,
    DUKE_M_M
};


// Valid Duke and MU configurations for a Port on the XBox
// If you change this list, you *MUST* update the ENUM list!!
static const WCHAR *validDukeAndMUConfigs[] = {
    L"Empty",
    L"Duke (E, E)",
    L"Duke (M, E)",
    L"Duke (E, M)",
    L"Duke (M, M)"
};

// Used to reference specific memory areas from our array of all memory areas
// If the Memory Area array changes, you *MUST* update this list
enum MemoryAreasWithinList
{
    MEMORY_AREA_MU1_DUKE1,
    MEMORY_AREA_MU2_DUKE1,
    MEMORY_AREA_MU1_DUKE2,
    MEMORY_AREA_MU2_DUKE2,
    MEMORY_AREA_MU1_DUKE3,
    MEMORY_AREA_MU2_DUKE3,
    MEMORY_AREA_MU1_DUKE4,
    MEMORY_AREA_MU2_DUKE4,
    MEMORY_AREA_XDISK
};

// Memory Area's available on the XBox
// If you change this list, you *MUST* update
// the ENUM list!!
static const WCHAR* gc_lpwszMEM_AREAS[] = {
    L"MU 1 in Duke 1",
    L"MU 2 in Duke 1",
    L"MU 1 in Duke 2",
    L"MU 2 in Duke 2",
    L"MU 1 in Duke 3",
    L"MU 2 in Duke 3",
    L"MU 1 in Duke 4",
    L"MU 2 in Duke 4",
    L"Xdisk"
};


// Used to reference specific memory area block configurations
// from our array of all memory area block configurations.
// If the Memory Area block configuration array changes, you *MUST* update this list
enum MemoryAreaBlockConfigsWithinList
{
    MEMORY_BLOCK_CONFIG_0_BLOCKS,
    MEMORY_BLOCK_CONFIG_1_BLOCK,
    MEMORY_BLOCK_CONFIG_HALF_BLOCKS,
    MEMORY_BLOCK_CONFIG_MAX_MINUS_1_BLOCKS,
    MEMORY_BLOCK_CONFIG_MAX__BLOCKS,
    MEMORY_BLOCK_CONFIG_MAX_PLUS_1_BLOCKS
};

// Memory Area standard block configurations
// If this list changes, you *MUST* update the enum list
static const WCHAR* gc_lpwszMEM_AREA_BLOCK_CONFIGS[] = {
    L"0 blocks used",
    L"1 block used",
    L"1/2 of MAX blocks used",
    L"MAX - 1 blocks used",
    L"MAX blocks used",
    L"MAX + 1 blocks used"
};

// Memory Area standard saved game configurations
static const WCHAR* gc_lpwszMEM_AREA_SAVEGAME_CONFIGS[] = {
    L"Empty",
    L"MAX Titles with 1 saved game, 1 block per saved game",
    L"MAX Titles with 10 saved games, 1 block per saved game",
    L"1 Title with MAX saved games, 1 block per saved game",
    L"2 Titles with MAX saved games, 1 block per saved game, each title uses 1/2 available space"
};


// List of saved game combinations for Single Saved game cases
static const WCHAR* gc_lpwszSINGLE_SAVED_GAME_CONFIGS[] = {
    L"1 Title (MAX saved games) - FIRST saved game",
    L"1 Title (MAX saved games) - MIDDLE saved game",
    L"1 Title (MAX saved games) - LAST saved game",
    L"2 Titles (1 saved game each) - Title 1's saved game",
    L"2 Titles (1 saved game each) - Title 2's saved game",
    L"2 Titles (Title 1 has 2 saved games, Title 2 has 1 saved game) - Title 1's FIRST saved game",
    L"2 Titles (Title 1 has 2 saved games, Title 2 has 1 saved game) - Title 1's LAST saved game",
    L"2 Titles (Title 1 has 1 saved game, Title 2 has 2 saved games) - Title 2's FIRST saved game",
    L"2 Titles (Title 1 has 1 saved game, Title 2 has 2 saved games) - Title 2's LAST saved game"
};

// List of saved game combinations for Multiple Saved game cases
static const WCHAR* gc_lpwszMULTIPLE_SAVED_GAME_CONFIGS[] = {
    L"1 Title (MAX saved games) - ALL saved games",
    L"1 Title (MAX saved games) - FIRST 5 saved games",
    L"1 Title (MAX saved games) - MIDDLE 5 saved games",
    L"1 Title (MAX saved games) - LAST 5 saved games",
    L"2 Titles (Title 1 has 10 saved games, Title 2 has 1 saved game) - ALL Title 1's saved games",
    L"2 Titles (Title 1 has 10 saved games, Title 2 has 1 saved game) - Title 1's FIRST 5 saved games",
    L"2 Titles (Title 1 has 10 saved games, Title 2 has 1 saved game) - Title 1's LAST 5 saved games",
    L"2 Titles (Title 1 has 1 saved game, Title 2 has 10 saved games) - ALL Title 2's saved games",
    L"2 Titles (Title 1 has 1 saved game, Title 2 has 10 saved games) - Title 2's FIRST 5 saved games",
    L"2 Titles (Title 1 has 1 saved game, Title 2 has 10 saved games) - Title 2's LAST 5 saved games"
};


// Used to reference specific title delete variations within the array
// If you change the array, you *MUST* update this list
enum DeleteTitleGameConfigsWithinList
{
    DELETE_1_TITLE_1_SAVED_GAME,
    DELETE_1_TITLE_MAX_SAVED_GAMES,
    DELETE_1_TITLE_MAX_PLUS_1_SAVED_GAMES,
    DELETE_2_TITLES_TITLE1_1_SAVED_GAME_TITLE2_1_SAVED_GAME_SELECT_TITLE1,
    DELETE_2_TITLES_TITLE1_1_SAVED_GAME_TITLE2_1_SAVED_GAME_SELECT_TITLE2,
    DELETE_2_TITLES_TITLE1_HALF_MAX_SAVED_GAMES_TITLE2_HALF_MAX_SAVED_GAMES_SELECT_TITLE1,
    DELETE_2_TITLES_TITLE1_1_SAVED_GAME_TITLE2_MAX_SAVED_GAMES_SELECT_TITLE1,
    DELETE_2_TITLES_TITLE1_MAX_SAVED_GAMES_TITLE2_1_SAVED_GAME_SELECT_TITLE2,
    DELETE_3_TITLES_TITLE1_1_SAVED_GAME_TITLE2_1_SAVED_GAME_TITLE3_1_SAVED_GAME_SELECT_TITLE2,
};

// List of Title and saved game combinations to be removed entirely from the XBox
// If you change this list you *MUST* update the ENUM list
static const WCHAR* gc_lpwszDELETE_TITLE_SAVED_GAME_CONFIGS[] = {
    L"1 Title (1 saved game)",
    L"1 Title (MAX saved games)",
    L"1 Title (MAX +1 saved games)",
    L"2 Titles (Title 1 has 1 saved game, Title 2 has 1 saved game) - Select Title 1",
    L"2 Titles (Title 1 has 1 saved game, Title 2 has 1 saved game) - Select Title 2",
    L"2 Titles (Title 1 has 1/2 MAX saved games, Title 2 has 1/2 MAX saved games) - Select Title 1",
    L"2 Titles (Title 1 has 1/2 MAX saved games, Title 2 has 1/2 MAX saved games) - Select Title 2",
    L"2 Titles (Title 1 has 1 saved game, Title 2 has MAX saved games) - Select Title 1",
    L"2 Titles (Title 1 has MAX saved games, Title 2 has 1 saved game) - Select Title 2",
    L"3 Titles (Title 1 has 1 saved game, Title 2 has 1 saved game, Title 3 has 1 saved game) - Select Title 2"
};


// Used to reference specific 'generic' saved games our array of 'generic' saved games
// If the 'generic' saved games array changes, you *MUST* update this list
enum SavedGamesGenericWithinList
{
    SAVED_GAMES_SINGLE,
    SAVED_GAMES_MULTIPLE,
    SAVED_GAMES_ALL
};

// Generic saved game configurations to be used in none-game specific tests
// If this list changes, you *MUST* update the ENUM list
static const WCHAR* gc_lpwszGENERIC_SAVED_GAME_CONFIGS[] = {
    L"1 saved game",
    L"Multiple saved games",
    L"All saved games"
};


// List of saved game actions to be performed for HW and other generic tests
static const WCHAR* gc_lpwszSAVED_GAME_ACTIONS[] = {
    L"Delete",
    L"Copy"
};


// Variations of names that Titles and Saved Games can have
static const WCHAR* gc_lpwszGAME_AND_TITLE_NAMES[] = {
    L"MAX Chars, uppercase, identical",
    L"MAX Chars, lowercase, identical",
    L"MAX Chars, mixed case, identical",
    L"MAX Chars, uppercase, last char different (A - Z)",
    L"MAX Chars, lowercase, last char different (a - z)",
    L"MAX Chars, mixed case, last char different (A - z)",
    L"MAX Chars, one has 'special' char as it's first char, the rest are MAX chars, mixed letters",
    L"MAX Chars, mixed case, identical except one has 'special' char as it's last char"
};

// SAVED GAME META: Variations in the name of a saved game
static const WCHAR* gc_lpwszMETA_SAVED_GAME_NAME_CONFIGS[] = {
    L"0 characters (saved game name missing)",
    L"1 character",
    L"MAX - 1 characters",
    L"MAX characters",
    L"MAX + 1 characters"
};

// SAVED GAME META: Variations in the name of the game that a saved game is from
static const WCHAR* gc_lpwszMETA_SAVED_GAME_PARENT_NAME_CONFIGS[] = {
    L"0 characters (parent game name missing)",
    L"1 character",
    L"MAX - 1 characters",
    L"MAX characters",
    L"MAX + 1 characters"
};

// SAVED GAME META: Variations in the size of the saved game
static const WCHAR* gc_lpwszMETA_SAVED_GAME_SIZE_CONFIGS[] = {
    L"Size missing (not in meta data)",
    L"0 blocks",
    L"1 block",
    L"MAX - 1 blocks",
    L"MAX blocks",
    L"MAX + 1 blocks"
};

// SAVED GAME META: Variations in the time that a game was saved
static const WCHAR* gc_lpwszMETA_SAVED_GAME_TIME_CONFIGS[] = {
    L"Time missing (not in meta data)",
    L"12:00am",
    L"12:00pm"
};

// SAVED GAME META: Variations in the images representing a saved game
static const WCHAR* gc_lpwszMETA_SAVED_GAME_IMAGE_CONFIGS[] = {
    L"Image missing (not in meta data)",
    L"Image normal size",
    L"Image to small",
    L"Image to large"
};

////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////// SETTINGS ///////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

// Used to reference specific dates and times from the clock start and end
// range list.
// If the list array changes, you *MUST* update this list
enum ClockValidDataWithinList
{
    SETTINGS_AREA_CLOCK_START_RANGE,
    SETTINGS_AREA_CLOCK_LEAP_DATE,
    SETTINGS_AREA_CLOCK_NON_LEAP_DATE,
    SETTINGS_AREA_CLOCK_END_RANGE
};


// Clock valid data and end range
static const WCHAR* gc_lpwszCLOCK_VALID_DATA[] = {
    L"Month, Day, Year, XX:XX:XX",
    L"Feb, 29, 2004, 12:00:00",
    L"Feb, 28, 2001, 12:00:00",
    L"Month, Day, Year, XX:XX:XX"
};


// The list of regions / countries that we will ship
// an XBox to that has specific (different) configurations
static const WCHAR* gc_lpwszXBOX_NATIVE_REGIONS[] = {
    L"North America",
    L"Japan"
};

// The list of languages that the XBox default title supports
static const WCHAR* gc_lpwszXBOX_DT_LANGUAGES[] = {
    L"English",
    L"Japanese",
    L"German",
    L"French",
    L"Spanish",
    L"Italian"
};


// Used to reference specific video settings from the video settings list.
// If the list array changes, you *MUST* update this list
enum VideoSettingsWithinList
{
    SETTINGS_VIDEO_NORMAL,
    SETTINGS_VIDEO_DEFAULT = 0, // The setting that a fresh XBox defaults to
    SETTINGS_VIDEO_LETTERBOX,
    SETTINGS_VIDEO_WIDESCREEN
};

// The list of valid video settings in the XDash
// If this list changes, you *MUST* update the enum list
static const WCHAR* gc_lpwszXBOX_DT_VIDEO_OPTIONS[] = {
    L"Normal",
    L"Letterbox",
    L"Widescreen"
};


// Used to reference specific audio settings from the audio settings list.
// If the list array changes, you *MUST* update this list
enum AudioSettingsWithinList
{
    SETTINGS_AUDIO_STEREO,
    SETTINGS_AUDIO_DEFAULT = 0, // The setting that a fresh XBox defaults to
    SETTINGS_AUDIO_MONO,
    SETTINGS_AUDIO_ANALOG,
    SETTINGS_AUDIO_DIGITAL
};

// The list of valid video settings in the XDash
// If this list changes, you *MUST* update the enum list
static const WCHAR* gc_lpwszXBOX_DT_AUDIO_OPTIONS[] = {
    L"Stereo",
    L"Mono",
    L"Analog",
    L"Digital"
};


// Used to reference specific video settings from the video settings list.
// If the list array changes, you *MUST* update this list
enum AVPacksWithinList
{
    AVPACK_NONE,
    AVPACK_NORMAL,
    AVPACK_DIGITAL
};

// The list of valid A/V packs the XBox supports
// If this list changes, you *MUST* update the enum list
static const WCHAR* gc_lpwszXBOX_AV_PACKS[] = {
    L"None",
    L"Normal",
    L"Digital"
};


// Tray            : Open / Closed
// Ports           : Device Installed / What's in the device
// Media Type      : None, XBox Game, Audio CD, etc
// Video Output    : 4:3Normal, HDTV, etc.
// Audio Output    : Normal, PCM, Dolby Digital
// Network Cable   : Plugged in / Not plugged in


#endif // _ENVIRONMENTS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\inc\commontest.h ===
#ifndef _commontest_h
#define _commontest_h

/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    commontest.h

Abstract:



Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created
    09-27-2000  Modified  jnh
*/

extern "C"
{
    ULONG DebugPrint(PCHAR Format, ...);
}

#include <xlog.h>
#include "utils.h"

#define CACHE_DRIVE         L"Z"
#define TITLE_DRIVE         L"T"
#define USER_DRIVE          L"U"
#define BASE_DRIVE          CACHE_DRIVE

static char* GetExceptionString(DWORD dwCode);
static void TESTPASS(HANDLE hLog, char *fmt, ...);
static void TESTFAIL(HANDLE hLog, char *fmt, ...);
static DWORD ExceptionHandler(HANDLE hLog, LPEXCEPTION_POINTERS exceptionInfo);
static void StartTest(HANDLE hLog, WCHAR *variant);
static void StartTest(HANDLE hLog, char *variant);

#define ADDSTEP(step)       wcscat(steps, step); wcscat(steps, L"\n")
#define ADDSTEPNOCR(step)   wcscat(steps, step)
#define TESTCASE(variant)   StartTest(hLog, variant); SetLastError(0); __try { do
#define ENDTESTCASE         while(0); } __except(ExceptionHandler(hLog, GetExceptionInformation())) {  } xEndVariation(hLog);
#define ENDTESTCASE_CLEAN(c)while(0); } __except(ExceptionHandler(hLog, GetExceptionInformation())) {  } c xEndVariation(hLog);
#define BLOCKED(bugid, msg) xLog(hLog, XLL_BLOCK, "BugID %d - %s", bugid, msg); break;
#define BUGGED(bugid, msg)  xLog(hLog, XLL_FAIL, "BugID %d - %s", bugid, msg); break;
#define BUGGEDPASS(bugid, msg)  xLog(hLog, XLL_PASS, "BugID %d - %s", bugid, msg); break;

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define NEWSIZE(ptr)        ( ((unsigned int*)(ptr))[-4] )

static void TESTPASS(HANDLE hLog, char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    xLog_va(hLog, XLL_PASS, fmt, args);
}

static void TESTFAIL(HANDLE hLog, char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    xLog_va(hLog, XLL_FAIL, fmt, args);
}

static void TESTMNUL(HANDLE hLog, char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    xLog_va(hLog, XLL_INFO, fmt, args);
}

static DWORD ExceptionHandler(HANDLE hLog, LPEXCEPTION_POINTERS exceptionInfo)
{
    if(exceptionInfo->ExceptionRecord->ExceptionCode == 0xCAFEBEEF) return EXCEPTION_EXECUTE_HANDLER;

    xLog(hLog, XLL_EXCEPTION, "Code: 0x%08X %s (Exception Pointer: 0x%08X)", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    DebugPrint("  Exception Caught - Code: 0x%08X %s (Exception Pointer: 0x%08X)\n", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    return EXCEPTION_EXECUTE_HANDLER;
}

static void StartTest(HANDLE hLog, char *variant)
{
    xStartVariation(hLog, variant);
}

static void StartTest(HANDLE hLog, WCHAR *variant)
{
    // UNICODE to ANSI hack
    size_t len = wcslen(variant);
    char *aVar = new char[len+1];
    if(!aVar) return;

    for(size_t i=0; i<len+1; i++)
    {
        aVar[i] = (char)variant[i];
    }

    xStartVariation(hLog, aVar);

    delete[] aVar;
}

static char* GetExceptionString(DWORD dwCode)
{
    #define EXCEPTION( x ) case EXCEPTION_##x: return #x;

    static char szBuffer[512] = { 0 };

    switch(dwCode)
    {
        EXCEPTION( ACCESS_VIOLATION )
        EXCEPTION( DATATYPE_MISALIGNMENT )
        EXCEPTION( BREAKPOINT )
        EXCEPTION( SINGLE_STEP )
        EXCEPTION( ARRAY_BOUNDS_EXCEEDED )
        EXCEPTION( FLT_DENORMAL_OPERAND )
        EXCEPTION( FLT_DIVIDE_BY_ZERO )
        EXCEPTION( FLT_INEXACT_RESULT )
        EXCEPTION( FLT_INVALID_OPERATION )
        EXCEPTION( FLT_OVERFLOW )
        EXCEPTION( FLT_STACK_CHECK )
        EXCEPTION( FLT_UNDERFLOW )
        EXCEPTION( INT_DIVIDE_BY_ZERO )
        EXCEPTION( INT_OVERFLOW )
        EXCEPTION( PRIV_INSTRUCTION )
        EXCEPTION( IN_PAGE_ERROR )
        EXCEPTION( ILLEGAL_INSTRUCTION )
        EXCEPTION( NONCONTINUABLE_EXCEPTION )
        EXCEPTION( STACK_OVERFLOW )
        EXCEPTION( INVALID_DISPOSITION )
        EXCEPTION( GUARD_PAGE )
        EXCEPTION( INVALID_HANDLE )

        default:
            break;
    }

    sprintf(szBuffer, "Unknown Error");

    return szBuffer;
}

#define ALLCHARS L"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f" \
    L"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x00"


// Device Port Count
#define DEVICE_PORT_COUNT 4

// sizes
#define KILOBYTE 1024
#define MEGABYTE (KILOBYTE*KILOBYTE)
#define PAGESIZE (4*KILOBYTE)

// common numbers
static DWORD dwBogus = 0xF000BAAA;
static ULARGE_INTEGER ulBogus = { 0xF000BAAA, 0xF000BAAA };

// common HANDLE parameters
static HANDLE hNull = NULL;
static HANDLE hBogus = (void*)0xF000BAAA;

// common string parameters
static LPCTSTR lpNull = NULL;
static LPCTSTR lpEmpty = L"";
static LPCTSTR lpSpace = L" ";
static LPCTSTR lpBogus = (const unsigned short*)0xF000BAAA;
static LPCTSTR lpCurrentDir = L".";
static LPCTSTR lpParentDir = L"..";
static LPCTSTR lpUnderMaxPathDir = BASE_DRIVE L":\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory";
static LPCTSTR lpOverMaxPathDir = BASE_DRIVE L":\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory\\directory";

// device names
static WCHAR *deviceNames[] = {
    BASE_DRIVE L":\\prn",
    BASE_DRIVE L":\\aux",
    BASE_DRIVE L":\\con",
    BASE_DRIVE L":\\lpt1",
    L"\\\\?\\prn",
    L"\\\\?\\aux",
    L"\\\\?\\con",
    L"\\\\?\\lpt1",
    L"\\\\lpt1",
    L"CONOUT$",
    L"CONIN$",
    };

// invalid file names
static WCHAR *invalidFileNames[] = {
    BASE_DRIVE L":\\abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd",
    BASE_DRIVE L":\\)#+l+RI+Td<\x12>",
    BASE_DRIVE L":\\~`!@#$%^&*()-=_+[]{}\\|';:\",./?><",
    BASE_DRIVE L":\\*",
    BASE_DRIVE L":\\?",
    BASE_DRIVE L":\\" ALLCHARS,
    BASE_DRIVE L":\\abc?",
    BASE_DRIVE L":\\abc>def",
    BASE_DRIVE L":\\abc<def",
    BASE_DRIVE L":\\abc|def",
    BASE_DRIVE L":\\abc:def",
    BASE_DRIVE L":\\abc\"def",
    BASE_DRIVE L":\\>",
    BASE_DRIVE L":\\<",
    BASE_DRIVE L":\\:",
    BASE_DRIVE L":\\|",
    BASE_DRIVE L":\\\"",
    BASE_DRIVE L":\\..\\abcdef",
    BASE_DRIVE L":\\.\\..\\abcdef",
    BASE_DRIVE L":\\..\\..\\..\\..\\..\\..\\..\\..\\..\\abcdef",
    BASE_DRIVE L":\\abc" BASE_DRIVE L":\\def",
    BASE_DRIVE L":\\new\nline",
    BASE_DRIVE L":\\newline\n",
    BASE_DRIVE L":\\Carriage\rreturn",
    BASE_DRIVE L":\\Carriagereturn\r",
    BASE_DRIVE L":\\\ttab",
    BASE_DRIVE L":\\tab\t",
    BASE_DRIVE L":\\\abell",
    BASE_DRIVE L":\\bell\a",
    BASE_DRIVE BASE_DRIVE L":\\abc",
    BASE_DRIVE L"::\\abc",
    BASE_DRIVE L"abc",
    BASE_DRIVE L".",
    BASE_DRIVE L"..",
    BASE_DRIVE L" ",
    L"\\\\?\\" BASE_DRIVE L":\\)#+l+RI+Td<\x12>",
    L"\\\\?\\" BASE_DRIVE L":\\~`!@#$%^&*()-=_+[]{}\\|';:\",./?><",
    L"\\\\?\\" BASE_DRIVE L":\\*",
    L"\\\\?\\" BASE_DRIVE L":\\?",
    L"\\\\?\\" BASE_DRIVE L":\\" ALLCHARS,
    L"\\\\?\\" BASE_DRIVE L":\\..\\abcdef",
    L"\\\\?\\" BASE_DRIVE L":\\.\\..\\abcdef",
    L"\\\\?\\" BASE_DRIVE L":\\new\nline",
    L"\\\\?\\" BASE_DRIVE L":\\Carriage\rreturn",
    L"\\\\?\\" BASE_DRIVE L":\\\ttab",
    L"\\\\?\\" BASE_DRIVE BASE_DRIVE L":\\abc",
    L"\\\\?\\" BASE_DRIVE L"::\\abc",
    L"\\\\?\\" BASE_DRIVE L":\\\\abc",
    L"\\\\?\\" BASE_DRIVE L"abc",
    L"\\\\?\\abc",
    L"\\\\?\\ ",
    L"\\\\?\\/",
    L"\\\\?\\\\",
    L"\\\\?\\.",
    L"\\\\?\\..",
    L" ",
    L"/",
    L"\\",
    L".",
    L".."
    };

#endif // _commontest_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\games\xdashgames.cpp ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    XDashGames.cpp

Abstract:

    The DLL exports two of the mandatory APIs: StartTest and EndTest.
    TESTINI.INI must be modified correctly so that the
    harness will load and call StartTest/EndTest.

    Please see "x-box test harness.doc" for more information.

Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10/16/2000  Created

*/


#include <xlog.h>
#include "stdafx.h"
#include "XDashGames.h"
#include "tests.h"

namespace xdashgames
{
    static BOOL printSteps = true;

    /*

    Routine Description:


    Arguments:

        HANDLE hLog - to the logging object
        CStepsLog* pStepsLog - Object used to log our test steps

    Return Value:

        DWORD

    */
    DWORD XDashGamesRunAll( HANDLE hLog, CStepsLog* pStepsLog )
    {
        struct APIFUNCT
        {
            APITEST_FUNC f;
            WCHAR *name;
            char *aname;
        };
    
        #define BUILTAPISTRUCT(n) { n , L#n , #n }

        // Define all the API tests
        APIFUNCT testlist[] =
        {
            /*
            */
            BUILTAPISTRUCT( Test1Here )
            /*
            */
        };

        // Run the suite of tests

        // run each test
        for( size_t j = 0; j < ARRAYSIZE( testlist ); j++ )
        {
            xSetFunctionName(hLog, testlist[j].aname);
            DebugPrint( "%s: Entering test = '%ws()'\n", COMPONENT_NAME_A, testlist[j].name );

            // Log the testcase name to our steps log
            pStepsLog->SetCaseName( testlist[j].name );
            testlist[j].f( hLog, pStepsLog );

            // Log the test case (if the user wishes to)
            if ( printSteps )
            {
                pStepsLog->LogTestCase();
            }

            // Clear out the log for our next test
            pStepsLog->ClearTestCase();
        }

        return 0;
    }
}; // namespace

/*

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

*/
VOID WINAPI XDashGamesStartTest( HANDLE hLog )
{
    using namespace xdashgames;

    // test settings
    const int buffLen = 1024;
    
    char* ownerAlias = new char[buffLen];
    char* componentMajor = new char[buffLen];
    char* componentMinor = new char[buffLen];
    char* stepsFileName = new char[buffLen];
    int HTMLLogFormat = 0;

    if( ownerAlias && componentMajor && componentMinor && stepsFileName )
    {
        // Object used to log our steps
        CStepsLog StepsLog;

        // Pull out internal INI file settings
        GetProfileStringA( DLL_NAME_A,   "Owner",           "Owner",          ownerAlias,     buffLen );
        GetProfileStringA( DLL_NAME_A,   "ComponentMajor",  "ComponentMajor", componentMajor, buffLen );
        GetProfileStringA( DLL_NAME_A,   "ComponentMinor",  "ComponentMinor", componentMinor, buffLen );
        GetProfileStringA( DLL_NAME_A,   "StepsFile",       "StepsFile",      stepsFileName,  buffLen );
        printSteps = GetProfileIntA( DLL_NAME_A, "PrintSteps", 0 );
        HTMLLogFormat = GetProfileIntA( DLL_NAME_A, "HTMLStepsLog", 1 );

        // Set the format for our STEPS log file
        StepsLog.SetHTMLLogFormat( HTMLLogFormat );

        xSetOwnerAlias( hLog, ownerAlias );
        xSetComponent( hLog, componentMajor, componentMinor );
        DebugPrint( "%s: **************************************************************\n", COMPONENT_NAME_A );
        DebugPrint( "%s: Entering %sStartTest()\n", COMPONENT_NAME_A, COMPONENT_NAME_A );
        DebugPrint( "%s: Internal INI Settings:\n", COMPONENT_NAME_A );
        DebugPrint( "   Owner           = '%s'\n", ownerAlias );
        DebugPrint( "   Component Major = '%s'\n", componentMajor );
        DebugPrint( "   Component Minor = '%s'\n", componentMinor );

        // Open our Steps Log File
        if (printSteps)
        {
            StepsLog.OpenLog( stepsFileName );
        }

        XDashGamesRunAll( hLog, &StepsLog );

        if ( printSteps )
        {
            // Close our Steps Log File
            StepsLog.CloseLog();
        }

        DebugPrint( "%s: Leaving %sStartTest()\n", COMPONENT_NAME_A, COMPONENT_NAME_A );
        DebugPrint( "%s: **************************************************************\n", COMPONENT_NAME_A );
        xSetOwnerAlias( hLog, NULL );
    }
    else // Memory allocation failed
    {
        DebugPrint( "**ERROR: %sStartTest():Could not allocate memory!!", COMPONENT_NAME_A );
    }

    if( ownerAlias )
    {
        delete[] ownerAlias;
        ownerAlias = NULL;
    }

    if( componentMajor )
    {
        delete[] componentMajor;
        componentMajor = NULL;
    }
    
    if( componentMinor )
    {
        delete[] componentMinor;
        componentMinor = NULL;
    }
    
    if( stepsFileName )
    {
        delete[] componentMinor;
        componentMinor = NULL;
    }
}


/*

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

*/
VOID WINAPI XDashGamesEndTest(void)
{
}


#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( xdashgames )
#pragma data_seg()

BEGIN_EXPORT_TABLE( xdashgames )
    EXPORT_TABLE_ENTRY( "StartTest", XDashGamesStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XDashGamesEndTest )
END_EXPORT_TABLE( xdashgames )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\inc\utils.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    This module contains the helper functions used by the API tests

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/
#include "stdafx.h"
#include "utils.h"

#ifdef  __cplusplus
    extern "C" {
    #include "ntos.h"
    }
#else
    #include "ntos.h"
#endif


/*

Routine Description:

    Checks to see if a file or directory exists

Arguments:

    char *filename - the name of the file or dir to search for

Return Value:

    true if it exists, false if it doesnt

*/
bool FileExists(const char *filename)
    {
    WIN32_FIND_DATAA FindFileData;
    HANDLE hFind;
    bool retval = false;

    hFind = FindFirstFileA(filename, &FindFileData);

    if(hFind != INVALID_HANDLE_VALUE)
        {
        retval = true;
        }
    FindClose(hFind);

    return retval;
    }


/*

Routine Description:

    Checks to see if a file or directory exists

Arguments:

    unsigned short *filename - the name of the file or dir to search for

Return Value:

    true if it exists, false if it doesnt

*/
bool FileExists(const WCHAR *filename)
    {
    WIN32_FIND_DATAW FindFileData;
    HANDLE hFind;
    bool retval = false;

    hFind = FindFirstFileW(filename, &FindFileData);

    if(hFind != INVALID_HANDLE_VALUE)
        {
        retval = true;
        }
    FindClose(hFind);

    return retval;
    }


/*

Routine Description:

    Creates a new file and fills it with x bytes of garbage

Arguments:

    char *filename - the name of the file to create
    DWORD size - how big the file should be

Return Value:

    DWORD actual size of file

*/
DWORD CreateFilledFile(const char *filename, DWORD size /*=16384*/)
    {
    HANDLE file = CreateFileA(filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    size = FillFile(file, size);

    CloseHandle(file);

    return size;
    return size;
    }


/*

Routine Description:

    Creates a new file and fills it with x bytes of garbage

Arguments:

    unsigned short *filename - the name of the file to create
    DWORD size - how big the file should be (defaults to 16k)

Return Value:

    DWORD actual size of file

*/
DWORD CreateFilledFile(const WCHAR *filename, DWORD size /*=16384*/)
    {
    HANDLE file = CreateFileW(filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    size = FillFile(file, size);

    CloseHandle(file);

    return size;
    }


/*

Routine Description:

    Fills an opened file with x bytes of garbage

Arguments:

    HANDLE hFile - handle to opened file
    DWORD size - how big the file should be

Return Value:

    DWORD actual size of file

*/
DWORD FillFile(HANDLE hFile, DWORD size)
    {
    WCHAR *error = NULL;
    char w = 'X';
    DWORD wsize = sizeof(w);
    DWORD errCode = 0;

    do
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            error = L"unable to create/open file";
            errCode = GetLastError();
            break;
            }

        if(size == 0) break;

        if(SetFilePointer(hFile, size-1, NULL, FILE_BEGIN) != size-1)
            {
            error = L"unable to size file";
            errCode = GetLastError();
            break;
            }

        if(WriteFile(hFile, &w, wsize, &wsize, NULL) != TRUE)
            {
            error = L"unable to write last byte";
            errCode = GetLastError();
            break;
            }
        } while(0);

    FlushFileBuffers(hFile);

    if(error)
        {
        DebugPrint("FILEIO: FillFile(%ld) - %ws (ec: %d)\n", size, error, errCode);
        size = 0;
        }

    return size;
    }

/*

Routine Description:

    Opens a file with Read Only access

Arguments:

    char *filename - name of the file to open

Return Value:

    BOOL - returns the result from CreateFile

*/
HANDLE FileOpen(const char *filename)
    {
    return CreateFileA(filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }


/*

Routine Description:

    Opens a file with Read Only access

Arguments:

    unsigned short *filename - name of the file to open

Return Value:

    BOOL - returns the result from CreateFile

*/
HANDLE FileOpen(const WCHAR *filename)
    {
    return CreateFileW(filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }


/*

Routine Description:

    Opens a file with Read Only access

Arguments:

    char *filename - name of the file to open

Return Value:

    BOOL - returns the result from CreateFile

*/
HANDLE FileOpenRW(const char *filename)
    {
    return CreateFileA(filename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }


/*

Routine Description:

    Opens a file with Read Only access

Arguments:

    unsigned short *filename - name of the file to open

Return Value:

    BOOL - returns the result from CreateFile

*/
HANDLE FileOpenRW(const WCHAR *filename)
    {
    return CreateFileW(filename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }


/*

Routine Description:

    Generates a FILETIME structure from the date components by calling 
    SystemTimeToFileTime

Arguments:

    LPFILETIME fileTime - pointer to the FILETIME struct to populate with the date
    WORD year
    WORD month
    WORD day
    WORD hour
    WORD min
    WORD sec
    WORD msec

Return Value:

    BOOL - returns the result from SystemTimeToFileTime

*/
BOOL CreateFileTime(LPFILETIME fileTime, WORD year, WORD month, WORD day, WORD hour, WORD min, WORD sec, WORD msec)
    {
    SYSTEMTIME sysTime;

    sysTime.wYear = year;
    sysTime.wMonth = month;
    sysTime.wDay = day;
    sysTime.wHour = hour;
    sysTime.wMinute = min;
    sysTime.wSecond = sec;
    sysTime.wMilliseconds = msec;

    return SystemTimeToFileTime(&sysTime, fileTime);
    }

/*

Routine Description:


Arguments:

    drive - Drive to fill up, it should be in the form 
        C:\
        D:\
        etc.
    lpFile - This function will populate buffer with the name of the file created

Return Value:

    DWORD return code from GetLastError in the event of a problem

*/
DWORD FillHDPartition(const WCHAR *drive, WCHAR *lpFile)
    {
    if(!drive || !lpFile) return ERROR_INVALID_PARAMETER;

    DWORD error = 0;
    char w = 'X';
    DWORD wsize = sizeof(w);
    LARGE_INTEGER distance;
    LARGE_INTEGER size;
    ULARGE_INTEGER available;
    ULARGE_INTEGER total;
    ULARGE_INTEGER free;

    DebugPrint("FILEIO: Filling HD Partition: %ws...\n", drive);

    wsprintf(lpFile, L"%wsFullHD_%lX.txt", drive, GetCurrentThreadId());

    HANDLE file = CreateFile(lpFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
    if(file == INVALID_HANDLE_VALUE)
        {
        return GetLastError();
        }

    // Get the disk space free
    GetDiskFreeSpaceEx(drive, &available, &total, &free);
    distance.QuadPart = (__int64)available.QuadPart - 256;
    size.QuadPart = 0;

    // Do a test write
    if(WriteFile(file, &w, wsize, &wsize, NULL) != TRUE)
        {
        error = GetLastError();
        CloseHandle(file);
        return error;
        }

    // write as big as a file as possible
    do
        {
        distance.QuadPart -= 256;
        if(SetFilePointerEx(file, distance, &size, FILE_BEGIN) != TRUE)
            {
            error = GetLastError();
            //DebugPrint("SetFilePointerEx (ec: %lu)\n", error);
            }
        else if(size.QuadPart != distance.QuadPart)
            {
            error = 99;
            //DebugPrint("SetFilePointerEx size != dist\n");
            }
        else if(WriteFile(file, &w, wsize, &wsize, NULL) != TRUE)
            {
            error = GetLastError();
            //DebugPrint("WriteFile (ec: %lu)\n", error);
            }
        else
            {
            error = 0;
            }

        } while(error);

    // clean up
    if(FlushFileBuffers(file) != TRUE)
        {
        error = GetLastError();
        //DebugPrint("FlushFileBuffers (ec: %lu)\n", error);
        }
    if(CloseHandle(file) != TRUE)
        {
        error = GetLastError();
        //DebugPrint("CloseHandle (ec: %lu)\n", error);
        }

    DebugPrint("FILEIO: Filled  HD Partition. %ws(%I64d)\n", lpFile, size.QuadPart);

    return error;
    }

/*

Routine Description:

    Writes system resource usage information to the specified log file 
    and/or to the debugger.

    Be sure to include extern "C" { "ntos.h" } to use MmQueryStatistics

    MM_STATISTICS:
        ULONG TotalPhysicalPages;
        ULONG AvailablePages;
        ULONG VirtualMemoryBytesCommitted;
        ULONG VirtualMemoryBytesReserved;
        ULONG CachePagesCommitted;
        ULONG PoolPagesCommitted;
        ULONG StackPagesCommitted;
        ULONG ImagePagesCommitted;

Arguments:

    HANDLE hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs
    bool debugger - true sends memory data to the debugger

Return Value:

    None

*/
void FlushDiskCache(void);

void LogResourceStatus(HANDLE hLog, bool debugger)
    {
    const DWORD pageSize = 4096;
    MM_STATISTICS mmStats;
    PS_STATISTICS psStats;

    // initialize the stat info
    memset(&mmStats, 0, sizeof(MM_STATISTICS));
    mmStats.Length = sizeof(MM_STATISTICS);
    memset(&psStats, 0, sizeof(PS_STATISTICS));
    psStats.Length = sizeof(PS_STATISTICS);

    FlushDiskCache();

    // gather all the data
    MmQueryStatistics(&mmStats);
    PsQueryStatistics(&psStats);

    // display/write the data
    if(hLog)
        {
        xLog(hLog, XLL_INFO, "Memory Status------------------------------------------");
        xLog(hLog, XLL_INFO, "   Total:     %lu", mmStats.TotalPhysicalPages*pageSize);
        xLog(hLog, XLL_INFO, "   Available: %lu", mmStats.AvailablePages*pageSize);
        xLog(hLog, XLL_INFO, "   Cache:     %lu", mmStats.CachePagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Pool:      %lu", mmStats.PoolPagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Stack:     %lu", mmStats.StackPagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Image:     %lu", mmStats.ImagePagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Handles:   %lu", psStats.HandleCount);
        xLog(hLog, XLL_INFO, "Memory Status------------------------------------------");
        }
    if(debugger)
        {
        DebugPrint("MEM: Available=%lu, Cache=%lu, Pool=%lu, Stack=%lu, Image=%lu, Handles=%lu\n", mmStats.AvailablePages*pageSize, mmStats.CachePagesCommitted*pageSize, mmStats.PoolPagesCommitted*pageSize, mmStats.StackPagesCommitted*pageSize, mmStats.ImagePagesCommitted*pageSize, psStats.HandleCount);
        }
    }

void FlushVolume(WCHAR *volume)
    {
    HANDLE hFile = CreateFile(volume, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, NULL);
    if(hFile == INVALID_HANDLE_VALUE)
        DebugPrint("MEM: FlushError: %lu, 0x%x\n", GetLastError(), GetLastError());
    FlushFileBuffers(hFile);
    CloseHandle(hFile);
    }

/*

Routine Description:

    This routine will flush the disk cache

Arguments:

    None

Return Value:

    No return value

*/
void FlushDiskCache(void)
    {
    ULONG Volume, Disk;
    HANDLE Handle;
    NTSTATUS Status;
    WCHAR VolumeBuffer[MAX_PATH];
    UNICODE_STRING VolumeString;
    OBJECT_ATTRIBUTES ObjA;
    IO_STATUS_BLOCK IoStatusBlock;

    for(Disk=0; Disk<2; Disk++)
        {
        for(Volume=1; Volume<4; Volume++)
            {
            swprintf(VolumeBuffer, L"\\Device\\Harddisk%d\\Partition%d", Disk, Volume);

            RtlInitUnicodeString(&VolumeString, VolumeBuffer);

            InitializeObjectAttributes(&ObjA,&VolumeString,OBJ_CASE_INSENSITIVE,NULL,NULL);

            Status = NtCreateFile(&Handle, SYNCHRONIZE|GENERIC_READ, &ObjA, &IoStatusBlock, 0, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);

            if(!NT_SUCCESS(Status)) continue;

            Status = NtFlushBuffersFile(Handle, &IoStatusBlock);
            NtClose(Handle);
            }
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\inc\xdashrootmenu.h ===
#ifndef _XDASHROOTMENU_H_
#define _XDASHROOTMENU_H_

#include <CXDashScreen.H>

class XDashRootMenu : public XDashScreen
{
}

#endif _XDASHROOTMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\inc\xdashcontrol.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    XDashControl.h

Abstract:
    This object can be used to set information about a control that
    lives on a screen within the XDash

Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-16-2000  Created

Notes:

*/
#ifndef _XDASHCONTROL_H_
#define _XDASHCONTROL_H_

#include <xtl.h>

extern "C"
{
        ULONG DebugPrint(PCHAR Format, ...);
}

class CXDashControl
{

public:
    
    // Properties
    char* m_Name;          // The name of the Control
    char* m_Destination;   // The destination of the Control

    // Methods
    CXDashControl();
    CXDashControl( char* controlName, char* controlDestination );
    ~CXDashControl();

    void UpdateControl( char* controlName, char* controlDestination );    // Allows the user to set the name and destination of the current control

    char* GetControlName() { return m_Name; };                             // Returns the name of the control
    char* GetControlDest() { return m_Destination; };                      // Returns the destination of the control
private:

};

#endif // _XDASHCONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\memory\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\memory\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
#define AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_

#if _MSC_VER > 1000
    #pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN         // Exclude rarely-used stuff from Windows headers
#endif

#ifndef UNICODE
    #define _UNICODE
    #define UNICODE
#endif




// Exclude rarely-used stuff from Windows headers
#define NTLEANANDMEAN
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_IA64_) && defined(_M_IX86)
#define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MRX000)
#define _MIPS_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_ALPHA)
#define _ALPHA_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_PPC)
#define _PPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_M68K)
#define _68K_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MPPC)
#define _MPPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_M_IX86) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <stdio.h>
#include <xtl.h>
#include <profilep.h>

#include "stepslog.h"
#include "xdashteststeps.h"
#include "commontest.h"
#include "environments.h"

extern "C"
{
        ULONG DebugPrint(PCHAR Format, ...);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\inc\xdashscreen.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    XDashScreen.h

Abstract:
    This object can be used to set information about a screen that
    lives within the XDash.  The information includes the Name of the
    screen, and the controls that live on that screen

Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-16-2000  Created

Notes:

*/

#ifndef _XDASHSCREEN_H_
#define _XDASHSCREEN_H_

#define NUM_CONTROLS    50

#include <xtl.h>
#include "XDashControl.h"

extern "C"
{
        ULONG DebugPrint(PCHAR Format, ...);
}

class CXDashScreen
{

public:

    // The controls that exist on the screen
    CXDashControl* m_Controls;

    // Methods
    CXDashScreen();                     // Default Constructor
    CXDashScreen( char* screenName );   // Constructor that will allow you to set the screen name
    ~CXDashScreen();                    // Destructor

    size_t GetNumControls() { return m_numControls; };                  // Returns the number of controls the screen contains
    char* GetScreenName() { return m_Name; };                           // Returns a pointer to the name of the screen
    char* GetControlNameByIndex( size_t index );                        // Returns the name of the control with a given index
    char* GetControlDestByIndex( size_t index );                        // Returns the destination of the control with a given index

    void SetScreenName( char* screenName );                             // Sets the name of the current screen
    void AddControl( char* controlName, char* controlDestination );     // Adds a control to the current screen
    
private:
    // Properties
    size_t m_numControls;       // The number of controls that exist on the screen
    char* m_Name;               // The name of the Screen

    // Methods
    void CXDashScreen::PropertyInit();  // Used to initialze member variables (called by our constructors)
};

#endif // _XDASHSCREEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\inc\utils.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    utils.h

Abstract:

    This module contains the helper functions used by the API tests

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/
#ifndef _UTILS_H_
#define _UTILS_H_

#include "stdafx.h"
#include <xlog.h>

extern bool FileExists(const char *filename);
extern bool FileExists(const WCHAR *filename);
extern DWORD FillFile(HANDLE hFile, DWORD size);
extern DWORD CreateFilledFile(const char *filename, DWORD size=16384);
extern DWORD CreateFilledFile(const WCHAR *filename, DWORD size=16384);
extern HANDLE FileOpen(const char *filename);
extern HANDLE FileOpen(const WCHAR *filename);
extern HANDLE FileOpenRW(const char *filename);
extern HANDLE FileOpenRW(const WCHAR *filename);
extern BOOL CreateFileTime(LPFILETIME fileTime, WORD year, WORD month, WORD day, WORD hour, WORD min, WORD sec, WORD msec);
extern DWORD FillHDPartition(const WCHAR *drive, WCHAR *lpFile);
extern void LogResourceStatus(HANDLE hLog, bool debugger);

class iLARGE_INTEGER
    {
    public: 
        __int64 value;

    public:
        iLARGE_INTEGER() { value = 0; }
        iLARGE_INTEGER(int i) { value = i; }
        iLARGE_INTEGER(DWORD i) { value = i; }
        iLARGE_INTEGER(__int64 i) { value = i; }
        iLARGE_INTEGER(const LARGE_INTEGER &i) { value = i.QuadPart; }

        operator int() {  return (int)value; }
        operator DWORD() {  return (DWORD)value; }
        operator __int64() {  return value; }
        operator LARGE_INTEGER() {  LARGE_INTEGER a; a.QuadPart=value; return a; }
    };

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\movies\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\movies\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
#define AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_

#if _MSC_VER > 1000
    #pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN         // Exclude rarely-used stuff from Windows headers
#endif

#ifndef UNICODE
    #define _UNICODE
    #define UNICODE
#endif

// Exclude rarely-used stuff from Windows headers
#define NTLEANANDMEAN
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_IA64_) && defined(_M_IX86)
#define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MRX000)
#define _MIPS_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_ALPHA)
#define _ALPHA_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_PPC)
#define _PPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_M68K)
#define _68K_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MPPC)
#define _MPPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_M_IX86) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <stdio.h>
#include <xtl.h>
#include <profilep.h>

#include "stepslog.h"
#include "xdashteststeps.h"
#include "commontest.h"
#include "environments.h"

extern "C"
{
        ULONG DebugPrint(PCHAR Format, ...);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\inc\xdashscreenlist.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    XDashScreenList.h

Abstract:
    This object can be used to hold a list of screens.  a screen consists
    of a name, and a list of controls and their destinations.

Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-16-2000  Created

Notes:

*/

#ifndef _XDASHSCREENLIST_H_
#define _XDASHSCREENLIST_H_

#include <xtl.h>
#include <stdio.h>
#include <profilep.h>
#include "xdashscreen.h"

extern "C"
{
    ULONG DebugPrint(PCHAR Format, ...);
}

// Maximum number of screen our object can hold
#define MAX_SCREENS         100

// INI Delimiters
#define NAME_TOKEN            L"Name="
#define NAME_TOKEN_A           "Name="
#define CONTROL_TOKEN         L"Control="
#define CONTROL_TOKEN_A        "Control="
#define CONTROL_DEST_TOKEN    L"ControlDest="
#define CONTROL_DEST_TOKEN_A   "ControlDest="
#define COMMENT_CHAR          L';'
#define COMMENT_CHAR_A         ';'

// Amount of characters in a line from the INI file
#define MAX_LINE_SIZE       255

class CXDashScreenList
{

public:
    // Properties

    // Methods
    CXDashScreenList();                     // Default Constructor
    CXDashScreenList( char* iniFileName );  // Constructor which accepts an INI filename
    ~CXDashScreenList();                    // Destructor

    void GetScreensFromINI( char* iniFileName );                                        // Populates the screen list from an INI file

    void AddScreenToList( char* screenName );                                           // Add a screen to our list
    void AddControlToScreen( char* controlName, char* controlDest );                    // Add a control to our current screen

    size_t GetNumScreens() { return m_numScreens; };                                    // Returns the number of screens currently in our list
    char* GetCurrentScreenName();                                                       // Returns the name of the current screen
    char* GetScreenNameByIndex( size_t index );                                         // Returns the name of a screen at a current index
    char* GetControlNameFromScreenByIndex( size_t screenIndex, size_t controlIndex );   // Returns the name of a control at a given screen and control index
    char* GetControlDestFromScreenByIndex( size_t screenIndex, size_t controlIndex );   // Returns the destination of a control at a given screen and control index
    char* GetControlFromCurrentScreenByIndex( size_t index );                           // Returns a control from the current screen specified by the index
    size_t GetNumControlsOnCurrentScreen();                                             // Returns the number of controls on the current screen
    size_t GetNumControlsOnScreenByIndex( size_t index );                               // Returns the number of controls on the screen specified by the index

private:
    // Properties
    CXDashScreen* m_Screens;    // The Screens and their controls
    size_t m_numScreens;        // The number of screens in our list

    char* GetValueFromINI( char* iniFileName, char* iniSection, char* iniKey, size_t bufferSize );   // Returns a value from an INI file, NULL if there was a problem
    void PropertyInit();                                                                             // Used to initialize our member variables.  (Called by constructors)
    size_t NullCharInString( char* targetString, char charToNull );                                  // Used to NULL specific characters from a string

};

#endif // _XDASHSCREENLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\inc\xdashteststeps.h ===
#ifndef _XDASHTESTSTEPS_H_
#define _XDASHTESTSTEPS_H_

const WCHAR STEP_ACTION_WAIT_FOR_DST[]                         = L"Wait until the DST rollover time has passed";

const WCHAR STEP_NOTE_CONFIG_SETTINGS[]                        = L"Note the various configuration settings: Clock, Language, Video, Audio, and Parental Control";

const WCHAR STEP_INITIATE_ACTION_ACCORD_TO_VAR[]               = L"Initiate the action according to the test variation";

const WCHAR STEP_INSERT_DVD_GAME_MEM_CLEANUP[]                 = L"Insert a disk that will allow you to boot to the XDash Memory Management Clean-Up Mode";
const WCHAR STEP_INSERT_HARDWARE_ACCORD_TO_VAR[]               = L"Insert the hardware according to the test variation";
const WCHAR STEP_INSERT_MEM_UNIT_EMPTY[]                       = L"Insert a Memory Unit that is EMPTY";
const WCHAR STEP_INSERT_MEM_UNIT_FULL[]                        = L"Insert a Memory Unit that is FULL";
const WCHAR STEP_INSERT_MEM_UNIT_1_SAVED_GAME_1_BLOCK[]        = L"Insert a Memory Unit that contains 1 saved game that is 1 block in size";
const WCHAR STEP_INSERT_PLUG_IN_TO_XBOX[]                      = L"Insert the plug in to the XBox console";

const WCHAR STEP_INVOKE_SCREEN_ACCORD_TO_VAR[]                 = L"Invoke the screen according to the test variation";

const WCHAR STEP_REMOVE_AVPACK_FROM_XBOX[]                     = L"Remove the A/V pack from the XBox console";
const WCHAR STEP_REMOVE_BB_PLUG_FROM_XBOX[]                    = L"Remove the broadband plug from the XBox console";
const WCHAR STEP_REMOVE_HARDWARE_ACCORD_TO_VAR[]               = L"Remove the hardware according to the test variation";
const WCHAR STEP_REMOVE_POWER_PLUG_FROM_XBOX[]                 = L"Remove the power plug from the XBox console";

const WCHAR STEP_SKIP_VARS_BASED_ON_DEFAULT_DUKE[]             = L"Skip variations based on the Default Duke/Port";

const WCHAR STEP_PERFORM_FILE_COMPARE_ACCORD_TO_VAR[]          = L"Perform a file compare to ensure the action was a successful according to the test variation";

const WCHAR STEP_PRESS_POWER[]                                 = L"Press Power";
const WCHAR STEP_PRESS_ACCEPT[]                                = L"Press 'A'";
const WCHAR STEP_PRESS_BACK[]	                               = L"Press 'B'";

const WCHAR STEP_TITLE_SHOULD_REQUEST_MAX_MINUS_2_BLOCKS[]     = L"The Title should request MAX - 2 blocks of space needed";
const WCHAR STEP_TITLE_SHOULD_REQUEST_MAXBLOCKS[]              = L"The Title should request MAX blocks of space needed";

const WCHAR STEP_SELECT_AUDIO[]                                = L"Select the 'Audio' menu option";
const WCHAR STEP_SELECT_AUDIO_OPTION_ACCORD_TO_VAR[]           = L"Select the audio option according to the test variation";
const WCHAR STEP_SELECT_AUDIO_OPTION_NEW[]                     = L"Select an audio option that is different from the current option";
const WCHAR STEP_SELECT_AUDIO_OPTION_TO_BE[]                   = L"Select the audio option to be:";
const WCHAR STEP_SELECT_CANCEL[]                               = L"Select the 'Cancel' menu option";
const WCHAR STEP_SELECT_CLOCK[]                                = L"Select the 'Clock' menu option";
const WCHAR STEP_SELECT_CLOCK_EACH_MONTH[]                     = L"Select each month";
const WCHAR STEP_SELECT_CLOCK_INFO_ACCORD_TO_VAR[]             = L"Select the 'Clock' date and time according to the test variation";
const WCHAR STEP_SELECT_CLOCK_LEAP_YEAR[]                      = L"Select the 'Year' to be 2004, or 2008, a leap year";
const WCHAR STEP_SELECT_CLOCK_MONTH_FEB[]                      = L"Select the 'Month' to be 'February'";
const WCHAR STEP_SELECT_CLOCK_NON_LEAP_YEAR[]                  = L"Select the 'Year' to be 2001, a non leap year";
const WCHAR STEP_SELECT_CLOCK_NEW[]                            = L"Select a different date or time";
const WCHAR STEP_SELECT_CONROL_ACCORD_TO_VAR[]                 = L"Select the control according to the test variation";
const WCHAR STEP_SELECT_COPY[]                                 = L"Select the 'Copy' menu option";
const WCHAR STEP_SELECT_COUNTRY_CURRENT[]                      = L"Select the 'Country' information for your current country";
const WCHAR STEP_SELECT_COUNTRY_WITH_DST[]                     = L"Select the 'Country' information for a country that has daylight savings time";
const WCHAR STEP_SELECT_DELETE[]                               = L"Select the 'Delete' menu option";
const WCHAR STEP_SELECT_DEST_MEM_AREA_ACCORD_TO_VAR[]          = L"Select the Memory Area to be copied TO according to the test variation";
const WCHAR STEP_SELECT_DEVICE_ACCORD_TO_VAR[]                 = L"Select the device according to the test variation";
const WCHAR STEP_SELECT_LANGUAGE[]                             = L"Select the 'Language' menu option";
const WCHAR STEP_SELECT_LANGUAGE_ACCORD_TO_VAR[]               = L"Select the language according to the test variation";
const WCHAR STEP_SELECT_LANGUAGE_NEW[]                         = L"Select a language that is different from the current language";
const WCHAR STEP_SELECT_MEM_AREA_BLOCK_CONFIG_ACCORD_TO_VAR[]  = L"Select the Memory Area block configuration according to the test variation";
const WCHAR STEP_SELECT_MEM_AREA_DEFAULT_DUKE[]                = L"Select the Memory Area in the 'default Duke'";
const WCHAR STEP_SELECT_MEM_AREA_EACH_MU[]                     = L"Select each Memory Unit Memory Area";
const WCHAR STEP_SELECT_MEM_AREA_EMPTY[]                       = L"Select the Memory Area that is empty";
const WCHAR STEP_SELECT_MEMORY_MANAGEMENT[]                    = L"Select Memory Management";
const WCHAR STEP_SELECT_SAVED_GAME[]                           = L"Select a saved game";
const WCHAR STEP_SELECT_SAVED_GAME_ACCORD_TO_VAR[]             = L"Select the saved game(s) according to the test variation";
const WCHAR STEP_SELECT_SAVED_GAME_ALL[]                       = L"Select ALL saved games";
const WCHAR STEP_SELECT_SAVED_GAMES_MARKED_BAD[]               = L"Select any saved games that are marked as 'invalid', or 'bad'";
const WCHAR STEP_SELECT_SETTINGS[]                             = L"Select Settings";
const WCHAR STEP_SELECT_SOURCE_MEM_AREA_ACCORD_TO_VAR[]        = L"Select the Memory Area to be copied FROM according to the test variation";
const WCHAR STEP_SELECT_SOURCE_MEM_AREA_XDISK[]                = L"Select the XDisk as the 'SOURCE' Memory Area";
const WCHAR STEP_SELECT_TITLE_ACCORD_TO_VAR[]                  = L"Select the Title (game) according to the test variation";
const WCHAR STEP_SELECT_VIDEO[]                                = L"Select the 'Video' menu option";
const WCHAR STEP_SELECT_VIDEO_ACCORD_TO_VAR[]                  = L"Select the video option according to the test variation";
const WCHAR STEP_SELECT_VIDEO_NEW[]                            = L"Select a video option that is different from the current option";
const WCHAR STEP_SELECT_XZONE[]                                = L"Select XZone";
const WCHAR STEP_SELECT_XZONE_SET_CLOCK[]                      = L"Select the 'Set Clock' option";

const WCHAR STEP_SETUP_XBOX_AVPACK_ACCORD_TO_VAR[]             = L"Setup the XBox to have the A/V pack installed according to the test variation";
const WCHAR STEP_SETUP_XBOX_AVPACK_ANY[]                       = L"Setup the XBox to have an A/V pack installed";
const WCHAR STEP_SETUP_XBOX_AVPACK_NONE[]                      = L"Setup the XBox to have NO A/V packs installed";
const WCHAR STEP_SETUP_XBOX_CLOCK_INCORRECT[]                  = L"Setup the XBox clock to be incorrect according to your current time zone / country";
const WCHAR STEP_SETUP_XBOX_DATE_JUST_BEFORE_DST[]             = L"Setup the XBox clock to be just before DST rollover - 'Month, Day, Year XX:XX:XX'";
const WCHAR STEP_SETUP_XBOX_FACTORY_SETTINGS_GOOD_BATTERY[]    = L"Setup the XBox with Factory Default Settings with a GOOD 20 day battery";
const WCHAR STEP_SETUP_XBOX_FACTORY_SETTINGS_BAD_BATTERY[]     = L"Setup the XBox with Factory Default Settings with an EXPIRED 20 day battery";
const WCHAR STEP_SETUP_XBOX_FROM_REGION_ACCORD_TO_VAR[]        = L"Setup the XBox to be from the region according to the test variation";
const WCHAR STEP_SETUP_XBOX_PORTS_DEVICE_ACCORD_TO_VAR[]       = L"Setup the XBox ports, and devices according to the test variation";
const WCHAR STEP_SETUP_XBOX_PORTS_DUKE_E_E[]                   = L"Setup the available XBox ports with a Duke (E, E)";
const WCHAR STEP_SETUP_XBOX_PORTS_DUKE_M_M[]                   = L"Setup the available XBox ports with a Duke (M, M)";
const WCHAR STEP_SETUP_XDISK_SOME_DATA[]                       = L"Setup the XDisk Memory Area in this test variation with at least 1 saved game";
const WCHAR STEP_SETUP_ALL_MEM_UNITS_FULL[]                    = L"Setup all the memory units used in this test case to be FULL (no space free)";
const WCHAR STEP_SETUP_ALL_MEM_AREAS_EMPTY[]                   = L"Setup all the memory areas used in this test case to be EMPTY (no space used)";
const WCHAR STEP_SETUP_ALL_MEM_AREAS_FULL[]                    = L"Setup all the memory areas used in this test case to be FULL (no space free)";
const WCHAR STEP_SETUP_ALL_MEM_AREAS_SAME_SAVED_GAME[]         = L"Setup all the memory areas with the EXACT SAME saved game.";
const WCHAR STEP_SETUP_MEM_AREA_DEFAULT_DUKE_SOME_DATA[]       = L"Setup the Memory Area in the 'default Duke' with at least 1 saved game";
const WCHAR STEP_SETUP_MEM_AREA_DEFAULT_DUKE_ACCORD_TO_VAR[]   = L"Setup the Memory Area in the 'default Duke' according to the test variation";
const WCHAR STEP_SETUP_MEM_AREA_DEFAULT_DUKE_TWO_SAVED_GAMES[] = L"Setup the Memory Area in the 'default Duke' with at least 2 saved games";
const WCHAR STEP_SETUP_MEM_AREA_IN_VAR_TWO_SAVED_GAMES[]       = L"Setup the Memory Area in the test variation with at least 2 saved games";
const WCHAR STEP_SETUP_MEM_AREA_IN_VAR_MAX_SAVED_GAMES[]       = L"Setup the Memory Area in the test variation with the MAX number of saved games";
const WCHAR STEP_SETUP_MEM_AREA_MAX_SAVED_GAMES_1_BLOCK_EACH[] = L"Setup the Memory Area in the test variation with the MAX number of saved games (1 block each)";
const WCHAR STEP_SETUP_MEM_AREA_EMPTY[]                        = L"Setup the Memory Area in this test variation to be empty (no saved games, etc)";
const WCHAR STEP_SETUP_MEM_AREA_SOME_DATA[]                    = L"Setup the Memory Area in this test variation with at least 1 saved game";
const WCHAR STEP_SETUP_MEM_AREA_ONE_SAVED_GAME[]               = L"Setup the Memory Area in this test variation with ONLY 1 saved game";
const WCHAR STEP_SETUP_MEM_AREA_TWO_SAVED_GAMES[]              = L"Setup the Memory Area in this test variation with ONLY 2 saved games";
const WCHAR STEP_SETUP_MEM_AREA_ACCORD_TO_VAR[]                = L"Setup the Memory Area in this test according to the test variation";
const WCHAR STEP_SETUP_MEM_AREA_TITLES_ACCORD_TO_VAR[]         = L"Setup the Memory Area, both with TITLES according to the test variation";
const WCHAR STEP_SETUP_MEM_AREA_GAMES_ACCORD_TO_VAR[]          = L"Setup the Memory Area, both with GAMES according to the test variation";
const WCHAR STEP_SETUP_SOURCE_MEM_AREA_ACCORD_TO_VAR[]         = L"Setup the 'SOURCE' Memory Area in this test according to the test variation";
const WCHAR STEP_SETUP_DEST_MEM_AREA_ENOUGH_SPACE[]            = L"Setup the 'DESTINATION' Memory Area in this test to be empty, or to contain enough space for the test variation";
const WCHAR STEP_SETUP_DEST_MEM_AREA_NOT_ENOUGH_SPACE[]        = L"Setup the 'DESTINATION' Memory Area in this test to be full, or to NOT contain enough space for the test variation";

const WCHAR STEP_VERIFY_DEST_MEMORY_DEVICE_SCREEN[]            = L"Verify you are at the 'DESTINATION' Memory Area screen";
const WCHAR STEP_VERIFY_GAME_DELETE_DIALOG[]                   = L"Verify that the delete SAVED GAME verification dialog appears";
const WCHAR STEP_VERIFY_GAME_OPTIONS_DIALOG[]                  = L"Verify that the game options dialog appears";
const WCHAR STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN[]             = L"Verify you are at the Memory Management screen";
const WCHAR STEP_VERIFY_MEMORY_DEVICE_SCREEN[]                 = L"Verify you are at the Memory Area screen";
const WCHAR STEP_VERIFY_ROOT_MENU_SCREEN[]                     = L"Verify you are at the Default Title Root Menu";
const WCHAR STEP_VERIFY_SAVED_GAME_COPY_SCREEN[]               = L"Verify you are at the Saved Game Copy screen";
const WCHAR STEP_VERIFY_SETTINGS_AUDIO_SCREEN[]                = L"Verify you are at the Settings 'Audio' screen";
const WCHAR STEP_VERIFY_SETTINGS_CLOCK_SCREEN[]                = L"Verify you are at the Settings 'Clock' screen";
const WCHAR STEP_VERIFY_SETTINGS_LANGUAGE_SCREEN[]             = L"Verify you are at the Settings 'Language' screen";
const WCHAR STEP_VERIFY_SETTINGS_SCREEN[]                      = L"Verify you are at the Settings screen";
const WCHAR STEP_VERIFY_SETTINGS_VIDEO_SCREEN[]                = L"Verify you are at the Settings 'Video' screen";
const WCHAR STEP_VERIFY_SOURCE_MEMORY_DEVICE_SCREEN[]          = L"Verify you are at the 'SOURCE' Memory Area screen";
const WCHAR STEP_VERIFY_TITLE_DELETE_DIALOG[]                  = L"Verify that the delete TITLE verification dialog appears";
const WCHAR STEP_VERIFY_XZONE_SCREEN[]                         = L"Verify you are at the XZone screen";

const WCHAR STEP_VERIFY_ACTION_COMPLETED[]                     = L"Verify the action being performed completed successfully";
const WCHAR STEP_VERIFY_ACTION_NOT_ALLOWED[]                   = L"Verify that you are not allowed to perform that action";
const WCHAR STEP_VERIFY_ACTION_NOTIFICATION[]                  = L"Verify that the user is notified that the action completed, or is finished";
const WCHAR STEP_VERIFY_ACTION_STARTED[]                       = L"Verify that the action has begun.";
const WCHAR STEP_VERIFY_ALL_MEM_AREAS_PROPER_FILES[]           = L"Verify that all Memory Areas have the files expected";
const WCHAR STEP_VERIFY_AUDIO_CHOICES_AVAILABLE_ARE[]          = L"Verify the audio choices that are available are:";
const WCHAR STEP_VERIFY_AUDIO_SET_ACCORD_TO_VAR[]              = L"Verify the audio display has been set according to the test variation";
const WCHAR STEP_VERIFY_AUDIO_SET_CORRECTLY[]                  = L"Verify the audio display has been set correctly";
const WCHAR STEP_VERIFY_AUDIO_SET_TO[]                         = L"Verify that the audio is set to:";
const WCHAR STEP_VERIFY_CLOCK_CANT_SET_AFTER[]                 = L"Verify that you CANNOT set the clock to a date after:";
const WCHAR STEP_VERIFY_CLOCK_CANT_SET_PRIOR_TO[]              = L"Verify that you CANNOT set the clock to a date prior to:";
const WCHAR STEP_VERIFY_CLOCK_DST_RESET[]                      = L"Verify that the clock DST information has been reset (disabled)";
const WCHAR STEP_VERIFY_CLOCK_INFO_ACCORD_TO_VAR[]             = L"Verify that the clock is set according to the test variation";
const WCHAR STEP_VERIFY_CLOCK_INITIAL_BOOT_GOOD_BATTERY[]      = L"Verify that the clock is set to 'Month, Day, Year', 'XX:XX:XX'";
const WCHAR STEP_VERIFY_CLOCK_INITIAL_BOOT_BAD_BATTERY[]       = L"Verify that the clock is set to 'Month, Day, Year', 'XX:XX:XX'";
const WCHAR STEP_VERIFY_CLOCK_NOT_UPDATED[]                    = L"Verify that the clock has NOT been updated";
const WCHAR STEP_VERIFY_CLOCK_NUM_DAYS_FOR_CURRENT_MONTH[]     = L"Verify that you can only select a valid day for the current month";
const WCHAR STEP_VERIFY_CLOCK_SET_CORRECTLY[]                  = L"Verify that the clock has been set correctly";
const WCHAR STEP_VERIFY_CLOCK_SET_FOR_DST_CORRECTLY[]          = L"Verify that the clock has been set for daylight savings time correctly";
const WCHAR STEP_VERIFY_CLOCK_UPDATED[]                        = L"Verify that the clock has been updated";
const WCHAR STEP_VERIFY_CORRECT_FILES_EXIST[]                  = L"Verify the correct files exist";
const WCHAR STEP_VERIFY_CORRECT_LANGUAGE[]                     = L"Verify the correct language is displayed";
const WCHAR STEP_VERIFY_CORRECT_LANGUAGE_ACCORD_TO_VAR[]       = L"Verify the correct language is displayed according to the test variation";
const WCHAR STEP_VERIFY_CORRECT_SETTINGS_ACCORD_TO_NOTE[]      = L"Verify the settings are correct as noted";
const WCHAR STEP_VERIFY_CORRECT_SIZE_ACCORD_TO_VAR[]           = L"Verify the correct size is displayed according to the test variation";
const WCHAR STEP_VERIFY_CORRECT_TITLES_EXIST[]                 = L"Verify the correct Titles (games) exist";
const WCHAR STEP_VERIFY_CORRECT_TITLES_DELETED[]               = L"Verify the correct Titles (games) have been deleted";
const WCHAR STEP_VERIFY_DEST_MEM_AREA_FILES_OK[]               = L"Verify that the files on the Memory Area are either NOT there, or MARKED bad";
const WCHAR STEP_VERIFY_DEST_MEM_AREA_MARKED_INVALID[]         = L"Verify that the 'DESTINATION' memory area is marked that it does not contain enough space";
const WCHAR STEP_VERIFY_DEST_SCREEN_ACCORD_TO_VAR[]            = L"Verify you are on the correct destination according to the test variation";
const WCHAR STEP_VERIFY_DISPLAY_PROPERLY_WRAPPING[]            = L"Verify the display is wrapping in the proper locations, and looks good";
const WCHAR STEP_VERIFY_MD_TEXT_REFLECTS_VARIATION[]           = L"Verify any references to the Memory Device (area) reflects the test variation";
const WCHAR STEP_VERIFY_MD_SPACE_REFLECTS_VARIATION[]          = L"Verify any references to space available on the Memory Device (area) reflects the test variation";
const WCHAR STEP_VERIFY_MEMORY_MANAGEMENT_CLEANUP[]            = L"Verify that the XDash is in Memory Managment clean-up mode";
const WCHAR STEP_VERIFY_MEMORY_MANAGEMENT_NOT_CLEANUP[]        = L"Verify that the XDash is NOT in Memory Managment clean-up mode";
const WCHAR STEP_VERIFY_SAVED_GAMES_SORTED_ALPHABETICALLY[]    = L"Verify that the saved games for each title are sorted alphabetically";
const WCHAR STEP_VERIFY_SCREEN_UPDATED[]                       = L"Verify the screen is updated as expected";
const WCHAR STEP_VERIFY_SCREEN_ACCORD_TO_VAR[]                 = L"Verify you are on the correct screen according to the test variation";
const WCHAR STEP_VERIFY_SELECTION[]                            = L"Verify the items you selected previously are still selected";
const WCHAR STEP_VERIFY_TEXT_NOT_CLIPPED[]                     = L"Verify that not text is being clipped (unless it's supposed to be)";
const WCHAR STEP_VERIFY_TITLE_FROM_PARENT[]                    = L"Verify that the title that is displayed is from the saved game's parent";
const WCHAR STEP_VERIFY_TITLE_CORRECT_NUM_GAMES_SELECTED[]     = L"Verify that the title reflects the correct number of saved games that were selected";
const WCHAR STEP_VERIFY_TITLES_SORTED_ALPHABETICALLY[]         = L"Verify that the game titles are sorted alphabetically";
const WCHAR STEP_VERIFY_VIDEO_SET_ACCORD_TO_VAR[]              = L"Verify the video display has been set according to the test variation";
const WCHAR STEP_VERIFY_VIDEO_SET_CORRECTLY[]                  = L"Verify the video display has been set correctly";
const WCHAR STEP_VERIFY_VIDEO_SET_TO[]                         = L"Verify that the video is set to:";
const WCHAR STEP_VERIFY_XBOX_POWERED_OFF[]                     = L"Verify the XBox has been powered off";

#endif // _XDASHTESTSTEPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\memory\tests.h ===
#ifndef _tests_h
#define _tests_h

namespace xdashmemory
{
    #define VARIATION_BUFFER_SIZE  1024

    /*

    Copyright (c) 2000 Microsoft Corporation

    Module Name:

        Tests.h

    Abstract:



    Author:

        Jim Helm (jimhelm)

    Environment:

        XBox

    Revision History:
        09-27-2000  Created

    */

    //
    //  Memory Management Tests
    //

    //    01234567890123456789012345678901
    DWORD MemColDukeMUVarsDisplay         ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD MemColMDVariousSizesDisplay     ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD MemColCannotSelectEmptyMD       ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD MemAreaTitleDisplay             ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD MemAreaFreeSpaceDisplay         ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD MemAreaSGWrapping               ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD MemAreaTitlesPerScreen          ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD MemAreaGeneralDisplay           ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD MemAreaHWDeviceRemoved          ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD MemAreaSorting                  ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD MemAreaSavedGameMetaData        ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD SavedGameTitleSingleSGDisplay   ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD SavedGameTitleMultipleSGDisplay ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD SavedGameNavCancel              ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD SavedGameNavCopy                ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD DeleteOnlySavedGameFromMD       ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD DeleteSingleSavedGameFromMD     ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD DeleteGameRemovesGameProperMD   ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD DeleteSingleGameFromMDPowerOff  ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD DeleteSingleGameFromMDPullsPlug ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD DeleteMultipleSavedGamesFromMD  ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD DeleteSavedGameNavConfirmCancel ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD DeleteTitleFromMD               ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD DeleteTitleNavConfirmCancel     ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD HWInsertedDuringOperation       ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD HWRemovedDuringOperation        ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD HWRemovedDuringOperationFail    ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD HWSourceRemovedBeforeCopy       ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD CopySingleSGFromMDToMD          ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD CopySingleSGFromMDToMDPowerOff  ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD CopySingleSGFromMDToMDPullsPlug ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD CopySingleSGAllUnitsFull        ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD CopySingleSGAllUnitsFullHSFull  ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD CopySingleSGAllUnitsFullHSEmpty ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD CopySingleSGHSFullEmptyFull     ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD CopyMultipleSGsFromMDToMD       ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD CopySingleSGFileVerification    ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD CopyMultipleSGsFileVerification ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD MemCopyDukeHotPlugVarsDisplay   ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD MemCopyMUHotPlugVarsDisplay     ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD MemCopyMDVariousSizesDisplay    ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD MemCopyDestMUNotEnoughRoom      ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD MemCopyTitleSingleSGDisplay     ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD MemCopyTitleMultipleSGDisplay   ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD BootToMemCleanUpMAFullDisplay   ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD BootToMemCleanUpMAEmptyDisplay  ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD BootToMemCleanUpMAFull0blocks   ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD BootToMemCleanUpMAFullDeleteAll ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD BootToMemCleanUpClearSpace      ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD BootToMemCleanUpHotSwapMA       ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD BootToMemCleanUpNavAway         ( HANDLE hLog, CStepsLog* pStepsLog );
}; // namespace

#endif // _tests_h

// Enumerate tests of removing any hardware while meta data is displayed for EVERY screen!
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\memory\tests.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    Tests.cpp

Abstract:


Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-09-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "tests.h"

namespace xdashmemory
{
    /***********************
    ************************
    *** Begin Test Cases ***
    ************************
    ***********************/


    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD MemColDukeMUVarsDisplay( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This case verifies that the Memory Collections main screen displays
        // properly with variations of Dukes and MUs.
        //
        // It also ensures that Dukes and MUs can be Hot-Plugged on this screen,
        // and it will behave as expected.
        //////////////////////////////////////////////////////////////////////////

        size_t testVariationNum = 0;                        // The Variation Number of the test we are running
        WCHAR portConfiguration[VARIATION_BUFFER_SIZE];     // The String representation of the XBox Port Configuration we'll be using
        WCHAR testVariation[VARIATION_BUFFER_SIZE];         // The String representation holding the variation number we are running

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SETUP_XBOX_PORTS_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );

        for ( size_t port1 = 0; port1 < ARRAYSIZE(validDukeAndMUConfigs); ++port1 )
        {
            for ( size_t port2 = 0; port2 < ARRAYSIZE(validDukeAndMUConfigs); ++port2 )
            {
                for ( size_t port3 = 0; port3 < ARRAYSIZE(validDukeAndMUConfigs); ++port3 )
                {
                    for ( size_t port4 = 0; port4 < ARRAYSIZE(validDukeAndMUConfigs); ++port4 )
                    {
                        _snwprintf( testVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++testVariationNum );
                        _snwprintf( portConfiguration, VARIATION_BUFFER_SIZE, L"Variation %d: Port 1: %s, Port 2: %s, Port 3: %s, Port 4: %s", testVariationNum, validDukeAndMUConfigs[port1], validDukeAndMUConfigs[port2], validDukeAndMUConfigs[port3], validDukeAndMUConfigs[port4]);
  
                        // Log the test case variation to our Steps File
                        pStepsLog->AddVariation( portConfiguration );

                        TESTCASE( testVariation )
                        {
                            TESTMNUL( hLog, "Manual Test" );
                        } ENDTESTCASE;
                    }
                }
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD MemColMDVariousSizesDisplay( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This case verifies that the Memory Collection main screen displays
        // properly with Memory Devices that are filled with various amounts of
        // data.  It verifies that the information displayed when you
        // "highlight" on of these areas is displayed correctly.
        //////////////////////////////////////////////////////////////////////////

        size_t testVariationNum = 0;                        // The Variation Number of the test we are running
        WCHAR deviceConfiguration[VARIATION_BUFFER_SIZE];   // The String representation of the XBox Device Configuration we'll be using
        WCHAR testVariation[VARIATION_BUFFER_SIZE];         // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );

        // Xdisk verified with each MD block configuration
        for( size_t blockConfig = 0; blockConfig < ARRAYSIZE( gc_lpwszMEM_AREA_BLOCK_CONFIGS ); ++blockConfig )
        {
            _snwprintf( testVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++testVariationNum );
            _snwprintf( deviceConfiguration, VARIATION_BUFFER_SIZE, L"Variation %d: Xdisk, MemArea Block Configuration: %s", testVariationNum, gc_lpwszMEM_AREA_BLOCK_CONFIGS[blockConfig] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( deviceConfiguration );

            TESTCASE( testVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }


        // All Dukes in all ports, and each port on each Duke tested with the MD block configurations
        for( size_t port = 1; port <= gc_nNUM_XBOX_PORTS; ++port )
        {
            for( size_t dukeSlot = 1; dukeSlot <= gc_nNUM_DUKE_SLOTS; ++dukeSlot )
            {
                for( size_t blockConfig = 0; blockConfig < ARRAYSIZE( gc_lpwszMEM_AREA_BLOCK_CONFIGS ); ++blockConfig )
                {
                    _snwprintf( testVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++testVariationNum );
                    _snwprintf( deviceConfiguration, VARIATION_BUFFER_SIZE, L"Variation %d: Port: %d, Duke Slot: %d, MemArea Block Configuration: %s", testVariationNum, port, dukeSlot, gc_lpwszMEM_AREA_BLOCK_CONFIGS[blockConfig] );
  
                    // Log the test case variation to our Steps File
                    pStepsLog->AddVariation( deviceConfiguration );

                    TESTCASE( testVariation )
                    {
                        TESTMNUL( hLog, "Manual Test" );
                    } ENDTESTCASE;
                }
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD MemColCannotSelectEmptyMD( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This case verifies that the Memory Collection main screen does
        // note allow the user to select a Memory Device that is empty.
        //////////////////////////////////////////////////////////////////////////

        size_t testVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR memArea[VARIATION_BUFFER_SIZE];           // The String representation of the XBox Memory Area we'll be using
        WCHAR testVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_EMPTY );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );

        // For each memory area available
        for( size_t currentMemArea=0; currentMemArea < ARRAYSIZE( gc_lpwszMEM_AREAS ); ++currentMemArea )
        {
            _snwprintf( testVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++testVariationNum );
            _snwprintf( memArea, VARIATION_BUFFER_SIZE, L"Variation %d: Memory Area: %s", testVariationNum, gc_lpwszMEM_AREAS[currentMemArea] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( memArea );

            TESTCASE( testVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD MemAreaTitleDisplay( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This case verifies that the Memory Device (area) screen properly
        // displays the title of the selected Memory Device (area)
        //////////////////////////////////////////////////////////////////////////

        size_t testVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR memArea[VARIATION_BUFFER_SIZE];           // The String representation of the XBox Memory Area we'll be using
        WCHAR testVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_MD_TEXT_REFLECTS_VARIATION );

        // For each memory area available
        for( size_t currentMemArea=0; currentMemArea < ARRAYSIZE( gc_lpwszMEM_AREAS ); ++currentMemArea )
        {
            _snwprintf( testVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++testVariationNum );
            _snwprintf( memArea, VARIATION_BUFFER_SIZE, L"Variation %d: Memory Area: %s", testVariationNum, gc_lpwszMEM_AREAS[currentMemArea] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( memArea );

            TESTCASE( testVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD MemAreaFreeSpaceDisplay( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This case verifies that the Memory Device (area) screen Properly
        // Displays the amount of space that's avialable on a MD
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_MU1_DUKE1,
            MEMORY_AREA_XDISK
        };

        size_t testVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR memDeviceInfo[VARIATION_BUFFER_SIZE];     // The String representation of the XBox Memory Device and Configuration we'll be using
        WCHAR testVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_MD_SPACE_REFLECTS_VARIATION );

        // For each memory area available
        for( size_t currentMemArea=0; currentMemArea < ARRAYSIZE( memDevices ); ++currentMemArea )
        {
            for( size_t blockConfig = 0; blockConfig < ARRAYSIZE( gc_lpwszMEM_AREA_BLOCK_CONFIGS ); ++blockConfig )
            {
                _snwprintf( testVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++testVariationNum );
                _snwprintf( memDeviceInfo, VARIATION_BUFFER_SIZE, L"Variation %d: Memory Area: %s, MemArea Block Configuration: %s", testVariationNum, gc_lpwszMEM_AREAS[memDevices[currentMemArea]], gc_lpwszMEM_AREA_BLOCK_CONFIGS[blockConfig] );

                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( memDeviceInfo );

                TESTCASE( testVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };



    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD MemAreaSGWrapping( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // As games have more and more save games, there comes a point at which
        // the game must start to "wrap" the save games to the next line of the
        // display.  This test is to ensure that wrapping is working as expected.
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_XDISK
        };

        WCHAR* memAreaSavedGameConfigs[] = {
            L"A Title with 1 saved game less than 1 screen line of saved games",
            L"A Title with EXACTLY 1 screen line of saved games",
            L"A Title with 1 saved game more than 1 screen line of saved games",
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_DISPLAY_PROPERLY_WRAPPING );
        pStepsLog->AddStep( STEP_VERIFY_TEXT_NOT_CLIPPED );

        // For each memory area available
        for( size_t currentMemArea=0; currentMemArea < ARRAYSIZE( memDevices ); ++currentMemArea )
        {
            for( size_t sgConfig = 0; sgConfig < ARRAYSIZE( memAreaSavedGameConfigs ); ++sgConfig )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Memory Area: %s, Saved Game Configuration: %s", xlogVariationNum, gc_lpwszMEM_AREAS[memDevices[currentMemArea]], memAreaSavedGameConfigs[sgConfig] );

                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( stepsVariation );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD MemAreaTitlesPerScreen( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // As games have more and more save games, there comes a point at which
        // the game must start to "wrap" the save games.  This will cause less
        // "titles (games)" to appear on the screen.  This test will verify that
        // no matter how many lines of saved games we have, the displays always
        // looks good.
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_XDISK
        };

        WCHAR* memAreaSavedGameConfigs[] = {
            L"10 Titles on the memory area, each with no more than 1 lines of saved game.",
            L"10 Titles on the memory area, the 1st title should have 2 lines saved games.",
            L"10 Titles on the memory area, the 1st title should have 3 lines saved games.",
            L"10 Titles on the memory area, the 1st title should have 4 lines saved games."
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_DISPLAY_PROPERLY_WRAPPING );
        pStepsLog->AddStep( STEP_VERIFY_TEXT_NOT_CLIPPED );

        // For each memory area available
        for( size_t currentMemArea=0; currentMemArea < ARRAYSIZE( memDevices ); ++currentMemArea )
        {
            for( size_t sgConfig = 0; sgConfig < ARRAYSIZE( memAreaSavedGameConfigs ); ++sgConfig )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Memory Area: %s, Saved Game Configuration: %s", xlogVariationNum, gc_lpwszMEM_AREAS[memDevices[currentMemArea]], memAreaSavedGameConfigs[sgConfig] );

                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( stepsVariation );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD MemAreaGeneralDisplay( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will ensure that the Memory Area screen displays correctly
        // with variations of the number of titles and saved games that are
        // being presented to the user.
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_MU1_DUKE1,
            MEMORY_AREA_XDISK
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_DISPLAY_PROPERLY_WRAPPING );
        pStepsLog->AddStep( STEP_VERIFY_TEXT_NOT_CLIPPED );

        // For each memory area available
        for( size_t currentMemArea=0; currentMemArea < ARRAYSIZE( memDevices ); ++currentMemArea )
        {
            for( size_t sgConfig = 0; sgConfig < ARRAYSIZE( gc_lpwszMEM_AREA_SAVEGAME_CONFIGS ); ++sgConfig )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Memory Area: %s, Saved Game Configuration: %s", xlogVariationNum, gc_lpwszMEM_AREAS[memDevices[currentMemArea]], gc_lpwszMEM_AREA_SAVEGAME_CONFIGS[sgConfig] );

                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( stepsVariation );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD MemAreaHWDeviceRemoved( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a user has selected a Memory Area, and
        // then hardware is removed (currently selected MU, or the Duke), that the
        // xdash takes the user to the appropriate location.
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_MU1_DUKE1
        };

        // List of the hardware to be removed for this test
        WCHAR* hardwareToRemove[] = {
            L"Remove MU 1 from Duke 1",
            L"Remove Duke 1"
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_SOME_DATA );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_REMOVE_HARDWARE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );

        // For each memory area available
        for( size_t currentMemArea=0; currentMemArea < ARRAYSIZE( memDevices ); ++currentMemArea )
        {
            for( size_t hardwareDevice = 0; hardwareDevice < ARRAYSIZE( hardwareToRemove ); ++hardwareDevice )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Memory Area: %s, Hardware to Remove: %s", xlogVariationNum, gc_lpwszMEM_AREAS[memDevices[currentMemArea]], hardwareToRemove[hardwareDevice] );

                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( stepsVariation );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD MemAreaSorting( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that the titles and saved games are displayed
        // in alphabetical order by the default title.
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_MU1_DUKE1,
            MEMORY_AREA_XDISK
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_TITLES_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_GAMES_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_TITLES_SORTED_ALPHABETICALLY );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAMES_SORTED_ALPHABETICALLY ); 

        // For each memory area available
        for( size_t currentMemArea=0; currentMemArea < ARRAYSIZE( memDevices ); ++currentMemArea )
        {
            // For each variation in the names
            for( size_t nameVar = 0; nameVar < ARRAYSIZE( gc_lpwszGAME_AND_TITLE_NAMES ); ++nameVar )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Memory Area: %s, Titles/Games: %s", xlogVariationNum, gc_lpwszMEM_AREAS[memDevices[currentMemArea]], gc_lpwszGAME_AND_TITLE_NAMES[nameVar] );

                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( stepsVariation );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD MemAreaSavedGameMetaData( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test that when the user highlights a saved game, the META data
        // for that game is displayed properly with different variations.
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_MU1_DUKE1,
            MEMORY_AREA_XDISK
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_DISPLAY_PROPERLY_WRAPPING );
        pStepsLog->AddStep( STEP_VERIFY_TEXT_NOT_CLIPPED );

        // For each memory area available
        for( size_t currentMemArea=0; currentMemArea < ARRAYSIZE( memDevices ); ++currentMemArea )
        {
            // All META data missing
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: ALL Meta data MISSING", xlogVariationNum );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );

            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        

            // All META data MAX characters
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Maximum amount of chars for all pieces of META data simultaneously", xlogVariationNum );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );

            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;


            // SAVED GAME META: Variations in the name of a saved game
            for( size_t sgName = 0; sgName < ARRAYSIZE( gc_lpwszMETA_SAVED_GAME_NAME_CONFIGS ); ++sgName )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Normal META data, except Saved Game Name: %s", xlogVariationNum, gc_lpwszMETA_SAVED_GAME_NAME_CONFIGS[sgName] );
 
                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( stepsVariation );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        
            // SAVED GAME META: Variations in the name of the game that a saved game is from (Parent game)
            for( size_t sgParentName = 0; sgParentName < ARRAYSIZE( gc_lpwszMETA_SAVED_GAME_PARENT_NAME_CONFIGS ); ++sgParentName )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Normal META data, except Saved Game Parent Name: %s", xlogVariationNum, gc_lpwszMETA_SAVED_GAME_PARENT_NAME_CONFIGS[sgParentName] );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        
            // SAVED GAME META: Variations in the size of the saved game
            for( size_t sgSize = 0; sgSize < ARRAYSIZE( gc_lpwszMETA_SAVED_GAME_SIZE_CONFIGS ); ++sgSize )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Normal META data, except Saved Game Size: %s", xlogVariationNum, gc_lpwszMETA_SAVED_GAME_SIZE_CONFIGS[sgSize] );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }

            // SAVED GAME META: Variations in the time that a game was saved
            for( size_t sgTime = 0; sgTime < ARRAYSIZE( gc_lpwszMETA_SAVED_GAME_TIME_CONFIGS ); ++sgTime )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Normal META data, except Saved Game Time: %s", xlogVariationNum, gc_lpwszMETA_SAVED_GAME_TIME_CONFIGS[sgTime] );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }

            // SAVED GAME META: Variations in the images representing a saved game
            for( size_t sgImage = 0; sgImage < ARRAYSIZE( gc_lpwszMETA_SAVED_GAME_IMAGE_CONFIGS ); ++sgImage )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Normal META data, except Saved Game Image: %s", xlogVariationNum, gc_lpwszMETA_SAVED_GAME_IMAGE_CONFIGS[sgImage] );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }
 
        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD SavedGameTitleSingleSGDisplay( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a user selects a single saved game
        // that the title of the "saved game" dialog is displayed appropriately.
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_XDISK
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_TWO_SAVED_GAMES );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_VERIFY_TITLE_FROM_PARENT );
        pStepsLog->AddStep( STEP_VERIFY_DISPLAY_PROPERLY_WRAPPING);
        pStepsLog->AddStep( STEP_VERIFY_TEXT_NOT_CLIPPED);

        // For each memory area available
        for( size_t currentMemArea=0; currentMemArea < ARRAYSIZE( memDevices ); ++currentMemArea )
        {
            // SAVED GAME META: Variations in the name of the game that a saved game is from (Parent game)
            for( size_t sgParentName = 0; sgParentName < ARRAYSIZE( gc_lpwszMETA_SAVED_GAME_PARENT_NAME_CONFIGS ); ++sgParentName )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Select a SINGLE game from Memory Area: %s, Saved Game's Parent Name: %s", xlogVariationNum, gc_lpwszMEM_AREAS[currentMemArea], gc_lpwszMETA_SAVED_GAME_PARENT_NAME_CONFIGS[sgParentName] );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD SavedGameTitleMultipleSGDisplay( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a user selects multiple saved games
        // that the title of the "saved game" dialog is displayed appropriately.
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_XDISK
        };

        // Subset of the generic saved game selections we want to make
        enum SavedGamesGenericWithinList genSGs[] = {
            SAVED_GAMES_MULTIPLE,
            SAVED_GAMES_ALL
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_TWO_SAVED_GAMES );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_VERIFY_TITLE_CORRECT_NUM_GAMES_SELECTED );
        pStepsLog->AddStep( STEP_VERIFY_DISPLAY_PROPERLY_WRAPPING);
        pStepsLog->AddStep( STEP_VERIFY_TEXT_NOT_CLIPPED);

        // For each memory area available
        for( size_t currentMemArea = 0; currentMemArea < ARRAYSIZE( memDevices ); ++currentMemArea )
        {
            // For each generic saved game config in our subset
            for( size_t sgConfig = 0; sgConfig < ARRAYSIZE( genSGs ); ++sgConfig )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Select MULTIPLE games from Memory Area: %s, Saved Games to Select: %s", xlogVariationNum, gc_lpwszMEM_AREAS[currentMemArea], gc_lpwszGENERIC_SAVED_GAME_CONFIGS[genSGs[sgConfig]] );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD SavedGameNavCancel( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a user selects a saved game, and then
        // chooses "cancel", they are navigated to the appropriate screen.
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_MU1_DUKE1
        };

        // Subset of the generic saved game selections we want to make
        enum SavedGamesGenericWithinList genSGs[] = {
            SAVED_GAMES_SINGLE,
            SAVED_GAMES_MULTIPLE
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_TWO_SAVED_GAMES );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_CANCEL );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SELECTION );

        // For each memory area available
        for( size_t currentMemArea=0; currentMemArea < ARRAYSIZE( memDevices ); ++currentMemArea )
        {
            // For each generic saved game config in our subset
            for( size_t sgConfig = 0; sgConfig < ARRAYSIZE( genSGs ); ++sgConfig )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Memory Area: %s, Games to Select: %s", xlogVariationNum, gc_lpwszMEM_AREAS[memDevices[currentMemArea]], gc_lpwszGENERIC_SAVED_GAME_CONFIGS[genSGs[sgConfig]] );

                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( stepsVariation );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD SavedGameNavCopy( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a user selects a saved game, and then
        // chooses "copy", they are navigated to the appropriate screen.
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_MU1_DUKE1
        };

        // Subset of the generic saved game selections we want to make
        enum SavedGamesGenericWithinList genSGs[] = {
            SAVED_GAMES_SINGLE,
            SAVED_GAMES_MULTIPLE
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_TWO_SAVED_GAMES );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_COPY );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SELECTION );

        // For each memory area available
        for( size_t currentMemArea=0; currentMemArea < ARRAYSIZE( memDevices ); ++currentMemArea )
        {
            // For each generic saved game config in our subset
            for( size_t sgConfig = 0; sgConfig < ARRAYSIZE( genSGs ); ++sgConfig )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Memory Area: %s, Games to Select: %s", xlogVariationNum, gc_lpwszMEM_AREAS[memDevices[currentMemArea]], gc_lpwszGENERIC_SAVED_GAME_CONFIGS[genSGs[sgConfig]] );

                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( stepsVariation );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD DeleteOnlySavedGameFromMD( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a user deletes the only saved game from
        // a Memory Device (area), the UI is correct.
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_MU1_DUKE1,
            MEMORY_AREA_XDISK
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_ONE_SAVED_GAME );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_DELETE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_DELETE_DIALOG );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );

        // For each memory area available
        for( size_t currentMemArea=0; currentMemArea < ARRAYSIZE( memDevices ); ++currentMemArea )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Memory Area: %s", xlogVariationNum, gc_lpwszMEM_AREAS[memDevices[currentMemArea]] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );

            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD DeleteSingleSavedGameFromMD( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that deleting a single saved game from a Memory
        // Device, with different saved game and block configurations works as
        // expected.
        //////////////////////////////////////////////////////////////////////////

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_DELETE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_DELETE_DIALOG );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );

        // Each memory area available
        for( size_t currentMemArea = 0; currentMemArea < ARRAYSIZE( gc_lpwszMEM_AREAS ); ++currentMemArea )
        {
            // Each Single Saved Game configuration
            for( size_t currentSavedGameConfig = 0; currentSavedGameConfig < ARRAYSIZE( gc_lpwszSINGLE_SAVED_GAME_CONFIGS ); ++currentSavedGameConfig )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Memory Area: %s, Game Configuration: %s", xlogVariationNum, gc_lpwszMEM_AREAS[currentMemArea], gc_lpwszSINGLE_SAVED_GAME_CONFIGS[currentSavedGameConfig] );

                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( stepsVariation );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD DeleteGameRemovesGameProperMD( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that deleting a single saved game from a Memory
        // Area only deletes the game from that Memory Area, and not any other
        // area.  Each area in this case must have the SAME game on the MU.
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_MU1_DUKE1,
            MEMORY_AREA_XDISK
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_ALL_MEM_AREAS_SAME_SAVED_GAME );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_DELETE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_DELETE_DIALOG );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );
        pStepsLog->AddStep( STEP_VERIFY_ALL_MEM_AREAS_PROPER_FILES );

        for( size_t currentMemArea=0; currentMemArea < ARRAYSIZE( memDevices ); ++currentMemArea )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Memory Area to delete game from: %s", xlogVariationNum, gc_lpwszMEM_AREAS[memDevices[currentMemArea]] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );

            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }

        return 0;
    };
    
    
    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD DeleteSingleGameFromMDPowerOff( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that deleting a single saved game from a Memory
        // Device, and the user pressing the power button, completes the delete
        // as expected
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_MU1_DUKE1,
            MEMORY_AREA_XDISK
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_IN_VAR_TWO_SAVED_GAMES );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_DELETE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_DELETE_DIALOG );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_STARTED );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_XBOX_POWERED_OFF );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CORRECT_FILES_EXIST );

        // Each memory area available
        for( size_t currentMemArea = 0; currentMemArea < ARRAYSIZE( memDevices ); ++currentMemArea )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Memory Area: %s", xlogVariationNum, gc_lpwszMEM_AREAS[currentMemArea] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );

            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD DeleteSingleGameFromMDPullsPlug( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that deleting a single saved game from a Memory
        // Device, and the user pulls the plug, only the files that were being
        // deleted has been affected.
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_MU1_DUKE1,
            MEMORY_AREA_XDISK
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_IN_VAR_TWO_SAVED_GAMES );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_DELETE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_DELETE_DIALOG );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_STARTED );
        pStepsLog->AddStep( STEP_REMOVE_POWER_PLUG_FROM_XBOX );
        pStepsLog->AddStep( STEP_VERIFY_XBOX_POWERED_OFF );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_DEST_MEM_AREA_FILES_OK );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAMES_MARKED_BAD );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_DELETE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_DELETE_DIALOG );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );
        pStepsLog->AddStep( STEP_VERIFY_CORRECT_FILES_EXIST );

        // Each memory area available
        for( size_t currentMemArea = 0; currentMemArea < ARRAYSIZE( memDevices ); ++currentMemArea )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Memory Area: %s", xlogVariationNum, gc_lpwszMEM_AREAS[currentMemArea] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );

            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD DeleteMultipleSavedGamesFromMD( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that deleting multiple saved games from a Memory
        // Device, with different saved game and block configurations works as
        // expected.
        //////////////////////////////////////////////////////////////////////////

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_DELETE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_DELETE_DIALOG );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );

        // Each memory area available
        for( size_t currentMemArea = 0; currentMemArea < ARRAYSIZE( gc_lpwszMEM_AREAS ); ++currentMemArea )
        {
            // Each Single Saved Game configuration
            for( size_t currentSavedGameConfig = 0; currentSavedGameConfig < ARRAYSIZE( gc_lpwszMULTIPLE_SAVED_GAME_CONFIGS ); ++currentSavedGameConfig )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Memory Area: %s, Game Configuration: %s", xlogVariationNum, gc_lpwszMEM_AREAS[currentMemArea], gc_lpwszMULTIPLE_SAVED_GAME_CONFIGS[currentSavedGameConfig] );

                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( stepsVariation );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD DeleteSavedGameNavConfirmCancel( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a user selects a saved game, and then
        // chooses delete, that they can select 'cancel' from the Delete Game
        // confirmation dialog, and they are navigated to the appropriate screen.
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_MU1_DUKE1
        };

        // Subset of the generic saved game selections we want to make
        enum SavedGamesGenericWithinList genSGs[] = {
            SAVED_GAMES_SINGLE,
            SAVED_GAMES_MULTIPLE
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_CANCEL );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SELECTION );

        // For each memory area available
        for( size_t currentMemArea=0; currentMemArea < ARRAYSIZE( memDevices ); ++currentMemArea )
        {
            // For each generic saved game config in our subset
            for( size_t sgConfig = 0; sgConfig < ARRAYSIZE( genSGs ); ++sgConfig )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Memory Area: %s, Games to Select: %s", xlogVariationNum, gc_lpwszMEM_AREAS[memDevices[currentMemArea]], gc_lpwszGENERIC_SAVED_GAME_CONFIGS[genSGs[sgConfig]] );

                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( stepsVariation );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD DeleteTitleFromMD( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that you can delete an entire title from the
        // XBox Memory Areas.
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_MU1_DUKE1,
            MEMORY_AREA_XDISK
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_TITLE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_TITLE_DELETE_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_DELETE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CORRECT_TITLES_DELETED );

        // For each memory area available
        for( size_t currentMemArea=0; currentMemArea < ARRAYSIZE( memDevices ); ++currentMemArea )
        {
            // For each Title and saved game combination to be removed entirely from the XBox
            for( size_t varConfig = 0; varConfig < ARRAYSIZE( gc_lpwszDELETE_TITLE_SAVED_GAME_CONFIGS ); ++varConfig )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Memory Area: %s, Title to Remove: %s", xlogVariationNum, gc_lpwszMEM_AREAS[memDevices[currentMemArea]], gc_lpwszDELETE_TITLE_SAVED_GAME_CONFIGS[varConfig] );

                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( stepsVariation );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD DeleteTitleNavConfirmCancel( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a user selects a Title to be deleted,
        // and then chooses "cancel", that they are navigated back to the
        // appropriate screen.
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_MU1_DUKE1
        };

        // Subset of the generic saved game selections we want to make
    enum DeleteTitleGameConfigsWithinList titleConfigs[] = {
            DELETE_2_TITLES_TITLE1_1_SAVED_GAME_TITLE2_1_SAVED_GAME_SELECT_TITLE1,
            DELETE_2_TITLES_TITLE1_1_SAVED_GAME_TITLE2_1_SAVED_GAME_SELECT_TITLE2,
            DELETE_3_TITLES_TITLE1_1_SAVED_GAME_TITLE2_1_SAVED_GAME_TITLE3_1_SAVED_GAME_SELECT_TITLE2
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_TITLE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_TITLE_DELETE_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_CANCEL );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SELECTION );

        // For each memory area available
        for( size_t currentMemArea=0; currentMemArea < ARRAYSIZE( memDevices ); ++currentMemArea )
        {
            // For each generic saved game config in our subset
            for( size_t titleConfig = 0; titleConfig < ARRAYSIZE( titleConfigs ); ++titleConfig )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Memory Area: %s, Title to Select: %s", xlogVariationNum, gc_lpwszMEM_AREAS[memDevices[currentMemArea]], gc_lpwszDELETE_TITLE_SAVED_GAME_CONFIGS[titleConfigs[titleConfig]] );

                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( stepsVariation );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD HWInsertedDuringOperation( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if hardware is inserted during a saved game
        // operation (copy or delete), the program will continue as expected.
        //
        // NOTE: The hardware used in this case is NOT the hardware that's either
        // the source, or destiation Duke/Memory Area
        //////////////////////////////////////////////////////////////////////////

        // A sub-list of possible memory areas to copy to / from for this
        // test case
        CopyFromToMD MDCopyList[] = {
            { MEMORY_AREA_MU1_DUKE1, MEMORY_AREA_XDISK },
            { MEMORY_AREA_XDISK,     MEMORY_AREA_MU1_DUKE1 }
        };

        // List of ports to use where the hardware will be inserted
        WCHAR* portsToUse[] = {
            L"2"
        };

        // Hardware devices to be used for the insertion
        WCHAR* hardwareDevicesToUse[] = {
            (WCHAR*)validDukeAndMUConfigs[DUKE_E_E],
            (WCHAR*)gc_lpwszMEM_AREAS[MEMORY_AREA_MU1_DUKE2],
            (WCHAR*)gc_lpwszMEM_AREAS[MEMORY_AREA_MU2_DUKE1]
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_SETUP_XBOX_PORTS_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SOURCE_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_INITIATE_ACTION_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_INSERT_HARDWARE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_COMPLETED );

        // For each memory area from/to combination available
        for( size_t currentCopy = 0; currentCopy < ARRAYSIZE( MDCopyList ); ++currentCopy )
        {
            // For each port we wish to use
            for( size_t port = 0; port < ARRAYSIZE( portsToUse ); ++port )
            {
                // for each piece of hardware to be inserted
                for( size_t hardware = 0; hardware < ARRAYSIZE( hardwareDevicesToUse ); ++hardware )
                {
                    // for each action we can perform on the saved game
                    for( size_t action = 0; action < ARRAYSIZE( gc_lpwszSAVED_GAME_ACTIONS ); ++action )
                    {
                        // for each generic saved game configuration that can be on a memory device
                        for( size_t gameConfig = 0; gameConfig < ARRAYSIZE( gc_lpwszGENERIC_SAVED_GAME_CONFIGS ); ++gameConfig )
                        {
                            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: FROM %s to %s, Hardward to Insert: %s in Port %s, Action: %s, Saved Game Config: %s", xlogVariationNum, gc_lpwszMEM_AREAS[MDCopyList[currentCopy].FromMD], gc_lpwszMEM_AREAS[MDCopyList[currentCopy].ToMD], hardwareDevicesToUse[hardware], portsToUse[port], gc_lpwszSAVED_GAME_ACTIONS[action], gc_lpwszGENERIC_SAVED_GAME_CONFIGS[gameConfig] );

                            // Log the test case variation to our Steps File
                            pStepsLog->AddVariation( stepsVariation );

                            TESTCASE( xlogVariation )
                            {
                                TESTMNUL( hLog, "Manual Test" );
                            } ENDTESTCASE;
                        }
                    }
                }
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD HWRemovedDuringOperation( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if hardware is removed during a saved game
        // operation (copy or delete), the program will continue as expected.
        //
        // NOTE: The hardware used in this case is NOT the hardware that's either
        // the source, or destiation Duke/Memory Area
        //////////////////////////////////////////////////////////////////////////

        // A sub-list of possible memory areas to copy to / from for this
        // test case
        CopyFromToMD MDCopyList[] = {
            { MEMORY_AREA_MU1_DUKE1, MEMORY_AREA_XDISK },
            { MEMORY_AREA_XDISK,     MEMORY_AREA_MU1_DUKE1 }
        };

        // List of ports to use where the hardware will be inserted
        WCHAR* portsToUse[] = {
            L"2"
        };

        WCHAR* hardwareDevicesToUse[] = {
            (WCHAR*)validDukeAndMUConfigs[DUKE_E_E],
            (WCHAR*)gc_lpwszMEM_AREAS[MEMORY_AREA_MU1_DUKE2],
            (WCHAR*)gc_lpwszMEM_AREAS[MEMORY_AREA_MU2_DUKE1]
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_SETUP_XBOX_PORTS_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SOURCE_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_INITIATE_ACTION_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_REMOVE_HARDWARE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_COMPLETED );

        // For each memory area from/to combination available
        for( size_t currentCopy = 0; currentCopy < ARRAYSIZE( MDCopyList ); ++currentCopy )
        {
            // For each port we wish to use
            for( size_t port = 0; port < ARRAYSIZE( portsToUse ); ++port )
            {
                // for each piece of hardware to be inserted
                for( size_t hardware = 0; hardware < ARRAYSIZE( hardwareDevicesToUse ); ++hardware )
                {
                    // for each action we can perform on the saved game
                    for( size_t action = 0; action < ARRAYSIZE( gc_lpwszSAVED_GAME_ACTIONS ); ++action )
                    {
                        // for each generic saved game configuration that can be on a memory device
                        for( size_t gameConfig = 0; gameConfig < ARRAYSIZE( gc_lpwszGENERIC_SAVED_GAME_CONFIGS ); ++gameConfig )
                        {
                            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: FROM %s to %s, Hardward to Remove: %s from Port %s, Action: %s, Saved Game Config: %s", xlogVariationNum, gc_lpwszMEM_AREAS[MDCopyList[currentCopy].FromMD], gc_lpwszMEM_AREAS[MDCopyList[currentCopy].ToMD], hardwareDevicesToUse[hardware], portsToUse[port], gc_lpwszSAVED_GAME_ACTIONS[action], gc_lpwszGENERIC_SAVED_GAME_CONFIGS[gameConfig] );

                            // Log the test case variation to our Steps File
                            pStepsLog->AddVariation( stepsVariation );

                            TESTCASE( xlogVariation )
                            {
                                TESTMNUL( hLog, "Manual Test" );
                            } ENDTESTCASE;
                        }
                    }
                }
            }
        }

        return 0;
    };



    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD HWRemovedDuringOperationFail( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if hardware is removed during a saved game
        // operation (copy or delete), the program will continue as expected.
        //
        // It will also verify that the files that were being copied/deleted are
        // able to be cleaned up after the failure.
        //
        // NOTE: The hardware used in this case IS the hardware that's either
        // the source, or destiation Duke/Memory Area
        //////////////////////////////////////////////////////////////////////////

        // A sub-list of possible memory areas to copy to / from for this
        // test case
        CopyFromToMD MDCopyList[] = {
            { MEMORY_AREA_MU1_DUKE1, MEMORY_AREA_XDISK },
            { MEMORY_AREA_XDISK,     MEMORY_AREA_MU1_DUKE1 }
        };

        // List of ports to use where the hardware will be inserted
        WCHAR* portsToUse[] = {
            L"1"
        };

        // Hardware devices to be used for the insertion/removal
        WCHAR* hardwareDevicesToUse[] = {
            (WCHAR*)validDukeAndMUConfigs[DUKE_M_E],
            (WCHAR*)gc_lpwszMEM_AREAS[MEMORY_AREA_MU1_DUKE1]
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_SETUP_XBOX_PORTS_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SOURCE_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_INITIATE_ACTION_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_REMOVE_HARDWARE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_NOTIFICATION );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SOURCE_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SELECTION );
        pStepsLog->AddStep( STEP_INSERT_HARDWARE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEST_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_DEST_MEM_AREA_FILES_OK );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAMES_MARKED_BAD );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_DELETE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_DELETE_DIALOG );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );

        // For each memory area from/to combination available
        for( size_t currentCopy = 0; currentCopy < ARRAYSIZE( MDCopyList ); ++currentCopy )
        {
            // For each port we wish to use
            for( size_t port = 0; port < ARRAYSIZE( portsToUse ); ++port )
            {
                // for each piece of hardware to be inserted
                for( size_t hardware = 0; hardware < ARRAYSIZE( hardwareDevicesToUse ); ++hardware )
                {
                    // for each action we can perform on the saved game
                    for( size_t action = 0; action < ARRAYSIZE( gc_lpwszSAVED_GAME_ACTIONS ); ++action )
                    {
                        // for each generic saved game configuration that can be on a memory device
                        for( size_t gameConfig = 0; gameConfig < ARRAYSIZE( gc_lpwszGENERIC_SAVED_GAME_CONFIGS ); ++gameConfig )
                        {
                            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: FROM %s to %s, Hardward to Remove: %s in Port %s, Action: %s, Saved Game Config: %s", xlogVariationNum, gc_lpwszMEM_AREAS[MDCopyList[currentCopy].FromMD], gc_lpwszMEM_AREAS[MDCopyList[currentCopy].ToMD], hardwareDevicesToUse[hardware], portsToUse[port], gc_lpwszSAVED_GAME_ACTIONS[action], gc_lpwszGENERIC_SAVED_GAME_CONFIGS[gameConfig] );

                            // Log the test case variation to our Steps File
                            pStepsLog->AddVariation( stepsVariation );

                            TESTCASE( xlogVariation )
                            {
                                TESTMNUL( hLog, "Manual Test" );
                            } ENDTESTCASE;
                        }
                    }
                }
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD HWSourceRemovedBeforeCopy( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if hardware is removed during a saved game
        // copy operation, before the operation is initiated, the program will
        // continue as expected.
        //////////////////////////////////////////////////////////////////////////

        // A sub-list of possible memory areas to copy to / from for this
        // test case

        enum MemoryAreasWithinList MAToUse [] = {
            MEMORY_AREA_MU1_DUKE1,
            MEMORY_AREA_MU2_DUKE1,
            MEMORY_AREA_MU1_DUKE2,
            MEMORY_AREA_MU2_DUKE2,
            MEMORY_AREA_MU1_DUKE3,
            MEMORY_AREA_MU2_DUKE3,
            MEMORY_AREA_MU1_DUKE4,
            MEMORY_AREA_MU2_DUKE4
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_SOME_DATA );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SOURCE_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SOURCE_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_COPY );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );
        pStepsLog->AddStep( STEP_REMOVE_HARDWARE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );

        // For each memory area in our list
        for( size_t memArea = 0; memArea < ARRAYSIZE( MAToUse ); ++memArea )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Source/Hardware to Remove %s", xlogVariationNum, gc_lpwszMEM_AREAS[MAToUse[memArea]] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );

            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD CopySingleSGFromMDToMD( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a user copies a single saved game from 
        // one MD to another MD, it works as expected.
        //////////////////////////////////////////////////////////////////////////

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_SOURCE_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_SETUP_DEST_MEM_AREA_ENOUGH_SPACE );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SOURCE_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SOURCE_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEST_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_COMPLETED );
        pStepsLog->AddStep( STEP_VERIFY_SOURCE_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SELECTION );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEST_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_DEST_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CORRECT_FILES_EXIST );

        // From each Memory Device (area)
        for( size_t fromMD = 0; fromMD < ARRAYSIZE( gc_lpwszMEM_AREAS ); ++fromMD )
        {
            // To each Memory Device (area)
            for( size_t toMD = 0; toMD < ARRAYSIZE( gc_lpwszMEM_AREAS ); ++toMD )
            {
                // If the "TO" memory area is the same as the "From", don't log/perform this test
                if( fromMD != toMD )
                {
                    // For each game variation
                    for( size_t gameVar = 0; gameVar < ARRAYSIZE( gc_lpwszSINGLE_SAVED_GAME_CONFIGS ); ++gameVar )
                    {
                        _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                        _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: FROM %s to %s, Game Variation: %s", xlogVariationNum, gc_lpwszMEM_AREAS[fromMD], gc_lpwszMEM_AREAS[toMD], gc_lpwszSINGLE_SAVED_GAME_CONFIGS[gameVar] );

                        // Log the test case variation to our Steps File
                        pStepsLog->AddVariation( stepsVariation );

                        TESTCASE( xlogVariation )
                        {
                            TESTMNUL( hLog, "Manual Test" );
                        } ENDTESTCASE;
                    }
                }
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD CopySingleSGFromMDToMDPowerOff( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a user copies a single saved game from 
        // one MD to another MD, and they press the XBox power button, that the
        // copy operation is completed.
        //////////////////////////////////////////////////////////////////////////

        // A sub-list of possible memory areas to copy to / from for this
        // test case
        CopyFromToMD MDCopyList[] = {
            { MEMORY_AREA_MU1_DUKE1, MEMORY_AREA_XDISK },
            { MEMORY_AREA_XDISK,     MEMORY_AREA_MU1_DUKE1 }
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_IN_VAR_TWO_SAVED_GAMES );
        pStepsLog->AddStep( STEP_SETUP_DEST_MEM_AREA_ENOUGH_SPACE );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SOURCE_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SOURCE_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEST_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_STARTED );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_XBOX_POWERED_OFF );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEST_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_DEST_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CORRECT_FILES_EXIST );

        // For each memory area from/to combination available
        for( size_t currentCopy = 0; currentCopy < ARRAYSIZE( MDCopyList ); ++currentCopy )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: SOURCE MD %s, DEST MD: %s", xlogVariationNum, gc_lpwszMEM_AREAS[MDCopyList[currentCopy].FromMD], gc_lpwszMEM_AREAS[MDCopyList[currentCopy].ToMD] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );

            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD CopySingleSGFromMDToMDPullsPlug( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a user copies a single saved game from 
        // one MD to another MD, and they pull the plug on the XBox, that the
        // destination either doesn't contain the files, or the files that
        // were being copied are marked bad and can be deleted without harming
        // other files.
        //////////////////////////////////////////////////////////////////////////

        // A sub-list of possible memory areas to copy to / from for this
        // test case
        CopyFromToMD MDCopyList[] = {
            { MEMORY_AREA_MU1_DUKE1, MEMORY_AREA_XDISK },
            { MEMORY_AREA_XDISK,     MEMORY_AREA_MU1_DUKE1 }
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_IN_VAR_TWO_SAVED_GAMES );
        pStepsLog->AddStep( STEP_SETUP_DEST_MEM_AREA_ENOUGH_SPACE );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SOURCE_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SOURCE_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEST_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_STARTED );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_REMOVE_POWER_PLUG_FROM_XBOX );
        pStepsLog->AddStep( STEP_VERIFY_XBOX_POWERED_OFF );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEST_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_DEST_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_DEST_MEM_AREA_FILES_OK );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAMES_MARKED_BAD );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_DELETE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_DELETE_DIALOG );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );
        pStepsLog->AddStep( STEP_VERIFY_CORRECT_FILES_EXIST );

        // For each memory area from/to combination available
        for( size_t currentCopy = 0; currentCopy < ARRAYSIZE( MDCopyList ); ++currentCopy )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: SOURCE MD %s, DEST MD: %s", xlogVariationNum, gc_lpwszMEM_AREAS[MDCopyList[currentCopy].FromMD], gc_lpwszMEM_AREAS[MDCopyList[currentCopy].ToMD] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );

            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }

        return 0;
    };

    
    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD CopySingleSGAllUnitsFull( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a user tries to copy a game, and all
        // Memory Areas are full, things work as expected.
        //////////////////////////////////////////////////////////////////////////

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_XBOX_PORTS_DUKE_M_M );
        pStepsLog->AddStep( STEP_SETUP_ALL_MEM_UNITS_FULL );
        pStepsLog->AddStep( STEP_SETUP_XDISK_SOME_DATA );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SOURCE_MEM_AREA_XDISK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SOURCE_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEM_AREA_EACH_MU );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_NOT_ALLOWED );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );

        TESTCASE( "" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD CopySingleSGAllUnitsFullHSFull( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a user tries to copy a game, and all
        // Memory Areas are full, and they hot-swap an MU with another FULL unit,
        // that they are not allowed to select it.
        //////////////////////////////////////////////////////////////////////////

        // Memory Areas to swap out
        enum MemoryAreasWithinList MAToUse [] = {
            MEMORY_AREA_MU1_DUKE1,
            MEMORY_AREA_MU2_DUKE4
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_XBOX_PORTS_DUKE_M_M );
        pStepsLog->AddStep( STEP_SETUP_ALL_MEM_UNITS_FULL );
        pStepsLog->AddStep( STEP_SETUP_XDISK_SOME_DATA );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SOURCE_MEM_AREA_XDISK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SOURCE_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );
        pStepsLog->AddStep( STEP_REMOVE_HARDWARE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );
        pStepsLog->AddStep( STEP_INSERT_HARDWARE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );
        pStepsLog->AddStep( STEP_SELECT_DEST_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_NOT_ALLOWED );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );

        // For each Memory Unit Memory Area we wish to try
        for( size_t memArea = 0; memArea < ARRAYSIZE( MAToUse ); ++memArea )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: FROM XDisk to %s, Remove FULL %s, Insert FULL %s", xlogVariationNum, gc_lpwszMEM_AREAS[MAToUse[memArea]], gc_lpwszMEM_AREAS[MAToUse[memArea]], gc_lpwszMEM_AREAS[MAToUse[memArea]] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );

            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD CopySingleSGAllUnitsFullHSEmpty( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a user tries to copy a game, and all
        // Memory Areas are full, and they hot-swap an MU that's empty, that they
        // are allowed to save the game to that MU
        //////////////////////////////////////////////////////////////////////////

        // Memory Areas to swap out
        enum MemoryAreasWithinList MAToUse [] = {
            MEMORY_AREA_MU1_DUKE1,
            MEMORY_AREA_MU2_DUKE4
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_XBOX_PORTS_DUKE_M_M );
        pStepsLog->AddStep( STEP_SETUP_ALL_MEM_UNITS_FULL );
        pStepsLog->AddStep( STEP_SETUP_XDISK_SOME_DATA );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SOURCE_MEM_AREA_XDISK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SOURCE_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );
        pStepsLog->AddStep( STEP_REMOVE_HARDWARE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );
        pStepsLog->AddStep( STEP_INSERT_MEM_UNIT_EMPTY );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );
        pStepsLog->AddStep( STEP_SELECT_MEM_AREA_EMPTY );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_COMPLETED );
        pStepsLog->AddStep( STEP_VERIFY_SOURCE_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SELECTION );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEST_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_DEST_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CORRECT_FILES_EXIST );

        // For each Memory Unit Memory Area we wish to try
        for( size_t memArea = 0; memArea < ARRAYSIZE( MAToUse ); ++memArea )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: FROM XDisk to %s, Remove FULL %s, Insert Empty (DEST) %s", xlogVariationNum, gc_lpwszMEM_AREAS[MAToUse[memArea]], gc_lpwszMEM_AREAS[MAToUse[memArea]], gc_lpwszMEM_AREAS[MAToUse[memArea]] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );

            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD CopySingleSGHSFullEmptyFull( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a user tries to copy a game, and all
        // Memory Areas are full, and they hot swap an empty MU, then HS a full
        // MU in it's place, that they aren't allowed to use that MU
        //////////////////////////////////////////////////////////////////////////

        // Memory Areas to swap out
        enum MemoryAreasWithinList MAToUse [] = {
            MEMORY_AREA_MU1_DUKE1,
            MEMORY_AREA_MU2_DUKE4
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_XBOX_PORTS_DUKE_M_M );
        pStepsLog->AddStep( STEP_SETUP_ALL_MEM_UNITS_FULL );
        pStepsLog->AddStep( STEP_SETUP_XDISK_SOME_DATA );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SOURCE_MEM_AREA_XDISK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SOURCE_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );
        pStepsLog->AddStep( STEP_REMOVE_HARDWARE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );
        pStepsLog->AddStep( STEP_INSERT_MEM_UNIT_EMPTY );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );
        pStepsLog->AddStep( STEP_REMOVE_HARDWARE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_INSERT_MEM_UNIT_FULL );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );
        pStepsLog->AddStep( STEP_SELECT_DEST_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_NOT_ALLOWED );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );

        // For each Memory Unit Memory Area we wish to try
        for( size_t memArea = 0; memArea < ARRAYSIZE( MAToUse ); ++memArea )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: FROM XDisk to %s, Remove FULL %s, Insert Empty (DEST) %s", xlogVariationNum, gc_lpwszMEM_AREAS[MAToUse[memArea]], gc_lpwszMEM_AREAS[MAToUse[memArea]], gc_lpwszMEM_AREAS[MAToUse[memArea]] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );

            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD CopyMultipleSGsFromMDToMD( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a user copies multiple saved games from 
        // one MD to another MD, it works as expected.
        //////////////////////////////////////////////////////////////////////////

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_SOURCE_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_SETUP_DEST_MEM_AREA_ENOUGH_SPACE );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SOURCE_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SOURCE_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEST_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_COMPLETED );
        pStepsLog->AddStep( STEP_VERIFY_SOURCE_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SELECTION );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEST_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_DEST_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CORRECT_FILES_EXIST );

        // From each Memory Device (area)
        for( size_t fromMD = 0; fromMD < ARRAYSIZE( gc_lpwszMEM_AREAS ); ++fromMD )
        {
            // To each Memory Device (area)
            for( size_t toMD = 0; toMD < ARRAYSIZE( gc_lpwszMEM_AREAS ); ++toMD )
            {
                // If the "TO" memory area is the same as the "From", don't log/perform this test
                if( fromMD != toMD )
                {
                    // For each game variation
                    for( size_t gameVar = 0; gameVar < ARRAYSIZE( gc_lpwszMULTIPLE_SAVED_GAME_CONFIGS ); ++gameVar )
                    {
                        _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                        _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: FROM %s to %s, Game Variation: %s", xlogVariationNum, gc_lpwszMEM_AREAS[fromMD], gc_lpwszMEM_AREAS[toMD], gc_lpwszMULTIPLE_SAVED_GAME_CONFIGS[gameVar] );

                        // Log the test case variation to our Steps File
                        pStepsLog->AddVariation( stepsVariation );

                        TESTCASE( xlogVariation )
                        {
                            TESTMNUL( hLog, "Manual Test" );
                        } ENDTESTCASE;
                    }
                }
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD CopySingleSGFileVerification( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a user copies a single saved game from 
        // one type of MD to each other type of MD, it works as expected, and
        // the file is inspected for correctness.
        //////////////////////////////////////////////////////////////////////////

        // A sub-list of possible memory areas to copy to / from for this
        // test case
        CopyFromToMD MDCopyList[] = {
            { MEMORY_AREA_MU1_DUKE1, MEMORY_AREA_MU1_DUKE2 },
            { MEMORY_AREA_MU1_DUKE1, MEMORY_AREA_XDISK },
            { MEMORY_AREA_XDISK,     MEMORY_AREA_MU1_DUKE2 }
        };


        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_SOURCE_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_SETUP_DEST_MEM_AREA_ENOUGH_SPACE );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SOURCE_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SOURCE_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEST_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_COMPLETED );
        pStepsLog->AddStep( STEP_VERIFY_SOURCE_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SELECTION );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEST_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_DEST_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CORRECT_FILES_EXIST );
        pStepsLog->AddStep( STEP_PERFORM_FILE_COMPARE_ACCORD_TO_VAR );

        // For each memory area from/to combination available
        for( size_t currentCopy = 0; currentCopy < ARRAYSIZE( MDCopyList ); ++currentCopy )
        {
            // For each type of saved game possible
            for( size_t blockConfig = 0; blockConfig < ARRAYSIZE( gc_lpwszMEM_AREA_BLOCK_CONFIGS ); ++blockConfig )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: FROM %s to %s, Game Variation: 1 saved game - %s", xlogVariationNum, gc_lpwszMEM_AREAS[MDCopyList[currentCopy].FromMD], gc_lpwszMEM_AREAS[MDCopyList[currentCopy].ToMD], gc_lpwszMEM_AREA_BLOCK_CONFIGS[blockConfig] );

                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( stepsVariation );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD CopyMultipleSGsFileVerification( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a user copies multiple saved games from 
        // one type of MD to each other type of MD, it works as expected, and
        // the file is inspected for correctness.
        //////////////////////////////////////////////////////////////////////////

        // A sub-list of possible memory areas to copy to / from for this
        // test case
        CopyFromToMD MDCopyList[] = {
            { MEMORY_AREA_MU1_DUKE1, MEMORY_AREA_MU1_DUKE2 },
            { MEMORY_AREA_MU1_DUKE1, MEMORY_AREA_XDISK },
            { MEMORY_AREA_XDISK,     MEMORY_AREA_MU1_DUKE2 }
        };


        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_SOURCE_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_SETUP_DEST_MEM_AREA_ENOUGH_SPACE );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SOURCE_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SOURCE_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEST_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_COMPLETED );
        pStepsLog->AddStep( STEP_VERIFY_SOURCE_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SELECTION );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEST_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_DEST_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CORRECT_FILES_EXIST );
        pStepsLog->AddStep( STEP_PERFORM_FILE_COMPARE_ACCORD_TO_VAR );

        // For each memory area from/to combination available
        for( size_t currentCopy = 0; currentCopy < ARRAYSIZE( MDCopyList ); ++currentCopy )
        {
            // For each type of saved game possible
            for( size_t blockConfig = 0; blockConfig < ARRAYSIZE( gc_lpwszMEM_AREA_BLOCK_CONFIGS ); ++blockConfig )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: FROM %s to %s, Game Variation: 2+ saved games - %s", xlogVariationNum, gc_lpwszMEM_AREAS[MDCopyList[currentCopy].FromMD], gc_lpwszMEM_AREAS[MDCopyList[currentCopy].ToMD], gc_lpwszMEM_AREA_BLOCK_CONFIGS[blockConfig] );

                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( stepsVariation );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD MemCopyDukeMUVarsDisplay( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This case verifies that the Memory Copy main screen displays
        // properly with variations of Dukes and MUs.
        //
        // It also ensures that Dukes and MUs can be Hot-Plugged on this screen,
        // and it will behave as expected.
        //////////////////////////////////////////////////////////////////////////

        size_t testVariationNum = 0;                        // The Variation Number of the test we are running
        WCHAR portConfiguration[VARIATION_BUFFER_SIZE];     // The String representation of the XBox Port Configuration we'll be using
        WCHAR testVariation[VARIATION_BUFFER_SIZE];         // The String representation holding the variation number we are running

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SETUP_XBOX_PORTS_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );

        for (size_t port1 = 0; port1 < ARRAYSIZE(validDukeAndMUConfigs); port1++)
        {
            for (size_t port2 = 0; port2 < ARRAYSIZE(validDukeAndMUConfigs); port2++)
            {
                for (size_t port3 = 0; port3 < ARRAYSIZE(validDukeAndMUConfigs); port3++)
                {
                    for (size_t port4 = 0; port4 < ARRAYSIZE(validDukeAndMUConfigs); port4++)
                    {
                        _snwprintf( testVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++testVariationNum );
                        _snwprintf( portConfiguration, VARIATION_BUFFER_SIZE, L"Variation %d: %s, %s, %s, %s", testVariationNum, validDukeAndMUConfigs[port1], validDukeAndMUConfigs[port2], validDukeAndMUConfigs[port3], validDukeAndMUConfigs[port4]);
  
                        // Log the test case variation to our Steps File
                        pStepsLog->AddVariation( portConfiguration );

                        TESTCASE( testVariation )
                        {
                            TESTMNUL( hLog, "Manual Test" );
                        } ENDTESTCASE;
                    }
                }
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD MemCopyDukeHotPlugVarsDisplay( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This case verifies that the Memory Copy main screen displays
        // properly with variations of Dukes and MUs.
        //
        // It also ensures that Dukes can be Hot-Plugged on this screen,
        // and it will behave as expected.
        //////////////////////////////////////////////////////////////////////////

        enum PortConfigurationsWithinList dukeSetup[] = {
            DUKE_E_E,
            DUKE_M_E,
            DUKE_E_M,
            DUKE_M_M
        };

        size_t testVariationNum = 0;                        // The Variation Number of the test we are running
        WCHAR portConfiguration[VARIATION_BUFFER_SIZE];     // The String representation of the XBox Port Configuration we'll be using
        WCHAR testVariation[VARIATION_BUFFER_SIZE];         // The String representation holding the variation number we are running

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_DEFAULT_DUKE_SOME_DATA );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEM_AREA_DEFAULT_DUKE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_COPY );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );
        pStepsLog->AddStep( STEP_SKIP_VARS_BASED_ON_DEFAULT_DUKE );
        pStepsLog->AddStep( STEP_INSERT_HARDWARE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );
        pStepsLog->AddStep( STEP_REMOVE_HARDWARE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );

        // Plug in Dukes (all ports) that have both MA slots used
        _snwprintf( testVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++testVariationNum );
        _snwprintf( portConfiguration, VARIATION_BUFFER_SIZE, L"Variation %d: ALL XBox Ports, Duke Variation: %s", testVariationNum, validDukeAndMUConfigs[DUKE_M_M] );

        // Log the test case variation to our Steps File
        pStepsLog->AddVariation( portConfiguration );

        TESTCASE( testVariation )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;


        // Plug in Dukes (all ports) that are empty (No MA slots used)
        _snwprintf( testVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++testVariationNum );
        _snwprintf( portConfiguration, VARIATION_BUFFER_SIZE, L"Variation %d: ALL XBox Ports, Duke Variation: %s", testVariationNum, validDukeAndMUConfigs[DUKE_E_E] );

        // Log the test case variation to our Steps File
        pStepsLog->AddVariation( portConfiguration );

        TESTCASE( testVariation )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;

    
        // For each individual port on the XBox
        for ( size_t xboxPort = 1; xboxPort <= gc_nNUM_XBOX_PORTS; ++xboxPort )
        {
            // For each Duke Variations available to a port
            for ( size_t dukeVariation = 0; dukeVariation < ARRAYSIZE( dukeSetup ); ++dukeVariation )
            {
                _snwprintf( testVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++testVariationNum );
                _snwprintf( portConfiguration, VARIATION_BUFFER_SIZE, L"Variation %d: XBox Port %d, Duke Variation: %s", testVariationNum, xboxPort, validDukeAndMUConfigs[dukeSetup[dukeVariation]] );
  
                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( portConfiguration );

                TESTCASE( testVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD MemCopyMUHotPlugVarsDisplay( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This case verifies that the Memory Copy main screen displays
        // properly with variations of MUs within Dukes.
        //
        // It also ensures that MUs can be Hot-Plugged on this screen,
        // and it will behave as expected.
        //////////////////////////////////////////////////////////////////////////

        size_t testVariationNum = 0;                        // The Variation Number of the test we are running
        WCHAR portConfiguration[VARIATION_BUFFER_SIZE];     // The String representation of the XBox Port Configuration we'll be using
        WCHAR testVariation[VARIATION_BUFFER_SIZE];         // The String representation holding the variation number we are running

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_DEFAULT_DUKE_SOME_DATA );
        pStepsLog->AddStep( STEP_SETUP_XBOX_PORTS_DUKE_E_E );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEM_AREA_DEFAULT_DUKE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_COPY );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );
        pStepsLog->AddStep( STEP_SKIP_VARS_BASED_ON_DEFAULT_DUKE );
        pStepsLog->AddStep( STEP_INSERT_HARDWARE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );
        pStepsLog->AddStep( STEP_REMOVE_HARDWARE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );

        // Plug in MU's (all Dukes, all ports) that have both MA slots used
        _snwprintf( testVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++testVariationNum );
        _snwprintf( portConfiguration, VARIATION_BUFFER_SIZE, L"Variation %d: Insert MU's in to EACH Duke slot on ALL Dukes", testVariationNum );

        // Log the test case variation to our Steps File
        pStepsLog->AddVariation( portConfiguration );

        TESTCASE( testVariation )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;

        // For each individual port on the XBox
        for( size_t xboxPort = 1; xboxPort <= gc_nNUM_XBOX_PORTS; ++xboxPort )
        {
            // For each Duke slot in each Duke
            for( size_t dukeSlot = 1; dukeSlot <= gc_nNUM_DUKE_SLOTS; ++dukeSlot )
            {
                _snwprintf( testVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++testVariationNum );
                _snwprintf( portConfiguration, VARIATION_BUFFER_SIZE, L"Variation %d: Memory Unit in Duke slot %d of the Duke in Port %d", testVariationNum, dukeSlot, xboxPort );
  
                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( portConfiguration );

                TESTCASE( testVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD MemCopyMDVariousSizesDisplay( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This case verifies that the Memory Copy main screen displays
        // properly with Memory Area that are filled with various amounts of
        // data.  It verifies that the information displayed when you
        // "highlight" on of these areas is displayed correctly.
        //////////////////////////////////////////////////////////////////////////

        size_t testVariationNum = 0;                        // The Variation Number of the test we are running
        WCHAR deviceConfiguration[VARIATION_BUFFER_SIZE];   // The String representation of the XBox Device Configuration we'll be using
        WCHAR testVariation[VARIATION_BUFFER_SIZE];         // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_DEFAULT_DUKE_SOME_DATA );
        pStepsLog->AddStep( STEP_SKIP_VARS_BASED_ON_DEFAULT_DUKE );
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEM_AREA_DEFAULT_DUKE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_COPY );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );

        // Xdisk verified with each MD block configuration
        for( size_t blockConfig = 0; blockConfig < ARRAYSIZE( gc_lpwszMEM_AREA_BLOCK_CONFIGS ); ++blockConfig )
        {
            _snwprintf( testVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++testVariationNum );
            _snwprintf( deviceConfiguration, VARIATION_BUFFER_SIZE, L"Variation %d: Xdisk, MemArea Block Configuration: %s", testVariationNum, gc_lpwszMEM_AREA_BLOCK_CONFIGS[blockConfig] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( deviceConfiguration );

            TESTCASE( testVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }


        // All Dukes in all ports, and each port on each Duke tested with the MD block configurations
        for( size_t port = 1; port <= gc_nNUM_XBOX_PORTS; ++port )
        {
            for( size_t dukeSlot = 1; dukeSlot <= gc_nNUM_DUKE_SLOTS; ++dukeSlot )
            {
                for( size_t blockConfig = 0; blockConfig < ARRAYSIZE( gc_lpwszMEM_AREA_BLOCK_CONFIGS ); ++blockConfig )
                {
                    _snwprintf( testVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++testVariationNum );
                    _snwprintf( deviceConfiguration, VARIATION_BUFFER_SIZE, L"Variation %d: Port: %d, Duke slot: %d, MemArea Block Configuration: %s", testVariationNum, port, dukeSlot, gc_lpwszMEM_AREA_BLOCK_CONFIGS[blockConfig] );
  
                    // Log the test case variation to our Steps File
                    pStepsLog->AddVariation( deviceConfiguration );

                    TESTCASE( testVariation )
                    {
                        TESTMNUL( hLog, "Manual Test" );
                    } ENDTESTCASE;
                }
            }
        }

        return 0;
    };



    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD MemCopyDestMUNotEnoughRoom( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This case verifies that the Memory Copy main screen displays
        // a Memory Area that does not have enough space to hold the saved
        // game being copied is displayed (marked) properly, and that that
        // Memory Area cannot be selected.
        //////////////////////////////////////////////////////////////////////////

        size_t testVariationNum = 0;                        // The Variation Number of the test we are running
        WCHAR deviceConfiguration[VARIATION_BUFFER_SIZE];   // The String representation of the XBox Device Configuration we'll be using
        WCHAR testVariation[VARIATION_BUFFER_SIZE];         // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SKIP_VARS_BASED_ON_DEFAULT_DUKE );
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_DEFAULT_DUKE_SOME_DATA );
        pStepsLog->AddStep( STEP_SETUP_DEST_MEM_AREA_NOT_ENOUGH_SPACE );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEM_AREA_DEFAULT_DUKE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_COPY );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_DEST_MEM_AREA_MARKED_INVALID );
        pStepsLog->AddStep( STEP_SELECT_DEST_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_NOT_ALLOWED );

        // For each Memory Area available on the XBox
        for( size_t memArea = 0; memArea < ARRAYSIZE( gc_lpwszMEM_AREAS ); ++memArea )
        {
            _snwprintf( testVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++testVariationNum );
            _snwprintf( deviceConfiguration, VARIATION_BUFFER_SIZE, L"Variation %d: Destination Memory Area: %s", testVariationNum, gc_lpwszMEM_AREAS[memArea] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( deviceConfiguration );

            TESTCASE( testVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }

        // Xdisk verified with each MD block configuration
        for( size_t blockConfig = 0; blockConfig < ARRAYSIZE( gc_lpwszMEM_AREA_BLOCK_CONFIGS ); ++blockConfig )
        {
            _snwprintf( testVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++testVariationNum );
            _snwprintf( deviceConfiguration, VARIATION_BUFFER_SIZE, L"Variation %d: Xdisk, MemArea Block Configuration: %s", testVariationNum, gc_lpwszMEM_AREA_BLOCK_CONFIGS[blockConfig] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( deviceConfiguration );

            TESTCASE( testVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }


        // All Dukes in all ports, and each port on each Duke tested with the MD block configurations
        for( size_t port = 1; port <= gc_nNUM_XBOX_PORTS; ++port )
        {
            for( size_t dukeSlot = 1; dukeSlot <= gc_nNUM_DUKE_SLOTS; ++dukeSlot )
            {
                for( size_t blockConfig = 0; blockConfig < ARRAYSIZE( gc_lpwszMEM_AREA_BLOCK_CONFIGS ); ++blockConfig )
                {
                    _snwprintf( testVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++testVariationNum );
                    _snwprintf( deviceConfiguration, VARIATION_BUFFER_SIZE, L"Variation %d: Port: %d, Duke slot: %d, MemArea Block Configuration: %s", testVariationNum, port, dukeSlot, gc_lpwszMEM_AREA_BLOCK_CONFIGS[blockConfig] );
  
                    // Log the test case variation to our Steps File
                    pStepsLog->AddVariation( deviceConfiguration );

                    TESTCASE( testVariation )
                    {
                        TESTMNUL( hLog, "Manual Test" );
                    } ENDTESTCASE;
                }
            }
        }

        return 0;
    };



    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD MemCopyTitleSingleSGDisplay( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a user selects a single saved game
        // and tries to copy it, that the title of the "XBox saved game copy"
        // screen is displayed appropriately.
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_XDISK
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_IN_VAR_TWO_SAVED_GAMES );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SOURCE_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_COPY );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_TITLE_FROM_PARENT );
        pStepsLog->AddStep( STEP_VERIFY_DISPLAY_PROPERLY_WRAPPING);
        pStepsLog->AddStep( STEP_VERIFY_TEXT_NOT_CLIPPED);

        // For each memory area available
        for( size_t currentMemArea=0; currentMemArea < ARRAYSIZE( memDevices ); ++currentMemArea )
        {
            // SAVED GAME META: Variations in the name of the game that a saved game is from (Parent game)
            for( size_t sgParentName = 0; sgParentName < ARRAYSIZE( gc_lpwszMETA_SAVED_GAME_PARENT_NAME_CONFIGS ); ++sgParentName )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Select a SINGLE game from Memory Area %s, Saved Game's Parent Name: %s", xlogVariationNum, gc_lpwszMEM_AREAS[currentMemArea], gc_lpwszMETA_SAVED_GAME_PARENT_NAME_CONFIGS[sgParentName] );

                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( stepsVariation );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD MemCopyTitleMultipleSGDisplay( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a user selects multiple saved games
        // that the title of the "XBox saved game copy" screen is displayed
        // appropriately.
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_XDISK
        };

        // Subset of the generic saved game selections we want to make
        enum SavedGamesGenericWithinList genSGs[] = {
            SAVED_GAMES_MULTIPLE,
            SAVED_GAMES_ALL
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_IN_VAR_MAX_SAVED_GAMES );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SOURCE_MEM_AREA_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_COPY );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SAVED_GAME_COPY_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_TITLE_CORRECT_NUM_GAMES_SELECTED );
        pStepsLog->AddStep( STEP_VERIFY_DISPLAY_PROPERLY_WRAPPING);
        pStepsLog->AddStep( STEP_VERIFY_TEXT_NOT_CLIPPED);

        // For each memory area available
        for( size_t currentMemArea = 0; currentMemArea < ARRAYSIZE( memDevices ); ++currentMemArea )
        {
            // For each generic saved game config in our subset
            for( size_t sgConfig = 0; sgConfig < ARRAYSIZE( genSGs ); ++sgConfig )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Select games from Memory Area: %s, Saved Games to Select: %s", xlogVariationNum, gc_lpwszMEM_AREAS[currentMemArea], gc_lpwszGENERIC_SAVED_GAME_CONFIGS[genSGs[sgConfig]] );

                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( stepsVariation );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD BootToMemCleanUpMAFullDisplay( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a title boots the user in to memory
        // management clean-up mode, the display is OK when the title requests
        // various amounts of space free when all Mem Areas are empty.
        //////////////////////////////////////////////////////////////////////////

        // Memory area block configurations to use for this test case
        enum MemoryAreaBlockConfigsWithinList BlockConfigsToUse[] = {
            MEMORY_BLOCK_CONFIG_1_BLOCK,
            MEMORY_BLOCK_CONFIG_HALF_BLOCKS,
            MEMORY_BLOCK_CONFIG_MAX_MINUS_1_BLOCKS,
            MEMORY_BLOCK_CONFIG_MAX__BLOCKS,
            MEMORY_BLOCK_CONFIG_MAX_PLUS_1_BLOCKS
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_ALL_MEM_AREAS_FULL );
        pStepsLog->AddStep( STEP_INSERT_DVD_GAME_MEM_CLEANUP );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_SELECT_MEM_AREA_BLOCK_CONFIG_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_CLEANUP );
        pStepsLog->AddStep( STEP_VERIFY_DISPLAY_PROPERLY_WRAPPING);
        pStepsLog->AddStep( STEP_VERIFY_TEXT_NOT_CLIPPED);

        // For each memory block configuration available
        for( size_t blockConfig = 0; blockConfig < ARRAYSIZE( BlockConfigsToUse ); ++blockConfig )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Title Should Request: %s", xlogVariationNum, gc_lpwszMEM_AREA_BLOCK_CONFIGS[BlockConfigsToUse[blockConfig]] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );

            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }

        return 0;
    };

    
    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD BootToMemCleanUpMAEmptyDisplay( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a title boots the user in to memory
        // management clean-up mode, and specifies any amount of space needed
        // when all memory areas are empty, that they are NOT placed in to
        // Memory Management clean-up mode.
        //////////////////////////////////////////////////////////////////////////

        // Memory area block configurations to use for this test case
        enum MemoryAreaBlockConfigsWithinList BlockConfigsToUse[] = {
            MEMORY_BLOCK_CONFIG_0_BLOCKS,
            MEMORY_BLOCK_CONFIG_1_BLOCK,
            MEMORY_BLOCK_CONFIG_MAX_MINUS_1_BLOCKS,
            MEMORY_BLOCK_CONFIG_MAX__BLOCKS
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_ALL_MEM_AREAS_EMPTY );
        pStepsLog->AddStep( STEP_INSERT_DVD_GAME_MEM_CLEANUP );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_SELECT_MEM_AREA_BLOCK_CONFIG_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_NOT_CLEANUP );

        // For each memory block configuration available
        for( size_t blockConfig = 0; blockConfig < ARRAYSIZE( BlockConfigsToUse ); ++blockConfig )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Title Should Request: %s", xlogVariationNum, gc_lpwszMEM_AREA_BLOCK_CONFIGS[BlockConfigsToUse[blockConfig]] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );

            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD BootToMemCleanUpMAFull0blocks( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a title boots the user in to memory
        // management clean-up mode and requests 0 blocks of space, and all
        // memory areas are FULL, that they are NOT placed in to memory
        // managment clean-up mode.
        //////////////////////////////////////////////////////////////////////////

        // Memory area block configurations to use for this test case
        enum MemoryAreaBlockConfigsWithinList BlockConfigsToUse[] = {
            MEMORY_BLOCK_CONFIG_0_BLOCKS
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_ALL_MEM_AREAS_FULL );
        pStepsLog->AddStep( STEP_INSERT_DVD_GAME_MEM_CLEANUP );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_SELECT_MEM_AREA_BLOCK_CONFIG_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_NOT_CLEANUP );

        // For each memory block configuration available
        for( size_t blockConfig = 0; blockConfig < ARRAYSIZE( BlockConfigsToUse ); ++blockConfig )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Title Should Request: %s", xlogVariationNum, gc_lpwszMEM_AREA_BLOCK_CONFIGS[BlockConfigsToUse[blockConfig]] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );

            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }

        return 0;
    };

    
    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD BootToMemCleanUpMAFullDeleteAll( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a title boots the user in to memory
        // management clean-up mode and requests x blocks of space, all
        // memory areas are FULL, and the user deletes all files off the memory
        // area, that they are taken out of clean-up mode
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_MU1_DUKE1,
            MEMORY_AREA_XDISK
        };

        // Memory area block configurations to use for this test case
        enum MemoryAreaBlockConfigsWithinList BlockConfigsToUse[] = {
            MEMORY_BLOCK_CONFIG_1_BLOCK,
            MEMORY_BLOCK_CONFIG_HALF_BLOCKS,
            MEMORY_BLOCK_CONFIG_MAX_MINUS_1_BLOCKS,
            MEMORY_BLOCK_CONFIG_MAX__BLOCKS,
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_ALL_MEM_AREAS_FULL );
        pStepsLog->AddStep( STEP_INSERT_DVD_GAME_MEM_CLEANUP );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_SELECT_MEM_AREA_BLOCK_CONFIG_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_CLEANUP );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME_ALL );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_DELETE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_DELETE_DIALOG );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_NOT_CLEANUP );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_NOT_CLEANUP );

        // For each memory device we wish to try
        for( size_t memDevice = 0; memDevice < ARRAYSIZE( memDevices ); ++memDevice )
        {
            // For each memory block configuration available
            for( size_t blockConfig = 0; blockConfig < ARRAYSIZE( BlockConfigsToUse ); ++blockConfig )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: TITLE SHOULD REQUEST: %s, MEM AREA TO USE: %s", xlogVariationNum, gc_lpwszMEM_AREA_BLOCK_CONFIGS[BlockConfigsToUse[blockConfig]], gc_lpwszMEM_AREAS[memDevices[memDevice]] );

                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( stepsVariation );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };
    
    
    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD BootToMemCleanUpClearSpace( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a title boots the user in to memory
        // management clean-up mode and requests x blocks of space, the user
        // can delete some files and the XDash will take them OUT of memory
        // management clean-up mode.  (The user will first delete a file and
        // NOT be taken out of clean up mode, and then then will delete another
        // file, and WILL be taken out of clean up mode)
        //////////////////////////////////////////////////////////////////////////

        // Used to setup the variations for this test
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_MU1_DUKE1,
            MEMORY_AREA_XDISK
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_MEM_AREA_MAX_SAVED_GAMES_1_BLOCK_EACH );
        pStepsLog->AddStep( STEP_INSERT_DVD_GAME_MEM_CLEANUP );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_TITLE_SHOULD_REQUEST_MAX_MINUS_2_BLOCKS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_CLEANUP );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_DELETE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_DELETE_DIALOG );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_CLEANUP );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_CLEANUP );
        pStepsLog->AddStep( STEP_SELECT_DEVICE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SAVED_GAME );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_OPTIONS_DIALOG );
        pStepsLog->AddStep( STEP_SELECT_DELETE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_GAME_DELETE_DIALOG );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_DEVICE_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_UPDATED );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_NOT_CLEANUP );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_NOT_CLEANUP );

        // For each memory device we wish to try
        for( size_t memDevice = 0; memDevice < ARRAYSIZE( memDevices ); ++memDevice )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: MEM AREA TO USE: %s", xlogVariationNum, gc_lpwszMEM_AREAS[memDevices[memDevice]] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );

            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD BootToMemCleanUpHotSwapMA( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a title boots the user in to memory
        // management clean-up mode and all memory areas are full, the user can
        // hot-swap an empty MU and the XDash will take the user out of
        // clean-up mode.
        //////////////////////////////////////////////////////////////////////////

        // The MU to Hot-Swap
        enum MemoryAreasWithinList memDevices[] = {
            MEMORY_AREA_MU1_DUKE1,
            MEMORY_AREA_MU2_DUKE1,
            MEMORY_AREA_MU1_DUKE2,
            MEMORY_AREA_MU2_DUKE2,
            MEMORY_AREA_MU1_DUKE3,
            MEMORY_AREA_MU2_DUKE3,
            MEMORY_AREA_MU1_DUKE4,
            MEMORY_AREA_MU2_DUKE4
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_ALL_MEM_AREAS_FULL );
        pStepsLog->AddStep( STEP_INSERT_DVD_GAME_MEM_CLEANUP );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_TITLE_SHOULD_REQUEST_MAXBLOCKS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_CLEANUP );
        pStepsLog->AddStep( STEP_REMOVE_HARDWARE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_CLEANUP );
        pStepsLog->AddStep( STEP_INSERT_MEM_UNIT_1_SAVED_GAME_1_BLOCK );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_CLEANUP );
        pStepsLog->AddStep( STEP_REMOVE_HARDWARE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_INSERT_MEM_UNIT_EMPTY );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_NOT_CLEANUP );

        // For each memory device we wish to try
        for( size_t memDevice = 0; memDevice < ARRAYSIZE( memDevices ); ++memDevice )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: MEM UNIT TO USE: %s", xlogVariationNum, gc_lpwszMEM_AREAS[memDevices[memDevice]] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );

            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }

        return 0;
    };


    /*

    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object



    Return Value:

        DWORD -

    */
    DWORD BootToMemCleanUpNavAway( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a title boots the user in to memory
        // management clean-up mode, and they navigate AWAY from the memory
        // management area, that they are taken OUT of memory management
        // clean up mode.
        //////////////////////////////////////////////////////////////////////////

        // Setup the steps for this case
        pStepsLog->AddStep( STEP_SETUP_ALL_MEM_AREAS_FULL );
        pStepsLog->AddStep( STEP_INSERT_DVD_GAME_MEM_CLEANUP );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_TITLE_SHOULD_REQUEST_MAXBLOCKS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_CLEANUP );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_MEMORY_MANAGEMENT );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_MEMORY_MANAGEMENT_NOT_CLEANUP );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;

        return 0;
    };
}; // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\memory\xdashmemory.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    XDashMemory.h

Abstract:



Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-17-2000  Created

*/
#ifndef _XDASHMEMORY_H_
#define _XDASHMEMORY_H_

#define COMPONENT_NAME_W    L"XDashMemory"
#define COMPONENT_NAME_A    "XDashMemory"
#define DLL_NAME_W          L"XDashMemory"
#define DLL_NAME_A          "XDashMemory"

typedef DWORD ( *APITEST_FUNC )( HANDLE hLog, CStepsLog* pStepsLog );

#endif // _XDASHMEMORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\music\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\music\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
#define AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_

#if _MSC_VER > 1000
    #pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN         // Exclude rarely-used stuff from Windows headers
#endif

#ifndef UNICODE
    #define _UNICODE
    #define UNICODE
#endif

// Exclude rarely-used stuff from Windows headers
#define NTLEANANDMEAN
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_IA64_) && defined(_M_IX86)
#define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MRX000)
#define _MIPS_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_ALPHA)
#define _ALPHA_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_PPC)
#define _PPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_M68K)
#define _68K_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MPPC)
#define _MPPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_M_IX86) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <stdio.h>
#include <xtl.h>
#include <profilep.h>

#include "stepslog.h"
#include "xdashteststeps.h"
#include "commontest.h"
#include "environments.h"

extern "C"
{
        ULONG DebugPrint(PCHAR Format, ...);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\memory\xdashmemory.cpp ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    XDashMemory.cpp

Abstract:

    The DLL exports two of the mandatory APIs: StartTest and EndTest.
    TESTINI.INI must be modified correctly so that the
    harness will load and call StartTest/EndTest.

    Please see "x-box test harness.doc" for more information.

Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10/09/2000  Created

*/


#include <xlog.h>
#include "stdafx.h"
#include "XDashMemory.h"
#include "tests.h"

namespace xdashmemory
{
    static BOOL printSteps = true;

    /*

    Routine Description:


    Arguments:

        HANDLE hLog - to the logging object
        CStepsLog* pStepsLog - Object used to log our test steps

    Return Value:

        DWORD

    */
    DWORD XDashMemoryRunAll( HANDLE hLog, CStepsLog* pStepsLog )
    {
        struct APIFUNCT
        {
            APITEST_FUNC f;
            WCHAR *name;
            char *aname;
        };

        #define BUILTAPISTRUCT(n) { n , L#n , #n }

        // Define all the API tests
        APIFUNCT testlist[] =
        {
            /*
            */
            BUILTAPISTRUCT( MemColDukeMUVarsDisplay ),
            BUILTAPISTRUCT( MemColMDVariousSizesDisplay ),
            BUILTAPISTRUCT( MemColCannotSelectEmptyMD ),
            BUILTAPISTRUCT( MemAreaTitleDisplay ),
            BUILTAPISTRUCT( MemAreaFreeSpaceDisplay ),
            BUILTAPISTRUCT( MemAreaSGWrapping ),
            BUILTAPISTRUCT( MemAreaTitlesPerScreen ),
            BUILTAPISTRUCT( MemAreaGeneralDisplay ),
            BUILTAPISTRUCT( MemAreaHWDeviceRemoved ),
            BUILTAPISTRUCT( MemAreaSorting ),
            BUILTAPISTRUCT( MemAreaSavedGameMetaData ),
            BUILTAPISTRUCT( SavedGameTitleSingleSGDisplay ),
            BUILTAPISTRUCT( SavedGameTitleMultipleSGDisplay ),
            BUILTAPISTRUCT( SavedGameNavCancel ),
            BUILTAPISTRUCT( SavedGameNavCopy ),
            BUILTAPISTRUCT( DeleteOnlySavedGameFromMD ),
            BUILTAPISTRUCT( DeleteSingleSavedGameFromMD ),
            BUILTAPISTRUCT( DeleteGameRemovesGameProperMD ),
            BUILTAPISTRUCT( DeleteSingleGameFromMDPowerOff ),
            BUILTAPISTRUCT( DeleteSingleGameFromMDPullsPlug ),
            BUILTAPISTRUCT( DeleteMultipleSavedGamesFromMD ),
            BUILTAPISTRUCT( DeleteSavedGameNavConfirmCancel ),
            BUILTAPISTRUCT( DeleteTitleFromMD ),
            BUILTAPISTRUCT( DeleteTitleNavConfirmCancel ),
            BUILTAPISTRUCT( HWInsertedDuringOperation ),
            BUILTAPISTRUCT( HWRemovedDuringOperation ),
            BUILTAPISTRUCT( HWRemovedDuringOperationFail ),
            BUILTAPISTRUCT( HWSourceRemovedBeforeCopy ),
            BUILTAPISTRUCT( CopySingleSGFromMDToMD ),
            BUILTAPISTRUCT( CopySingleSGFromMDToMDPowerOff ),
            BUILTAPISTRUCT( CopySingleSGFromMDToMDPullsPlug ),
            BUILTAPISTRUCT( CopySingleSGAllUnitsFull ),
            BUILTAPISTRUCT( CopySingleSGAllUnitsFullHSFull ),
            BUILTAPISTRUCT( CopySingleSGAllUnitsFullHSEmpty ),
            BUILTAPISTRUCT( CopySingleSGHSFullEmptyFull ),
            BUILTAPISTRUCT( CopyMultipleSGsFromMDToMD ),
            BUILTAPISTRUCT( CopySingleSGFileVerification ),
            BUILTAPISTRUCT( CopyMultipleSGsFileVerification ), 
            BUILTAPISTRUCT( MemCopyDukeHotPlugVarsDisplay ),
            BUILTAPISTRUCT( MemCopyMUHotPlugVarsDisplay ),
            BUILTAPISTRUCT( MemCopyMDVariousSizesDisplay ),
            BUILTAPISTRUCT( MemCopyDestMUNotEnoughRoom ),
            BUILTAPISTRUCT( MemCopyTitleSingleSGDisplay ),
            BUILTAPISTRUCT( MemCopyTitleMultipleSGDisplay ),
            BUILTAPISTRUCT( BootToMemCleanUpMAFullDisplay ),
            BUILTAPISTRUCT( BootToMemCleanUpMAEmptyDisplay ),
            BUILTAPISTRUCT( BootToMemCleanUpMAFull0blocks ),
            BUILTAPISTRUCT( BootToMemCleanUpMAFullDeleteAll ),
            BUILTAPISTRUCT( BootToMemCleanUpClearSpace ),
            BUILTAPISTRUCT( BootToMemCleanUpHotSwapMA ),
            BUILTAPISTRUCT( BootToMemCleanUpNavAway )
            /*
            */
        };

        // Run the suite of tests

        // run each test
        for( size_t j = 0; j < ARRAYSIZE( testlist ); j++ )
        {
            xSetFunctionName(hLog, testlist[j].aname);
            DebugPrint( "%s: Entering test = '%ws()'\n", COMPONENT_NAME_A, testlist[j].name );

            // Log the testcase name to our steps log
            pStepsLog->SetCaseName( testlist[j].name );
            testlist[j].f( hLog, pStepsLog );

            // Log the test case (if the user wishes to)
            if ( printSteps )
            {
                pStepsLog->LogTestCase();
            }

            // Clear out the log for our next test
            pStepsLog->ClearTestCase();
        }

        return 0;
    }
}; // namespace


/*

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

*/
VOID WINAPI XDashMemoryStartTest( HANDLE hLog )
{
    using namespace xdashmemory;

    // test settings
    const int buffLen = 1024;
    
    char* ownerAlias     = new char[buffLen];
    char* componentMajor = new char[buffLen];
    char* componentMinor = new char[buffLen];
    char* stepsFileName  = new char[buffLen];
    int HTMLLogFormat    = 0;

    if( ownerAlias && componentMajor && componentMinor && stepsFileName )
    {
        // Object used to log our steps
        CStepsLog StepsLog;

        // Pull out internal INI file settings
        GetProfileStringA( DLL_NAME_A,   "Owner",           "Owner",          ownerAlias,     buffLen );
        GetProfileStringA( DLL_NAME_A,   "ComponentMajor",  "ComponentMajor", componentMajor, buffLen );
        GetProfileStringA( DLL_NAME_A,   "ComponentMinor",  "ComponentMinor", componentMinor, buffLen );
        GetProfileStringA( DLL_NAME_A,   "StepsFile",       "StepsFile",      stepsFileName,  buffLen );
        printSteps = GetProfileIntA( DLL_NAME_A, "PrintSteps", 0 );
        HTMLLogFormat = GetProfileIntA( DLL_NAME_A, "HTMLStepsLog", 1 );

        // Set the format for our STEPS log file
        StepsLog.SetHTMLLogFormat( HTMLLogFormat );

        xSetOwnerAlias( hLog, ownerAlias );
        xSetComponent( hLog, componentMajor, componentMinor );
        DebugPrint( "%s: **************************************************************\n", COMPONENT_NAME_A );
        DebugPrint( "%s: Entering %sStartTest()\n", COMPONENT_NAME_A, COMPONENT_NAME_A );
        DebugPrint( "%s: Internal INI Settings:\n", COMPONENT_NAME_A );
        DebugPrint( "   Owner           = '%s'\n", ownerAlias );
        DebugPrint( "   Component Major = '%s'\n", componentMajor );
        DebugPrint( "   Component Minor = '%s'\n", componentMinor );

        // Open our Steps Log File
        if (printSteps)
        {
            StepsLog.OpenLog( stepsFileName );
        }

        XDashMemoryRunAll( hLog, &StepsLog );

        if ( printSteps )
        {
            // Close our Steps Log File
            StepsLog.CloseLog();
        }

        DebugPrint( "%s: Leaving %sStartTest()\n", COMPONENT_NAME_A, COMPONENT_NAME_A );
        DebugPrint( "%s: **************************************************************\n", COMPONENT_NAME_A );
        xSetOwnerAlias( hLog, NULL );
    }
    else // Memory allocation failed
    {
        DebugPrint( "**ERROR: XDashMemoryStartTest():Could not allocate memory!!" );
    }

    if( ownerAlias )
    {
        delete[] ownerAlias;
        ownerAlias = NULL;
    }

    if( componentMajor )
    {
        delete[] componentMajor;
        componentMajor = NULL;
    }
    
    if( componentMinor )
    {
        delete[] componentMinor;
        componentMinor = NULL;
    }
    
    if( stepsFileName )
    {
        delete[] componentMinor;
        componentMinor = NULL;
    }
}


/*

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

*/
VOID WINAPI XDashMemoryEndTest(void)
{
}


#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( xdashmemory )
#pragma data_seg()

BEGIN_EXPORT_TABLE( xdashmemory )
    EXPORT_TABLE_ENTRY( "StartTest", XDashMemoryStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XDashMemoryEndTest )
END_EXPORT_TABLE( xdashmemory )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\movies\tests.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    Tests.cpp

Abstract:


Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-18-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "tests.h"

namespace xdashmovies
{
    /***********************
    ************************
    *** Begin Test Cases ***
    ************************
    ***********************/


    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD Test1Here( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This case verifies that 
        //////////////////////////////////////////////////////////////////////////

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( L"Step 1" );
        pStepsLog->AddStep( L"Step 2" );
        pStepsLog->AddStep( L"Step 3" );

        _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
        _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Variation Here", xlogVariationNum );

        // Log the test case variation to our Steps File
        pStepsLog->AddVariation( stepsVariation );

        TESTCASE( xlogVariation )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };
}; // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\movies\xdashmovies.cpp ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    XDashMovies.cpp

Abstract:

    The DLL exports two of the mandatory APIs: StartTest and EndTest.
    TESTINI.INI must be modified correctly so that the
    harness will load and call StartTest/EndTest.

    Please see "x-box test harness.doc" for more information.

Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10/16/2000  Created

*/


#include <xlog.h>
#include "stdafx.h"
#include "XDashMovies.h"
#include "tests.h"

namespace xdashmovies
{
    static BOOL printSteps = true;

    /*

    Routine Description:


    Arguments:

        HANDLE hLog - to the logging object
        CStepsLog* pStepsLog - Object used to log our test steps

    Return Value:

        DWORD

    */
    DWORD XDashMoviesRunAll( HANDLE hLog, CStepsLog* pStepsLog )
    {
        struct APIFUNCT
        {
            APITEST_FUNC f;
            WCHAR *name;
            char *aname;
        };
    
        #define BUILTAPISTRUCT(n) { n , L#n , #n }

        // Define all the API tests
        APIFUNCT testlist[] =
        {
            /*
            */
            BUILTAPISTRUCT( Test1Here )
            /*
            */
        };

        // Run the suite of tests

        // run each test
        for( size_t j = 0; j < ARRAYSIZE( testlist ); j++ )
        {
            xSetFunctionName(hLog, testlist[j].aname);
            DebugPrint( "%s: Entering test = '%ws()'\n", COMPONENT_NAME_A, testlist[j].name );

            // Log the testcase name to our steps log
            pStepsLog->SetCaseName( testlist[j].name );
            testlist[j].f( hLog, pStepsLog );

            // Log the test case (if the user wishes to)
            if ( printSteps )
            {
                pStepsLog->LogTestCase();
            }

            // Clear out the log for our next test
            pStepsLog->ClearTestCase();
        }

        return 0;
    }
}; // namespace

/*

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

*/
VOID WINAPI XDashMoviesStartTest( HANDLE hLog )
{
    using namespace xdashmovies;

    // test settings
    const int buffLen = 1024;
    
    char* ownerAlias     = new char[buffLen];
    char* componentMajor = new char[buffLen];
    char* componentMinor = new char[buffLen];
    char* stepsFileName  = new char[buffLen];
    int HTMLLogFormat    = 0;

    if( ownerAlias && componentMajor && componentMinor && stepsFileName )
    {
        // Object used to log our steps
        CStepsLog StepsLog;

        // Pull out internal INI file settings
        GetProfileStringA( DLL_NAME_A,   "Owner",           "Owner",          ownerAlias,     buffLen );
        GetProfileStringA( DLL_NAME_A,   "ComponentMajor",  "ComponentMajor", componentMajor, buffLen );
        GetProfileStringA( DLL_NAME_A,   "ComponentMinor",  "ComponentMinor", componentMinor, buffLen );
        GetProfileStringA( DLL_NAME_A,   "StepsFile",       "StepsFile",      stepsFileName,  buffLen );
        printSteps = GetProfileIntA( DLL_NAME_A, "PrintSteps", 0 );
        HTMLLogFormat = GetProfileIntA( DLL_NAME_A, "HTMLStepsLog", 1 );

        // Set the format for our STEPS log file
        StepsLog.SetHTMLLogFormat( HTMLLogFormat );

        xSetOwnerAlias( hLog, ownerAlias );
        xSetComponent( hLog, componentMajor, componentMinor );
        DebugPrint( "%s: **************************************************************\n", COMPONENT_NAME_A );
        DebugPrint( "%s: Entering %sStartTest()\n", COMPONENT_NAME_A, COMPONENT_NAME_A );
        DebugPrint( "%s: Internal INI Settings:\n", COMPONENT_NAME_A );
        DebugPrint( "   Owner           = '%s'\n", ownerAlias );
        DebugPrint( "   Component Major = '%s'\n", componentMajor );
        DebugPrint( "   Component Minor = '%s'\n", componentMinor );

        // Open our Steps Log File
        if (printSteps)
        {
            StepsLog.OpenLog( stepsFileName );
        }

        XDashMoviesRunAll( hLog, &StepsLog );

        if ( printSteps )
        {
            // Close our Steps Log File
            StepsLog.CloseLog();
        }

        DebugPrint( "%s: Leaving %sStartTest()\n", COMPONENT_NAME_A, COMPONENT_NAME_A );
        DebugPrint( "%s: **************************************************************\n", COMPONENT_NAME_A );
        xSetOwnerAlias( hLog, NULL );
    }
    else // Memory allocation failed
    {
        DebugPrint( "**ERROR: %sStartTest():Could not allocate memory!!", COMPONENT_NAME_A );
    }

    if( ownerAlias )
    {
        delete[] ownerAlias;
        ownerAlias = NULL;
    }

    if( componentMajor )
    {
        delete[] componentMajor;
        componentMajor = NULL;
    }
    
    if( componentMinor )
    {
        delete[] componentMinor;
        componentMinor = NULL;
    }
    
    if( stepsFileName )
    {
        delete[] componentMinor;
        componentMinor = NULL;
    }
}


/*

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

*/
VOID WINAPI XDashMoviesEndTest(void)
{
}


#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( xdashmovies )
#pragma data_seg()

BEGIN_EXPORT_TABLE( xdashmovies )
    EXPORT_TABLE_ENTRY( "StartTest", XDashMoviesStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XDashMoviesEndTest )
END_EXPORT_TABLE( xdashmovies )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\movies\tests.h ===
#ifndef _TESTS_H_
#define _TESTS_H_

namespace xdashmovies
{
    #define VARIATION_BUFFER_SIZE  1024

    /*

    Copyright (c) 2000 Microsoft Corporation

    Module Name:

        Tests.h

    Abstract:



    Author:

        Jim Helm (jimhelm)

    Environment:

        XBox

    Revision History:
        10-18-2000  Created

    */

    //
    //  Movie Area Tests
    //

    //    01234567890123456789012345678901

    DWORD Test1Here                       ( HANDLE hLog, CStepsLog* pStepsLog );

}; // namespace

#endif // _TESTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\movies\xdashmovies.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    XDashMovies.h

Abstract:



Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-16-2000  Created

*/
#ifndef _XDASHMOVIES_H_
#define _XDASHMOVIES_H_

#define COMPONENT_NAME_W    L"XDashMovies"
#define COMPONENT_NAME_A    "XDashMovies"
#define DLL_NAME_W          L"XDashMovies"
#define DLL_NAME_A          "XDashMovies"

typedef DWORD ( *APITEST_FUNC )( HANDLE hLog, CStepsLog* pStepsLog );

#endif // _XDASHMOVIES_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\music\tests.h ===
#ifndef _TESTS_H_
#define _TESTS_H_

namespace xdashmusic
{
    #define VARIATION_BUFFER_SIZE  1024

    /*

    Copyright (c) 2000 Microsoft Corporation

    Module Name:

        Tests.h

    Abstract:



    Author:

        Jim Helm (jimhelm)

    Environment:

        XBox

    Revision History:
        10-18-2000  Created

    */

    //
    //  Music Area Tests
    //

    //    01234567890123456789012345678901

    DWORD Test1Here                       ( HANDLE hLog, CStepsLog* pStepsLog );

}; // namespace

#endif // _TESTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\navigation\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\inc\stepslog.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    StepsLog.h

Abstract:
    This object can be used to log test steps and variations to a file
    so that cases can be run manually

Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-10-2000  Created

Notes:

*/

#ifndef _STEPSLOG_H_
#define _STEPSLOG_H_

#include <xtl.h>
#include <stdio.h>

#define DEFAULT_LOG_NAME  L"steps"
#define DEFAULT_DRIVE     L"t:\\"
#define HTML_FILE_EXT     L".htm"
#define TEXT_FILE_EXT     L".txt"
#define USE_HTML_DEFAULT  true

// The Header/Footer is placed at the very beginning and end of the HTML file
#define HTML_HEADER       L"<HTML>\n  <HEAD>\n    <TITLE>Test Steps</TITLE>\n  </HEAD>\n  <SCRIPT language=\"JScript\">\n    function ToggleVariations(DivTag)\n    {\n      if (DivTag.style.display == \"block\")\n      {\n        DivTag.style.display = \"none\";\n      }\n      else\n      {\n        DivTag.style.display = \"block\";\n      }\n    }\n  </SCRIPT>\n  <BODY>\n    <TABLE border=\"1\" width=\"100%%\">\n"
#define HTML_FOOTER       L"    </TABLE>\n  </BODY>\n</HTML>\n"

// The Header/Footer surrounds all of the steps for a single test case
#define HTML_STEP_HEADER  L"          <OL>\n"
#define HTML_STEP_FOOTER  L"          </OL>\n"
// The begin/end surrounds each individual step of a test case
#define HTML_STEP_BEGIN   L"            <LI>"
#define HTML_STEP_END     L"\n"

// The Header/Footer surrounds all of the variations for a single test case
#define HTML_VAR_HEADER   L"          <INPUT type=\"button\" value=\"Toggle Variations\" onclick=\"ToggleVariations(VAR%d)\"><br><br>\n          <DIV id=\"VAR%d\" STYLE=\"display:block\">\n"
#define HTML_VAR_FOOTER   L"          </DIV>\n"
// The begin/end surrounds each individual variation of a test case
#define HTML_VAR_BEGIN    L"            <STRONG>&nbsp;&nbsp;"
#define HTML_VAR_END      L"</STRONG><br>\n"

#define MAX_STEPS         1024
#define STEP_SIZE         1024

#define MAX_VARIATIONS    2048
#define VARIATION_SIZE    1024

extern "C"
{
        ULONG DebugPrint(PCHAR Format, ...);
}

class CStepsLog
{
public:

    // Constructors and Destructors
    CStepsLog();
    ~CStepsLog();

    // Log Specific Methods
    void OpenLog      ( char* lpszLogFileName /*=NULL*/ );
    void LogTestCase  ();
    void LogCaseName  ();
    void LogVariations();
    void LogSteps     ();
    void CloseLog     ();

    // Case Specific Methods
    void SetCaseName ( const WCHAR* caseName );
    void AddStep     ( const WCHAR* lpwszFormat, ... );
    void AddVariation( const WCHAR* lpwszFormat, ... );
    
    // These functions will remove any user defined information
    // ClearTestCase will clear ALL information
    void ClearTestCase     ();
    void ClearTestCaseName ();
    void ClearSteps        ();
    void ClearVariations   ();
    
    // Get a pointer to a specific step or Variation
    WCHAR* GetStep     ( const size_t index );
    WCHAR* GetVariation( const size_t index );

    // Accessors
    void SetHTMLLogFormat( BOOL bUseHTML );

private:
    // Properties
    FILE* m_LogFile;
    BOOL m_bHTMLLogFormat;

    BOOL m_bCaseLogged;
    size_t m_numTestCases;

    WCHAR* m_currentCaseName;
    
    size_t m_maxSteps;
    size_t m_currentStep;
    WCHAR** m_steps;

    size_t m_maxVariations;
    size_t m_currentVariation;
    WCHAR** m_variations;
};

#endif //_CSTEPSLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\music\tests.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    Tests.cpp

Abstract:


Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-18-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "tests.h"

namespace xdashmusic
{
    /***********************
    ************************
    *** Begin Test Cases ***
    ************************
    ***********************/


    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD Test1Here( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This case verifies that 
        //////////////////////////////////////////////////////////////////////////

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( L"Step 1" );
        pStepsLog->AddStep( L"Step 2" );
        pStepsLog->AddStep( L"Step 3" );

        _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
        _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Variation Here", xlogVariationNum );

        // Log the test case variation to our Steps File
        pStepsLog->AddVariation( stepsVariation );

        TESTCASE( xlogVariation )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };
}; // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\music\xdashmusic.cpp ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    XDashMusic.cpp

Abstract:

    The DLL exports two of the mandatory APIs: StartTest and EndTest.
    TESTINI.INI must be modified correctly so that the
    harness will load and call StartTest/EndTest.

    Please see "x-box test harness.doc" for more information.

Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10/16/2000  Created

*/


#include <xlog.h>
#include "stdafx.h"
#include "XDashMusic.h"
#include "tests.h"

namespace xdashmusic
{
    static BOOL printSteps = true;

    /*

    Routine Description:


    Arguments:

        HANDLE hLog - to the logging object
        CStepsLog* pStepsLog - Object used to log our test steps

    Return Value:

        DWORD

    */
    DWORD XDashMusicRunAll( HANDLE hLog, CStepsLog* pStepsLog )
    {
        struct APIFUNCT
        {
            APITEST_FUNC f;
            WCHAR *name;
            char *aname;
        };
    
        #define BUILTAPISTRUCT(n) { n , L#n , #n }

        // Define all the API tests
        APIFUNCT testlist[] =
        {
            /*
            */
            BUILTAPISTRUCT( Test1Here )
            /*
            */
        };

        // Run the suite of tests

        // run each test
        for( size_t j = 0; j < ARRAYSIZE( testlist ); j++ )
        {
            xSetFunctionName(hLog, testlist[j].aname);
            DebugPrint( "%s: Entering test = '%ws()'\n", COMPONENT_NAME_A, testlist[j].name );

            // Log the testcase name to our steps log
            pStepsLog->SetCaseName( testlist[j].name );
            testlist[j].f( hLog, pStepsLog );

            // Log the test case (if the user wishes to)
            if ( printSteps )
            {
                pStepsLog->LogTestCase();
            }

            // Clear out the log for our next test
            pStepsLog->ClearTestCase();
        }

        return 0;
    }
}; // namespace

/*

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

*/
VOID WINAPI XDashMusicStartTest( HANDLE hLog )
{
    using namespace xdashmusic;

    // test settings
    const int buffLen = 1024;
    
    char* ownerAlias     = new char[buffLen];
    char* componentMajor = new char[buffLen];
    char* componentMinor = new char[buffLen];
    char* stepsFileName  = new char[buffLen];
    int HTMLLogFormat    = 0;

    if( ownerAlias && componentMajor && componentMinor && stepsFileName )
    {
        // Object used to log our steps
        CStepsLog StepsLog;

        // Pull out internal INI file settings
        GetProfileStringA( DLL_NAME_A,   "Owner",           "Owner",          ownerAlias,     buffLen );
        GetProfileStringA( DLL_NAME_A,   "ComponentMajor",  "ComponentMajor", componentMajor, buffLen );
        GetProfileStringA( DLL_NAME_A,   "ComponentMinor",  "ComponentMinor", componentMinor, buffLen );
        GetProfileStringA( DLL_NAME_A,   "StepsFile",       "StepsFile",      stepsFileName,  buffLen );
        printSteps = GetProfileIntA( DLL_NAME_A, "PrintSteps", 0 );
        HTMLLogFormat = GetProfileIntA( DLL_NAME_A, "HTMLStepsLog", 1 );

        // Set the format for our STEPS log file
        StepsLog.SetHTMLLogFormat( HTMLLogFormat );

        xSetOwnerAlias( hLog, ownerAlias );
        xSetComponent( hLog, componentMajor, componentMinor );
        DebugPrint( "%s: **************************************************************\n", COMPONENT_NAME_A );
        DebugPrint( "%s: Entering %sStartTest()\n", COMPONENT_NAME_A, COMPONENT_NAME_A );
        DebugPrint( "%s: Internal INI Settings:\n", COMPONENT_NAME_A );
        DebugPrint( "   Owner           = '%s'\n", ownerAlias );
        DebugPrint( "   Component Major = '%s'\n", componentMajor );
        DebugPrint( "   Component Minor = '%s'\n", componentMinor );

        // Open our Steps Log File
        if (printSteps)
        {
            StepsLog.OpenLog( stepsFileName );
        }

        XDashMusicRunAll( hLog, &StepsLog );

        if ( printSteps )
        {
            // Close our Steps Log File
            StepsLog.CloseLog();
        }

        DebugPrint( "%s: Leaving %sStartTest()\n", COMPONENT_NAME_A, COMPONENT_NAME_A );
        DebugPrint( "%s: **************************************************************\n", COMPONENT_NAME_A );
        xSetOwnerAlias( hLog, NULL );
    }
    else // Memory allocation failed
    {
        DebugPrint( "**ERROR: XDashMusicStartTest():Could not allocate memory!!" );
    }

    if( ownerAlias )
    {
        delete[] ownerAlias;
        ownerAlias = NULL;
    }

    if( componentMajor )
    {
        delete[] componentMajor;
        componentMajor = NULL;
    }
    
    if( componentMinor )
    {
        delete[] componentMinor;
        componentMinor = NULL;
    }
    
    if( stepsFileName )
    {
        delete[] componentMinor;
        componentMinor = NULL;
    }
}


/*

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

*/
VOID WINAPI XDashMusicEndTest(void)
{
}


#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( xdashmusic )
#pragma data_seg()

BEGIN_EXPORT_TABLE( xdashmusic )
    EXPORT_TABLE_ENTRY( "StartTest", XDashMusicStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XDashMusicEndTest )
END_EXPORT_TABLE( xdashmusic )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\music\xdashmusic.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    XDashMusic.h

Abstract:



Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-16-2000  Created

*/
#ifndef _XDASHMUSIC_H_
#define _XDASHMUSIC_H_

#define COMPONENT_NAME_W    L"XDashMusic"
#define COMPONENT_NAME_A    "XDashMusic"
#define DLL_NAME_W          L"XDashMusic"
#define DLL_NAME_A          "XDashMusic"

typedef DWORD ( *APITEST_FUNC )( HANDLE hLog, CStepsLog* pStepsLog );

#endif // _XDASHMUSIC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\navigation\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
#define AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_

#if _MSC_VER > 1000
    #pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN         // Exclude rarely-used stuff from Windows headers
#endif

#ifndef UNICODE
    #define _UNICODE
    #define UNICODE
#endif

// Exclude rarely-used stuff from Windows headers
#define NTLEANANDMEAN
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_IA64_) && defined(_M_IX86)
#define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MRX000)
#define _MIPS_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_ALPHA)
#define _ALPHA_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_PPC)
#define _PPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_M68K)
#define _68K_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MPPC)
#define _MPPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_M_IX86) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <stdio.h>
#include <xtl.h>
#include <profilep.h>

#include "stepslog.h"
#include "xdashteststeps.h"
#include "commontest.h"
#include "environments.h"
#include "xdashscreenlist.h"

extern "C"
{
        ULONG DebugPrint(PCHAR Format, ...);
};

// #include "environments.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\navigation\tests.h ===
#ifndef _tests_h
#define _tests_h

namespace xdashnav
{
    #define VARIATION_BUFFER_SIZE  1024

    // Global list of ALL Screens and Controls
    extern CXDashScreenList g_XDashScreens;

    /*

    Copyright (c) 2000 Microsoft Corporation

    Module Name:

        Tests.h

    Abstract:



    Author:

        Jim Helm (jimhelm)

    Environment:

        XBox

    Revision History:
        09-27-2000  Created

    */

    //
    //  Navigation / Skeleton Tests
    //

    //    01234567890123456789012345678901
    DWORD AllControlsBasicNav             ( HANDLE hLog, CStepsLog* pStepsLog );

}; // namespace

#endif // _tests_h

// Enumerate navigation cases where media is inserted and the user is wisked away - Music CD's, etc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\settings\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\settings\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
#define AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_

#if _MSC_VER > 1000
    #pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN         // Exclude rarely-used stuff from Windows headers
#endif

#ifndef UNICODE
    #define _UNICODE
    #define UNICODE
#endif

// Exclude rarely-used stuff from Windows headers
#define NTLEANANDMEAN
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_IA64_) && defined(_M_IX86)
#define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MRX000)
#define _MIPS_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_ALPHA)
#define _ALPHA_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_PPC)
#define _PPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_M68K)
#define _68K_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MPPC)
#define _MPPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_M_IX86) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <stdio.h>
#include <xtl.h>
#include <profilep.h>

#include "stepslog.h"
#include "xdashteststeps.h"
#include "commontest.h"
#include "environments.h"

extern "C"
{
        ULONG DebugPrint(PCHAR Format, ...);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\navigation\tests.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    Tests.cpp

Abstract:


Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-16-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "tests.h"

namespace xdashnav
{
    // Globals
    CXDashScreenList g_XDashScreens( "t:\\XDSCREEN.INI" );     // All screens and controls for the XBOX
    
    /***********************
    ************************
    *** Begin Test Cases ***
    ************************
    ***********************/


    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD AllControlsBasicNav( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This case verifies that each control on each screen of the XDash
        // responds to the basic controls (standard select and back buttons)
        //////////////////////////////////////////////////////////////////////////

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_INVOKE_SCREEN_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_SELECT_CONROL_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_DEST_SCREEN_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_SCREEN_ACCORD_TO_VAR );

        // For every screen in the XDash
        for( size_t screenIndex = 0; screenIndex < g_XDashScreens.GetNumScreens(); ++screenIndex )
        {
            // For every control on each screen
            for( size_t controlIndex = 0; controlIndex < g_XDashScreens.GetNumControlsOnScreenByIndex( screenIndex ); ++controlIndex )
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: SCREEN: %S, CONTROL: %S, DEST: %S", xlogVariationNum, g_XDashScreens.GetScreenNameByIndex( screenIndex ), g_XDashScreens.GetControlNameFromScreenByIndex( screenIndex, controlIndex ), g_XDashScreens.GetControlDestFromScreenByIndex( screenIndex, controlIndex ) );

                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( stepsVariation );

                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }
    
        return 0;
    };
}; // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\navigation\xdashnav.cpp ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    XDashNav.cpp

Abstract:

    The DLL exports two of the mandatory APIs: StartTest and EndTest.
    TESTINI.INI must be modified correctly so that the
    harness will load and call StartTest/EndTest.

    Please see "x-box test harness.doc" for more information.

Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10/16/2000  Created

*/


#include <xlog.h>
#include "stdafx.h"
#include "XDashNav.h"
#include "tests.h"

namespace xdashnav
{
    static BOOL printSteps = true;

    /*

    Routine Description:


    Arguments:

        HANDLE hLog - to the logging object
        CStepsLog* pStepsLog - Object used to log our test steps

    Return Value:

        DWORD

    */
    DWORD XDashNavRunAll( HANDLE hLog, CStepsLog* pStepsLog )
    {
        struct APIFUNCT
        {
            APITEST_FUNC f;
            WCHAR *name;
            char *aname;
        };
    
        #define BUILTAPISTRUCT(n) { n , L#n , #n }

        // Define all the API tests
        APIFUNCT testlist[] =
        {
            /*
            */
            BUILTAPISTRUCT( AllControlsBasicNav )
            /*
            */
        };

        // Run the suite of tests

        // run each test
        for( size_t j = 0; j < ARRAYSIZE( testlist ); j++ )
        {
            xSetFunctionName(hLog, testlist[j].aname);
            DebugPrint( "%s: Entering test = '%ws()'\n", COMPONENT_NAME_A, testlist[j].name );

            // Log the testcase name to our steps log
            pStepsLog->SetCaseName( testlist[j].name );
            testlist[j].f( hLog, pStepsLog );

            // Log the test case (if the user wishes to)
            if ( printSteps )
            {
                pStepsLog->LogTestCase();
            }

            // Clear out the log for our next test
            pStepsLog->ClearTestCase();
        }

        return 0;
    }
}; // namespace


/*

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

*/
VOID WINAPI XDashNavStartTest( HANDLE hLog )
{
    using namespace xdashnav;

    // test settings
    const int buffLen = 1024;
    
    char* ownerAlias     = new char[buffLen];
    char* componentMajor = new char[buffLen];
    char* componentMinor = new char[buffLen];
    char* stepsFileName  = new char[buffLen];
    int HTMLLogFormat    = 0;

    if( ownerAlias && componentMajor && componentMinor && stepsFileName )
    {
        // Object used to log our steps
        CStepsLog StepsLog;

        // Pull out internal INI file settings
        GetProfileStringA( DLL_NAME_A,   "Owner",           "Owner",          ownerAlias,     buffLen );
        GetProfileStringA( DLL_NAME_A,   "ComponentMajor",  "ComponentMajor", componentMajor, buffLen );
        GetProfileStringA( DLL_NAME_A,   "ComponentMinor",  "ComponentMinor", componentMinor, buffLen );
        GetProfileStringA( DLL_NAME_A,   "StepsFile",       "StepsFile",      stepsFileName,  buffLen );
        printSteps = GetProfileIntA( DLL_NAME_A, "PrintSteps", 0 );
        HTMLLogFormat = GetProfileIntA( DLL_NAME_A, "HTMLStepsLog", 1 );

        // Set the format for our STEPS log file
        StepsLog.SetHTMLLogFormat( HTMLLogFormat );

        xSetOwnerAlias( hLog, ownerAlias );
        xSetComponent( hLog, componentMajor, componentMinor );
        DebugPrint( "%s: **************************************************************\n", COMPONENT_NAME_A );
        DebugPrint( "%s: Entering %sStartTest()\n", COMPONENT_NAME_A, COMPONENT_NAME_A );
        DebugPrint( "%s: Internal INI Settings:\n", COMPONENT_NAME_A );
        DebugPrint( "   Owner           = '%s'\n", ownerAlias );
        DebugPrint( "   Component Major = '%s'\n", componentMajor );
        DebugPrint( "   Component Minor = '%s'\n", componentMinor );

        // Open our Steps Log File
        if (printSteps)
        {
            StepsLog.OpenLog( stepsFileName );
        }

        XDashNavRunAll( hLog, &StepsLog );

        if ( printSteps )
        {
            // Close our Steps Log File
            StepsLog.CloseLog();
        }

        DebugPrint( "%s: Leaving %sStartTest()\n", COMPONENT_NAME_A, COMPONENT_NAME_A );
        DebugPrint( "%s: **************************************************************\n", COMPONENT_NAME_A );
        xSetOwnerAlias( hLog, NULL );
    }
    else // Memory allocation failed
    {
        DebugPrint( "**ERROR: XDashNavStartTest():Could not allocate memory!!" );
    }

    if( ownerAlias )
    {
        delete[] ownerAlias;
        ownerAlias = NULL;
    }

    if( componentMajor )
    {
        delete[] componentMajor;
        componentMajor = NULL;
    }
    
    if( componentMinor )
    {
        delete[] componentMinor;
        componentMinor = NULL;
    }
    
    if( stepsFileName )
    {
        delete[] componentMinor;
        componentMinor = NULL;
    }
}


/*

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

*/
VOID WINAPI XDashNavEndTest(void)
{
}


#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( xdashnav )
#pragma data_seg()

BEGIN_EXPORT_TABLE( xdashnav )
    EXPORT_TABLE_ENTRY( "StartTest", XDashNavStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XDashNavEndTest )
END_EXPORT_TABLE( xdashnav )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\navigation\xdashnav.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    XDashNav.h

Abstract:



Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-16-2000  Created

*/
#ifndef _XDASHNAV_H_
#define _XDASHNAV_H_

#define COMPONENT_NAME_W    L"XDashNav"
#define COMPONENT_NAME_A    "XDashNav"
#define DLL_NAME_W          L"XDashNav"
#define DLL_NAME_A          "XDashNav"

typedef DWORD ( *APITEST_FUNC )( HANDLE hLog, CStepsLog* pStepsLog );

#endif // _XDASHNAV_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\settings\xdashsettings.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    XDashSettings.h

Abstract:



Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-16-2000  Created

*/
#ifndef _XDASHSETTINGS_H_
#define _XDASHSETTINGS_H_

#define COMPONENT_NAME_W    L"XDashSettings"
#define COMPONENT_NAME_A    "XDashSettings"
#define DLL_NAME_W          L"XDashSettings"
#define DLL_NAME_A          "XDashSettings"

typedef DWORD ( *APITEST_FUNC )( HANDLE hLog, CStepsLog* pStepsLog );

#endif // _XDASHSETTINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\settings\tests.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    Tests.cpp

Abstract:


Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-18-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "tests.h"

namespace xdashsettings
{
    /***********************
    ************************
    *** Begin Test Cases ***
    ************************
    ***********************/

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////// CLOCK ////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD ClockInitialBootGoodBattery( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a new user receives their XBox
        // BEFORE their 20 day battery dies, they can boot in to the default
        // title, and the clock is set to the correct time.
        //////////////////////////////////////////////////////////////////////////

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_SETUP_XBOX_FACTORY_SETTINGS_GOOD_BATTERY );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_INITIAL_BOOT_GOOD_BATTERY );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };

    
    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD ClockInitialBootBadBattery( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if a new user receives their XBox
        // AFTER their 20 day battery dies, they can boot in to the default
        // title, and the clock is set to the correct time.
        //////////////////////////////////////////////////////////////////////////

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_SETUP_XBOX_FACTORY_SETTINGS_BAD_BATTERY );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_INITIAL_BOOT_BAD_BATTERY );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };

    
    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD ClockStartRange( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that a user cannot boot to the XDash and set
        // the clock to a date BEFORE the RTM date of the XBox.
        //////////////////////////////////////////////////////////////////////////

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( L"%s %s", STEP_VERIFY_CLOCK_CANT_SET_PRIOR_TO, gc_lpwszCLOCK_VALID_DATA[SETTINGS_AREA_CLOCK_START_RANGE] );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };


    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD ClockEndRange( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that a user cannot boot to the XDash and set
        // the clock to a date AFTER the largest allowable date for the XBox.
        //////////////////////////////////////////////////////////////////////////

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( L"%s %s", STEP_VERIFY_CLOCK_CANT_SET_AFTER, gc_lpwszCLOCK_VALID_DATA[SETTINGS_AREA_CLOCK_END_RANGE] );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };

    
    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD ClockMonthsUseValidNumDays( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that the Default Title clock accepts the proper
        // number of days for each month of a non-leap year.
        //////////////////////////////////////////////////////////////////////////

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK_NON_LEAP_YEAR );
        pStepsLog->AddStep( STEP_SELECT_CLOCK_EACH_MONTH );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_NUM_DAYS_FOR_CURRENT_MONTH );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };

    
    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD ClockFebUseValidNumDaysLeapYear( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that the Default Title clock accepts the proper
        // number of days for Februrary for a leap year.
        //////////////////////////////////////////////////////////////////////////

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK_LEAP_YEAR );
        pStepsLog->AddStep( STEP_SELECT_CLOCK_MONTH_FEB );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_NUM_DAYS_FOR_CURRENT_MONTH );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };

    
    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD ClockDatesStoredToXDisk( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that the Default Title will store the dates
        // and times the user sets on to the XDisk, and displays them upon
        // next boot.
        //////////////////////////////////////////////////////////////////////////

        // Subset of the valid data we we to use for the clock stored to disk test
        enum ClockValidDataWithinList clockData[] = {
            SETTINGS_AREA_CLOCK_START_RANGE,
            SETTINGS_AREA_CLOCK_END_RANGE
        };

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK_INFO_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_XBOX_POWERED_OFF );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_INFO_ACCORD_TO_VAR );

        // For each clock setting we wish to use
        for( size_t clockSetting = 0; clockSetting < ARRAYSIZE( clockData ); ++clockSetting )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Set Data/Time to: %s", xlogVariationNum, gc_lpwszCLOCK_VALID_DATA[clockData[clockSetting]] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );
            
            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }
    
        return 0;
    };

    
    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD ClockSetUsingXZone( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that the Default Title will allow the XZone to
        // update it's Date / Time information.
        //////////////////////////////////////////////////////////////////////////

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_SETUP_XBOX_CLOCK_INCORRECT );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_XZONE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_XZONE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_COUNTRY_CURRENT );
        pStepsLog->AddStep( STEP_SELECT_XZONE_SET_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_COMPLETED );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_SET_CORRECTLY );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_XBOX_POWERED_OFF );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_SET_CORRECTLY );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };

    
    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD ClockXZoneSetsDSTInfo( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that the Default Title will allow the XZone to
        // update it's Date / Time for countries with DST information.
        //////////////////////////////////////////////////////////////////////////

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_SETUP_XBOX_FACTORY_SETTINGS_GOOD_BATTERY );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_XZONE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_XZONE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_COUNTRY_WITH_DST );
        pStepsLog->AddStep( STEP_SELECT_XZONE_SET_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_COMPLETED );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_SET_CORRECTLY );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_SET_FOR_DST_CORRECTLY );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_XBOX_POWERED_OFF );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_SET_CORRECTLY );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_SET_FOR_DST_CORRECTLY );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };

    
    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD ClockManualSetRemovesDSTInfo( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that the Default Title will reset the DST
        // information after a user has set the Clock on the XZone, and then
        // manually changes the time/date information.
        //////////////////////////////////////////////////////////////////////////

        //BUGBUG: Possibly need to do this for each settable field on the clock.
        //        May be able to get around this by doing a code review with the
        //        developer

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_SETUP_XBOX_FACTORY_SETTINGS_GOOD_BATTERY );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_XZONE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_XZONE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_COUNTRY_WITH_DST );
        pStepsLog->AddStep( STEP_SELECT_XZONE_SET_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_COMPLETED );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK_NEW );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_SET_CORRECTLY );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_DST_RESET );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };
    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD ClockDSTUpdatesXBoxAlreadyOn( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if the XBox is set to honor daylight
        // savings time, if you leave the XBox on, at the appropriate moment
        // the clock will be updated.
        //////////////////////////////////////////////////////////////////////////

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_SETUP_XBOX_DATE_JUST_BEFORE_DST );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_ACTION_WAIT_FOR_DST );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_SET_CORRECTLY );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_SET_FOR_DST_CORRECTLY );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_XBOX_POWERED_OFF );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_SET_CORRECTLY );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_SET_FOR_DST_CORRECTLY );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };

    
    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD ClockDSTUpdatesXBoxPoweredOn( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if the XBox is set to honor daylight
        // savings time, if power off the XBox, and power it back on AFTER
        // the DST rollover time has passed, the clock will be updated.
        //////////////////////////////////////////////////////////////////////////

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_SETUP_XBOX_DATE_JUST_BEFORE_DST );
        pStepsLog->AddStep( STEP_VERIFY_XBOX_POWERED_OFF );
        pStepsLog->AddStep( STEP_ACTION_WAIT_FOR_DST );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_SET_CORRECTLY );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_SET_FOR_DST_CORRECTLY );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };


    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD ClockXZoneSetClockPowerOff( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if the XZone is in the middle of setting
        // the XBox clock, and the user presses Power, we will do the correct
        // thing.
        //////////////////////////////////////////////////////////////////////////

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_XZONE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_XZONE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_COUNTRY_WITH_DST );
        pStepsLog->AddStep( STEP_SELECT_XZONE_SET_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_STARTED );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_XBOX_POWERED_OFF );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_NOT_UPDATED );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };


    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD ClockXZoneSetClockUnplugPower( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if the XZone is in the middle of setting
        // the XBox clock, and the user unplugs the power cord, we will do the
        // correct thing.
        //////////////////////////////////////////////////////////////////////////

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_XZONE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_XZONE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_COUNTRY_WITH_DST );
        pStepsLog->AddStep( STEP_SELECT_XZONE_SET_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_STARTED );
        pStepsLog->AddStep( STEP_REMOVE_POWER_PLUG_FROM_XBOX );
        pStepsLog->AddStep( STEP_VERIFY_XBOX_POWERED_OFF );
        pStepsLog->AddStep( STEP_INSERT_PLUG_IN_TO_XBOX );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_NOT_UPDATED );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };

    
    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD ClockXZoneSetClockUnplugBB( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if the XZone is in the middle of setting
        // the XBox clock, and the user unplugs the Broadband connection, we will
        // do the correct thing.
        //////////////////////////////////////////////////////////////////////////

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_XZONE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_XZONE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_COUNTRY_WITH_DST );
        pStepsLog->AddStep( STEP_SELECT_XZONE_SET_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_STARTED );
        pStepsLog->AddStep( STEP_REMOVE_BB_PLUG_FROM_XBOX );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_NOTIFICATION );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_NOT_UPDATED );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_XZONE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_XZONE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_COUNTRY_WITH_DST );
        pStepsLog->AddStep( STEP_SELECT_XZONE_SET_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_ACTION_COMPLETED );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CLOCK_SET_CORRECTLY );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };


    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD ClockNewSettingUpdatesClockOnly( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if the user selects a new time/date option
        // in the default title, no other settings are affected.
        //////////////////////////////////////////////////////////////////////////

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_NOTE_CONFIG_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_CLOCK_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_CLOCK_NEW );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CORRECT_SETTINGS_ACCORD_TO_NOTE );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };

    //////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////// LANGUAGE ////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////

    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD LangXBoxRegionsCorrectLanguage( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that the XBox is defaulting to the correct
        // language for the various regions we support.
        //////////////////////////////////////////////////////////////////////////

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_SETUP_XBOX_FROM_REGION_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CORRECT_LANGUAGE_ACCORD_TO_VAR );

        // For each clock setting we wish to use
        for( size_t xboxRegion = 0; xboxRegion < ARRAYSIZE( gc_lpwszXBOX_NATIVE_REGIONS ); ++xboxRegion )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: XBox Region: %s", xlogVariationNum, gc_lpwszXBOX_NATIVE_REGIONS[xboxRegion] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );
            
            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }
    
        return 0;
    };

    
    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD LangNewLangDisplayAndConfig( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if the user selects a new language in the
        // default title, the change is immediate, and does not require a
        // reboot.  It also verifies that the setting is stored to the XDisk,
        // and upon reboot, the Language setting is remembered.
        //////////////////////////////////////////////////////////////////////////

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_SETUP_XBOX_FROM_REGION_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_LANGUAGE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_LANGUAGE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_LANGUAGE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_CORRECT_LANGUAGE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CORRECT_LANGUAGE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CORRECT_LANGUAGE_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_XBOX_POWERED_OFF );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CORRECT_LANGUAGE_ACCORD_TO_VAR );

        // For each clock setting we wish to use
        for( size_t language = 0; language < ARRAYSIZE( gc_lpwszXBOX_DT_LANGUAGES ); ++language )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Language: %s", xlogVariationNum, gc_lpwszXBOX_DT_LANGUAGES[language] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );
            
            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }
    
        return 0;
    };

    
    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD LangNewLangUpdatesLangOnly( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if the user selects a new language in the
        // default title, no other settings are affected.
        //////////////////////////////////////////////////////////////////////////

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_NOTE_CONFIG_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_LANGUAGE );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_LANGUAGE_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_LANGUAGE_NEW );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_CORRECT_LANGUAGE );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CORRECT_SETTINGS_ACCORD_TO_NOTE );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////// VIDEO ////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD VideoInitalBootCorrectDefault( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that upon initial boot of the XBox, the video
        // setting is correctly defaulted to the 'Normal' choice.
        //////////////////////////////////////////////////////////////////////////

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_SETUP_XBOX_FACTORY_SETTINGS_GOOD_BATTERY );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_VIDEO );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_VIDEO_SCREEN );
        pStepsLog->AddStep( L"%s %s", STEP_VERIFY_VIDEO_SET_TO, gc_lpwszXBOX_DT_VIDEO_OPTIONS[SETTINGS_VIDEO_DEFAULT] );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };


    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD VideoNewSettingDisplayAndConfig( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if the user selects a new video option in
        // the default title, the change is immediate, and does not require a
        // reboot.  It also verifies that the setting is stored to the XDisk,
        // and upon reboot, the setting is remembered.
        //////////////////////////////////////////////////////////////////////////

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_SETUP_XBOX_FROM_REGION_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_VIDEO );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_VIDEO_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_VIDEO_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_VIDEO_SET_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_TEXT_NOT_CLIPPED );
        pStepsLog->AddStep( STEP_VERIFY_DISPLAY_PROPERLY_WRAPPING );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_TEXT_NOT_CLIPPED );
        pStepsLog->AddStep( STEP_VERIFY_DISPLAY_PROPERLY_WRAPPING );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_TEXT_NOT_CLIPPED );
        pStepsLog->AddStep( STEP_VERIFY_DISPLAY_PROPERLY_WRAPPING );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_XBOX_POWERED_OFF );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_VIDEO_SET_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_VERIFY_TEXT_NOT_CLIPPED );
        pStepsLog->AddStep( STEP_VERIFY_DISPLAY_PROPERLY_WRAPPING );

        // For each clock setting we wish to use
        for( size_t videoSetting = 0; videoSetting < ARRAYSIZE( gc_lpwszXBOX_DT_VIDEO_OPTIONS ); ++videoSetting )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Video setting: %s", xlogVariationNum, gc_lpwszXBOX_DT_VIDEO_OPTIONS[videoSetting] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );
            
            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }
    
        return 0;
    };

    
    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD VideoNewSettingUpdatesVideoOnly( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if the user selects a new video option
        // in the default title, no other settings are affected.
        //////////////////////////////////////////////////////////////////////////

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_NOTE_CONFIG_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_VIDEO );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_VIDEO_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_VIDEO_NEW );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_VIDEO_SET_CORRECTLY );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_PRESS_BACK );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_CORRECT_SETTINGS_ACCORD_TO_NOTE );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////// AUDIO ////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    
    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD AudioInitalBootCorrectDefault( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that upon initial boot of the XBox, the audio
        // setting is correctly defaulted to the 'Normal' choice, no matter
        // which A/V pack is installed.
        //////////////////////////////////////////////////////////////////////////

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_SETUP_XBOX_AVPACK_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_SETUP_XBOX_FACTORY_SETTINGS_GOOD_BATTERY );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_AUDIO );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_AUDIO_SCREEN );
        pStepsLog->AddStep( L"%s %s", STEP_VERIFY_AUDIO_SET_TO, gc_lpwszXBOX_DT_AUDIO_OPTIONS[SETTINGS_AUDIO_DEFAULT] );

        // For each A/V pack in our list
        for( size_t avPack = 0; avPack < ARRAYSIZE( gc_lpwszXBOX_AV_PACKS ); ++avPack )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: A/V pack installed: %s", xlogVariationNum, gc_lpwszXBOX_AV_PACKS[avPack] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );
            
            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }

        return 0;
    };

    
    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD AudioChoicesNoAVPack( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if the XBox does not have an A/V pack
        // installed, they will only have a subset of the audio options
        // available to them in the default title.
        //////////////////////////////////////////////////////////////////////////

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_SETUP_XBOX_AVPACK_NONE );
        pStepsLog->AddStep( STEP_SETUP_XBOX_FACTORY_SETTINGS_GOOD_BATTERY );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_AUDIO );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_AUDIO_SCREEN );
        pStepsLog->AddStep( L"%s %s and %s", STEP_VERIFY_AUDIO_CHOICES_AVAILABLE_ARE, gc_lpwszXBOX_DT_AUDIO_OPTIONS[SETTINGS_AUDIO_STEREO], gc_lpwszXBOX_DT_AUDIO_OPTIONS[SETTINGS_AUDIO_MONO] );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };


    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD AudioChoicesWithAVPack( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if the XBox DOES have an A/V pack
        // installed, they will have the full list of audio options
        // available to them in the default title.
        //////////////////////////////////////////////////////////////////////////

        const size_t buffSize = 512;    // Buffer size to be used by our static choice list
        const WCHAR* sepText = L", ";   // Used to separate each choice within the step
        size_t numCharsCopied = 0;      // Number of characters copied in to our buffer

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        size_t numCharsToBeCopied = 0;                  // The number of characters the current choice will end up copying
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running
        WCHAR choicesAvailable[buffSize];               // The audio choices available to the user with an A/V pack installed

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_SETUP_XBOX_AVPACK_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_SETUP_XBOX_FACTORY_SETTINGS_GOOD_BATTERY );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_AUDIO );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_AUDIO_SCREEN );

        ZeroMemory( choicesAvailable, sizeof( WCHAR ) * buffSize );
        for( size_t choice = 0; choice < ARRAYSIZE( gc_lpwszXBOX_DT_AUDIO_OPTIONS ); ++choice )
        {
            // The number of characters to be copied in this concat operation
            numCharsToBeCopied = wcslen( gc_lpwszXBOX_DT_AUDIO_OPTIONS[choice] );

            // If we are not on our last choice, add the length of our sep text to the char copy total
            if( 1 != ARRAYSIZE( gc_lpwszXBOX_DT_AUDIO_OPTIONS ) - choice )
            {
                numCharsToBeCopied += wcslen( sepText );
            }


            // If we don't have enough room in our buffer, let the user know and bail the test case
            if( buffSize - ( numCharsCopied + numCharsToBeCopied ) <= 0 )
            {
                DebugPrint( "SettingsTests():AudioChoicesWithAVPack():Out of buffer space!!\n" );
                return -1;
            }
            
            wcsncat( choicesAvailable, gc_lpwszXBOX_DT_AUDIO_OPTIONS[choice], buffSize - numCharsCopied );
            numCharsCopied += wcslen( gc_lpwszXBOX_DT_AUDIO_OPTIONS[choice] );

            // If we are not on our last choice, append the separator text
            if( 1 != ARRAYSIZE( gc_lpwszXBOX_DT_AUDIO_OPTIONS ) - choice )
            {
                wcsncat( choicesAvailable, sepText, buffSize - numCharsCopied );
                numCharsCopied += wcslen( sepText );
            }

        }

        pStepsLog->AddStep( L"%s %s", STEP_VERIFY_AUDIO_CHOICES_AVAILABLE_ARE, choicesAvailable );

        // For each A/V pack in our list
        for( size_t avPack = 0; avPack < ARRAYSIZE( gc_lpwszXBOX_AV_PACKS ); ++avPack )
        {
            // Skip the variation if there is no A/V pack installed
            if( avPack > AVPACK_NONE)
            {
                _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
                _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: A/V pack installed: %s", xlogVariationNum, gc_lpwszXBOX_AV_PACKS[avPack] );

                // Log the test case variation to our Steps File
                pStepsLog->AddVariation( stepsVariation );
            
                TESTCASE( xlogVariation )
                {
                    TESTMNUL( hLog, "Manual Test" );
                } ENDTESTCASE;
            }
        }

        return 0;
    };


    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD AudioNewSettingConfig( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if the user selects a new audio option in
        // the default title, the change is stored to the XDisk, and upon reboot,
        // the setting is remembered.
        //////////////////////////////////////////////////////////////////////////

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_SETUP_XBOX_AVPACK_ANY );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_AUDIO );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_AUDIO_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_AUDIO_OPTION_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_AUDIO );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_AUDIO_SET_ACCORD_TO_VAR );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_XBOX_POWERED_OFF );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_AUDIO );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_AUDIO_SCREEN );
        pStepsLog->AddStep( STEP_VERIFY_AUDIO_SET_ACCORD_TO_VAR );

        // For each audio option we wish to use
        for( size_t audioOption = 0; audioOption < ARRAYSIZE( gc_lpwszXBOX_DT_AUDIO_OPTIONS ); ++audioOption )
        {
            _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
            _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Audio option: %s", xlogVariationNum, gc_lpwszXBOX_DT_AUDIO_OPTIONS[audioOption] );

            // Log the test case variation to our Steps File
            pStepsLog->AddVariation( stepsVariation );
            
            TESTCASE( xlogVariation )
            {
                TESTMNUL( hLog, "Manual Test" );
            } ENDTESTCASE;
        }
    
        return 0;
    };


    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD AudioAVRemovedAfterOptionSet( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This test will verify that if the user selects an audio choice that
        // requires an A/V pack to be installed, and then the user switches
        // the A/V packs around, the correct options are set and stored
        // to the XDisk.
        //////////////////////////////////////////////////////////////////////////

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( STEP_SETUP_XBOX_AVPACK_ANY );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_AUDIO );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_AUDIO_SCREEN );
        pStepsLog->AddStep( L"%s %s", STEP_SELECT_AUDIO_OPTION_TO_BE, gc_lpwszXBOX_DT_AUDIO_OPTIONS[SETTINGS_AUDIO_ANALOG] );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_XBOX_POWERED_OFF );
        pStepsLog->AddStep( STEP_REMOVE_AVPACK_FROM_XBOX );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_AUDIO );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_AUDIO_SCREEN );
        pStepsLog->AddStep( L"%s %s", STEP_VERIFY_AUDIO_SET_TO, gc_lpwszXBOX_DT_AUDIO_OPTIONS[SETTINGS_AUDIO_STEREO] );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_XBOX_POWERED_OFF );
        pStepsLog->AddStep( STEP_SETUP_XBOX_AVPACK_ANY );
        pStepsLog->AddStep( STEP_PRESS_POWER );
        pStepsLog->AddStep( STEP_VERIFY_ROOT_MENU_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_SETTINGS );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_SCREEN );
        pStepsLog->AddStep( STEP_SELECT_AUDIO );
        pStepsLog->AddStep( STEP_PRESS_ACCEPT );
        pStepsLog->AddStep( STEP_VERIFY_SETTINGS_AUDIO_SCREEN );
        pStepsLog->AddStep( L"%s %s", STEP_VERIFY_AUDIO_SET_TO, gc_lpwszXBOX_DT_AUDIO_OPTIONS[SETTINGS_AUDIO_STEREO] );

        TESTCASE( L"" )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };

    //////////////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////// PARENTAL CONTROL ////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////

}; // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\settings\tests.h ===
#ifndef _TESTS_H_
#define _TESTS_H_

namespace xdashsettings
{
    #define VARIATION_BUFFER_SIZE  1024

    /*

    Copyright (c) 2000 Microsoft Corporation

    Module Name:

        Tests.h

    Abstract:



    Author:

        Jim Helm (jimhelm)

    Environment:

        XBox

    Revision History:
        10-18-2000  Created

    */

    //
    //  Settings Area Tests
    //

    //    01234567890123456789012345678901

    DWORD ClockInitialBootGoodBattery     ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD ClockInitialBootBadBattery      ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD ClockStartRange                 ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD ClockEndRange                   ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD ClockMonthsUseValidNumDays      ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD ClockFebUseValidNumDaysLeapYear ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD ClockDatesStoredToXDisk         ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD ClockSetUsingXZone              ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD ClockXZoneSetsDSTInfo           ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD ClockManualSetRemovesDSTInfo    ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD ClockDSTUpdatesXBoxAlreadyOn    ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD ClockDSTUpdatesXBoxPoweredOn    ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD ClockXZoneSetClockPowerOff      ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD ClockXZoneSetClockUnplugPower   ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD ClockXZoneSetClockUnplugBB      ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD ClockNewSettingUpdatesClockOnly ( HANDLE hLog, CStepsLog* pStepsLog );

    DWORD LangXBoxRegionsCorrectLanguage  ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD LangNewLangDisplayAndConfig     ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD LangNewLangUpdatesLangOnly      ( HANDLE hLog, CStepsLog* pStepsLog );

    DWORD VideoInitalBootCorrectDefault   ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD VideoNewSettingDisplayAndConfig ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD VideoNewSettingUpdatesVideoOnly ( HANDLE hLog, CStepsLog* pStepsLog );

    DWORD AudioInitalBootCorrectDefault   ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD AudioChoicesNoAVPack            ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD AudioChoicesWithAVPack          ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD AudioNewSettingConfig           ( HANDLE hLog, CStepsLog* pStepsLog );
    DWORD AudioAVRemovedAfterOptionSet    ( HANDLE hLog, CStepsLog* pStepsLog );
}; // namespace

#endif // _TESTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\xzone\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\xzone\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
#define AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_

#if _MSC_VER > 1000
    #pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN         // Exclude rarely-used stuff from Windows headers
#endif

#ifndef UNICODE
    #define _UNICODE
    #define UNICODE
#endif

// Exclude rarely-used stuff from Windows headers
#define NTLEANANDMEAN
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_IA64_) && defined(_M_IX86)
#define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MRX000)
#define _MIPS_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_ALPHA)
#define _ALPHA_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_PPC)
#define _PPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_M68K)
#define _68K_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MPPC)
#define _MPPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_M_IX86) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <stdio.h>
#include <xtl.h>
#include <profilep.h>

#include "stepslog.h"
#include "xdashteststeps.h"
#include "commontest.h"
#include "environments.h"

extern "C"
{
        ULONG DebugPrint(PCHAR Format, ...);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\settings\xdashsettings.cpp ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    XDashSettings.cpp

Abstract:

    The DLL exports two of the mandatory APIs: StartTest and EndTest.
    TESTINI.INI must be modified correctly so that the
    harness will load and call StartTest/EndTest.

    Please see "x-box test harness.doc" for more information.

Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10/16/2000  Created

*/


#include <xlog.h>
#include "stdafx.h"
#include "XDashSettings.h"
#include "tests.h"

namespace xdashsettings
{
    static BOOL printSteps = true;

    /*

    Routine Description:


    Arguments:

        HANDLE hLog - to the logging object
        CStepsLog* pStepsLog - Object used to log our test steps

    Return Value:

        DWORD

    */
    DWORD XDashSettingsRunAll( HANDLE hLog, CStepsLog* pStepsLog )
    {
        struct APIFUNCT
        {
            APITEST_FUNC f;
            WCHAR *name;
            char *aname;
        };
    
        #define BUILTAPISTRUCT(n) { n , L#n , #n }

        // Define all the API tests
        APIFUNCT testlist[] =
        {
            /*
            */
            BUILTAPISTRUCT( ClockInitialBootGoodBattery ),
            BUILTAPISTRUCT( ClockInitialBootBadBattery ),
            BUILTAPISTRUCT( ClockStartRange ),
            BUILTAPISTRUCT( ClockEndRange ),
            BUILTAPISTRUCT( ClockMonthsUseValidNumDays ),
            BUILTAPISTRUCT( ClockFebUseValidNumDaysLeapYear ),
            BUILTAPISTRUCT( ClockDatesStoredToXDisk ),
            BUILTAPISTRUCT( ClockSetUsingXZone ),
            BUILTAPISTRUCT( ClockXZoneSetsDSTInfo ),
            BUILTAPISTRUCT( ClockManualSetRemovesDSTInfo ),
            BUILTAPISTRUCT( ClockDSTUpdatesXBoxAlreadyOn ),
            BUILTAPISTRUCT( ClockDSTUpdatesXBoxPoweredOn ),
            BUILTAPISTRUCT( ClockXZoneSetClockPowerOff ),
            BUILTAPISTRUCT( ClockXZoneSetClockUnplugPower ),
            BUILTAPISTRUCT( ClockXZoneSetClockUnplugBB ),
            BUILTAPISTRUCT( ClockNewSettingUpdatesClockOnly ),
            BUILTAPISTRUCT( LangXBoxRegionsCorrectLanguage ),
            BUILTAPISTRUCT( LangNewLangDisplayAndConfig ),
            BUILTAPISTRUCT( LangNewLangUpdatesLangOnly ),
            BUILTAPISTRUCT( VideoInitalBootCorrectDefault ),
            BUILTAPISTRUCT( VideoNewSettingDisplayAndConfig ),
            BUILTAPISTRUCT( VideoNewSettingUpdatesVideoOnly ),
            BUILTAPISTRUCT( AudioInitalBootCorrectDefault ),
            BUILTAPISTRUCT( AudioChoicesNoAVPack ),
            BUILTAPISTRUCT( AudioChoicesWithAVPack ),
            BUILTAPISTRUCT( AudioNewSettingConfig )
            /*
            */
        };

        // Run the suite of tests

        // run each test
        for( size_t j = 0; j < ARRAYSIZE( testlist ); j++ )
        {
            xSetFunctionName(hLog, testlist[j].aname);
            DebugPrint( "%s: Entering test = '%ws()'\n", COMPONENT_NAME_A, testlist[j].name );

            // Log the testcase name to our steps log
            pStepsLog->SetCaseName( testlist[j].name );
            testlist[j].f( hLog, pStepsLog );

            // Log the test case (if the user wishes to)
            if ( printSteps )
            {
                pStepsLog->LogTestCase();
            }

            // Clear out the log for our next test
            pStepsLog->ClearTestCase();
        }

        return 0;
    }
}; // namespace

/*

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

*/
VOID WINAPI XDashSettingsStartTest( HANDLE hLog )
{
    using namespace xdashsettings;

    // test settings
    const int buffLen = 1024;
    
    char* ownerAlias     = new char[buffLen];
    char* componentMajor = new char[buffLen];
    char* componentMinor = new char[buffLen];
    char* stepsFileName  = new char[buffLen];
    int HTMLLogFormat    = 0;

    if( ownerAlias && componentMajor && componentMinor && stepsFileName )
    {
        // Object used to log our steps
        CStepsLog StepsLog;

        // Pull out internal INI file settings
        GetProfileStringA( DLL_NAME_A,   "Owner",           "Owner",          ownerAlias,     buffLen );
        GetProfileStringA( DLL_NAME_A,   "ComponentMajor",  "ComponentMajor", componentMajor, buffLen );
        GetProfileStringA( DLL_NAME_A,   "ComponentMinor",  "ComponentMinor", componentMinor, buffLen );
        GetProfileStringA( DLL_NAME_A,   "StepsFile",       "StepsFile",      stepsFileName,  buffLen );
        printSteps = GetProfileIntA( DLL_NAME_A, "PrintSteps", 0 );
        HTMLLogFormat = GetProfileIntA( DLL_NAME_A, "HTMLStepsLog", 1 );

        // Set the format for our STEPS log file
        StepsLog.SetHTMLLogFormat( HTMLLogFormat );

        xSetOwnerAlias( hLog, ownerAlias );
        xSetComponent( hLog, componentMajor, componentMinor );
        DebugPrint( "%s: **************************************************************\n", COMPONENT_NAME_A );
        DebugPrint( "%s: Entering %sStartTest()\n", COMPONENT_NAME_A, COMPONENT_NAME_A );
        DebugPrint( "%s: Internal INI Settings:\n", COMPONENT_NAME_A );
        DebugPrint( "   Owner           = '%s'\n", ownerAlias );
        DebugPrint( "   Component Major = '%s'\n", componentMajor );
        DebugPrint( "   Component Minor = '%s'\n", componentMinor );

        // Open our Steps Log File
        if (printSteps)
        {
            StepsLog.OpenLog( stepsFileName );
        }

        XDashSettingsRunAll( hLog, &StepsLog );

        if ( printSteps )
        {
            // Close our Steps Log File
            StepsLog.CloseLog();
        }

        DebugPrint( "%s: Leaving %sStartTest()\n", COMPONENT_NAME_A, COMPONENT_NAME_A );
        DebugPrint( "%s: **************************************************************\n", COMPONENT_NAME_A );
        xSetOwnerAlias( hLog, NULL );
    }
    else // Memory allocation failed
    {
        DebugPrint( "**ERROR: %sStartTest():Could not allocate memory!!", COMPONENT_NAME_A );
    }

    if( ownerAlias )
    {
        delete[] ownerAlias;
        ownerAlias = NULL;
    }

    if( componentMajor )
    {
        delete[] componentMajor;
        componentMajor = NULL;
    }
    
    if( componentMinor )
    {
        delete[] componentMinor;
        componentMinor = NULL;
    }
    
    if( stepsFileName )
    {
        delete[] componentMinor;
        componentMinor = NULL;
    }
}


/*

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

*/
VOID WINAPI XDashSettingsEndTest(void)
{
}


#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( xdashsettings )
#pragma data_seg()

BEGIN_EXPORT_TABLE( xdashsettings )
    EXPORT_TABLE_ENTRY( "StartTest", XDashSettingsStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XDashSettingsEndTest )
END_EXPORT_TABLE( xdashsettings )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\tools\xdashuiobjects\xdashcontrol.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    XDashControl.cpp

Abstract:
    This object can be used to set information about a control that
    lives on a screen within the XDash

Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-16-2000  Created

Notes:

*/

#include "xdashcontrol.h"


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This is the default constructor.  Initialization of properies is done
  here.

Arguments:

Return Value:

------------------------------------------------------------------------------*/
CXDashControl::CXDashControl()
{
    m_Name = NULL;
    m_Destination = NULL;
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This constructor allows the user to pass in the control name and the
  control destination, so that they can set them at object creation time.

Arguments:
  char* controlName - The name of the control.
  char* controlDestination - The destination the user would end up on if they
                              selected this control.

Return Value:

------------------------------------------------------------------------------*/
CXDashControl::CXDashControl( char* controlName, char* controlDestination )
{
    m_Name = NULL;
    m_Destination = NULL;

    UpdateControl( controlName, controlDestination );
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  The destructor.  Any memory allocation the object creates will be cleaned
  up here.

Arguments:

Return Value:

------------------------------------------------------------------------------*/
CXDashControl::~CXDashControl()
{
    // If we allocated space for a control name,
    // let's clean up
    if( m_Name )
    {
        delete[] m_Name;
        m_Name = NULL;
    }

    // If we allocated space for a control destination,
    // let's clean up
    if( m_Destination )
    {
        delete[] m_Destination;
        m_Destination = NULL;
    }
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This function will set the control name and control destination.  This is
  called by the user, or the contructor.

Arguments:
  WCHAR* controlName - The name of the control.
  WCHAR* controlDestination - The destination the user would end up on if they
                              selected this control.

Return Value:

------------------------------------------------------------------------------*/
void CXDashControl::UpdateControl( char* controlName, char* controlDestination )
{
    // Check to make sure we were passed in valid parameters, otherwise error and
    // return
    if( !controlName || !controlDestination )
    {
        DebugPrint( "CXDashControl::UpdateControl():Invalid Parameter passed in\r\n" );
        return;
    }

    // If we already have allocated space for a name, let's clean it up so that
    // we can replace it with our new name
    if( m_Name )
    {
        delete[] m_Name;
        m_Name = NULL;
    }

    // Allocate memory for our new name, and copy the information in to it
    m_Name = _strdup( controlName );

    // If we already have allocated space for a destination, let's clean it up so that
    // we can replace it with our new destination
    if( m_Destination )
    {
        delete[] m_Destination;
        m_Destination = NULL;
    }

    // Allocate memory for our new destination, and copy the information in to it
    m_Destination = _strdup( controlDestination );

    // Alert our developer if there was a failure to allocate memory
    if( !m_Name || !m_Destination )
    {
        DebugPrint( "CXDashControl::UpdateControl( char*, char* ): Failed to allocate memory!!\r\n" );
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\tools\stepslog\stepslog.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    StepsLog.cpp

Abstract:
    This object can be used to log test steps and variations to a file
    so that cases can be run manually

Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-10-2000  Created

Notes:

*/

#include "StepsLog.h"
#include <stdio.h>

// Constructor
CStepsLog::CStepsLog()
{
    DebugPrint("CStepsLog::CStepsLog()\r\n");

    m_LogFile          = NULL;
    m_bHTMLLogFormat   = USE_HTML_DEFAULT;

    m_bCaseLogged      = false;
    m_numTestCases     = 0;
    
    m_currentCaseName  = NULL;
    
    m_maxSteps         = MAX_STEPS;
    m_currentStep      = 0;
    m_steps            = new WCHAR*[MAX_STEPS];

    m_maxVariations    = MAX_VARIATIONS;
    m_currentVariation = 0;
    m_variations       = new WCHAR*[MAX_VARIATIONS];

    // Initialize all our step pointers to NULL
    for( size_t i=0; i < MAX_STEPS; ++i )
    {
        m_steps[i] = NULL;
    }

    // Initial all our variation pointers to NULL
    for( i=0; i < MAX_VARIATIONS; ++i )
    {
        m_variations[i] = NULL;
    }
}

// Destructor
CStepsLog::~CStepsLog()
{
    DebugPrint("CStepsLog::~CStepsLog()\r\n");

    // If our log file is opened, then lets close it
    if ( m_LogFile )
    {
        CloseLog();
    }

    // Clean up our arrays -- This will delete memory allocated for the test case name,
    // and memory for each WCHAR array within m_steps and m_variations
    ClearTestCase();

    // Clear out the space we allocated for our test steps
    if( m_steps )
    {
        delete[] m_steps;
        m_steps = NULL;
    }

    // Clear out the space we allocated for our test variations
    if( m_variations )
    {
        delete[] m_variations;
        m_variations = NULL;
    }
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This routine will let clear out the memory used by the current test case.
  That includes zeroing out the test case name memory, and deleting all memory
  set by the m_steps and m_variations arrays.

  NOTE: This should be called between each test case!

Arguments:

Return Value:

------------------------------------------------------------------------------*/
void CStepsLog::ClearTestCase()
{
    ClearTestCaseName();
    ClearSteps();
    ClearVariations();
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This routine will let zero out the memory used by the current test case name.

Arguments:

Return Value:

------------------------------------------------------------------------------*/
void CStepsLog::ClearTestCaseName()
{
    // Reset our flag indicating whether or not this case was logged
    m_bCaseLogged = false;

    // Clear out the memory space we have allocated for our test case name
    if( m_currentCaseName )
    {
        delete[] m_currentCaseName;
        m_currentCaseName = NULL;
    }
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This routine will let clear out the memory used by the current set of steps so
  that a new set of steps can be created.

Arguments:

Return Value:

------------------------------------------------------------------------------*/
void CStepsLog::ClearSteps()
{
    // Set our current step to 0
    m_currentStep = 0;

    // Destroy any memory we have allocated
    if( m_steps )
    {
        for( size_t i=0; i < MAX_STEPS; ++i )
        {
            if( m_steps[i] )
            {
                delete[] m_steps[i];
                m_steps[i] = NULL;
            }
        }
    }
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This routine will let clear out the memory used by the current set of
  variations so that a new set of steps can be created.

Arguments:

Return Value:

------------------------------------------------------------------------------*/
void CStepsLog::ClearVariations()
{
    // Set our current step to 0
    m_currentVariation = 0;

    // Destroy any memory we have allocated
    if( m_variations )
    {
        for( size_t i=0; i < MAX_VARIATIONS; ++i )
        {
            if( m_variations[i] )
            {
                delete[] m_variations[i];
                m_variations[i] = NULL;
            }
        }
    }
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This routine will let set the name of the current Test Case

Arguments:

  caseName - An array of wide characters that is the "test case name" the user
             wishes to use for the current steps and variations.

Return Value:

------------------------------------------------------------------------------*/
void CStepsLog::SetCaseName( const WCHAR* caseName )
{
    if( !caseName )
    {
        DebugPrint( "CStepsLog::SetTestCaseName():caseName not set!\r\n" );
        return;
    }

    size_t caseNameLen = wcslen( caseName ) + 1;
    
    // If there is already a case name, let's clear out the memory
    if( m_currentCaseName )
    {
        ClearTestCaseName();
    }

    m_currentCaseName = new WCHAR[caseNameLen];
    wcscpy( m_currentCaseName, caseName );
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This routine will let the user add steps to the class array.

Arguments:

  lpwszFormat - An array of wide characters that is the "step" the user
                wishes to add to the array.  This is the formated string.

  ... - A list of arguments used with the formated string passed in to form
        the step

Return Value:

------------------------------------------------------------------------------*/
void CStepsLog::AddStep( const WCHAR* lpwszFormat, ... )
{
    // DebugPrint("  CStepsLog::AddStep()\r\n");

    // Make sure we were passed in a valid pointer
    if ( !lpwszFormat )
    {
        DebugPrint( "  CStepsLog::AddStep():!lpwszFormat is true!\r\n" );
        return;
    }

    va_list args;
    va_start( args, lpwszFormat );

    WCHAR step[STEP_SIZE];

    vswprintf( step, lpwszFormat, args );

    // DebugPrint( "CStepsLog::AddStep():step = '%S'\r\n", step );

    // Get the length of the information the user wishes to add (plus space for a \0)
    size_t newStepLength = wcslen( step ) + 1;
    // DebugPrint( "CStepsLog::AddStep():newStepLength = '%d'\r\n", newStepLength );

    // Add the step if there isn't already one here
    if( ( !m_steps[m_currentStep] ) && ( m_currentStep < MAX_STEPS ) )
    {
        // DebugPrint( "CStepsLog::AddStep():Creating Step '%d'.\r\n", m_currentStep );

        m_steps[m_currentStep] = new WCHAR[newStepLength];
        if( !m_steps[m_currentStep] )
        {
            DebugPrint( "CStepsLog::AddStep():Couldn't allocate memory!!\r\n" );
            return;
        }

        wcscpy( m_steps[m_currentStep], step );

        m_currentStep++;
    }
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This routine will let the user add a variation to the m_variations array.

Arguments:

  lpwszFormat - An array of wide characters that is the "variation" the user
                wishes to add to the array.  This is the formated string.

  ... - A list of arguments used with the formated string passed in to form
        the variation

Return Value:

------------------------------------------------------------------------------*/
void CStepsLog::AddVariation( const WCHAR* lpwszFormat, ... )
{
    // DebugPrint("CStepsLog::AddVariation()\r\n");

    // Make sure we were passed in a valid pointer
    if ( !lpwszFormat )
    {
        DebugPrint( "  CStepsLog::AddVariation():!lpwszFormat is true!\r\n" );
        return;
    }

    va_list args;
    va_start( args, lpwszFormat );

    WCHAR variation[STEP_SIZE];

    vswprintf( variation, lpwszFormat, args );

    // DebugPrint( "CStepsLog::AddVariation():variation = '%S'\r\n", variation );

    // Get the length of the information the user wishes to add (plus space for a \0)
    size_t newVariationLength = wcslen( variation ) + 1;
    // DebugPrint( "CStepsLog::AddVariation():newVariationLength = '%d'\r\n", newVariationLength );

    // Add the step if there isn't already one here
    if( ( !m_variations[m_currentVariation] ) && ( m_currentVariation < MAX_VARIATIONS ) )
    {
        // DebugPrint( "CStepsLog::AddVariation():Creating Variation '%d'.\r\n", m_currentVariation );

        m_variations[m_currentVariation] = new WCHAR[newVariationLength];
        if( !m_variations[m_currentVariation] )
        {
            DebugPrint( "CStepsLog::AddVariation():Couldn't allocate memory!!\r\n" );
            return;
        }

        wcscpy( m_variations[m_currentVariation], variation );

        m_currentVariation++;
    }
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This routine will return a pointer to the step that the user requested

Arguments:

  index - The index of the step the user wishes to access.  Must be 0 based, and
          cannot exceed m_currentStep

Return Value:

------------------------------------------------------------------------------*/
WCHAR* CStepsLog::GetStep( const size_t index )
{
    if( ( index > m_currentStep ) || ( index < 0 ) )
    {
        return NULL;
    }

    return m_steps[index];
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This routine will return a pointer to the variation that the user requested

Arguments:

  index - The index of the step the user wishes to access.  Must be 0 based, and
          cannot exceed m_currentStep

Return Value:

------------------------------------------------------------------------------*/
WCHAR* CStepsLog::GetVariation( const size_t index )
{
    if( ( index > m_currentVariation ) || ( index < 0 ) )
    {
        return NULL;
    }

    return m_variations[index];
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This routine will let the user set the type of log to output (HTML, or plain text)

Arguments:

  bUseHTML - Boolean variable.  If true, the log will be output in HTML format.  If false, it will be plain text.

Return Value:

------------------------------------------------------------------------------*/
void CStepsLog::SetHTMLLogFormat( BOOL bUseHTML )
{
    DebugPrint("CStepsLog::SetHTMLLogFormat\r\n");

    if ( !m_LogFile )
    {
        m_bHTMLLogFormat = bUseHTML;
    }
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This routine will open a file to log the desired test steps.

Arguments:

  lpszLogFileName - Pointer to a null-terminated string that specifies the filename to which the log output will be directed.  This member is NULL if the user wishes to use the default filename.

Return Value:

------------------------------------------------------------------------------*/
void CStepsLog::OpenLog( char* lpszLogFileName = NULL )
{
    DebugPrint("CStepsLog::OpenLog\r\n");

    // If we don't already have a log open, let's create one
    if ( !m_LogFile )
    {
        // If the user does not specify a log file name
        // lets use the default
        if ( lpszLogFileName ) // Use the user defined log name
        {
            m_LogFile = fopen( lpszLogFileName, "w+" );
        }
        else  // Use the default log name
        {
            char* lpwszFileName = NULL;

            if ( m_bHTMLLogFormat )
            {
                lpwszFileName = new char[wcslen( DEFAULT_DRIVE ) + wcslen( DEFAULT_LOG_NAME ) + wcslen( HTML_FILE_EXT ) + 1];
                if( !lpwszFileName )
                {
                    DebugPrint( "CStepsLog::OpenLog(): Couldn't allocate memory!\r\n" );
                    return;
                }

                sprintf( lpwszFileName, "%S%S%S", DEFAULT_DRIVE, DEFAULT_LOG_NAME, HTML_FILE_EXT );
            }
            else
            {
                lpwszFileName = new char[wcslen( DEFAULT_DRIVE ) + wcslen( DEFAULT_LOG_NAME ) + wcslen( TEXT_FILE_EXT ) + 1];
                if( !lpwszFileName )
                {
                    DebugPrint( "CStepsLog::OpenLog(): Couldn't allocate memory!\r\n" );
                    return;
                }
                
                sprintf( lpwszFileName, "%S%S%S", DEFAULT_DRIVE, DEFAULT_LOG_NAME, TEXT_FILE_EXT );
            }

            m_LogFile = fopen ( lpwszFileName, "w+" );

            // Clean up our memory
            delete[] lpwszFileName;
            lpwszFileName = NULL;
        }
        
        // Verify our log file was opened.  If not, print a debug line,
        // if it was, see if we need to export the HTML Header
        if ( !m_LogFile )
        {
            DebugPrint( "Failed to open the Steps Log!\r\n" );
        }
        else if ( m_bHTMLLogFormat )
        {
            fwprintf( m_LogFile, HTML_HEADER );
        }
    }
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This routine will log the test case name to the file.

Arguments:

  lpszCaseName - Pointer to a null-terminated string that specifies the test case name.

Return Value:

------------------------------------------------------------------------------*/
void CStepsLog::LogTestCase()
{
    DebugPrint("CStepsLog::LogTestCase()\r\n");

    // if our log file is opened, let's output some formatting (if needed)
    if ( m_LogFile )
    {
        // If the log is in HTML format, let's set it up appropriately, otherwise set it up for TEXT mode
        if ( m_bHTMLLogFormat )
        {
            fwprintf( m_LogFile, L"      <TR>\n        <TD>\n" );
        }
        else // text mode
        {
            fwprintf( m_LogFile, L"\n\n" );
        }
        
        LogCaseName();
        LogSteps();
        LogVariations();

        // If the log is in HTML format, let's close it out appropriately
        if ( m_bHTMLLogFormat )
        {
            fwprintf( m_LogFile, L"        </TD>\n      </TR>\n" );
        }
    }
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This routine will log the test case name to the file.

Arguments:

  lpszCaseName - Pointer to a null-terminated string that specifies the test case name.

Return Value:

------------------------------------------------------------------------------*/
void CStepsLog::LogCaseName()
{
    DebugPrint("  CStepsLog::LogCaseName()\r\n");

    // Incrememt the total number of test cases
    ++m_numTestCases;

    // if our log file is opened, and the user passed in a
    // valid pointer, let's log the case name to the file
    if ( m_LogFile )
    {
        // If the log is in HTML format, let's set it up appropriately
        if ( m_bHTMLLogFormat )
        {
            fwprintf( m_LogFile, L"          <H3>%d. ", m_numTestCases );
        }
        
        // Log the case name itself
        fwprintf( m_LogFile, m_currentCaseName );

        // If the log is in HTML format, let's close it up appropriately, otherwise close it for TEXT mode
        if ( m_bHTMLLogFormat )
        {
            fwprintf( m_LogFile, L"</H3>\n" );
        }
        else
        {
            fwprintf( m_LogFile, L"\n" );
        }
    }
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This routine will log a test variation to the current test case that's being logged.

Arguments:

  lpszVariation - Pointer to a null-terminated string that specifies the test case variation.

Return Value:

------------------------------------------------------------------------------*/
void CStepsLog::LogVariations()
{
    DebugPrint("  CStepsLog::LogVariations()\r\n");

    // if our log file is opened
    // pointer, let's log the test steps
    if( m_LogFile )
    {
        // DebugPrint("CStepsLog::LogVariations():m_LogFile is opened.\r\n");

        // Output our opening tag for HTML or TEXT mode
        if( m_bHTMLLogFormat )
        {
            fwprintf( m_LogFile, HTML_VAR_HEADER, m_numTestCases, m_numTestCases );
        }
        else
        {
            fwprintf( m_LogFile, L"\n" );
        }

        for( size_t variationNum=0; variationNum < m_currentVariation; ++variationNum )
        {
            // Format our variation output for HTML or TEXT
            if( m_bHTMLLogFormat )
            {
                fwprintf( m_LogFile, HTML_VAR_BEGIN );
            }
            else // text mode
            {
                fwprintf( m_LogFile, L"  " );
            }

            // Print the variation itself
            fwprintf( m_LogFile, m_variations[variationNum] );

            // If the log is in HTML Format, close variation Tag
            if( m_bHTMLLogFormat )
            {
                fwprintf( m_LogFile, HTML_VAR_END );
            }
            else // text mode
            {
                fwprintf( m_LogFile, L"\n" );
            }
        }

        // Output a closting tag for HTML format mode
        if( m_bHTMLLogFormat )
        {
            fwprintf( m_LogFile, HTML_VAR_FOOTER );
        }
    }
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This routine will log the test steps to the log file.

Arguments:

Return Value:

------------------------------------------------------------------------------*/
void CStepsLog::LogSteps()
{
    DebugPrint("  CStepsLog::LogSteps()\r\n");

    // if our log file is opened
    // pointer, let's log the test steps
    if( m_LogFile )
    {
        // DebugPrint("CStepsLog::LogSteps():m_LogFile is opened.\r\n");

        // If the log is in HTML Format mode, let's display things properly
        if( m_bHTMLLogFormat )
        {
            fwprintf( m_LogFile, HTML_STEP_HEADER );
        }
        else // text mode
        {
            fwprintf( m_LogFile, L"\n" );
        }

        for( size_t stepNum=0; stepNum < m_currentStep; ++stepNum )
        {
            // Format our step output for HTML or TEXT
            if( m_bHTMLLogFormat)
            {
                fwprintf( m_LogFile, HTML_STEP_BEGIN );
            }
            else
            {
                fwprintf( m_LogFile, L"  %d. ", stepNum+1 );
            }

            // Print the step itself
            fwprintf( m_LogFile, m_steps[stepNum] );


            if( m_bHTMLLogFormat )
            {
                fwprintf( m_LogFile, HTML_STEP_END );
            }
            else // text mode
            {
                fwprintf( m_LogFile, L"\n" );
            }
        }

        // If the log is in HTML Format, close our List Tag
        if( m_bHTMLLogFormat )
        {
            fwprintf( m_LogFile, HTML_STEP_FOOTER );
        }
    }
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This routine will close the log file if the user is done.
  This routine will be called when the destructor is called.

Arguments:

Return Value:

------------------------------------------------------------------------------*/
void CStepsLog::CloseLog()
{
    DebugPrint("CStepsLog::CloseLog()\r\n");

    // If the log is open, let's close it
    if ( m_LogFile )
    {
        // If the log file is in HTML format, append the HTML footer
        if ( m_bHTMLLogFormat )
        {
            fwprintf( m_LogFile, HTML_FOOTER );
        };

        if ( fclose ( m_LogFile ) == EOF )
        {
            DebugPrint("Failed to close the Steps Log!\r\n");
        };
        
        m_LogFile = NULL;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\3dobject.cpp ===
#include "stdafx.h"
#include "3dobject.h"

float divPI = 0.01745f;


// Constructor
C3DObject::C3DObject( void )
{
}


// Desctructor
C3DObject::~C3DObject( void )
{
}


void C3DObject::translate( float x, float y, float z )
{
	m_TranslateVector = m_TranslateVector + D3DXVECTOR4( x, y, z, 0.0f );
}


void C3DObject::rotateX( float x )
{
	D3DXMatrixRotationX( &m_WorkMatrix, x * divPI );

	m_ObjectMatrix = m_WorkMatrix * m_ObjectMatrix;
	D3DXVec4Transform( &m_TranslateVector, &m_TranslateVector, &m_WorkMatrix );
}


void C3DObject::rotateY( float y )
{
	D3DXMatrixRotationY( &m_WorkMatrix, y * divPI );

	m_ObjectMatrix = m_WorkMatrix * m_ObjectMatrix;
	D3DXVec4Transform( &m_TranslateVector, &m_TranslateVector, &m_WorkMatrix );
}


void C3DObject::rotateZ( float z )
{
	D3DXMatrixRotationZ( &m_WorkMatrix, z * divPI );

	m_ObjectMatrix = m_WorkMatrix * m_ObjectMatrix;
	D3DXVec4Transform( &m_TranslateVector, &m_TranslateVector, &m_WorkMatrix );
}


void C3DObject::spinX( float x )
{
	D3DXMatrixRotationX( &m_WorkMatrix, x * divPI );

	m_ObjectMatrix = m_WorkMatrix * m_ObjectMatrix;
}


void C3DObject::spinY( float y )
{
	D3DXMatrixRotationY( &m_WorkMatrix, y * divPI );

	m_ObjectMatrix = m_WorkMatrix * m_ObjectMatrix;
}


void C3DObject::spinZ( float z )
{
	D3DXMatrixRotationZ( &m_WorkMatrix, z * divPI );

	m_ObjectMatrix = m_WorkMatrix * m_ObjectMatrix;
}


void C3DObject::localRotateX( float x )
{
	D3DXMatrixRotationX( &m_WorkMatrix, x * divPI );

	m_ObjectMatrix = m_ObjectMatrix * m_WorkMatrix;
}


void C3DObject::localRotateY( float y )
{
	D3DXMatrixRotationY( &m_WorkMatrix, y * divPI );

	m_ObjectMatrix = m_ObjectMatrix * m_WorkMatrix;
}


void C3DObject::localRotateZ( float z )
{
	D3DXMatrixRotationZ( &m_WorkMatrix, z * divPI );

	m_ObjectMatrix = m_ObjectMatrix * m_WorkMatrix;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\tools\xdashuiobjects\xdashscreenlist.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    XDashScreenList.cpp

Abstract:
    This object can be used to hold a list of screens.  a screen consists
    of a name, and a list of controls and their destinations.

Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-16-2000  Created

Notes:

*/

#include "xdashscreenlist.h"


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This is the default constructor.  Initialization of properies is done
  here.

Arguments:

Return Value:

------------------------------------------------------------------------------*/
CXDashScreenList::CXDashScreenList()
{
    // Initial our member variables
    PropertyInit();
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This constructor will accept an INI File name, and will immediately parse the
  file and populate our lists.

Arguments:
  char* iniFileName - The name of the INI file that contains the screen
                       information

Return Value:

------------------------------------------------------------------------------*/
CXDashScreenList::CXDashScreenList( char* iniFileName )
{
    // Initial our member variables
    PropertyInit();

    // Populate our arrays with the data found in the INI File that was passed in
    GetScreensFromINI( iniFileName );
};



/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  The destructor.  Any memory this object allocates will be cleaned up here.

Arguments:

Return Value:

------------------------------------------------------------------------------*/
CXDashScreenList::~CXDashScreenList()
{
    // Clean up the memory we allocated for our screen list
    if ( m_Screens )
    {
        delete[] m_Screens;
        m_Screens = NULL;
    }
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This function will be called by our constructors to initialize our memory
  variables.

Arguments:

Return Value:

------------------------------------------------------------------------------*/
void CXDashScreenList::PropertyInit()
{
    m_Screens = NULL;   // Set our Screens member to NULL
    m_numScreens = 0;   // The number of screens we currently have in our list
};



/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This function will allow a user to add a screen to their list.  It simply
  needs a name for the screen, which the user passes in.

Arguments:
  char* screenName - The name of the screen to be added to our screen list

Return Value:

------------------------------------------------------------------------------*/
void CXDashScreenList::AddScreenToList( char* screenName )
{
    // Make sure we were passed a valid pointer.  If not, error and bail
    if( !screenName )
    {
        DebugPrint( "CXDashScreenList::AddScreenToList( char* ):Invalid parameter passed in\r\n" );
        return;
    }

    // Make sure we have enough room to add a screen.  If not, error and bail
    if( m_numScreens >= MAX_SCREENS )
    {
        DebugPrint( "CXDashScreenList::AddScreenToList():Exceeded screen list maximum size = '%d'!!\r\n", MAX_SCREENS );
        return;
    }

    // Increment the number of screens the list contains
    ++m_numScreens;

    // Set the name of the screen the user wishes to add
    m_Screens[m_numScreens - 1].SetScreenName( screenName );
}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This function will allow a user to add a control to the current screen.  The
  current screen is the last screen that was added to our list.

Arguments:
  char* controlName - The name of the control to be added to our screen
  char* controlDest - The destination of the control to be added to our screen

Return Value:
------------------------------------------------------------------------------*/
void CXDashScreenList::AddControlToScreen( char* controlName, char* controlDest )
{
    // Make sure we were passed a valid pointer.  If not, inform the user and return
    if( !controlName || !controlDest )
    {
        DebugPrint( "CXDashScreenList::AddControlToScreen( char* ):Invalid parameter passed in\r\n" );
        return;
    }

    // Make sure that there has been at least one screen added before we update controls - If not, inform the
    // user and return
    if( m_numScreens <= 0 )
    {
        DebugPrint( "CXDashScreenList::AddControlToScreen( char* ):No Screens have been added to the list yet!!\r\n" );
        return;
    }

    // Make sure we have allocated memory for our screens -- If not, inform the user and return
    if( !m_Screens )
    {
        DebugPrint( "CXDashScreenList::AddControlToScreen( char* ):m_Screens has not be allocated any memory!!\r\n" );
        return;
    }

    // Add the control to our current screen
    m_Screens[m_numScreens - 1].AddControl( controlName, controlDest );
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This function will allow a user to get the number of controls that are on the
  current screen.  The current screen is the last screen that was added to our
  list.

Arguments:

Return Value:
  size_t - The number of screens that the current (last) screen has defined
           within its control list

  This function will also return 0 if there are no screens defined in our
  screen list
------------------------------------------------------------------------------*/
size_t CXDashScreenList::GetNumControlsOnCurrentScreen()
{
    // Check to see if there are any screen in our list -- If not, inform the user and return 0
    if( GetNumScreens() == 0 )
    {
        DebugPrint( "CXDashScreenList::GetNumControlsOnCurrentScreen():No screens in list!!\r\n" );
        return 0;
    }

    // Return the number of controls from our current screen
    return m_Screens[m_numScreens - 1].GetNumControls();
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This function will allow a user to get the number of controls that are on the
  screen specified by an index.  The current screen is the last screen that was added to our
  list.

Arguments:
  size_t index - The 0 based index of the screen they wish to have the number
                 of controls for.

Return Value:
  size_t - The number of screens that the current (last) screen has defined
           within its control list

  This function will also return 0 if the user passes in an invalid index
------------------------------------------------------------------------------*/
size_t CXDashScreenList::GetNumControlsOnScreenByIndex( size_t index )
{
    // Check to see if the index is valid -- If not, inform the user and return 0
    if( index < 0 || index >= GetNumScreens() )
    {
        DebugPrint( "CXDashScreenList::GetNumControlsOnScreenByIndex( size_t ):index out of range - '%d'\r\n", index );
        return 0;
    }

    // Return the number of controls for the specified screen
    return m_Screens[index].GetNumControls();
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This function will allow a user to get the name of a control from a specific
  screen by specifying the screen index, and the control index within that
  screen.

Arguments:
  size_t screenIndex - The 0 based index of the screen they are interested in
  size_t controlIndex - The 0 based index of the control they are interested in

Return Value:
  char* - A pointer to the name of the control the user is intetersted in.

  If the user passes in an invalid parameter, of if there is an error,
  the function will return NULL.
------------------------------------------------------------------------------*/
char* CXDashScreenList::GetControlNameFromScreenByIndex( size_t screenIndex, size_t controlIndex )
{
    // Check the screen index to ensure it's within range
    if( screenIndex < 0 || screenIndex >= GetNumScreens() )
    {
        DebugPrint( "CXDashScreenList::GetControlNameFromScreenByIndex( size_t, size_t ):screenIndex out of range - '%d'\r\n", screenIndex );
        return NULL;
    }

    // Check the control index to ensure it's within range
    if( controlIndex < 0 || controlIndex >= m_Screens[screenIndex].GetNumControls() )
    {
        DebugPrint( "CXDashScreenList::GetControlNameFromScreenByIndex( size_t, size_t ):controlIndex out of range - '%d'\r\n", controlIndex );
        return NULL;
    }

    // Return the name of the control to the user
    return m_Screens[screenIndex].GetControlNameByIndex( controlIndex );
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This function will allow a user to get the destination of a control from a 
  specific screen by specifying the screen index, and the control index within
  that screen.

Arguments:
  size_t screenIndex - The 0 based index of the screen they are interested in
  size_t controlIndex - The 0 based index of the control they are interested in

Return Value:
  char* - A pointer to the destination of the control the user is intetersted
           in.

  If the user passes in an invalid parameter, of if there is an error,
  the function will return NULL.
------------------------------------------------------------------------------*/
char* CXDashScreenList::GetControlDestFromScreenByIndex( size_t screenIndex, size_t controlIndex )
{
    // Check the screen index to ensure it's within range
    if( screenIndex < 0 || screenIndex >= GetNumScreens() )
    {
        DebugPrint( "CXDashScreenList::GetControlDestFromScreenByIndex( size_t, size_t ):screenIndex out of range - '%d'\r\n", screenIndex );
        return NULL;
    }

    // Check the control index to ensure it's within range
    if( controlIndex < 0 || controlIndex >= m_Screens[screenIndex].GetNumControls() )
    {
        DebugPrint( "CXDashScreenList::GetControlDestFromScreenByIndex( size_t, size_t ):controlIndex out of range - '%d'\r\n", controlIndex );
        return NULL;
    }

    // Return the destination of the control to the user
    return m_Screens[screenIndex].GetControlDestByIndex( controlIndex );
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This function will allow a user to get the name of a screen at a specific
  index.

Arguments:
  size_t index - The 0 based index of the screen they are interested in

Return Value:
  char* - A pointer to the name of the screen the user is intetersted in.

  If the user passes in an invalid parameter, of if there is an error,
  the function will return NULL.
------------------------------------------------------------------------------*/
char* CXDashScreenList::GetScreenNameByIndex( size_t index )
{
    // Check to make sure our index is valid -- If not, inform the user and return NULL
    if( index < 0 || index >= GetNumScreens() )
    {
        DebugPrint( "CXDashScreenList::GetScreenNameByIndex( size_t ):index out of range - '%d'\r\n", index );
        return NULL;
    }

    // Return the name of the screen the user is interested in
    return m_Screens[index].GetScreenName();
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This function will return the name of the current screen.  The current screen
  is the screen that was added last to our list.

Arguments:

Return Value:
  char* - A pointer to the name of the current (last) screen

  If there is an error, the function will return NULL.
------------------------------------------------------------------------------*/
char* CXDashScreenList::GetCurrentScreenName()
{
    // Make sure we have a current screen -- If not, inform the user, and return NULL
    if( m_numScreens == 0 )
    {
        DebugPrint( "CXDashScreenList::GetCurrentScreenName():No screens in list!!\r\n" );
        return NULL;
    }

    // Return the name of the current screen
    return m_Screens[m_numScreens - 1].GetScreenName();
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This function will return the name of a control specified by the user, from
  the current screen.  The current screen is the screen that was added last to
  our list.

Arguments:
  size_t index - The 0 based index of the control from the current screen that
                 the user is interested in.

Return Value:
  char* - A pointer to the name of the control that the user is interested in

  If there is an error, the function will return NULL.
------------------------------------------------------------------------------*/
char* CXDashScreenList::GetControlFromCurrentScreenByIndex( size_t index )
{
    // Check to make sure we have some screens in our list -- If not, inform user and return NULL
    if( 0 == m_numScreens )
    {
        DebugPrint( "CXDashScreenList::GetControlFromCurrentScreen( size_t ):No screen in list!!\r\n" );
        return NULL;
    }

    // Check to make sure the index is valid -- If not, inform user and return NULL
    if( index < 0 || index >= m_Screens[m_numScreens - 1].GetNumControls() )
    {
        DebugPrint( "CXDashScreenList::GetControlFromCurrentScreen( size_t ):index out of range - '%d'\r\n", index );
        return NULL;
    }

    // Return the name of the control to the user
    return m_Screens[m_numScreens - 1].GetControlNameByIndex( index );
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This function will parse an INI file, and populate our data structures with
  the information from the file.

Arguments:
  char* iniFileName - The name of the INI file that the function should
                       parse

Return Value:
------------------------------------------------------------------------------*/
void CXDashScreenList::GetScreensFromINI( char* iniFileName )
{
    // If the user did not pass a valid file name, inform them and return
    if( !iniFileName )
    {
        DebugPrint("CXDashScreenList::GetScreensFromINI( char* ):iniFileName not set!!\r\n" );
        return;
    }

    // Check to see if we've already allocated memory for our screens.  If so, delete
    // the memory we've allocated, and create new space
    if( m_Screens )
    {
        delete[] m_Screens;
        m_Screens = NULL;
    }

    // Allocate memory to hold our screens
    m_Screens = new CXDashScreen[MAX_SCREENS];

    // If the memory allocation failed, inform user and return
    if( !m_Screens )
    {
        DebugPrint("**ERROR: CXDashScreenList::GetScreensFromINI( char* ):Couldn't allocate memory!!\r\n" );
        return;
    }

    FILE* iniFile = NULL;           // The stream we will get when opening the INI file
    char fileLine[MAX_LINE_SIZE];   // Used to hold each line from the INI file as we read it in
    char* subString = NULL;         // Used several times to parse the 'fileLine' from the INI file
    BOOL bReturnEarly = false;      // Used if we have a problem, and want to return early but STILL CLEAN UP

    // Zero our our file buffer memory (helps for debugging if there is a problem down the road)
    ZeroMemory( fileLine, sizeof(char) * MAX_LINE_SIZE );
    
    // Open the INI file for reading
    iniFile = fopen( iniFileName, "r" );

    // If there was a problem opening the INI file, inform the user and return
    if( !iniFile )
    {
        DebugPrint("CXDashScreenList::GetScreensFromINI( char* ):Could not open INI file - '%S'\r\n", iniFileName );
        return;
    }

    // Read in lines from the INI file until we reach the end of file (fgetws will return NULL)
    while( fgets( fileLine, MAX_LINE_SIZE, iniFile ) )
    {
        // If it's a comment line, skip to the next line of the file before doing ANY processing
        if( fileLine[0] == COMMENT_CHAR_A )
        {
            continue;
        }

        // Remove any newline characters from the line, so they are not added to our arrays (fgetws leaves newlines in)
        NullCharInString( fileLine, '\n' );

        // If the line contains the NAME_TOKEN, add a new screen to our list
        if( subString = strstr( fileLine, NAME_TOKEN_A ) )
        {
            AddScreenToList( subString + strlen( NAME_TOKEN_A ) );
        }
        else if( subString = strstr( fileLine, CONTROL_TOKEN_A ) )  // If the line contains the CONTROL_TOKEN, add a new control with its destination to our current screen
        {
            char* controlName = _strdup( subString + strlen( CONTROL_TOKEN_A ) );    // The name of our control minus the CONTROL_TOKEN from the INI file (stored since we will overwrite fileLine)
            char* lpDestToken = NULL;                                                // Used to determine if the line from the INI file contains the destination of the current control we are dealing with

            subString = NULL;   // Set subString back to NULL now that we are finished with it

            // Make sure we could allocate memory to hold our control name -- If not, inform user and return early
            if( !controlName )
            {
                DebugPrint("**ERROR: CXDashScreenList::GetScreensFromINI( char* ):Couldn't allocate memory!!\r\n" );
                bReturnEarly = true;
            }

            // Make sure there wasn't a problem above, and continue if there was not
            if( !bReturnEarly )
            {
                // Read the next line of the file (which is REQUIRED to be a ControlDestination) -- If not, inform user and return early
                if( !fgets( fileLine, MAX_LINE_SIZE, iniFile ) )
                {
                    DebugPrint("**CXDashScreenList::GetScreensFromINI( char* ):Found control with no destination - 1!!\r\n" );
                    bReturnEarly = true;
                }

                if( !bReturnEarly )
                {
                    // Remove any newline characters from the line, so they are not added to our arrays (fgetws leaves newlines in)
                    NullCharInString( fileLine, '\n' );

                    // search for our CONTROL_DEST_TOKEN from our file line
                    lpDestToken = strstr( fileLine, CONTROL_DEST_TOKEN_A );

                    // Make sure we found the token, if not, error and bail
                    // If so, add the control and the destination to the list of screens
                    if( !lpDestToken )
                    {
                        DebugPrint("CXDashScreenList::GetScreensFromINI( char* ):Found control with no destination - 2!!\r\n" );
                        bReturnEarly = true;
                    }

                    // Make sure there wasn't a problem above, and continue with the processing
                    if( !bReturnEarly )
                    {
                        // Let's get the actual name of the Control destination from the INI file
                        // Make sure our call succeeded, otherwise use what was pulled from the INI
                        char* lpControlDest = NULL;    // Used to hold the destination of our control from the INI

                        // Get the value of the screen destination from the INI file, so that names of screens are only recorded ONCE in an INI file
                        // If there was a problem, or the name wasn't found, we will use what was pulled from the INI file (user override)
                        if( lpControlDest = GetValueFromINI( iniFileName, lpDestToken + strlen( CONTROL_DEST_TOKEN_A ), "Name", MAX_LINE_SIZE ) )
                        {
                            AddControlToScreen( controlName, lpControlDest );

                            // Clean up the memory allocated by the call to GetPrivateProfileString
                            delete[] lpControlDest;
                        }
                        else
                        {
                            // Add the control using the original information pulled from the INI
                            AddControlToScreen( controlName, lpDestToken + strlen( CONTROL_DEST_TOKEN_A ) );
                        }
                    }
                }
            }
            
            // If we allocated memory, let's clean up
            if( controlName )
            {
                delete[] controlName;
                controlName = NULL;
            }

            // If the user wishes to return, we should break out of the loop so that we can clean up properly and exit
            // of the INI file
            if( bReturnEarly )
            {
                break;
            }
        }
    }

    // Close the file we opened
    if( iniFile )
    {
        fclose( iniFile );
    }

};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This function will get in to INI file specified by the user and return
  value.

Arguments:
  char* iniFileName - INI File the user wishes to parse
  char* iniSection - INI Section the user wishes to search
  char* iniKey - INI Key the user wishes to get the value of
  size_t bufferSize - Size of the buffer that user has to hold the information
                      found in the INI

Return Value:
  char* - pointer to the value that was found in the INI.  The caller is
          responsible for cleaning up memory allocated by this function

  If there is an error, NULL is returned
------------------------------------------------------------------------------*/
char* CXDashScreenList::GetValueFromINI( char* iniFileName, char* iniSection, char* iniKey, size_t bufferSize )
{
    BOOL bReturnEarly = false;

    // Check parameters
    if( !iniFileName || !iniSection || !iniKey )
    {
        DebugPrint("CXDashScreenList::GetValueFromINI():Invalid parameters passed in!!\r\n" );
        return NULL;
    }
    
    // Local Variables
    char* lpControlDest = new char[bufferSize];       // The control destination as pulled from the ini

    // Make sure we could allocate memory for our buffer -- If not, inform the user and exit
    if( !lpControlDest )
    {
        DebugPrint("**ERROR: CXDashScreenList::GetValueFromINI():Couldn't allocate memory - lpControlDest!!\r\n" );
        return NULL;
    }

    // Zero out our buffer memory (helps with debugging)
    ZeroMemory( lpControlDest, sizeof(char) * bufferSize );

    // Make sure our call succeeds, otherwise Error and bail
    if( 0 == GetPrivateProfileStringA( iniSection, iniKey, "Not Found", lpControlDest, bufferSize, iniFileName ) )
    {
        DebugPrint("CXDashScreenList::GetValueFromINI():Didn't find value in INI!  INI File: '%S', Section: '%S', Key: '%S', BufferSize: '%d'\r\n", iniFileName, iniSection, iniKey, bufferSize );
        bReturnEarly = true;
    }

    // Return the pointer to the value that was pulled from the INI file
    return lpControlDest;
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This function will NULL out the first instance of a user passed in character.

Arguments:
  char* targetString - Pointer to the targetString the user wishes to search
  char charToNull  - The character the user wishes to null out in the
                     targetString

Return Value:
  size_t - Will return a 0 if the character wasn't found, and a 1 if the
           character was found and nulled out.

  If there is an error, 0 is returned
------------------------------------------------------------------------------*/
size_t CXDashScreenList::NullCharInString( char* targetString, char charToNull )
{
    char* subString = NULL;     // Used to parse our targetString
    size_t returnVal = 0;       // Return value

    // Ensure we have a valid pointer -- If not, inform user and return 0
    if( !targetString )
    {
        DebugPrint( "CXDashScreenList::NullCharInString():Invalid parameters passed in\r\n" );
        return returnVal;
    }

    // See if there are any instances of the character in our string
    subString = strchr( targetString, charToNull );
    if( subString ) // If one is found, convert it to a NULL character
    {
        *subString = '\0';
        subString = NULL;   // Set our char* back to null for the next use
        returnVal = 1;      // Set our return value to 1 since we found a character
    }

    return returnVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\tools\xdashuiobjects\xdashscreen.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    XDashScreen.cpp

Abstract:
    This object can be used to set information about a screen that
    lives within the XDash.  The information includes the Name of the
    screen, and the controls that live on that screen

Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-16-2000  Created

Notes:

*/

#include "xdashscreen.h"


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This is the default constructor.  Initialization of properies is done
  here.

Arguments:

Return Value:

------------------------------------------------------------------------------*/
CXDashScreen::CXDashScreen()
{
    // Initialize our memory variables and allocate space
    PropertyInit();
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This constructor will allow the user to pass a screen name in, so that it can
  be set upon object creation.

Arguments:
  char* screenName - The name of the screen

Return Value:

------------------------------------------------------------------------------*/
CXDashScreen::CXDashScreen( char* screenName )
{
    // Initialize our memory variables and allocate space
    PropertyInit();

    // Call the method that will set the screen name
    SetScreenName( screenName );
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  The destructor.  Any memory this object allocates will be cleaned up here.

Arguments:

Return Value:

------------------------------------------------------------------------------*/
CXDashScreen::~CXDashScreen()
{
    // If the user allocated space to hold a screen name,
    // let's clean it up
    if( m_Name )
    {
        delete[] m_Name;
        m_Name = NULL;
    }

    // Clean up the memory we allocated to hold our array of controls
    if( m_Controls )
    {
        delete[] m_Controls;
        m_Controls = NULL;
    }
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This function will be called by our constructors to initialize our memory
  variables.

Arguments:

Return Value:

------------------------------------------------------------------------------*/
void CXDashScreen::PropertyInit()
{
    m_Name = NULL;
    m_Controls = NULL;
    m_numControls = 0;

    // Allocate memory to hold our array of controls
    m_Controls = new CXDashControl[NUM_CONTROLS];

    // If we failed to allocate memory, let's inform the user
    if( !m_Controls )
    {
        DebugPrint( "**ERROR: CXDashScreen::CXDashScreen(): failed to allocate memory!!" );
    }
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This function will return the name of the control that is specified by
  the user via an index.

Arguments:
  size_t index - The 0 based index number of the control the user wishes to
                 have the name of.

Return Value:

------------------------------------------------------------------------------*/
char* CXDashScreen::GetControlNameByIndex( size_t index )
{
    // Check to see if the user passed in a valid index.
    // If not, return NULL
    if( index < 0 || index >= GetNumControls() )
    {
        DebugPrint( "CXDashScreen::GetControlNameByIndex( size_t ): index out of range - '%d'\r\n", index );
        return NULL;
    }

    // Return the control at the index the user requested.
    return m_Controls[index].GetControlName();
};


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This function will return the destination of the control that is specified by
  the user via an index.

Arguments:
  size_t index - The 0 based index number of the control the user wishes to
                 have the description of.

Return Value:

------------------------------------------------------------------------------*/
char* CXDashScreen::GetControlDestByIndex( size_t index )
{
    // Check to see if the user passed in a valid index.
    // If not, return NULL
    if( index < 0 || index >= GetNumControls() )
    {
        DebugPrint( "CXDashScreen::GetControlDestByIndex( size_t ): index out of range - '%d'\r\n", index );
        return NULL;
    }

    // Return the control at the index the user requested.
    return m_Controls[index].GetControlDest();
};



/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This function will set the name of the screen.  It will allocate and free
  memory as necessary to do this.

Arguments:
  char* screenName - The name of the screen

Return Value:

------------------------------------------------------------------------------*/
void CXDashScreen::SetScreenName( char* screenName )
{
    // Make sure the user passed us a legitimate pointer
    if( !screenName )
    {
        DebugPrint( "CXDashScreen::SetScreenName( char* ):Invalid parameter passed in\r\n" );
        return;
    }

    // If there is already a screen name set, let's clean it up
    if( m_Name )
    {
        delete[] m_Name;
        m_Name = NULL;
    }
    
    // Create memory to hold our new screen name, and copy the data in to it
    m_Name = _strdup( screenName );
}



/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  This function will add a control to the control array for this screen.

Arguments:
  char* controlName - The name of the control to be added
  char* controlDestination - The destination of the control to be added.  The
                              destination is the screen name of the screen the
                              user would end up on if they selected this
                              control.

Return Value:

------------------------------------------------------------------------------*/
// This function will let the user add a control to the current screen
void CXDashScreen::AddControl( char* controlName, char* controlDestination )
{
    // Make sure we were passed valid pointers, otherwise let the user know and return
    if( !controlName || !controlDestination )
    {
        DebugPrint( "  CXDashScreen::AddControl( char*, char* ):Invalid parameter passed in\r\n" );
        return;
    }

    // Make sure we haven't exceeded our maximum number of controls.  If not, update the control at the current
    // location with the data the user passed in
    if( m_numControls < NUM_CONTROLS )
    {
        m_Controls[m_numControls].UpdateControl( controlName, controlDestination );

        // Make sure we increase the number of controls
        ++m_numControls;
    }
    else // Too many controls, notify user
    {
        DebugPrint( "  CXDashScreen::AddControl( char*, char* ):Exceeded NUM_CONTROLS - '%d'\r\n", NUM_CONTROLS );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\xzone\tests.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    Tests.cpp

Abstract:


Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-18-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "tests.h"

namespace xdashxzone
{
    /***********************
    ************************
    *** Begin Test Cases ***
    ************************
    ***********************/


    /*
    Routine Description:


    Arguments:

        HANDLE hLog - handle to an XLOG object
        CStepsLog* pStepsLog - Pointer to the steps logging object

    Return Value:

        DWORD -

    */
    DWORD Test1Here( HANDLE hLog, CStepsLog* pStepsLog )
    {
        //////////////////////////////////////////////////////////////////////////
        // This case verifies that 
        //////////////////////////////////////////////////////////////////////////

        size_t xlogVariationNum = 0;                    // The Variation Number of the test we are running
        WCHAR stepsVariation[VARIATION_BUFFER_SIZE];    // The String representation of the test variation we want logged to our steps file
        WCHAR xlogVariation[VARIATION_BUFFER_SIZE];     // The String representation holding the variation number we are running

        // If the user wishes to print the steps, let's log them
        pStepsLog->AddStep( L"Step 1" );
        pStepsLog->AddStep( L"Step 2" );
        pStepsLog->AddStep( L"Step 3" );

        _snwprintf( xlogVariation, VARIATION_BUFFER_SIZE, L"Variation %d", ++xlogVariationNum );
        _snwprintf( stepsVariation, VARIATION_BUFFER_SIZE, L"Variation %d: Variation Here", xlogVariationNum );

        // Log the test case variation to our Steps File
        pStepsLog->AddVariation( stepsVariation );

        TESTCASE( xlogVariation )
        {
            TESTMNUL( hLog, "Manual Test" );
        } ENDTESTCASE;
    
        return 0;
    };
}; // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\xzone\xdashxzone.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    XDashXZone.h

Abstract:



Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10-16-2000  Created

*/
#ifndef _XDASHXZONE_H_
#define _XDASHXZONE_H_

#define COMPONENT_NAME_W    L"XDashXZone"
#define COMPONENT_NAME_A    "XDashXZone"
#define DLL_NAME_W          L"XDashXZone"
#define DLL_NAME_A          "XDashXZone"

typedef DWORD ( *APITEST_FUNC )( HANDLE hLog, CStepsLog* pStepsLog );

#endif // _XDASHXZONE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\xzone\tests.h ===
#ifndef _TESTS_H_
#define _TESTS_H_

namespace xdashxzone
{
    #define VARIATION_BUFFER_SIZE  1024

    /*

    Copyright (c) 2000 Microsoft Corporation

    Module Name:

        Tests.h

    Abstract:



    Author:

        Jim Helm (jimhelm)

    Environment:

        XBox

    Revision History:
        10-18-2000  Created

    */

    //
    //  XZone Area Tests
    //

    //    01234567890123456789012345678901

    DWORD Test1Here                       ( HANDLE hLog, CStepsLog* pStepsLog );

}; // namespace

#endif // _TESTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xdashtests\xzone\xdashxzone.cpp ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    XDashXZone.cpp

Abstract:

    The DLL exports two of the mandatory APIs: StartTest and EndTest.
    TESTINI.INI must be modified correctly so that the
    harness will load and call StartTest/EndTest.

    Please see "x-box test harness.doc" for more information.

Author:

    Jim Helm (jimhelm)

Environment:

    XBox

Revision History:
    10/18/2000  Created

*/


#include <xlog.h>
#include "stdafx.h"
#include "XDashXZone.h"
#include "tests.h"

namespace xdashxzone
{
    static BOOL printSteps = true;

    /*

    Routine Description:


    Arguments:

        HANDLE hLog - to the logging object
        CStepsLog* pStepsLog - Object used to log our test steps

    Return Value:

        DWORD

    */
    DWORD XDashXZoneRunAll( HANDLE hLog, CStepsLog* pStepsLog )
    {
        struct APIFUNCT
        {
            APITEST_FUNC f;
            WCHAR *name;
            char *aname;
        };
    
        #define BUILTAPISTRUCT(n) { n , L#n , #n }

        // Define all the API tests
        APIFUNCT testlist[] =
        {
            /*
            */
            BUILTAPISTRUCT( Test1Here )
            /*
            */
        };

        // Run the suite of tests

        // run each test
        for( size_t j = 0; j < ARRAYSIZE( testlist ); j++ )
        {
            xSetFunctionName(hLog, testlist[j].aname);
            DebugPrint( "%s: Entering test = '%ws()'\n", COMPONENT_NAME_A, testlist[j].name );

            // Log the testcase name to our steps log
            pStepsLog->SetCaseName( testlist[j].name );
            testlist[j].f( hLog, pStepsLog );

            // Log the test case (if the user wishes to)
            if ( printSteps )
            {
                pStepsLog->LogTestCase();
            }

            // Clear out the log for our next test
            pStepsLog->ClearTestCase();
        }

        return 0;
    }
}; // namespace

/*

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

*/
VOID WINAPI XDashXZoneStartTest( HANDLE hLog )
{
    using namespace xdashxzone;

    // test settings
    const int buffLen = 1024;
    
    char* ownerAlias     = new char[buffLen];
    char* componentMajor = new char[buffLen];
    char* componentMinor = new char[buffLen];
    char* stepsFileName  = new char[buffLen];
    int HTMLLogFormat    = 0;

    if( ownerAlias && componentMajor && componentMinor && stepsFileName )
    {
        // Object used to log our steps
        CStepsLog StepsLog;

        // Pull out internal INI file settings
        GetProfileStringA( DLL_NAME_A,   "Owner",           "Owner",          ownerAlias,     buffLen );
        GetProfileStringA( DLL_NAME_A,   "ComponentMajor",  "ComponentMajor", componentMajor, buffLen );
        GetProfileStringA( DLL_NAME_A,   "ComponentMinor",  "ComponentMinor", componentMinor, buffLen );
        GetProfileStringA( DLL_NAME_A,   "StepsFile",       "StepsFile",      stepsFileName,  buffLen );
        printSteps = GetProfileIntA( DLL_NAME_A, "PrintSteps", 0 );
        HTMLLogFormat = GetProfileIntA( DLL_NAME_A, "HTMLStepsLog", 1 );

        // Set the format for our STEPS log file
        StepsLog.SetHTMLLogFormat( HTMLLogFormat );

        xSetOwnerAlias( hLog, ownerAlias );
        xSetComponent( hLog, componentMajor, componentMinor );
        DebugPrint( "%s: **************************************************************\n", COMPONENT_NAME_A );
        DebugPrint( "%s: Entering %sStartTest()\n", COMPONENT_NAME_A, COMPONENT_NAME_A );
        DebugPrint( "%s: Internal INI Settings:\n", COMPONENT_NAME_A );
        DebugPrint( "   Owner           = '%s'\n", ownerAlias );
        DebugPrint( "   Component Major = '%s'\n", componentMajor );
        DebugPrint( "   Component Minor = '%s'\n", componentMinor );

        // Open our Steps Log File
        if (printSteps)
        {
            StepsLog.OpenLog( stepsFileName );
        }

        XDashXZoneRunAll( hLog, &StepsLog );

        if ( printSteps )
        {
            // Close our Steps Log File
            StepsLog.CloseLog();
        }

        DebugPrint( "%s: Leaving %sStartTest()\n", COMPONENT_NAME_A, COMPONENT_NAME_A );
        DebugPrint( "%s: **************************************************************\n", COMPONENT_NAME_A );
        xSetOwnerAlias( hLog, NULL );
    }
    else // Memory allocation failed
    {
        DebugPrint( "**ERROR: %sStartTest():Could not allocate memory!!", COMPONENT_NAME_A );
    }

    if( ownerAlias )
    {
        delete[] ownerAlias;
        ownerAlias = NULL;
    }

    if( componentMajor )
    {
        delete[] componentMajor;
        componentMajor = NULL;
    }
    
    if( componentMinor )
    {
        delete[] componentMinor;
        componentMinor = NULL;
    }
    
    if( stepsFileName )
    {
        delete[] componentMinor;
        componentMinor = NULL;
    }
}


/*

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

*/
VOID WINAPI XDashXZoneEndTest(void)
{
}


#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( xdashxzone )
#pragma data_seg()

BEGIN_EXPORT_TABLE( xdashxzone )
    EXPORT_TABLE_ENTRY( "StartTest", XDashXZoneStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XDashXZoneEndTest )
END_EXPORT_TABLE( xdashxzone )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\3dobject.h ===
#ifndef _3DOBJECT_H_
#define _3DOBJECT_H_

class Face
{
public:	
	WORD        point[3];
	D3DXVECTOR3 normal;
};

class Quaternion
{
public:
	float w;
	float x;
	float y;
	float z;
};

class C3DObject
{
public:
    // Constructors and Destructors
    C3DObject(void);
	~C3DObject(void);

    // Public Properties
	D3DXMATRIX   m_WorkMatrix;
	D3DXMATRIX   m_ObjectMatrix;
	D3DXVECTOR4  m_TranslateVector;

    // Public Methods
	void translate( float x, float y, float z );
	void rotateX( float x );
	void rotateY( float y );
	void rotateZ( float z );
	void spinX( float x );
	void spinY( float y );
	void spinZ( float z );
	void localRotateX( float x );
	void localRotateY( float y );
	void localRotateZ( float z );
};

#endif // _3DOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\avregionmenu.h ===
/*****************************************************
*** avregionmenu.h
***
*** Header file for our AV Region menu class.  This
*** class will allow a user to select a new AV
*** region
***
*** by James Helm
*** May 13th, 2001
***
*****************************************************/

#ifndef _AVREGIONMENU_H_
#define _AVREGIONMENU_H_

#include "keypadmenu.h"  // Base menu type

class CAVRegionMenu : public CKeypadMenu
{
public:
    // Constructors and Destructor
    CAVRegionMenu( CXItem* pParent );
    ~CAVRegionMenu();

    // Methods
    void Enter();                                                       // This will be called whenever the user enters this menu
    void Action( CUDTexture* pTexture );                                // Perform our actions (draw the screen items, etc)
    void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );   // Handle input to the buttons
    void HandleInput( enum CONTROLS buttonPressed, BOOL bFirstPress );

    HRESULT Init( char* menuFileName );                                 // Initialize our font and settings

private:
    // Properties
    Key m_keyPad[MENU_AVREGION_NUM_COLS][MENU_AVREGION_NUM_ROWS];   // Keypad
    unsigned int m_uiButtonWidth;                                   // Used to calculate our button width
    unsigned int m_uiButtonX1;                                      // Used to calculate the X1 position of our buttons


    void GenerateKeypad(void);
	BOOL renderKeypad( CUDTexture* pTexture );

    DWORD GetAVRegion();                            // Get the AV Region in a 'menu-friendly' format
    HRESULT SetAVRegion( DWORD dwAVRegion );        // Set the AV Region using our 'menu-friendly' format
};

#endif // _AVREGIONMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\avregionmenu.cpp ===
/*****************************************************
*** avregionmenu.cpp
***
*** CPP file for our AV Region menu class.  This
*** class will allow a user to select a new AV
*** region
***
*** by James Helm
*** May 11th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "avregionmenu.h"

extern CXSettings       g_XboxSettings;     // Xbox Settings Object
extern CSoundCollection g_Sounds;           // Used to generate all sounds for the XShell

// Constructor
CAVRegionMenu::CAVRegionMenu( CXItem* pParent )
: CKeypadMenu( pParent ),
m_uiButtonWidth( 0 )
{
    XDBGTRC( APP_TITLE_NAME_A, "CAVRegionMenu::CAVRegionMenu( CXItem )" );

    // Set the number of items on the menu
    m_uiNumItems = AVREGIONMENU_ITEM_NUM_ITEMS;
    SetSelectedItem( 0 );

    // Default the key to the TOP Button
	m_xKeypos = 0;
	m_yKeypos = 0;

    SetTitle( MENU_TITLE_AVREGION );
}


// Destructor
CAVRegionMenu::~CAVRegionMenu()
{
}


// Initialize the Menu
HRESULT CAVRegionMenu::Init( char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CAVRegionMenu::Init()" );

    HRESULT hr = CKeypadMenu::Init( menuFileName );

    // Calculate the width of our buttons
    unsigned int uiMaxWidth = 0;
    unsigned int uiCurrentWidth = 0;
    for( unsigned int x = 0; x < AVREGIONMENU_ITEM_NUM_ITEMS; x++ )
    {
        uiCurrentWidth = GetStringPixelWidth( g_pwszAVRegionMenuItems[x] );
        if( uiCurrentWidth > uiMaxWidth )
        {
            uiMaxWidth = uiCurrentWidth;
        }
    }
    m_uiButtonWidth = uiMaxWidth + MENU_AVREGION_BUTTON_TEXT_BORDER;

    m_uiButtonX1 = (int)MENUBOX_TEXTAREA_X_CENTER - ( m_uiButtonWidth / 2 );

	GenerateKeypad();

    return hr;
}


// Draws a menu on to the screen
void CAVRegionMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should update our texture, if not, return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else // Reset the Update flag
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture so we can render to it
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );
    
    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

    //
	// Render the current AV Region Text
    //
    int iStringPixelWidth = GetStringPixelWidth( MENU_AVREGION_CURRENT_REGION_TEXT );
    float fXPos = MENUBOX_TEXTAREA_X_CENTER - ( iStringPixelWidth / 2.0f );
    float fYPos = MENU_AVREGION_TEXT_Y1;
    pTexture->DrawText( fXPos, fYPos, ITEM_HEADER_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", MENU_AVREGION_CURRENT_REGION_TEXT );

    iStringPixelWidth = GetStringPixelWidth( g_pwszAVRegionMenuItems[GetAVRegion()] );
    fXPos = MENUBOX_TEXTAREA_X_CENTER - ( iStringPixelWidth / 2.0f );
    unsigned int uiFontHeight, uiFontWidth;
    GetFontSize( &uiFontHeight, &uiFontWidth );
    fYPos = MENU_AVREGION_TEXT_Y1 + uiFontHeight + ITEM_VERT_SPACING;
    pTexture->DrawText( fXPos, fYPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", g_pwszAVRegionMenuItems[GetAVRegion()] );
    
    //
    // Draw our keypad / AV Region Menu Items
    //
	renderKeypad( pTexture );

    // Unlock our Texture
    pTexture->Unlock();
}

// Handles input (of the BUTTONS) for the current menu
void CAVRegionMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Don't update the setting unless the user is on one of the buttons
            if( 0 == m_xKeypos )
            {
                m_bUpdateTexture = TRUE;

                // Play the Select button Sound
                g_Sounds.PlaySelectSound();

                // Set the AV Region in to the Config Sector
                HRESULT hr = SetAVRegion( m_yKeypos ); // m_yKeypos will map to the enum AVRegionMenu items
                if( FAILED( hr ) )
                {
                    XDBGWRN( APP_TITLE_NAME_A, "CAVRegionMenu::HandleInput():Failed to set the AV Region!! Region - '%d', Error - '0x%X.08'", m_yKeypos, hr );
                }
                else
                {
                    XDBGTRC( APP_TITLE_NAME_A, "CAVRegionMenu::HandleInput():Successfully set the AV Region!!" );
                }

                Leave( GetParent() );
            }
            break;
        }
    case BUTTON_B:
        {
            // Go Back one menu
            if( GetParent() )
            {
                // Play the Back Sound
                g_Sounds.PlayBackSound();

                Leave( GetParent() );
            }
            break;
        }
    }
}

// Handles input (of the CONTROLS) for the current menu
void CAVRegionMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            if( m_yKeypos != 0 )
            {
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

                m_yKeypos--;
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            if( m_yKeypos < ( AVREGIONMENU_ITEM_NUM_ITEMS - 1 ) )
            {
                m_bUpdateTexture = TRUE;

                // Play the Menu Item Select Sound
                g_Sounds.PlayMenuItemSelectSound();

				m_yKeypos++;
            }
            break;
        }
    case CONTROL_DPAD_LEFT:
        {
            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            break;
        }
	}
}


void CAVRegionMenu::GenerateKeypad(void) 
{
	// First create numberpad
	int xgrid  = MENU_AVREGION_NUM_COLS;
	int ygrid  = MENU_AVREGION_NUM_ROWS;
	int xstart = m_uiButtonX1;
	int ystart = MENU_AVREGION_BUTTON_Y1;
	int width  = m_uiButtonWidth;
	int height = 32;
	int spacer = 2;

	int currentx = xstart;
	int currenty = ystart;

	for(int y = 0; y < ygrid; y++)
	{
		for(int x = 0; x < xgrid; x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, SCREEN_DEFAULT_TEXT_FG_COLOR );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}

    // Set the text of the keys
    for( int z = 0; z < AVREGIONMENU_ITEM_NUM_ITEMS; z++ )
    {
        m_keyPad[0][z].defineText(g_pwszAVRegionMenuItems[z]);
    }
}


BOOL CAVRegionMenu::renderKeypad( CUDTexture* pTexture )
{
	
	// Render outlines of keys	
	float x1, x2;
	float y1, y2;
	for(int x = 0; x < MENU_AVREGION_NUM_COLS; x++)
	{
		for(int y = 0; y < MENU_AVREGION_NUM_ROWS; y++)
		{
			if(m_keyPad[x][y].getRender())
			{
                // Lock our texture
                pTexture->Lock();

				x1 = (float)m_keyPad[x][y].xorigin;
				x2 = (float)(m_keyPad[x][y].xorigin + m_keyPad[x][y].width);
				
				y1 = (float)m_keyPad[x][y].yorigin;
				y2 = (float)(m_keyPad[x][y].yorigin + m_keyPad[x][y].height);
	
				// hilight key if currently selected
                DWORD dwCharColor;
				if((m_xKeypos == x) && (m_yKeypos == y))
                {
					pTexture->DrawBox( x1, y1, x2, y2, ITEM_SELECTOR_COLOR );
                    
                    dwCharColor = ITEM_SELECTED_VALUE_COLOR;
                }
                else
                {
                    dwCharColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
                }

                pTexture->DrawOutline( x1, y1, x2, y2, MENU_AVREGION_LINE_WIDTH, m_keyPad[x][y].selectColor );
				
				unsigned int decent;
				unsigned int fontHeight;
				GetFontSize( &fontHeight, &decent );
				
				float textX = (float)((m_keyPad[x][y].width / 2) + m_keyPad[x][y].xorigin) - GetStringPixelWidth( m_keyPad[x][y].resultChar ) / 2;
				float textY = (float)((m_keyPad[x][y].height / 2) + m_keyPad[x][y].yorigin) - (fontHeight / 2);
				pTexture->DrawText( textX, textY, dwCharColor, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", m_keyPad[x][y].resultChar);

                // Unlock our Texture
                pTexture->Unlock();
			}
		}
	}
	
	return TRUE;
}

// This will be called whenever the user enters this menu
void CAVRegionMenu::Enter()
{
    // Call the base-class enter
    CKeypadMenu::Enter();

    // Default the key to currently selection option
	m_xKeypos = 0;
	m_yKeypos = GetAVRegion(); // 0;

    // Make sure our settings are up to date
    g_XboxSettings.LoadSettings();

    // Set our item selector to the currently selected item in the EEPROM
    m_yKeypos = GetAVRegion();
}


// Get the AV Region in a 'menu-friendly' format
DWORD CAVRegionMenu::GetAVRegion()
{
    switch( g_XboxSettings.GetAVRegion() )
    {
    case XSETTINGS_DISPLAY_SETTING_NTSC_M:
        {
            return AVREGIONMENU_ITEM_REGION1;

            break;
        }
    case XSETTINGS_DISPLAY_SETTING_NTSC_J:
        {
            return AVREGIONMENU_ITEM_REGION2;

            break;
        }
    case XSETTINGS_DISPLAY_SETTING_PAL_I:
        {
            return AVREGIONMENU_ITEM_REGION3;

            break;
        }
    default:
        {
            XDBGWRN( APP_TITLE_NAME_A, "CAVRegionMenu::GetAVRegion():Received unknown AV Region from Config Sector!! Region - '%d'", g_XboxSettings.GetAVRegion() );
            XDBGWRN( APP_TITLE_NAME_A, "CAVRegionMenu::GetAVRegion():Setting AV Region to - '%d'", XSETTINGS_DISPLAY_SETTING_NTSC_M );

            HRESULT hr = g_XboxSettings.SetAVRegion( XSETTINGS_DISPLAY_SETTING_NTSC_M );
            if( FAILED( hr ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CAVRegionMenu::GetAVRegion():Failed to Set the AV Region!! Region - '%d', Error - '0x%0.8X (%d)'", XSETTINGS_DISPLAY_SETTING_NTSC_M, hr, hr );
            }

            break;
        }
    }

    return XSETTINGS_DISPLAY_SETTING_NONE;
}


// Set the AV Region using our 'menu-friendly' format
HRESULT CAVRegionMenu::SetAVRegion( DWORD dwAVRegion )
{
    DWORD dwConfigSectorAVRegion = XSETTINGS_DISPLAY_SETTING_NONE;

    switch( dwAVRegion )
    {
    case AVREGIONMENU_ITEM_REGION1:
        {
            dwConfigSectorAVRegion = XSETTINGS_DISPLAY_SETTING_NTSC_M;

            break;
        }
    case AVREGIONMENU_ITEM_REGION2:
        {
            dwConfigSectorAVRegion = XSETTINGS_DISPLAY_SETTING_NTSC_J;

            break;
        }
    case AVREGIONMENU_ITEM_REGION3:
        {
            dwConfigSectorAVRegion = XSETTINGS_DISPLAY_SETTING_PAL_I;

            break;
        }
    default:
        {
            XDBGWRN( APP_TITLE_NAME_A, "CAVRegionMenu::SetAVRegion():Invalid AV Region Passed In - '%d'", dwAVRegion );

            return E_INVALIDARG;
        }
    }

    HRESULT hr = g_XboxSettings.SetAVRegion( dwConfigSectorAVRegion );
    if( FAILED( hr ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CAVRegionMenu::SetAVRegion():Failed to set the AV Region!! Region - '%d', Error - '0x%0.8X (%d)'", dwConfigSectorAVRegion, hr, hr );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\camera.cpp ===
#include "stdafx.h"
#include "camera.h"

int randIntBetween(int start, int finish)
{
	float randMax = RAND_MAX;
	float random  = rand() / randMax;

	int delta = finish - start;
	int final = (int)(random * delta) + start;
	return final;
}

float randFloatBetween(float start, float finish)
{
	float randMax = RAND_MAX;
	float random  = rand() / randMax;

	float delta = finish - start;
	float final = (random * delta) + start;
	return final;
}


// Constructor
Camera::Camera( void ) 
{
}

// Destructor
Camera::~Camera( void )
{
}

void Camera::update(IDirect3DDevice8* pd3dDevice)
{
	pd3dDevice->SetTransform( D3DTS_VIEW, &m_MatView );
	pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_MatProj );
}

void Camera::noise( IDirect3DDevice8* pd3dDevice )
{
	float randMax = RAND_MAX;

	for(int i = 0; i < 2; i++)
	{
		D3DXVECTOR3 CameraPos;
		if(i == 0)
		{
			CameraPos = m_CameraBase;
		}
		else if(i == 1)
		{
			CameraPos = m_CameraTarget;
		}
		
		if(m_iXframeCount[i] == m_iXframeDuration[i])
		{
			m_iXframeDuration[i] = randIntBetween(500, 800);  // new duration of frames for move
			m_PreviousPos[i].x = m_NewPos[i].x;
			
			float randx = randFloatBetween(-0.1f, 0.1f);
			m_NewPos[i].x = randx + CameraPos.x;
			m_iXframeCount[i] = 0;
		}
		if(m_iYframeCount[i] == m_iYframeDuration[i])
		{
			m_iYframeDuration[i] = randIntBetween(500, 800);
			m_PreviousPos[i].y = m_NewPos[i].y;

			float randy = randFloatBetween(-0.1f, 0.1f);
			m_NewPos[i].y = randy + CameraPos.y;
			m_iYframeCount[i] = 0;
		}
		if(m_iZframeCount[i] == m_iZframeDuration[i])
		{
			m_iZframeDuration[i] = randIntBetween(500, 800);
			m_PreviousPos[i].z = m_NewPos[i].z;
			
			float randz = randFloatBetween(-0.00f, 0.00f);
			m_NewPos[i].z = randz + CameraPos.z;
			m_iZframeCount[i] = 0;
		}

		m_fXinc[i] = (m_NewPos[i].x - m_PreviousPos[i].x);
		m_fYinc[i] = (m_NewPos[i].y - m_PreviousPos[i].y);
		m_fZinc[i] = (m_NewPos[i].z - m_PreviousPos[i].z);

		m_fXinc[i] *= (float)sin(((float)m_iXframeCount[i] / (float)m_iXframeDuration[i]) * 1.5708f);
		m_fYinc[i] *= (float)sin(((float)m_iYframeCount[i] / (float)m_iYframeDuration[i]) * 1.5708f);
		m_fZinc[i] *= (float)sin(((float)m_iZframeCount[i] / (float)m_iZframeDuration[i]) * 1.5708f);

		m_iXframeCount[i]++;
		m_iYframeCount[i]++;
		m_iZframeCount[i]++;
	}

	//	D3DXMATRIX translate;
	//	D3DXMatrixTranslation( &translate, m_PreviousPos.x + m_fXinc, m_PreviousPos.y + m_fYinc, m_PreviousPos.z + m_fZinc);
	//	m_MatView = translate * objectMatrix;

	D3DXVECTOR3 newBase   = D3DXVECTOR3(m_PreviousPos[0].x + m_fXinc[0], m_PreviousPos[0].y + m_fYinc[0], m_PreviousPos[0].z + m_fZinc[0]);
	D3DXVECTOR3 newTarget = D3DXVECTOR3(m_PreviousPos[1].x + m_fXinc[1], m_PreviousPos[1].y + m_fYinc[1], m_PreviousPos[1].z + m_fZinc[1]);
	D3DXMatrixLookAtRH(&m_MatView, &newBase, &newTarget, &D3DXVECTOR3(0.0f, 0.0f, 1.0f));
	pd3dDevice->SetTransform( D3DTS_VIEW, &m_MatView );
}

// Sets the proper aspect ration for 4:3 or Widescreen mode depending upon the value
// passed in.  TRUE for Widescree
void Camera::SetWidescreen( BOOL bValue )
{
 	float fieldOfView = (3.14159f / 2.0f) * 0.89f;
    float aspect = 640.0f / 480.0f;

    // widescreen
    if( bValue )
        aspect *= 1.25f;

    D3DXMatrixPerspectiveFovRH( &m_MatProj, fieldOfView, aspect, 1.0f, 1000.0f );
}

void Camera::readCAM( char* pszFilename )
{
	FILE  *pfInput;
	DWORD totalObjects = 1;

	pfInput = fopen( pszFilename, "rb" );

    if( !pfInput )
    {
        XDBGERR( APP_TITLE_NAME_A, "Camera::readCAM():Failed to open the file - '%s'!!", pszFilename );

        return;
    }

	fread( &totalObjects, sizeof(DWORD), 1, pfInput );

	//
	// Write out camera information necessary for scene
	//
	fread( &m_CameraBase.x, sizeof(float), 1, pfInput );
	fread( &m_CameraBase.y, sizeof(float), 1, pfInput );
	fread( &m_CameraBase.z, sizeof(float), 1, pfInput );
	fread( &m_CameraTarget.x, sizeof(float), 1, pfInput );
	fread( &m_CameraTarget.y, sizeof(float), 1, pfInput );
	fread( &m_CameraTarget.z, sizeof(float), 1, pfInput );
	fread( &m_Axis.x, sizeof(float), 1, pfInput );
	fread( &m_Axis.y, sizeof(float), 1, pfInput );
	fread( &m_Axis.z, sizeof(float), 1, pfInput );
	fread( &m_Angle, sizeof(float), 1, pfInput );
	fread( &m_fFOV, sizeof(float), 1, pfInput );
	
    fclose( pfInput );

	//
	// Preform math necessary for 3D space placement
	//
    /*
	D3DXQUATERNION q;
	D3DXQuaternionRotationAxis( &q, &m_Axis, m_Angle );
	D3DXMatrixRotationQuaternion( &m_ObjectMatrix, &q );

	D3DXMATRIX translate;
	D3DXMatrixTranslation( &translate, m_CameraBase.x, m_CameraBase.y, m_CameraBase.z );
	m_MatView = translate * m_ObjectMatrix;
    */

    // Bring camera down a bit
    m_CameraBase.z -= 0.1f;
    m_CameraTarget.z -= 0.1f;

	m_CameraBase.x *= -1.0f;
	m_CameraBase.y *= -1.0f;
	m_CameraBase.z *= -1.0f;
	m_CameraTarget.x *= -1.0f;
	m_CameraTarget.y *= -1.0f;
	m_CameraTarget.z *= -1.0f;
	D3DXMatrixLookAtRH(&m_MatView, &m_CameraBase, &m_CameraTarget, &D3DXVECTOR3(0.0f, 0.0f, 1.0f));

	//
	// Setup the Projection Matrix
	//
    SetWidescreen( FALSE ); // Default it to 4:3 mode
	
	//
	// Initalize noise paramaters
	//
    for( int i = 0; i < 2; i++ )
    {
	    m_iXframeCount[i]    = 0;
	    m_iXframeDuration[i] = 0;
	    m_iYframeCount[i]    = 0;
	    m_iYframeDuration[i] = 0;
	    m_iZframeCount[i]    = 0;
	    m_iZframeDuration[i] = 0;
    }

	m_PreviousPos[0]     = D3DXVECTOR3( m_CameraBase.x, m_CameraBase.y, m_CameraBase.z );
	m_NewPos[0]          = D3DXVECTOR3( m_CameraBase.x, m_CameraBase.y, m_CameraBase.z );
	m_PreviousPos[1]     = D3DXVECTOR3( m_CameraTarget.x, m_CameraTarget.y, m_CameraTarget.z );
	m_NewPos[1]          = D3DXVECTOR3( m_CameraTarget.x, m_CameraTarget.y, m_CameraTarget.z );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\camera.h ===
#ifndef _CAMERA_H_
#define _CAMERA_H_

class Camera
{

public:
    // Constructors and Destructors
    Camera(void);
    ~Camera(void);

    // Public Properties
	D3DXVECTOR3   m_CameraBase;
	D3DXVECTOR3   m_CameraTarget;
	float		  m_fFOV;
	D3DXVECTOR3   m_Axis;
	float         m_Angle;
	
	D3DXMATRIX    m_MatView;
	D3DXMATRIX    m_MatProj;
	D3DXMATRIX    m_ObjectMatrix;

	// Noise variables
	int			  m_iXframeCount[2];
	int			  m_iYframeCount[2];
	int			  m_iZframeCount[2];
	int			  m_iXframeDuration[2];
	int			  m_iYframeDuration[2];
	int			  m_iZframeDuration[2];
	D3DXVECTOR3   m_PreviousPos[2];
	D3DXVECTOR3   m_NewPos[2];
    float         m_fXinc[2], m_fYinc[2], m_fZinc[2];

	// Public Methods
	void update( IDirect3DDevice8* pd3dDevice );
	void noise( IDirect3DDevice8* pd3dDevice );
	void readCAM( char* pszFilename );
    void SetWidescreen( BOOL bValue );
};

#endif // _CAMERA_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\ui\xshell\certmenu.cpp ===
/*****************************************************
*** certmenu.h
***
*** CPP file for our XShell Certification menu 
*** class.  This is a standard menu contains a list
*** of menu items to be selected.
***
*** by James N. Helm
*** May 26th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "certmenu.h"

extern CXSettings           g_XboxSettings;         // Settings that are stored on the Xbox
extern IDirect3DDevice8*    g_pD3DDevice;           // Pointer to our Direct3D Device Object
extern CSoundCollection     g_Sounds;               // Used to generate all sounds for the XShell
extern BOOL                 g_bDisplayUpArrow;      // Used to determine if we should render the Up Arrow
extern BOOL                 g_bDisplayDownArrow;    // Used to determine if we should render the Down Arrow
extern CHardDrive           g_XboxHardDrive;        // Used to configure the Xbox Hard Drive
extern XFONT*               g_pFont;
extern CMADisplayMenu       g_MADisplayMenu;        // Used to display our Memory Areas

// Constructors
CCertMenu::CCertMenu( CXItem* pParent )
: CMenuScreen( pParent ),
m_HexKeypadMenu( NULL ),
m_DumpCacheMenu( NULL ),
m_LanguageMenu( NULL ),
m_TimeZoneMenu( NULL ),
m_EEPROMMenu( NULL ),
m_uiTopItemIndex( 0 ),
m_bProcessing( FALSE ),
m_bStartThread( FALSE ),
m_bDisableInput( FALSE ),
m_hThread( NULL ),
m_bAborting( FALSE ),
m_bDispHDTVSafe( FALSE ),
m_bDispNonHDTVSafe( FALSE )
{
    XDBGTRC( APP_TITLE_NAME_A, "CCertMenu::CCertMenu(ex)" );

    m_uiNumItems = CERTMENU_ITEM_NUM_ITEMS;
    SetSelectedItem( 0 );

    // Clear out our pre-allocated memory
    ZeroMemory( m_pwszTitleID, sizeof( WCHAR ) * MENU_CERT_TITLE_ID_STR_LEN+1 );

    SetTitle( MENU_TITLE_CERT );
}


// Destructor
CCertMenu::~CCertMenu()
{
}

// Draws a menu on to the screen
void CCertMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should take action
    if( m_bStartThread )
    {
        m_bUpdateTexture = TRUE;
        m_bProcessing = TRUE;
        m_bDisableInput = TRUE;
        m_bStartThread = FALSE;

        m_hThread = CreateThread( NULL,                     // Security Attributes
                                  0,                        // Stack Size (0 uses default)
                                  ProcessDataThreadFunc,    // Thread function
                                  this,                     // Parameter
                                  0,                        // Creation Flags
                                  NULL );                   // Thread ID
    }

    // Check on our Thread to see if it's still running
    DWORD dwThreadExitCode = 0;
    GetExitCodeThread( m_hThread, &dwThreadExitCode );

    // Check to see if our thread is done processing, and if so, udpate our texture, and re-enable input
    if( m_bProcessing && ( dwThreadExitCode != STILL_ACTIVE ) )
    {
        m_bUpdateTexture = TRUE;
        m_bProcessing = FALSE;
        m_bDisableInput = FALSE;
        g_XboxHardDrive.SetAbortProcess( FALSE );
        m_bAborting = FALSE;
    }

    if( m_bDispHDTVSafe )
    {
        DrawBoxPercentBased( SCREEN_HDTV_SAFE_PERCENTAGE, COLOR_YELLOW );
    }

    if( m_bDispNonHDTVSafe )
    {
        DrawBoxPercentBased( SCREEN_NONHDTV_SAFE_PERCENTAGE, COLOR_WHITE );
    }

    // Only update the texture if we need to, otherwise return
    if( !m_bUpdateTexture )
    {
        return;
    }
    else
    {
        m_bUpdateTexture = FALSE;
    }

    // Lock our texture and set it as the render target
    pTexture->Lock();
    pTexture->Clear( SCREEN_DEFAULT_BACKGROUND_COLOR );

    // Update our Font Height
    XFONT_SetTextHeight( g_pFont, ITEM_OPTIONMENU_FONT_HEIGHT );
    m_uiFontHeightOfItem = ITEM_OPTIONMENU_FONT_HEIGHT;

    // If we are processing a user action, update the texture and
    // bail
    if( STILL_ACTIVE == dwThreadExitCode )
    {
        float fXPos = MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( MENU_CERT_PROCESSING_TEXT ) / 2.0f );
        float fYPos = MENUBOX_TEXTAREA_Y_CENTER - GetFontHeightOfItem() - ( 2 * ITEM_VERT_SPACING );
        pTexture->DrawText( fXPos, fYPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls", MENU_CERT_PROCESSING_TEXT );

        fXPos = MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( g_pwszCertMenuItems[GetSelectedItem()] ) / 2.0f );
        fYPos = MENUBOX_TEXTAREA_Y_CENTER + ITEM_VERT_SPACING;
        pTexture->DrawText( fXPos, fYPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%ls", g_pwszCertMenuItems[GetSelectedItem()] );

        // We should display the file name in this case
        if( CERTMENU_ITEM_REQUIREMENT10_3_33 == GetSelectedItem() )
        {
            char* pszFileName = strrchr( FILE_DATA_FILELIST_FILENAME, '\\' );
            char pszDestFileName[100];
            pszDestFileName[0] = 0;

            _snprintf( pszDestFileName, 99, "%hs%hs", FILE_DEVELOPER_DRIVE_A, pszFileName );

            fXPos = MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( pszDestFileName ) / 2.0f );
            fYPos = fYPos + m_uiFontHeightOfItem + ITEM_VERT_SPACING;
            pTexture->DrawText( fXPos, fYPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%hs", pszDestFileName );
        }

        fYPos = MENUBOX_TEXTAREA_Y2 - m_uiFontHeightOfItem;
        if( m_bAborting )
        {
            fXPos = MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( "Aborting..." ) / 2.0f );
            pTexture->DrawText( fXPos, fYPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"Aborting..." );
        }
        else
        {
            // Draw our aborting message
            fXPos = MENUBOX_TEXTAREA_X_CENTER - ( GetStringPixelWidth( "Press 'B' to abort" ) / 2.0f );
            pTexture->DrawText( fXPos, fYPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"Press 'B' to abort" );
        }

        // Unlock the texture
        pTexture->Unlock();

        // Turn off our arrows
        g_bDisplayUpArrow = FALSE;
        g_bDisplayDownArrow = FALSE;

        return;
    }
    else
    {
        m_hThread = NULL;

        // Fix our arrows
        AdjustDisplayArrows();
    }

    // Let our base menu class draw all the items pulled from the MNU file
    CMenuScreen::Action( pTexture );

    // Draw a box behind the currently highlighted choice
    float X1Pos = MENUBOX_SELECTBAR_X1;
    float Y1Pos = MENUBOX_TEXTAREA_Y1 + MENUBOX_TEXT_TOP_BORDER + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( GetSelectedItem() - m_uiTopItemIndex ) ) - ITEM_SELECTOR_BORDER_SPACE;
    float X2Pos = MENUBOX_SELECTBAR_X2;
    float Y2Pos = Y1Pos + m_uiFontHeightOfItem + ( 2 * ITEM_SELECTOR_BORDER_SPACE );
    
    pTexture->DrawBox( X1Pos, Y1Pos, X2Pos, Y2Pos, ITEM_SELECTOR_COLOR );

    //
    // Draw our Menu Items
    //

    for( unsigned int x = m_uiTopItemIndex; x < ( MENU_CERT_NUM_ITEMS_TO_DISPLAY + m_uiTopItemIndex ); x++ )
    {
        if( x == GetNumItems() )
        {
            break;
        }

        float XPos = MENUBOX_TEXTAREA_X1;
        float YPos = MENUBOX_TEXTAREA_Y1 + MENUBOX_TEXT_TOP_BORDER + ( ( ITEM_VERT_SPACING + m_uiFontHeightOfItem ) * ( x - m_uiTopItemIndex ) );

        pTexture->DrawText( XPos, YPos, SCREEN_DEFAULT_TEXT_FG_COLOR, SCREEN_DEFAULT_TEXT_BG_COLOR, L"%s", g_pwszCertMenuItems[x] );
    }

    // Correct our Font Height
    m_uiFontHeightOfItem = FONT_DEFAULT_HEIGHT;
    XFONT_SetTextHeight( g_pFont, FONT_DEFAULT_HEIGHT );

    // Unlock the texture
    pTexture->Unlock();
}


// Handle any requests for the joystick (thumb-pad)
void CCertMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Y
            if( ( nThumbY < 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) ) // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( ( nThumbY > 0 ) && ( abs( nThumbY ) > m_nJoystickDeadZone ) )// Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( ( nThumbX < 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) ) // Move the left joystick left
            {
            }
            else if( ( nThumbX > 0 ) && ( abs( nThumbX ) > m_nJoystickDeadZone ) )// Move the left joystick right
            {
            }
            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CCertMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // Check to see if input is enabled or disabled
    if( m_bDisableInput )
    {
        return;
    }

    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_INITIAL_DELAY;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_keyPressDelayTimer ) < m_keyPressDelayInterval )
        {
            return;
        }
        m_keyPressDelayTimer = GetTickCount();
        m_keyPressDelayInterval = KEY_PRESS_REPEAT_DELAY;
    }

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( GetSelectedItem() > 0 )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() - 1 );

                    // Make sure we are displaying the correct items
                    if( GetSelectedItem() < (int)m_uiTopItemIndex )
                    {
                        m_uiTopItemIndex = GetSelectedItem();

                        AdjustDisplayArrows();
                    }
                }
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                if( ( (unsigned int)GetSelectedItem() + 1 ) < GetNumItems() )
                {
                    m_bUpdateTexture = TRUE;

                    // Play the Menu Item Select Sound
                    g_Sounds.PlayMenuItemSelectSound();

                    SetSelectedItem( GetSelectedItem() + 1 );

                    // Make sure we are displaying the correct items
                    if( GetSelectedItem() >= (int)( MENU_CERT_NUM_ITEMS_TO_DISPLAY + m_uiTopItemIndex ) )
                    {
                        m_uiTopItemIndex += 1;

                        AdjustDisplayArrows();
                    }
                }
            }
            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CCertMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, or input is disabled, let's bail
    if( !bFirstPress )
    {
        return;
    }

    if( ( m_bDisableInput ) && ( buttonPressed != BUTTON_B ) )
    {
        return;
    }

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Only act if we have any items on our screen
            if( GetNumItems() != 0 )
            {
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                m_bUpdateTexture = TRUE;

                switch( GetSelectedItem() )
                {
                case CERTMENU_ITEM_REQUIREMENT10_1_12:  // Display all settings to the user
                    {
                        // Display all of the settings to the user
                        Leave( &m_EEPROMMenu );

                        break;
                    }
                case CERTMENU_ITEM_REQUIREMENT10_2_07:  // Create 4096 udata\<titleid> entries
                    {
                        m_bStartThread = TRUE;

                        // Get the TITLE ID from the Hex Keypad
                        Leave( &m_HexKeypadMenu );

                        break;
                    }
                case CERTMENU_ITEM_REQUIREMENT10_2_10:  // Clear utility partition for <titleid>
                    {
                        m_bStartThread = TRUE;

                        // Get the Title ID from the Cache Partition Info
                        Leave( &m_DumpCacheMenu );

                        break;
                    }
                case CERTMENU_ITEM_REQUIREMENT10_2_18:  // Toggle non-HDTV safe area box
                    {
                        m_bDispNonHDTVSafe = !m_bDispNonHDTVSafe;

                        break;
                    }
                case CERTMENU_ITEM_REQUIREMENT10_2_19:  // Toggle HDTV safe area box
                    {
                        m_bDispHDTVSafe = !m_bDispHDTVSafe;

                        break;
                    }
                case CERTMENU_ITEM_REQUIREMENT10_3_11:  // Display all Memory Areas to the user
                    {
                        // Display all of the settings to the user
                        g_MADisplayMenu.SetParent( this );
                        Leave( &g_MADisplayMenu );

                        break;
                    }
                case CERTMENU_ITEM_REQUIREMENT10_3_14:  // Change the language
                    {
                        // Let the user specify a language
                        Leave( &m_LanguageMenu );

                        break;
                    }
                case CERTMENU_ITEM_REQUIREMENT10_3_15:  // Change the TimeZone
                    {
                        Leave( &m_TimeZoneMenu );

                        break;
                    }
                case CERTMENU_ITEM_REQUIREMENT10_3_26_4:  // Create Saved Game name with Loc Text
                    {
                        m_bStartThread = TRUE;

                        // Get the TITLE ID from the Hex Keypad
                        Leave( &m_HexKeypadMenu );

                        break;
                    }
                case CERTMENU_ITEM_REQUIREMENT10_3_04:
                    {
                        m_bStartThread = TRUE;

                        // Clean the Udata directory
                        // m_CertReqs.CleanDir( "X:", ".xdk" );

                        // Get the TITLE ID from the Hex Keypad
                        WCHAR pwszPrompt[100];

                        ZeroMemory( m_pwszTitleID, sizeof( WCHAR ) * MENU_CERT_TITLE_ID_STR_LEN+1 );
                        ZeroMemory( pwszPrompt, sizeof( WCHAR ) * 100 );

                        _snwprintf( pwszPrompt, 99, L"Enter # of blocks to fill (%d free):", g_XboxHardDrive.GetFreeBlocks() );
                        m_HexKeypadMenu.SetInfo( pwszPrompt, m_pwszTitleID, MENU_CERT_TITLE_ID_STR_LEN );
                        Leave( &m_HexKeypadMenu );

                        break;
                    }
                case CERTMENU_ITEM_REQUIREMENT10_6_05:  // Corrupt Saved Games for a particular Title ID
                    {
                        m_bStartThread = TRUE;

                        // Get the TITLE ID from the Hex Keypad
                        Leave( &m_HexKeypadMenu );

                        break;
                    }
                default:
                    {
                        m_bStartThread = TRUE;
                    }
                }
            }

            break;
        }
    case BUTTON_B:
        {
            if( m_bDisableInput )
            {
                // Play the Select Sound
                g_Sounds.PlaySelectSound();

                m_bUpdateTexture = TRUE;
                m_bAborting = TRUE;
                g_XboxHardDrive.SetAbortProcess( TRUE );
            }
            else
            {
                // Go Back one menu
                if( GetParent() )
                {
                    // Play the Back Sound
                    g_Sounds.PlayBackSound();

                    Leave( GetParent() );
                }
            }

            break;
        }
    case BUTTON_Y:
        {
            break;
        }
    }
}


// Initialize the Menu
HRESULT CCertMenu::Init( char* menuFileName )
{
    XDBGTRC( APP_TITLE_NAME_A, "CCertMenu::Init()" );

    HRESULT hr = CMenuScreen::Init( menuFileName );

    // Initialize our sub-menus
    m_DumpCacheMenu.Init( MENU_DUMPCACHE_MENU_FILENAME_A );
    m_DumpCacheMenu.SetParent( this );

    m_LanguageMenu.Init( MENU_LANGUAGE_MENU_FILENAME_A );
    m_LanguageMenu.SetParent( this );

    m_TimeZoneMenu.Init( TIMEZONEMENU_FILENAME_A );
    m_TimeZoneMenu.SetParent( this );

    m_EEPROMMenu.Init( EEPROMMENU_FILENAME_A );
    m_EEPROMMenu.SetParent( this );

    return hr;
}


// Should be called whenever a user leaves the menu
void CCertMenu::Leave( CXItem* pItem )
{
    // Call our base class Leave
    CMenuScreen::Leave( pItem );

    g_bDisplayUpArrow = FALSE;
    g_bDisplayDownArrow = FALSE;
}

// This will be called whenever the user enters this menu
void CCertMenu::Enter()
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Make sure our input is enabled
    m_bDisableInput = FALSE;

    // Set our selected item to the top of the menu
    // SetSelectedItem( 0 );

    // Make sure the proper arrows are displayed
    AdjustDisplayArrows();

    // Setup our Hex Keypad Menu
    m_HexKeypadMenu.SetParent( this );
    m_HexKeypadMenu.SetInfo( L"Enter an 8 digit Title ID:", m_pwszTitleID, MENU_CERT_TITLE_ID_STR_LEN );
}


// Adjust the UP and DOWN arrows on the screen
void CCertMenu::AdjustDisplayArrows()
{
    // Decide if we need to turn on the Up Arrow
    if( 0 == m_uiTopItemIndex )
    //
    // We can turn off the Up Arrow, because there is nothing above us
    //
    {
        g_bDisplayUpArrow = FALSE;
    }
    else
    //
    // We have to turn on the Up Arrow, because a menu choice is above us
    //
    {
        g_bDisplayUpArrow = TRUE;
    }

    // Decide if we need to turn on the Down Arrow
    if( ( m_uiTopItemIndex + MENU_CERT_NUM_ITEMS_TO_DISPLAY ) == GetNumItems() )
    //
    // We can turn off the Down arrow, because nothing is below us
    //
    {
        g_bDisplayDownArrow = FALSE;
    }
    else
    //
    // We have to turn on the Down Arrow, because there are menu choices below us
    //
    {
        g_bDisplayDownArrow = TRUE;
    }
}


// Thread proc
DWORD WINAPI ProcessDataThreadFunc( LPVOID lpParameter )
{
    CCertMenu* pCertMenu = (CCertMenu*)lpParameter;
    DWORD dwReturnVal = 0;

    switch( pCertMenu->GetSelectedItem() )
    {
    case CERTMENU_ITEM_REQUIREMENT10_1_11:
        {
            if( FAILED( pCertMenu->m_CertReqs.Req10_1_11() ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CCertMenu::ProcessDataThreadFunc():Failed to properly configure the Xbox!!" );

                dwReturnVal = 1;
            }

            break;
        }
    // Lists all global settings
    case CERTMENU_ITEM_REQUIREMENT10_1_12:
        {
            if( FAILED( pCertMenu->m_CertReqs.Req10_1_12() ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CCertMenu::ProcessDataThreadFunc():Failed to properly configure the Xbox!!" );

                dwReturnVal = 1;
            }

            break;
        }

    // Fragments TDATA and UDATA partitions
    case CERTMENU_ITEM_REQUIREMENT10_2_01:
        {
            if( FAILED( pCertMenu->m_CertReqs.Req10_2_01() ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CCertMenu::ProcessDataThreadFunc():Failed to properly configure the Xbox!! (udata)" );

                dwReturnVal = 1;
            }

            break;
        }
    case CERTMENU_ITEM_REQUIREMENT10_2_02:
        {
            if( FAILED( pCertMenu->m_CertReqs.Req10_2_02() ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CCertMenu::ProcessDataThreadFunc():Failed to properly configure the Xbox!!" );

                dwReturnVal = 1;
            }

            break;
        }
    // Fills udata\<titleid> with 4096 entries
    case CERTMENU_ITEM_REQUIREMENT10_2_07:
        {
            if( wcslen( pCertMenu->m_pwszTitleID ) != 8 )
            {
                // TODO: Display an error message
                return 2;
            }

            char pszTitleID[9];
            ZeroMemory( pszTitleID, 9 );

            sprintf( pszTitleID, "%ls", pCertMenu->m_pwszTitleID );

            if( FAILED( pCertMenu->m_CertReqs.Req10_2_07( pszTitleID ) ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CCertMenu::ProcessDataThreadFunc():Failed to properly configure the Xbox!!" );

                dwReturnVal = 1;
            }

            break;
        }
    case CERTMENU_ITEM_REQUIREMENT10_2_10:
        {
            if( FAILED( pCertMenu->m_CertReqs.Req10_2_10( pCertMenu->m_DumpCacheMenu.GetSelectedTitleID() ) ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CCertMenu::ProcessDataThreadFunc():Failed to properly configure the Xbox!!" );

                dwReturnVal = 1;
            }

            break;
        }
    case CERTMENU_ITEM_REQUIREMENT10_2_18:
        {
            if( FAILED( pCertMenu->m_CertReqs.Req10_2_18() ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CCertMenu::ProcessDataThreadFunc():Failed to properly configure the Xbox!!" );

                dwReturnVal = 1;
            }

            break;
        }
    case CERTMENU_ITEM_REQUIREMENT10_2_19:
        {
            if( FAILED( pCertMenu->m_CertReqs.Req10_2_19() ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CCertMenu::ProcessDataThreadFunc():Failed to properly configure the Xbox!!" );

                dwReturnVal = 1;
            }

            break;
        }
    case CERTMENU_ITEM_REQUIREMENT10_3_04:
        {
            if( L'\0' == pCertMenu->m_pwszTitleID[0] )
            {
                return 0;
            }

            WCHAR* pwszStopString = NULL;
            DWORD dwFileSize = wcstol( pCertMenu->m_pwszTitleID, &pwszStopString, 10 );
            
            XDBGTRC( APP_TITLE_NAME_A, "CCertMenu::ProcessDataThreadFunc():pCertMenu->m_pwszTitleID - '%ls'", pCertMenu->m_pwszTitleID );
            if( FAILED( pCertMenu->m_CertReqs.Req10_3_04( dwFileSize ) ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CCertMenu::ProcessDataThreadFunc():Failed to properly configure the Xbox!!" );

                dwReturnVal = 1;
            }

            break;
        }
    case CERTMENU_ITEM_REQUIREMENT10_3_11:
        {
            if( FAILED( pCertMenu->m_CertReqs.Req10_3_11() ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CCertMenu::ProcessDataThreadFunc():Failed to properly configure the Xbox!!" );

                dwReturnVal = 1;
            }

            break;
        }
    case CERTMENU_ITEM_REQUIREMENT10_3_14:
        {
            if( FAILED( pCertMenu->m_CertReqs.Req10_3_14() ) )
            {
                XDBGWRN( APP_TITLE_NAME_A, "CCertMenu::ProcessDataThreadFunc():Failed to properly configure the Xbox!!" );

                dwReturnVal = 1;
            }

            break;
        }
    case CERTMENU_ITEM_REQUIREMENT10_3_15:
        {
            if( FAILED( pCertMenu->m_CertReqs.Req10_3_15() ) )
            {
                XDBGWRN( APP_TITLE_NAME_