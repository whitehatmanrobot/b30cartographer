ture == PS_FRAME_PICTURE)
		{
		curFrame->GetMPP(mx, my, yc, uvc, stride);

		if (predictionType == PT_FRAME_BASED)
			{
			if (IS_MACROBLOCK_MOTION_BACKWARD(macroblockType))
				{
				sx[0] = mx * 2 + vectors[0][1][0] & motionVectorMask;
				sy[0] = my * 2 + vectors[0][1][1] & motionVectorMask;
				csx[0] = mx + DIV2(vectors[0][1][0]);
				csy[0] = my + DIV2(vectors[0][1][1]);

				if (succFrame->GetYPP(sx[0] >> 1, sy[0] >> 1, ys))
					{
					succFrame->GetUVPP(csx[0] >> 1, csy[0] >> 1, uvs);

					if (IS_MACROBLOCK_MOTION_FORWARD(macroblockType))
						{
						px[0] = mx * 2 + vectors[0][0][0] & motionVectorMask;
						py[0] = my * 2 + vectors[0][0][1] & motionVectorMask;
						cpx[0] = mx + DIV2(vectors[0][0][0]);
						cpy[0] = my + DIV2(vectors[0][0][1]);

						if (predFrame->GetYPP(px[0] >> 1, py[0] >> 1, yp))
							{
							predFrame->GetUVPP(cpx[0] >> 1, cpy[0] >> 1, uvp);

							if (directAccess)
								{
								if (needsFrameData)
									{
									motionComp->SBiMotionCompensationUV(
											cpy[0], cpx[0], csy[0], csx[0],
											uvp, uvs, stride, copyUV,
											uvc, &(mbuv[0][0]), 32, &(mbuv[8][0]));
									motionComp->SDBiMotionCompensationY(
											py[0], px[0], sy[0], sx[0],
											yp, ys, stride, copyY,
											yc, &(mby[0][0]), 32, &(mby[16][0]),
											uvc, fbp, fbstride);
									}
								else
									{
									motionComp->BiMotionCompensationUV(
											cpy[0], cpx[0], csy[0], csx[0],
											uvp, uvs, stride, copyUV,
											&(mbuv[0][0]), 32, &(mbuv[8][0]));
									motionComp->DBiMotionCompensationY(
											py[0], px[0], sy[0], sx[0],
											yp, ys, stride, copyY,
											&(mby[0][0]), 32, &(mby[16][0]),
											(BYTE *)&(mbuv[0][0]), fbp, fbstride);
									}
								}
							else
								{
								motionComp->SBiMotionCompensationUV(
										cpy[0], cpx[0], csy[0], csx[0],
										uvp, uvs, stride, copyUV,
										uvc, &(mbuv[0][0]), 32, &(mbuv[8][0]));
								motionComp->SBiMotionCompensationY(
										py[0], px[0], sy[0], sx[0],
										yp, ys, stride, copyY,
										yc, &(mby[0][0]), 32, &(mby[16][0]));
								}
							}
						else
							errorInSlice = true;
						}
					else
						{
						if (directAccess)
							{
							if (needsFrameData)
								{
								motionComp->SMotionCompensationUV(
										csy[0], csx[0],
										uvs, stride, copyUV,
										uvc, &(mbuv[0][0]), 32, &(mbuv[8][0]));
								motionComp->SDMotionCompensationY(
										sy[0], sx[0],
										ys, stride, copyY,
										yc, &(mby[0][0]), 32, &(mby[16][0]),
										uvc, fbp, fbstride);
								}
							else
								{
								motionComp->MotionCompensationUV(
										csy[0], csx[0],
										uvs, stride, copyUV,
										&(mbuv[0][0]), 32, &(mbuv[8][0]));
								motionComp->DMotionCompensationY(
										sy[0], sx[0],
										ys, stride, copyY,
										&(mby[0][0]), 32, &(mby[16][0]),
										(BYTE *)&(mbuv[0][0]), fbp, fbstride);
								}
							}
						else
							{
							motionComp->SMotionCompensationUV(
									csy[0], csx[0],
									uvs, stride, copyUV,
									uvc, &(mbuv[0][0]), 32, &(mbuv[8][0]));
							motionComp->SMotionCompensationY(
									sy[0], sx[0],
									ys, stride, copyY,
									yc, &(mby[0][0]), 32, &(mby[16][0]));
							}
						}
					}
				else
					errorInSlice = true;
				}
			else
				{
				px[0] = mx * 2 + vectors[0][0][0] & motionVectorMask;
				py[0] = my * 2 + vectors[0][0][1] & motionVectorMask;
				cpx[0] = mx + DIV2(vectors[0][0][0]);
				cpy[0] = my + DIV2(vectors[0][0][1]);

				if (predFrame->GetYPP(px[0] >> 1, py[0] >> 1, yp))
					{
					predFrame->GetUVPP(cpx[0] >> 1, cpy[0] >> 1, uvp);

					if (directAccess)
						{
						if (needsFrameData)
							{
							motionComp->SMotionCompensationUV(
									cpy[0], cpx[0],
									uvp, stride, copyUV,
									uvc, &(mbuv[0][0]), 32, &(mbuv[8][0]));
							motionComp->SDMotionCompensationY(
									py[0], px[0],
									yp, stride, copyY,
									yc, &(mby[0][0]), 32, &(mby[16][0]),
									uvc, fbp, fbstride);
							}
						else
							{
							motionComp->MotionCompensationUV(
									cpy[0], cpx[0],
									uvp, stride, copyUV,
									&(mbuv[0][0]), 32, &(mbuv[8][0]));
							motionComp->DMotionCompensationY(
									py[0], px[0],
									yp, stride, copyY,
									&(mby[0][0]), 32, &(mby[16][0]),
									(BYTE *)&(mbuv[0][0]), fbp, fbstride);
							}
						}
					else
						{
						motionComp->SMotionCompensationUV(
								cpy[0], cpx[0],
								uvp, stride, copyUV,
								uvc, &(mbuv[0][0]), 32, &(mbuv[8][0]));
						motionComp->SMotionCompensationY(
								py[0], px[0],
								yp, stride, copyY,
								yc, &(mby[0][0]), 32, &(mby[16][0]));
						}
					}
				else
					errorInSlice = true;
				}
			}
		else if (predictionType == PT_DUAL_PRIME)
			{
			sx[0] = mx * 2 + vectors[0][0][0];
			sy[0] = my     + vectors[0][0][1];
			csx[0] = mx        + DIV2(vectors[0][0][0]);
			csy[0] = (my >> 1) + DIV2(vectors[0][0][1]);

			px[0] = mx * 2 + vectors[2][0][0];
			py[0] = my     + vectors[2][0][1];
			px[1] = mx * 2 + vectors[3][0][0];
			py[1] = my     + vectors[3][0][1];
			cpx[0] = mx        + DIV2(vectors[2][0][0]);
			cpy[0] = (my >> 1) + DIV2(vectors[2][0][1]);
			cpx[1] = mx        + DIV2(vectors[3][0][0]);
			cpy[1] = (my >> 1) + DIV2(vectors[3][0][1]);

			if (predFrame->GetYPPF(FALSE, sx[0] >> 1, sy[0] >> 1, ys) &&
				 predFrame->GetYPPF(TRUE, px[0] >> 1, py[0] >> 1, yp))
				{
				predFrame->GetUVPPF(FALSE, csx[0] >> 1, csy[0] >> 1, uvs);
				predFrame->GetUVPPF(TRUE, cpx[0] >> 1, cpy[0] >> 1, uvp);

				if (directAccess)
					{
					if (needsFrameData)
						{
						motionComp->SBiMotionCompensationUV(
								cpy[0], cpx[0], csy[0], csx[0],
								uvp, uvs, 2 * stride, copyUV,
								uvc, &(mbuv[0][0]), 64, &(mbuv[8][0]));
						motionComp->SDBiMotionCompensationY(
								py[0], px[0], sy[0], sx[0],
								yp, ys, 2 * stride, copyY,
								yc, &(mby[0][0]), 64, &(mby[16][0]),
								uvc, fbp, fbstride * 2);
						}
					else
						{
						motionComp->BiMotionCompensationUV(
								cpy[0], cpx[0], csy[0], csx[0],
								uvp, uvs, 2 * stride, copyUV,
								&(mbuv[0][0]), 64, &(mbuv[8][0]));
						motionComp->DBiMotionCompensationY(
								py[0], px[0], sy[0], sx[0],
								yp, ys, 2 * stride, copyY,
								&(mby[0][0]), 64, &(mby[16][0]),
								(BYTE *)&(mbuv[0][0]), fbp, fbstride * 2);
						}
					}
				else
					{
					motionComp->SBiMotionCompensationUV(
							cpy[0], cpx[0], csy[0], csx[0],
							uvp, uvs, 2 * stride, copyUV,
							uvc, &(mbuv[0][0]), 64, &(mbuv[8][0]));
					motionComp->SBiMotionCompensationY(
							py[0], px[0], sy[0], sx[0],
							yp, ys, 2 * stride, copyY,
							yc, &(mby[0][0]), 64, &(mby[16][0]));
					}
				}
			else
				errorInSlice = true;

			if (predFrame->GetYPPF(TRUE, sx[0] >> 1, sy[0] >> 1, ys) &&
			    predFrame->GetYPPF(FALSE, px[1] >> 1, py[1] >> 1, yp))
				{
				predFrame->GetUVPPF(TRUE, csx[0] >> 1, csy[0] >> 1, uvs);
				predFrame->GetUVPPF(FALSE, cpx[1] >> 1, cpy[1] >> 1, uvp);

				if (directAccess)
					{
					if (needsFrameData)
						{
						motionComp->SBiMotionCompensationUV(
								cpy[1], cpx[1], csy[0], csx[0],
								uvp, uvs, 2 * stride, copyUV,
								uvc + stride, &(mbuv[1][0]), 64, &(mbuv[9][0]));
						motionComp->SDBiMotionCompensationY(
								py[1], px[1], sy[0], sx[0],
								yp, ys, 2 * stride, copyY,
								yc + stride, &(mby[1][0]), 64, &(mby[17][0]),
								uvc + stride, fbp + fbstride, fbstride * 2);
						}
					else
						{
						motionComp->BiMotionCompensationUV(
								cpy[1], cpx[1], csy[0], csx[0],
								uvp, uvs, 2 * stride, copyUV,
								&(mbuv[1][0]), 64, &(mbuv[9][0]));
						motionComp->DBiMotionCompensationY(
								py[1], px[1], sy[0], sx[0],
								yp, ys, 2 * stride, copyY,
								&(mby[1][0]), 64, &(mby[17][0]),
								(BYTE *)&(mbuv[1][0]), fbp + fbstride, fbstride * 2);
						}
					}
				else
					{
					motionComp->SBiMotionCompensationUV(
							cpy[1], cpx[1], csy[0], csx[0],
							uvp, uvs, 2 * stride, copyUV,
							uvc + stride, &(mbuv[1][0]), 64, &(mbuv[9][0]));
					motionComp->SBiMotionCompensationY(
							py[1], px[1], sy[0], sx[0],
							yp, ys, 2 * stride, copyY,
							yc + stride, &(mby[1][0]), 64, &(mby[17][0]));
					}
				}
			else
				errorInSlice = true;
			}
		else
			{
			if (IS_MACROBLOCK_MOTION_BACKWARD(macroblockType))
				{
				sx[0] = mx * 2 + vectors[0][1][0] & motionVectorMask;
				sy[0] = my     + vectors[0][1][1] & motionVectorMask;
				sx[1] = mx * 2 + vectors[1][1][0] & motionVectorMask;
				sy[1] = my     + vectors[1][1][1] & motionVectorMask;
				csx[0] = mx        + DIV2(vectors[0][1][0]);
				csy[0] = (my >> 1) + DIV2(vectors[0][1][1]);
				csx[1] = mx        + DIV2(vectors[1][1][0]);
				csy[1] = (my >> 1) + DIV2(vectors[1][1][1]);

				if (IS_MACROBLOCK_MOTION_FORWARD(macroblockType))
					{
					px[0] = mx * 2 + vectors[0][0][0] & motionVectorMask;
					py[0] = my     + vectors[0][0][1] & motionVectorMask;
					px[1] = mx * 2 + vectors[1][0][0] & motionVectorMask;
					py[1] = my     + vectors[1][0][1] & motionVectorMask;
					cpx[0] = mx        + DIV2(vectors[0][0][0]);
					cpy[0] = (my >> 1) + DIV2(vectors[0][0][1]);
					cpx[1] = mx        + DIV2(vectors[1][0][0]);
					cpy[1] = (my >> 1) + DIV2(vectors[1][0][1]);

					if (predFrame->GetYPPF(motionVerticalFieldSelect[0][0], px[0] >> 1, py[0] >> 1, yp) &&
						 succFrame->GetYPPF(motionVerticalFieldSelect[0][1], sx[0] >> 1, sy[0] >> 1, ys))
						{
						predFrame->GetUVPPF(motionVerticalFieldSelect[0][0], cpx[0] >> 1, cpy[0] >> 1, uvp);
						succFrame->GetUVPPF(motionVerticalFieldSelect[0][1], csx[0] >> 1, csy[0] >> 1, uvs);

						if (directAccess)
							{
							if (needsFrameData)
								{
								motionComp->SBiMotionCompensationUV(
										cpy[0], cpx[0], csy[0], csx[0],
										uvp, uvs, 2 * stride, copyUV,
										uvc, &(mbuv[0][0]), 64, &(mbuv[8][0]));
								motionComp->SDBiMotionCompensationY(
										py[0], px[0], sy[0], sx[0],
										yp, ys, 2 * stride, copyY,
										yc, &(mby[0][0]), 64, &(mby[16][0]),
										uvc, fbp, fbstride * 2);
								}
							else
								{
								motionComp->BiMotionCompensationUV(
										cpy[0], cpx[0], csy[0], csx[0],
										uvp, uvs, 2 * stride, copyUV,
										&(mbuv[0][0]), 64, &(mbuv[8][0]));
								motionComp->DBiMotionCompensationY(
										py[0], px[0], sy[0], sx[0],
										yp, ys, 2 * stride, copyY,
										&(mby[0][0]), 64, &(mby[16][0]),
										(BYTE *)&(mbuv[0][0]), fbp, fbstride * 2);
								}
							}
						else
							{
							motionComp->SBiMotionCompensationUV(
									cpy[0], cpx[0], csy[0], csx[0],
									uvp, uvs, 2 * stride, copyUV,
									uvc, &(mbuv[0][0]), 64, &(mbuv[8][0]));
							motionComp->SBiMotionCompensationY(
									py[0], px[0], sy[0], sx[0],
									yp, ys, 2 * stride, copyY,
									yc, &(mby[0][0]), 64, &(mby[16][0]));
							}
						}
					else
						errorInSlice = true;

					if (predFrame->GetYPPF(motionVerticalFieldSelect[1][0], px[1] >> 1, py[1] >> 1, yp) &&
						 succFrame->GetYPPF(motionVerticalFieldSelect[1][1], sx[1] >> 1, sy[1] >> 1, ys))
						{
						predFrame->GetUVPPF(motionVerticalFieldSelect[1][0], cpx[1] >> 1, cpy[1] >> 1, uvp);
						succFrame->GetUVPPF(motionVerticalFieldSelect[1][1], csx[1] >> 1, csy[1] >> 1, uvs);

						if (directAccess)
							{
							if (needsFrameData)
								{
								motionComp->SBiMotionCompensationUV(
										cpy[1], cpx[1], csy[1], csx[1],
										uvp, uvs, 2 * stride, copyUV,
										uvc + stride, &(mbuv[1][0]), 64, &(mbuv[9][0]));
								motionComp->SDBiMotionCompensationY(
										py[1], px[1], sy[1], sx[1],
										yp, ys, 2 * stride, copyY,
										yc + stride, &(mby[1][0]), 64, &(mby[17][0]),
										uvc + stride, fbp + fbstride, fbstride * 2);
								}
							else
								{
								motionComp->BiMotionCompensationUV(
										cpy[1], cpx[1], csy[1], csx[1],
										uvp, uvs, 2 * stride, copyUV,
										&(mbuv[1][0]), 64, &(mbuv[9][0]));
								motionComp->DBiMotionCompensationY(
										py[1], px[1], sy[1], sx[1],
										yp, ys, 2 * stride, copyY,
										&(mby[1][0]), 64, &(mby[17][0]),
										(BYTE *)&(mbuv[1][0]), fbp + fbstride, fbstride * 2);
								}
							}
						else
							{
							motionComp->SBiMotionCompensationUV(
									cpy[1], cpx[1], csy[1], csx[1],
									uvp, uvs, 2 * stride, copyUV,
									uvc + stride, &(mbuv[1][0]), 64, &(mbuv[9][0]));
							motionComp->SBiMotionCompensationY(
									py[1], px[1], sy[1], sx[1],
									yp, ys, 2 * stride, copyY,
									yc + stride, &(mby[1][0]), 64, &(mby[17][0]));
							}
						}
					else
						errorInSlice = true;
					}
				else
					{
					if (succFrame->GetYPPF(motionVerticalFieldSelect[0][1], sx[0] >> 1, sy[0] >> 1, ys))
						{
						succFrame->GetUVPPF(motionVerticalFieldSelect[0][1], csx[0] >> 1, csy[0] >> 1, uvs);

						if (directAccess)
							{
							if (needsFrameData)
								{
								motionComp->SMotionCompensationUV(
										csy[0], csx[0],
										uvs, 2 * stride, copyUV,
										uvc, &(mbuv[0][0]), 64, &(mbuv[8][0]));
								motionComp->SDMotionCompensationY(
										sy[0], sx[0],
										ys, 2 * stride, copyY,
										yc, &(mby[0][0]), 64, &(mby[16][0]),
										uvc, fbp, 2 * fbstride);
								}
							else
								{
								motionComp->MotionCompensationUV(
										csy[0], csx[0],
										uvs, 2 * stride, copyUV,
										&(mbuv[0][0]), 64, &(mbuv[8][0]));
								motionComp->DMotionCompensationY(
										sy[0], sx[0],
										ys, 2 * stride, copyY,
										&(mby[0][0]), 64, &(mby[16][0]),
										(BYTE *)&(mbuv[0][0]), fbp, 2 * fbstride);
								}
							}
						else
							{
							motionComp->SMotionCompensationUV(
									csy[0], csx[0],
									uvs, 2 * stride, copyUV,
									uvc, &(mbuv[0][0]), 64, &(mbuv[8][0]));
							motionComp->SMotionCompensationY(
									sy[0], sx[0],
									ys, 2 * stride, copyY,
									yc, &(mby[0][0]), 64, &(mby[16][0]));
							}
						}
					else
						errorInSlice = true;

					if (succFrame->GetYPPF(motionVerticalFieldSelect[1][1], sx[1] >> 1, sy[1] >> 1, ys))
						{
						succFrame->GetUVPPF(motionVerticalFieldSelect[1][1], csx[1] >> 1, csy[1] >> 1, uvs);

						if (directAccess)
							{
							if (needsFrameData)
								{
								motionComp->SMotionCompensationUV(
										csy[1], csx[1],
										uvs, 2 * stride, copyUV,
										uvc + stride, &(mbuv[1][0]), 64, &(mbuv[9][0]));
								motionComp->SDMotionCompensationY(
										sy[1], sx[1],
										ys, 2 * stride, copyY,
										yc + stride, &(mby[1][0]), 64, &(mby[17][0]),
										uvc + stride, fbp + fbstride, 2 * fbstride);
								}
							else
								{
								motionComp->MotionCompensationUV(
										csy[1], csx[1],
										uvs, 2 * stride, copyUV,
										&(mbuv[1][0]), 64, &(mbuv[9][0]));
								motionComp->DMotionCompensationY(
										sy[1], sx[1],
										ys, 2 * stride, copyY,
										&(mby[1][0]), 64, &(mby[17][0]),
										(BYTE *)&(mbuv[1][0]), fbp + fbstride, 2 * fbstride);
								}
							}
						else
							{
							motionComp->SMotionCompensationUV(
									csy[1], csx[1],
									uvs, 2 * stride, copyUV,
									uvc + stride, &(mbuv[1][0]), 64, &(mbuv[9][0]));
							motionComp->SMotionCompensationY(
									sy[1], sx[1],
									ys, 2 * stride, copyY,
									yc + stride, &(mby[1][0]), 64, &(mby[17][0]));
							}
						}
					else
						errorInSlice = true;
					}
				}
			else
				{
				px[0] = mx * 2 + vectors[0][0][0] & motionVectorMask;
				py[0] = my + vectors[0][0][1] & motionVectorMask;
				px[1] = mx * 2 + vectors[1][0][0] & motionVectorMask;
				py[1] = my + vectors[1][0][1] & motionVectorMask;
				cpx[0] = mx        + DIV2(vectors[0][0][0]);
				cpy[0] = (my >> 1) + DIV2(vectors[0][0][1]);
				cpx[1] = mx        + DIV2(vectors[1][0][0]);
				cpy[1] = (my >> 1) + DIV2(vectors[1][0][1]);

				if (predFrame->GetYPPF(motionVerticalFieldSelect[0][0], px[0] >> 1, py[0] >> 1, yp))
					{
					predFrame->GetUVPPF(motionVerticalFieldSelect[0][0], cpx[0] >> 1, cpy[0] >> 1, uvp);

					if (directAccess)
						{
						if (needsFrameData)
							{
							motionComp->SMotionCompensationUV(
									cpy[0], cpx[0],
									uvp, 2 * stride, copyUV,
									uvc, &(mbuv[0][0]), 64, &(mbuv[8][0]));
							motionComp->SDMotionCompensationY(
									py[0], px[0],
									yp, 2 * stride, copyY,
									yc, &(mby[0][0]), 64, &(mby[16][0]),
									uvc, fbp, 2 * fbstride);
							}
						else
							{
							motionComp->MotionCompensationUV(
									cpy[0], cpx[0],
									uvp, 2 * stride, copyUV,
									&(mbuv[0][0]), 64, &(mbuv[8][0]));
							motionComp->DMotionCompensationY(
									py[0], px[0],
									yp, 2 * stride, copyY,
									&(mby[0][0]), 64, &(mby[16][0]),
									(BYTE *)&(mbuv[0][0]), fbp, 2 * fbstride);
							}
						}
					else
						{
						motionComp->SMotionCompensationUV(
								cpy[0], cpx[0],
								uvp, 2 * stride, copyUV,
								uvc, &(mbuv[0][0]), 64, &(mbuv[8][0]));
						motionComp->SMotionCompensationY(
								py[0], px[0],
								yp, 2 * stride, copyY,
								yc, &(mby[0][0]), 64, &(mby[16][0]));
						}
					}
				else
					errorInSlice = true;

				if (predFrame->GetYPPF(motionVerticalFieldSelect[1][0], px[1] >> 1, py[1] >> 1, yp))
					{
					predFrame->GetUVPPF(motionVerticalFieldSelect[1][0], cpx[1] >> 1, cpy[1] >> 1, uvp);

					if (directAccess)
						{
						if (needsFrameData)
							{
							motionComp->SMotionCompensationUV(
									cpy[1], cpx[1],
									uvp, 2 * stride, copyUV,
									uvc + stride, &(mbuv[1][0]), 64, &(mbuv[9][0]));
							motionComp->SDMotionCompensationY(
									py[1], px[1],
									yp, 2 * stride, copyY,
									yc + stride, &(mby[1][0]), 64, &(mby[17][0]),
									uvc + stride, fbp + fbstride, 2 * fbstride);
							}
						else
							{
							motionComp->MotionCompensationUV(
									cpy[1], cpx[1],
									uvp, 2 * stride, copyUV,
									&(mbuv[1][0]), 64, &(mbuv[9][0]));
							motionComp->DMotionCompensationY(
									py[1], px[1],
									yp, 2 * stride, copyY,
									&(mby[1][0]), 64, &(mby[17][0]),
									(BYTE *)&(mbuv[1][0]), fbp + fbstride, 2 * fbstride);
							}
						}
					else
						{
						motionComp->SMotionCompensationUV(
								cpy[1], cpx[1],
								uvp, 2 * stride, copyUV,
								uvc + stride, &(mbuv[1][0]), 64, &(mbuv[9][0]));
						motionComp->SMotionCompensationY(
								py[1], px[1],
								yp, 2 * stride, copyY,
								yc + stride, &(mby[1][0]), 64, &(mby[17][0]));
						}
					}
				else
					errorInSlice = true;
				}
			}
		}
	else
		{
		curFrame->GetIMPP(currentFieldID, mx, my, yc, uvc, stride);

		if (predictionType == PT_FIELD_BASED)
			{
			if (IS_MACROBLOCK_MOTION_BACKWARD(macroblockType))
				{
				sx[0] = mx * 2 + vectors[0][1][0] & motionVectorMask;
				sy[0] = my * 2 + vectors[0][1][1] & motionVectorMask;
				csx[0] = mx + DIV2(vectors[0][1][0]);
				csy[0] = my + DIV2(vectors[0][1][1]);

				if (succFrame->GetYPPF(motionVerticalFieldSelect[0][1], sx[0] >> 1, sy[0] >> 1, ys))
					{
					succFrame->GetUVPPF(motionVerticalFieldSelect[0][1], csx[0] >> 1, csy[0] >> 1, uvs);

					if (IS_MACROBLOCK_MOTION_FORWARD(macroblockType))
						{
						px[0] = mx * 2 + vectors[0][0][0] & motionVectorMask;
						py[0] = my * 2 + vectors[0][0][1] & motionVectorMask;
						cpx[0] = mx + DIV2(vectors[0][0][0]);
						cpy[0] = my + DIV2(vectors[0][0][1]);

						if (predFrame->GetYPPF(motionVerticalFieldSelect[0][0], px[0] >> 1, py[0] >> 1, yp))
							{
							predFrame->GetUVPPF(motionVerticalFieldSelect[0][0], cpx[0] >> 1, cpy[0] >> 1, uvp);

							if (directAccess)
								{
								if (needsFrameData)
									{
									motionComp->SBiMotionCompensationUV(
											cpy[0], cpx[0], csy[0], csx[0],
											uvp, uvs, stride, copyUV,
											uvc, &(mbuv[0][0]), 32, &(mbuv[8][0]));
									motionComp->SDBiMotionCompensationY(
											py[0], px[0], sy[0], sx[0],
											yp, ys, stride, copyY,
											yc, &(mby[0][0]), 32, &(mby[16][0]),
											uvc, fbp, fbstride);
									}
								else
									{
									motionComp->BiMotionCompensationUV(
											cpy[0], cpx[0], csy[0], csx[0],
											uvp, uvs, stride, copyUV,
											&(mbuv[0][0]), 32, &(mbuv[8][0]));
									motionComp->DBiMotionCompensationY(
											py[0], px[0], sy[0], sx[0],
											yp, ys, stride, copyY,
											&(mby[0][0]), 32, &(mby[16][0]),
											(BYTE *)&(mbuv[0][0]), fbp, fbstride);
									}
								}
							else
								{
								motionComp->SBiMotionCompensationUV(
										cpy[0], cpx[0], csy[0], csx[0],
										uvp, uvs, stride, copyUV,
										uvc, &(mbuv[0][0]), 32, &(mbuv[8][0]));
								motionComp->SBiMotionCompensationY(
										py[0], px[0], sy[0], sx[0],
										yp, ys, stride, copyY,
										yc, &(mby[0][0]), 32, &(mby[16][0]));
								}
							}
						else
							errorInSlice = true;
						}
					else
						{
						if (directAccess)
							{
							if (needsFrameData)
								{
								motionComp->SMotionCompensationUV(
										csy[0], csx[0],
										uvs, stride, copyUV,
										uvc, &(mbuv[0][0]), 32, &(mbuv[8][0]));
								motionComp->SDMotionCompensationY(
										sy[0], sx[0],
										ys, stride, copyY,
										yc, &(mby[0][0]), 32, &(mby[16][0]),
										uvc, fbp, fbstride);
								}
							else
								{
								motionComp->MotionCompensationUV(
										csy[0], csx[0],
										uvs, stride, copyUV,
										&(mbuv[0][0]), 32, &(mbuv[8][0]));
								motionComp->DMotionCompensationY(
										sy[0], sx[0],
										ys, stride, copyY,
										&(mby[0][0]), 32, &(mby[16][0]),
										(BYTE *)&(mbuv[0][0]), fbp, fbstride);
								}
							}
						else
							{
							motionComp->SMotionCompensationUV(
									csy[0], csx[0],
									uvs, stride, copyUV,
									uvc, &(mbuv[0][0]), 32, &(mbuv[8][0]));
							motionComp->SMotionCompensationY(
									sy[0], sx[0],
									ys, stride, copyY,
									yc, &(mby[0][0]), 32, &(mby[16][0]));
							}
						}
					}
				else
					errorInSlice = true;
				}
			else
				{
				px[0] = mx * 2 + vectors[0][0][0] & motionVectorMask;
				py[0] = my * 2 + vectors[0][0][1] & motionVectorMask;
				cpx[0] = mx + DIV2(vectors[0][0][0]);
				cpy[0] = my + DIV2(vectors[0][0][1]);

				if (predFields[motionVerticalFieldSelect[0][0]]->GetYPPF(motionVerticalFieldSelect[0][0], px[0] >> 1, py[0] >> 1, yp))
					{
					predFields[motionVerticalFieldSelect[0][0]]->GetUVPPF(motionVerticalFieldSelect[0][0], cpx[0] >> 1, cpy[0] >> 1, uvp);

					if (directAccess)
						{
						if (needsFrameData)
							{
							motionComp->SMotionCompensationUV(
									cpy[0], cpx[0],
									uvp, stride, copyUV,
									uvc, &(mbuv[0][0]), 32, &(mbuv[8][0]));
							motionComp->SDMotionCompensationY(
									py[0], px[0],
									yp, stride, copyY,
									yc, &(mby[0][0]), 32, &(mby[16][0]),
									uvc, fbp, fbstride);
							}
						else
							{
							motionComp->MotionCompensationUV(
									cpy[0], cpx[0],
									uvp, stride, copyUV,
									&(mbuv[0][0]), 32, &(mbuv[8][0]));
							motionComp->DMotionCompensationY(
									py[0], px[0],
									yp, stride, copyY,
									&(mby[0][0]), 32, &(mby[16][0]),
									(BYTE *)&(mbuv[0][0]), fbp, fbstride);
							}
						}
					else
						{
						motionComp->SMotionCompensationUV(
								cpy[0], cpx[0],
								uvp, stride, copyUV,
								uvc, &(mbuv[0][0]), 32, &(mbuv[8][0]));
						motionComp->SMotionCompensationY(
								py[0], px[0],
								yp, stride, copyY,
								yc, &(mby[0][0]), 32, &(mby[16][0]));
						}
					}
				else
					errorInSlice = true;
				}
			}
		else if (predictionType == PT_DUAL_PRIME)
			{
			sx[0] = mx * 2 + vectors[0][0][0];
			sy[0] = my * 2 + vectors[0][0][1];
			csx[0] = mx + DIV2(vectors[0][0][0]);
			csy[0] = my + DIV2(vectors[0][0][1]);
			px[0] = mx * 2 + vectors[2][0][0];
			py[0] = my * 2 + vectors[2][0][1];
			cpx[0] = mx + DIV2(vectors[2][0][0]);
			cpy[0] = my + DIV2(vectors[2][0][1]);

			if (predFields[!currentFieldID]->GetYPPF(!currentFieldID, px[0] >> 1, py[0] >> 1, yp) &&
			    predFields[currentFieldID]->GetYPPF(currentFieldID, sx[0] >> 1, sy[0] >> 1, ys))
				{
				predFields[!currentFieldID]->GetUVPPF(!currentFieldID, cpx[0] >> 1, cpy[0] >> 1, uvp);
				predFields[currentFieldID]->GetUVPPF(currentFieldID, csx[0] >> 1, csy[0] >> 1, uvs);

				if (directAccess)
					{
					if (needsFrameData)
						{
						motionComp->SBiMotionCompensationUV(
								cpy[0], cpx[0], csy[0], csx[0],
								uvp, uvs, stride, copyUV,
								uvc, &(mbuv[0][0]), 32, &(mbuv[8][0]));
						motionComp->SDBiMotionCompensationY(
								py[0], px[0], sy[0], sx[0],
								yp, ys, stride, copyY,
								yc, &(mby[0][0]), 32, &(mby[16][0]),
								uvc, fbp, fbstride);
						}
					else
						{
						motionComp->BiMotionCompensationUV(
								cpy[0], cpx[0], csy[0], csx[0],
								uvp, uvs, stride, copyUV,
								&(mbuv[0][0]), 32, &(mbuv[8][0]));
						motionComp->DBiMotionCompensationY(
								py[0], px[0], sy[0], sx[0],
								yp, ys, stride, copyY,
								&(mby[0][0]), 32, &(mby[16][0]),
								(BYTE *)&(mbuv[0][0]), fbp, fbstride);
						}
					}
				else
					{
					motionComp->SBiMotionCompensationUV(
							cpy[0], cpx[0], csy[0], csx[0],
							uvp, uvs, stride, copyUV,
							uvc, &(mbuv[0][0]), 32, &(mbuv[8][0]));
					motionComp->SBiMotionCompensationY(
							py[0], px[0], sy[0], sx[0],
							yp, ys, stride, copyY,
							yc, &(mby[0][0]), 32, &(mby[16][0]));
					}
				}
			else
				errorInSlice = true;
			}
		else
			{
			if (IS_MACROBLOCK_MOTION_BACKWARD(macroblockType))
				{
				sx[0] = mx * 2 + vectors[0][1][0] & motionVectorMask;
				sy[0] = my * 2 + vectors[0][1][1] & motionVectorMask;
				sx[1] = mx * 2 + vectors[1][1][0] & motionVectorMask;
				sy[1] = my * 2 + (vectors[1][1][1] + 16)  & motionVectorMask;
				csx[0] = mx + DIV2(vectors[0][1][0]);
				csy[0] = my + DIV2(vectors[0][1][1]);
				csx[1] = mx + DIV2(vectors[1][1][0]);
				csy[1] = my + DIV2(vectors[1][1][1]) + 8;

				if (IS_MACROBLOCK_MOTION_FORWARD(macroblockType))
					{
					px[0] = mx * 2 + vectors[0][0][0] & motionVectorMask;
					py[0] = my * 2 + vectors[0][0][1] & motionVectorMask;
					px[1] = mx * 2 + vectors[1][0][0] & motionVectorMask;
					py[1] = my * 2 + (vectors[1][0][1] + 16)  & motionVectorMask;
					cpx[0] = mx + DIV2(vectors[0][0][0]);
					cpy[0] = my + DIV2(vectors[0][0][1]);
					cpx[1] = mx + DIV2(vectors[1][0][0]);
					cpy[1] = my + DIV2(vectors[1][0][1]) + 8;

					if (succFrame->GetYPPF(motionVerticalFieldSelect[0][1], sx[0] >> 1, sy[0] >> 1, ys) &&
						 predFrame->GetYPPF(motionVerticalFieldSelect[0][0], px[0] >> 1, py[0] >> 1, yp))
						{
						succFrame->GetUVPPF(motionVerticalFieldSelect[0][1], csx[0] >> 1, csy[0] >> 1, uvs);
						predFrame->GetUVPPF(motionVerticalFieldSelect[0][0], cpx[0] >> 1, cpy[0] >> 1, uvp);

						if (directAccess)
							{
							if (needsFrameData)
								{
								motionComp->SBiMotionCompensationUV(
										cpy[0], cpx[0], csy[0], csx[0],
										uvp, uvs, stride, copyUV,
										uvc, &(mbuv[0][0]), 32, &(mbuv[4][0]));
								motionComp->SDBiMotionCompensationY(
										py[0], px[0], sy[0], sx[0],
										yp, ys, stride, copyY,
										yc, &(mby[0][0]), 32, &(mby[8][0]),
										uvc, fbp, fbstride);
								}
							else
								{
								motionComp->BiMotionCompensationUV(
										cpy[0], cpx[0], csy[0], csx[0],
										uvp, uvs, stride, copyUV,
										&(mbuv[0][0]), 32, &(mbuv[4][0]));
								motionComp->DBiMotionCompensationY(
										py[0], px[0], sy[0], sx[0],
										yp, ys, stride, copyY,
										&(mby[0][0]), 32, &(mby[8][0]),
										(BYTE *)&(mbuv[0][0]), fbp, fbstride);
								}
							}
						else
							{
							motionComp->SBiMotionCompensationUV(
									cpy[0], cpx[0], csy[0], csx[0],
									uvp, uvs, stride, copyUV,
									uvc, &(mbuv[0][0]), 32, &(mbuv[4][0]));
							motionComp->SBiMotionCompensationY(
									py[0], px[0], sy[0], sx[0],
									yp, ys, stride, copyY,
									yc, &(mby[0][0]), 32, &(mby[8][0]));
							}
						}
					else
						errorInSlice = true;

					if (succFrame->GetYPPF(motionVerticalFieldSelect[1][1], sx[1] >> 1, sy[1] >> 1, ys) &&
						 predFrame->GetYPPF(motionVerticalFieldSelect[1][0], px[1] >> 1, py[1] >> 1, yp))
						{
						succFrame->GetUVPPF(motionVerticalFieldSelect[1][1], csx[1] >> 1, csy[1] >> 1, uvs);
						predFrame->GetUVPPF(motionVerticalFieldSelect[1][0], cpx[1] >> 1, cpy[1] >> 1, uvp);

						if (directAccess)
							{
							if (needsFrameData)
								{
								motionComp->SBiMotionCompensationUV(
										cpy[0], cpx[0], csy[0], csx[0],
										uvp, uvs, stride, copyUV,
										uvc + 4 * stride, &(mbuv[4][0]), 32, &(mbuv[8][0]));
								motionComp->SDBiMotionCompensationY(
										py[0], px[0], sy[0], sx[0],
										yp, ys, stride, copyY,
										yc + 8 * stride, &(mby[8][0]), 32, &(mby[16][0]),
										uvc + 4 * stride, fbp + 8 * fbstride, fbstride);
								}
							else
								{
								motionComp->BiMotionCompensationUV(
										cpy[0], cpx[0], csy[0], csx[0],
										uvp, uvs, stride, copyUV,
										&(mbuv[4][0]), 32, &(mbuv[8][0]));
								motionComp->DBiMotionCompensationY(
										py[0], px[0], sy[0], sx[0],
										yp, ys, stride, copyY,
										&(mby[8][0]), 32, &(mby[16][0]),
										(BYTE *)&(mbuv[4][0]), fbp + 8 * fbstride, fbstride);
								}
							}
						else
							{
							motionComp->SBiMotionCompensationUV(
									cpy[0], cpx[0], csy[0], csx[0],
									uvp, uvs, stride, copyUV,
									uvc + 4 * stride, &(mbuv[4][0]), 32, &(mbuv[8][0]));
							motionComp->SBiMotionCompensationY(
									py[0], px[0], sy[0], sx[0],
									yp, ys, stride, copyY,
									yc + 8 * stride, &(mby[8][0]), 32, &(mby[16][0]));
							}
						}
					else
						errorInSlice = true;
					}
				else
					{
					if (succFrame->GetYPPF(motionVerticalFieldSelect[0][1], sx[0] >> 1, sy[0] >> 1, ys))
						{
						succFrame->GetUVPPF(motionVerticalFieldSelect[0][1], csx[0] >> 1, csy[0] >> 1, uvs);

						if (directAccess)
							{
							if (needsFrameData)
								{
								motionComp->SMotionCompensationUV(
										csy[0], csx[0],
										uvs, stride, copyUV,
										uvc, &(mbuv[0][0]), 32, &(mbuv[4][0]));
								motionComp->SDMotionCompensationY(
										sy[0], sx[0],
										ys, stride, copyY,
										yc, &(mby[0][0]), 32, &(mby[8][0]),
										uvc, fbp, fbstride);
								}
							else
								{
								motionComp->MotionCompensationUV(
										csy[0], csx[0],
										uvs, stride, copyUV,
										&(mbuv[0][0]), 32, &(mbuv[4][0]));
								motionComp->DMotionCompensationY(
										sy[0], sx[0],
										ys, stride, copyY,
										&(mby[0][0]), 32, &(mby[8][0]),
										(BYTE *)&(mbuv[0][0]), fbp, fbstride);
								}
							}
						else
							{
							motionComp->SMotionCompensationUV(
									csy[0], csx[0],
									uvs, stride, copyUV,
									uvc, &(mbuv[0][0]), 32, &(mbuv[4][0]));
							motionComp->SMotionCompensationY(
									sy[0], sx[0],
									ys, stride, copyY,
									yc, &(mby[0][0]), 32, &(mby[8][0]));
							}
						}

					if (succFrame->GetYPPF(motionVerticalFieldSelect[1][1], sx[1] >> 1, sy[1] >> 1, ys))
						{
						succFrame->GetUVPPF(motionVerticalFieldSelect[1][1], csx[1] >> 1, csy[1] >> 1, uvs);

						if (directAccess)
							{
							if (needsFrameData)
								{
								motionComp->SMotionCompensationUV(
										csy[0], csx[0],
										uvs, stride, copyUV,
										uvc + 4 * stride, &(mbuv[4][0]), 32, &(mbuv[8][0]));
								motionComp->SDMotionCompensationY(
										sy[0], sx[0],
										ys, stride, copyY,
										yc + 8 * stride, &(mby[8][0]), 32, &(mby[16][0]),
										uvc + 4 * stride, fbp + 8 * fbstride, fbstride);
								}
							else
								{
								motionComp->MotionCompensationUV(
										csy[0], csx[0],
										uvs, stride, copyUV,
										&(mbuv[4][0]), 32, &(mbuv[8][0]));
								motionComp->DMotionCompensationY(
										sy[0], sx[0],
										ys, stride, copyY,
										&(mby[8][0]), 32, &(mby[16][0]),
										(BYTE *)&(mbuv[4][0]), fbp + 8 * fbstride, fbstride);
								}
							}
						else
							{
							motionComp->SMotionCompensationUV(
									csy[0], csx[0],
									uvs, stride, copyUV,
									uvc + 4 * stride, &(mbuv[4][0]), 32, &(mbuv[8][0]));
							motionComp->SMotionCompensationY(
									sy[0], sx[0],
									ys, stride, copyY,
									yc + 8 * stride, &(mby[8][0]), 32, &(mby[16][0]));
							}
						}
					else
						errorInSlice = true;
					}
				}
			else
				{
				px[0] = mx * 2 + vectors[0][0][0] & motionVectorMask;
				py[0] = my * 2 + vectors[0][0][1] & motionVectorMask;
				px[1] = mx * 2 + vectors[1][0][0] & motionVectorMask;
				py[1] = my * 2 + (vectors[1][0][1] + 16)  & motionVectorMask;
				cpx[0] = mx + DIV2(vectors[0][0][0]);
				cpy[0] = my + DIV2(vectors[0][0][1]);
				cpx[1] = mx + DIV2(vectors[1][0][0]);
				cpy[1] = my + DIV2(vectors[1][0][1]) + 8;

				if (predFields[motionVerticalFieldSelect[0][0]]->GetYPPF(motionVerticalFieldSelect[0][0], px[0] >> 1, py[0] >> 1, yp))
					{
					predFields[motionVerticalFieldSelect[0][0]]->GetUVPPF(motionVerticalFieldSelect[0][0], cpx[0] >> 1, cpy[0] >> 1, uvp);

					if (directAccess)
						{
						if (needsFrameData)
							{
							motionComp->SMotionCompensationUV(
									cpy[0], cpx[0],
									uvp, stride, copyUV,
									uvc, &(mbuv[0][0]), 32, &(mbuv[4][0]));
							motionComp->SDMotionCompensationY(
									py[0], px[0],
									yp, stride, copyY,
									yc, &(mby[0][0]), 32, &(mby[8][0]),
									uvc, fbp, fbstride);
							}
						else
							{
							motionComp->MotionCompensationUV(
									cpy[0], cpx[0],
									uvp, stride, copyUV,
									&(mbuv[0][0]), 32, &(mbuv[4][0]));
							motionComp->DMotionCompensationY(
									py[0], px[0],
									yp, stride, copyY,
									&(mby[0][0]), 32, &(mby[8][0]),
									(BYTE *)&(mbuv[0][0]), fbp, fbstride);
							}
						}
					else
						{
						motionComp->SMotionCompensationUV(
								cpy[0], cpx[0],
								uvp, stride, copyUV,
								uvc, &(mbuv[0][0]), 32, &(mbuv[4][0]));
						motionComp->SMotionCompensationY(
								py[0], px[0],
								yp, stride, copyY,
								yc, &(mby[0][0]), 32, &(mby[8][0]));
						}
					}
				else
					errorInSlice = true;

				if (predFields[motionVerticalFieldSelect[1][0]]->GetYPPF(motionVerticalFieldSelect[1][0], px[1] >> 1, py[1] >> 1, yp))
					{
					predFields[motionVerticalFieldSelect[1][0]]->GetUVPPF(motionVerticalFieldSelect[1][0], cpx[1] >> 1, cpy[1] >> 1, uvp);

					if (directAccess)
						{
						if (needsFrameData)
							{
							motionComp->SMotionCompensationUV(
									cpy[0], cpx[0],
									uvp, stride, copyUV,
									uvc + 4 * stride, &(mbuv[4][0]), 32, &(mbuv[8][0]));
							motionComp->SDMotionCompensationY(
									py[0], px[0],
									yp, stride, copyY,
									yc + 8 * stride, &(mby[8][0]), 32, &(mby[16][0]),
									uvc + 4 * stride, fbp + 8 * fbstride, fbstride);
							}
						else
							{
							motionComp->MotionCompensationUV(
									cpy[0], cpx[0],
									uvp, stride, copyUV,
									&(mbuv[4][0]), 32, &(mbuv[8][0]));
							motionComp->DMotionCompensationY(
									py[0], px[0],
									yp, stride, copyY,
									&(mby[8][0]), 32, &(mby[16][0]),
									(BYTE *)&(mbuv[4][0]), fbp + 8 * fbstride, fbstride);
							}
						}
					else
						{
						motionComp->SMotionCompensationUV(
								cpy[0], cpx[0],
								uvp, stride, copyUV,
								uvc + 4 * stride, &(mbuv[4][0]), 32, &(mbuv[8][0]));
						motionComp->SMotionCompensationY(
								py[0], px[0],
								yp, stride, copyY,
								yc + 8 * stride, &(mby[8][0]), 32, &(mby[16][0]));
						}
					}
				else
					errorInSlice = true;
				}
			}
		}
	}

bool QFastMMXSliceDecoder::AttemptDirectAccess(void)
	{
	if (pictureStructure == PS_FRAME_PICTURE)
		return display->AttemptDirectStripeYUVAccess(width, height, macroblockY * 16, fbp, ifbp, fbstride);
	else
		{
		if (display->AttemptDirectStripeYUVAccess(width, height, macroblockY * 32, fbp, ifbp, fbstride))
			{
			if (ifbp)
				{
				if (pictureStructure == PS_BOTTOM_FIELD) fbp = ifbp;
				ifbp = NULL;
				}
			else
				{
				if (pictureStructure == PS_BOTTOM_FIELD) fbp += fbstride;
				fbstride *= 2;
				}

			return TRUE;
			}
		else
			return FALSE;
		}
	}

void QFastMMXSliceDecoder::DoneDirectAccess(void)
	{
	display->DoneDirectStripeAccess(pictureStructure);
	}

bool QFastMMXSliceDecoder::BeginFrameDecoding(FrameStore * pred, FrameStore * succ, FrameStore * curr, PictureDisplayBuffer * display, bool hurryUp)
	{
	needsFrameData = !display ||
		               pictureCodingType != BIDIRECTIONAL_PREDICTIVE_CODED ||
							display->NeedsFrameDataWithDirectYUVAccess();

	if (GenericPackedIntraMMXSliceDecoder::BeginFrameDecoding(pred, succ, curr, display, hurryUp))
		{
		if (this->hurryUp)
			motionVectorMask = ~1;
		else
			motionVectorMask = ~0;

		if (needsFrameData)
			{
			if (pictureStructure == PS_FRAME_PICTURE)
				{
				iyuvbd[0][0] = curr->Stride();
				iyuvbd[0][1] = curr->Stride();
				iyuvbd[0][2] = curr->Stride();

				iyuvbp[0][0] = (BYTE *)0;
				iyuvbp[0][1] = (BYTE *)8;
				iyuvbp[0][2] = (BYTE *)(8 * curr->Stride());
				iyuvbp[0][3] = (BYTE *)(8 * curr->Stride() + 8);
				iyuvbp[0][4] = (BYTE *)0;
				iyuvbp[0][5] = (BYTE *)8;

				iyuvbd[1][0] = curr->Stride() * 2;
				iyuvbd[1][1] = curr->Stride();
				iyuvbd[1][2] = curr->Stride();

				iyuvbp[1][0] = (BYTE *)0;
				iyuvbp[1][1] = (BYTE *)8;
				iyuvbp[1][2] = (BYTE *)(curr->Stride());
				iyuvbp[1][3] = (BYTE *)(curr->Stride() + 8);
				iyuvbp[1][4] = (BYTE *)0;
				iyuvbp[1][5] = (BYTE *)8;
				}
			else
				{
				iyuvbd[0][0] = iyuvbd[1][0] = 2 * curr->Stride();
				iyuvbd[0][1] = iyuvbd[1][1] = 2 * curr->Stride();
				iyuvbd[0][2] = iyuvbd[1][2] = 2 * curr->Stride();

				iyuvbp[0][0] = iyuvbp[1][0] = (BYTE *)0;
				iyuvbp[0][1] = iyuvbp[1][1] = (BYTE *)8;
				iyuvbp[0][2] = iyuvbp[1][2] = (BYTE *)(16 * curr->Stride());
				iyuvbp[0][3] = iyuvbp[1][3] = (BYTE *)(16 * curr->Stride() + 8);
				iyuvbp[0][4] = iyuvbp[1][4] = (BYTE *)0;
				iyuvbp[0][5] = iyuvbp[1][5] = (BYTE *)8;
				}
			}
		else
			{
			iyuvbp[0][0] = (BYTE *)yuvp[0][0];
			iyuvbp[0][1] = (BYTE *)yuvp[0][1];
			iyuvbp[0][2] = (BYTE *)yuvp[0][2];
			iyuvbp[0][3] = (BYTE *)yuvp[0][3];
			iyuvbp[0][4] = (BYTE *)yuvp[0][4];
			iyuvbp[0][5] = (BYTE *)yuvp[0][5];

			iyuvbd[0][0] = yuvd[0][0];
			iyuvbd[0][1] = yuvd[0][1];
			iyuvbd[0][2] = yuvd[0][2];

			iyuvbp[1][0] = (BYTE *)yuvp[1][0];
			iyuvbp[1][1] = (BYTE *)yuvp[1][1];
			iyuvbp[1][2] = (BYTE *)yuvp[1][2];
			iyuvbp[1][3] = (BYTE *)yuvp[1][3];
			iyuvbp[1][4] = (BYTE *)yuvp[1][4];
			iyuvbp[1][5] = (BYTE *)yuvp[1][5];

			iyuvbd[1][0] = yuvd[1][0];
			iyuvbd[1][1] = yuvd[1][1];
			iyuvbd[1][2] = yuvd[1][2];

			iyuvbpoffset[0] = 0;
			iyuvbpoffset[1] = 0;
			iyuvbpoffset[2] = 0;
			}

		__asm {pxor	mm0, mm0}

		return TRUE;
		}
	else
		return FALSE;
	}

QFastMMXSliceDecoder::QFastMMXSliceDecoder(VideoBitStream * bitStream, GenericMMXMotionComp * motionComp, GenericMMXMacroBlockIDCTDecoder * idctDecoder, GenericMMXYUVVideoConverter	*	yuvConverter)
	: GenericPackedIntraMMXSliceDecoder(bitStream, idctDecoder)
	{
	yuvp[0][0] = &(mby[0][0]);
	yuvp[0][1] = &(mby[0][8]);
	yuvp[0][2] = &(mby[8][0]);
	yuvp[0][3] = &(mby[8][8]);
	yuvp[0][4] = &(mbuv[0][0]);
	yuvp[0][5] = &(mbuv[0][8]);

	yuvd[0][0] = 32;
	yuvd[0][1] = 32;
	yuvd[0][2] = 32;

	yuvp[1][0] = &(mby[0][0]);
	yuvp[1][1] = &(mby[0][8]);
	yuvp[1][2] = &(mby[1][0]);
	yuvp[1][3] = &(mby[1][8]);
	yuvp[1][4] = &(mbuv[0][0]);
	yuvp[1][5] = &(mbuv[0][8]);

	yuvd[1][0] = 64;
	yuvd[1][1] = 32;
	yuvd[1][2] = 32;

	if (yuvConverter)
		this->yuvConverter = yuvConverter;
	else
		this->yuvConverter = new GenericMMXYUVVideoConverter();

	if (motionComp)
		this->motionComp = motionComp;
//	else
//		this->motionComp = new FastMMXMotionComp();
	}

QFastMMXSliceDecoder::~QFastMMXSliceDecoder(void)
	{
	delete motionComp;
	delete yuvConverter;
	}

FrameStore * QFastMMXSliceDecoder::AllocFrameStore(PictureCodingType type, bool stripeOptimized)
	{
#if !_DEBUG
	if (type == BIDIRECTIONAL_PREDICTIVE_CODED && vcs == VCS_MPEG_2 && stripeOptimized)
		return new FrameStore(yuvConverter, width, height, TRUE);
	else
#endif
		return new FrameStore(yuvConverter, width, height);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\FastMMXSliceDecoder.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef FASTMMXSLICEDECODER_H
#define FASTMMXSLICEDECODER_H

#include "GenericMMXSliceDecoder.h"
#include "GenericMMXMotionComp.h"

class QFastMMXSliceDecoder : public GenericPackedIntraMMXSliceDecoder
	{
	protected:
		int									motionVectorMask;

		MMXShort16							mby[16];
		MMXShort16							mbuv[8];

		BPTR									fbp, ifbp;
		int									fbstride;
		bool									needsFrameData;

		GenericMMXMotionComp			 * motionComp;
		GenericMMXYUVVideoConverter *	yuvConverter;

		void ClearBlocks(void);
		void MotionCompensation(int mx, int my, bool copyY, bool copyUV);
		void ParseIntraMacroblock(int mx, int my);

		bool AttemptDirectAccess(void);
		void DoneDirectAccess(void);
	public:
		QFastMMXSliceDecoder(VideoBitStream * bitStream,
			                  GenericMMXMotionComp * motionComp = NULL,
									GenericMMXMacroBlockIDCTDecoder * idctDecoder = NULL,
									GenericMMXYUVVideoConverter	*	yuvConverter = NULL);
		~QFastMMXSliceDecoder(void);

		bool BeginFrameDecoding(FrameStore * pred, FrameStore * succ, FrameStore * curr, PictureDisplayBuffer * display, bool hurryUp);

		SPUDisplayBuffer * CreateSPUDisplayBuffer(void) {return new FullWidthMMXSPUDisplayBuffer();}
		FrameStore * AllocFrameStore(PictureCodingType type, bool stripeOptimized);
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\LPCMDecoder\LPCMStreamParser.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGAudioDecoder\MPEGAudioTables.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef MPEGAUDIOTABLES_H
#define MPEGAUDIOTABLES_H

#pragma warning(disable : 4244 4305)

static const float LayerIIScaleFactors[64] =
	{
	2.00000000000000, 1.58740105196820, 1.25992104989487, 1.00000000000000,
	0.79370052598410, 0.62996052494744, 0.50000000000000, 0.39685026299205,
	0.31498026247372, 0.25000000000000, 0.19842513149602, 0.15749013123686,
	0.12500000000000, 0.09921256574801, 0.07874506561843, 0.06250000000000,
	0.04960628287401, 0.03937253280921, 0.03125000000000, 0.02480314143700,
	0.01968626640461, 0.01562500000000, 0.01240157071850, 0.00984313320230,
	0.00781250000000, 0.00620078535925, 0.00492156660115, 0.00390625000000,
	0.00310039267963, 0.00246078330058, 0.00195312500000, 0.00155019633981,
	0.00123039165029, 0.00097656250000, 0.00077509816991, 0.00061519582514,
	0.00048828125000, 0.00038754908495, 0.00030759791257, 0.00024414062500,
	0.00019377454248, 0.00015379895629, 0.00012207031250, 0.00009688727124,
	0.00007689947814, 0.00006103515625, 0.00004844363562, 0.00003844973907,
	0.00003051757813, 0.00002422181781, 0.00001922486954, 0.00001525878906,
	0.00001211090890, 0.00000961243477, 0.00000762939453, 0.00000605545445,
	0.00000480621738, 0.00000381469727, 0.00000302772723, 0.00000240310869,
	0.00000190734863, 0.00000151386361, 0.00000120155435, 0.00000000000000
	};

static const float LayerIIWindowFactors[512] =
	{
	 0.000000000, -0.000015259, -0.000015259, -0.000015259,
	-0.000015259, -0.000015259, -0.000015259, -0.000030518,
	-0.000030518, -0.000030518, -0.000030518, -0.000045776,
	-0.000045776, -0.000061035, -0.000061035, -0.000076294,

	-0.000076294, -0.000091553, -0.000106812, -0.000106812,
	-0.000122070, -0.000137329, -0.000152588, -0.000167847,
	-0.000198364, -0.000213623, -0.000244141, -0.000259399,
	-0.000289917, -0.000320435, -0.000366211, -0.000396729,

	-0.000442505, -0.000473022, -0.000534058, -0.000579834,
	-0.000625610, -0.000686646, -0.000747681, -0.000808716,
	-0.000885010, -0.000961304, -0.001037598, -0.001113892,
	-0.001205444, -0.001296997, -0.001388550, -0.001480103,

	-0.001586914, -0.001693726, -0.001785278, -0.001907349,
	-0.002014160, -0.002120972, -0.002243042, -0.002349854,
	-0.002456665, -0.002578735, -0.002685547, -0.002792358,
	-0.002899170, -0.002990723, -0.003082275, -0.003173828,

	 0.003250122,  0.003326416,  0.003387451,  0.003433228,
	 0.003463745,  0.003479004,  0.003479004,  0.003463745,
	 0.003417969,  0.003372192,  0.003280640,  0.003173828,
	 0.003051758,  0.002883911,  0.002700806,  0.002487183,

	 0.002227783,  0.001937866,  0.001617432,  0.001266479,
	 0.000869751,  0.000442505, -0.000030518, -0.000549316,
	-0.001098633, -0.001693726, -0.002334595, -0.003005981,
	-0.003723145, -0.004486084, -0.005294800, -0.006118774,

	-0.007003784, -0.007919312, -0.008865356, -0.009841919,
	-0.010848999, -0.011886597, -0.012939453, -0.014022827,
	-0.015121460, -0.016235352, -0.017349243, -0.018463135,
	-0.019577026, -0.020690918, -0.021789551, -0.022857666,

	-0.023910522, -0.024932861, -0.025909424, -0.026840210,
	-0.027725220, -0.028533936, -0.029281616, -0.029937744,
	-0.030532837, -0.031005859, -0.031387329, -0.031661987,
	-0.031814575, -0.031845093, -0.031738281, -0.031478882,

	 0.031082153,  0.030517578,  0.029785156,  0.028884888,
	 0.027801514,  0.026535034,  0.025085449,  0.023422241,
	 0.021575928,  0.019531250,  0.017257690,  0.014801025,
	 0.012115479,  0.009231567,  0.006134033,  0.002822876,

	-0.000686646, -0.004394531, -0.008316040, -0.012420654,
	-0.016708374, -0.021179199, -0.025817871, -0.030609131,
	-0.035552979, -0.040634155, -0.045837402, -0.051132202,
	-0.056533813, -0.061996460, -0.067520142, -0.073059082,

	-0.078628540, -0.084182739, -0.089706421, -0.095169067,
	-0.100540161, -0.105819702, -0.110946655, -0.115921021,
	-0.120697021, -0.125259399, -0.129562378, -0.133590698,
	-0.137298584, -0.140670776, -0.143676758, -0.146255493,

	-0.148422241, -0.150115967, -0.151306152, -0.151962280,
	-0.152069092, -0.151596069, -0.150497437, -0.148773193,
	-0.146362305, -0.143264771, -0.139450073, -0.134887695,
	-0.129577637, -0.123474121, -0.116577148, -0.108856201,

	 0.100311279,  0.090927124,  0.080688477,  0.069595337,
	 0.057617187,  0.044784546,  0.031082153,  0.016510010,
	 0.001068115, -0.015228271, -0.032379150, -0.050354004,
	-0.069168091, -0.088775635, -0.109161377, -0.130310059,

	-0.152206421, -0.174789429, -0.198059082, -0.221984863,
	-0.246505737, -0.271591187, -0.297210693, -0.323318481,
	-0.349868774, -0.376800537, -0.404083252, -0.431655884,
	-0.459472656, -0.487472534, -0.515609741, -0.543823242,

	-0.572036743, -0.600219727, -0.628295898, -0.656219482,
	-0.683914185, -0.711318970, -0.738372803, -0.765029907,
	-0.791213989, -0.816864014, -0.841949463, -0.866363525,
	-0.890090942, -0.913055420, -0.935195923, -0.956481934,

	-0.976852417, -0.996246338, -1.014617920, -1.031936646,
	-1.048156738, -1.063217163, -1.077117920, -1.089782715,
	-1.101211548, -1.111373901, -1.120223999, -1.127746582,
	-1.133926392, -1.138763428, -1.142211914, -1.144287109,

	 1.144989014,  1.144287109,  1.142211914,  1.138763428,
	 1.133926392,  1.127746582,  1.120223999,  1.111373901,
	 1.101211548,  1.089782715,  1.077117920,  1.063217163,
	 1.048156738,  1.031936646,  1.014617920,  0.996246338,

	 0.976852417,  0.956481934,  0.935195923,  0.913055420,
	 0.890090942,  0.866363525,  0.841949463,  0.816864014,
	 0.791213989,  0.765029907,  0.738372803,  0.711318970,
	 0.683914185,  0.656219482,  0.628295898,  0.600219727,

	 0.572036743,  0.543823242,  0.515609741,  0.487472534,
	 0.459472656,  0.431655884,  0.404083252,  0.376800537,
	 0.349868774,  0.323318481,  0.297210693,  0.271591187,
	 0.246505737,  0.221984863,  0.198059082,  0.174789429,

	 0.152206421,  0.130310059,  0.109161377,  0.088775635,
	 0.069168091,  0.050354004,  0.032379150,  0.015228271,
	-0.001068115, -0.016510010, -0.031082153, -0.044784546,
	-0.057617187, -0.069595337, -0.080688477, -0.090927124,

	 0.100311279,  0.108856201,  0.116577148,  0.123474121,
	 0.129577637,  0.134887695,  0.139450073,  0.143264771,
	 0.146362305,  0.148773193,  0.150497437,  0.151596069,
	 0.152069092,  0.151962280,  0.151306152,  0.150115967,

	 0.148422241,  0.146255493,  0.143676758,  0.140670776,
	 0.137298584,  0.133590698,  0.129562378,  0.125259399,
	 0.120697021,  0.115921021,  0.110946655,  0.105819702,
	 0.100540161,  0.095169067,  0.089706421,  0.084182739,

	 0.078628540,  0.073059082,  0.067520142,  0.061996460,
	 0.056533813,  0.051132202,  0.045837402,  0.040634155,
	 0.035552979,  0.030609131,  0.025817871,  0.021179199,
	 0.016708374,  0.012420654,  0.008316040,  0.004394531,

	 0.000686646, -0.002822876, -0.006134033, -0.009231567,
	-0.012115479, -0.014801025, -0.017257690, -0.019531250,
	-0.021575928, -0.023422241, -0.025085449, -0.026535034,
	-0.027801514, -0.028884888, -0.029785156, -0.030517578,

	 0.031082153,  0.031478882,  0.031738281,  0.031845093,
	 0.031814575,  0.031661987,  0.031387329,  0.031005859,
	 0.030532873,  0.029937744,  0.029281616,  0.028533936,
	 0.027725220,  0.026840210,  0.025909424,  0.024932861,

	 0.023910522,  0.022857666,  0.021789551,  0.020690918,
	 0.019577026,  0.018463135,  0.017349243,  0.016235352,
	 0.015121460,  0.014022827,  0.012939453,  0.011886597,
	 0.010848999,  0.009841919,  0.008865356,  0.007919312,

	 0.007003784,  0.006118774,  0.005294800,  0.004486084,
	 0.003723145,  0.003005981,  0.002334595,  0.001693726,
	 0.001098633,  0.000549316,  0.000030518, -0.000442505,
	-0.000869751, -0.001266479, -0.001617432, -0.001937866,

	-0.002227783, -0.002487183, -0.002700806, -0.002883911,
	-0.003051758, -0.003173828, -0.003280640, -0.003372192,
	-0.003417969, -0.003463745, -0.003479004, -0.003479004,
	-0.003463745, -0.003433228, -0.003387451, -0.003326416,

	 0.003250122,  0.003173828,  0.003082275,  0.002990723,
	 0.002899170,  0.002792358,  0.002685547,  0.002578735,
	 0.002456665,  0.002349854,  0.002243042,  0.002120972,
	 0.002014160,  0.001907349,  0.001785278,  0.001693726,

	 0.001586914,  0.001480103,  0.001388550,  0.001296997,
	 0.001205444,  0.001113892,  0.001037598,  0.000961304,
	 0.000885010,  0.000808716,  0.000747681,  0.000686646,
	 0.000625610,  0.000579834,  0.000534058,  0.000473022,

	 0.000442505,  0.000396729,  0.000366211,  0.000320435,
	 0.000289917,  0.000259399,  0.000244141,  0.000213623,
	 0.000198364,  0.000167847,  0.000152588,  0.000137329,
	 0.000122070,  0.000106812,  0.000106812,  0.000091553,

	 0.000076294,  0.000076294,  0.000061035,  0.000061035,
	 0.000045776,  0.000045776,  0.000030518,  0.000030518,
	 0.000030518,  0.000030518,  0.000015259,  0.000015259,
	 0.000015259,  0.000015259,  0.000015259,  0.000015259
	};

static const int LayerIIBalLut[3][11] =
	{
		{1, 2, 2, 0, 0, 0, 1, 1, 1, 1, 1},
		{0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0},
		{1, 3, 3, 0, 0, 0, 1, 1, 1, 1, 1}
	};

static const int LayerIIHalfBitrate[16] =
	{0, 0, 0, 0, 1, 0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0};


static const int LayerIINBalTab[4][32] =
	{
		{4, 4, 4, 4, 4, 4, 4, 4,
	 	 4, 4, 4, 3, 3, 3, 3, 3,
		 3, 3, 3, 3, 3, 3, 3, 2,
		 2, 2, 2, 0, 0, 0, 0, 0},
		{4, 4, 4, 4, 4, 4, 4, 4,
		 4, 4, 4, 3, 3, 3, 3, 3,
		 3, 3, 3, 3, 3, 3, 3, 2,
		 2, 2, 2, 2, 2, 2, 0, 0},
		{4, 4, 3, 3, 3, 3, 3, 3,
		 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0},
		{4, 4, 3, 3, 3, 3, 3, 3,
		 3, 3, 3, 3, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0}
	};

static const int LayerIISBLimit[4] = {27, 30, 8, 12};

static const int LayerIIBapTab[4][32][16] =
	{
		{
			{ 0,  1,  3,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17},
			{ 0,  1,  3,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17},
			{ 0,  1,  3,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17},
			{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 17},

			{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 17},
			{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 17},
			{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 17},
			{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 17},

			{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 17},
			{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 17},
			{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 17},
			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2, 17,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  1,  2, 17,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2, 17,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2, 17,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0}
		},

		{
			{ 0,  1,  3,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17},
			{ 0,  1,  3,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17},
			{ 0,  1,  3,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17},
			{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 17},

			{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 17},
			{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 17},
			{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 17},
			{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 17},

			{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 17},
			{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 17},
			{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 17},
			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  3,  4,  5,  6, 17,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2, 17,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  1,  2, 17,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2, 17,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2, 17,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2, 17,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  1,  2, 17,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2, 17,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0}
		},

		{
			{ 0,  1,  2,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16},
			{ 0,  1,  2,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16},
			{ 0,  1,  2,  4,  5,  6,  7,  8,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  4,  5,  6,  7,  8,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  1,  2,  4,  5,  6,  7,  8,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  4,  5,  6,  7,  8,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  4,  5,  6,  7,  8,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  4,  5,  6,  7,  8,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0}
		},

		{
			{ 0,  1,  2,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16},
			{ 0,  1,  2,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16},
			{ 0,  1,  2,  4,  5,  6,  7,  8,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  4,  5,  6,  7,  8,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  1,  2,  4,  5,  6,  7,  8,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  4,  5,  6,  7,  8,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  4,  5,  6,  7,  8,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  4,  5,  6,  7,  8,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  1,  2,  4,  5,  6,  7,  8,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  4,  5,  6,  7,  8,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  4,  5,  6,  7,  8,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  1,  2,  4,  5,  6,  7,  8,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},


			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},

			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
			{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0}
		}
	};

#pragma warning(default : 4244 4305)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\GenericMMXMacroBlockIDCTDecoder.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef GENERICMMXMACROBLOCKIDCTDECODER_H
#define GENERICMMXMACROBLOCKIDCTDECODER_H

#include "SliceParser.h"
#include "IDCTTables.h"

extern MMXShort8	tmmxf[32];

class GenericMMXMacroBlockIDCTDecoder
	{
	protected:
		VideoBitStream		*	bitStream;

		bool						hurryUp;
		HuffmanTable		*	splitIntraDCTable[3];

		DCTMulTable			*	dctMulTable[3];

		VideoCodingStandard	vcs;
		int						intraDCPrecision;
		HuffmanTable		*	intraNonDCTable;

	protected:

		void InverseDCT(short * mb, int stride, DCTMulTable * table, int numLines, int numColumns);
		void InverseBYTEIntraDCT(BYTE * mb, int stride, DCTMulTable * table, int numLines, int numColumns);

		int ParseIntraBlockMatrix(int yuvType, int & dcPredictor, int * matrix);
		int ParseNonIntraBlockMatrix(int * matrix);

	public:
		GenericMMXMacroBlockIDCTDecoder(void);
		virtual ~GenericMMXMacroBlockIDCTDecoder(void);

		virtual void ParseIntraBlock(int num, int yuvType, int & dcPredictor, int * matrix, short * mb, int stride);
		virtual void ParseNonIntraBlock(int num, int yuvType, int * matrix, short * mb, int stride);
		virtual void ParseNonIntraBlocks(int codedBlockPattern, short ** yuvp, int * yuvd, int * matrix, int * offset);
		virtual void ParseBaseNonIntraBlocks(int codedBlockPattern, short * yuvbp, int * yuvbo, int * yuvd, int * matrix);

		virtual void ParseBYTEIntraBlock(int num, int yuvType, int & dcPredictor, int * matrix, BYTE * mb, int stride);

		void SetBitStream(VideoBitStream * bitStream) {this->bitStream = bitStream;}

		void SetDCTMulTable(DCTMulTable * lumaDCTMulTable, DCTMulTable * chromaDCTMulTable)
			{
			dctMulTable[0] = lumaDCTMulTable;
			dctMulTable[1] = chromaDCTMulTable;
			dctMulTable[2] = chromaDCTMulTable;
			}

		void SetPictureParameters(bool hurryUp,
										  VideoCodingStandard vcs,
										  int intraDCPrecision,
		                          HuffmanTable * intraNonDCTable);
	};

class GenericXMMXMacroBlockIDCTDecoder : public GenericMMXMacroBlockIDCTDecoder
	{
	protected:
		void InverseDCT(short * mb, int stride, DCTMulTable * table, int numLines, int numColumns);
		void InverseBYTEIntraDCT(BYTE * mb, int stride, DCTMulTable * table, int numLines, int numColumns);

	public:
		GenericXMMXMacroBlockIDCTDecoder(void);

		void ParseIntraBlock(int num, int yuvType, int & dcPredictor, int * matrix, short * mb, int stride);
		void ParseNonIntraBlock(int num, int yuvType, int * matrix, short * mb, int stride);
		void ParseNonIntraBlocks(int codedBlockPattern, short ** yuvp, int * yuvd, int * matrix, int * offset);
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\GenericMMXSliceDecoder.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "GenericMMXSliceDecoder.h"
#include "library\common\vddebug.h"

#pragma warning (disable : 4799)

MMXShort8	tmmxf[32];

////////////////////////////////////////////////////////////////////
//
//  Generic MMX Slice Decoder
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

GenericMMXSliceDecoder::GenericMMXSliceDecoder(VideoBitStream * bitStream, GenericMMXMacroBlockIDCTDecoder * idctDecoder)
	: SliceParser(bitStream)
	{
	static unsigned char translate[8] = {0, 4, 2, 6, 1, 5, 3, 7};
	unsigned char v, u;

	int i, j;

	for(i=0; i<2; i++)
		{
		for(j=0; j<64; j++)
			{
			u = InverseScanTable[i][j];
			u = ((u >> 3) | (u << 3)) & 0x3f;
			v = (u & ~7) | translate[u & 7];
			AlternateInverseScanTable[i][j] = v;
			AlternateInverseScanTableX[i][j] = ((unsigned short)v << 8) | ((u & 7) + 1);
			}
		}

	inverseScanTable[0] = &(AlternateInverseScanTable[0][0]);
	inverseScanTable[1] = &(AlternateInverseScanTable[1][0]);

	if (idctDecoder)
		this->idctDecoder = idctDecoder;
	else
		this->idctDecoder = new GenericMMXMacroBlockIDCTDecoder();

	this->idctDecoder->SetBitStream(bitStream);

	xbrightness = 128;
	xubrightness = 128;
	xvbrightness = 128;
	contrast = 128;
	saturation = 128;

	__asm {emms}

	lumaDCTMulTable.CalculateTable(contrast);
	chromaDCTMulTable.CalculateTable(saturation);

	this->idctDecoder->SetDCTMulTable(&lumaDCTMulTable, &chromaDCTMulTable);
	}

//
//  Destructor
//

GenericMMXSliceDecoder::~GenericMMXSliceDecoder(void)
	{
	delete idctDecoder;
	}

//
//  Begin Frame Decoding
//

bool GenericMMXSliceDecoder::BeginFrameDecoding(FrameStore * pred, FrameStore * succ, FrameStore * curr, PictureDisplayBuffer * display, bool hurryUp)
	{
	this->hurryUp = hurryUp && pictureCodingType == BIDIRECTIONAL_PREDICTIVE_CODED;

	if (this->hurryUp)
		{
		if (PF_ALTERNATE_SCAN(pictureFlags))
			orgQuant[1] = orgQuantX[1][1][1];
		else
			orgQuant[1] = orgQuantX[1][0][1];
		}

	idctDecoder->SetPictureParameters(this->hurryUp, vcs, intraDCPrecision, intraNonDCTable);

	lastIntraQuantScaleCode[0] = -1;
	lastIntraQuantScaleCode[1] = -1;
	lastIntraQuantScaleCode[2] = -1;
	lastIntraQuantScaleCode[3] = -1;
	lastNonIntraQuantScaleCode[0] = -1;
	lastNonIntraQuantScaleCode[1] = -1;
	lastNonIntraQuantScaleCode[2] = -1;
	lastNonIntraQuantScaleCode[3] = -1;

	memclr128(tmmxf);

	curr->SetPrecision(8);
	if (SliceParser::BeginFrameDecoding(pred, succ, curr, display, this->hurryUp))
		{
		__asm {pxor	mm0, mm0}

		return TRUE;
		}
	else
		return FALSE;
	}

//
//  Done Frame Decoding
//

void GenericMMXSliceDecoder::DoneFrameDecoding(void)
	{
	SliceParser::DoneFrameDecoding();

	__asm {emms}
	}

void GenericMMXSliceDecoder::BeginSecondFieldDecoding(void)
	{
	idctDecoder->SetPictureParameters(this->hurryUp, vcs, intraDCPrecision, intraNonDCTable);

	SliceParser::BeginSecondFieldDecoding();
	}

//
//  Set Brightness
//

void GenericMMXSliceDecoder::SetBrightness(int brightness, int uBrightness, int vBrightness)
	{
	xbrightness = brightness;
	xubrightness = uBrightness;
	xvbrightness = vBrightness;

	SliceParser::SetBrightness(xbrightness + 64*128 / contrast - 64,
		                        xubrightness + 16384 / saturation - 128,
										xvbrightness + 16384 / saturation - 128);
	}

//
//  Set Contrast
//

void GenericMMXSliceDecoder::SetContrast(int contrast)
	{
	this->contrast = contrast;
	lumaDCTMulTable.CalculateTable(contrast);

	SetBrightness(xbrightness, xubrightness, xvbrightness);
	}

//
//  Set Saturation
//

void GenericMMXSliceDecoder::SetSaturation(int saturation)
	{
	this->saturation = saturation;
	chromaDCTMulTable.CalculateTable(saturation);

	SetBrightness(xbrightness, xubrightness, xvbrightness);
	}

//
//  Calculate Quantizer Matrix
//

static inline void CalcQuantMatrix(int quant, int * dst, unsigned short * src, unsigned short * scan)
	{
	__asm
		{
		movd			mm0, [quant]

		punpcklwd	mm0, mm0
		mov			eax, [src]

		punpckldq	mm0, mm0
		mov			ecx, 0

		mov			edx, [dst]
		mov			ebx, [scan]
loop1:
		movq			mm1, [eax+ecx]
		cmp			ecx, 128 - 16

		movq			mm4, [eax+8+ecx]
		pmullw		mm1, mm0

		movq			mm3, [ebx+ecx]
		pmullw		mm4, mm0

		movq			mm6, [ebx+8+ecx]

		paddb			mm3, mm3
		paddb			mm6, mm6

		movq			mm2, mm1
		punpcklwd	mm1, mm3

		punpckhwd	mm2, mm3
		movq			mm5, mm4

		movq			[edx+2*ecx], mm1
		punpcklwd	mm4, mm6

		movq			[edx+8+2*ecx], mm2
		punpckhwd	mm5, mm6

		movq			[edx+16+2*ecx], mm4

		movq			[edx+24+2*ecx], mm5

		lea			ecx, [ecx + 16]
		jne			loop1
		}
	}

//
//  Parse Intra Block
//

void GenericMMXSliceDecoder::ParseIntraBlock(int num, int yuvType)
	{
	int * matrix;

	matrix = intraQuant[quantizerScaleCode & 3];
	if (quantizerScaleCode != lastIntraQuantScaleCode[quantizerScaleCode & 3])
		{
		lastIntraQuantScaleCode[quantizerScaleCode & 3] = quantizerScaleCode;

		CalcQuantMatrix(quantizerScaleValue, matrix, orgQuant[0], scanTableX);
		}

	idctDecoder->ParseIntraBlock(num, yuvType, dcPredictor[yuvType], matrix, yuvp[dctType][num], yuvd[dctType][yuvType]);
	}

//
//  Parse Intra Blocks
//

void GenericMMXSliceDecoder::ParseIntraBlocks(void)
	{
	int i, t;
	static char tp[] = {0, 0, 0, 0, 1, 2};
	int * matrix;

	matrix = intraQuant[quantizerScaleCode & 3];
	if (quantizerScaleCode != lastIntraQuantScaleCode[quantizerScaleCode & 3])
		{
		lastIntraQuantScaleCode[quantizerScaleCode & 3] = quantizerScaleCode;

		CalcQuantMatrix(quantizerScaleValue, matrix, orgQuant[0], scanTableX);
		}

	for(i=0; i<6; i++)
		{
		t = tp[i];
		idctDecoder->ParseIntraBlock(i, t, dcPredictor[t], matrix, yuvp[dctType][i], yuvd[dctType][t]);
		}
	}

//
//  Parse Non Intra Block
//

void GenericMMXSliceDecoder::ParseNonIntraBlock(int num, int yuvType)
	{
	int * matrix;

	matrix = nonIntraQuant[quantizerScaleCode & 3];

	if (quantizerScaleCode != lastNonIntraQuantScaleCode[quantizerScaleCode & 3])
		{
		lastNonIntraQuantScaleCode[quantizerScaleCode & 3] = quantizerScaleCode;

		CalcQuantMatrix(quantizerScaleValue, matrix, orgQuant[1], scanTableX);
		}

	idctDecoder->ParseNonIntraBlock(num, yuvType, matrix, yuvp[dctType][num], yuvd[dctType][yuvType]);
	}

static inline int DIV2(int x)
	{
	return (x - (x >> 31)) >> 1;
	}
//
//  Parse Non Intra Blocks
//

void GenericMMXSliceDecoder::ParseNonIntraBlocks(void)
	{
	int * matrix;
	int offset[3];

	matrix = nonIntraQuant[quantizerScaleCode & 3];

	if (quantizerScaleCode != lastNonIntraQuantScaleCode[quantizerScaleCode & 3])
		{
		lastNonIntraQuantScaleCode[quantizerScaleCode & 3] = quantizerScaleCode;

		CalcQuantMatrix(quantizerScaleValue, matrix, orgQuant[1], scanTableX);
		}

	if ((vectors[0][0][0] & 1) && (vectors[0][0][1] & 1))
		offset[0] = -3;
	else
		offset[0] = 0;

	if ((DIV2(vectors[0][0][0]) & 1) && (DIV2(vectors[0][0][1]) & 1))
		offset[1] = offset[2] = -3;
	else
		offset[1] = offset[2] = 0;

	idctDecoder->ParseNonIntraBlocks(codedBlockPattern, yuvp[dctType], yuvd[dctType], matrix, offset);
	}

//
//  Parse Pattern Macroblock
//

void GenericMMXSliceDecoder::ParsePatternMacroblock(int mx, int my)
	{
	CalcMotionComponents();

	ClearBlocks();

	ParseNonIntraBlocks();

	MotionCompensation(mx, my, (codedBlockPattern & 0x3c) == 0, (codedBlockPattern & 0x03) == 0);
	}

//
//  Set Quantizer Scale Code
//

void GenericMMXSliceDecoder::SetQuantScaleCode(int code)
	{
	SliceParser::SetQuantScaleCode(code);

	if (!PF_Q_SCALE_TYPE(pictureFlags))
		quantizerScaleValue = QuantizerScale[0][quantizerScaleCode];
	else
		quantizerScaleValue = QuantizerScale[1][quantizerScaleCode];
	}

static const int scantrans[64] =
	{
	 0,  4,  1,  2,  5,  6, 20,  7,
	 8,  3, 10,  9, 19, 21, 22, 36,
	23, 24, 18, 17, 11, 12, 16, 26,
	25, 34, 37, 38, 52, 39, 40, 35,
	30, 27, 15, 13, 14, 28, 31, 42,
	41, 50, 53, 54, 51, 46, 43, 32,
	29, 33, 44, 47, 56, 55, 60, 57,
	48, 45, 49, 58, 61, 62, 59, 63
	};

//
//  Set Quantiation Matrix
//

void GenericMMXSliceDecoder::SetQuantMatrix(QuantMatrices type, const QuantizationMatrix & matrix)
	{
	int i;

	if (type < 2)
		{
		for(i=0; i<64; i++)
			{
			orgQuantX[0][0][type][i] = (BYTE)matrix[i];
			orgQuantX[0][1][type][scantrans[i]] = (BYTE)matrix[i];
			if (((InverseScanTable[0][i] & 7) >= 4) ||
				 ( InverseScanTable[0][i]      >= 32))
				{
				orgQuantX[1][0][type][i] = 0;
				}
			else
				{
				orgQuantX[1][0][type][i] = (BYTE)matrix[i];
				}
			orgQuantX[1][1][type][scantrans[i]] = (BYTE)matrix[i];
			}
		}

	lastIntraQuantScaleCode[0] = -1;
	lastIntraQuantScaleCode[1] = -1;
	lastIntraQuantScaleCode[2] = -1;
	lastIntraQuantScaleCode[3] = -1;
	lastNonIntraQuantScaleCode[0] = -1;
	lastNonIntraQuantScaleCode[1] = -1;
	lastNonIntraQuantScaleCode[2] = -1;
	lastNonIntraQuantScaleCode[3] = -1;
	}

//
//  Oops
//

unsigned char	GenericMMXSliceDecoder::AlternateInverseScanTable[2][64];
unsigned short	GenericMMXSliceDecoder::AlternateInverseScanTableX[2][64];

//
//  Set Picture Parameters
//

void GenericMMXSliceDecoder::SetPictureParameters(BYTE intraDCPrecision,
		                                            PictureStructure pictureStructure,
								                          BYTE pictureFlags)
	{
	SliceParser::SetPictureParameters(intraDCPrecision, pictureStructure, pictureFlags);

	if (PF_ALTERNATE_SCAN(pictureFlags))
		{
		scanTableX = AlternateInverseScanTableX[1];
		orgQuant[0] = orgQuantX[0][1][0];
		orgQuant[1] = orgQuantX[0][1][1];
		}
	else
		{
		scanTableX = AlternateInverseScanTableX[0];
		orgQuant[0] = orgQuantX[0][0][0];
		orgQuant[1] = orgQuantX[0][0][1];
		}
	}

////////////////////////////////////////////////////////////////////
//
//  Generic Packed Intra MMX Slice Decoder
//
////////////////////////////////////////////////////////////////////

//
//  Parse Intra Block
//

void GenericPackedIntraMMXSliceDecoder::ParseIntraBlock(int num, int yuvType)
	{
	int * matrix;

	matrix = intraQuant[quantizerScaleCode & 3];
	if (quantizerScaleCode != lastIntraQuantScaleCode[quantizerScaleCode & 3])
		{
		lastIntraQuantScaleCode[quantizerScaleCode & 3] = quantizerScaleCode;

		CalcQuantMatrix(quantizerScaleValue, matrix, orgQuant[0], scanTableX);
		}

	idctDecoder->ParseBYTEIntraBlock(num, yuvType, dcPredictor[yuvType], matrix, iyuvbp[dctType][num] + iyuvbpoffset[yuvType], iyuvbd[dctType][yuvType]);
	}

//
//  Parse Intra Blocks
//

void GenericPackedIntraMMXSliceDecoder::ParseIntraBlocks(void)
	{
	int i, t;
	static char tp[] = {0, 0, 0, 0, 1, 2};
	int * matrix;

	matrix = intraQuant[quantizerScaleCode & 3];
	if (quantizerScaleCode != lastIntraQuantScaleCode[quantizerScaleCode & 3])
		{
		lastIntraQuantScaleCode[quantizerScaleCode & 3] = quantizerScaleCode;

		CalcQuantMatrix(quantizerScaleValue, matrix, orgQuant[0], scanTableX);
		}

	for(i=0; i<6; i++)
		{
		t = tp[i];
		idctDecoder->ParseBYTEIntraBlock(i, t, dcPredictor[t], matrix, iyuvbp[dctType][i] + iyuvbpoffset[t], iyuvbd[dctType][t]);
		}
	}

//
//  Constructor
//

GenericPackedIntraMMXSliceDecoder::GenericPackedIntraMMXSliceDecoder(VideoBitStream * bitStream, GenericMMXMacroBlockIDCTDecoder * idctDecoder)
	: GenericMMXSliceDecoder(bitStream, idctDecoder)
	{
	iyuvbpoffset[0] = 0;
	iyuvbpoffset[1] = 0;
	iyuvbpoffset[2] = 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\GenericMMXSliceDecoder.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef GENERICMMXSLICEDECODER_H
#define GENERICMMXSLICEDECODER_H

#include "SliceParser.h"
#include "IDCTTables.h"
#include "GenericMMXMacroBlockIDCTDecoder.h"

extern MMXShort8	tmmxf[32];

//
//  The mother of all slice decoders
//

class GenericMMXSliceDecoder : public SliceParser
	{
	protected:
		static unsigned char		AlternateInverseScanTable[2][64];
		static unsigned short	AlternateInverseScanTableX[2][64];

		PadOnQWord				pad00;

		int						intraQuant[4][64];
		int						nonIntraQuant[4][64];

		unsigned short			orgQuantX[2][2][2][64];
		unsigned short		*	orgQuant[2];

		int						lastIntraQuantScaleCode[4];
		int						lastNonIntraQuantScaleCode[4];

		bool						hurryUp;

		short					*	yuvp[2][8];
		int						yuvd[2][4];

		int						quantizerScaleValue;
		unsigned short		*	scanTableX;

		int						numFColumns;

		PadOnQWord				pad01;

		DCTMulTable				lumaDCTMulTable, chromaDCTMulTable;

		int						contrast;
		int						saturation;
		int						xbrightness, xubrightness, xvbrightness;

		GenericMMXMacroBlockIDCTDecoder * idctDecoder;
	public:
		GenericMMXSliceDecoder(VideoBitStream * bitStream, GenericMMXMacroBlockIDCTDecoder * idctDecoder = NULL);
		~GenericMMXSliceDecoder(void);

		bool BeginFrameDecoding(FrameStore * pred, FrameStore * succ, FrameStore * curr, PictureDisplayBuffer * display, bool hurryUp);
		void DoneFrameDecoding(void);

		void BeginSecondFieldDecoding(void);

		void SetBrightness(int brightness, int uBrightness, int vBrightness);
		void SetContrast(int contrast);
		void SetSaturation(int saturation);

		void ParseIntraBlock(int num, int yuvType);
		virtual void ParseIntraBlocks(void);

		void ParseNonIntraBlock(int num, int yuvType);
		virtual void ParseNonIntraBlocks(void);
		void ParsePatternMacroblock(int mx, int my);

		void SetQuantScaleCode(int code);
		void SetQuantMatrix(QuantMatrices type, const QuantizationMatrix & matrix);

		void SetPictureParameters(BYTE intraDCPrecision,
		                          PictureStructure pictureStructure,
									  	  BYTE pictureFlags);


		void SetBitStream(VideoBitStream * bitStream) {this->bitStream = bitStream; idctDecoder->SetBitStream(bitStream);}
	};

//
//  Generic Packed Intra MMX Slice Decoder
//

class GenericPackedIntraMMXSliceDecoder : public GenericMMXSliceDecoder
	{
	protected:
		BYTE					*	iyuvbp[2][8];
		int						iyuvbd[2][4];
		int						iyuvbpoffset[4];
	public:
		GenericPackedIntraMMXSliceDecoder(VideoBitStream * bitStream, GenericMMXMacroBlockIDCTDecoder * idctDecoder = NULL);

		void ParseIntraBlock(int num, int yuvType);
		void ParseIntraBlocks(void);
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\Huffdec.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#include "huffdec.h"


HuffmanTable::HuffmanTable(void)
	{
	root = new HuffEntry;
	}

HuffmanTable::HuffmanTable(HuffInit * init)
	{
	root = new HuffEntry;

	if (init)
		{
		while (init->str)
			{
			AddEntry(init->str, init->val);
			init++;
			}

		BuildXTable();
		}
	}

HuffmanTable::~HuffmanTable(void)
	{
	if (root) delete root;
	}

void HuffmanTable::AddEntry(const char * str, long val)
	{
	char c;
	HuffEntry * e = root;
	bool append = FALSE;

	while (c = *str++)
		{
		if (e->final)
			throw ObjectInUse();
		else if (c == '0')
			{
			if (!e->zero)
      		e->zero = new HuffEntry;
      	e = e->zero;
			}
		else if (c == '1')
			{
			if (!e->one)
      		e->one = new HuffEntry;
      	e = e->one;
			}
		else if (c == 'x')
			append = TRUE;
		else
			throw RangeViolation();
		}

	if (e->one || e->zero)
		throw ObjectInUse();

	e->final = TRUE;
	e->append = append;

	e->val = val;
	}

void HuffmanTable::BuildXRest(HuffXEntry * xentry, HuffEntry * entry, int predepth)
	{
	int i, j, k;
	HuffEntry * e;


	for(i=0; i<HUFF_PARTITION_SIZE; i++)
		{
		e = entry;
		j = i;
		k = 0;

		while (k < HUFF_PARTITION_BITS && e && !e->final)
			{
			if (j & (1 << (HUFF_PARTITION_BITS - 1)))
				e = e->one;
			else
				e = e->zero;
			j <<= 1;
			k++;
			}

		if (e)
			{
			if (e->final)
				{
				if (e->append) k++;

				xentry[i].u.val = (e->val << 8) | ((predepth + k) << 1) | 1;
				}
			else
				{
				xentry[i].u.sub = new HuffXEntry[HUFF_PARTITION_SIZE];
				BuildXRest(xentry[i].u.sub, e, predepth + HUFF_PARTITION_BITS);
				}
			}
		else
			xentry[i].u.val = 0;
		}
	}

void HuffmanTable::SecureXRest(HuffXEntry * xentry)
	{
	int i;

	for(i=0; i<HUFF_PARTITION_SIZE; i++)
		{
		if (!xentry[i].u.val)
			xentry[i].u.sub = xentry;
		else if (!(xentry[i].u.val & 1) && xentry[i].u.sub != xentry)
			SecureXRest(xentry[i].u.sub);
		}
	}

HuffmanTable::HuffXEntry * HuffmanTable::MergeXRest(HuffXEntry * me, HuffXEntry * with)
	{
	int i;

	if (me && with)
		{
		for(i=0; i<HUFF_PARTITION_SIZE; i++)
			{
			if (!(me[i].u.val & 1) && !(with[i].u.val & 1))
				me[i].u.sub = MergeXRest(me[i].u.sub, with[i].u.sub);

			if (me[i].u.val != with[i].u.val) return me;
			}

		return with;
		}
	else
		return me;
	}

void HuffmanTable::BuildXTable(void)
	{
	BuildXRest(xroot, root, 0);

	delete root;
	root = NULL;
	}

void HuffmanTable::Merge(HuffmanTable & table)
	{
	int i;

	for(i=0; i<HUFF_PARTITION_SIZE; i++)
		{
		if (!(      xroot[i].u.val & 1) &&
			 !(table.xroot[i].u.val & 1))
			xroot[i].u.sub = MergeXRest(xroot[i].u.sub, table.xroot[i].u.sub);
		}
	}

void HuffmanTable::Secure(void)
	{
	SecureXRest(xroot);
	}

void HuffmanTable::PrepareByteTable(int add)
	{
	int i, v;

	for(i=0; i<256; i++)
		{
		v = xroot[i].u.val;
		v = (v & 0xffffff00) | (((v & 0xff) >> 1) + add);
		xroot[i].u.val = v;
		}
	}

void HuffmanTable::BuildExtPatternTable(void)
	{
	int i;
	int v, d, s;

	for(i=0; i<128+32; i++)
		extPatternTable[i] = 0x00000000;

	for(i=4; i<256; i++)
		{
		v = xroot[i].u.val;
		s = (v & 0xff) >> 1;
		d = v >> 8;
		if (i & 0xc0)
			{
			extPatternTable[i >> 3] = d | ((s - 3) << 6);
			}
		else
			{
			extPatternTable[(i << 1)     + 32] = d | ((s - 6) << 6);
			extPatternTable[(i << 1) + 1 + 32] = d | ((s - 6) << 6);
			}
		}
	for(i=2; i<8; i++)
		{
		v = xroot[i >> 1].u.sub[(i & 1) << 7].u.val;
		s = (v & 0xff) >> 1;
		d = v >> 8;
		extPatternTable[i + 32] = d | ((s - 6) << 6);
		}

	}

void HuffmanTable::BuildExtDCTTable(void)
	{
	int i, j, k, l, b;
	long v, w;
	HuffXEntry * e;

//	extDCTTable = new unsigned long[0x407];
//	extDCTTable += ((32 - ((int)extDCTTable & 31)) & 31) >> 2;
//	extNIDCTTable = new unsigned long[0x407];
//	extNIDCTTable += ((32 - ((int)extNIDCTTable & 31)) & 31) >> 2;

	for(i=0; i<0x400; i++)
		{
		extDCTTable[i] = 0x00000000;
		extNIDCTTable[i] = 0x00000000;
		}

	for(i=0; i<0x200; i++)
		extNIDCTTable2[i] = 0x0000;

	for(i = 8; i < 512; i++)
		{
		v = xroot[i >> 1].u.val;

		if ((v >> 8) == -1)
			{
			extDCTTable[i] = 0;
			extNIDCTTable[i] = 0;
			extNIDCTTable2[i] = 0;
			}
		else if ((v >> 8) == -2)
			{
			extDCTTable[i] = (v & 0xff) >> 1 << 16;
			extNIDCTTable[i] = (v & 0xff) >> 1 << 16;
			extNIDCTTable2[i] = (unsigned short) ( (v & 0xff) >> 1 << 12 );
			}
		else
			{
			l = (v & 0x000000ff) >> 1;
			k = (v >> 20) + 1;
			j = (v & 0x000fff00) >> 8;
			v = k | (l << 16) | (j << 4);
			w = (k << 16) | l | (j << 5) | 16;
//			w = k | (l << 16) | (j << 5) | 16;

			if (i & (512 >> l))
				{
				v = (v ^ 0x0000fff0) + 0x00000010;
				w = (w ^ 0x0000fff0) + 0x00000010;
				}

			extDCTTable[i] = v;
			extNIDCTTable[i] = w;

			extNIDCTTable2[i] = (unsigned short) ( (w & 0x0f) | (w >> 16 << 12) | (w & 0x0ff0) );
			}
		}

	for(j = 0; j < 4; j++)
		{
		e = xroot[j].u.sub;

		for(i = 0; i < 512; i++)
			{
			v = e[i >> 1].u.val;
			if (v)
				{
				l = (v & 0x000000ff) >> 1;
				k = (v >> 20) + 1;
				v = (v & 0x000fff00) >> 8;

				b = (j << 9) | i;

				w = (l - 8) | (v << 5) | (k << 16) | 16;
				v = (l - 8) | (v << 4) | (k << 16);

				if (b & (1 << (17-l)))
					{
					v = (v ^ 0x0000fff0) + 0x00000010;
					w = (w ^ 0x0000fff0) + 0x00000010;
					}

				if (l <= 14)
					{
					extDCTTable[0x200 + (b >> 3)] = v;
					extNIDCTTable[0x200 + (b >> 3)] = w;
					}
				else
					{
					extDCTTable[0x300 + b] = v;
					extNIDCTTable[0x300 + b] = w;
					}
				}
			}
		}
	}

void HuffmanTable::BuildFlatDCTTable(void)
	{
	int i, j, k, l, b;
	long v, w;
	HuffXEntry * e;

	flatDCTTable = new unsigned long[0x407];
	flatDCTTable += ((32 - ((int)flatDCTTable & 31)) & 31) >> 2;
	flatNIDCTTable = new unsigned long[0x407];
	flatNIDCTTable += ((32 - ((int)flatNIDCTTable & 31)) & 31) >> 2;

	for(i=0; i<0x400; i++)
		{
		flatDCTTable[i] = 0x00000040;
		flatNIDCTTable[i] = 0x00000040;
		}

	for(i = 8; i < 512; i++)
		{
		v = xroot[i >> 1].u.val;

		if ((v >> 8) == -1)
			{
			flatDCTTable[i]   = 0x40;
			flatNIDCTTable[i] = 0x40;
			}
		else if ((v >> 8) == -2)
			{
			flatDCTTable[i]   = ((v & 0xff) >> 1 << 8) | 0x80;
			flatNIDCTTable[i] = ((v & 0xff) >> 1 << 8) | 0x80;
			}
		else
			{
			l = (v & 0x000000ff) >> 1;		// size in bits
			k = (v >> 20);						// run 0..63
			j = (v & 0x000fff00) >> 8;		// level

			v = k | (l << 8) | (j << 17);
			w = k | (l << 8) | (j << 17) | 0x00010000;

			if (i & (512 >> l))
				{
				v = (v ^ 0xffff0000) + 0x00010000;
				w = (w ^ 0xffff0000) + 0x00010000;
				}

			flatDCTTable[i] = v;
			flatNIDCTTable[i] = w;
			}
		}

	for(j = 0; j < 4; j++)
		{
		e = xroot[j].u.sub;

		for(i = 0; i < 512; i++)
			{
			v = e[i >> 1].u.val;
			if (v)
				{
				l = (v & 0x000000ff) >> 1;		// size in bits
				k = (v >> 20);						// run 0..63
				v = (v & 0x000fff00) >> 8;		// level

				w = k | (l << 8) | (v << 17) | 0x00010000;
				v = k | (l << 8) | (v << 17);

				b = (j << 9) | i;

				if (b & (1 << (17-l)))
					{
					v = (v ^ 0xffff0000) + 0x00010000;
					w = (w ^ 0xffff0000) + 0x00010000;
					}

				if (l <= 14)
					{
					flatDCTTable  [0x200 + (b >> 3)] = v;
					flatNIDCTTable[0x200 + (b >> 3)] = w;
					}
				else
					{
					flatDCTTable  [0x300 + b] = v;
					flatNIDCTTable[0x300 + b] = w;
					}
				}
			}
		}
	}

DWORD VideoStreamBuffer[VIDEO_STREAM_BUFFER_SIZE+8];
int	BSBits;

VideoBitStream::VideoBitStream(StreamFlipCopy * streamFlipCopy)
	: BitStream(VideoStreamBuffer, VIDEO_STREAM_BUFFER_SIZE, BSBits, streamFlipCopy)
	{
	sequenceEndFound = FALSE;
	}

VideoBitStream::~VideoBitStream(void)
	{
	}

void VideoBitStream::NextStartCode(void)
	{
	int d, num;

	ByteAllign();

	RefillBuffer(4096 * 8);
	num = AvailBits();
	while (num >= 32)
		{
		if (num > 4096 * 8) num = 4096 * 8;
		while (num >= 32)
			{
			d = Peek();

			if ((d & 0xffffff00) == 0x00000100) return;

			if ((d & 0x000000ff) > 1)
				{
				Advance(32); num -= 32;
				}
			else
				{
				Advance(8); num -= 8;
				}
			}
		RefillBuffer(4096 * 8);
		num = AvailBits();
		}

	Advance(num);
	}

int VideoBitStream::AddData(BYTE * ptr, int num)
	{
	int done = BitStream::AddData(ptr, num);

	if (done > 4)
		{
		if (done == num && ptr[num-4] == 0x00 && ptr[num-3] == 0x00 &&
		                   ptr[num-2] == 0x01 && ptr[num-1] == 0xb7)
			sequenceEndFound = TRUE;
		}
	else if (done)
		sequenceEndFound = FALSE;

	return done;
	}

bool VideoBitStream::RefillBuffer(int requestBits, bool lowDataPanic)
	{
	if (sequenceEndFound)
		return BitStream::RefillBuffer(32, lowDataPanic);
	else
		return BitStream::RefillBuffer(requestBits, lowDataPanic);
	}

void VideoBitStream::FlushBuffer(void)
	{
	BitStream::FlushBuffer();
	sequenceEndFound = FALSE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\GenericMMXMotionComp.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef GENERICMMXMOTIONCOMP_H
#define GENERICMMXMOTIONCOMP_H

#include "driver\SoftwareCinemaster\Common\Prelude.h"

class GenericMMXMotionComp
	{
	public:
		virtual void BiMotionCompensationUV(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal) = 0;

		virtual void SBiMotionCompensationUV(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal) = 0;

		virtual void BiMotionCompensationY(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal) = 0;

		virtual void SBiMotionCompensationY(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal) = 0;

		virtual void DBiMotionCompensationY(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr) = 0;

		virtual void SDBiMotionCompensationY(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr) = 0;

		virtual void IDBiMotionCompensationY(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist) = 0;

		virtual void ISDBiMotionCompensationY(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist) = 0;

		virtual void MotionCompensationUV(int yp, int xp, BYTE * prevp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal) = 0;

		virtual void SMotionCompensationUV(int yp, int xp, BYTE * prevp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal) = 0;

		virtual void MotionCompensationY(int yp, int xp, BYTE * prevp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal) = 0;

		virtual void SMotionCompensationY(int yp, int xp, BYTE * prevp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal) = 0;

		virtual void DMotionCompensationY(int yp, int xp, BYTE * prevp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr) = 0;

		virtual void SDMotionCompensationY(int yp, int xp, BYTE * prevp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr) = 0;

		virtual void IDMotionCompensationY(int yp, int xp, BYTE * prevp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist) = 0;

		virtual void ISDMotionCompensationY(int yp, int xp, BYTE * prevp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist) = 0;
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\Huffdec.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef HUFFDEC_H
#define HUFFDEC_H

#include "driver\SoftwareCinemaster\Common\Prelude.h"
#include "..\common\bitstreams.h"

#define HUFF_PARTITION_BITS	8
#define HUFF_PARTITION_SIZE	(1 << HUFF_PARTITION_BITS)

struct HuffInit
	{
	char	*	str;
	long		val;
	};

class HuffmanTable
	{
	friend class VideoBitStream;
	private:
		class HuffXEntry
			{
			public:
				union {
						HuffXEntry	*	sub;
						long				val;} u;

				HuffXEntry(void)
					{
					u.val = 0x0f;
					}

				~HuffXEntry(void)
					{
					//if (!(u.val & 1)) delete[] u.sub;
					}

			} xroot[HUFF_PARTITION_SIZE];

		class HuffEntry
			{
			public:
				bool		final;
				bool		append;
				long		val;
				HuffEntry	*	zero;
				HuffEntry	*	one;

				HuffEntry(void)
					{
					final = FALSE;
					one = zero = NULL;
					}

				~HuffEntry(void)
					{
					if (!final)
						{
						delete zero;
						delete one;
						}
					}
				};
		HuffEntry * root;

		void BuildXRest(HuffXEntry * xentry, HuffEntry * entry, int predepth);

		void SecureXRest(HuffXEntry * xentry);

		HuffXEntry * MergeXRest(HuffXEntry * me, HuffXEntry * with);
	public:
		HuffmanTable(void);
		HuffmanTable(HuffInit * init);
		~HuffmanTable(void);

		DWORD FindSymbol(DWORD val);
		DWORD FindFlatSymbol(DWORD val);

		void AddEntry(const char * str, long val);

		void BuildXTable(void);

		void PrepareByteTable(int add);

		void Merge(HuffmanTable & table);

		void Secure(void);

		void BuildExtDCTTable(void);
		void BuildFlatDCTTable(void);
		void BuildExtPatternTable(void);

		DWORD		pad0[7];

		unsigned long extDCTTable[0x400];
		unsigned long extNIDCTTable[0x400];
		unsigned short extNIDCTTable2[0x200];
		unsigned char extPatternTable[32 + 128]; // SSCCCCCC
		unsigned long * flatDCTTable;		//	format XXX.LLLLLLLLLLLL.0 00SSSSSS TTRRRRRR
		unsigned long * flatNIDCTTable;	// format XXX.LLLLLLLLLLLL.F 00SSSSSS.TTRRRRRR
													// LLLLLLLLLLLL	: 12 bit level
													// XXX				: sign extension of level
													// F					: fraction bit for non intra values
													// SSSSSS			: size of huffman code in bits
													// TT					: 00 correct table, 10 end of block, 01 extended code
													//	RRRRRR			: run

		DWORD		pad1[6];
	};

#define VIDEO_STREAM_BUFFER_SIZE	(1 << 19)
#define VIDEO_STREAM_BUFFER_MASK	(VIDEO_STREAM_BUFFER_SIZE * 32 - 1)

extern DWORD VideoStreamBuffer[VIDEO_STREAM_BUFFER_SIZE+8];
extern int BSBits;

class VideoBitStream : public BitStream
	{
	protected:
		bool	sequenceEndFound;
	public:
		VideoBitStream(StreamFlipCopy * streamFlipCopy);

		~VideoBitStream(void);

		long GetSymbol(HuffmanTable * table);

		DWORD GetBits(int num);

		DWORD GetBit(void);

		bool GetBool(void);

		DWORD PeekBits(int num);

		DWORD PeekBit(void);

		bool PeekBool(void);

		int Peek(void);

		void Advance(int bits);

		void NextStartCode(void);

		long GetDCCoefficient(HuffmanTable * table);

		long GetCoefficient(HuffmanTable * table);

		int AddData(BYTE * ptr, int num);

		bool RefillBuffer(int requestBits = 65536, bool lowDataPanic = FALSE);

		void FlushBuffer(void);
	};


__forceinline void VideoBitStream::Advance(int bits)
	{
	BSBits += bits;
	}

#pragma warning(disable : 4035)

__forceinline int VideoBitStream::Peek(void)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [BSBits]

		mov	ecx, eax
 		and	eax, VIDEO_STREAM_BUFFER_MASK

		shr	eax, 5

		mov	edx, [VideoStreamBuffer + 4 + eax * 4]
		mov	eax, [VideoStreamBuffer +     eax * 4]

		shld	eax, edx, cl
		}
#else
	DWORD * p = VideoStreamBuffer + ((BSBits & VIDEO_STREAM_BUFFER_MASK) >> 5);
	DWORD res = SHLD64(p[0], p[1], BSBits & 31);

	return (int)res;
#endif
	}

__forceinline DWORD VideoBitStream::PeekBits(int num)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [BSBits]
		mov	ecx, [num]

 		and	eax, VIDEO_STREAM_BUFFER_MASK
		mov	ch, 32

		sub	ch, cl
		mov	cl, al

		shr	eax, 5

		mov	edx, [VideoStreamBuffer + 4 + eax * 4]
		mov	eax, [VideoStreamBuffer +     eax * 4]

		shld	eax, edx, cl

		mov	cl, ch

		shr	eax, cl
		}
#else
	return (DWORD)(Peek()) >> (32 - num);
#endif
	}

__forceinline DWORD VideoBitStream::GetBits(int num)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [BSBits]
		mov	ecx, [num]

		mov	edx, eax
		and	eax, VIDEO_STREAM_BUFFER_MASK

		add	edx, ecx
		mov	ch, 32

		sub	ch, cl
		mov	cl, al

		shr	eax, 5
		mov	[BSBits], edx

		mov	edx, [VideoStreamBuffer + 4 + eax * 4]
		mov	eax, [VideoStreamBuffer +     eax * 4]

		shld	eax, edx, cl

		mov	cl, ch

		shr	eax, cl
		}
#else
	DWORD res;

	res = PeekBits(num);
	Advance(num);

	return res;
#endif
	}

inline DWORD HuffmanTable::FindSymbol(DWORD val)
	{
	DWORD sym;

	sym = xroot[(val >> 24) & 255].u.val;
	if (!(sym & 1))
		sym = ((HuffmanTable::HuffXEntry *)sym)[(val >> 16) & 255].u.val;

	return sym;
	}

inline DWORD HuffmanTable::FindFlatSymbol(DWORD val)
	{
	return xroot[(val >> 24) & 255].u.val;
	}

__forceinline long VideoBitStream::GetSymbol(HuffmanTable * table)
	{
#if _M_IX86
	__asm
		{
		mov	edx, [BSBits]
		mov	eax, [table]

		mov	ecx, edx
		and	edx, VIDEO_STREAM_BUFFER_MASK

		shr	edx, 5

		mov	ebx, [VideoStreamBuffer + 4 + edx * 4]
		mov	edx, [VideoStreamBuffer +     edx * 4]

		shld	edx, ebx, cl

		mov	ebx, edx
		mov	ecx, 0x000000ff

		shr	ebx, 24
		and	edx, 0x00ff0000

		shr	edx, 16
		mov	eax, [eax + 4 * ebx]

		test	eax, 1
		jne	hit1

		mov	eax, [eax + 4 * edx]
hit1:
		and	ecx, eax

		shr	ecx, 1
		mov	ebx, [BSBits]

		add	ebx, ecx

		sar	eax, 8
		mov	[BSBits], ebx
		}
#else
	DWORD res;
	DWORD sym;

	res = Peek();

	sym = table->FindSymbol(res);

	Advance((sym >> 1) & 0x7f);

	return ((int)sym) >> 8;
#endif
	}

__forceinline long VideoBitStream::GetCoefficient(HuffmanTable * table)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [table]
		mov	edx, [BSBits]

		mov	ecx, edx
		and	edx, VIDEO_STREAM_BUFFER_MASK

		shr	edx, 5

		mov	ebx, [VideoStreamBuffer + 4 + edx * 4]
		mov	edx, [VideoStreamBuffer +     edx * 4]

		shld	edx, ebx, cl

		mov	ecx, edx
		mov	ebx, edx

		shr	ecx, 24
		and	edx, 0x00ff0000

		shr	edx, 16

		mov	eax, [eax + 4 * ecx]
		mov	ecx, 0xff

		test	eax, 1
		je		notfirsthit

		test	eax, eax
		jns	firsthit

		test	eax, 0x0100
		je		firsthit

		mov	eax, ebx
		mov	edx, [BSBits]

		and	eax, 0x03ffffff
		add	edx, 24

		mov	[BSBits], edx
		jmp	escfinal

notfirsthit:
		mov	eax, [eax + 4 * edx]

firsthit:
		shr	ebx, 1
		and	ecx, eax

		shr	ecx, 1
		mov	edx, [BSBits]

		shl	ebx, cl

		sar	ebx, 31
		add	edx, ecx

		and	ebx, 0x000fff00
		mov	[BSBits], edx

		xor	eax, ebx
		and	ebx, 0x00000100

		add	eax, ebx
escfinal:
		}
#else
	DWORD * p = VideoStreamBuffer + ((BSBits & VIDEO_STREAM_BUFFER_MASK) >> 5);
	DWORD res = SHLD64(p[0], p[1], BSBits & 31);
	DWORD numbits;
	DWORD sym;

	sym = table->xroot[res & 255].u.val;
	if (sym & 1)
		{
		sym = ((HuffmanTable::HuffXEntry *)sym)[(res >> 8) & 255].u.val;
		}
	else if ((sym & 0x80000000) && (sym & 0x0100))
		{
		BSBits += 24;

		return res & 0x03ffffff;
		}

	numbits = (sym & 0xff) >> 1;

	if (res & (1 << (32 - numbits)))
		{
		sym ^= 0x000fff00;
		sym += 0x00000100;
		}

	Advance(numbits);

	return sym;
#endif
	}

__forceinline long VideoBitStream::GetDCCoefficient(HuffmanTable * table)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [BSBits]
		mov	edx, [table]

		mov	ecx, eax
		and	eax, VIDEO_STREAM_BUFFER_MASK

		shr	eax, 5

		mov	ebx, [VideoStreamBuffer + 4 + eax * 4]
		mov	eax, [VideoStreamBuffer +     eax * 4]

		shld	eax, ebx, cl

		mov	ecx, eax
		mov	ebx, eax
loop1:
		shr	ebx, 32 - HUFF_PARTITION_BITS

		shl	ecx, HUFF_PARTITION_BITS
		mov	edx, [edx + 4 * ebx]

		test	edx, 1
		mov	ebx, ecx

		je		loop1

		shr	dl, 1
		test	dh, dh

		mov	cl, dl
		je		zero

		shl	eax, cl

		test	eax, eax

		mov	cl, 32
		jns	notPositive

		add	dl, dh
		sub	cl, dh

		shr	eax, cl
		jmp	signDone
zero:
		xor	eax, eax
		jmp	signDone

notPositive:

		shr	eax, 1
		mov	cl, 31

		or		eax, 0x80000000
		sub	cl, dh

		sar	eax, cl

		add	dl, dh
		add	eax, 0x00000001

signDone:
		and	edx, 0x000000ff
		mov	ebx, [BSBits]

		add	ebx, edx

		mov	[BSBits], ebx
		}
#else
	DWORD res = Peek();
	DWORD temp, sym, num, nummant;
	HuffmanTable::HuffXEntry * ltable = table->xroot;

	temp = res;
	do {
		ltable = ltable[temp >> (32 - HUFF_PARTITION_BITS)].u.sub;
		temp <<= HUFF_PARTITION_BITS;
		} while (!((DWORD)ltable & 1));

	sym = (DWORD)ltable;
	num = (sym >> 1) & 0x7f;
	nummant = (sym >> 8) & 0xff;

	if (nummant)
		{
		res <<= num;

		num += nummant;

		if (res & 0x80000000)
			{
			res >>= (32 - nummant);
			}
		else
			{
			res = (DWORD)-(int)(~res >> (32 - nummant));
			}
		}
	else
		{
		res = 0;
		}

	Advance(num);

	return res;
#endif
	}

__forceinline DWORD VideoBitStream::GetBit(void)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [BSBits]
		mov	cl, 31

		mov	edx, eax
		and	eax, VIDEO_STREAM_BUFFER_MASK

		shr	eax, 5
		sub	cl, dl

		mov	eax, [VideoStreamBuffer + eax * 4]
		inc	edx

		shr	eax, cl

		and	eax, 1
		mov	[BSBits], edx
		}
#else
	return GetBits(1);
#endif
	}

__forceinline DWORD VideoBitStream::PeekBit(void)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [BSBits]
		mov	cl, 31

		sub	cl, al
		and	eax, VIDEO_STREAM_BUFFER_MASK

		shr	eax, 5

		mov	eax, [VideoStreamBuffer + eax * 4]

		shr	eax, cl

		and	eax, 1
		}
#else
	return PeekBits(1);
#endif
	}

__forceinline bool VideoBitStream::GetBool(void)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [BSBits]
		mov	cl, 31

		mov	edx, eax
		and	eax, VIDEO_STREAM_BUFFER_MASK

		shr	eax, 5
		sub	cl, dl

		mov	eax, [VideoStreamBuffer + eax * 4]
		inc	edx

		shr	eax, cl

		and	eax, 1
		mov	[BSBits], edx
		}
#else
	return GetBits(1);
#endif
	}

__forceinline bool VideoBitStream::PeekBool(void)
	{
#if _M_IX86
	__asm
		{
		mov	eax, [BSBits]
		mov	cl, 31

		sub	cl, al
		and	eax, VIDEO_STREAM_BUFFER_MASK

		shr	eax, 5

		mov	eax, [VideoStreamBuffer + eax * 4]

		shr	eax, cl

		and	eax, 1
		}
#else
	return PeekBits(1);
#endif
	}

#pragma warning(default : 4035)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\GenericMMXMacroBlockIDCTDecoder.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#include "GenericMMXMacroBlockIDCTDecoder.h"

#include "..\common\MMXExtensionMacros.h"
//#include "driver\SoftwareCinemaster\common\ATHLONMacros.h"

#define DUMP_COEFFICIENTS	0
#define MEASURE_PARSE_TIME	0

#if DUMP_COEFFICIENTS
#include <stdio.h>

FILE * dfile;
static int blockcount;

#endif

#pragma warning (disable : 4799)

static unsigned char hflut[2][16] =
	{
		{1, 1, 2, 3, 4, 5, 6, 7, 8, 1, 1, 1, 1, 1, 1, 1},
		{1, 1, 2, 3, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1}
	};

static unsigned char hfluti[16] =
	{1, 1, 2, 3, 4, 5, 6, 7, 8, 1, 1, 1, 1, 1, 1, 1};

#define HIGH_PRECISION_IDCT		0

#if HIGH_PRECISION_IDCT

static inline double R1(double x)
	{
	return floor(x * (1 << 4));
	}

static inline double R2(double x)
	{
	return floor(x / (1 << 0));
	}

static inline double R2a(double x)
	{
	return floor(x / (1 << 0));
	}

void GenericMMXMacroBlockIDCTDecoder::InverseDCT(short * mb, int stride, DCTMulTable * table, int numLines, int numColumns)
	{
	double fmmxf[8][8];
	int y, x;
	double y0, y1, y2, y3, a0, a1, a2, a3, y4, y6, y5, y7;

	static int maxco, minco;

	__asm emms

	for (y=0; y < 8; y++)
		{
		y0 = R1(tmmxf[y][0] * DC8) + R1(tmmxf[y][1] * DC8);
		y1 = R1(tmmxf[y][0] * DC8) - R1(tmmxf[y][1] * DC8);
		y2 = R1(tmmxf[y][2] * DC2) + R1(tmmxf[y][3] * DC6);
		y3 = R1(tmmxf[y][2] * DC6) - R1(tmmxf[y][3] * DC2);
		a0 = y0 + y2;
		a1 = y1 + y3;
		a2 = y1 - y3;
		a3 = y0 - y2;
		y4 = R1(tmmxf[y][4] * DC1) + R1(tmmxf[y][6] * DC3) + R1(tmmxf[y][5] * DC5) + R1(tmmxf[y][7] * DC7);
		y6 = R1(tmmxf[y][4] * DC3) - R1(tmmxf[y][6] * DC7) - R1(tmmxf[y][5] * DC1) - R1(tmmxf[y][7] * DC5);
		y5 = R1(tmmxf[y][4] * DC7) - R1(tmmxf[y][6] * DC5) + R1(tmmxf[y][5] * DC3) - R1(tmmxf[y][7] * DC1);
		y7 = R1(tmmxf[y][4] * DC5) - R1(tmmxf[y][6] * DC1) + R1(tmmxf[y][5] * DC7) + R1(tmmxf[y][7] * DC3);
		fmmxf[y][0] = a0 + y4;
		fmmxf[y][1] = a1 + y6;
		fmmxf[y][2] = a2 + y7;
		fmmxf[y][3] = a3 + y5;
		fmmxf[y][4] = a3 - y5;
		fmmxf[y][5] = a2 - y7;
		fmmxf[y][6] = a1 - y6;
		fmmxf[y][7] = a0 - y4;
		}

	for (y=0; y < 8; y++)
		{
		y0 = R2(fmmxf[0][y] * DC8) + R2(fmmxf[4][y] * DC8);
		y1 = R2(fmmxf[0][y] * DC8) - R2(fmmxf[4][y] * DC8);
		y2 = R2(fmmxf[2][y] * DC2) + R2(fmmxf[6][y] * DC6);
		y3 = R2(fmmxf[2][y] * DC6) - R2(fmmxf[6][y] * DC2);
		a0 = y0 + y2;
		a1 = y1 + y3;
		a2 = y1 - y3;
		a3 = y0 - y2;
		y4 = R2(fmmxf[1][y] * DC1) + R2(fmmxf[3][y] * DC3) + R2(fmmxf[5][y] * DC5) + R2(fmmxf[7][y] * DC7);
		y6 = R2(fmmxf[1][y] * DC3) - R2(fmmxf[3][y] * DC7) - R2(fmmxf[5][y] * DC1) - R2(fmmxf[7][y] * DC5);
		y7 = R2(fmmxf[1][y] * DC5) - R2(fmmxf[3][y] * DC1) + R2(fmmxf[5][y] * DC7) + R2(fmmxf[7][y] * DC3);
		y5 = R2(fmmxf[1][y] * DC7) - R2(fmmxf[3][y] * DC5) + R2(fmmxf[5][y] * DC3) - R2(fmmxf[7][y] * DC1);
		fmmxf[0][y] = a0 + y4;
		fmmxf[1][y] = a1 + y6;
		fmmxf[2][y] = a2 + y7;
		fmmxf[3][y] = a3 + y5;
		fmmxf[4][y] = a3 - y5;
		fmmxf[5][y] = a2 - y7;
		fmmxf[6][y] = a1 - y6;
		fmmxf[7][y] = a0 - y4;
		}

	for(y=0; y<8; y++)
		{
		for(x=0; x<8; x++)
			{
			int t = (int)(floor(fmmxf[y][x]) + 0);
			t = (t + 64) >> 7;

			mb[y*(stride/2)+x] = t;
			tmmxf[y][x] = 0;
			}
		}
	}
#else
void GenericMMXMacroBlockIDCTDecoder::InverseDCT(short * mb, int stride, DCTMulTable * table, int numLines, int numColumns)
	{
	static MMXQWORD RoundOne0    = {ROUND_ONE, ROUND_ONE, ROUND_ONE, ROUND_ONE};
	static MMXQWORD RoundSingle0 = {ROUND_SINGLE, ROUND_SINGLE, ROUND_SINGLE, ROUND_SINGLE};

	static MMXQWORD RoundOne1    = {ROUND_ONE, ROUND_ONE, ROUND_ONE, ROUND_ONE};
	static MMXQWORD RoundSingle1 = {ROUND_SINGLE, ROUND_SINGLE, ROUND_SINGLE, ROUND_SINGLE};

	static MMXQWORD RoundSecond0 = {ROUND_SECOND, ROUND_SECOND, ROUND_SECOND, ROUND_SECOND};
	static MMXQWORD RoundSecond1 = {ROUND_SECOND, ROUND_SECOND, ROUND_SECOND, ROUND_SECOND};

	static MMXQWORD RoundSecond0a = {ROUND_SECOND * 4, ROUND_SECOND * 4, ROUND_SECOND * 4, ROUND_SECOND * 4};
	static MMXQWORD RoundSecond1a = {ROUND_SECOND * 4, ROUND_SECOND * 4, ROUND_SECOND * 4, ROUND_SECOND * 4};

	switch (numColumns)
		{
		case 1:
			if (numLines == 1)
				{
				__asm
					{
					mov			esi, [table]
					mov			edx, [stride]

					movq			mm0, [tmmxf]
					pxor			mm2, mm2

					movq			mm1, [RoundOne1]
					punpcklwd	mm0, mm0

					mov	ebx, [mb]
					punpckldq	mm0, mm0

					pmulhw		mm0, [esi].tpC8pC8pC8pC8

					lea			eax, [ebx+2*edx]

					lea			ecx, [ebx+2*edx]

					lea			eax, [eax+edx]

					paddw			mm1, mm0
					paddw			mm0, [RoundOne0]

					movq			[tmmxf], mm2
					psraw			mm0, ONE_SHIFT

					movq			[ebx], mm0
					movq			[ebx+8], mm0

					psraw			mm1, ONE_SHIFT

					movq			[ebx+2*edx], mm0
  					movq			[ebx+2*edx+8], mm0

					movq			[ebx+4*edx], mm0
					movq			[ebx+4*edx+8], mm0

					movq			[ecx+4*edx], mm0
					movq			[ecx+4*edx+8], mm0

					movq			[ebx+edx], mm1
					movq			[ebx+edx+8], mm1

					movq			[eax], mm1
					movq			[eax+8], mm1

					movq			[eax+2*edx], mm1
					movq			[eax+2*edx+8], mm1

					movq			[eax+4*edx], mm1
					movq			[eax+4*edx+8], mm1
					}

				return;
				}
			else
				{
				__asm
					{
					lea			eax, tmmxf
					mov			esi, [table]

					mov			ecx, [numLines]

					movq			mm1, [eax+0]

					pmaddwd		mm1, [esi].tpC8000000000

					sub			ecx, 1
loop11:
					movq			mm0, [eax+16]
					psrad			mm1, FIRST_SHIFT

					pmaddwd		mm0, [esi].tpC8000000000
					punpckldq	mm1, mm1

					packssdw		mm1, mm1
					sub			ecx, 1

					movq			[eax], mm1

					movq			[eax + 8], mm1
					movq			mm1, mm0

					lea			eax, [eax + 16]
					jne			loop11

					psrad			mm1, FIRST_SHIFT

					punpckldq	mm1, mm1

					packssdw		mm1, mm1

					movq			[eax], mm1

					movq			[eax + 8], mm1
					}
				}
			break;
		case 2:
			__asm
				{
				mov			esi, [table]

				lea			eax, tmmxf
				mov			ecx, [numLines]

				movq			mm1, [eax+8]

				punpcklwd	mm1, [eax+0]

				movq			mm4, [esi].tpC8pC7pC8pC5
				punpckldq	mm1, mm1

				movq			mm2, [esi].tpC8pC3pC8pC1
				pmaddwd		mm4, mm1

				movq			mm3, [esi].tpC8mC1pC8mC3
				pmaddwd		mm2, mm1

				movq			mm5, mm1
				pmaddwd		mm3, mm1

				pmaddwd		mm5, [esi].tpC8mC5pC8mC7
				psrad			mm4, FIRST_SHIFT

				psrad			mm2, FIRST_SHIFT
				sub			ecx, 1

				psrad			mm3, FIRST_SHIFT
				je				done12
loop12:
				movq			mm1, [eax+24]
				psrad			mm5, FIRST_SHIFT

				punpcklwd	mm1, [eax+16]
				packssdw		mm2, mm4

				movq			mm4, [esi].tpC8pC7pC8pC5
				punpckldq	mm1, mm1

				movq			[eax], mm2
				packssdw		mm5, mm3

				movq			mm2, [esi].tpC8pC3pC8pC1
				pmaddwd		mm4, mm1

				movq			mm3, [esi].tpC8mC1pC8mC3
				pmaddwd		mm2, mm1

				movq			[eax + 8], mm5
				movq			mm5, mm1

				pmaddwd		mm3, mm1
				psrad			mm4, FIRST_SHIFT

				pmaddwd		mm5, [esi].tpC8mC5pC8mC7
				psrad			mm2, FIRST_SHIFT

				lea			eax, [eax+16]
				sub			ecx, 1

				psrad			mm3, FIRST_SHIFT
				jne			loop12
done12:
				psrad			mm5, FIRST_SHIFT

				packssdw		mm2, mm4

				packssdw		mm5, mm3

				movq			[eax], mm2

				movq			[eax + 8], mm5
				}
			break;
		case 3:
			__asm
				{
				mov			esi, [table]

				lea			eax, tmmxf
				mov			ecx, [numLines]
				movq			mm0, [eax+0]

				movq			mm4, [eax+8]
				movq			mm2, mm0

				pmaddwd		mm0, [esi].tpC8000000000
				psrlq			mm2, 32

				punpcklwd	mm4, mm2

				movq			mm1, [esi].tmC2pC7mC6pC5
				punpckldq	mm4, mm4

				movq			mm2, [esi].tpC6pC3pC2pC1
				pmaddwd		mm1, mm4

				movq			mm3, [esi].tpC2mC1pC6mC3
				punpckldq	mm0, mm0

				pmaddwd		mm2, mm4
				psrad			mm0, FIRST_SHIFT

				pmaddwd		mm3, mm4
				psrad			mm1, FIRST_SHIFT

				pmaddwd		mm4, [esi].tmC6mC5mC2mC7
				packssdw		mm0, mm0

				psrad			mm2, FIRST_SHIFT

				psrad			mm3, FIRST_SHIFT

				psrad			mm4, FIRST_SHIFT

				sub			ecx, 1
				je				done13
loop13:
				movq			mm5, [eax+16]
				packssdw		mm2, mm1

				movq			mm1, [eax+24]
				paddsw		mm2, mm0

				movq			[eax], mm2
				movq			mm2, mm5

				pmaddwd		mm5, [esi].tpC8000000000
				packssdw		mm4, mm3

				psrlq			mm2, 32
				paddsw		mm4, mm0

				movq			[eax + 8], mm4
				punpcklwd	mm1, mm2

				punpckldq	mm1, mm1
				movq			mm0, mm5

				movq			mm2, [esi].tpC6pC3pC2pC1
				movq			mm4, mm1

				pmaddwd		mm1, [esi].tmC2pC7mC6pC5

				movq			mm3, [esi].tpC2mC1pC6mC3
				punpckldq	mm0, mm0

				pmaddwd		mm2, mm4
				psrad			mm0, FIRST_SHIFT

				pmaddwd		mm3, mm4
				psrad			mm1, FIRST_SHIFT

				pmaddwd		mm4, [esi].tmC6mC5mC2mC7
				packssdw		mm0, mm0

				psrad			mm2, FIRST_SHIFT
				sub			ecx, 1

				psrad			mm3, FIRST_SHIFT
				lea			eax, [eax+16]

				psrad			mm4, FIRST_SHIFT
				jne			loop13
done13:
				packssdw		mm2, mm1

				packssdw		mm4, mm3
				paddsw		mm2, mm0

				paddsw		mm4, mm0

				movq	[eax], mm2

				movq	[eax + 8], mm4

				}
			break;
		case 4:
			__asm
				{
				mov			esi, [table]

				lea			eax, tmmxf
				mov			ecx, [numLines]

loop14:
				movq			mm0, [eax+0]	// 00 f2 00 f0

				movq			mm1, [eax+8]	// 00 f3 00 f1
				psrlq			mm0, 16

				por			mm0, [eax+0]
				psrlq			mm1, 16

				por			mm1, [eax+8]
				punpckldq	mm0, mm0			// f2 f0 f2 f0

				movq			mm2, [esi].tpC6pC8pC2pC8
				punpckldq	mm1, mm1			// f3 f1 f3 f1

				movq			mm3, [esi].tmC7pC3pC3pC1
				pmaddwd		mm2, mm0

				pmaddwd		mm0, [esi].tmC2pC8mC6pC8

				pmaddwd		mm3, mm1

				pmaddwd		mm1, [esi].tmC5pC7mC1pC5
				movq			mm4, mm2

				movq			mm5, mm0
				paddd			mm2, mm3

				psrad			mm2, FIRST_SHIFT
				paddd			mm0, mm1

				psrad			mm0, FIRST_SHIFT
				psubd			mm4, mm3

				psrad			mm4, FIRST_SHIFT
				psubd			mm5, mm1

				psrad			mm5, FIRST_SHIFT

				packssdw		mm5, mm4
				add			eax, 16

				movq			mm4, mm5
				packssdw		mm2, mm0

				pslld			mm5, 16

				psrld			mm4, 16

				por			mm4, mm5

				movq			[eax-16], mm2

				movq			[eax-8], mm4

				sub			ecx, 1
				jne			loop14
				}
			break;
		default:
			__asm
				{
				mov			esi, [table]

				lea			eax, [tmmxf]
				mov			ecx, [numLines]
loop18a:
				movq			mm0, [eax+0]
				movq			mm1, mm0
				dec			ecx

				movq			mm6, [eax+8]			// f7 f3 f5 f1
				punpckldq	mm0, mm0					// f4 f0 f4 f0
				movq			mm7, mm6

				pmaddwd		mm0, [esi].tmC8pC8pC8pC8
				punpckhdq	mm1, mm1					// f6 f2 f6 f2

				pmaddwd		mm1, [esi].tmC2pC6pC6pC2
				movq			mm2, mm0

				movq			mm4, [esi].tmC1pC3pC5pC1
				lea			eax, [eax + 16]
				punpckldq	mm6, mm6					// f5 f1 f5 f1

				punpckhdq	mm7, mm7					// f7 f3 f7 f3
				pmaddwd		mm4, mm6					// y6a y4a

				pmaddwd		mm6, [esi].tpC3pC7pC7pC5	// y5a y7a
				paddd			mm0, mm1					// a1 a0
				psubd			mm2, mm1					// a3 a2

				movq			mm5, [esi].tmC5mC7pC7pC3
				pmaddwd		mm5, mm7					// y6b y4b
				punpckldq	mm1, mm2

				pmaddwd		mm7, [esi].tmC1mC5pC3mC1	// y5b y7b
				punpckhdq	mm2, mm1					// a2 a3

				paddd			mm4, mm5
				paddd			mm6, mm7

				movq			mm7, mm0
				movq			mm5, mm2

				paddd			mm0, mm4					// t1 t0
				paddd			mm2, mm6					// t2 t3

				psrad			mm0, FIRST_SHIFT
				psrad			mm2, FIRST_SHIFT

				psubd			mm7, mm4					// t6 t7
				psubd			mm5, mm6					// t4 t5

				psrad			mm7, FIRST_SHIFT
				psrad			mm5, FIRST_SHIFT

				packssdw		mm0, mm2					// t3 t2 t1 t0
				packssdw		mm5, mm7					// t6 t7 t4 t5

				movq			mm7, mm5
				pslld			mm5, 16

				movq			[eax-16], mm0

				psrld			mm7, 16
				por			mm5, mm7					// t4 t5 t6 t7

				movq			[eax-8], mm5

				jne			loop18a
				}
			break;
		}

	switch (numLines)
		{
		case 1:
			__asm
				{
				movq		mm2, [RoundSingle0]
				pxor		mm7, mm7

				movq		mm0, [tmmxf + 0 * 16 + 0]
				paddsw	mm0, mm2
				psraw		mm0, INTER_PREC

				movq		mm1, [tmmxf + 0 * 16 + 8]
				paddsw	mm1, mm2
				psraw		mm1, INTER_PREC

				movq		[tmmxf + 0 * 16 + 0], mm7
				mov		ebx, [mb]
				mov		edx, [stride]

				movq		[tmmxf + 0 * 16 + 8], mm7
				lea		ecx, [ebx+4*edx]
				lea		esi, [ebx+2* edx]
				lea		edi, [ecx+2*edx]

				movq		[ebx+edx], mm0
				movq		[ebx+edx+8], mm1
				movq		[ecx+edx], mm0
				movq		[ecx+edx+8], mm1
				movq		[ebx], mm0
				movq		[ebx+8], mm1
				movq		[ecx], mm0
				movq		[ecx+8], mm1
				movq		[esi], mm0
				movq		[esi+8], mm1
				movq		[edi], mm0
				movq		[edi+8], mm1
				add		esi, edx
				movq		[esi], mm0
				add		edi, edx
				movq		[esi+8], mm1
				movq		[edi], mm0
				movq		[edi+8], mm1
				}
			break;
		case 2:
			__asm
				{
				mov		ebx, [mb]
				mov		edx, [stride]
				lea		ecx, [ebx+4*edx]
				lea		esi, [edx+2*edx]

				movq		mm0, [tmmxf + 0 * 16 + 0]
				movq		mm1, [tmmxf + 0 * 16 + 8]
				paddsw	mm0, [RoundSecond0a]
				paddsw	mm1, [RoundSecond0a]

				pxor		mm7, mm7
				movq		[tmmxf + 0 * 16 + 0], mm7
				movq		[tmmxf + 0 * 16 + 8], mm7


				//////////////////////

				movq		mm3, [pC1pC1pC1pC1a]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]
				paddsw	mm2, [tmmxf + 1 * 16 + 0]
				paddsw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm4, mm0
				movq		mm5, mm0
				paddsw	mm4, mm2
				psubsw	mm5, mm2

				movq		mm6, mm1
				movq		mm7, mm1
				paddsw	mm6, mm3
				psubsw	mm7, mm3

				psraw		mm4, SECOND_SHIFT + 2
				psraw		mm5, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx], mm4
				movq		[ebx+8], mm6
				movq		[ecx+esi], mm5
				movq		[ecx+esi+8], mm7


				movq		mm3, [pC3pC3pC3pC3a]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]
				paddsw	mm2, [tmmxf + 1 * 16 + 0]
				paddsw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm4, mm0
				movq		mm5, mm0
				paddsw	mm4, mm2
				psubsw	mm5, mm2

				movq		mm6, mm1
				movq		mm7, mm1
				paddsw	mm6, mm3
				psubsw	mm7, mm3

				psraw		mm4, SECOND_SHIFT + 2
				psraw		mm5, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx+edx], mm4
				movq		[ebx+edx+8], mm6
				movq		[ecx+2*edx], mm5
				movq		[ecx+2*edx+8], mm7


				movq		mm3, [pC5pC5pC5pC5a]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				paddsw	mm2, mm2
				paddsw	mm3, mm3

				movq		mm4, mm0
				movq		mm5, mm0
				paddsw	mm4, mm2
				psubsw	mm5, mm2

				movq		mm6, mm1
				movq		mm7, mm1
				paddsw	mm6, mm3
				psubsw	mm7, mm3

				psraw		mm4, SECOND_SHIFT + 2
				psraw		mm5, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx+2*edx], mm4
				movq		[ebx+2*edx+8], mm6
				movq		[ecx+edx], mm5
				movq		[ecx+edx+8], mm7

				movq		mm3, [pC7pC7pC7pC7a]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm4, mm0
				movq		mm5, mm0
				paddsw	mm4, mm2
				psubsw	mm5, mm2

				movq		mm6, mm1
				movq		mm7, mm1
				paddsw	mm6, mm3
				psubsw	mm7, mm3

				psraw		mm4, SECOND_SHIFT + 2
				psraw		mm5, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx+esi], mm4
				movq		[ebx+esi+8], mm6
				movq		[ecx], mm5
				movq		[ecx+8], mm7

				pxor		mm7, mm7
				movq		[tmmxf + 1 * 16 + 0], mm7
				movq		[tmmxf + 1 * 16 + 8], mm7
				}

			break;
		case 3:
			__asm
				{
				mov		ebx, [mb]
				mov		edx, [stride]
				lea		ecx, [ebx+4*edx]
				lea		esi, [edx+2*edx]

				movq		mm0, [tmmxf + 0 * 16 + 0]
				movq		mm1, [tmmxf + 0 * 16 + 8]

				movq		mm3, [pC2pC2pC2pC2a]
				movq		mm2, [tmmxf + 2 * 16 + 0]
				pmulhw	mm2, mm3
				paddsw	mm2, [tmmxf + 2 * 16 + 0]

				pmulhw	mm3, [tmmxf + 2 * 16 + 8]
				paddsw	mm3, [tmmxf + 2 * 16 + 8]

				paddsw	mm0, [RoundSecond0a]
				paddsw	mm1, [RoundSecond0a]

				movq		mm4, mm0
				movq		mm5, mm1

				paddsw	mm0, mm2
				paddsw	mm1, mm3
				psubsw	mm4, mm2
				psubsw	mm5, mm3

				/////////////

				movq		mm3, [pC1pC1pC1pC1a]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]
				paddsw	mm2, [tmmxf + 1 * 16 + 0]
				paddsw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm6, mm0
				paddsw	mm0, mm2
				psubsw	mm6, mm2

				movq		mm7, mm1
				paddsw	mm1, mm3
				psubsw	mm7, mm3

				psraw		mm0, SECOND_SHIFT + 2
				psraw		mm1, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx], mm0
				movq		[ebx+8], mm1
				movq		[ecx+esi], mm6
				movq		[ecx+esi+8], mm7

				//////////

				movq		mm3, [pC7pC7pC7pC7a]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm6, mm4
				paddsw	mm4, mm2
				psubsw	mm6, mm2

				movq		mm7, mm5
				paddsw	mm5, mm3
				psubsw	mm7, mm3

				psraw		mm4, SECOND_SHIFT + 2
				psraw		mm5, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx+esi], mm4
				movq		[ebx+esi+8], mm5
				movq		[ecx], mm6
				movq		[ecx+8], mm7

				////////////////////////////

				movq		mm0, [tmmxf + 0 * 16 + 0]
				movq		mm1, [tmmxf + 0 * 16 + 8]

				movq		mm3, [pC6pC6pC6pC6a]
				movq		mm2, [tmmxf + 2 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 2 * 16 + 8]
				paddsw	mm2, mm2
				paddsw	mm3, mm3

				paddsw	mm0, [RoundSecond0a]
				paddsw	mm1, [RoundSecond0a]
				movq		mm4, mm0
				movq		mm5, mm1

				pxor		mm7, mm7
				movq		[tmmxf + 0 * 16 + 0], mm7
				movq		[tmmxf + 0 * 16 + 8], mm7
				movq		[tmmxf + 2 * 16 + 0], mm7
				movq		[tmmxf + 2 * 16 + 8], mm7

				paddsw	mm0, mm2
				paddsw	mm1, mm3
				psubsw	mm4, mm2
				psubsw	mm5, mm3

				/////////////

				movq		mm3, [pC3pC3pC3pC3a]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]
				paddsw	mm2, [tmmxf + 1 * 16 + 0]
				paddsw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm6, mm0
				paddsw	mm0, mm2
				psubsw	mm6, mm2

				movq		mm7, mm1
				paddsw	mm1, mm3
				psubsw	mm7, mm3

				psraw		mm0, SECOND_SHIFT + 2
				psraw		mm1, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx+edx], mm0
				movq		[ebx+edx+8], mm1
				movq		[ecx+2*edx], mm6
				movq		[ecx+2*edx+8], mm7

				//////////

				movq		mm3, [pC5pC5pC5pC5a]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]
				paddsw	mm2, mm2
				paddsw	mm3, mm3

				movq		mm6, mm4
				paddsw	mm4, mm2
				psubsw	mm6, mm2

				movq		mm7, mm5
				paddsw	mm5, mm3
				psubsw	mm7, mm3

				psraw		mm4, SECOND_SHIFT + 2
				psraw		mm5, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx+2*edx], mm4
				movq		[ebx+2*edx+8], mm5
				movq		[ecx+edx], mm6
				movq		[ecx+edx+8], mm7

				pxor		mm7, mm7
				movq		[tmmxf + 1 * 16 + 0], mm7
				movq		[tmmxf + 1 * 16 + 8], mm7
				}
			break;
		case 4:
			__asm
				{
				mov		ebx, [mb]
				mov		edx, [stride]
				lea		ecx, [ebx+4*edx]
				lea		esi, [edx+2*edx]

				movq		mm7, [RoundSecond0a]

				movq		mm0, [tmmxf + 0 * 16 + 0]
				paddsw	mm0, mm7

				movq		mm1, [tmmxf + 0 * 16 + 8]
				paddsw	mm1, mm7

				movq		mm2, [pC2pC2pC2pC2a]
				movq		mm3, mm2

				movq		mm4, [tmmxf + 2 * 16 + 0]
				pmulhw	mm2, mm4
				paddsw	mm2, mm4

				movq		mm4, [tmmxf + 2 * 16 + 8]
				pmulhw	mm3, mm4
				paddsw	mm3, mm4

				movq		mm4, mm0
				paddsw	mm0, mm2	// a0 0
				psubsw	mm4, mm2 // a3 0

				movq		mm5, mm1
				paddsw	mm1, mm3 // a0 1
				psubsw	mm5, mm3 // a3 1

				movq		mm3, [tmmxf + 1 * 16 + 0]
				movq		mm2, [pC1pC1pC1pC1a]

				pmulhw	mm2, mm3
				paddsw	mm2, mm3

				movq		mm3, [tmmxf + 3 * 16 + 0]
				paddsw	mm2, mm3

				pmulhw	mm3, [pC3pC3pC3pC3a]

				paddsw	mm2, mm3

				movq		mm6, mm0
				paddsw	mm0, mm2		// r0	0
				psubsw	mm6, mm2		// r7	0

				movq		mm3, [tmmxf + 1 * 16 + 8]
				movq		mm2, [pC1pC1pC1pC1a]

				pmulhw	mm2, mm3
				paddsw	mm2, mm3

				movq		mm3, [tmmxf + 3 * 16 + 8]
				paddsw	mm2, mm3

				pmulhw	mm3, [pC3pC3pC3pC3a]

				paddsw	mm2, mm3

				movq		mm7, mm1
				paddsw	mm1, mm2		// r0 1
				psubsw	mm7, mm2		// r7 1

				psraw		mm0, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm1, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx], mm0			// r0
				movq		[ebx+8], mm1			// r0
				movq		[ecx + esi], mm6	// r7
				movq		[ecx + esi+8], mm7	// r7

				//////

				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC5pC5pC5pC5a]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, [pC7pC7pC7pC7a]
				paddsw	mm3, mm3
				psubsw	mm2, mm3

				movq		mm6, mm4
				paddsw	mm4, mm2		// r3	0
				psubsw	mm6, mm2		// r4	0

				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC5pC5pC5pC5a]
				movq		mm2, [tmmxf + 1 * 16 + 8]
				pmulhw	mm2, [pC7pC7pC7pC7a]
				paddsw	mm3, mm3
				psubsw	mm2, mm3

				movq		mm7, mm5
				paddsw	mm5, mm2		// r3 1
				psubsw	mm7, mm2		// r4 1

				psraw		mm4, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm5, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx + esi], mm4			// r0
				movq		[ebx + esi+8], mm5			// r0
				movq		[ecx], mm6	// r7
				movq		[ecx+8], mm7	// r7

				//////////////////////////////

				pxor		mm7, mm7
				movq		mm6, [RoundSecond0a]

				movq		mm0, [tmmxf + 0 * 16 + 0]
				paddsw	mm0, mm6

				movq		[tmmxf + 0 * 16 + 0], mm7

				movq		mm1, [tmmxf + 0 * 16 + 8]
				paddsw	mm1, mm6

				movq		[tmmxf + 0 * 16 + 8], mm7

				movq		mm3, [pC6pC6pC6pC6a]
				movq		mm2, [tmmxf + 2 * 16 + 0]
				pmulhw	mm2, mm3
				paddsw	mm2, mm2

				movq		[tmmxf + 2 * 16 + 0], mm7

				pmulhw	mm3, [tmmxf + 2 * 16 + 8]
				paddsw	mm3, mm3

				movq		[tmmxf + 2 * 16 + 8], mm7

				movq		mm4, mm0
				paddsw	mm0, mm2	// a1 0
				psubsw	mm4, mm2 // a2 0

				movq		mm5, mm1
				paddsw	mm1, mm3 // a1 1
				psubsw	mm5, mm3 // a2 1

				movq		mm3, [tmmxf + 1 * 16 + 0]
				movq		mm2, [pC3pC3pC3pC3a]
				pmulhw	mm2, mm3
				paddsw	mm2, mm3

				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC7pC7pC7pC7a]
				psubsw	mm2, mm3

				movq		mm6, mm0
				paddsw	mm0, mm2		// r1	0
				psubsw	mm6, mm2		// r6	0

				movq		mm3, [tmmxf + 1 * 16 + 8]
				movq		mm2, [pC3pC3pC3pC3a]
				pmulhw	mm2, mm3
				paddsw	mm2, mm3

				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC7pC7pC7pC7a]
				psubsw	mm2, mm3

				movq		mm7, mm1
				paddsw	mm1, mm2		// r1 1
				psubsw	mm7, mm2		// r6 1

				psraw		mm0, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm1, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx + edx], mm0			// r1
				movq		[ebx + edx+8], mm1			// r1
				movq		[ecx + 2 * edx], mm6	// r6
				movq		[ecx + 2 * edx+8], mm7	// r6

				//////
				pxor		mm7, mm7

				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, [pC5pC5pC5pC5a]
				paddsw	mm2, mm2
				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC1pC1pC1pC1a]
				paddsw	mm3, [tmmxf + 3 * 16 + 0]
				psubsw	mm2, mm3

				movq		[tmmxf + 1 * 16 + 0], mm7
				movq		[tmmxf + 3 * 16 + 0], mm7

				movq		mm6, mm4
				paddsw	mm4, mm2		// r2	0
				psubsw	mm6, mm2		// r5	0

				movq		mm2, [tmmxf + 1 * 16 + 8]
				pmulhw	mm2, [pC5pC5pC5pC5a]
				paddsw	mm2, mm2
				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC1pC1pC1pC1a]
				paddsw	mm3, [tmmxf + 3 * 16 + 8]
				psubsw	mm2, mm3

				movq		[tmmxf + 1 * 16 + 8], mm7
				movq		[tmmxf + 3 * 16 + 8], mm7

				movq		mm7, mm5
				paddsw	mm5, mm2		// r2 1
				psubsw	mm7, mm2		// r5 1
				psraw		mm4, SECOND_SHIFT + 2

				movq		[ebx + 2 * edx], mm4			// r2
				psraw		mm5, SECOND_SHIFT + 2

				movq		[ebx + 2 * edx+8], mm5			// r2
				psraw		mm6, SECOND_SHIFT + 2

				movq		[ecx + edx], mm6	// r5
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ecx + edx+8], mm7	// r5
				}
			break;
		default:
			__asm
				{
				movq		mm6, [RoundSecond0a]
				lea		eax, [tmmxf]

				movq		mm0, [eax + 0 * 16 + 0]
				paddsw	mm0, [eax + 4 * 16 + 0]
				paddsw	mm0, mm6

				movq		mm1, [eax + 0 * 16 + 8]
				paddsw	mm1, [eax + 4 * 16 + 8]
				paddsw	mm1, mm6

				movq		mm3, [pC6pC6pC6pC6a]
				movq		mm2, [eax + 6 * 16 + 0]
				pmulhw	mm2, mm3
				paddsw	mm2, mm2

				movq		mm5, [eax + 2 * 16 + 0]
				movq		mm4, [pC2pC2pC2pC2a]
				pmulhw	mm4, mm5

				paddsw	mm2, mm5
				paddsw	mm2, mm4 // y2 0

				pmulhw	mm3, [eax + 6 * 16 + 8]
				paddsw	mm3, mm3

				movq		mm5, [eax + 2 * 16 + 8]
				movq		mm4, [pC2pC2pC2pC2a]
				pmulhw	mm4, mm5

				paddsw	mm3, mm5
				paddsw	mm3, mm4 // y2 1

				movq		mm4, mm0
				paddsw	mm0, mm2	// a0 0
				psubsw	mm4, mm2 // a3 0

				movq		mm5, mm1
				paddsw	mm1, mm3 // a0 1
				psubsw	mm5, mm3 // a3 1

				mov		ebx, [mb]
				mov		edx, [stride]
				lea		ecx, [ebx+4*edx]
				lea		esi, [edx+2*edx]


				movq		mm2, [pC1pC1pC1pC1a]
				movq		mm6, [eax + 1 * 16 + 0]
				pmulhw	mm2, mm6
				paddsw	mm2, mm6

				movq		mm3, [eax + 3 * 16 + 0]

				paddsw	mm2, mm3

				pmulhw	mm3, [pC3pC3pC3pC3a]

				paddsw	mm2, mm3

				movq		mm3, [eax + 5 * 16 + 0]
				pmulhw	mm3, [pC5pC5pC5pC5a]
				paddsw	mm3, mm3

				paddsw	mm2, mm3

				movq		mm3, [eax + 7 * 16 + 0]
				pmulhw	mm3, [pC7pC7pC7pC7a]

				paddsw	mm2, mm3

				movq		mm6, mm0
				paddsw	mm0, mm2		// r0	0
				psubsw	mm6, mm2		// r7	0

				movq		mm2, [pC1pC1pC1pC1a]
				movq		mm3, [eax + 1 * 16 + 8]
				pmulhw	mm2, mm3
				paddsw	mm2, mm3

				movq		mm3, [eax + 3 * 16 + 8]

				paddsw	mm2, mm3

				pmulhw	mm3, [pC3pC3pC3pC3a]

				paddsw	mm2, mm3

				movq		mm3, [eax + 5 * 16 + 8]
				pmulhw	mm3, [pC5pC5pC5pC5a]
				paddsw	mm3, mm3

				paddsw	mm2, mm3

				movq		mm3, [eax + 7 * 16 + 8]
				pmulhw	mm3, [pC7pC7pC7pC7a]

				paddsw	mm2, mm3

				movq		mm7, mm1
				paddsw	mm1, mm2		// r0 1
				psubsw	mm7, mm2		// r7 1

				psraw		mm0, SECOND_SHIFT + 2
				psraw		mm1, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx], mm0			// r0
				movq		[ebx+8], mm1			// r0
				movq		[ecx + esi], mm6	// r7
				movq		[ecx + esi+8], mm7	// r7

				//////

				movq		mm2, [eax + 1 * 16 + 0]
				pmulhw	mm2, [pC7pC7pC7pC7a]

				movq		mm3, [eax + 3 * 16 + 0]
				pmulhw	mm3, [pC5pC5pC5pC5a]
				paddsw	mm3, mm3

				psubsw	mm2, mm3

				movq		mm3, [eax + 5 * 16 + 0]
				paddsw	mm2, mm3
				pmulhw	mm3, [pC3pC3pC3pC3a]

				paddsw	mm2, mm3

				movq		mm3, [eax + 7 * 16 + 0]
				psubsw	mm2, mm3
				pmulhw	mm3, [pC1pC1pC1pC1a]

				psubsw	mm2, mm3

				movq		mm6, mm4
				paddsw	mm4, mm2		// r3	0
				psubsw	mm6, mm2		// r4	0

				movq		mm2, [eax + 1 * 16 + 8]
				pmulhw	mm2, [pC7pC7pC7pC7a]

				movq		mm3, [eax + 3 * 16 + 8]
				pmulhw	mm3, [pC5pC5pC5pC5a]
				paddsw	mm3, mm3

				psubsw	mm2, mm3

				movq		mm3, [eax + 5 * 16 + 8]

				paddsw	mm2, mm3

				pmulhw	mm3, [pC3pC3pC3pC3a]

				paddsw	mm2, mm3

				movq		mm3, [eax + 7 * 16 + 8]

				psubsw	mm2, mm3

				pmulhw	mm3, [pC1pC1pC1pC1a]

				psubsw	mm2, mm3

				movq		mm7, mm5
				paddsw	mm5, mm2		// r3 1
				psubsw	mm7, mm2		// r4 1

				psraw		mm4, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm5, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx + esi], mm4			// r0
				movq		[ebx + esi+8], mm5			// r
				movq		[ecx], mm6	// r7
				movq		[ecx+8], mm7	// r7



				//////////////////////////////

				pxor		mm7, mm7

				movq		mm6, [RoundSecond1a]

				movq		mm0, [eax + 0 * 16 + 0]
				psubsw	mm0, [eax + 4 * 16 + 0]
				paddsw	mm0, mm6

				movq		mm1, [eax + 0 * 16 + 8]
				psubsw	mm1, [eax + 4 * 16 + 8]
				paddsw	mm1, mm6

				movq		[eax + 0 * 16 + 0], mm7
				movq		[eax + 4 * 16 + 0], mm7
				movq		[eax + 0 * 16 + 8], mm7
				movq		[eax + 4 * 16 + 8], mm7

				movq		mm2, [eax + 2 * 16 + 0]
				movq		mm3, [pC6pC6pC6pC6a]

				pmulhw	mm2, mm3
				paddsw	mm2, mm2

				movq		mm4, [eax + 6 * 16 + 0]
				movq		mm5, [pC2pC2pC2pC2a]
				psubsw	mm2, mm4
				pmulhw	mm4, mm5

				psubsw	mm2, mm4 // y2 0

				pmulhw	mm3, [eax + 2 * 16 + 8]
				paddsw	mm3, mm3

				movq		mm4, [eax + 6 * 16 + 8]
				psubsw	mm3, mm4
				pmulhw	mm4, mm5

				psubsw	mm3, mm4 // y2 1

				movq		mm4, mm0
				paddsw	mm0, mm2	// a1 0
				psubsw	mm4, mm2 // a2 0

				movq		mm5, mm1
				paddsw	mm1, mm3 // a1 1
				psubsw	mm5, mm3 // a2 1

				movq		[eax + 2 * 16 + 0], mm7
				movq		[eax + 6 * 16 + 0], mm7
				movq		[eax + 2 * 16 + 8], mm7
				movq		[eax + 6 * 16 + 8], mm7

				movq		mm6, [eax + 1 * 16 + 0]
				movq		mm2, [pC3pC3pC3pC3a]
				pmulhw	mm2, mm6
				paddsw	mm2, mm6

				movq		mm3, [eax + 3 * 16 + 0]
				pmulhw	mm3, [pC7pC7pC7pC7a]

				psubsw	mm2, mm3

				movq		mm3, [eax + 5 * 16 + 0]
				psubsw	mm2, mm3
				pmulhw	mm3, [pC1pC1pC1pC1a]

				psubsw	mm2, mm3

				movq		mm3, [eax + 7 * 16 + 0]
				pmulhw	mm3, [pC5pC5pC5pC5a]
				paddsw	mm3, mm3

				psubsw	mm2, mm3

				movq		mm6, mm0
				paddsw	mm0, mm2		// r1	0
				psubsw	mm6, mm2		// r6	0

				movq		mm7, [eax + 1 * 16 + 8]
				movq		mm2, [pC3pC3pC3pC3a]
				pmulhw	mm2, mm7
				paddsw	mm2, mm7

				movq		mm3, [eax + 3 * 16 + 8]
				pmulhw	mm3, [pC7pC7pC7pC7a]

				psubsw	mm2, mm3

				movq		mm3, [eax + 5 * 16 + 8]
				psubsw	mm2, mm3
				pmulhw	mm3, [pC1pC1pC1pC1a]

				psubsw	mm2, mm3

				movq		mm3, [eax + 7 * 16 + 8]
				pmulhw	mm3, [pC5pC5pC5pC5a]
				paddsw	mm3, mm3

				psubsw	mm2, mm3

				movq		mm7, mm1
				paddsw	mm1, mm2		// r1 1
				psubsw	mm7, mm2		// r6 1

				psraw		mm0, SECOND_SHIFT + 2
				psraw		mm1, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx + edx], mm0			// r1
				movq		[ebx + edx+8], mm1			// r1
				movq		[ecx + 2 * edx], mm6	// r6
				movq		[ecx + 2 * edx+8], mm7	// r6
				//////
				pxor		mm1, mm1

				movq		mm2, [eax + 1 * 16 + 0]
				pmulhw	mm2, [pC5pC5pC5pC5a]
				paddsw	mm2, mm2

				movq		mm3, [eax + 3 * 16 + 0]
				psubsw	mm2, mm3
				pmulhw	mm3, [pC1pC1pC1pC1a]

				psubsw	mm2, mm3

				movq		mm3, [eax + 5 * 16 + 0]
				pmulhw	mm3, [pC7pC7pC7pC7a]

				paddsw	mm2, mm3

				movq		mm3, [eax + 7 * 16 + 0]
				paddsw	mm2, mm3
				pmulhw	mm3, [pC3pC3pC3pC3a]

				paddsw	mm2, mm3

				movq		[eax + 1 * 16 + 0], mm1
				movq		[eax + 3 * 16 + 0], mm1
				movq		[eax + 5 * 16 + 0], mm1
				movq		[eax + 7 * 16 + 0], mm1

				movq		mm6, mm4
				paddsw	mm4, mm2		// r2	0
				psubsw	mm6, mm2		// r5	0

				movq		mm2, [eax + 1 * 16 + 8]
				pmulhw	mm2, [pC5pC5pC5pC5a]
				paddsw	mm2, mm2

				movq		mm3, [eax + 3 * 16 + 8]
				psubsw	mm2, mm3
				pmulhw	mm3, [pC1pC1pC1pC1a]

				psubsw	mm2, mm3

				movq		mm3, [eax + 5 * 16 + 8]
				pmulhw	mm3, [pC7pC7pC7pC7a]

				paddsw	mm2, mm3

				movq		mm3, [eax + 7 * 16 + 8]
				paddsw	mm2, mm3
				pmulhw	mm3, [pC3pC3pC3pC3a]

				paddsw	mm2, mm3

				movq		[eax + 1 * 16 + 8], mm1
				movq		[eax + 3 * 16 + 8], mm1
				movq		[eax + 5 * 16 + 8], mm1
				movq		[eax + 7 * 16 + 8], mm1


				movq		mm7, mm5
				paddsw	mm5, mm2		// r2 1
				psubsw	mm7, mm2		// r5 1

				psraw		mm4, SECOND_SHIFT + 2
				psraw		mm5, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx + 2 * edx], mm4			// r2
				movq		[ebx + 2 * edx+8], mm5			// r2
				movq		[ecx + edx], mm6	// r5
				movq		[ecx + edx+8], mm7	// r5
				}
		}
	}
#endif



void GenericMMXMacroBlockIDCTDecoder::InverseBYTEIntraDCT(BYTE * mb, int stride, DCTMulTable * table, int numLines, int numColumns)
	{
	static MMXQWORD RoundOne0    = {ROUND_ONE, ROUND_ONE - 1, ROUND_ONE, ROUND_ONE - 1};
	static MMXQWORD RoundSingle0 = {ROUND_SINGLE, ROUND_SINGLE - 1, ROUND_SINGLE, ROUND_SINGLE - 1};
	static MMXQWORD RoundSecond0 = {ROUND_SECOND, ROUND_SECOND - 1, ROUND_SECOND, ROUND_SECOND - 1};

	static MMXQWORD RoundOne1    = {ROUND_ONE - 1, ROUND_ONE, ROUND_ONE - 1, ROUND_ONE};
	static MMXQWORD RoundSingle1 = {ROUND_SINGLE - 1, ROUND_SINGLE, ROUND_SINGLE - 1, ROUND_SINGLE};
	static MMXQWORD RoundSecond1 = {ROUND_SECOND - 1, ROUND_SECOND, ROUND_SECOND - 1, ROUND_SECOND};

	switch (numColumns)
		{
		case 1:
			if (numLines == 1)
				{
				__asm
					{
					mov	ebx, [mb]
					mov	edx, [stride]
					mov	esi, [table]

					movq			mm0, [tmmxf]

					punpcklwd	mm0, mm0

					punpckldq	mm0, mm0

					pmulhw		mm0, [esi].tpC8pC8pC8pC8


					pxor			mm2, mm2

					lea			eax, [ebx+2*edx]

					lea			ecx, [ebx+2*edx]

					movq			mm1, mm0
					lea			eax, [eax+edx]

					paddw			mm0, [RoundOne0]

					movq			[tmmxf], mm2
					psraw			mm0, ONE_SHIFT

					paddw			mm1, [RoundOne1]
					packuswb		mm0, mm0

					psraw			mm1, ONE_SHIFT

					movq			[ebx], mm0
					packuswb		mm1, mm1

					movq			[ebx+2*edx], mm0

					movq			[ebx+4*edx], mm0

					movq			[ecx+4*edx], mm0

					movq			[ebx+edx], mm1

					movq			[eax], mm1

					movq			[eax+2*edx], mm1

					movq			[eax+4*edx], mm1
					}

				return;
				}
			else
				{
				__asm
					{
					lea	eax, tmmxf
					mov	ecx, [numLines]
					mov	esi, [table]
loop11:
					movq	mm0, [eax+0]

					pmaddwd mm0, [esi].tpC8000000000

					add	eax, 16

					psrad			mm0, FIRST_SHIFT

					punpckldq	mm0, mm0

					packssdw		mm0, mm0

					movq	[eax - 16], mm0

					movq	[eax - 8], mm0

					sub	ecx, 1
					jne	loop11
					}
				}
			break;
		case 2:
			__asm
				{
				mov	esi, [table]
				lea			eax, tmmxf
				mov			ecx, [numLines]
loop12:
				movq			mm1, [eax+8]

				punpcklwd	mm1, [eax+0]

				punpckldq	mm1, mm1

				movq			mm4, mm1

				pmaddwd		mm1, [esi].tpC8pC7pC8pC5
				movq			mm2, mm4

				pmaddwd		mm2, [esi].tpC8pC3pC8pC1
				movq			mm3, mm4

				pmaddwd		mm3, [esi].tpC8mC1pC8mC3

				pmaddwd		mm4, [esi].tpC8mC5pC8mC7
				psrad			mm1, FIRST_SHIFT

				psrad			mm2, FIRST_SHIFT
				add			eax, 16

				psrad			mm3, FIRST_SHIFT

				psrad			mm4, FIRST_SHIFT

				packssdw		mm2, mm1

				packssdw		mm4, mm3

				movq	[eax - 16], mm2

				movq	[eax - 8], mm4

				sub	ecx, 1
				jne	loop12
				}
			break;
		case 3:
			__asm
				{
				mov	esi, [table]
				lea			eax, tmmxf
				mov			ecx, [numLines]
loop13:
				movq			mm0, [eax+0]

				movq			mm4, [eax+8]
				movq			mm2, mm0

				pmaddwd		mm0, [esi].tpC8000000000
				psrlq			mm2, 32

				punpcklwd	mm4, mm2
				add			eax, 16

				punpckldq	mm4, mm4

				movq			mm1, mm4
				punpckldq	mm0, mm0

				pmaddwd		mm1, [esi].tmC2pC7mC6pC5
				movq			mm2, mm4

				pmaddwd		mm2, [esi].tpC6pC3pC2pC1
				movq			mm3, mm4

				pmaddwd		mm3, [esi].tpC2mC1pC6mC3
				psrad			mm0, FIRST_SHIFT

				pmaddwd		mm4, [esi].tmC6mC5mC2mC7
				psrad			mm1, FIRST_SHIFT

				psrad			mm2, FIRST_SHIFT

				psrad			mm3, FIRST_SHIFT

				psrad			mm4, FIRST_SHIFT

				packssdw		mm0, mm0

				packssdw		mm2, mm1

				packssdw		mm4, mm3
				paddsw		mm2, mm0

				paddsw		mm4, mm0

				movq	[eax - 16], mm2

				movq	[eax - 8], mm4

				sub	ecx, 1
				jne	loop13
				}
			break;
		case 4:
			__asm
				{
				mov	esi, [table]
				lea			eax, tmmxf
				mov			ecx, [numLines]

loop14:
				movq			mm0, [eax+0]	// 00 f2 00 f0

				movq			mm1, [eax+8]	// 00 f3 00 f1
				psllq			mm0, 32

				punpckhwd	mm0, [eax+0]

				psllq			mm1, 32

				punpckhwd	mm1, [eax+8]

				punpckldq	mm0, mm0			// f2 f0 f2 f0

				punpckldq	mm1, mm1			// f3 f1 f3 f1
				movq			mm2, mm0

				pmaddwd		mm0, [esi].tpC6pC8pC2pC8
				movq			mm3, mm1

				pmaddwd		mm2, [esi].tmC2pC8mC6pC8

				pmaddwd		mm1, [esi].tmC7pC3pC3pC1

				pmaddwd		mm3, [esi].tmC5pC7mC1pC5
				movq			mm4, mm0

				movq			mm5, mm2
				paddd			mm0, mm1

				psrad			mm0, FIRST_SHIFT
				paddd			mm2, mm3

				psrad			mm2, FIRST_SHIFT
				psubd			mm4, mm1

				psrad			mm4, FIRST_SHIFT
				psubd			mm5, mm3

				psrad			mm5, FIRST_SHIFT

				packssdw		mm5, mm4
				add			eax, 16

				movq			mm4, mm5
				packssdw		mm0, mm2

				pslld			mm5, 16

				psrld			mm4, 16

				por			mm4, mm5

				movq			[eax-16], mm0

				movq			[eax-8], mm4

				sub			ecx, 1
				jne			loop14
				}
			break;
		default:
			__asm
				{
				mov	esi, [table]
				lea			eax, [tmmxf]
				mov			ecx, [numLines]
loop18a:
				movq			mm0, [eax+0]

				movq			mm1, [eax+0]

				punpckldq	mm0, mm0					// f4 f0 f4 f0

				pmaddwd		mm0, [esi].tmC8pC8pC8pC8
				punpckhdq	mm1, mm1					// f6 f2 f6 f2

				pmaddwd		mm1, [esi].tmC2pC6pC6pC2

				movq			mm2, mm0
				paddd			mm0, mm1					// a1 a0
				psubd			mm2, mm1					// a3 a2

				punpckldq	mm1, mm2
				punpckhdq	mm2, mm1					// a2 a3

				movq			mm1, [eax+8]			// f7 f3 f5 f1

				movq			mm3, [eax+8]

				punpckldq	mm1, mm1					// f5 f1 f5 f1
				punpckhdq	mm3, mm3					// f7 f3 f7 f3

				movq			mm4, [esi].tmC1pC3pC5pC1
				pmaddwd		mm4, mm1					// y6a y4a
				pmaddwd		mm1, [esi].tpC3pC7pC7pC5	// y5a y7a

				movq			mm5, [esi].tmC5mC7pC7pC3
				pmaddwd		mm5, mm3					// y6b y4b
				pmaddwd		mm3, [esi].tmC1mC5pC3mC1	// y5b y7b

				paddd			mm4, mm5
				paddd			mm1, mm3

				movq			mm3, mm0
				movq			mm5, mm2

				paddd			mm0, mm4					// t1 t0
				paddd			mm2, mm1					// t2 t3

				psrad			mm0, FIRST_SHIFT
				psrad			mm2, FIRST_SHIFT

				psubd			mm3, mm4					// t6 t7
				psubd			mm5, mm1					// t4 t5

				psrad			mm3, FIRST_SHIFT
				psrad			mm5, FIRST_SHIFT

				packssdw		mm0, mm2					// t3 t2 t1 t0
				packssdw		mm5, mm3					// t6 t7 t4 t5

				movq			mm3, mm5
				pslld			mm5, 16

				movq			[eax], mm0
				psrld			mm3, 16
				por			mm3, mm5					// t4 t5 t6 t7

				movq			[eax+8], mm3

				add			eax, 16
				sub			ecx, 1
				jne			loop18a
				}
			break;
		}

	switch (numLines)
		{
		case 1:
			__asm
				{
				movq		mm0, [tmmxf + 0 * 16 + 0]
				paddsw	mm0, [RoundSingle0]
				pxor		mm7, mm7
				movq		mm1, [tmmxf + 0 * 16 + 8]
				paddsw	mm1, [RoundSingle1]
				psraw		mm0, 7
				psraw		mm1, 7
				movq		[tmmxf + 0 * 16 + 0], mm7
				mov		ebx, [mb]
				mov		edx, [stride]
				movq		[tmmxf + 0 * 16 + 8], mm7
				lea		ecx, [ebx+4*edx]
				packuswb	mm0, mm1

				movq		[ebx], mm0
				lea		esi, [edx+2*edx]
				movq		[ebx+edx], mm0
				movq		[ebx+2*edx], mm0
				movq		[ebx+esi], mm0
				movq		[ecx], mm0
				movq		[ecx+edx], mm0
				movq		[ecx+2*edx], mm0
				movq		[ecx+esi], mm0
				}
			break;
		case 2:
			__asm
				{
				mov		ebx, [mb]
				mov		edx, [stride]
				lea		ecx, [ebx+4*edx]
				lea		esi, [edx+2*edx]

				movq		mm0, [tmmxf + 0 * 16 + 0]
				psraw		mm0, 2
				movq		mm1, [tmmxf + 0 * 16 + 8]
				psraw		mm1, 2
				paddsw	mm0, [RoundSecond0]
				paddsw	mm1, [RoundSecond0]

				pxor		mm7, mm7
				movq		[tmmxf + 0 * 16 + 0], mm7
				movq		[tmmxf + 0 * 16 + 8], mm7


				//////////////////////

				movq		mm3, [pC1pC1pC1pC1]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm4, mm0
				movq		mm5, mm0
				paddsw	mm4, mm2
				psubsw	mm5, mm2

				movq		mm6, mm1
				movq		mm7, mm1
				paddsw	mm6, mm3
				psubsw	mm7, mm3

				psraw		mm4, 5
				psraw		mm5, 5
				psraw		mm6, 5
				psraw		mm7, 5

				packuswb	mm4, mm6
				packuswb	mm5, mm7

				movq		[ebx], mm4
				movq		[ecx+esi], mm5


				movq		mm3, [pC3pC3pC3pC3]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm4, mm0
				movq		mm5, mm0
				paddsw	mm4, mm2
				psubsw	mm5, mm2

				movq		mm6, mm1
				movq		mm7, mm1
				paddsw	mm6, mm3
				psubsw	mm7, mm3

				psraw		mm4, 5
				psraw		mm5, 5
				psraw		mm6, 5
				psraw		mm7, 5

				packuswb	mm4, mm6
				packuswb	mm5, mm7

				movq		[ebx+edx], mm4
				movq		[ecx+2*edx], mm5


				movq		mm3, [pC5pC5pC5pC5]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm4, mm0
				movq		mm5, mm0
				paddsw	mm4, mm2
				psubsw	mm5, mm2

				movq		mm6, mm1
				movq		mm7, mm1
				paddsw	mm6, mm3
				psubsw	mm7, mm3

				psraw		mm4, 5
				psraw		mm5, 5
				psraw		mm6, 5
				psraw		mm7, 5

				packuswb	mm4, mm6
				packuswb	mm5, mm7

				movq		[ebx+2*edx], mm4
				movq		[ecx+edx], mm5


				movq		mm3, [pC7pC7pC7pC7]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm4, mm0
				movq		mm5, mm0
				paddsw	mm4, mm2
				psubsw	mm5, mm2

				movq		mm6, mm1
				movq		mm7, mm1
				paddsw	mm6, mm3
				psubsw	mm7, mm3

				psraw		mm4, 5
				psraw		mm5, 5
				psraw		mm6, 5
				psraw		mm7, 5

				packuswb	mm4, mm6
				packuswb	mm5, mm7

				movq		[ebx+esi], mm4
				movq		[ecx], mm5

				pxor		mm7, mm7
				movq		[tmmxf + 1 * 16 + 0], mm7
				movq		[tmmxf + 1 * 16 + 8], mm7
				}

			break;
		case 3:
			__asm
				{
				mov		ebx, [mb]
				mov		edx, [stride]
				lea		ecx, [ebx+4*edx]
				lea		esi, [edx+2*edx]

				movq		mm0, [tmmxf + 0 * 16 + 0]
				psraw		mm0, 2
				movq		mm1, [tmmxf + 0 * 16 + 8]
				psraw		mm1, 2
				movq		mm3, [pC2pC2pC2pC2]
				movq		mm2, [tmmxf + 2 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 2 * 16 + 8]
				paddsw	mm0, [RoundSecond0]
				paddsw	mm1, [RoundSecond0]
				movq		mm4, mm0
				movq		mm5, mm1

				paddsw	mm0, mm2
				paddsw	mm1, mm3
				psubsw	mm4, mm2
				psubsw	mm5, mm3

				/////////////

				movq		mm3, [pC1pC1pC1pC1]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm6, mm0
				paddsw	mm0, mm2
				psubsw	mm6, mm2

				movq		mm7, mm1
				paddsw	mm1, mm3
				psubsw	mm7, mm3

				psraw		mm0, 5
				psraw		mm1, 5
				psraw		mm6, 5
				psraw		mm7, 5

				packuswb	mm0, mm1
				packuswb	mm6, mm7

				movq		[ebx], mm0
				movq		[ecx+esi], mm6

				//////////

				movq		mm3, [pC7pC7pC7pC7]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm6, mm4
				paddsw	mm4, mm2
				psubsw	mm6, mm2

				movq		mm7, mm5
				paddsw	mm5, mm3
				psubsw	mm7, mm3

				psraw		mm4, 5
				psraw		mm5, 5
				psraw		mm6, 5
				psraw		mm7, 5

				packuswb	mm4, mm5
				packuswb	mm6, mm7

				movq		[ebx+esi], mm4
				movq		[ecx], mm6

				////////////////////////////

				movq		mm0, [tmmxf + 0 * 16 + 0]
				psraw		mm0, 2
				movq		mm1, [tmmxf + 0 * 16 + 8]
				psraw		mm1, 2
				movq		mm3, [pC6pC6pC6pC6]
				movq		mm2, [tmmxf + 2 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 2 * 16 + 8]
				paddsw	mm0, [RoundSecond0]
				paddsw	mm1, [RoundSecond0]
				movq		mm4, mm0
				movq		mm5, mm1

				pxor		mm7, mm7
				movq		[tmmxf + 0 * 16 + 0], mm7
				movq		[tmmxf + 0 * 16 + 8], mm7
				movq		[tmmxf + 2 * 16 + 0], mm7
				movq		[tmmxf + 2 * 16 + 8], mm7

				paddsw	mm0, mm2
				paddsw	mm1, mm3
				psubsw	mm4, mm2
				psubsw	mm5, mm3

				/////////////

				movq		mm3, [pC3pC3pC3pC3]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm6, mm0
				paddsw	mm0, mm2
				psubsw	mm6, mm2

				movq		mm7, mm1
				paddsw	mm1, mm3
				psubsw	mm7, mm3

				psraw		mm0, 5
				psraw		mm1, 5
				psraw		mm6, 5
				psraw		mm7, 5

				packuswb	mm0, mm1
				packuswb	mm6, mm7

				movq		[ebx+edx], mm0
				movq		[ecx+2*edx], mm6

				//////////

				movq		mm3, [pC5pC5pC5pC5]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm6, mm4
				paddsw	mm4, mm2
				psubsw	mm6, mm2

				movq		mm7, mm5
				paddsw	mm5, mm3
				psubsw	mm7, mm3

				psraw		mm4, 5
				psraw		mm5, 5
				psraw		mm6, 5
				psraw		mm7, 5

				packuswb	mm4, mm5
				packuswb	mm6, mm7

				movq		[ebx+2*edx], mm4
				movq		[ecx+edx], mm6

				pxor		mm7, mm7
				movq		[tmmxf + 1 * 16 + 0], mm7
				movq		[tmmxf + 1 * 16 + 8], mm7
				}
			break;
		case 4:
			__asm
				{
				mov		ebx, [mb]
				mov		edx, [stride]
				lea		ecx, [ebx+4*edx]
				lea		esi, [edx+2*edx]

				movq		mm0, [tmmxf + 0 * 16 + 0]
				psraw		mm0, 2
				paddsw	mm0, [RoundSecond0]

				movq		mm2, [tmmxf + 2 * 16 + 0]
				pmulhw	mm2, [pC2pC2pC2pC2]
				movq		mm1, [tmmxf + 0 * 16 + 8]
				psraw		mm1, 2
				paddsw	mm1, [RoundSecond0]

				movq		mm3, [tmmxf + 2 * 16 + 8]
				pmulhw	mm3, [pC2pC2pC2pC2]

				movq		mm4, mm0
				paddsw	mm0, mm2	// a0 0
				psubsw	mm4, mm2 // a3 0

				movq		mm5, mm1
				paddsw	mm1, mm3 // a0 1
				psubsw	mm5, mm3 // a3 1

				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, [pC1pC1pC1pC1]
				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC3pC3pC3pC3]
				paddsw	mm2, mm3

				movq		mm6, mm0
				paddsw	mm0, mm2		// r0	0
				psubsw	mm6, mm2		// r7	0

				movq		mm2, [tmmxf + 1 * 16 + 8]
				pmulhw	mm2, [pC1pC1pC1pC1]
				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC3pC3pC3pC3]
				paddsw	mm2, mm3

				movq		mm7, mm1
				paddsw	mm1, mm2		// r0 1
				psubsw	mm7, mm2		// r7 1

				psraw		mm0, 5
				psraw		mm6, 5
				psraw		mm1, 5
				psraw		mm7, 5

				packuswb	mm0, mm1
				packuswb	mm6, mm7

				movq		[ebx], mm0			// r0
				movq		[ecx + esi], mm6	// r7

				//////

				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, [pC7pC7pC7pC7]
				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC5pC5pC5pC5]
				psubsw	mm2, mm3

				movq		mm6, mm4
				paddsw	mm4, mm2		// r3	0
				psubsw	mm6, mm2		// r4	0

				movq		mm2, [tmmxf + 1 * 16 + 8]
				pmulhw	mm2, [pC7pC7pC7pC7]
				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC5pC5pC5pC5]
				psubsw	mm2, mm3

				movq		mm7, mm5
				paddsw	mm5, mm2		// r3 1
				psubsw	mm7, mm2		// r4 1

				psraw		mm4, 5
				psraw		mm6, 5
				psraw		mm5, 5
				psraw		mm7, 5

				packuswb	mm4, mm5
				packuswb	mm6, mm7

				movq		[ebx + esi], mm4			// r0
				movq		[ecx], mm6	// r7

				//////////////////////////////

				pxor		mm7, mm7

				movq		mm0, [tmmxf + 0 * 16 + 0]
				psraw		mm0, 2
				paddsw	mm0, [RoundSecond0]

				movq		[tmmxf + 0 * 16 + 0], mm7

				movq		mm1, [tmmxf + 0 * 16 + 8]
				psraw		mm1, 2
				paddsw	mm1, [RoundSecond0]

				movq		[tmmxf + 0 * 16 + 8], mm7

				movq		mm2, [tmmxf + 2 * 16 + 0]
				pmulhw	mm2, [pC6pC6pC6pC6]

				movq		[tmmxf + 2 * 16 + 0], mm7

				movq		mm3, [tmmxf + 2 * 16 + 8]
				pmulhw	mm3, [pC6pC6pC6pC6]

				movq		[tmmxf + 2 * 16 + 8], mm7

				movq		mm4, mm0
				paddsw	mm0, mm2	// a1 0
				psubsw	mm4, mm2 // a2 0

				movq		mm5, mm1
				paddsw	mm1, mm3 // a1 1
				psubsw	mm5, mm3 // a2 1

				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, [pC3pC3pC3pC3]
				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC7pC7pC7pC7]
				psubsw	mm2, mm3

				movq		mm6, mm0
				paddsw	mm0, mm2		// r1	0
				psubsw	mm6, mm2		// r6	0

				movq		mm2, [tmmxf + 1 * 16 + 8]
				pmulhw	mm2, [pC3pC3pC3pC3]
				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC7pC7pC7pC7]
				psubsw	mm2, mm3

				movq		mm7, mm1
				paddsw	mm1, mm2		// r1 1
				psubsw	mm7, mm2		// r6 1

				psraw		mm0, 5
				psraw		mm6, 5
				psraw		mm1, 5
				psraw		mm7, 5

				packuswb	mm0, mm1
				packuswb	mm6, mm7

				movq		[ebx + edx], mm0			// r1
				movq		[ecx + 2 * edx], mm6	// r6

				//////
				pxor		mm7, mm7

				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, [pC5pC5pC5pC5]
				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC1pC1pC1pC1]
				psubsw	mm2, mm3

				movq		[tmmxf + 1 * 16 + 0], mm7
				movq		[tmmxf + 3 * 16 + 0], mm7

				movq		mm6, mm4
				paddsw	mm4, mm2		// r2	0
				psubsw	mm6, mm2		// r5	0

				movq		mm2, [tmmxf + 1 * 16 + 8]
				pmulhw	mm2, [pC5pC5pC5pC5]
				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC1pC1pC1pC1]
				psubsw	mm2, mm3

				movq		[tmmxf + 1 * 16 + 8], mm7
				movq		[tmmxf + 3 * 16 + 8], mm7

				movq		mm7, mm5
				paddsw	mm5, mm2		// r2 1
				psubsw	mm7, mm2		// r5 1

				psraw		mm4, 5
				psraw		mm6, 5
				psraw		mm5, 5
				psraw		mm7, 5

				packuswb	mm4, mm5
				packuswb	mm6, mm7

				movq		[ebx + 2 * edx], mm4			// r2
				movq		[ecx + edx], mm6	// r5
				}
			break;
		default:

			__asm
				{
				mov		ebx, [mb]
				mov		edx, [stride]
				lea		ecx, [ebx+4*edx]
				lea		esi, [edx+2*edx]

				movq		mm0, [tmmxf + 0 * 16 + 0]
				paddsw	mm0, [tmmxf + 4 * 16 + 0]
				psraw		mm0, 2
				paddsw	mm0, [RoundSecond0]

				movq		mm1, [tmmxf + 0 * 16 + 8]
				paddsw	mm1, [tmmxf + 4 * 16 + 8]
				psraw		mm1, 2
				paddsw	mm1, [RoundSecond0]

				movq		mm2, [tmmxf + 2 * 16 + 0]
				pmulhw	mm2, [pC2pC2pC2pC2]
				movq		mm3, [tmmxf + 6 * 16 + 0]
				pmulhw	mm3, [pC6pC6pC6pC6]
				paddsw	mm2, mm3 // y2 0

				movq		mm3, [tmmxf + 2 * 16 + 8]
				pmulhw	mm3, [pC2pC2pC2pC2]
				movq		mm4, [tmmxf + 6 * 16 + 8]
				pmulhw	mm4, [pC6pC6pC6pC6]
				paddsw	mm3, mm4 // y2 1

				movq		mm4, mm0
				paddsw	mm0, mm2	// a0 0
				psubsw	mm4, mm2 // a3 0

				movq		mm5, mm1
				paddsw	mm1, mm3 // a0 1
				psubsw	mm5, mm3 // a3 1

				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, [pC1pC1pC1pC1]
				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC3pC3pC3pC3]
				paddsw	mm2, mm3
				movq		mm3, [tmmxf + 5 * 16 + 0]
				pmulhw	mm3, [pC5pC5pC5pC5]
				paddsw	mm2, mm3
				movq		mm3, [tmmxf + 7 * 16 + 0]
				pmulhw	mm3, [pC7pC7pC7pC7]
				paddsw	mm2, mm3

				movq		mm6, mm0
				paddsw	mm0, mm2		// r0	0
				psubsw	mm6, mm2		// r7	0

				movq		mm2, [tmmxf + 1 * 16 + 8]
				pmulhw	mm2, [pC1pC1pC1pC1]
				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC3pC3pC3pC3]
				paddsw	mm2, mm3
				movq		mm3, [tmmxf + 5 * 16 + 8]
				pmulhw	mm3, [pC5pC5pC5pC5]
				paddsw	mm2, mm3
				movq		mm3, [tmmxf + 7 * 16 + 8]
				pmulhw	mm3, [pC7pC7pC7pC7]
				paddsw	mm2, mm3

				movq		mm7, mm1
				paddsw	mm1, mm2		// r0 1
				psubsw	mm7, mm2		// r7 1

				psraw		mm0, 5
				psraw		mm6, 5
				psraw		mm1, 5
				psraw		mm7, 5

				packuswb	mm0, mm1
				packuswb	mm6, mm7

				movq		[ebx], mm0			// r0
				movq		[ecx + esi], mm6	// r7

				//////

				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, [pC7pC7pC7pC7]
				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC5pC5pC5pC5]
				psubsw	mm2, mm3
				movq		mm3, [tmmxf + 5 * 16 + 0]
				pmulhw	mm3, [pC3pC3pC3pC3]
				paddsw	mm2, mm3
				movq		mm3, [tmmxf + 7 * 16 + 0]
				pmulhw	mm3, [pC1pC1pC1pC1]
				psubsw	mm2, mm3

				movq		mm6, mm4
				paddsw	mm4, mm2		// r3	0
				psubsw	mm6, mm2		// r4	0

				movq		mm2, [tmmxf + 1 * 16 + 8]
				pmulhw	mm2, [pC7pC7pC7pC7]
				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC5pC5pC5pC5]
				psubsw	mm2, mm3
				movq		mm3, [tmmxf + 5 * 16 + 8]
				pmulhw	mm3, [pC3pC3pC3pC3]
				paddsw	mm2, mm3
				movq		mm3, [tmmxf + 7 * 16 + 8]
				pmulhw	mm3, [pC1pC1pC1pC1]
				psubsw	mm2, mm3

				movq		mm7, mm5
				paddsw	mm5, mm2		// r3 1
				psubsw	mm7, mm2		// r4 1

				psraw		mm4, 5
				psraw		mm6, 5
				psraw		mm5, 5
				psraw		mm7, 5

				packuswb	mm4, mm5
				packuswb	mm6, mm7

				movq		[ebx + esi], mm4			// r0
				movq		[ecx], mm6	// r7

				//////////////////////////////

				pxor		mm7, mm7

				movq		mm0, [tmmxf + 0 * 16 + 0]
				psubsw	mm0, [tmmxf + 4 * 16 + 0]
				psraw		mm0, 2
				paddsw	mm0, [RoundSecond0]

				movq		[tmmxf + 0 * 16 + 0], mm7
				movq		[tmmxf + 4 * 16 + 0], mm7

				movq		mm1, [tmmxf + 0 * 16 + 8]
				psubsw	mm1, [tmmxf + 4 * 16 + 8]
				psraw		mm1, 2
				paddsw	mm1, [RoundSecond0]

				movq		[tmmxf + 0 * 16 + 8], mm7
				movq		[tmmxf + 4 * 16 + 8], mm7

				movq		mm2, [tmmxf + 2 * 16 + 0]
				pmulhw	mm2, [pC6pC6pC6pC6]
				movq		mm3, [tmmxf + 6 * 16 + 0]
				pmulhw	mm3, [pC2pC2pC2pC2]
				psubsw	mm2, mm3 // y2 0

				movq		[tmmxf + 2 * 16 + 0], mm7
				movq		[tmmxf + 6 * 16 + 0], mm7

				movq		mm3, [tmmxf + 2 * 16 + 8]
				pmulhw	mm3, [pC6pC6pC6pC6]
				movq		mm4, [tmmxf + 6 * 16 + 8]
				pmulhw	mm4, [pC2pC2pC2pC2]
				psubsw	mm3, mm4 // y2 1

				movq		[tmmxf + 2 * 16 + 8], mm7
				movq		[tmmxf + 6 * 16 + 8], mm7

				movq		mm4, mm0
				paddsw	mm0, mm2	// a1 0
				psubsw	mm4, mm2 // a2 0

				movq		mm5, mm1
				paddsw	mm1, mm3 // a1 1
				psubsw	mm5, mm3 // a2 1

				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, [pC3pC3pC3pC3]
				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC7pC7pC7pC7]
				psubsw	mm2, mm3
				movq		mm3, [tmmxf + 5 * 16 + 0]
				pmulhw	mm3, [pC1pC1pC1pC1]
				psubsw	mm2, mm3
				movq		mm3, [tmmxf + 7 * 16 + 0]
				pmulhw	mm3, [pC5pC5pC5pC5]
				psubsw	mm2, mm3

				movq		mm6, mm0
				paddsw	mm0, mm2		// r1	0
				psubsw	mm6, mm2		// r6	0

				movq		mm2, [tmmxf + 1 * 16 + 8]
				pmulhw	mm2, [pC3pC3pC3pC3]
				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC7pC7pC7pC7]
				psubsw	mm2, mm3
				movq		mm3, [tmmxf + 5 * 16 + 8]
				pmulhw	mm3, [pC1pC1pC1pC1]
				psubsw	mm2, mm3
				movq		mm3, [tmmxf + 7 * 16 + 8]
				pmulhw	mm3, [pC5pC5pC5pC5]
				psubsw	mm2, mm3

				movq		mm7, mm1
				paddsw	mm1, mm2		// r1 1
				psubsw	mm7, mm2		// r6 1

				psraw		mm0, 5
				psraw		mm6, 5
				psraw		mm1, 5
				psraw		mm7, 5

				packuswb	mm0, mm1
				packuswb	mm6, mm7

				movq		[ebx + edx], mm0			// r1
				movq		[ecx + 2 * edx], mm6	// r6

				//////
				pxor		mm7, mm7

				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, [pC5pC5pC5pC5]
				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC1pC1pC1pC1]
				psubsw	mm2, mm3
				movq		mm3, [tmmxf + 5 * 16 + 0]
				pmulhw	mm3, [pC7pC7pC7pC7]
				paddsw	mm2, mm3
				movq		mm3, [tmmxf + 7 * 16 + 0]
				pmulhw	mm3, [pC3pC3pC3pC3]
				paddsw	mm2, mm3

				movq		[tmmxf + 1 * 16 + 0], mm7
				movq		[tmmxf + 3 * 16 + 0], mm7
				movq		[tmmxf + 5 * 16 + 0], mm7
				movq		[tmmxf + 7 * 16 + 0], mm7

				movq		mm6, mm4
				paddsw	mm4, mm2		// r2	0
				psubsw	mm6, mm2		// r5	0

				movq		mm2, [tmmxf + 1 * 16 + 8]
				pmulhw	mm2, [pC5pC5pC5pC5]
				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC1pC1pC1pC1]
				psubsw	mm2, mm3
				movq		mm3, [tmmxf + 5 * 16 + 8]
				pmulhw	mm3, [pC7pC7pC7pC7]
				paddsw	mm2, mm3
				movq		mm3, [tmmxf + 7 * 16 + 8]
				pmulhw	mm3, [pC3pC3pC3pC3]
				paddsw	mm2, mm3

				movq		[tmmxf + 1 * 16 + 8], mm7
				movq		[tmmxf + 3 * 16 + 8], mm7
				movq		[tmmxf + 5 * 16 + 8], mm7
				movq		[tmmxf + 7 * 16 + 8], mm7

				movq		mm7, mm5
				paddsw	mm5, mm2		// r2 1
				psubsw	mm7, mm2		// r5 1

				psraw		mm4, 5
				psraw		mm6, 5
				psraw		mm5, 5
				psraw		mm7, 5

				packuswb	mm4, mm5
				packuswb	mm6, mm7

				movq		[ebx + 2 * edx], mm4			// r2
				movq		[ecx + edx], mm6	// r5
				}
		}
	}



int GenericMMXMacroBlockIDCTDecoder::ParseIntraBlockMatrix(int yuvType, int & dcPredictor, int * matrix)
	{
	int dctPred;
	unsigned long * table;
	int l;
	static MMXInt<2> lmask = {0x0000fff0, 0x00000000};
	static MMXInt<2> l2    = {(7 << 25) | (1 << 17), 0x00000000};
	VideoCodingStandard	vcs = this->vcs;

	dctPred = dcPredictor + bitStream->GetDCCoefficient(splitIntraDCTable[yuvType]);
	dcPredictor = dctPred;

	tmmxf[0][0] = (dctPred << (7 - DCT_PREC)) >> intraDCPrecision;

	table = intraNonDCTable->extDCTTable;

#if MEASURE_PARSE_TIME
	static __int64 dctSumTime;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif

	__asm
		{
		mov	ecx, [BSBits]
		mov	edi, [matrix]

		movq	mm2, [lmask]

		mov	edx, VIDEO_STREAM_BUFFER_MASK

		movq	mm3, [l2]

		and	edx, ecx
		//

		mov	esi, [table]
		shr	edx, 5
		//

		//
		//
loop1:
		mov	ebx, [VideoStreamBuffer +     edx * 4]
		mov	eax, [VideoStreamBuffer + 4 + edx * 4]

		shld	ebx, eax, cl

		mov	eax, ebx
		shr	ebx, 23
		//

		mov	ebx, [esi + 4 * ebx]
		mov	edx, 0x0000000f

		and	edx, ebx
		je		notSingle
single:
		movd	mm0, ebx
		shr	ebx, 16
		add	ecx, ebx

		movd	mm1, [edi + 4 * edx]
		lea	edi, [edi + 4 * edx]
		mov	edx, VIDEO_STREAM_BUFFER_MASK

		movzx	ebx, [edi + 3]
		and	edx, ecx
		shr	edx, 5

		mov	eax, [VideoStreamBuffer + 4 + edx * 4]
		pand	mm0, mm2

		mov	edx, [VideoStreamBuffer +     edx * 4]
		pmaddwd	mm0, mm1

		shld	edx, eax, cl
		psubusb	mm3, mm1
		paddb	mm3, mm1

		movd	eax, mm0
		add	eax, 0x00000001 << (DCT_PREC + 3)
		sar	eax, DCT_PREC + 4

		mov	WORD PTR [tmmxf+ebx], ax

		mov	eax, edx
		shr	edx, 23

		mov	ebx, [esi + 4 * edx]
		mov	edx, 0x0000000f
		and	edx, ebx

		jne	single
notSingle:
		cmp	eax, 0x08000000
		jnc	done

		cmp	eax, 0x04000000
		jnc	escape

		mov	ebx, 0x0000000f

		test	eax, 0x03800000
		je		longmulti

		shr	eax, 18

		mov	edx, [esi + 4 * eax + 0x800]

		mov	eax, edx
		and	ebx, edx

		shr	edx, 16
		jmp	final

longmulti:
		shr	eax, 15

		mov	edx, [esi + 4 * eax + 0xc00]

		mov	eax, edx
		and	ebx, edx

		shr	edx, 16
		jmp	final
escape:
		cmp	[vcs], VCS_MPEG_1
		jne	mpeg2escape

		mov	edx, eax
		shr	edx, 20
		and	edx, 0x0000003f
		add	edx, 1

		test	eax, 0x0007f000
		jne	mpeg1single

		mov	ebx, eax
		shl	ebx, 12
		and	ebx, 0x80000000
		sar	ebx, 19
		or		eax, ebx
		and	eax, 0x0000fff0

		mov	ebx, 20
		jmp	final
mpeg1single:
		shl	eax, 12

		sar	eax, 20
		and	eax, 0x0000fff0

		mov	ebx, 12
		jmp	final

mpeg2escape:
		mov	edx, eax

		shr	edx, 20

		shr	eax, 4

		and	edx, 0x0000003f

		mov	ebx, 16
		add	edx, 1
final:
		movd	mm0, eax

		movd	mm1, [edi + 4 * edx]
		pand	mm0, mm2

		pmaddwd	mm0, mm1

		lea	ecx, [ecx + ebx + 8]
		movzx	ebx, BYTE PTR [edi + 4 * edx + 3]

		lea	edi, [edi + 4 * edx]
		mov	edx, VIDEO_STREAM_BUFFER_MASK

		and	edx, ecx

		movd	eax, mm0

		shr	edx, 5
		add	eax, 0x00000001 << (DCT_PREC + 3)

		sar	eax, DCT_PREC + 4
		psubusb	mm3, mm1

		mov	WORD PTR [tmmxf+ebx], ax
		paddb		mm3, mm1

		jmp	loop1
done:
		shr	ebx, 16

		add	ecx, ebx

		mov	[BSBits], ecx

		movd	[l], mm3
		}

#if MEASURE_PARSE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			char buffer[100];
			wsprintf(buffer, "PARSE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
			OutputDebugString(buffer);
			}
#endif

#if DUMP_COEFFICIENTS
		{
		if (!dfile)
			{
			dfile = fopen("c:\\coeffdump.txt", "w");
			}

		fprintf(dfile, "INTRA %d\n", blockcount);
		for(int i=0; i<8; i++)
			{
			for(int j=0; j<8; j++)
				{
				fprintf(dfile, "%5d ", tmmxf[i][j]);
				}
			fprintf(dfile, "\n");
			}
		fprintf(dfile, "\n");
		}

#endif

	return l;
	}

int GenericMMXMacroBlockIDCTDecoder::ParseNonIntraBlockMatrix(int * matrix)
	{
	int l;
	static MMXInt<2> lmask = {0x0000fff0, 0x00000000};
	static MMXInt<2> tzmask = {0x000000ff, 0x00000000};
	static MMXInt<2> tzmaskh = {0x000001ff, 0x00000000};
	static MMXInt<2> lround = {0x00000001 << (DCT_PREC + 3 + 1), 0x00000000};
	VideoCodingStandard	vcs = this->vcs;

	static int l2 = (7 << 25) | (1 << 17);

	__asm
		{
		mov	ecx, [BSBits]
		mov	edx, VIDEO_STREAM_BUFFER_MASK

		mov	edi, [matrix]
		and	edx, ecx

		shr	edx, 5
		sub	edi, 4

		movq	mm2, [lmask]
		movq	mm4, [tzmaskh]
		//

		movd	mm3, [l2]
		//

		mov	ebx, [VideoStreamBuffer +     edx * 4]
		mov	eax, [VideoStreamBuffer + 4 + edx * 4]

		shld	ebx, eax, cl

		test	ebx, ebx
		jns	notInitial

		mov	eax, ebx
		add	ebx, ebx

		sar	ebx, 31
		mov	edx, [edi+4]

		shl	eax, 2
		add	edx, edx

		add	edx, [edi+4]
		add	ecx, 2

		and	edx, 0x0000ffff

		shr	edx, 1 + DCT_PREC
		add	edi, 4

		xor	edx, ebx

		sub	edx, ebx
		mov	ebx, eax

		shr	ebx, 23
		and	edx, 0x0000ffff

		mov	DWORD PTR [tmmxf], edx
		mov	edx, ecx
		mov	ecx, 0x0000000f

		mov	esi, [dctCoefficientZero + 4 * ebx].extNIDCTTable
		xor	ebx, ebx

		and	ecx, esi
		movd	mm0, esi
		jne	single

		jmp	notSingle

		align	16
		nop
		nop
notInitial:
		mov	eax, ebx
		shr	ebx, 23
		mov	esi, [dctCoefficientZero + 4 * ebx].extNIDCTTable

		mov	edx, ecx
		mov	ecx, 0x0000000f
		and	ecx, esi

		movd	mm0, esi
		je		notSingle

single:
		shr		esi, 16
		movd		mm1, [edi + 4 * esi]
		//

		shl		eax, cl
		mov		ebx, eax
		shr		eax, 23


		movq		mm6, mm0
		pand		mm0, mm2
		pmaddwd	mm0, mm1
		//

		add		edx, ecx
		mov		ecx, [dctCoefficientZero + 4 * eax].extNIDCTTable
		psraw		mm6, 15

		lea		edi, [edi + 4 * esi]
		movzx		esi, [edi + 3]

		psrlw		mm6, 7
		paddd		mm0, mm6
		movd		eax, mm0

		psubusb	mm1, mm3
		movd		mm0, ecx

		sar		eax, DCT_PREC + 4 + 1

		and		ecx, 0x0000000f
		paddb		mm3, mm1

		mov		WORD PTR [tmmxf+esi], ax

		movd		esi, mm0
		je			multiSingle2

		shr		esi, 16
		movd		mm1, [edi + 4 * esi]
		//

		shl		ebx, cl
		mov		eax, ebx
		shr		ebx, 23

		movq		mm6, mm0
		pand		mm0, mm2
		pmaddwd	mm0, mm1

		add		edx, ecx
		mov		ecx, [dctCoefficientZero + 4 * ebx].extNIDCTTable
		psraw		mm6, 15

		//

		lea		edi, [edi + 4 * esi]
		movzx		esi, [edi + 3]
		psrlw		mm6, 7

		paddd		mm0, mm6
		movd		ebx, mm0

		sar		ebx, DCT_PREC + 4 + 1

		psubusb	mm1, mm3
		movd		mm0, ecx

		and		ecx, 0x0000000f
		paddb		mm3, mm1

		mov		WORD PTR [tmmxf+esi], bx

		movd		esi, mm0
		je			multiSingle

		shr		esi, 16
		movd		mm1, [edi + 4 * esi]

		add		edx, ecx
		mov		ecx, edx
		and		edx, VIDEO_STREAM_BUFFER_MASK

		shr		edx, 5
		lea		edi, [edi + 4 * esi]

		mov		ebx, [VideoStreamBuffer + 4 + edx * 4]

		movq		mm6, mm0

		pand		mm0, mm2

		mov		esi, [VideoStreamBuffer +     edx * 4]
		pmaddwd	mm0, mm1
		psubusb	mm1, mm3

		movzx		edx, [edi + 3]
		paddb		mm3, mm1

		shld		esi, ebx, cl

		psraw		mm6, 15
		pand		mm6, mm4
		paddd		mm0, mm6

		movd		ebx, mm0

		sar		ebx, DCT_PREC + 4 + 1
		mov		eax, esi

		mov		BYTE PTR [tmmxf+edx], bl
		shr		esi, 23

		mov		BYTE PTR [tmmxf+edx+1], bh
		mov		esi, [dctCoefficientZero + 4 * esi].extNIDCTTable
		mov		edx, ecx
		mov		ecx, 0x0000000f

		movd		mm0, esi
		and		ecx, esi

		jne		single
notSingle:
		mov	ecx, edx

		test	eax, eax
		js		done

		cmp	eax, 0x04000000
		jnc	escape
		test	eax, 0x03800000
		je		longmulti
notLongMulti:
		shr	eax, 18

		mov	esi, [dctCoefficientZero + 4 * eax + 0x800].extNIDCTTable
		mov	edx, 0x0000000f

		mov	eax, esi
		and	edx, esi

		shr	esi, 16
		jmp	final

		align	16
multiSingle:
		mov	ebx, eax
multiSingle2:
		mov	ecx, edx
		test	ebx, ebx
		js		done

		and	edx, VIDEO_STREAM_BUFFER_MASK
		shr	edx, 5
		mov	ebx, [VideoStreamBuffer + 4 + edx * 4]
		mov	eax, [VideoStreamBuffer +     edx * 4]
		shld	eax, ebx, cl

//llongmulti:
		cmp	eax, 0x04000000
		jnc	escape


		test	eax, 0x03800000
		jne	notLongMulti

longmulti:
		shr	eax, 15

		mov	esi, [dctCoefficientZero + 4 * eax + 0xc00].extNIDCTTable
		mov	edx, 0x0000000f

		mov	eax, esi
		and	edx, esi

		shr	esi, 16
		jmp	final

		align	16
mpeg1escape:

		shr	esi, 20
		and	esi, 0x0000003f
		add	esi, 1

		test	eax, 0x0007f000
		jne	mpeg1single

		add	eax, eax
		and	eax, 0x00001fe0
		shl	edx, 12
		and	edx, 0x80000000
		sar	edx, 18
		or		eax, edx

		mov	edx, eax
		sar	edx, 31
		and	edx, 0xffffffe0
		lea	eax, [eax + edx + 16]

		mov	edx, 20
		jmp	final

		align	16
mpeg1single:
		shl	eax, 12
		and	eax, 0xff000000
		sar	eax, 19

		mov	edx, eax
		sar	edx, 31
		and	edx, 0xffffffe0
		lea	eax, [eax + edx + 16]

		mov	edx, 12
		jmp	final

		align	16
escape:
		cmp	[vcs], VCS_MPEG_1
		mov	esi, eax
		mov	edx, eax
		je		mpeg1escape

		shr	esi, 20

		shr	eax, 4
		and	esi, 0x0000003f

		shr	edx, 15
		lea	edi, [edi + 4 * esi + 4]

		movd	mm1, [edi]
		and	eax, 0x0000fff0
		and	edx, 0x00000010

		movzx	ebx, BYTE PTR [edi + 3]
		add	eax, 0x00000008
		add	ecx, 24

		sub	eax, edx
		movd	mm0, eax
		pmaddwd	mm0, mm1

		mov	edx, VIDEO_STREAM_BUFFER_MASK

		and	edx, ecx

		movq	mm6, mm0
		psrad	mm6, 31
		pand	mm6, [tzmask]
		paddd	mm0, mm6

		movd	eax, mm0

		shr	edx, 5

		mov	esi, [VideoStreamBuffer + 4 + edx * 4]

		sar	eax, DCT_PREC + 3 + 1
		psubusb	mm3, mm1

		mov	BYTE PTR [tmmxf+ebx], al
		paddb		mm3, mm1

		mov	BYTE PTR [tmmxf+ebx+1], ah
		mov	ebx, [VideoStreamBuffer +     edx * 4]

		shld	ebx, esi, cl

		jmp	notInitial

		align	16
final:
		lea		edi, [edi + 4 * esi]
		movd		mm1, [edi]
		movzx		esi, [edi + 3]

		movd		mm0, eax
		movd		mm6, eax
		pand		mm0, mm2

		pmaddwd	mm0, mm1
		lea		ecx, [ecx + edx + 8]
		mov		edx, VIDEO_STREAM_BUFFER_MASK

		and		edx, ecx
		psraw		mm6, 15
		pand		mm6, mm4

		paddd		mm0, mm6
		shr		edx, 5
		mov		ebx, [VideoStreamBuffer +     edx * 4]

		movd		eax, mm0
		sar		eax, DCT_PREC + 4 + 1

		mov		edx, [VideoStreamBuffer + 4 + edx * 4]
		shld		ebx, edx, cl

		psubusb	mm3, mm1
		test		ebx, ebx

		mov		WORD PTR [tmmxf+esi], ax
		paddb		mm3, mm1
		jns		notInitial

		test		ebx, 0x40000000
		jne		notInitial
done:
		add		ecx, 2

		mov		[BSBits], ecx

		movd		[l], mm3
		}

#if DUMP_COEFFICIENTS
		{
		if (!dfile)
			{
			dfile = fopen("c:\\coeffdump.txt", "w");
			}

		fprintf(dfile, "NON INTRA %d\n", blockcount);
		for(int i=0; i<8; i++)
			{
			for(int j=0; j<8; j++)
				{
				fprintf(dfile, "%5d ", tmmxf[i][j]);
				}
			fprintf(dfile, "\n");
			}
		fprintf(dfile, "\n");
		}

#endif

	return l;
	}

GenericMMXMacroBlockIDCTDecoder::GenericMMXMacroBlockIDCTDecoder(void)
	{
	splitIntraDCTable[0] = &dctDCSizeLuminance;
	splitIntraDCTable[1] = splitIntraDCTable[2] = &dctDCSizeChrominance;
	}

GenericMMXMacroBlockIDCTDecoder::~GenericMMXMacroBlockIDCTDecoder(void)
	{
#if DUMP_COEFFICIENTS
	if (dfile)
		{
		fclose(dfile);
		dfile = NULL;
		}
#endif
	}

void GenericMMXMacroBlockIDCTDecoder::SetPictureParameters(bool hurryUp,
																			  VideoCodingStandard vcs,
																			  int intraDCPrecision,
																			  HuffmanTable * intraNonDCTable)
	{
	this->hurryUp = hurryUp;
	this->vcs = vcs;
	this->intraDCPrecision = intraDCPrecision;
	this->intraNonDCTable = intraNonDCTable;

	memclr128(tmmxf);
	}

void GenericMMXMacroBlockIDCTDecoder::ParseIntraBlock(int num, int yuvType, int & dcPredictor, int * matrix, short * mb, int stride)
	{
	int l;

	l = ParseIntraBlockMatrix(yuvType, dcPredictor, matrix);
	InverseDCT(mb, stride, dctMulTable[yuvType], hfluti[(((l >> 25) + 8) >> 3) & 0x0f], hfluti[(l >> 17) & 0x0f]);
	}

void GenericMMXMacroBlockIDCTDecoder::ParseNonIntraBlock(int num, int yuvType, int * matrix, short * mb, int stride)
	{
	int l;

	l = ParseNonIntraBlockMatrix(matrix);
	InverseDCT(mb, stride, dctMulTable[yuvType], hflut[hurryUp][(((l >> 25) + 8) >> 3) & 0x0f], hflut[hurryUp][(l >> 17) & 0x0f]);
	}

void GenericMMXMacroBlockIDCTDecoder::ParseNonIntraBlocks(int codedBlockPattern, short ** yuvp, int * yuvd, int * matrix, int * offset)
	{
	int l, i, t;
	static char tp[] = {0, 0, 0, 0, 1, 2};

	for(i=0; i<6; i++)
		{
		if ((codedBlockPattern << i) & 0x20)
			{
			t = tp[i];
			l = ParseNonIntraBlockMatrix(matrix);
			tmmxf[0][0] += (short)offset[t];
			InverseDCT(yuvp[i], yuvd[t], dctMulTable[t], hflut[hurryUp][(((l >> 25) + 8) >> 3) & 0x0f], hflut[hurryUp][(l >> 17) & 0x0f]);
			}
		}
	}

void GenericMMXMacroBlockIDCTDecoder::ParseBaseNonIntraBlocks(int codedBlockPattern, short * yuvbp, int * yuvbo, int * yuvd, int * matrix)
	{
	int l, i, t;
	static char tp[] = {0, 0, 0, 0, 1, 2};

	for(i=0; i<6; i++)
		{
		if ((codedBlockPattern << i) & 0x20)
			{
			t = tp[i];
			l = ParseNonIntraBlockMatrix(matrix);
			InverseDCT(yuvbp + yuvbo[i], 2 * yuvd[t], dctMulTable[t], hflut[hurryUp][(((l >> 25) + 8) >> 3) & 0x0f], hflut[hurryUp][(l >> 17) & 0x0f]);
			}
		}
	}

void GenericMMXMacroBlockIDCTDecoder::ParseBYTEIntraBlock(int num, int yuvType, int & dcPredictor, int * matrix, BYTE * mb, int stride)
	{
	int l;

	l = ParseIntraBlockMatrix(yuvType, dcPredictor, matrix);
	InverseBYTEIntraDCT(mb, stride, dctMulTable[yuvType], hfluti[(((l >> 25) + 8) >> 3) & 0x0f], hfluti[(l >> 17) & 0x0f]);
	}




////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// AMD-ATHLON INTEL-KATMAI SUPPORT /////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

// optimized 9/3/1999
void GenericXMMXMacroBlockIDCTDecoder::InverseDCT(short * mb, int stride, DCTMulTable * table, int numLines, int numColumns)
	{
	static MMXQWORD RoundOne0    = {ROUND_ONE, ROUND_ONE, ROUND_ONE, ROUND_ONE};
	static MMXQWORD RoundSingle0 = {ROUND_SINGLE, ROUND_SINGLE, ROUND_SINGLE, ROUND_SINGLE};

	static MMXQWORD RoundOne1    = {ROUND_ONE, ROUND_ONE, ROUND_ONE, ROUND_ONE};
	static MMXQWORD RoundSingle1 = {ROUND_SINGLE, ROUND_SINGLE, ROUND_SINGLE, ROUND_SINGLE};

	static MMXQWORD RoundSecond0 = {ROUND_SECOND, ROUND_SECOND, ROUND_SECOND, ROUND_SECOND};
	static MMXQWORD RoundSecond1 = {ROUND_SECOND, ROUND_SECOND, ROUND_SECOND, ROUND_SECOND};

	static MMXQWORD RoundSecond0a = {ROUND_SECOND * 4, ROUND_SECOND * 4, ROUND_SECOND * 4, ROUND_SECOND * 4};
	static MMXQWORD RoundSecond1a = {ROUND_SECOND * 4, ROUND_SECOND * 4, ROUND_SECOND * 4, ROUND_SECOND * 4};

	switch (numColumns)
		{
		case 1:
			if (numLines == 1)
				{
				__asm
					{
					mov			esi, [table]
					mov			edx, [stride]

					movq			mm0, [tmmxf]				// tm3 tm2 tm1 tm0

					// XMMX
					pshufw		(mm0, mm0, 0x00)
				//	punpcklwd	mm0, mm0						// tm1 tm1 tm0 tm0
				//	punpckldq	mm0, mm0						// tm0 tm0 tm0 tm0

					pxor			mm2, mm2

					movq			mm1, [RoundOne1]

					mov	ebx, [mb]

					pmulhw		mm0, [esi].tpC8pC8pC8pC8

					lea			eax, [ebx+2*edx]

					lea			ecx, [ebx+2*edx]

					lea			eax, [eax+edx]

					paddw			mm1, mm0
					paddw			mm0, [RoundOne0]

					movq			[tmmxf], mm2
					psraw			mm0, ONE_SHIFT

					movq			[ebx], mm0
					movq			[ebx+8], mm0

					psraw			mm1, ONE_SHIFT

					movq			[ebx+2*edx], mm0
  					movq			[ebx+2*edx+8], mm0

					movq			[ebx+4*edx], mm0
					movq			[ebx+4*edx+8], mm0

					movq			[ecx+4*edx], mm0
					movq			[ecx+4*edx+8], mm0

					movq			[ebx+edx], mm1
					movq			[ebx+edx+8], mm1

					movq			[eax], mm1
					movq			[eax+8], mm1

					movq			[eax+2*edx], mm1
					movq			[eax+2*edx+8], mm1

					movq			[eax+4*edx], mm1
					movq			[eax+4*edx+8], mm1
					}

				return;
				}
			else
				{
				__asm
					{
					lea			eax, tmmxf
					mov			esi, [table]

					mov			ecx, [numLines]

					movq			mm1, [eax+0]

					pmaddwd		mm1, [esi].tpC8000000000

					sub			ecx, 1
loop11:
					movq			mm0, [eax+16]
					psrad			mm1, FIRST_SHIFT

					pmaddwd		mm0, [esi].tpC8000000000
					punpckldq	mm1, mm1

					packssdw		mm1, mm1
					sub			ecx, 1

					movq			[eax], mm1

					movq			[eax + 8], mm1
					movq			mm1, mm0

					lea			eax, [eax + 16]
					jne			loop11

					psrad			mm1, FIRST_SHIFT

					punpckldq	mm1, mm1

					packssdw		mm1, mm1

					movq			[eax], mm1

					movq			[eax + 8], mm1
					}
				}
			break;
		case 2:
			__asm
				{
				mov			esi, [table]

				lea			eax, tmmxf
				mov			ecx, [numLines]

				movq			mm1, [eax+8]

				punpcklwd	mm1, [eax+0]

				movq			mm4, [esi].tpC8pC7pC8pC5
				punpckldq	mm1, mm1

				movq			mm2, [esi].tpC8pC3pC8pC1
				pmaddwd		mm4, mm1

				movq			mm3, [esi].tpC8mC1pC8mC3
				pmaddwd		mm2, mm1

				movq			mm5, mm1
				pmaddwd		mm3, mm1

				pmaddwd		mm5, [esi].tpC8mC5pC8mC7
				psrad			mm4, FIRST_SHIFT

				psrad			mm2, FIRST_SHIFT
				sub			ecx, 1

				psrad			mm3, FIRST_SHIFT
				je				done12
loop12:
				movq			mm1, [eax+24]
				psrad			mm5, FIRST_SHIFT

				punpcklwd	mm1, [eax+16]
				packssdw		mm2, mm4

				movq			mm4, [esi].tpC8pC7pC8pC5
				punpckldq	mm1, mm1

				movq			[eax], mm2
				packssdw		mm5, mm3

				movq			mm2, [esi].tpC8pC3pC8pC1
				pmaddwd		mm4, mm1

				movq			mm3, [esi].tpC8mC1pC8mC3
				pmaddwd		mm2, mm1

				movq			[eax + 8], mm5
				movq			mm5, mm1

				pmaddwd		mm3, mm1
				psrad			mm4, FIRST_SHIFT

				pmaddwd		mm5, [esi].tpC8mC5pC8mC7
				psrad			mm2, FIRST_SHIFT

				lea			eax, [eax+16]
				sub			ecx, 1

				psrad			mm3, FIRST_SHIFT
				jne			loop12
done12:
				psrad			mm5, FIRST_SHIFT

				packssdw		mm2, mm4

				packssdw		mm5, mm3

				movq			[eax], mm2

				movq			[eax + 8], mm5
				}
			break;
		case 3:
			__asm
				{
				mov			esi, [table]

				lea			eax, tmmxf
				mov			ecx, [numLines]

				movq			mm0, [eax+0]					// tm3 tm2 tm1 tm0

				// XMMX
				pshufw		(mm2, mm0, 0xEE)				// tm3 tm2 tm3 tm2
			//	movq			mm2, mm0							// tm3 tm2 tm1 tm0
			//	psrlq			mm2, 32							//   0   0 tm3 tm2

				movq			mm4, [eax+8]					// tm7 tm6 tm5 tm4
				punpcklwd	mm4, mm2							// tm3 tm5 tm2 tm4
				punpckldq	mm4, mm4						   // tm2 tm4 tm2 tm4

				pmaddwd		mm0, [esi].tpC8000000000


				movq			mm1, [esi].tmC2pC7mC6pC5

				movq			mm2, [esi].tpC6pC3pC2pC1
				pmaddwd		mm1, mm4

				movq			mm3, [esi].tpC2mC1pC6mC3
				punpckldq	mm0, mm0							//

				pmaddwd		mm2, mm4
				psrad			mm0, FIRST_SHIFT

				pmaddwd		mm3, mm4
				psrad			mm1, FIRST_SHIFT

				pmaddwd		mm4, [esi].tmC6mC5mC2mC7
				packssdw		mm0, mm0

				psrad			mm2, FIRST_SHIFT

				psrad			mm3, FIRST_SHIFT

				psrad			mm4, FIRST_SHIFT

				sub			ecx, 1
				je				done13
loop13:
				movq			mm5, [eax+16]				   // tm3 tm2 tm1 tm0
				packssdw		mm2, mm1

				movq			mm1, [eax+24]					// tm7 tm6 tm5 tm4
				paddsw		mm2, mm0

				movq			[eax], mm2

				// XMMX
				pshufw		(mm2, mm5, 0xEE)				// tm3 tm2 tm3 tm2
			//	movq			mm2, mm5							// tm3 tm2 tm1 tm0
			//	psrlq			mm2, 32							//   0   0 tm3 tm2

				pmaddwd		mm5, [esi].tpC8000000000
				packssdw		mm4, mm3

				paddsw		mm4, mm0

				movq			[eax + 8], mm4

				punpcklwd	mm1, mm2							//	tm3 tm5 tm2 tm4
				punpckldq	mm1, mm1							//	tm2 tm4 tm2 tm4

				movq			mm0, mm5

				movq			mm2, [esi].tpC6pC3pC2pC1
				movq			mm4, mm1

				pmaddwd		mm1, [esi].tmC2pC7mC6pC5

				movq			mm3, [esi].tpC2mC1pC6mC3
				punpckldq	mm0, mm0

				pmaddwd		mm2, mm4
				psrad			mm0, FIRST_SHIFT

				pmaddwd		mm3, mm4
				psrad			mm1, FIRST_SHIFT

				pmaddwd		mm4, [esi].tmC6mC5mC2mC7
				packssdw		mm0, mm0

				psrad			mm2, FIRST_SHIFT
				sub			ecx, 1

				psrad			mm3, FIRST_SHIFT
				lea			eax, [eax+16]

				psrad			mm4, FIRST_SHIFT
				jne			loop13
done13:
				packssdw		mm2, mm1

				packssdw		mm4, mm3
				paddsw		mm2, mm0

				paddsw		mm4, mm0

				movq	[eax], mm2

				movq	[eax + 8], mm4

				}
			break;
		case 4:
			__asm
				{
				mov			esi, [table]

				lea			eax, tmmxf
				mov			ecx, [numLines]

loop14:

				//
				pshufwMEM	(mm0, eax, 0x99)					// 4
				pshufwMEM	(mm7, eax, 0x44)					// 4
				por			mm0, mm7								// 3

				//
				pshufwIMM8	(mm1, eax, 8, 0x99)				// 5

				//
				pshufwIMM8	(mm6, eax, 8, 0x44)				// 5
				por			mm1, mm6								// 3
				movq			mm2, [esi].tpC6pC8pC2pC8		// 4

				//
				movq			mm3, [esi].tmC7pC3pC3pC1		// 4

				//
				pmaddwd		mm2, mm0								// 3
				pmaddwd		mm0, [esi].tmC2pC8mC6pC8		// 4
				pmaddwd		mm3, mm1								// 3

				//
				pmaddwd		mm1, [esi].tmC5pC7mC1pC5		// 4
				movq			mm4, mm2								// 3

				movq			mm5, mm0								// 3
				paddd			mm2, mm3								// 3

				psrad			mm2, FIRST_SHIFT					// 4
				paddd			mm0, mm1								// 3

				psrad			mm0, FIRST_SHIFT					// 4
				psubd			mm4, mm3								// 3

				psrad			mm4, FIRST_SHIFT					// 4
				psubd			mm5, mm1								// 3

				psrad			mm5, FIRST_SHIFT					// 4

				packssdw		mm5, mm4								// 3
				lea			eax, [eax+16]
			//	add			eax, 16								// 3

				movq			mm4, mm5								// 3
				packssdw		mm2, mm0								// 3

				pslld			mm5, 16								// 4

				psrld			mm4, 16								// 4

				por			mm4, mm5								// 3

				movq			[eax-16], mm2

				movq			[eax-8], mm4

				sub			ecx, 1
				jne			loop14
				}
		break;
		default:
			__asm
				{
				mov			esi, [table]

				lea			eax, [tmmxf]
				mov			ecx, [numLines]
loop18a:

				// XMMX
				pshufwMEM	(mm0, eax, 0x44)		// tm1 tm0 tm1 tm0
			//	movq			mm0, [eax+0]
			//	punpckldq	mm0, mm0					// f4 f0 f4 f0

				// XMMX
				pshufwMEM	(mm1, eax, 0xEE)		// tm3 tm2 tm3 tm2
			//	movq			mm1, [eax+0]
			//	punpckhdq	mm1, mm1					// f6 f2 f6 f2

				// XMMX
				pshufwIMM8	(mm6, eax, 8, 0x44)
			//	movq			mm6, [eax+8]			// f7 f3 f5 f1
			//	punpckldq	mm6, mm6					// f5 f1 f5 f1

				// XMMX
				pshufwIMM8	(mm7, eax, 8, 0xEE)
			//	movq			mm7, [eax+8]
			//	punpckhdq	mm7, mm7					// f7 f3 f7 f3

				pmaddwd		mm0, [esi].tmC8pC8pC8pC8

				pmaddwd		mm1, [esi].tmC2pC6pC6pC2
				movq			mm2, mm0

				movq			mm4, [esi].tmC1pC3pC5pC1
				lea			eax, [eax + 16]

				pmaddwd		mm4, mm6					// y6a y4a

				pmaddwd		mm6, [esi].tpC3pC7pC7pC5	// y5a y7a
				paddd			mm0, mm1					// a1 a0
				psubd			mm2, mm1					// a3 a2

				movq			mm5, [esi].tmC5mC7pC7pC3
				pmaddwd		mm5, mm7					// y6b y4b

				// XMMX
				pshufw		(mm2, mm2, 0x4E)
			//	punpckldq	mm1, mm2
			//	punpckhdq	mm2, mm1					// a2 a3

				pmaddwd		mm7, [esi].tmC1mC5pC3mC1	// y5b y7b

				paddd			mm4, mm5
				paddd			mm6, mm7

				movq			mm7, mm0
				movq			mm5, mm2

				paddd			mm0, mm4					// t1 t0
				paddd			mm2, mm6					// t2 t3

				psrad			mm0, FIRST_SHIFT
				psrad			mm2, FIRST_SHIFT

				psubd			mm7, mm4					// t6 t7
				psubd			mm5, mm6					// t4 t5

				psrad			mm7, FIRST_SHIFT
				psrad			mm5, FIRST_SHIFT

				packssdw		mm0, mm2					// t3 t2 t1 t0
				packssdw		mm5, mm7					// t6 t7 t4 t5

				movq			mm7, mm5
				pslld			mm5, 16

				movq			[eax-16], mm0

				psrld			mm7, 16
				por			mm5, mm7					// t4 t5 t6 t7

				movq			[eax-8], mm5
				dec			ecx

				jne			loop18a
				}
			break;
		}

	switch (numLines)
		{
		case 1:
			__asm
				{
				movq		mm2, [RoundSingle0]
				pxor		mm7, mm7

				movq		mm0, [tmmxf + 0 * 16 + 0]
				paddsw	mm0, mm2
				psraw		mm0, INTER_PREC

				movq		mm1, [tmmxf + 0 * 16 + 8]
				paddsw	mm1, mm2
				psraw		mm1, INTER_PREC

				movq		[tmmxf + 0 * 16 + 0], mm7
				mov		ebx, [mb]
				mov		edx, [stride]

				movq		[tmmxf + 0 * 16 + 8], mm7
				lea		ecx, [ebx+4*edx]
				lea		esi, [ebx+2* edx]
				lea		edi, [ecx+2*edx]

				movq		[ebx+edx], mm0
				movq		[ebx+edx+8], mm1
				movq		[ecx+edx], mm0
				movq		[ecx+edx+8], mm1
				movq		[ebx], mm0
				movq		[ebx+8], mm1
				movq		[ecx], mm0
				movq		[ecx+8], mm1
				movq		[esi], mm0
				movq		[esi+8], mm1
				movq		[edi], mm0
				movq		[edi+8], mm1
				add		esi, edx
				movq		[esi], mm0
				add		edi, edx
				movq		[esi+8], mm1
				movq		[edi], mm0
				movq		[edi+8], mm1
				}
			break;
		case 2:
			__asm
				{
				mov		ebx, [mb]
				mov		edx, [stride]
				lea		ecx, [ebx+4*edx]
				lea		esi, [edx+2*edx]

				movq		mm0, [tmmxf + 0 * 16 + 0]
				movq		mm1, [tmmxf + 0 * 16 + 8]
				paddsw	mm0, [RoundSecond0a]
				paddsw	mm1, [RoundSecond0a]

				pxor		mm7, mm7
				movq		[tmmxf + 0 * 16 + 0], mm7
				movq		[tmmxf + 0 * 16 + 8], mm7


				//////////////////////

				movq		mm3, [pC1pC1pC1pC1a]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]
				paddsw	mm2, [tmmxf + 1 * 16 + 0]
				paddsw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm4, mm0
				movq		mm5, mm0
				paddsw	mm4, mm2
				psubsw	mm5, mm2

				movq		mm6, mm1
				movq		mm7, mm1
				paddsw	mm6, mm3
				psubsw	mm7, mm3

				psraw		mm4, SECOND_SHIFT + 2
				psraw		mm5, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx], mm4
				movq		[ebx+8], mm6
				movq		[ecx+esi], mm5
				movq		[ecx+esi+8], mm7


				movq		mm3, [pC3pC3pC3pC3a]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]
				paddsw	mm2, [tmmxf + 1 * 16 + 0]
				paddsw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm4, mm0
				movq		mm5, mm0
				paddsw	mm4, mm2
				psubsw	mm5, mm2

				movq		mm6, mm1
				movq		mm7, mm1
				paddsw	mm6, mm3
				psubsw	mm7, mm3

				psraw		mm4, SECOND_SHIFT + 2
				psraw		mm5, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx+edx], mm4
				movq		[ebx+edx+8], mm6
				movq		[ecx+2*edx], mm5
				movq		[ecx+2*edx+8], mm7


				movq		mm3, [pC5pC5pC5pC5a]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				paddsw	mm2, mm2
				paddsw	mm3, mm3

				movq		mm4, mm0
				movq		mm5, mm0
				paddsw	mm4, mm2
				psubsw	mm5, mm2

				movq		mm6, mm1
				movq		mm7, mm1
				paddsw	mm6, mm3
				psubsw	mm7, mm3

				psraw		mm4, SECOND_SHIFT + 2
				psraw		mm5, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx+2*edx], mm4
				movq		[ebx+2*edx+8], mm6
				movq		[ecx+edx], mm5
				movq		[ecx+edx+8], mm7

				movq		mm3, [pC7pC7pC7pC7a]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm4, mm0
				movq		mm5, mm0
				paddsw	mm4, mm2
				psubsw	mm5, mm2

				movq		mm6, mm1
				movq		mm7, mm1
				paddsw	mm6, mm3
				psubsw	mm7, mm3

				psraw		mm4, SECOND_SHIFT + 2
				psraw		mm5, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx+esi], mm4
				movq		[ebx+esi+8], mm6
				movq		[ecx], mm5
				movq		[ecx+8], mm7

				pxor		mm7, mm7
				movq		[tmmxf + 1 * 16 + 0], mm7
				movq		[tmmxf + 1 * 16 + 8], mm7
				}

			break;
		case 3:
			__asm
				{
				mov		ebx, [mb]
				mov		edx, [stride]
				lea		ecx, [ebx+4*edx]
				lea		esi, [edx+2*edx]

				movq		mm0, [tmmxf + 0 * 16 + 0]
				movq		mm1, [tmmxf + 0 * 16 + 8]

				movq		mm3, [pC2pC2pC2pC2a]
				movq		mm2, [tmmxf + 2 * 16 + 0]
				pmulhw	mm2, mm3
				paddsw	mm2, [tmmxf + 2 * 16 + 0]

				pmulhw	mm3, [tmmxf + 2 * 16 + 8]
				paddsw	mm3, [tmmxf + 2 * 16 + 8]

				paddsw	mm0, [RoundSecond0a]
				paddsw	mm1, [RoundSecond0a]

				movq		mm4, mm0
				movq		mm5, mm1

				paddsw	mm0, mm2
				paddsw	mm1, mm3
				psubsw	mm4, mm2
				psubsw	mm5, mm3

				/////////////

				movq		mm3, [pC1pC1pC1pC1a]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]
				paddsw	mm2, [tmmxf + 1 * 16 + 0]
				paddsw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm6, mm0
				paddsw	mm0, mm2
				psubsw	mm6, mm2

				movq		mm7, mm1
				paddsw	mm1, mm3
				psubsw	mm7, mm3

				psraw		mm0, SECOND_SHIFT + 2
				psraw		mm1, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx], mm0
				movq		[ebx+8], mm1
				movq		[ecx+esi], mm6
				movq		[ecx+esi+8], mm7

				//////////

				movq		mm3, [pC7pC7pC7pC7a]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm6, mm4
				paddsw	mm4, mm2
				psubsw	mm6, mm2

				movq		mm7, mm5
				paddsw	mm5, mm3
				psubsw	mm7, mm3

				psraw		mm4, SECOND_SHIFT + 2
				psraw		mm5, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx+esi], mm4
				movq		[ebx+esi+8], mm5
				movq		[ecx], mm6
				movq		[ecx+8], mm7

				////////////////////////////

				movq		mm0, [tmmxf + 0 * 16 + 0]
				movq		mm1, [tmmxf + 0 * 16 + 8]

				movq		mm3, [pC6pC6pC6pC6a]
				movq		mm2, [tmmxf + 2 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 2 * 16 + 8]
				paddsw	mm2, mm2
				paddsw	mm3, mm3

				paddsw	mm0, [RoundSecond0a]
				paddsw	mm1, [RoundSecond0a]
				movq		mm4, mm0
				movq		mm5, mm1

				pxor		mm7, mm7
				movq		[tmmxf + 0 * 16 + 0], mm7
				movq		[tmmxf + 0 * 16 + 8], mm7
				movq		[tmmxf + 2 * 16 + 0], mm7
				movq		[tmmxf + 2 * 16 + 8], mm7

				paddsw	mm0, mm2
				paddsw	mm1, mm3
				psubsw	mm4, mm2
				psubsw	mm5, mm3

				/////////////

				movq		mm3, [pC3pC3pC3pC3a]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]
				paddsw	mm2, [tmmxf + 1 * 16 + 0]
				paddsw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm6, mm0
				paddsw	mm0, mm2
				psubsw	mm6, mm2

				movq		mm7, mm1
				paddsw	mm1, mm3
				psubsw	mm7, mm3

				psraw		mm0, SECOND_SHIFT + 2
				psraw		mm1, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx+edx], mm0
				movq		[ebx+edx+8], mm1
				movq		[ecx+2*edx], mm6
				movq		[ecx+2*edx+8], mm7

				//////////

				movq		mm3, [pC5pC5pC5pC5a]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]
				paddsw	mm2, mm2
				paddsw	mm3, mm3

				movq		mm6, mm4
				paddsw	mm4, mm2
				psubsw	mm6, mm2

				movq		mm7, mm5
				paddsw	mm5, mm3
				psubsw	mm7, mm3

				psraw		mm4, SECOND_SHIFT + 2
				psraw		mm5, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx+2*edx], mm4
				movq		[ebx+2*edx+8], mm5
				movq		[ecx+edx], mm6
				movq		[ecx+edx+8], mm7

				pxor		mm7, mm7
				movq		[tmmxf + 1 * 16 + 0], mm7
				movq		[tmmxf + 1 * 16 + 8], mm7
				}
			break;
		case 4:
			__asm
				{
				mov		ebx, [mb]
				mov		edx, [stride]
				lea		ecx, [ebx+4*edx]
				lea		esi, [edx+2*edx]

				movq		mm7, [RoundSecond0a]

				movq		mm0, [tmmxf + 0 * 16 + 0]
				paddsw	mm0, mm7

				movq		mm1, [tmmxf + 0 * 16 + 8]
				paddsw	mm1, mm7

				movq		mm2, [pC2pC2pC2pC2a]
				movq		mm3, mm2

				movq		mm4, [tmmxf + 2 * 16 + 0]
				pmulhw	mm2, mm4
				paddsw	mm2, mm4

				movq		mm4, [tmmxf + 2 * 16 + 8]
				pmulhw	mm3, mm4
				paddsw	mm3, mm4

				movq		mm4, mm0
				paddsw	mm0, mm2	// a0 0
				psubsw	mm4, mm2 // a3 0

				movq		mm5, mm1
				paddsw	mm1, mm3 // a0 1
				psubsw	mm5, mm3 // a3 1

				movq		mm3, [tmmxf + 1 * 16 + 0]
				movq		mm2, [pC1pC1pC1pC1a]

				pmulhw	mm2, mm3
				paddsw	mm2, mm3

				movq		mm3, [tmmxf + 3 * 16 + 0]
				paddsw	mm2, mm3

				pmulhw	mm3, [pC3pC3pC3pC3a]

				paddsw	mm2, mm3

				movq		mm6, mm0
				paddsw	mm0, mm2		// r0	0
				psubsw	mm6, mm2		// r7	0

				movq		mm3, [tmmxf + 1 * 16 + 8]
				movq		mm2, [pC1pC1pC1pC1a]

				pmulhw	mm2, mm3
				paddsw	mm2, mm3

				movq		mm3, [tmmxf + 3 * 16 + 8]
				paddsw	mm2, mm3

				pmulhw	mm3, [pC3pC3pC3pC3a]

				paddsw	mm2, mm3

				movq		mm7, mm1
				paddsw	mm1, mm2		// r0 1
				psubsw	mm7, mm2		// r7 1

				psraw		mm0, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm1, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx], mm0			// r0
				movq		[ebx+8], mm1			// r0
				movq		[ecx + esi], mm6	// r7
				movq		[ecx + esi+8], mm7	// r7

				//////

				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC5pC5pC5pC5a]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, [pC7pC7pC7pC7a]
				paddsw	mm3, mm3
				psubsw	mm2, mm3

				movq		mm6, mm4
				paddsw	mm4, mm2		// r3	0
				psubsw	mm6, mm2		// r4	0

				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC5pC5pC5pC5a]
				movq		mm2, [tmmxf + 1 * 16 + 8]
				pmulhw	mm2, [pC7pC7pC7pC7a]
				paddsw	mm3, mm3
				psubsw	mm2, mm3

				movq		mm7, mm5
				paddsw	mm5, mm2		// r3 1
				psubsw	mm7, mm2		// r4 1

				psraw		mm4, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm5, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx + esi], mm4			// r0
				movq		[ebx + esi+8], mm5			// r0
				movq		[ecx], mm6	// r7
				movq		[ecx+8], mm7	// r7

				//////////////////////////////

				pxor		mm7, mm7
				movq		mm6, [RoundSecond0a]

				movq		mm0, [tmmxf + 0 * 16 + 0]
				paddsw	mm0, mm6

				movq		[tmmxf + 0 * 16 + 0], mm7

				movq		mm1, [tmmxf + 0 * 16 + 8]
				paddsw	mm1, mm6

				movq		[tmmxf + 0 * 16 + 8], mm7

				movq		mm3, [pC6pC6pC6pC6a]
				movq		mm2, [tmmxf + 2 * 16 + 0]
				pmulhw	mm2, mm3
				paddsw	mm2, mm2

				movq		[tmmxf + 2 * 16 + 0], mm7

				pmulhw	mm3, [tmmxf + 2 * 16 + 8]
				paddsw	mm3, mm3

				movq		[tmmxf + 2 * 16 + 8], mm7

				movq		mm4, mm0
				paddsw	mm0, mm2	// a1 0
				psubsw	mm4, mm2 // a2 0

				movq		mm5, mm1
				paddsw	mm1, mm3 // a1 1
				psubsw	mm5, mm3 // a2 1

				movq		mm3, [tmmxf + 1 * 16 + 0]
				movq		mm2, [pC3pC3pC3pC3a]
				pmulhw	mm2, mm3
				paddsw	mm2, mm3

				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC7pC7pC7pC7a]
				psubsw	mm2, mm3

				movq		mm6, mm0
				paddsw	mm0, mm2		// r1	0
				psubsw	mm6, mm2		// r6	0

				movq		mm3, [tmmxf + 1 * 16 + 8]
				movq		mm2, [pC3pC3pC3pC3a]
				pmulhw	mm2, mm3
				paddsw	mm2, mm3

				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC7pC7pC7pC7a]
				psubsw	mm2, mm3

				movq		mm7, mm1
				paddsw	mm1, mm2		// r1 1
				psubsw	mm7, mm2		// r6 1

				psraw		mm0, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm1, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx + edx], mm0			// r1
				movq		[ebx + edx+8], mm1			// r1
				movq		[ecx + 2 * edx], mm6	// r6
				movq		[ecx + 2 * edx+8], mm7	// r6

				//////
				pxor		mm7, mm7

				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, [pC5pC5pC5pC5a]
				paddsw	mm2, mm2
				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC1pC1pC1pC1a]
				paddsw	mm3, [tmmxf + 3 * 16 + 0]
				psubsw	mm2, mm3

				movq		[tmmxf + 1 * 16 + 0], mm7
				movq		[tmmxf + 3 * 16 + 0], mm7

				movq		mm6, mm4
				paddsw	mm4, mm2		// r2	0
				psubsw	mm6, mm2		// r5	0

				movq		mm2, [tmmxf + 1 * 16 + 8]
				pmulhw	mm2, [pC5pC5pC5pC5a]
				paddsw	mm2, mm2
				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC1pC1pC1pC1a]
				paddsw	mm3, [tmmxf + 3 * 16 + 8]
				psubsw	mm2, mm3

				movq		[tmmxf + 1 * 16 + 8], mm7
				movq		[tmmxf + 3 * 16 + 8], mm7

				movq		mm7, mm5
				paddsw	mm5, mm2		// r2 1
				psubsw	mm7, mm2		// r5 1
				psraw		mm4, SECOND_SHIFT + 2

				movq		[ebx + 2 * edx], mm4			// r2
				psraw		mm5, SECOND_SHIFT + 2

				movq		[ebx + 2 * edx+8], mm5			// r2
				psraw		mm6, SECOND_SHIFT + 2

				movq		[ecx + edx], mm6	// r5
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ecx + edx+8], mm7	// r5
				}
			break;
		default:
			__asm
				{
				movq		mm6, [RoundSecond0a]
				lea		eax, [tmmxf]

				movq		mm0, [eax + 0 * 16 + 0]
				paddsw	mm0, [eax + 4 * 16 + 0]
				paddsw	mm0, mm6

				movq		mm1, [eax + 0 * 16 + 8]
				paddsw	mm1, [eax + 4 * 16 + 8]
				paddsw	mm1, mm6

				movq		mm3, [pC6pC6pC6pC6a]
				movq		mm2, [eax + 6 * 16 + 0]
				pmulhw	mm2, mm3
				paddsw	mm2, mm2

				movq		mm5, [eax + 2 * 16 + 0]
				movq		mm4, [pC2pC2pC2pC2a]
				pmulhw	mm4, mm5

				paddsw	mm2, mm5
				paddsw	mm2, mm4 // y2 0

				pmulhw	mm3, [eax + 6 * 16 + 8]
				paddsw	mm3, mm3

				movq		mm5, [eax + 2 * 16 + 8]
				movq		mm4, [pC2pC2pC2pC2a]
				pmulhw	mm4, mm5

				paddsw	mm3, mm5
				paddsw	mm3, mm4 // y2 1

				movq		mm4, mm0
				paddsw	mm0, mm2	// a0 0
				psubsw	mm4, mm2 // a3 0

				movq		mm5, mm1
				paddsw	mm1, mm3 // a0 1
				psubsw	mm5, mm3 // a3 1

				mov		ebx, [mb]
				mov		edx, [stride]
				lea		ecx, [ebx+4*edx]
				lea		esi, [edx+2*edx]


				movq		mm2, [pC1pC1pC1pC1a]
				movq		mm6, [eax + 1 * 16 + 0]
				pmulhw	mm2, mm6
				paddsw	mm2, mm6

				movq		mm3, [eax + 3 * 16 + 0]

				paddsw	mm2, mm3

				pmulhw	mm3, [pC3pC3pC3pC3a]

				paddsw	mm2, mm3

				movq		mm3, [eax + 5 * 16 + 0]
				pmulhw	mm3, [pC5pC5pC5pC5a]
				paddsw	mm3, mm3

				paddsw	mm2, mm3

				movq		mm3, [eax + 7 * 16 + 0]
				pmulhw	mm3, [pC7pC7pC7pC7a]

				paddsw	mm2, mm3

				movq		mm6, mm0
				paddsw	mm0, mm2		// r0	0
				psubsw	mm6, mm2		// r7	0

				movq		mm2, [pC1pC1pC1pC1a]
				movq		mm3, [eax + 1 * 16 + 8]
				pmulhw	mm2, mm3
				paddsw	mm2, mm3

				movq		mm3, [eax + 3 * 16 + 8]

				paddsw	mm2, mm3

				pmulhw	mm3, [pC3pC3pC3pC3a]

				paddsw	mm2, mm3

				movq		mm3, [eax + 5 * 16 + 8]
				pmulhw	mm3, [pC5pC5pC5pC5a]
				paddsw	mm3, mm3

				paddsw	mm2, mm3

				movq		mm3, [eax + 7 * 16 + 8]
				pmulhw	mm3, [pC7pC7pC7pC7a]

				paddsw	mm2, mm3

				movq		mm7, mm1
				paddsw	mm1, mm2		// r0 1
				psubsw	mm7, mm2		// r7 1

				psraw		mm0, SECOND_SHIFT + 2
				psraw		mm1, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx], mm0			// r0
				movq		[ebx+8], mm1			// r0
				movq		[ecx + esi], mm6	// r7
				movq		[ecx + esi+8], mm7	// r7

				//////

				movq		mm2, [eax + 1 * 16 + 0]
				pmulhw	mm2, [pC7pC7pC7pC7a]

				movq		mm3, [eax + 3 * 16 + 0]
				pmulhw	mm3, [pC5pC5pC5pC5a]
				paddsw	mm3, mm3

				psubsw	mm2, mm3

				movq		mm3, [eax + 5 * 16 + 0]
				paddsw	mm2, mm3
				pmulhw	mm3, [pC3pC3pC3pC3a]

				paddsw	mm2, mm3

				movq		mm3, [eax + 7 * 16 + 0]
				psubsw	mm2, mm3
				pmulhw	mm3, [pC1pC1pC1pC1a]

				psubsw	mm2, mm3

				movq		mm6, mm4
				paddsw	mm4, mm2		// r3	0
				psubsw	mm6, mm2		// r4	0

				movq		mm2, [eax + 1 * 16 + 8]
				pmulhw	mm2, [pC7pC7pC7pC7a]

				movq		mm3, [eax + 3 * 16 + 8]
				pmulhw	mm3, [pC5pC5pC5pC5a]
				paddsw	mm3, mm3

				psubsw	mm2, mm3

				movq		mm3, [eax + 5 * 16 + 8]

				paddsw	mm2, mm3

				pmulhw	mm3, [pC3pC3pC3pC3a]

				paddsw	mm2, mm3

				movq		mm3, [eax + 7 * 16 + 8]

				psubsw	mm2, mm3

				pmulhw	mm3, [pC1pC1pC1pC1a]

				psubsw	mm2, mm3

				movq		mm7, mm5
				paddsw	mm5, mm2		// r3 1
				psubsw	mm7, mm2		// r4 1

				psraw		mm4, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm5, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx + esi], mm4			// r0
				movq		[ebx + esi+8], mm5			// r
				movq		[ecx], mm6	// r7
				movq		[ecx+8], mm7	// r7



				//////////////////////////////

				pxor		mm7, mm7

				movq		mm6, [RoundSecond1a]

				movq		mm0, [eax + 0 * 16 + 0]
				psubsw	mm0, [eax + 4 * 16 + 0]
				paddsw	mm0, mm6

				movq		mm1, [eax + 0 * 16 + 8]
				psubsw	mm1, [eax + 4 * 16 + 8]
				paddsw	mm1, mm6

				movq		[eax + 0 * 16 + 0], mm7
				movq		[eax + 4 * 16 + 0], mm7
				movq		[eax + 0 * 16 + 8], mm7
				movq		[eax + 4 * 16 + 8], mm7

				movq		mm2, [eax + 2 * 16 + 0]
				movq		mm3, [pC6pC6pC6pC6a]

				pmulhw	mm2, mm3
				paddsw	mm2, mm2

				movq		mm4, [eax + 6 * 16 + 0]
				movq		mm5, [pC2pC2pC2pC2a]
				psubsw	mm2, mm4
				pmulhw	mm4, mm5

				psubsw	mm2, mm4 // y2 0

				pmulhw	mm3, [eax + 2 * 16 + 8]
				paddsw	mm3, mm3

				movq		mm4, [eax + 6 * 16 + 8]
				psubsw	mm3, mm4
				pmulhw	mm4, mm5

				psubsw	mm3, mm4 // y2 1

				movq		mm4, mm0
				paddsw	mm0, mm2	// a1 0
				psubsw	mm4, mm2 // a2 0

				movq		mm5, mm1
				paddsw	mm1, mm3 // a1 1
				psubsw	mm5, mm3 // a2 1

				movq		[eax + 2 * 16 + 0], mm7
				movq		[eax + 6 * 16 + 0], mm7
				movq		[eax + 2 * 16 + 8], mm7
				movq		[eax + 6 * 16 + 8], mm7

				movq		mm6, [eax + 1 * 16 + 0]
				movq		mm2, [pC3pC3pC3pC3a]
				pmulhw	mm2, mm6
				paddsw	mm2, mm6

				movq		mm3, [eax + 3 * 16 + 0]
				pmulhw	mm3, [pC7pC7pC7pC7a]

				psubsw	mm2, mm3

				movq		mm3, [eax + 5 * 16 + 0]
				psubsw	mm2, mm3
				pmulhw	mm3, [pC1pC1pC1pC1a]

				psubsw	mm2, mm3

				movq		mm3, [eax + 7 * 16 + 0]
				pmulhw	mm3, [pC5pC5pC5pC5a]
				paddsw	mm3, mm3

				psubsw	mm2, mm3

				movq		mm6, mm0
				paddsw	mm0, mm2		// r1	0
				psubsw	mm6, mm2		// r6	0

				movq		mm7, [eax + 1 * 16 + 8]
				movq		mm2, [pC3pC3pC3pC3a]
				pmulhw	mm2, mm7
				paddsw	mm2, mm7

				movq		mm3, [eax + 3 * 16 + 8]
				pmulhw	mm3, [pC7pC7pC7pC7a]

				psubsw	mm2, mm3

				movq		mm3, [eax + 5 * 16 + 8]
				psubsw	mm2, mm3
				pmulhw	mm3, [pC1pC1pC1pC1a]

				psubsw	mm2, mm3

				movq		mm3, [eax + 7 * 16 + 8]
				pmulhw	mm3, [pC5pC5pC5pC5a]
				paddsw	mm3, mm3

				psubsw	mm2, mm3

				movq		mm7, mm1
				paddsw	mm1, mm2		// r1 1
				psubsw	mm7, mm2		// r6 1

				psraw		mm0, SECOND_SHIFT + 2
				psraw		mm1, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx + edx], mm0			// r1
				movq		[ebx + edx+8], mm1			// r1
				movq		[ecx + 2 * edx], mm6	// r6
				movq		[ecx + 2 * edx+8], mm7	// r6
				//////
				pxor		mm1, mm1

				movq		mm2, [eax + 1 * 16 + 0]
				pmulhw	mm2, [pC5pC5pC5pC5a]
				paddsw	mm2, mm2

				movq		mm3, [eax + 3 * 16 + 0]
				psubsw	mm2, mm3
				pmulhw	mm3, [pC1pC1pC1pC1a]

				psubsw	mm2, mm3

				movq		mm3, [eax + 5 * 16 + 0]
				pmulhw	mm3, [pC7pC7pC7pC7a]

				paddsw	mm2, mm3

				movq		mm3, [eax + 7 * 16 + 0]
				paddsw	mm2, mm3
				pmulhw	mm3, [pC3pC3pC3pC3a]

				paddsw	mm2, mm3

				movq		[eax + 1 * 16 + 0], mm1
				movq		[eax + 3 * 16 + 0], mm1
				movq		[eax + 5 * 16 + 0], mm1
				movq		[eax + 7 * 16 + 0], mm1

				movq		mm6, mm4
				paddsw	mm4, mm2		// r2	0
				psubsw	mm6, mm2		// r5	0

				movq		mm2, [eax + 1 * 16 + 8]
				pmulhw	mm2, [pC5pC5pC5pC5a]
				paddsw	mm2, mm2

				movq		mm3, [eax + 3 * 16 + 8]
				psubsw	mm2, mm3
				pmulhw	mm3, [pC1pC1pC1pC1a]

				psubsw	mm2, mm3

				movq		mm3, [eax + 5 * 16 + 8]
				pmulhw	mm3, [pC7pC7pC7pC7a]

				paddsw	mm2, mm3

				movq		mm3, [eax + 7 * 16 + 8]
				paddsw	mm2, mm3
				pmulhw	mm3, [pC3pC3pC3pC3a]

				paddsw	mm2, mm3

				movq		[eax + 1 * 16 + 8], mm1
				movq		[eax + 3 * 16 + 8], mm1
				movq		[eax + 5 * 16 + 8], mm1
				movq		[eax + 7 * 16 + 8], mm1


				movq		mm7, mm5
				paddsw	mm5, mm2		// r2 1
				psubsw	mm7, mm2		// r5 1

				psraw		mm4, SECOND_SHIFT + 2
				psraw		mm5, SECOND_SHIFT + 2
				psraw		mm6, SECOND_SHIFT + 2
				psraw		mm7, SECOND_SHIFT + 2

				movq		[ebx + 2 * edx], mm4			// r2
				movq		[ebx + 2 * edx+8], mm5			// r2
				movq		[ecx + edx], mm6	// r5
				movq		[ecx + edx+8], mm7	// r5
				}
		}
	}


void GenericXMMXMacroBlockIDCTDecoder::InverseBYTEIntraDCT(BYTE * mb, int stride, DCTMulTable * table, int numLines, int numColumns)
	{
	static MMXQWORD RoundOne0    = {ROUND_ONE, ROUND_ONE - 1, ROUND_ONE, ROUND_ONE - 1};
	static MMXQWORD RoundSingle0 = {ROUND_SINGLE, ROUND_SINGLE - 1, ROUND_SINGLE, ROUND_SINGLE - 1};
	static MMXQWORD RoundSecond0 = {ROUND_SECOND, ROUND_SECOND - 1, ROUND_SECOND, ROUND_SECOND - 1};

	static MMXQWORD RoundOne1    = {ROUND_ONE - 1, ROUND_ONE, ROUND_ONE - 1, ROUND_ONE};
	static MMXQWORD RoundSingle1 = {ROUND_SINGLE - 1, ROUND_SINGLE, ROUND_SINGLE - 1, ROUND_SINGLE};
	static MMXQWORD RoundSecond1 = {ROUND_SECOND - 1, ROUND_SECOND, ROUND_SECOND - 1, ROUND_SECOND};

	switch (numColumns)
		{
		case 1:
			if (numLines == 1)
				{
				__asm
					{
					lea			edi, [tmmxf]
					mov			ebx, [mb]
					mov			edx, [stride]
					mov			esi, [table]

					// XMMX
					pshufwMEM	(mm0, edi, 0x00)		// tm0 tm0 tm0 tm0
				//	movq			mm0, [edi]				// tm3 tm2 tm1 tm0
				//	punpcklwd	mm0, mm0					// tm1 tm1 tm0 tm0
				//	punpckldq	mm0, mm0					// tm0 tm0 tm0 tm0

					pmulhw		mm0, [esi].tpC8pC8pC8pC8


					pxor			mm2, mm2

					lea			eax, [ebx+2*edx]

					lea			ecx, [ebx+2*edx]

					movq			mm1, mm0
					lea			eax, [eax+edx]

					paddw			mm0, [RoundOne0]

					movq			[edi], mm2
					psraw			mm0, ONE_SHIFT

					paddw			mm1, [RoundOne1]
					packuswb		mm0, mm0

					psraw			mm1, ONE_SHIFT

					movq			[ebx], mm0
					packuswb		mm1, mm1

					movq			[ebx+2*edx], mm0

					movq			[ebx+4*edx], mm0

					movq			[ecx+4*edx], mm0

					movq			[ebx+edx], mm1

					movq			[eax], mm1

					movq			[eax+2*edx], mm1

					movq			[eax+4*edx], mm1
					}

				return;
				}
			else
				{
				__asm
					{
					lea	eax, tmmxf
					mov	ecx, [numLines]
					mov	esi, [table]
loop11:
					movq	mm0, [eax+0]

					pmaddwd mm0, [esi].tpC8000000000

					add	eax, 16

					psrad			mm0, FIRST_SHIFT

					punpckldq	mm0, mm0

					packssdw		mm0, mm0

					movq	[eax - 16], mm0

					movq	[eax - 8], mm0

					sub	ecx, 1
					jne	loop11
					}
				}
			break;
		case 2:
			__asm
				{
				mov			esi, [table]
				lea			eax, tmmxf
				mov			ecx, [numLines]
loop12:
				movq			mm1, [eax+8]			// tm7 tm6 tm5 tm4
				punpcklwd	mm1, [eax+0]			// tm1 tm5 tm0 tm4
				punpckldq	mm1, mm1					// tm0 tm4 tm0 tm4
				movq			mm4, mm1					// tm0 tm4 tm0 tm4

				pmaddwd		mm1, [esi].tpC8pC7pC8pC5
				movq			mm2, mm4

				pmaddwd		mm2, [esi].tpC8pC3pC8pC1
				movq			mm3, mm4

				pmaddwd		mm3, [esi].tpC8mC1pC8mC3

				pmaddwd		mm4, [esi].tpC8mC5pC8mC7
				psrad			mm1, FIRST_SHIFT

				psrad			mm2, FIRST_SHIFT
				add			eax, 16

				psrad			mm3, FIRST_SHIFT

				psrad			mm4, FIRST_SHIFT

				packssdw		mm2, mm1

				packssdw		mm4, mm3

				movq			[eax - 16], mm2

				movq			[eax - 8], mm4

				sub	ecx, 1
				jne	loop12
				}
			break;
		case 3:
			__asm
				{
				mov	esi, [table]
				lea			eax, tmmxf
				mov			ecx, [numLines]
loop13:

				// XMMX
				movq			mm0, [eax+0]				// tm3 tm2 tm1 tm0
				pshufw		(mm1, mm0, 0xAA)			// tm2 tm2 tm2 tm2
				pshufwIMM8	(mm4, eax, 8, 0x00)		// tm4 tm4 tm4 tm4
				punpcklwd	mm4, mm1						// tm2 tm4 tm2 tm4
				movq			mm1, mm4						// tm2 tm4 tm2 tm4

			//	movq			mm0, [eax+0]				// tm3 tm2 tm1 tm0
			//	movq			mm4, [eax+8]				// tm7 tm6 tm5 tm4
			//	movq			mm2, [eax+0]				// tm3 tm2 tm1 tm0
			//	psrlq			mm2, 32						//   0   0 tm3 tm2
			//	punpcklwd	mm4, mm2						// tm3 tm5 tm2 tm4
			//	punpckldq	mm4, mm4						// tm2 tm4 tm2 tm4
			//	movq			mm1, mm4						// tm2 tm4 tm2 tm4

				pmaddwd		mm0, [esi].tpC8000000000

				add			eax, 16


				punpckldq	mm0, mm0

				pmaddwd		mm1, [esi].tmC2pC7mC6pC5
				movq			mm2, mm4

				pmaddwd		mm2, [esi].tpC6pC3pC2pC1
				movq			mm3, mm4

				pmaddwd		mm3, [esi].tpC2mC1pC6mC3
				psrad			mm0, FIRST_SHIFT

				pmaddwd		mm4, [esi].tmC6mC5mC2mC7
				psrad			mm1, FIRST_SHIFT

				psrad			mm2, FIRST_SHIFT

				psrad			mm3, FIRST_SHIFT

				psrad			mm4, FIRST_SHIFT

				packssdw		mm0, mm0

				packssdw		mm2, mm1

				packssdw		mm4, mm3
				paddsw		mm2, mm0

				paddsw		mm4, mm0

				movq	[eax - 16], mm2

				movq	[eax - 8], mm4

				sub	ecx, 1
				jne	loop13
				}
			break;
		case 4:
			__asm
				{
				mov	esi, [table]
				lea			eax, tmmxf
				mov			ecx, [numLines]

loop14:

				// XMMX
				pshufwMEM	(mm0, eax, 0x88)
			//	movq			mm0, [eax+0]			// tm3 tm2 tm1 tm0
			//	psllq			mm0, 32					//	tm1 tm0	 0	  0
			//	punpckhwd	mm0, [eax+0]			//	tm3 tm1 tm2 tm0
			//	punpckldq	mm0, mm0					// tm2 tm0 tm2 tm0

				// XMMX
				pshufwIMM8	(mm1, eax, 8, 0x88)
			//	movq			mm1, [eax+8]			// tm7 tm6 tm5 tm4
			//	psllq			mm1, 32					//	tm5 tm4   0   0
			//	punpckhwd	mm1, [eax+8]			//	tm7 tm5 tm6 tm4
			//	punpckldq	mm1, mm1					// tm6 tm4 tm6 tm4

			//	movq			mm2, mm0					//	tm2 tm0 tm2 tm0
			//	movq			mm3, mm1					//	tm6 tm4 tm6 tm4

				movq			mm2, [esi].tmC2pC8mC6pC8
			//	pmaddwd		mm0, [esi].tpC6pC8pC2pC8
				pmaddwd		mm2, mm0

				pmaddwd		mm0, [esi].tpC6pC8pC2pC8

				movq			mm3, [esi].tmC5pC7mC1pC5
			//	pmaddwd		mm1, [esi].tmC7pC3pC3pC1
				pmaddwd		mm3, mm1

				pmaddwd		mm1, [esi].tmC7pC3pC3pC1

				movq			mm4, mm0

				movq			mm5, mm2
				paddd			mm0, mm1

				psrad			mm0, FIRST_SHIFT
				paddd			mm2, mm3

				psrad			mm2, FIRST_SHIFT
				psubd			mm4, mm1

				psrad			mm4, FIRST_SHIFT
				psubd			mm5, mm3

				psrad			mm5, FIRST_SHIFT

				packssdw		mm5, mm4
				add			eax, 16

				movq			mm4, mm5
				packssdw		mm0, mm2

				pslld			mm5, 16

				psrld			mm4, 16

				por			mm4, mm5

				movq			[eax-16], mm0

				movq			[eax-8], mm4

				sub			ecx, 1
				jne			loop14
				}
			break;
		default:
			__asm
				{
				mov	esi, [table]
				lea			eax, [tmmxf]
				mov			ecx, [numLines]
loop18a:

				// XMMX
				pshufwMEM	(mm0, eax, 0x44)		// tm1 tm0 tm1 tm0
			//	movq			mm0, [eax+0]
			//	punpckldq	mm0, mm0					// f4 f0 f4 f0

				// XMMX
				pshufwMEM	(mm1, eax, 0xEE)		// tm3 tm2 tm3 tm2
			//	movq			mm1, [eax+0]
			//	punpckhdq	mm1, mm1					// f6 f2 f6 f2


				pmaddwd		mm0, [esi].tmC8pC8pC8pC8

				pmaddwd		mm1, [esi].tmC2pC6pC6pC2

				movq			mm2, mm0
				paddd			mm0, mm1					// a1 a0
				psubd			mm2, mm1					// a3 a2

				// XMMX
				pshufw		(mm2, mm2, 0x4E)		// fpli DWORDS
			//	punpckldq	mm1, mm2
			//	punpckhdq	mm2, mm1					// a2 a3

				// XMMX
				pshufwIMM8	(mm1, eax, 8, 0x44)
			//	movq			mm1, [eax+8]			// f7 f3 f5 f1
			//	punpckldq	mm1, mm1					// f5 f1 f5 f1

				// XMMX
				pshufwIMM8	(mm3, eax, 8, 0xEE)
			//	movq			mm3, [eax+8]
			//	punpckhdq	mm3, mm3					// f7 f3 f7 f3

				movq			mm4, [esi].tmC1pC3pC5pC1
				pmaddwd		mm4, mm1					// y6a y4a
				pmaddwd		mm1, [esi].tpC3pC7pC7pC5	// y5a y7a

				movq			mm5, [esi].tmC5mC7pC7pC3
				pmaddwd		mm5, mm3					// y6b y4b
				pmaddwd		mm3, [esi].tmC1mC5pC3mC1	// y5b y7b

				paddd			mm4, mm5
				paddd			mm1, mm3

				movq			mm3, mm0
				movq			mm5, mm2

				paddd			mm0, mm4					// t1 t0
				paddd			mm2, mm1					// t2 t3

				psrad			mm0, FIRST_SHIFT
				psrad			mm2, FIRST_SHIFT

				psubd			mm3, mm4					// t6 t7
				psubd			mm5, mm1					// t4 t5

				psrad			mm3, FIRST_SHIFT
				psrad			mm5, FIRST_SHIFT

				packssdw		mm0, mm2					// t3 t2 t1 t0
				packssdw		mm5, mm3					// t6 t7 t4 t5

				movq			mm3, mm5
				pslld			mm5, 16

				movq			[eax], mm0
				psrld			mm3, 16
				por			mm3, mm5					// t4 t5 t6 t7

				movq			[eax+8], mm3

				add			eax, 16
				sub			ecx, 1
				jne			loop18a
				}
			break;
		}

	switch (numLines)
		{
		case 1:
			__asm
				{
				movq		mm0, [tmmxf + 0 * 16 + 0]
				paddsw	mm0, [RoundSingle0]
				pxor		mm7, mm7
				movq		mm1, [tmmxf + 0 * 16 + 8]
				paddsw	mm1, [RoundSingle1]
				psraw		mm0, 7
				psraw		mm1, 7
				movq		[tmmxf + 0 * 16 + 0], mm7
				mov		ebx, [mb]
				mov		edx, [stride]
				movq		[tmmxf + 0 * 16 + 8], mm7
				lea		ecx, [ebx+4*edx]
				packuswb	mm0, mm1

				movq		[ebx], mm0
				lea		esi, [edx+2*edx]
				movq		[ebx+edx], mm0
				movq		[ebx+2*edx], mm0
				movq		[ebx+esi], mm0
				movq		[ecx], mm0
				movq		[ecx+edx], mm0
				movq		[ecx+2*edx], mm0
				movq		[ecx+esi], mm0
				}
			break;
		case 2:
			__asm
				{
				mov		ebx, [mb]
				mov		edx, [stride]
				lea		ecx, [ebx+4*edx]
				lea		esi, [edx+2*edx]

				movq		mm0, [tmmxf + 0 * 16 + 0]
				psraw		mm0, 2
				movq		mm1, [tmmxf + 0 * 16 + 8]
				psraw		mm1, 2
				paddsw	mm0, [RoundSecond0]
				paddsw	mm1, [RoundSecond0]

				pxor		mm7, mm7
				movq		[tmmxf + 0 * 16 + 0], mm7
				movq		[tmmxf + 0 * 16 + 8], mm7


				//////////////////////

				movq		mm3, [pC1pC1pC1pC1]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm4, mm0
				movq		mm5, mm0
				paddsw	mm4, mm2
				psubsw	mm5, mm2

				movq		mm6, mm1
				movq		mm7, mm1
				paddsw	mm6, mm3
				psubsw	mm7, mm3

				psraw		mm4, 5
				psraw		mm5, 5
				psraw		mm6, 5
				psraw		mm7, 5

				packuswb	mm4, mm6
				packuswb	mm5, mm7

				movq		[ebx], mm4
				movq		[ecx+esi], mm5


				movq		mm3, [pC3pC3pC3pC3]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm4, mm0
				movq		mm5, mm0
				paddsw	mm4, mm2
				psubsw	mm5, mm2

				movq		mm6, mm1
				movq		mm7, mm1
				paddsw	mm6, mm3
				psubsw	mm7, mm3

				psraw		mm4, 5
				psraw		mm5, 5
				psraw		mm6, 5
				psraw		mm7, 5

				packuswb	mm4, mm6
				packuswb	mm5, mm7

				movq		[ebx+edx], mm4
				movq		[ecx+2*edx], mm5


				movq		mm3, [pC5pC5pC5pC5]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm4, mm0
				movq		mm5, mm0
				paddsw	mm4, mm2
				psubsw	mm5, mm2

				movq		mm6, mm1
				movq		mm7, mm1
				paddsw	mm6, mm3
				psubsw	mm7, mm3

				psraw		mm4, 5
				psraw		mm5, 5
				psraw		mm6, 5
				psraw		mm7, 5

				packuswb	mm4, mm6
				packuswb	mm5, mm7

				movq		[ebx+2*edx], mm4
				movq		[ecx+edx], mm5


				movq		mm3, [pC7pC7pC7pC7]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm4, mm0
				movq		mm5, mm0
				paddsw	mm4, mm2
				psubsw	mm5, mm2

				movq		mm6, mm1
				movq		mm7, mm1
				paddsw	mm6, mm3
				psubsw	mm7, mm3

				psraw		mm4, 5
				psraw		mm5, 5
				psraw		mm6, 5
				psraw		mm7, 5

				packuswb	mm4, mm6
				packuswb	mm5, mm7

				movq		[ebx+esi], mm4
				movq		[ecx], mm5

				pxor		mm7, mm7
				movq		[tmmxf + 1 * 16 + 0], mm7
				movq		[tmmxf + 1 * 16 + 8], mm7
				}

			break;
		case 3:
			__asm
				{
				mov		ebx, [mb]
				mov		edx, [stride]
				lea		ecx, [ebx+4*edx]
				lea		esi, [edx+2*edx]

				movq		mm0, [tmmxf + 0 * 16 + 0]
				psraw		mm0, 2
				movq		mm1, [tmmxf + 0 * 16 + 8]
				psraw		mm1, 2
				movq		mm3, [pC2pC2pC2pC2]
				movq		mm2, [tmmxf + 2 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 2 * 16 + 8]
				paddsw	mm0, [RoundSecond0]
				paddsw	mm1, [RoundSecond0]
				movq		mm4, mm0
				movq		mm5, mm1

				paddsw	mm0, mm2
				paddsw	mm1, mm3
				psubsw	mm4, mm2
				psubsw	mm5, mm3

				/////////////

				movq		mm3, [pC1pC1pC1pC1]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm6, mm0
				paddsw	mm0, mm2
				psubsw	mm6, mm2

				movq		mm7, mm1
				paddsw	mm1, mm3
				psubsw	mm7, mm3

				psraw		mm0, 5
				psraw		mm1, 5
				psraw		mm6, 5
				psraw		mm7, 5

				packuswb	mm0, mm1
				packuswb	mm6, mm7

				movq		[ebx], mm0
				movq		[ecx+esi], mm6

				//////////

				movq		mm3, [pC7pC7pC7pC7]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm6, mm4
				paddsw	mm4, mm2
				psubsw	mm6, mm2

				movq		mm7, mm5
				paddsw	mm5, mm3
				psubsw	mm7, mm3

				psraw		mm4, 5
				psraw		mm5, 5
				psraw		mm6, 5
				psraw		mm7, 5

				packuswb	mm4, mm5
				packuswb	mm6, mm7

				movq		[ebx+esi], mm4
				movq		[ecx], mm6

				////////////////////////////

				movq		mm0, [tmmxf + 0 * 16 + 0]
				psraw		mm0, 2
				movq		mm1, [tmmxf + 0 * 16 + 8]
				psraw		mm1, 2
				movq		mm3, [pC6pC6pC6pC6]
				movq		mm2, [tmmxf + 2 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 2 * 16 + 8]
				paddsw	mm0, [RoundSecond0]
				paddsw	mm1, [RoundSecond0]
				movq		mm4, mm0
				movq		mm5, mm1

				pxor		mm7, mm7
				movq		[tmmxf + 0 * 16 + 0], mm7
				movq		[tmmxf + 0 * 16 + 8], mm7
				movq		[tmmxf + 2 * 16 + 0], mm7
				movq		[tmmxf + 2 * 16 + 8], mm7

				paddsw	mm0, mm2
				paddsw	mm1, mm3
				psubsw	mm4, mm2
				psubsw	mm5, mm3

				/////////////

				movq		mm3, [pC3pC3pC3pC3]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm6, mm0
				paddsw	mm0, mm2
				psubsw	mm6, mm2

				movq		mm7, mm1
				paddsw	mm1, mm3
				psubsw	mm7, mm3

				psraw		mm0, 5
				psraw		mm1, 5
				psraw		mm6, 5
				psraw		mm7, 5

				packuswb	mm0, mm1
				packuswb	mm6, mm7

				movq		[ebx+edx], mm0
				movq		[ecx+2*edx], mm6

				//////////

				movq		mm3, [pC5pC5pC5pC5]
				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, mm3
				pmulhw	mm3, [tmmxf + 1 * 16 + 8]

				movq		mm6, mm4
				paddsw	mm4, mm2
				psubsw	mm6, mm2

				movq		mm7, mm5
				paddsw	mm5, mm3
				psubsw	mm7, mm3

				psraw		mm4, 5
				psraw		mm5, 5
				psraw		mm6, 5
				psraw		mm7, 5

				packuswb	mm4, mm5
				packuswb	mm6, mm7

				movq		[ebx+2*edx], mm4
				movq		[ecx+edx], mm6

				pxor		mm7, mm7
				movq		[tmmxf + 1 * 16 + 0], mm7
				movq		[tmmxf + 1 * 16 + 8], mm7
				}
			break;
		case 4:
			__asm
				{
				mov		ebx, [mb]
				mov		edx, [stride]
				lea		ecx, [ebx+4*edx]
				lea		esi, [edx+2*edx]

				movq		mm0, [tmmxf + 0 * 16 + 0]
				psraw		mm0, 2
				paddsw	mm0, [RoundSecond0]

				movq		mm2, [tmmxf + 2 * 16 + 0]
				pmulhw	mm2, [pC2pC2pC2pC2]
				movq		mm1, [tmmxf + 0 * 16 + 8]
				psraw		mm1, 2
				paddsw	mm1, [RoundSecond0]

				movq		mm3, [tmmxf + 2 * 16 + 8]
				pmulhw	mm3, [pC2pC2pC2pC2]

				movq		mm4, mm0
				paddsw	mm0, mm2	// a0 0
				psubsw	mm4, mm2 // a3 0

				movq		mm5, mm1
				paddsw	mm1, mm3 // a0 1
				psubsw	mm5, mm3 // a3 1

				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, [pC1pC1pC1pC1]
				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC3pC3pC3pC3]
				paddsw	mm2, mm3

				movq		mm6, mm0
				paddsw	mm0, mm2		// r0	0
				psubsw	mm6, mm2		// r7	0

				movq		mm2, [tmmxf + 1 * 16 + 8]
				pmulhw	mm2, [pC1pC1pC1pC1]
				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC3pC3pC3pC3]
				paddsw	mm2, mm3

				movq		mm7, mm1
				paddsw	mm1, mm2		// r0 1
				psubsw	mm7, mm2		// r7 1

				psraw		mm0, 5
				psraw		mm6, 5
				psraw		mm1, 5
				psraw		mm7, 5

				packuswb	mm0, mm1
				packuswb	mm6, mm7

				movq		[ebx], mm0			// r0
				movq		[ecx + esi], mm6	// r7

				//////

				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, [pC7pC7pC7pC7]
				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC5pC5pC5pC5]
				psubsw	mm2, mm3

				movq		mm6, mm4
				paddsw	mm4, mm2		// r3	0
				psubsw	mm6, mm2		// r4	0

				movq		mm2, [tmmxf + 1 * 16 + 8]
				pmulhw	mm2, [pC7pC7pC7pC7]
				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC5pC5pC5pC5]
				psubsw	mm2, mm3

				movq		mm7, mm5
				paddsw	mm5, mm2		// r3 1
				psubsw	mm7, mm2		// r4 1

				psraw		mm4, 5
				psraw		mm6, 5
				psraw		mm5, 5
				psraw		mm7, 5

				packuswb	mm4, mm5
				packuswb	mm6, mm7

				movq		[ebx + esi], mm4			// r0
				movq		[ecx], mm6	// r7

				//////////////////////////////

				pxor		mm7, mm7

				movq		mm0, [tmmxf + 0 * 16 + 0]
				psraw		mm0, 2
				paddsw	mm0, [RoundSecond0]

				movq		[tmmxf + 0 * 16 + 0], mm7

				movq		mm1, [tmmxf + 0 * 16 + 8]
				psraw		mm1, 2
				paddsw	mm1, [RoundSecond0]

				movq		[tmmxf + 0 * 16 + 8], mm7

				movq		mm2, [tmmxf + 2 * 16 + 0]
				pmulhw	mm2, [pC6pC6pC6pC6]

				movq		[tmmxf + 2 * 16 + 0], mm7

				movq		mm3, [tmmxf + 2 * 16 + 8]
				pmulhw	mm3, [pC6pC6pC6pC6]

				movq		[tmmxf + 2 * 16 + 8], mm7

				movq		mm4, mm0
				paddsw	mm0, mm2	// a1 0
				psubsw	mm4, mm2 // a2 0

				movq		mm5, mm1
				paddsw	mm1, mm3 // a1 1
				psubsw	mm5, mm3 // a2 1

				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, [pC3pC3pC3pC3]
				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC7pC7pC7pC7]
				psubsw	mm2, mm3

				movq		mm6, mm0
				paddsw	mm0, mm2		// r1	0
				psubsw	mm6, mm2		// r6	0

				movq		mm2, [tmmxf + 1 * 16 + 8]
				pmulhw	mm2, [pC3pC3pC3pC3]
				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC7pC7pC7pC7]
				psubsw	mm2, mm3

				movq		mm7, mm1
				paddsw	mm1, mm2		// r1 1
				psubsw	mm7, mm2		// r6 1

				psraw		mm0, 5
				psraw		mm6, 5
				psraw		mm1, 5
				psraw		mm7, 5

				packuswb	mm0, mm1
				packuswb	mm6, mm7

				movq		[ebx + edx], mm0			// r1
				movq		[ecx + 2 * edx], mm6	// r6

				//////
				pxor		mm7, mm7

				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, [pC5pC5pC5pC5]
				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC1pC1pC1pC1]
				psubsw	mm2, mm3

				movq		[tmmxf + 1 * 16 + 0], mm7
				movq		[tmmxf + 3 * 16 + 0], mm7

				movq		mm6, mm4
				paddsw	mm4, mm2		// r2	0
				psubsw	mm6, mm2		// r5	0

				movq		mm2, [tmmxf + 1 * 16 + 8]
				pmulhw	mm2, [pC5pC5pC5pC5]
				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC1pC1pC1pC1]
				psubsw	mm2, mm3

				movq		[tmmxf + 1 * 16 + 8], mm7
				movq		[tmmxf + 3 * 16 + 8], mm7

				movq		mm7, mm5
				paddsw	mm5, mm2		// r2 1
				psubsw	mm7, mm2		// r5 1

				psraw		mm4, 5
				psraw		mm6, 5
				psraw		mm5, 5
				psraw		mm7, 5

				packuswb	mm4, mm5
				packuswb	mm6, mm7

				movq		[ebx + 2 * edx], mm4			// r2
				movq		[ecx + edx], mm6	// r5
				}
			break;
		default:

			__asm
				{
				mov		ebx, [mb]
				mov		edx, [stride]
				lea		ecx, [ebx+4*edx]
				lea		esi, [edx+2*edx]

				movq		mm0, [tmmxf + 0 * 16 + 0]
				paddsw	mm0, [tmmxf + 4 * 16 + 0]
				psraw		mm0, 2
				paddsw	mm0, [RoundSecond0]

				movq		mm1, [tmmxf + 0 * 16 + 8]
				paddsw	mm1, [tmmxf + 4 * 16 + 8]
				psraw		mm1, 2
				paddsw	mm1, [RoundSecond0]

				movq		mm2, [tmmxf + 2 * 16 + 0]
				pmulhw	mm2, [pC2pC2pC2pC2]
				movq		mm3, [tmmxf + 6 * 16 + 0]
				pmulhw	mm3, [pC6pC6pC6pC6]
				paddsw	mm2, mm3 // y2 0

				movq		mm3, [tmmxf + 2 * 16 + 8]
				pmulhw	mm3, [pC2pC2pC2pC2]
				movq		mm4, [tmmxf + 6 * 16 + 8]
				pmulhw	mm4, [pC6pC6pC6pC6]
				paddsw	mm3, mm4 // y2 1

				movq		mm4, mm0
				paddsw	mm0, mm2	// a0 0
				psubsw	mm4, mm2 // a3 0

				movq		mm5, mm1
				paddsw	mm1, mm3 // a0 1
				psubsw	mm5, mm3 // a3 1

				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, [pC1pC1pC1pC1]
				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC3pC3pC3pC3]
				paddsw	mm2, mm3
				movq		mm3, [tmmxf + 5 * 16 + 0]
				pmulhw	mm3, [pC5pC5pC5pC5]
				paddsw	mm2, mm3
				movq		mm3, [tmmxf + 7 * 16 + 0]
				pmulhw	mm3, [pC7pC7pC7pC7]
				paddsw	mm2, mm3

				movq		mm6, mm0
				paddsw	mm0, mm2		// r0	0
				psubsw	mm6, mm2		// r7	0

				movq		mm2, [tmmxf + 1 * 16 + 8]
				pmulhw	mm2, [pC1pC1pC1pC1]
				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC3pC3pC3pC3]
				paddsw	mm2, mm3
				movq		mm3, [tmmxf + 5 * 16 + 8]
				pmulhw	mm3, [pC5pC5pC5pC5]
				paddsw	mm2, mm3
				movq		mm3, [tmmxf + 7 * 16 + 8]
				pmulhw	mm3, [pC7pC7pC7pC7]
				paddsw	mm2, mm3

				movq		mm7, mm1
				paddsw	mm1, mm2		// r0 1
				psubsw	mm7, mm2		// r7 1

				psraw		mm0, 5
				psraw		mm6, 5
				psraw		mm1, 5
				psraw		mm7, 5

				packuswb	mm0, mm1
				packuswb	mm6, mm7

				movq		[ebx], mm0			// r0
				movq		[ecx + esi], mm6	// r7

				//////

				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, [pC7pC7pC7pC7]
				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC5pC5pC5pC5]
				psubsw	mm2, mm3
				movq		mm3, [tmmxf + 5 * 16 + 0]
				pmulhw	mm3, [pC3pC3pC3pC3]
				paddsw	mm2, mm3
				movq		mm3, [tmmxf + 7 * 16 + 0]
				pmulhw	mm3, [pC1pC1pC1pC1]
				psubsw	mm2, mm3

				movq		mm6, mm4
				paddsw	mm4, mm2		// r3	0
				psubsw	mm6, mm2		// r4	0

				movq		mm2, [tmmxf + 1 * 16 + 8]
				pmulhw	mm2, [pC7pC7pC7pC7]
				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC5pC5pC5pC5]
				psubsw	mm2, mm3
				movq		mm3, [tmmxf + 5 * 16 + 8]
				pmulhw	mm3, [pC3pC3pC3pC3]
				paddsw	mm2, mm3
				movq		mm3, [tmmxf + 7 * 16 + 8]
				pmulhw	mm3, [pC1pC1pC1pC1]
				psubsw	mm2, mm3

				movq		mm7, mm5
				paddsw	mm5, mm2		// r3 1
				psubsw	mm7, mm2		// r4 1

				psraw		mm4, 5
				psraw		mm6, 5
				psraw		mm5, 5
				psraw		mm7, 5

				packuswb	mm4, mm5
				packuswb	mm6, mm7

				movq		[ebx + esi], mm4			// r0
				movq		[ecx], mm6	// r7

				//////////////////////////////

				pxor		mm7, mm7

				movq		mm0, [tmmxf + 0 * 16 + 0]
				psubsw	mm0, [tmmxf + 4 * 16 + 0]
				psraw		mm0, 2
				paddsw	mm0, [RoundSecond0]

				movq		[tmmxf + 0 * 16 + 0], mm7
				movq		[tmmxf + 4 * 16 + 0], mm7

				movq		mm1, [tmmxf + 0 * 16 + 8]
				psubsw	mm1, [tmmxf + 4 * 16 + 8]
				psraw		mm1, 2
				paddsw	mm1, [RoundSecond0]

				movq		[tmmxf + 0 * 16 + 8], mm7
				movq		[tmmxf + 4 * 16 + 8], mm7

				movq		mm2, [tmmxf + 2 * 16 + 0]
				pmulhw	mm2, [pC6pC6pC6pC6]
				movq		mm3, [tmmxf + 6 * 16 + 0]
				pmulhw	mm3, [pC2pC2pC2pC2]
				psubsw	mm2, mm3 // y2 0

				movq		[tmmxf + 2 * 16 + 0], mm7
				movq		[tmmxf + 6 * 16 + 0], mm7

				movq		mm3, [tmmxf + 2 * 16 + 8]
				pmulhw	mm3, [pC6pC6pC6pC6]
				movq		mm4, [tmmxf + 6 * 16 + 8]
				pmulhw	mm4, [pC2pC2pC2pC2]
				psubsw	mm3, mm4 // y2 1

				movq		[tmmxf + 2 * 16 + 8], mm7
				movq		[tmmxf + 6 * 16 + 8], mm7

				movq		mm4, mm0
				paddsw	mm0, mm2	// a1 0
				psubsw	mm4, mm2 // a2 0

				movq		mm5, mm1
				paddsw	mm1, mm3 // a1 1
				psubsw	mm5, mm3 // a2 1

				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, [pC3pC3pC3pC3]
				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC7pC7pC7pC7]
				psubsw	mm2, mm3
				movq		mm3, [tmmxf + 5 * 16 + 0]
				pmulhw	mm3, [pC1pC1pC1pC1]
				psubsw	mm2, mm3
				movq		mm3, [tmmxf + 7 * 16 + 0]
				pmulhw	mm3, [pC5pC5pC5pC5]
				psubsw	mm2, mm3

				movq		mm6, mm0
				paddsw	mm0, mm2		// r1	0
				psubsw	mm6, mm2		// r6	0

				movq		mm2, [tmmxf + 1 * 16 + 8]
				pmulhw	mm2, [pC3pC3pC3pC3]
				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC7pC7pC7pC7]
				psubsw	mm2, mm3
				movq		mm3, [tmmxf + 5 * 16 + 8]
				pmulhw	mm3, [pC1pC1pC1pC1]
				psubsw	mm2, mm3
				movq		mm3, [tmmxf + 7 * 16 + 8]
				pmulhw	mm3, [pC5pC5pC5pC5]
				psubsw	mm2, mm3

				movq		mm7, mm1
				paddsw	mm1, mm2		// r1 1
				psubsw	mm7, mm2		// r6 1

				psraw		mm0, 5
				psraw		mm6, 5
				psraw		mm1, 5
				psraw		mm7, 5

				packuswb	mm0, mm1
				packuswb	mm6, mm7

				movq		[ebx + edx], mm0			// r1
				movq		[ecx + 2 * edx], mm6	// r6

				//////
				pxor		mm7, mm7

				movq		mm2, [tmmxf + 1 * 16 + 0]
				pmulhw	mm2, [pC5pC5pC5pC5]
				movq		mm3, [tmmxf + 3 * 16 + 0]
				pmulhw	mm3, [pC1pC1pC1pC1]
				psubsw	mm2, mm3
				movq		mm3, [tmmxf + 5 * 16 + 0]
				pmulhw	mm3, [pC7pC7pC7pC7]
				paddsw	mm2, mm3
				movq		mm3, [tmmxf + 7 * 16 + 0]
				pmulhw	mm3, [pC3pC3pC3pC3]
				paddsw	mm2, mm3

				movq		[tmmxf + 1 * 16 + 0], mm7
				movq		[tmmxf + 3 * 16 + 0], mm7
				movq		[tmmxf + 5 * 16 + 0], mm7
				movq		[tmmxf + 7 * 16 + 0], mm7

				movq		mm6, mm4
				paddsw	mm4, mm2		// r2	0
				psubsw	mm6, mm2		// r5	0

				movq		mm2, [tmmxf + 1 * 16 + 8]
				pmulhw	mm2, [pC5pC5pC5pC5]
				movq		mm3, [tmmxf + 3 * 16 + 8]
				pmulhw	mm3, [pC1pC1pC1pC1]
				psubsw	mm2, mm3
				movq		mm3, [tmmxf + 5 * 16 + 8]
				pmulhw	mm3, [pC7pC7pC7pC7]
				paddsw	mm2, mm3
				movq		mm3, [tmmxf + 7 * 16 + 8]
				pmulhw	mm3, [pC3pC3pC3pC3]
				paddsw	mm2, mm3

				movq		[tmmxf + 1 * 16 + 8], mm7
				movq		[tmmxf + 3 * 16 + 8], mm7
				movq		[tmmxf + 5 * 16 + 8], mm7
				movq		[tmmxf + 7 * 16 + 8], mm7

				movq		mm7, mm5
				paddsw	mm5, mm2		// r2 1
				psubsw	mm7, mm2		// r5 1

				psraw		mm4, 5
				psraw		mm6, 5
				psraw		mm5, 5
				psraw		mm7, 5

				packuswb	mm4, mm5
				packuswb	mm6, mm7

				movq		[ebx + 2 * edx], mm4			// r2
				movq		[ecx + edx], mm6	// r5
				}
		}
	}





GenericXMMXMacroBlockIDCTDecoder::GenericXMMXMacroBlockIDCTDecoder(void)
	: GenericMMXMacroBlockIDCTDecoder()
	{
	}

void GenericXMMXMacroBlockIDCTDecoder::ParseIntraBlock(int num, int yuvType, int & dcPredictor, int * matrix, short * mb, int stride)
	{
	int l;

	l = ParseIntraBlockMatrix(yuvType, dcPredictor, matrix);
	InverseDCT(mb, stride, dctMulTable[yuvType], hfluti[(((l >> 25) + 8) >> 3) & 0x0f], hfluti[(l >> 17) & 0x0f]);
	}

void GenericXMMXMacroBlockIDCTDecoder::ParseNonIntraBlock(int num, int yuvType, int * matrix, short * mb, int stride)
	{
	int l;

	l = ParseNonIntraBlockMatrix(matrix);
	InverseDCT(mb, stride, dctMulTable[yuvType], hflut[hurryUp][(((l >> 25) + 8) >> 3) & 0x0f], hflut[hurryUp][(l >> 17) & 0x0f]);
	}

void GenericXMMXMacroBlockIDCTDecoder::ParseNonIntraBlocks(int codedBlockPattern, short ** yuvp, int * yuvd, int * matrix, int * offset)
	{
	int l, i, t;
	static char tp[] = {0, 0, 0, 0, 1, 2};

	for(i=0; i<6; i++)
		{
		if ((codedBlockPattern << i) & 0x20)
			{
			t = tp[i];
			l = ParseNonIntraBlockMatrix(matrix);
			tmmxf[0][0] += (short)offset[t];
			InverseDCT(yuvp[i], yuvd[t], dctMulTable[t], hflut[hurryUp][(((l >> 25) + 8) >> 3) & 0x0f], hflut[hurryUp][(l >> 17) & 0x0f]);
			}
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\IDCTTables.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "IDCTTables.h"

void DCTMulTable::CalculateTable(int fact)
	{
	short c1, c2, c3, c4, c5, c6, c7, c8;
	double mul = (1 << ACCURATE) * (fact / 128.);

	c1 = (short) ( floor((DC1 * mul) + 0.5) );
	c2 = (short) ( floor((DC2 * mul) + 0.5) );
	c3 = (short) ( floor((DC3 * mul) + 0.5) );
	c4 = (short) ( floor((DC4 * mul) + 0.5) );
	c5 = (short) ( floor((DC5 * mul) + 0.5) );
	c6 = (short) ( floor((DC6 * mul) + 0.5) );
	c7 = (short) ( floor((DC7 * mul) + 0.5) );
	c8 = (short) ( floor((DC8 * mul) + 0.5) );

	tpC8pC8pC8pC8[0] =  c8; tpC8pC8pC8pC8[1] =  c8;
	tpC8pC8pC8pC8[2] =  c8; tpC8pC8pC8pC8[3] =  c8;

	tpC8000000000[0] =  c8; tpC8000000000[1] =   0;
	tpC8000000000[2] =   0; tpC8000000000[3] =   0;

	tpC8pC7pC8pC5[0] =  c5; tpC8pC7pC8pC5[1] =  c8;
	tpC8pC7pC8pC5[2] =  c7; tpC8pC7pC8pC5[3] =  c8;

	tpC8pC3pC8pC1[0] =  c1; tpC8pC3pC8pC1[1] =  c8;
	tpC8pC3pC8pC1[2] =  c3; tpC8pC3pC8pC1[3] =  c8;

	tpC8mC1pC8mC3[0] = -c3; tpC8mC1pC8mC3[1] =  c8;
	tpC8mC1pC8mC3[2] = -c1; tpC8mC1pC8mC3[3] =  c8;

	tpC8mC5pC8mC7[0] = -c7; tpC8mC5pC8mC7[1] =  c8;
	tpC8mC5pC8mC7[2] = -c5; tpC8mC5pC8mC7[3] =  c8;

	tmC2pC7mC6pC5[0] =  c5; tmC2pC7mC6pC5[1] = -c6;
	tmC2pC7mC6pC5[2] =  c7; tmC2pC7mC6pC5[3] = -c2;

	tpC6pC3pC2pC1[0] =  c1; tpC6pC3pC2pC1[1] =  c2;
	tpC6pC3pC2pC1[2] =  c3; tpC6pC3pC2pC1[3] =  c6;

	tpC2mC1pC6mC3[0] = -c3; tpC2mC1pC6mC3[1] =  c6;
	tpC2mC1pC6mC3[2] = -c1; tpC2mC1pC6mC3[3] =  c2;

	tmC6mC5mC2mC7[0] = -c7; tmC6mC5mC2mC7[1] = -c2;
	tmC6mC5mC2mC7[2] = -c5; tmC6mC5mC2mC7[3] = -c6;

	tpC6pC8pC2pC8[0] =  c8; tpC6pC8pC2pC8[1] =  c2;
	tpC6pC8pC2pC8[2] =  c8; tpC6pC8pC2pC8[3] =  c6;

	tmC2pC8mC6pC8[0] =  c8; tmC2pC8mC6pC8[1] = -c6;
	tmC2pC8mC6pC8[2] =  c8; tmC2pC8mC6pC8[3] = -c2;

	tmC7pC3pC3pC1[0] =  c1; tmC7pC3pC3pC1[1] =  c3;
	tmC7pC3pC3pC1[2] =  c3; tmC7pC3pC3pC1[3] = -c7;

	tmC5pC7mC1pC5[0] =  c5; tmC5pC7mC1pC5[1] = -c1;
	tmC5pC7mC1pC5[2] =  c7; tmC5pC7mC1pC5[3] = -c5;

	tmC8pC8pC8pC8[0] =  c8; tmC8pC8pC8pC8[1] =  c8;
	tmC8pC8pC8pC8[2] =  c8; tmC8pC8pC8pC8[3] = -c8;

	tmC2pC6pC6pC2[0] =  c2; tmC2pC6pC6pC2[1] =  c6;
	tmC2pC6pC6pC2[2] =  c6; tmC2pC6pC6pC2[3] = -c2;

	tmC1pC3pC5pC1[0] =  c1; tmC1pC3pC5pC1[1] =  c5;
	tmC1pC3pC5pC1[2] =  c3; tmC1pC3pC5pC1[3] = -c1;

	tpC3pC7pC7pC5[0] =  c5; tpC3pC7pC7pC5[1] =  c7;
	tpC3pC7pC7pC5[2] =  c7; tpC3pC7pC7pC5[3] =  c3;

	tmC5mC7pC7pC3[0] =  c3; tmC5mC7pC7pC3[1] =  c7;
	tmC5mC7pC7pC3[2] = -c7; tmC5mC7pC7pC3[3] = -c5;

	tmC1mC5pC3mC1[0] = -c1; tmC1mC5pC3mC1[1] =  c3;
	tmC1mC5pC3mC1[2] = -c5; tmC1mC5pC3mC1[3] = -c1;

	tpC8pC8_000000_pC8pC8_000000[0] = c8;
	tpC8pC8_000000_pC8pC8_000000[1] = 0;
	tpC8pC8_000000_pC8pC8_000000[2] = c8;
	tpC8pC8_000000_pC8pC8_000000[3] = 0;

	tpC2pC6_pC6mC2_mC2mC6_mC6pC2[0] = (short)(( (int)c2 + (int)c6 + 1) >> 1);
	tpC2pC6_pC6mC2_mC2mC6_mC6pC2[1] = (short)((-(int)c2 + (int)c6 + 1) >> 1);
	tpC2pC6_pC6mC2_mC2mC6_mC6pC2[2] = (short)((-(int)c2 - (int)c6 + 1) >> 1);
	tpC2pC6_pC6mC2_mC2mC6_mC6pC2[3] = (short)(( (int)c2 - (int)c6 + 1) >> 1);

	tpC1pC3_pC5mC1_pC3mC7_pC7mC5[0] = (short)(( (int)c1 + (int)c3 + 1) >> 1);
	tpC1pC3_pC5mC1_pC3mC7_pC7mC5[1] = (short)(( (int)c5 - (int)c1 + 1) >> 1);
	tpC1pC3_pC5mC1_pC3mC7_pC7mC5[2] = (short)(( (int)c3 - (int)c7 + 1) >> 1);
	tpC1pC3_pC5mC1_pC3mC7_pC7mC5[3] = (short)(( (int)c7 - (int)c5 + 1) >> 1);

	tpC7pC5_pC3pC7_mC5mC1_mC1pC3[0] = (short)(( (int)c7 + (int)c5 + 1) >> 1);
	tpC7pC5_pC3pC7_mC5mC1_mC1pC3[1] = (short)(( (int)c3 + (int)c7 + 1) >> 1);
	tpC7pC5_pC3pC7_mC5mC1_mC1pC3[2] = (short)((-(int)c5 - (int)c1 + 1) >> 1);
	tpC7pC5_pC3pC7_mC5mC1_mC1pC3[3] = (short)((-(int)c1 + (int)c3 + 1) >> 1);

	pC8pC8_tpC3pC1_pC8pC8_pC7pC5[0] = c8;
	pC8pC8_tpC3pC1_pC8pC8_pC7pC5[1] = (short)(( (int)c3 + (int)c1 + 1) >> 1);
	pC8pC8_tpC3pC1_pC8pC8_pC7pC5[2] = c8;
	pC8pC8_tpC3pC1_pC8pC8_pC7pC5[3] = (short)(( (int)c7 + (int)c5 + 1) >> 1);
	pC8pC8_tmC5mC7_pC8pC8_mC1mC3[0] = c8;
	pC8pC8_tmC5mC7_pC8pC8_mC1mC3[1] = (short)((-(int)c7 - (int)c5 + 1) >> 1);
	pC8pC8_tmC5mC7_pC8pC8_mC1mC3[2] = c8;
	pC8pC8_tmC5mC7_pC8pC8_mC1mC3[3] = (short)((-(int)c3 - (int)c1 + 1) >> 1);

	tpC2pC6_pC3pC1_mC2mC6_pC7pC5[0] = (short)(( (int)c2 + (int)c6 + 1) >> 1);
	tpC2pC6_pC3pC1_mC2mC6_pC7pC5[1] = (short)(( (int)c3 + (int)c1 + 1) >> 1);
	tpC2pC6_pC3pC1_mC2mC6_pC7pC5[2] = (short)((-(int)c2 - (int)c6 + 1) >> 1);
	tpC2pC6_pC3pC1_mC2mC6_pC7pC5[3] = (short)(( (int)c7 + (int)c5 + 1) >> 1);

	tmC2mC6_mC7mC5_pC2pC6_mC3mC1[0] = (short)((-(int)c2 - (int)c6 + 1) >> 1);
	tmC2mC6_mC7mC5_pC2pC6_mC3mC1[1] = (short)((-(int)c7 - (int)c5 + 1) >> 1);
	tmC2mC6_mC7mC5_pC2pC6_mC3mC1[2] = (short)(( (int)c2 + (int)c6 + 1) >> 1);
	tmC2mC6_mC7mC5_pC2pC6_mC3mC1[3] = (short)((-(int)c3 - (int)c1 + 1) >> 1);

	tpC8pC8_pC6pC2_pC8pC8_mC2mC6[0] = c8;
	tpC8pC8_pC6pC2_pC8pC8_mC2mC6[1] = (short)(( (int)c2 + (int)c6 + 1) >> 1);
	tpC8pC8_pC6pC2_pC8pC8_mC2mC6[2] = c8;
	tpC8pC8_pC6pC2_pC8pC8_mC2mC6[3] = (short)((-(int)c2 - (int)c6 + 1) >> 1);

	tpC1pC3_pC3mC7_pC7pC5_mC5mC1[0] = (short)(( (int)c3 + (int)c1 + 1) >> 1);
	tpC1pC3_pC3mC7_pC7pC5_mC5mC1[1] = (short)(( (int)c3 - (int)c7 + 1) >> 1);
	tpC1pC3_pC3mC7_pC7pC5_mC5mC1[2] = (short)(( (int)c7 + (int)c5 + 1) >> 1);
	tpC1pC3_pC3mC7_pC7pC5_mC5mC1[3] = (short)((-(int)c5 - (int)c1 + 1) >> 1);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\IDCTTables.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef IDCTTABLES_H
#define IDCTTABLES_H

#include "driver\SoftwareCinemaster\Common\Prelude.h"
#include <math.h>

//
// ACCURATE			: fractional bits of DCT
// FREQ_PREC		: fractional bits of frequency coefficients
// DCT_PREC			: fractional bits difference second to first step
// INTER_PREC		: fractional bits in middle stage
// FIRST_SHIFT		: number of bitshifts between first and second stage


#define ACCURATE					14
#define FREQ_PREC					3
#define INTER_PREC				7
#define DCT_PREC					(INTER_PREC - FREQ_PREC)

#define ONE_SHIFT					(FREQ_PREC + ACCURATE - 16)
#define FIRST_SHIFT				(ACCURATE - DCT_PREC)
#define SECOND_SHIFT				(INTER_PREC + ACCURATE - 16)

#define ROUND_ONE					(1 << (ONE_SHIFT - 1))
#define ROUND_SINGLE				(1 << (INTER_PREC - 1))
#define ROUND_SECOND				(1 << (SECOND_SHIFT - 1))

#define FLOAT_SHIFT				(1 << ACCURATE)

static const double pi = acos(0) * 2;
static const double DC1 = sqrt(2) * cos(pi*1/16);
static const double DC2 = sqrt(2) * cos(pi*2/16);
static const double DC3 = sqrt(2) * cos(pi*3/16);
static const double DC4 = sqrt(2) * cos(pi*4/16);
static const double DC5 = sqrt(2) * cos(pi*5/16);
static const double DC6 = sqrt(2) * cos(pi*6/16);
static const double DC7 = sqrt(2) * cos(pi*7/16);
static const double DC8 = 1.0000000000;

#define FCTI(x) ((int) ( floor(((x) * FLOAT_SHIFT) + 0.5) ))
#define FCCTI(x, y) FCTI((x + y) / 2)

static const short C1 =  (short) ( floor((DC1 * FLOAT_SHIFT) + 0.5) );
static const short C2 =  (short) ( floor((DC2 * FLOAT_SHIFT) + 0.5) );
static const short C3 =  (short) ( floor((DC3 * FLOAT_SHIFT) + 0.5) );
static const short C4 =  (short) ( floor((DC4 * FLOAT_SHIFT) + 0.5) );
static const short C5 =  (short) ( floor((DC5 * FLOAT_SHIFT) + 0.5) );
static const short C6 =  (short) ( floor((DC6 * FLOAT_SHIFT) + 0.5) );
static const short C7 =  (short) ( floor((DC7 * FLOAT_SHIFT) + 0.5) );
static const short C8 =  (short) ( floor((               FLOAT_SHIFT) + 0.5) );

static const short C1a = (short) ( floor(((DC1 - 1) * FLOAT_SHIFT * 4) + 0.5) );
static const short C2a = (short) ( floor(((DC2 - 1) * FLOAT_SHIFT * 4) + 0.5) );
static const short C3a = (short) ( floor(((DC3 - 1) * FLOAT_SHIFT * 4) + 0.5) );
static const short C5a = (short) ( floor(( DC5      * FLOAT_SHIFT * 2) + 0.5) );
static const short C6a = (short) ( floor(( DC6 		* FLOAT_SHIFT * 2) + 0.5) );
static const short C7a = (short) ( floor(( DC7 		* FLOAT_SHIFT * 4) + 0.5) );

static MMXQShort pC6pC2mC2pC6 = { C6, -C2,  C2,  C6};
static MMXQShort pC7pC3pC3mC1 = {-C1,  C3,  C3,  C7};
static MMXQShort mC1pC5mC5pC7 = { C7, -C5,  C5, -C1};
static MMXQShort pC5pC7mC1mC5 = {-C5, -C1,  C7,  C5};
static MMXQShort pC3pC1mC7pC3 = { C3, -C7,  C1,  C3};

static MMXQShort pC8pC8pC8pC8 = { C8,  C8,  C8,  C8};
static MMXQShort pC1pC1pC1pC1 = { C1,  C1,  C1,  C1};
static MMXQShort pC2pC2pC2pC2 = { C2,  C2,  C2,  C2};
static MMXQShort pC3pC3pC3pC3 = { C3,  C3,  C3,  C3};
static MMXQShort pC5pC5pC5pC5 = { C5,  C5,  C5,  C5};
static MMXQShort pC6pC6pC6pC6 = { C6,  C6,  C6,  C6};
static MMXQShort pC7pC7pC7pC7 = { C7,  C7,  C7,  C7};
static MMXQShort pC8000000000 = { C8,   0,   0,   0};

static MMXQShort pC1pC1pC1pC1a = { C1a,  C1a,  C1a,  C1a};
static MMXQShort pC2pC2pC2pC2a = { C2a,  C2a,  C2a,  C2a};
static MMXQShort pC3pC3pC3pC3a = { C3a,  C3a,  C3a,  C3a};
static MMXQShort pC5pC5pC5pC5a = { C5a,  C5a,  C5a,  C5a};
static MMXQShort pC6pC6pC6pC6a = { C6a,  C6a,  C6a,  C6a};
static MMXQShort pC7pC7pC7pC7a = { C7a,  C7a,  C7a,  C7a};

static MMXQShort pC1pC3pC3mC7 = {-C7,  C3,  C3,  C1};
static MMXQShort pC5mC1pC7mC5 = {-C5,  C7, -C1,  C5};
static MMXQShort pC2pC6pC6mC2 = {-C2,  C6,  C6,  C2};
static MMXQShort pC7mC5pC5mC1 = {-C1,  C5, -C5,  C7};
static MMXQShort pC3mC1pC7pC3 = { C3,  C7, -C1,  C3};

static MMXQShort pC6pC2mC8pC8 = { C8, -C8,  C2,  C6};
static MMXQShort pC8pC8mC2pC6 = { C6, -C2,  C8,  C8};
static MMXQShort pC2mC6pC8pC8 = { C8,  C8, -C6,  C2};
static MMXQShort mC8pC8mC6mC2 = {-C2, -C6,  C8, -C8};
static MMXQShort pC7pC3mC1pC3 = { C3, -C1,  C3,  C7};
static MMXQShort pC5pC1mC5mC7 = {-C7, -C5,  C1,  C5};
static MMXQShort pC3mC1pC3pC7 = { C7,  C3, -C1,  C3};
static MMXQShort pC7pC5mC1mC5 = {-C5, -C1,  C5,  C7};

static MMXQShort pC7mC5pC3mC1 = {-C1,  C3, -C5,  C7};
static MMXQShort pC5mC1pC7pC3 = { C3,  C7, -C1,  C5};
static MMXQShort pC3mC7mC1mC5 = {-C5, -C1, -C7,  C3};
static MMXQShort pC1pC3pC5pC7 = { C7,  C5,  C3,  C1};
static MMXQShort pC6mC2pC2mC6 = {-C6,  C2, -C2,  C6};
static MMXQShort pC2pC6mC6mC2 = {-C2, -C6,  C6,  C2};
static MMXQShort pC8mC8mC8pC8 = { C8, -C8, -C8,  C8};

static MMXQShort pC8pC7pC8pC5 = { C5,  C8,  C7,  C8};
static MMXQShort pC8pC3pC8pC1 = { C1,  C8,  C3,  C8};
static MMXQShort pC8mC1pC8mC3 = {-C3,  C8, -C1,  C8};
static MMXQShort pC8mC5pC8mC7 = {-C7,  C8, -C5,  C8};

static MMXQShort mC2pC7mC6pC5 = { C5, -C6,  C7, -C2};
static MMXQShort pC6pC3pC2pC1 = { C1,  C2,  C3,  C6};
static MMXQShort pC2mC1pC6mC3 = {-C3,  C6, -C1,  C2};
static MMXQShort mC6mC5mC2mC7 = {-C7, -C2, -C5, -C6};

static MMXQShort pC6pC8pC2pC8 = { C8,  C2,  C8,  C6};
static MMXQShort mC2pC8mC6pC8 = { C8, -C6,  C8, -C2};
static MMXQShort mC7pC3pC3pC1 = { C1,  C3,  C3, -C7};
static MMXQShort mC5pC7mC1pC5 = { C5, -C1,  C7, -C5};

static MMXQShort mC1mC5pC3mC1 = {-C1,  C3, -C5, -C1};
static MMXQShort mC5mC7pC7pC3 = { C3,  C7, -C7, -C5};
static MMXQShort pC3pC7pC7pC5 = { C5,  C7,  C7,  C3};
static MMXQShort mC1pC3pC5pC1 = { C1,  C5,  C3, -C1};
static MMXQShort mC2pC6pC6pC2 = { C2,  C6,  C6, -C2};
static MMXQShort mC8pC8pC8pC8 = { C8,  C8,  C8, -C8};



static MMXQShort pC8pC8_pC8pC8_pC8pC8_pC8pC8 = {FCCTI( DC8, DC8), FCCTI( DC8, DC8), FCCTI( DC8, DC8), FCCTI( DC8, DC8)};
static MMXQShort pC2pC6_mC2mC6_mC2mC6_pC2pC6 = {FCCTI( DC6, DC2), FCCTI(-DC2,-DC6), FCCTI(-DC2,-DC6), FCCTI( DC6, DC2)};
static MMXQShort mC2pC6_pC2mC6_pC2mC6_mC2pC6 = {FCCTI(-DC2, DC6), FCCTI( DC2,-DC6), FCCTI( DC2,-DC6), FCCTI(-DC2, DC6)};

static MMXQShort mC1mC3_mC5mC7_pC5pC7_pC1pC3 = {FCCTI( DC1, DC3), FCCTI( DC5, DC7), FCCTI(-DC5,-DC7), FCCTI(-DC1,-DC3)};
static MMXQShort mC3pC7_pC1pC5_mC1mC5_pC3mC7 = {FCCTI( DC3,-DC7), FCCTI(-DC1,-DC5), FCCTI( DC1, DC5), FCCTI(-DC3, DC7)};
static MMXQShort mC5pC1_mC7mC3_pC7pC3_pC5mC1 = {FCCTI( DC5,-DC1), FCCTI( DC7, DC3), FCCTI(-DC7,-DC3), FCCTI(-DC5, DC1)};
static MMXQShort mC7pC5_mC3pC1_pC3mC1_pC7mC5 = {FCCTI( DC7,-DC5), FCCTI( DC3,-DC1), FCCTI(-DC3, DC1), FCCTI(-DC7, DC5)};

class DCTMulTable
	{
	public:
		short tpC8pC8pC8pC8[4];
		short tpC8000000000[4];
		short tpC8pC7pC8pC5[4];
		short tpC8pC3pC8pC1[4];
		short tpC8mC1pC8mC3[4];
		short tpC8mC5pC8mC7[4];
		short tmC2pC7mC6pC5[4];
		short tpC6pC3pC2pC1[4];
		short tpC2mC1pC6mC3[4];
		short tmC6mC5mC2mC7[4];
		short tpC6pC8pC2pC8[4];
		short tmC2pC8mC6pC8[4];
		short tmC7pC3pC3pC1[4];
		short tmC5pC7mC1pC5[4];
		short tmC8pC8pC8pC8[4];
		short tmC2pC6pC6pC2[4];
		short tmC1pC3pC5pC1[4];
		short tpC3pC7pC7pC5[4];
		short tmC5mC7pC7pC3[4];
		short tmC1mC5pC3mC1[4];

		short tpC8pC8_000000_pC8pC8_000000[4];
		short tpC2pC6_pC6mC2_mC2mC6_mC6pC2[4];
		short tpC1pC3_pC5mC1_pC3mC7_pC7mC5[4];
		short tpC7pC5_pC3pC7_mC5mC1_mC1pC3[4];

		short pC8pC8_tpC3pC1_pC8pC8_pC7pC5[4];
		short pC8pC8_tmC5mC7_pC8pC8_mC1mC3[4];

		short tpC2pC6_pC3pC1_mC2mC6_pC7pC5[4];
		short tmC2mC6_mC7mC5_pC2pC6_mC3mC1[4];

		short tpC8pC8_pC6pC2_pC8pC8_mC2mC6[4];
		short tpC1pC3_pC3mC7_pC7pC5_mC5mC1[4];

		void CalculateTable(int fact);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\MPEGStatistics.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// MPEGStatistics.h
//
#ifndef MPEGSTATISTICS_H
#define MPEGSTATISTICS_H

#include <stdio.h>

extern int statCoefficients;
extern int statBlocks;
extern int statBlocksIntra;
extern int statBlocksPattern;
extern int statBlocksSkipped;
extern int statPredicts[2][2][2];

void StatFrameCompleted(void);
void StatFrameSkipped(void);

void StatDisplay(FILE * f);

void StatReset(void);

void GetStatistics(char * str);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\Mp2HuffTables.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef MP2HUFFTABLES_H
#define MP2HUFFTABLES_H

#include "huffdec.h"

#define PICTURE_START_CODE		0x00000100
#define USER_DATA_START_CODE	0x000001b2
#define SEQUENCE_HEADER_CODE	0x000001b3
#define SEQUENCE_ERROR_CODE	0x000001b4
#define EXTENSION_START_CODE	0x000001b5
#define SEQUENCE_END_CODE		0x000001b7
#define GROUP_START_CODE		0x000001b8

#define IS_SLICE_HEADER(x)		(x >= 0x00000101 && x <= 0x000001af)

#define SEQUENCE_EXTENSION_ID							1
#define SEQUENCE_DISPLAY_EXTENSION_ID				2
#define QUANT_MATRIX_EXTENSION_ID					3
#define COPYRIGHT_EXTENSION_ID						4
#define SEQUENCE_SCALABLE_EXTENSION_ID				5

#define PICTURE_DISPLAY_EXTENSION_ID				7
#define PICTURE_CODING_EXTENSION_ID					8
#define PICTURE_SPATIAL_EXTENSION_ID				9
#define PICTURE_TEMPORAL_SCALABLE_EXTENSION_ID	10

enum PredictionType
	{
	PT_FIELD_BASED,
	PT_FRAME_BASED,
	PT_DUAL_PRIME,
	PT_16x8MC
	};

#define RL(run, level)	((run << 12) | (level & 0xfff))
#define RLF(run, level)	((run << 12) | (level & 0xfff))
#define RLRUN(x)		(int)((unsigned)x >> 20)
#define RLLEVEL(x)	((int)x << 12 >> 20)

#define MF_DUAL_PRIME_PREDICTION				0x200
#define MF_16X8_PREDICTION						0x100
#define MF_ALTERNATE_DCT						0x080
#define MF_FIELD_PREDICTION					0x040
#define MF_FRAME_PREDICTION					0x020
#define MF_QUANT									0x010
#define MF_MOTION_FORWARD						0x008
#define MF_MOTION_BACKWARD						0x004
#define MF_PATTERN								0x002
#define MF_INTRA									0x001

#define IS_MACROBLOCK_ALTERNATE_DCT(x)				((x & MF_ALTERNATE_DCT) != 0)
#define IS_MACROBLOCK_QUANT(x)						((x & MF_QUANT) != 0)
#define IS_MACROBLOCK_PATTERN(x)						((x & MF_PATTERN) != 0)
#define IS_MACROBLOCK_INTRA(x)						((x & MF_INTRA) != 0)
#define IS_MACROBLOCK_FIELD_PREDICTION(x)			((x & MF_FIELD_PREDICTION) != 0)
#define IS_MACROBLOCK_FRAME_PREDICTION(x)			((x & MF_FRAME_PREDICTION) != 0)
#define IS_MACROBLOCK_16X8_PREDICTION(x)			((x & MF_16X8_PREDICTION) != 0)
#define IS_MACROBLOCK_DUAL_PRIME_PREDICTION(x)	((x & MF_DUAL_PRIME_PREDICTION) != 0)
#define IS_MACROBLOCK_MOTION_FORWARD(x)			((x & MF_MOTION_FORWARD) != 0)
#define IS_MACROBLOCK_MOTION_BACKWARD(x)			((x & MF_MOTION_BACKWARD) != 0)
#define IS_MACROBLOCK_MOTION(x)						((x & (MF_MOTION_FORWARD | MF_MOTION_BACKWARD)) != 0)

#define MKMFMVCNT(t)	(IS_MACROBLOCK_MOTION(t) ? (IS_MACROBLOCK_FIELD_PREDICTION(t) ? 2 : 1) : 0)
#define MKMFPT(t) (IS_MACROBLOCK_FIELD_PREDICTION(t) ? PT_FIELD_BASED : (IS_MACROBLOCK_DUAL_PRIME_PREDICTION(t) ? PT_DUAL_PRIME : PT_FRAME_BASED))
#define MKMIMVCNT(t)	(IS_MACROBLOCK_MOTION(t) ? (IS_MACROBLOCK_16X8_PREDICTION(t) ? 2 : 1) : 0)
#define MKMIPT(t) (IS_MACROBLOCK_16X8_PREDICTION(t) ? PT_16x8MC : (IS_MACROBLOCK_DUAL_PRIME_PREDICTION(t) ? PT_DUAL_PRIME : PT_FIELD_BASED))

#define MKMF(flags)	flags | (MKMFMVCNT((flags)) << 12) | (MKMFPT((flags)) << 14)
#define MKMI(flags)	flags | (MKMIMVCNT((flags)) << 12) | (MKMIPT((flags)) << 14)
#define MACROBLOCK_MOTION_COUNT(x) ((x >> 12) & 3)
#define MACROBLOCK_PREDICT_TYPE(x) (PredictionType)((x >> 14) & 3)

extern HuffmanTable	macroBlockAddressIncrement;
extern HuffmanTable	iFrameMacroBlockType;
extern HuffmanTable	bFrameMacroBlockType;
extern HuffmanTable	pFrameMacroBlockType;

extern HuffmanTable	iFrameMacroBlockTypeFPFD;
extern HuffmanTable	bFrameMacroBlockTypeFPFD;
extern HuffmanTable	pFrameMacroBlockTypeFPFD;

extern HuffmanTable	iFieldMacroBlockType;
extern HuffmanTable	bFieldMacroBlockType;
extern HuffmanTable	pFieldMacroBlockType;

extern HuffmanTable	codedBlockPattern420;
extern HuffmanTable	motionCodes;
extern HuffmanTable	dmtVector;
extern HuffmanTable	dctDCSizeLuminance;
extern HuffmanTable	dctDCSizeChrominance;
extern HuffmanTable	dctCoefficientZeroFirst;
extern HuffmanTable	dctCoefficientZero;
extern HuffmanTable	dctCoefficientOne;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\Mp2HuffTables.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "Mp2HuffTables.h"

struct HuffInit MacroBlockAddressIncrementInit[] = {
	{"1",					1},
	{"011",				2},
	{"010",				3},
	{"0011",				4},
	{"0010",				5},
	{"00011",			6},
	{"00010",			7},
	{"0000111",			8},
	{"0000110",			9},
	{"00001011",		10},
	{"00001010",		11},
	{"00001001",		12},
	{"00001000",		13},
	{"00000111",		14},
	{"00000110",		15},
	{"0000010111",		16},
	{"0000010110",		17},
	{"0000010101",		18},
	{"0000010100",		19},
	{"0000010011",		20},
	{"0000010010",		21},
	{"00000100011",	22},
	{"00000100010",	23},
	{"00000100001",	24},
	{"00000100000",	25},
	{"00000011111",	26},
	{"00000011110",	27},
	{"00000011101",	28},
	{"00000011100",	29},
	{"00000011011",	30},
	{"00000011010",	31},
	{"00000011001",	32},
	{"00000011000",	33},
	{"00000001000",	34},
	{NULL, 0}};

struct HuffInit IFrameMacroBlockTypeInit[] = {
	{"10",		MKMF(MF_FRAME_PREDICTION | MF_INTRA)},
	{"11",		MKMF(MF_FRAME_PREDICTION | MF_ALTERNATE_DCT | MF_INTRA)},
   {"010",		MKMF(MF_FRAME_PREDICTION | MF_QUANT | MF_INTRA)},
   {"011",		MKMF(MF_FRAME_PREDICTION | MF_ALTERNATE_DCT | MF_QUANT | MF_INTRA)},

	// security to fill empy slot
	{"00",		0},

   {NULL,		0}};

struct HuffInit PFrameMacroBlockTypeInit[] = {
	{"010",			MKMF(                   MF_FRAME_PREDICTION | MF_PATTERN)},
	{"011",			MKMF(MF_ALTERNATE_DCT | MF_FRAME_PREDICTION | MF_PATTERN)},
	{"1000",			MKMF(                                         MF_PATTERN | MF_MOTION_FORWARD)},
	{"1001",			MKMF(MF_ALTERNATE_DCT |                       MF_PATTERN | MF_MOTION_FORWARD)},
	{"1010",			MKMF(                   MF_FIELD_PREDICTION | MF_PATTERN | MF_MOTION_FORWARD)},
	{"1011",			MKMF(MF_ALTERNATE_DCT | MF_FIELD_PREDICTION | MF_PATTERN | MF_MOTION_FORWARD)},
	{"1100",			MKMF(                   MF_FRAME_PREDICTION | MF_PATTERN | MF_MOTION_FORWARD)},
	{"1101",			MKMF(MF_ALTERNATE_DCT | MF_FRAME_PREDICTION | MF_PATTERN | MF_MOTION_FORWARD)},
	{"1110",			MKMF(                   MF_DUAL_PRIME_PREDICTION | MF_PATTERN | MF_MOTION_FORWARD)},
	{"1111",			MKMF(MF_ALTERNATE_DCT | MF_DUAL_PRIME_PREDICTION | MF_PATTERN | MF_MOTION_FORWARD)},

	{"00100",		MKMF(                                            MF_MOTION_FORWARD)},
	{"00101",		MKMF(                      MF_FIELD_PREDICTION | MF_MOTION_FORWARD)},
	{"00110",		MKMF(MF_FRAME_PREDICTION |                       MF_MOTION_FORWARD)},
	{"00111",		MKMF(MF_DUAL_PRIME_PREDICTION                  | MF_MOTION_FORWARD)},

	{"000010",		MKMF(                   MF_FRAME_PREDICTION | MF_QUANT | MF_PATTERN)},
	{"000011",		MKMF(MF_ALTERNATE_DCT | MF_FRAME_PREDICTION | MF_QUANT | MF_PATTERN)},
	{"000110",		MKMF(                   MF_FRAME_PREDICTION | MF_INTRA)},
	{"000111",		MKMF(MF_ALTERNATE_DCT | MF_FRAME_PREDICTION | MF_INTRA)},
	{"0000010",		MKMF(                   MF_FRAME_PREDICTION | MF_QUANT | MF_INTRA)},
	{"0000011",		MKMF(MF_ALTERNATE_DCT | MF_FRAME_PREDICTION | MF_QUANT | MF_INTRA)},
	{"00010000",	MKMF(                   MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"00010001",	MKMF(MF_ALTERNATE_DCT | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"00010010",	MKMF(                   MF_FIELD_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"00010011",	MKMF(MF_ALTERNATE_DCT | MF_FIELD_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"00010100",	MKMF(                   MF_FRAME_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"00010101",	MKMF(MF_ALTERNATE_DCT | MF_FRAME_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"00010110",	MKMF(                   MF_DUAL_PRIME_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"00010111",	MKMF(MF_ALTERNATE_DCT | MF_DUAL_PRIME_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},

	{NULL,		0}};

struct HuffInit BFrameMacroBlockTypeInit[] = {
	{"1000",			MKMF(MF_MOTION_FORWARD | MF_MOTION_BACKWARD)},
	{"01000",		MKMF(MF_MOTION_BACKWARD)},
	{"001000",		MKMF(MF_MOTION_FORWARD)},

	{"1001",			MKMF(MF_FIELD_PREDICTION | MF_MOTION_FORWARD | MF_MOTION_BACKWARD)},
	{"01001",		MKMF(MF_FIELD_PREDICTION | MF_MOTION_BACKWARD)},
	{"001001",		MKMF(MF_FIELD_PREDICTION | MF_MOTION_FORWARD)},

	{"1010",			MKMF(MF_FRAME_PREDICTION | MF_MOTION_FORWARD | MF_MOTION_BACKWARD)},
	{"01010",		MKMF(MF_FRAME_PREDICTION | MF_MOTION_BACKWARD)},
	{"001010",		MKMF(MF_FRAME_PREDICTION | MF_MOTION_FORWARD)},

	{"1011",			MKMF(MF_DUAL_PRIME_PREDICTION | MF_MOTION_FORWARD | MF_MOTION_BACKWARD)},
	{"01011",		MKMF(MF_DUAL_PRIME_PREDICTION | MF_MOTION_BACKWARD)},
	{"001011",		MKMF(MF_DUAL_PRIME_PREDICTION | MF_MOTION_FORWARD)},

	{"11000",		MKMF(MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"011000",		MKMF(MF_MOTION_BACKWARD | MF_PATTERN)},
	{"0011000",		MKMF(MF_MOTION_FORWARD | MF_PATTERN)},
	{"00010000",	MKMF(MF_QUANT | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"000011000",	MKMF(MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"000010000",	MKMF(MF_QUANT | MF_MOTION_BACKWARD | MF_PATTERN)},

	{"11010",		MKMF(MF_FIELD_PREDICTION | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"011010",		MKMF(MF_FIELD_PREDICTION | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"0011010",		MKMF(MF_FIELD_PREDICTION | MF_MOTION_FORWARD | MF_PATTERN)},
	{"00010010",	MKMF(MF_FIELD_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"000011010",	MKMF(MF_FIELD_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"000010010",	MKMF(MF_FIELD_PREDICTION | MF_QUANT | MF_MOTION_BACKWARD | MF_PATTERN)},

	{"11100",		MKMF(MF_FRAME_PREDICTION | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"011100",		MKMF(MF_FRAME_PREDICTION | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"0011100",		MKMF(MF_FRAME_PREDICTION | MF_MOTION_FORWARD | MF_PATTERN)},
	{"00010100",	MKMF(MF_FRAME_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"000011100",	MKMF(MF_FRAME_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"000010100",	MKMF(MF_FRAME_PREDICTION | MF_QUANT | MF_MOTION_BACKWARD | MF_PATTERN)},

	{"11110",		MKMF(MF_DUAL_PRIME_PREDICTION | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"011110",		MKMF(MF_DUAL_PRIME_PREDICTION | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"0011110",		MKMF(MF_DUAL_PRIME_PREDICTION | MF_MOTION_FORWARD | MF_PATTERN)},
	{"00010110",	MKMF(MF_DUAL_PRIME_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"000011110",	MKMF(MF_DUAL_PRIME_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"000010110",	MKMF(MF_DUAL_PRIME_PREDICTION | MF_QUANT | MF_MOTION_BACKWARD | MF_PATTERN)},

	{"000110",		MKMF(MF_FRAME_PREDICTION | MF_INTRA)},
	{"0000010",		MKMF(MF_QUANT | MF_INTRA)},

	{"11001",		MKMF(MF_ALTERNATE_DCT | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"011001",		MKMF(MF_ALTERNATE_DCT | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"0011001",		MKMF(MF_ALTERNATE_DCT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"00010001",	MKMF(MF_ALTERNATE_DCT | MF_QUANT | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"000011001",	MKMF(MF_ALTERNATE_DCT | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"000010001",	MKMF(MF_ALTERNATE_DCT | MF_QUANT | MF_MOTION_BACKWARD | MF_PATTERN)},

	{"11011",		MKMF(MF_ALTERNATE_DCT | MF_FIELD_PREDICTION | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"011011",		MKMF(MF_ALTERNATE_DCT | MF_FIELD_PREDICTION | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"0011011",		MKMF(MF_ALTERNATE_DCT | MF_FIELD_PREDICTION | MF_MOTION_FORWARD | MF_PATTERN)},
	{"00010011",	MKMF(MF_ALTERNATE_DCT | MF_FIELD_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"000011011",	MKMF(MF_ALTERNATE_DCT | MF_FIELD_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"000010011",	MKMF(MF_ALTERNATE_DCT | MF_FIELD_PREDICTION | MF_QUANT | MF_MOTION_BACKWARD | MF_PATTERN)},

	{"11101",		MKMF(MF_ALTERNATE_DCT | MF_FRAME_PREDICTION | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"011101",		MKMF(MF_ALTERNATE_DCT | MF_FRAME_PREDICTION | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"0011101",		MKMF(MF_ALTERNATE_DCT | MF_FRAME_PREDICTION | MF_MOTION_FORWARD | MF_PATTERN)},
	{"00010101",	MKMF(MF_ALTERNATE_DCT | MF_FRAME_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"000011101",	MKMF(MF_ALTERNATE_DCT | MF_FRAME_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"000010101",	MKMF(MF_ALTERNATE_DCT | MF_FRAME_PREDICTION | MF_QUANT | MF_MOTION_BACKWARD | MF_PATTERN)},

	{"11111",		MKMF(MF_ALTERNATE_DCT | MF_DUAL_PRIME_PREDICTION | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"011111",		MKMF(MF_ALTERNATE_DCT | MF_DUAL_PRIME_PREDICTION | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"0011111",		MKMF(MF_ALTERNATE_DCT | MF_DUAL_PRIME_PREDICTION | MF_MOTION_FORWARD | MF_PATTERN)},
	{"00010111",	MKMF(MF_ALTERNATE_DCT | MF_DUAL_PRIME_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"000011111",	MKMF(MF_ALTERNATE_DCT | MF_DUAL_PRIME_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"000010111",	MKMF(MF_ALTERNATE_DCT | MF_DUAL_PRIME_PREDICTION | MF_QUANT | MF_MOTION_BACKWARD | MF_PATTERN)},

	{"000111",		MKMF(MF_ALTERNATE_DCT | MF_FRAME_PREDICTION | MF_INTRA)},
	{"0000011",		MKMF(MF_ALTERNATE_DCT | MF_QUANT | MF_INTRA)},

	{NULL,		0}};

struct HuffInit IFrameMacroBlockTypeInitFPFD[] = {
	{"1",    MKMF(MF_FRAME_PREDICTION | MF_INTRA)},
   {"01",	MKMF(MF_FRAME_PREDICTION | MF_QUANT | MF_INTRA)},
   {NULL,	0}};

struct HuffInit PFrameMacroBlockTypeInitFPFD[] = {
	{"1",	 		MKMF(MF_FRAME_PREDICTION | MF_PATTERN | MF_MOTION_FORWARD)},
	{"01",		MKMF(MF_FRAME_PREDICTION | MF_PATTERN)},
	{"001",		MKMF(MF_FRAME_PREDICTION | MF_MOTION_FORWARD)},
	{"00011",	MKMF(MF_FRAME_PREDICTION | MF_INTRA)},
	{"00010",	MKMF(MF_FRAME_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"00001",	MKMF(MF_FRAME_PREDICTION | MF_QUANT | MF_PATTERN)},
	{"000001",	MKMF(MF_FRAME_PREDICTION | MF_QUANT | MF_INTRA)},
	{NULL,		0}};

struct HuffInit BFrameMacroBlockTypeInitFPFD[] = {
	{"10",		MKMF(MF_FRAME_PREDICTION | MF_MOTION_FORWARD | MF_MOTION_BACKWARD)},
	{"11",		MKMF(MF_FRAME_PREDICTION | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"010",		MKMF(MF_FRAME_PREDICTION | MF_MOTION_BACKWARD)},
	{"011",		MKMF(MF_FRAME_PREDICTION | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"0010",		MKMF(MF_FRAME_PREDICTION | MF_MOTION_FORWARD)},
	{"0011",		MKMF(MF_FRAME_PREDICTION | MF_MOTION_FORWARD | MF_PATTERN)},
	{"00011",	MKMF(MF_FRAME_PREDICTION | MF_INTRA)},
	{"00010",	MKMF(MF_FRAME_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"000011",	MKMF(MF_FRAME_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"000010",  MKMF(MF_FRAME_PREDICTION | MF_QUANT | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"000001",	MKMF(MF_QUANT | MF_INTRA)},
	{NULL,		0}};

struct HuffInit IFieldMacroBlockTypeInit[] = {
	{"1",    MKMI(MF_FRAME_PREDICTION | MF_INTRA)},
   {"01",	MKMI(MF_FRAME_PREDICTION | MF_QUANT | MF_INTRA)},
   {NULL,	0}};

struct HuffInit PFieldMacroBlockTypeInit[] = {
	{"01",			MKMI(                   MF_FIELD_PREDICTION | MF_PATTERN)},
	{"100",			MKMI(                                         MF_PATTERN | MF_MOTION_FORWARD)},
	{"101",			MKMI(                   MF_FIELD_PREDICTION | MF_PATTERN | MF_MOTION_FORWARD)},
	{"110",			MKMI(                   MF_16X8_PREDICTION | MF_PATTERN | MF_MOTION_FORWARD)},
	{"111",			MKMI(                   MF_DUAL_PRIME_PREDICTION | MF_PATTERN | MF_MOTION_FORWARD)},

	{"00100",		MKMI(                                            MF_MOTION_FORWARD)},
	{"00101",		MKMI(                      MF_FIELD_PREDICTION | MF_MOTION_FORWARD)},
	{"00110",		MKMI(MF_16X8_PREDICTION |                       MF_MOTION_FORWARD)},
	{"00111",		MKMI(MF_DUAL_PRIME_PREDICTION | MF_MOTION_FORWARD)},

	{"00001",		MKMI(                   MF_FIELD_PREDICTION | MF_QUANT | MF_PATTERN)},
	{"00011",		MKMI(                   MF_FIELD_PREDICTION | MF_INTRA)},
	{"000001",		MKMI(                   MF_FIELD_PREDICTION | MF_QUANT | MF_INTRA)},
	{"0001000",		MKMI(                   MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"0001001",		MKMI(                   MF_FIELD_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"0001010",		MKMI(                   MF_16X8_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"0001011",		MKMI(                   MF_DUAL_PRIME_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},

	{NULL,		0}};

struct HuffInit BFieldMacroBlockTypeInit[] = {
	{"1000",			MKMI(MF_MOTION_FORWARD | MF_MOTION_BACKWARD)},
	{"01000",		MKMI(MF_MOTION_BACKWARD)},
	{"001000",		MKMI(MF_MOTION_FORWARD)},

	{"1001",			MKMI(MF_FIELD_PREDICTION | MF_MOTION_FORWARD | MF_MOTION_BACKWARD)},
	{"01001",		MKMI(MF_FIELD_PREDICTION | MF_MOTION_BACKWARD)},
	{"001001",		MKMI(MF_FIELD_PREDICTION | MF_MOTION_FORWARD)},

	{"1010",			MKMI(MF_16X8_PREDICTION | MF_MOTION_FORWARD | MF_MOTION_BACKWARD)},
	{"01010",		MKMI(MF_16X8_PREDICTION | MF_MOTION_BACKWARD)},
	{"001010",		MKMI(MF_16X8_PREDICTION | MF_MOTION_FORWARD)},

	{"1011",			MKMI(MF_FIELD_PREDICTION | MF_FRAME_PREDICTION | MF_MOTION_FORWARD | MF_MOTION_BACKWARD)},
	{"01011",		MKMI(MF_FIELD_PREDICTION | MF_FRAME_PREDICTION | MF_MOTION_BACKWARD)},
	{"001011",		MKMI(MF_FIELD_PREDICTION | MF_FRAME_PREDICTION | MF_MOTION_FORWARD)},

	{"1100",			MKMI(MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"01100",		MKMI(MF_MOTION_BACKWARD | MF_PATTERN)},
	{"001100",		MKMI(MF_MOTION_FORWARD | MF_PATTERN)},
	{"0001000",		MKMI(MF_QUANT | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"00001100",	MKMI(MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"00001000",	MKMI(MF_QUANT | MF_MOTION_BACKWARD | MF_PATTERN)},

	{"1101",			MKMI(MF_FIELD_PREDICTION | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"01101",		MKMI(MF_FIELD_PREDICTION | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"001101",		MKMI(MF_FIELD_PREDICTION | MF_MOTION_FORWARD | MF_PATTERN)},
	{"0001001",		MKMI(MF_FIELD_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"00001101",	MKMI(MF_FIELD_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"00001001",	MKMI(MF_FIELD_PREDICTION | MF_QUANT | MF_MOTION_BACKWARD | MF_PATTERN)},

	{"1110",			MKMI(MF_16X8_PREDICTION | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"01110",		MKMI(MF_16X8_PREDICTION | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"001110",		MKMI(MF_16X8_PREDICTION | MF_MOTION_FORWARD | MF_PATTERN)},
	{"0001010",		MKMI(MF_16X8_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"00001110",	MKMI(MF_16X8_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"00001010",	MKMI(MF_16X8_PREDICTION | MF_QUANT | MF_MOTION_BACKWARD | MF_PATTERN)},

	{"1111",			MKMI(MF_DUAL_PRIME_PREDICTION | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"01111",		MKMI(MF_DUAL_PRIME_PREDICTION | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"001111",		MKMI(MF_DUAL_PRIME_PREDICTION | MF_MOTION_FORWARD | MF_PATTERN)},
	{"0001011",		MKMI(MF_DUAL_PRIME_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_MOTION_BACKWARD | MF_PATTERN)},
	{"00001111",	MKMI(MF_DUAL_PRIME_PREDICTION | MF_QUANT | MF_MOTION_FORWARD | MF_PATTERN)},
	{"00001011",	MKMI(MF_DUAL_PRIME_PREDICTION | MF_QUANT | MF_MOTION_BACKWARD | MF_PATTERN)},

	{"00011",		MKMI(MF_FRAME_PREDICTION | MF_INTRA)},
	{"000001",		MKMI(MF_QUANT | MF_INTRA)},

	{NULL,		0}};


struct HuffInit CodedBlockPatternInit420[] = {
	{"111",				60},
	{"1101",				4},
	{"1100",				8},
	{"1011",				16},
	{"1010",				32},
	{"10011",			12},
	{"10010",			48},
	{"10001",			20},
	{"10000",			40},
	{"01111",			28},
	{"01110",			44},
	{"01101",			52},
	{"01100",			56},
	{"01011",			1},
	{"01010",			61},
	{"01001",			2},
	{"01000",			62},
	{"001111",			24},
	{"001110",			36},
	{"001101",			3},
	{"001100",			63},
	{"0010111",			5},
	{"0010110",			9},
	{"0010101",			17},
	{"0010100",			33},
	{"0010011",			6},
	{"0010010",			10},
	{"0010001",			18},
	{"0010000",			34},
	{"00011111",		7},
	{"00011110",		11},
	{"00011101",		19},

	{"00011100",		35},
	{"00011011",		13},
	{"00011010",		49},
	{"00011001",		21},
	{"00011000",		41},
	{"00010111",		14},
	{"00010110",		50},
	{"00010101",		22},
	{"00010100",		42},
	{"00010011",		15},
	{"00010010",		51},
	{"00010001",		23},
	{"00010000",		43},
	{"00001111",		25},
	{"00001110",		37},
	{"00001101",		26},
	{"00001100",		38},
	{"00001011",		29},
	{"00001010",		45},
	{"00001001",		53},
	{"00001000",		57},
	{"00000111",		30},
	{"00000110",		46},
	{"00000101",		54},
	{"00000100",		58},
	{"000000111",		31},
	{"000000110",		47},
	{"000000101",		55},
	{"000000100",		59},
	{"000000011",		27},
	{"000000010",		39},
	{"000000001",		0},
	{NULL, 0}};

struct HuffInit MotionCodesInit[] = {
	{"1",				0x01},
	{"01",			0x02},
	{"0011",			0x03},
	{"00101",		0x04},
	{"00100",		0x05},
	{"00011",		0x06},
	{"0001011",		0x07},
	{"0001010",		0x08},
	{"0001001",		0x09},
	{"00010001",	0x0a},
	{"00010000",	0x0b},
	{"00001111",	0x0c},
	{"00001110",	0x0d},
	{"00001101",	0x0e},
	{"00001100",	0x0f},
	{NULL, 0}};

struct HuffInit DMTVectorInit[] = {
	{"11",		-1},
	{"0",			0},
	{"10",		1},
	{NULL,		0}};

struct HuffInit DCTDCSizeLuminanceInit[] = {
	{"100",			0},
	{"00",			1},
	{"01",			2},
	{"101",			3},
	{"110",			4},
	{"1110",			5},
	{"11110",		6},
	{"111110",		7},
	{"1111110",		8},
	{"11111110",	9},
	{"111111110",	10},
	{"111111111",	11},
	{NULL,			0}};

struct HuffInit DCTDCSizeChrominanceInit[] = {
	{"00",			0},
	{"01",			1},
	{"10",			2},
	{"110",			3},
	{"1110",			4},
	{"11110",		5},
	{"111110",		6},
	{"1111110",		7},
	{"11111110",	8},
	{"111111110",	9},
	{"1111111110",	10},
	{"1111111111",	11},
	{NULL,			0}};


struct HuffInit DCTCoefficientZeroInit[] = {
	{"10",						-2},	// end of block
	{"000001",					-1},	// escape code

	{"11x",						RL(0,1)},
	{"011x",						RL(1,1)},
	{"0100x",					RL(0,2)},
	{"0101x",					RL(2,1)},
	{"00101x",					RL(0,3)},
	{"00111x",					RL(3,1)},
	{"00110x",					RL(4,1)},
	{"000110x",					RL(1,2)},
	{"000111x",					RL(5,1)},
	{"000101x",					RL(6,1)},
	{"000100x",					RL(7,1)},
	{"0000110x",				RL(0,4)},
	{"0000100x",				RL(2,2)},
	{"0000111x",				RL(8,1)},
	{"0000101x",				RL(9,1)},
	{"00100110x",				RL(0,5)},
	{"00100001x",				RL(0,6)},
	{"00100101x",				RL(1,3)},
	{"00100100x",				RL(3,2)},
	{"00100111x",				RL(10,1)},
	{"00100011x",				RL(11,1)},
	{"00100010x",				RL(12,1)},
	{"00100000x",				RL(13,1)},

	{"0000001010x",			RL(0,7)},
	{"0000001100x",			RL(1,4)},
	{"0000001011x",			RL(2,3)},
	{"0000001111x",			RL(4,2)},
	{"0000001001x",			RL(5,2)},
	{"0000001110x",			RL(14,1)},
	{"0000001101x",			RL(15,1)},
	{"0000001000x",			RL(16,1)},
	{"000000011101x",			RL(0,8)},
	{"000000011000x",			RL(0,9)},
	{"000000010011x",			RL(0,10)},
	{"000000010000x",			RL(0,11)},
	{"000000011011x",			RL(1,5)},
	{"000000010100x",			RL(2,4)},
	{"000000011100x",			RL(3,3)},
	{"000000010010x",			RL(4,3)},
	{"000000011110x",			RL(6,2)},
	{"000000010101x",			RL(7,2)},
	{"000000010001x",			RL(8,2)},
	{"000000011111x",			RL(17,1)},
	{"000000011010x",			RL(18,1)},
	{"000000011001x",			RL(19,1)},
	{"000000010111x",			RL(20,1)},
	{"000000010110x",			RL(21,1)},
	{"0000000011010x",		RL(0,12)},
	{"0000000011001x",		RL(0,13)},
	{"0000000011000x",		RL(0,14)},
	{"0000000010111x",		RL(0,15)},
	{"0000000010110x",		RL(1,6)},
	{"0000000010101x",		RL(1,7)},
	{"0000000010100x",		RL(2,5)},
	{"0000000010011x",		RL(3,4)},
	{"0000000010010x",		RL(5,3)},
	{"0000000010001x",		RL(9,2)},
	{"0000000010000x",		RL(10,2)},
	{"0000000011111x",		RL(22,1)},
	{"0000000011110x",		RL(23,1)},
	{"0000000011101x",		RL(24,1)},
	{"0000000011100x",		RL(25,1)},
	{"0000000011011x",		RL(26,1)},

	{"00000000011111x",		RL(0,16)},
	{"00000000011110x",		RL(0,17)},
	{"00000000011101x",		RL(0,18)},
	{"00000000011100x",		RL(0,19)},
	{"00000000011011x",		RL(0,20)},
	{"00000000011010x",		RL(0,21)},
	{"00000000011001x",		RL(0,22)},
	{"00000000011000x",		RL(0,23)},
	{"00000000010111x",		RL(0,24)},
	{"00000000010110x",		RL(0,25)},
	{"00000000010101x",		RL(0,26)},
	{"00000000010100x",		RL(0,27)},
	{"00000000010011x",		RL(0,28)},
	{"00000000010010x",		RL(0,29)},
	{"00000000010001x",		RL(0,30)},
	{"00000000010000x",		RL(0,31)},
	{"000000000011000x",		RL(0,32)},
	{"000000000010111x",		RL(0,33)},
	{"000000000010110x",		RL(0,34)},
	{"000000000010101x",		RL(0,35)},
	{"000000000010100x",		RL(0,36)},
	{"000000000010011x",		RL(0,37)},
	{"000000000010010x",		RL(0,38)},
	{"000000000010001x",		RL(0,39)},
	{"000000000010000x",		RL(0,40)},
	{"000000000011111x",		RL(1,8)},
	{"000000000011110x",		RL(1,9)},
	{"000000000011101x",		RL(1,10)},
	{"000000000011100x",		RL(1,11)},
	{"000000000011011x",		RL(1,12)},
	{"000000000011010x",		RL(1,13)},
	{"000000000011001x",		RL(1,14)},

	{"0000000000010011x",	RL(1,15)},
	{"0000000000010010x",	RL(1,16)},
	{"0000000000010001x",	RL(1,17)},
	{"0000000000010000x",	RL(1,18)},
	{"0000000000010100x",	RL(6,3)},
	{"0000000000011010x",	RL(11,2)},
	{"0000000000011001x",	RL(12,2)},
	{"0000000000011000x",	RL(13,2)},
	{"0000000000010111x",	RL(14,2)},
	{"0000000000010110x",	RL(15,2)},
	{"0000000000010101x",	RL(16,2)},
	{"0000000000011111x",	RL(27,1)},
	{"0000000000011110x",	RL(28,1)},
	{"0000000000011101x",	RL(29,1)},
	{"0000000000011100x",	RL(30,1)},
	{"0000000000011011x",	RL(31,1)},

	{NULL,					0}};


struct HuffInit DCTCoefficientZeroFirstInit[] = {
	{"000001",					-1},
	{"1x",						RLF(0,1)},
	{"011x",						RLF(1,1)},
	{"0100x",					RLF(0,2)},
	{"0101x",					RLF(2,1)},
	{"00101x",					RLF(0,3)},
	{"00111x",					RLF(3,1)},
	{"00110x",					RLF(4,1)},
	{"000110x",					RLF(1,2)},
	{"000111x",					RLF(5,1)},
	{"000101x",					RLF(6,1)},
	{"000100x",					RLF(7,1)},
	{"0000110x",				RLF(0,4)},
	{"0000100x",				RLF(2,2)},
	{"0000111x",				RLF(8,1)},
	{"0000101x",				RLF(9,1)},
	{"00100110x",				RLF(0,5)},
	{"00100001x",				RLF(0,6)},
	{"00100101x",				RLF(1,3)},
	{"00100100x",				RLF(3,2)},
	{"00100111x",				RLF(10,1)},
	{"00100011x",				RLF(11,1)},
	{"00100010x",				RLF(12,1)},
	{"00100000x",				RLF(13,1)},

	{"0000001010x",			RLF(0,7)},
	{"0000001100x",			RLF(1,4)},
	{"0000001011x",			RLF(2,3)},
	{"0000001111x",			RLF(4,2)},
	{"0000001001x",			RLF(5,2)},
	{"0000001110x",			RLF(14,1)},
	{"0000001101x",			RLF(15,1)},
	{"0000001000x",			RLF(16,1)},
	{"000000011101x",			RLF(0,8)},
	{"000000011000x",			RLF(0,9)},
	{"000000010011x",			RLF(0,10)},
	{"000000010000x",			RLF(0,11)},
	{"000000011011x",			RLF(1,5)},
	{"000000010100x",			RLF(2,4)},
	{"000000011100x",			RLF(3,3)},
	{"000000010010x",			RLF(4,3)},
	{"000000011110x",			RLF(6,2)},
	{"000000010101x",			RLF(7,2)},
	{"000000010001x",			RLF(8,2)},
	{"000000011111x",			RLF(17,1)},
	{"000000011010x",			RLF(18,1)},
	{"000000011001x",			RLF(19,1)},
	{"000000010111x",			RLF(20,1)},
	{"000000010110x",			RLF(21,1)},
	{"0000000011010x",		RLF(0,12)},
	{"0000000011001x",		RLF(0,13)},
	{"0000000011000x",		RLF(0,14)},
	{"0000000010111x",		RLF(0,15)},
	{"0000000010110x",		RLF(1,6)},
	{"0000000010101x",		RLF(1,7)},
	{"0000000010100x",		RLF(2,5)},
	{"0000000010011x",		RLF(3,4)},
	{"0000000010010x",		RLF(5,3)},
	{"0000000010001x",		RLF(9,2)},
	{"0000000010000x",		RLF(10,2)},
	{"0000000011111x",		RLF(22,1)},
	{"0000000011110x",		RLF(23,1)},
	{"0000000011101x",		RLF(24,1)},
	{"0000000011100x",		RLF(25,1)},
	{"0000000011011x",		RLF(26,1)},

	{"00000000011111x",		RLF(0,16)},
	{"00000000011110x",		RLF(0,17)},
	{"00000000011101x",		RLF(0,18)},
	{"00000000011100x",		RLF(0,19)},
	{"00000000011011x",		RLF(0,20)},
	{"00000000011010x",		RLF(0,21)},
	{"00000000011001x",		RLF(0,22)},
	{"00000000011000x",		RLF(0,23)},
	{"00000000010111x",		RLF(0,24)},
	{"00000000010110x",		RLF(0,25)},
	{"00000000010101x",		RLF(0,26)},
	{"00000000010100x",		RLF(0,27)},
	{"00000000010011x",		RLF(0,28)},
	{"00000000010010x",		RLF(0,29)},
	{"00000000010001x",		RLF(0,30)},
	{"00000000010000x",		RLF(0,31)},
	{"000000000011000x",		RLF(0,32)},
	{"000000000010111x",		RLF(0,33)},
	{"000000000010110x",		RLF(0,34)},
	{"000000000010101x",		RLF(0,35)},
	{"000000000010100x",		RLF(0,36)},
	{"000000000010011x",		RLF(0,37)},
	{"000000000010010x",		RLF(0,38)},
	{"000000000010001x",		RLF(0,39)},
	{"000000000010000x",		RLF(0,40)},
	{"000000000011111x",		RLF(1,8)},
	{"000000000011110x",		RLF(1,9)},
	{"000000000011101x",		RLF(1,10)},
	{"000000000011100x",		RLF(1,11)},
	{"000000000011011x",		RLF(1,12)},
	{"000000000011010x",		RLF(1,13)},
	{"000000000011001x",		RLF(1,14)},
	{"0000000000010011x",	RLF(1,15)},
	{"0000000000010010x",	RLF(1,16)},
	{"0000000000010001x",	RLF(1,17)},
	{"0000000000010000x",	RLF(1,18)},
	{"0000000000010100x",	RLF(6,3)},
	{"0000000000011010x",	RLF(11,2)},
	{"0000000000011001x",	RLF(12,2)},
	{"0000000000011000x",	RLF(13,2)},
	{"0000000000010111x",	RLF(14,2)},
	{"0000000000010110x",	RLF(15,2)},
	{"0000000000010101x",	RLF(16,2)},
	{"0000000000011111x",	RLF(27,1)},
	{"0000000000011110x",	RLF(28,1)},
	{"0000000000011101x",	RLF(29,1)},
	{"0000000000011100x",	RLF(30,1)},
	{"0000000000011011x",	RLF(31,1)},

	{NULL,					0}};


struct HuffInit DCTCoefficientOneInit[] = {
	{"0110",				   -2},
	{"000001",				-1},

	{"10x",						RL(0,1)},
	{"010x",						RL(1,1)},
	{"110x",						RL(0,2)},
	{"0111x",					RL(0,3)},
	{"00101x",					RL(2,1)},
	{"00111x",					RL(3,1)},
	{"00110x",					RL(1,2)},
	{"11100x",					RL(0,4)},
	{"11101x",					RL(0,5)},
	{"000101x",					RL(0,6)},
	{"000110x",					RL(4,1)},
	{"000111x",					RL(5,1)},
	{"000100x",					RL(0,7)},
	{"0000110x",				RL(6,1)},
	{"0000100x",				RL(7,1)},
	{"0000111x",				RL(2,2)},
	{"0000101x",				RL(8,1)},
	{"1111000x",				RL(9,1)},
	{"1111001x",				RL(1,3)},
	{"1111010x",				RL(10,1)},
	{"1111011x",				RL(0,8)},
	{"1111100x",				RL(0,9)},
	{"00100110x",				RL(3,2)},
	{"00100001x",				RL(11,1)},
	{"00100101x",				RL(12,1)},
	{"00100100x",				RL(13,1)},
	{"00100111x",				RL(1,4)},
	{"11111100x",				RL(2,3)},
	{"11111101x",				RL(4,2)},
	{"11111010x",				RL(0,12)},
	{"11111011x",				RL(0,13)},
	{"11111110x",				RL(0,14)},
	{"11111111x",				RL(0,15)},
	{"00100011x",				RL(0,10)},
	{"00100010x",				RL(0,11)},
	{"00100000x",				RL(1,5)},

	{"000000100x",				RL(5,2)},
	{"000000101x",				RL(14,1)},
	{"000000111x",				RL(15,1)},
	{"0000001101x",			RL(16,1)},
	{"0000001100x",			RL(2,4)},
	{"000000011100x",			RL(3,3)},
	{"000000010010x",			RL(4,3)},
	{"000000011110x",			RL(6,2)},
	{"000000010101x",			RL(7,2)},
	{"000000010001x",			RL(8,2)},
	{"000000011111x",			RL(17,1)},
	{"000000011010x",			RL(18,1)},
	{"000000011001x",			RL(19,1)},
	{"000000010111x",			RL(20,1)},
	{"000000010110x",			RL(21,1)},
	{"0000000010110x",		RL(1,6)},
	{"0000000010101x",		RL(1,7)},
	{"0000000010100x",		RL(2,5)},
	{"0000000010011x",		RL(3,4)},
	{"0000000010010x",		RL(5,3)},
	{"0000000010001x",		RL(9,2)},
	{"0000000010000x",		RL(10,2)},
	{"0000000011111x",		RL(22,1)},
	{"0000000011110x",		RL(23,1)},
	{"0000000011101x",		RL(24,1)},
	{"0000000011100x",		RL(25,1)},
	{"0000000011011x",		RL(26,1)},

	{"00000000011111x",		RL(0,16)},
	{"00000000011110x",		RL(0,17)},
	{"00000000011101x",		RL(0,18)},
	{"00000000011100x",		RL(0,19)},
	{"00000000011011x",		RL(0,20)},
	{"00000000011010x",		RL(0,21)},
	{"00000000011001x",		RL(0,22)},
	{"00000000011000x",		RL(0,23)},
	{"00000000010111x",		RL(0,24)},
	{"00000000010110x",		RL(0,25)},
	{"00000000010101x",		RL(0,26)},
	{"00000000010100x",		RL(0,27)},
	{"00000000010011x",		RL(0,28)},
	{"00000000010010x",		RL(0,29)},
	{"00000000010001x",		RL(0,30)},
	{"00000000010000x",		RL(0,31)},
	{"000000000011000x",		RL(0,32)},
	{"000000000010111x",		RL(0,33)},
	{"000000000010110x",		RL(0,34)},
	{"000000000010101x",		RL(0,35)},
	{"000000000010100x",		RL(0,36)},
	{"000000000010011x",		RL(0,37)},
	{"000000000010010x",		RL(0,38)},
	{"000000000010001x",		RL(0,39)},
	{"000000000010000x",		RL(0,40)},
	{"000000000011111x",		RL(1,8)},
	{"000000000011110x",		RL(1,9)},
	{"000000000011101x",		RL(1,10)},
	{"000000000011100x",		RL(1,11)},
	{"000000000011011x",		RL(1,12)},
	{"000000000011010x",		RL(1,13)},
	{"000000000011001x",		RL(1,14)},
	{"0000000000010011x",	RL(1,15)},
	{"0000000000010010x",	RL(1,16)},
	{"0000000000010001x",	RL(1,17)},
	{"0000000000010000x",	RL(1,18)},
	{"0000000000010100x",	RL(6,3)},
	{"0000000000011010x",	RL(11,2)},
	{"0000000000011001x",	RL(12,2)},
	{"0000000000011000x",	RL(13,2)},
	{"0000000000010111x",	RL(14,2)},
	{"0000000000010110x",	RL(15,2)},
	{"0000000000010101x",	RL(16,2)},
	{"0000000000011111x",	RL(27,1)},
	{"0000000000011110x",	RL(28,1)},
	{"0000000000011101x",	RL(29,1)},
	{"0000000000011100x",	RL(30,1)},
	{"0000000000011011x",	RL(31,1)},

	{NULL, 0}};

#pragma data_seg(".zeroseg0")

HuffmanTable	macroBlockAddressIncrement(MacroBlockAddressIncrementInit);
HuffmanTable	iFrameMacroBlockType(IFrameMacroBlockTypeInit);
HuffmanTable	bFrameMacroBlockType(BFrameMacroBlockTypeInit);
HuffmanTable	pFrameMacroBlockType(PFrameMacroBlockTypeInit);
HuffmanTable	iFieldMacroBlockType(IFieldMacroBlockTypeInit);
HuffmanTable	bFieldMacroBlockType(BFieldMacroBlockTypeInit);
HuffmanTable	pFieldMacroBlockType(PFieldMacroBlockTypeInit);
HuffmanTable	iFrameMacroBlockTypeFPFD(IFrameMacroBlockTypeInitFPFD);
HuffmanTable	bFrameMacroBlockTypeFPFD(BFrameMacroBlockTypeInitFPFD);
HuffmanTable	pFrameMacroBlockTypeFPFD(PFrameMacroBlockTypeInitFPFD);
HuffmanTable	codedBlockPattern420(CodedBlockPatternInit420);
HuffmanTable	motionCodes(MotionCodesInit);
HuffmanTable	dmtVector(DMTVectorInit);
HuffmanTable	dctDCSizeLuminance(DCTDCSizeLuminanceInit);
HuffmanTable	dctDCSizeChrominance(DCTDCSizeChrominanceInit);
HuffmanTable	dctCoefficientZero(DCTCoefficientZeroInit);
HuffmanTable	dctCoefficientZeroFirst(DCTCoefficientZeroFirstInit);
HuffmanTable	dctCoefficientOne(DCTCoefficientOneInit);

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\MPEGUserDataDecoder.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef MPEGUSERDATADECODER_H
#define MPEGUSERDATADECODER_H

#include "Huffdec.h"

class Line21Decoder
	{
	public:
		virtual void SendLine21Data(int displayTime, BYTE * data, int size) = 0;

		virtual bool NeedsPureData(void) {return false;}
	};

class MPEGUserDataDecoder
	{
	protected:
		Line21Decoder * line21Decoder;
		VideoBitStream * bitStream;
		bool					fieldID;
	public:
		MPEGUserDataDecoder(VideoBitStream * bitStream);

		void SetLine21Decoder(Line21Decoder * line21Decoder) {this->line21Decoder = line21Decoder;}

		bool ParseUserData(void);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\MPEGUserDataDecoder.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "MPEGUserDataDecoder.h"

MPEGUserDataDecoder::MPEGUserDataDecoder(VideoBitStream * bitStream)
	{
	this->bitStream = bitStream;
	line21Decoder = NULL;
	fieldID = false;
	}

bool MPEGUserDataDecoder::ParseUserData(void)
	{
	BYTE ibuffer[256];
	BYTE obuffer[256];

	int i, j, n;

	for(i=0; i<4; i++)
		{
		ibuffer[i] = (BYTE)(bitStream->GetBits(8));
		}

	while (i < 256 && bitStream->PeekBits(24) != 0x000001) ibuffer[i++] = (BYTE)(bitStream->GetBits(8));

	while (bitStream->PeekBits(24) != 0x000001) bitStream->Advance(8);

	if (ibuffer[4] == 0x43 && ibuffer[5] == 0x43)
		{
		if (line21Decoder)
			{
			if (line21Decoder->NeedsPureData())
				{
				n = i;
				i = 0;
				j = 9;
				while (j <n && (ibuffer[j] & 0xfe) == 0xfe)
					{
					if (ibuffer[j] & 0x01)
						{
						obuffer[i] = ibuffer[j+1];
						obuffer[i+1] = ibuffer[j+2];
						i += 2;
						}
					j += 3;
					}
				}
			else
				{
				n = i;
				for(i=0; i<n; i++)
					obuffer[i] = ibuffer[i];
				i = 9 + 3 * (ibuffer[8] & 63);
				}

			line21Decoder->SendLine21Data(bitStream->GetCurrentTimeStamp(), obuffer, i);
			}
		}
	else if (ibuffer[4] == 0x47 && ibuffer[5] == 0x41 && ibuffer[6] == 0x39 && ibuffer[7] == 0x34)
		{
		n = ibuffer[9] & 0x1f;
		if (n && line21Decoder && ibuffer[8] == 0x03 && (ibuffer[9] & 0x40) != 0)
			{
			if (line21Decoder->NeedsPureData())
				{
				i = 0;
				for(j=0; j<n; j++)
					{
					if ((ibuffer[3*j+11] & 0x06) == 0x04)
						{
						obuffer[i  ] = ibuffer[3*j+12];
						obuffer[i+1] = ibuffer[3*j+13];
						i+=2;
						}
					}
				}
			else
				{
				obuffer[0] = ibuffer[0];
				obuffer[1] = ibuffer[1];
				obuffer[2] = ibuffer[2];
				obuffer[3] = ibuffer[3];
				obuffer[4] = 0x43;
				obuffer[5] = 0x43;
				obuffer[6] = 0x01;
				obuffer[7] = 0xf8;
				obuffer[8] = fieldID ? 0x40 : 0xc0;
				i = 0;
				for(j=0; j<n;j++)
					{
					if ((ibuffer[3*j+11] & 0x06) == 0x04)
						{
						if (fieldID != ((ibuffer[3*j+11] & 0x01) != 0))
							{
							obuffer[ 9+3*i] = 0xfe;
							obuffer[10+3*i] = 0x00;
							obuffer[11+3*i] = 0x00;
							i++;
							}

						obuffer[ 9+3*i] = 0xff;
						obuffer[10+3*i] = ibuffer[3*j+12];
						obuffer[11+3*i] = ibuffer[3*j+13];
						i++;

						fieldID = ((ibuffer[3*j+11] & 0x01) == 0);
						}
					}
				obuffer[8] |= i;
				i = i * 3 + 9;
				}

			line21Decoder->SendLine21Data(bitStream->GetCurrentTimeStamp(), obuffer, i);
			}
		}

	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\MPEGStatistics.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include "MPEGStatistics.h"

int statCoefficients;
int statBlocks;
int statBlocksIntra;
int statBlocksPattern;
int statBlocksSkipped;
int statPredicts[2][2][2];

int maxStatCoefficients;
int sumStatCoefficients;
int maxStatBlocks;
int sumStatBlocks;
int maxStatBlocksIntra;
int sumStatBlocksIntra;
int maxStatBlocksPattern;
int sumStatBlocksPattern;
int maxStatBlocksSkipped;
int sumStatBlocksSkipped;
int maxStatPredicts[2][2][2];
int sumStatPredicts[2][2][2];
int maxStatPredFetch;
int sumStatPredFetch;
int numStatFrames;
int numStatSkipped;

void StatFrameSkipped(void)
	{
	numStatSkipped++;
	}

void GetStatistics(char * str)
	{
	sprintf(str, "Skipped : %d of %d", numStatSkipped, numStatFrames + numStatSkipped);
	}


void StatFrameCompleted(void)
	{
	int i, j, k;
	int statPredFetch;

	sumStatCoefficients += statCoefficients;
	if (statCoefficients > maxStatCoefficients) maxStatCoefficients = statCoefficients;
	statCoefficients = 0;

	sumStatBlocks += statBlocks;
	if (statBlocks > maxStatBlocks) maxStatBlocks = statBlocks;
	statBlocks = 0;
	sumStatBlocksIntra += statBlocksIntra;
	if (statBlocksIntra > maxStatBlocksIntra) maxStatBlocksIntra = statBlocksIntra;
	statBlocksIntra = 0;
	sumStatBlocksPattern += statBlocksPattern;
	if (statBlocksPattern > maxStatBlocksPattern) maxStatBlocksPattern = statBlocksPattern;
	statBlocksPattern = 0;
	sumStatBlocksSkipped += statBlocksSkipped;
	if (statBlocksSkipped > maxStatBlocksSkipped) maxStatBlocksSkipped = statBlocksSkipped;
	statBlocksSkipped = 0;

	statPredFetch = 0;

	for(i=0; i<2; i++)
		{
		for(j=0; j<2; j++)
			{
			for(k=0; k<2; k++)
				{
				statPredFetch += statPredicts[i][j][k] * (16 + j) * (i ? (16 + k) : (8 + k));

				sumStatPredicts[i][j][k] += statPredicts[i][j][k];
				if (statPredicts[i][j][k] > maxStatPredicts[i][j][k]) maxStatPredicts[i][j][k] = statPredicts[i][j][k];
				statPredicts[i][j][k] = 0;
				}
			}
		}
	sumStatPredFetch += statPredFetch;
	if (statPredFetch > maxStatPredFetch) maxStatPredFetch = statPredFetch;

	numStatFrames++;
	}

void StatDisplay(FILE * f)
	{
	int i, j, k;

	if (numStatFrames)
		{
		fprintf(f, "Frames : %d\n", numStatFrames);
		fprintf(f, "Coefficients : %7d : %11.3f\n", maxStatCoefficients,  (double)sumStatCoefficients / numStatFrames);
		fprintf(f, "Blocks       : %7d : %11.3f\n", maxStatBlocks,        (double)sumStatBlocks / numStatFrames);
		fprintf(f, "Macroblocks  :\n");
		fprintf(f, "  Intra      : %7d : %11.3f\n", maxStatBlocksIntra,   (double)sumStatBlocksIntra / numStatFrames);
		fprintf(f, "  Pattern    : %7d : %11.3f\n", maxStatBlocksPattern, (double)sumStatBlocksPattern / numStatFrames);
		fprintf(f, "  Skipped    : %7d : %11.3f\n", maxStatBlocksSkipped, (double)sumStatBlocksSkipped / numStatFrames);

		for(i=0; i<2; i++)
			{
			for(j=0; j<2; j++)
				{
				for(k=0; k<2; k++)
					{
					fprintf(f, "Pred %d%d%d     : %7d : %11.3f\n", i,j,k, maxStatPredicts[i][j][k], (double)sumStatPredicts[i][j][k] / numStatFrames);
					}
				}
			}
		fprintf(f, "Pred Fetch   : %7d : %11.3f\n", maxStatPredFetch * 3 / 2, (double)sumStatPredFetch * 1.5 / numStatFrames);
		}
	}

void StatReset(void)
	{
	int i, j, k;

	numStatFrames = 0;
	numStatSkipped = 0;
	maxStatCoefficients = 0;
	sumStatCoefficients = 0;
	statCoefficients = 0;

	maxStatBlocks = 0;
	sumStatBlocks = 0;
	statBlocks = 0;
	maxStatBlocksIntra = 0;
	sumStatBlocksIntra = 0;
	statBlocksIntra = 0;
	maxStatBlocksPattern = 0;
	sumStatBlocksPattern = 0;
	statBlocksPattern = 0;
	maxStatBlocksSkipped = 0;
	sumStatBlocksSkipped = 0;
	statBlocksSkipped = 0;

	for(i=0; i<2; i++)
		{
		for(j=0; j<2; j++)
			{
			for(k=0; k<2; k++)
				{
				maxStatPredicts[i][j][k] = 0;
				sumStatPredicts[i][j][k] = 0;
				statPredicts[i][j][k] = 0;
				}
			}
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\MPEGVideoStreamDecoder.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "MPEGVideoStreamDecoder.h"

#pragma warning(disable : 4355)
MPEGVideoStreamDecoder::MPEGVideoStreamDecoder(GenericPictureDisplay * display,
															  GenericSliceParser * highQualitySliceParser,
			                                      GenericSliceParser * lowQualitySliceParser,
															  GenericProfile * globalProfile,
															  GenericProfile * profile,
															  StreamFlipCopy * streamFlipCopy)
												 : VideoStreamParser(this, this), VideoBitStream(streamFlipCopy),
												   PictureParser(highQualitySliceParser, lowQualitySliceParser, display, this, globalProfile, profile),
													bufferRefillEvent(FALSE, TRUE),
													TimedFiber(10)
	{
	this->display = display;

	highQualitySliceParser->SetBitStream(this);
	lowQualitySliceParser->SetBitStream(this);

//	InitializeCriticalSection(&lock);

	streaming = FALSE;
	}
#pragma warning(default : 4355)

MPEGVideoStreamDecoder::~MPEGVideoStreamDecoder(void)
	{
	if (streaming) EndStreaming(TRUE);

//	DeleteCriticalSection(&lock);
	}

void MPEGVideoStreamDecoder::FiberRoutine(void)
	{
	while (RefillBuffer())
		{
		VideoStreamParser::Parse();
		if (playbackMode == VDPM_SCANNING)
			{
			if (!terminate)
				{
				completing = FALSE;
				FlushBuffer();
				}

			ScanCompleted();
			}
		else
			{
			PictureParser::DoneStreaming();
			if (endCodeReceived)
				{
				endCodeReceived--;
				endCodeCompleted++;
				}
			}
		}

	streamingCompleted = TRUE;
	StreamCompleted();
	}

void MPEGVideoStreamDecoder::PictureDecodingCompleted(void)
	{
	switch (playbackMode)
		{
		case VDPM_SCANNING:
			while (!terminate && !completing)
				{
				RefillRequest();

				bufferRefillEvent.Wait(100);
				}

			if (!terminate)
				{
				completing = FALSE;
				FlushBuffer();
				}

			ScanCompleted();
			break;
		case VDPM_TRICKPLAY:
			break;
		default:
			YieldTimedFiber(0);
		}
	}

bool MPEGVideoStreamDecoder::EnoughDataToStart(void)
	{
	return endCodeReceived > 0 || endCodeCompleted > 0;
	}

void MPEGVideoStreamDecoder::BeginStreaming(VideoPlaybackMode playbackMode, bool highQuality)
	{
	this->playbackMode = playbackMode;

	terminate = FALSE;
	completing = FALSE;
	streamingCompleted = FALSE;

	endCodeReceived = 0;
	endCodeCompleted = 0;

	VideoStreamParser::BeginStreaming(playbackMode);
	PictureParser::BeginStreaming(playbackMode, highQuality);

	streaming = TRUE;

	StartFiber();
	}

void MPEGVideoStreamDecoder::StartStreaming(int playbackSpeed)
	{
	PictureParser::StartStreaming(playbackSpeed);
	}

void MPEGVideoStreamDecoder::StopStreaming(void)
	{
	PictureParser::StopStreaming();
	}

void MPEGVideoStreamDecoder::EndStreaming(bool fullReset)
	{
	if (streaming)
		{
		terminate = TRUE;
		bufferRefillEvent.SetEvent();
		display->EndStreaming(fullReset);
		VideoStreamParser::EndStreaming(fullReset);
		CompleteFiber();
		PictureParser::EndStreaming(fullReset);
		FlushBuffer();
		streaming = FALSE;
		}
	}

void MPEGVideoStreamDecoder::AdvanceFrame(void)
	{
	PictureParser::AdvanceFrame();
	}

bool MPEGVideoStreamDecoder::StreamingCompleted(void)
	{
	return streamingCompleted;
	}

DWORD MPEGVideoStreamDecoder::VideoSegmentRequested(void)
	{
	return VideoStreamParser::VideoSegmentRequested();
	}

void MPEGVideoStreamDecoder::SetFirstVideoSegment(DWORD seg)
	{
	VideoStreamParser::SetFirstVideoSegment(seg);
	}

void MPEGVideoStreamDecoder::SetLastVideoSegment(DWORD seg)
	{
	VideoStreamParser::SetLastVideoSegment(seg);
	}


void MPEGVideoStreamDecoder::AdvanceTrickFrame(int by)
	{
	VideoStreamParser::AdvanceTrickFrame(by);
	}

DWORD MPEGVideoStreamDecoder::SendData(BYTE * ptr, DWORD num)
	{
	DWORD done;
	static BYTE stuff[] = {0x00, 0x00, 0x00, 0x00};

//	EnterCriticalSection(&lock);

	done = AddData(ptr, num);

	if (AvailBits() > requestedBits) bufferRefillEvent.SetEvent();
	if (done == num && num > 4 && *(DWORD*)(ptr + num - 4) == 0xb7010000)
		{
		endCodeReceived++;
		AddData(stuff, 4);
		bufferRefillEvent.SetEvent();
		}

//	LeaveCriticalSection(&lock);

	return done;
	}

void MPEGVideoStreamDecoder::TrickSegmentRequested(void)
	{
	completing = FALSE;
	}

void MPEGVideoStreamDecoder::WaitForSegmentCompleted(void)
	{
	while (!terminate && !completing)
		{
		RefillRequest();
		bufferRefillEvent.Wait(100);
		}
	}

bool MPEGVideoStreamDecoder::IsSegmentCompleted(void)
	{
	return completing;
	}

void MPEGVideoStreamDecoder::CompleteData(void)
	{
//	EnterCriticalSection(&lock);

	if (!completing)
		{
		StuffBuffer();
		completing = TRUE;
		bufferRefillEvent.SetEvent();
		}
	endCodeReceived = 0;

//	LeaveCriticalSection(&lock);
	}

bool MPEGVideoStreamDecoder::InternalIsBufferComplete(void)
	{
	return completing;
	}

bool MPEGVideoStreamDecoder::InternalRefillBuffer(int requestBits, bool lowDataPanic)
	{
//	EnterCriticalSection(&lock);

//	if (AvailBits() == 0) endCodeReceived = FALSE;

	requestedBits = requestBits;

	while (!terminate && !completing && !endCodeReceived && requestBits > AvailBits())
		{
		RefillRequest();

//		LeaveCriticalSection(&lock);
		bufferRefillEvent.Wait(100);
//		EnterCriticalSection(&lock);
		}

	if (!terminate && !completing && AvailBits() < 8 * VIDEO_STREAM_BUFFER_SIZE) RefillRequest();

//	LeaveCriticalSection(&lock);

	return !terminate && ((endCodeReceived || completing) && AvailBits() > 0 || AvailBits() >= requestBits);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\PictureParser.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef PICTUREPARSER_H
#define PICTUREPARSER_H

#include "VideoStreamParser.h"
#include "..\video\FrameStore.h"
#include "..\video\VideoDisplay.h"
#include "library\common\profiles.h"
#include "..\spudecoder\SPUDisplayBuffer.h"

enum BobWeaveLevel
	{
	BWL_FORCE_BOB,
	BWL_FORCE_WEAVE,
	BWL_PREFERE_BOB,
	BWL_PREFERE_WEAVE,
	BWL_SMART_DECISION
	};

#define PF_TOP_FIELD_FIRST(x)					((x & 0x20) != 0)
#define PF_FRAME_PRED_FRAME_DCT(x)			((x & 0x10) != 0)
#define PF_CONCEALMENT_MOTION_VECTORS(x)	((x & 0x08) != 0)
#define PF_Q_SCALE_TYPE(x)						((x & 0x04) != 0)
#define PF_INTRA_VLC_FORMAT(x)				((x & 0x02) != 0)
#define PF_ALTERNATE_SCAN(x)					((x & 0x01) != 0)

class GenericSliceParser : public SPUDisplayBufferFactory
	{
	public:
		virtual ~GenericSliceParser(void) {}

		virtual void SetVideoCodingStandard(VideoCodingStandard vcd) = 0;
		virtual void SetFCodes(BYTE fc00, BYTE fc01, BYTE fc10, BYTE fc11) = 0;
		virtual void SetPictureParameters(BYTE intraDCPrecision,
			                               PictureStructure pictureStructure,
												  	 BYTE pictureFlags) = 0;
		virtual void SetCodingType(PictureCodingType pictureCodingType) = 0;
		virtual void SetForwardVector(bool fullPel, BYTE fcode) = 0;
		virtual void SetBackwardVector(bool fullPel, BYTE fcode) = 0;
		virtual void SetImageSize(int width, int height) = 0;
		virtual void SetQuantMatrix(QuantMatrices type, const QuantizationMatrix & matrix) = 0;

		virtual bool BeginFrameDecoding(FrameStore * pred, FrameStore * succ, FrameStore * curr, PictureDisplayBuffer * display, bool hurryUp) = 0;
		virtual void DoneFirstFieldDecoding(void) = 0;
		virtual void BeginSecondFieldDecoding(void) = 0;
		virtual void DoneFrameDecoding(void) = 0;

		virtual bool SuspendFrameDecoding(void) {return FALSE;}
		virtual void ResumeFrameDecoding(void) {}

		virtual void Parse(void) = 0;

		virtual void SetBitStream(VideoBitStream * bitStream) = 0;

		virtual FrameStore * AllocFrameStore(PictureCodingType type, bool stripeOptimized) = 0;

		virtual int MinimumStretch(void) {return 1;}

		virtual void SetBrightness(int Brightness, int uBrightness, int vBrightness) = 0;
		virtual void SetContrast(int contrast) = 0;
		virtual void SetSaturation(int saturation) = 0;
		virtual DWORD QueryColorControl(void) = 0;

		virtual void BeginFrameSequence(void) {}
		virtual void EndFrameSequence(void) {}

		virtual void BeginFrameReference(FrameStore * frame) {}
		virtual void EndFrameReference(FrameStore * frame) {}
		virtual void InvalidateFrameReferences(void) {}
	};

class PictureParser : public GenericPictureParser, protected TimingClient
	{
	protected:
		GenericSliceParser		*	sliceParser;
		GenericPictureDisplay	*	display;
		VideoBitStream				*	bitStream;
		GenericProfile				*	globalProfile;
		GenericProfile				*	profile;

		GenericSliceParser		*	lowQualitySliceParser;
		GenericSliceParser		*	highQualitySliceParser;

		FrameStore					*	ipFrameBuffers[3];
		FrameStore					*	bFrameBuffers[2];
		FrameStore					*	previousFrame;
		int								previousBFrameID;
		BYTE								pictureFlags;
		BYTE								lastIPPictureFlags;
		bool								repeatFirstField;
		bool								progressiveFrame;
		bool								progressiveSequenceStructure;
		int								frameRepeat, ipFrameRepeat, thisFrameRepeat;

		TimedFiberEvent				event;
		TimedFiberMutex				doneStreamingLock;

	private:
		int								pad00;
	protected:
		PictureCodingType				codingType;
		PictureStructure				pictureStructure;
		VideoCodingStandard			vcs;
		PictureStructure				lastIPFieldDisplayMode;
		Inverse32PulldownHint		phint;
		PictureDisplayAspectRatio	aspectRatio;
		int								panScanOffset;

		int								frameContinuationCounter;

		DWORD								frameDropIncrement, frameDropCounter;

		bool								isIPFrame;
		bool								initialized;
		VideoPlaybackMode				playbackMode;
		bool								isStreamPlayback;
		bool								progressiveSequence, pullDownSequence, mixedPullDownSequence;
		bool								initialBFrameSkip;
		BobWeaveLevel					bobWeaveLevel;
		bool								pullDownReconstruction;
		bool								lastIPRepeatFirstField;
		bool								lastIPProgressiveFrame;
		bool								highQuality;
		bool								alwaysHurryUp;

		DWORD								progressiveHistory, repeatFirstHistory, progressiveDisplayHistory;
		int								pastIPFrame, futureIPFrame;
		int								fieldCount, lowFieldCount;
		int								framesPerSecond, fieldTime;
		int								timeOffset, previousTimeStamp;
		int								lastIPTimeStamp;
		int								playbackSpeed;
		int								width, height;
		DWORD								currentDeinterlaceMode;

		PictureDisplayBuffer		*	ipDisplayBuffer;
		PictureDisplayBuffer		*	bDisplayBuffer;
		PictureDisplayBuffer		*	previousDisplayBuffer;
		bool								previousWasIPFrame;
		int								previousDisplayTime;

		void ParsePictureHeader(void);
		void ParsePictureCodingExtension(void);
		void ParseQuantMatrixExtension(void);
		void ParsePictureDisplayExtension(void);
		void ParseExtensionAndUserData(void);

		bool WaitForPictureDataComplete(void);
		bool ParsePictureBody(void);
		bool SkipPictureBody(void);
		void ParsePicture(void);

		void PreParsePicture(PictureCodingType & codingType);
		void ParseTempPicture(void);

		void PostIPFrameBuffer(int displayTime, bool hurryUp);
		void PostBFrameBuffer(int displayTime, Inverse32PulldownHint bphint, bool hurryUp);
		void PostPreviousFrame(void);

		void ReleaseFrameBuffers(void);
		void AllocateFrameBuffers(void);

		virtual void PictureDecodingCompleted(void) {}
	public:
		void SetImageSize(int width, int height, int aspectRatio);
		void SetQuantMatrix(QuantMatrices type, const QuantizationMatrix & matrix);
		void SetFrameRate(int framesPerSecond);
		void SetClosedGOP(void);
		void SetBrokenLink(void);
		void SetVideoCodingStandard(VideoCodingStandard vcs);
		void SetProgressiveSequence(bool progressiveSequence);

		void Parse(PictureDecodeMode mode);
		void PreParse(PictureCodingType & codingType);

		void BeginStreaming(VideoPlaybackMode playbackMode, bool highQuality);
		void EndStreaming(bool fullReset);

		void StartStreaming(int playbackSpeed);
		void StopStreaming(void);

		void DoneStreaming(void);

		void AdvanceFrame(void);

		PictureParser(GenericSliceParser * highQualitySliceParser,
			           GenericSliceParser * lowQualitySliceParser,
						  GenericPictureDisplay * display,
						  VideoBitStream * bitStream,
						  GenericProfile * globalProfile,
						  GenericProfile * profile);
		~PictureParser(void);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\PictureParser.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#include "PictureParser.h"
#include "Mp2HuffTables.h"
#include "library\common\vddebug.h"
#include "..\common\TimedFibers.h"
#include "..\common\PerformanceMonitor.h"

///////////////////////////////////////////////////////////////////////////////
//
//  Statistics
//
///////////////////////////////////////////////////////////////////////////////

#define FRAME_STATISTICS	0
#define FRAME_ANNOTATION	0
#define NO_DROPPED_FRAMES	0
#define ONLY_I_FRAMES		0
#define ONLY_IP_FRAMES		0

#if FRAME_ANNOTATION
static int decodeFrameCount;
static int displayFrameCount;
#endif

#if FRAME_STATISTICS
#include <stdio.h>

struct StatusRecord
	{
	int	displayTime, enterTime, postTime, getTime, offsetTime, decodeTime;
	char	frameType;
	bool	skipped;
	int	ptsTime;
	bool	repeatFirstField, progressiveFrame;
	int	counter;
	};

static int StatusFramesDecoded[3];
static int StatusFrameDuration[3];

static StatusRecord	sr[10244];
static int				nsr;
static int				ntsr;

inline void AddStatus(int displayTime, int enterTime, int postTime, int getTime, int offsetTime, char frameType, bool skipped, int ptsTime, bool repeatFirstField, bool progressiveFrame, int decodeTime, int counter)
	{
	if (nsr < 10240)
		{
		sr[nsr].displayTime = displayTime;
		sr[nsr].enterTime = enterTime;
		sr[nsr].getTime = getTime;
		sr[nsr].postTime = postTime;
		sr[nsr].offsetTime = offsetTime;
		sr[nsr].frameType = frameType;
		sr[nsr].skipped = skipped;
		sr[nsr].ptsTime = ptsTime;
		sr[nsr].repeatFirstField = repeatFirstField;
		sr[nsr].progressiveFrame = progressiveFrame;
		sr[nsr].decodeTime = decodeTime;
		sr[nsr].counter = counter;

		nsr++;
		}
	}

void DumpStatusList(FILE * f)
	{
	int i, total, skipped;

	total = 0;
	skipped = 0;

	for(i=0; i<nsr; i++)
		{
		fprintf(f, "%4d(%4d) : %c(%c%c)%c D: %6d (%6d)- T %3d E: %6d P: %6d S: %6d G: %6d (%d) %s\n",
			i, sr[i].counter, sr[i].frameType,
			sr[i].repeatFirstField ? 'R' : '-',
			sr[i].progressiveFrame ? 'P' : '-',
			sr[i].progressiveFrame != sr[i].frameType < 'a' ? '*' : ' ',
			sr[i].displayTime, sr[i+1].displayTime - sr[i].displayTime,
			sr[i].decodeTime,
			sr[i].enterTime,
			sr[i].postTime,
			sr[i].ptsTime,
			sr[i].getTime,
			sr[i].offsetTime,
			sr[i].skipped ? "skipped" : "done"
			);
		if (sr[i].skipped) skipped++;
		total++;
		}
	if (total) fprintf(f, "Total : %6d Skipped : %6d (%3d%%)\n", total, skipped, skipped * 100 / total);
	}

void Partition(int first, int last)
	{
	int pivot, i;
	StatusRecord	swap;

	if (last > first)
		{
		swap = sr[first];
		pivot = first;
		for(i=first+1; i<=last; i++)
			{
			if (sr[i].decodeTime > swap.decodeTime)
				{
				sr[pivot] = sr[i];
				sr[i] = sr[pivot+1];
				pivot++;
				}
			}
		sr[pivot] = swap;
		Partition(first, pivot-1);
		Partition(pivot+1, last);
		}
	}

void SortStatus(void)
	{
	Partition(0, nsr-1);
	}

void DumpStatus(void)
	{
	char fname[100];
	FILE * f;

	wsprintf(fname, "c:\\mpstat\\sdump.%d.txt", ntsr);

	if (nsr)
		{
		f = fopen(fname, "w");
		if (f)
			{
			DumpStatusList(f);
			printf("\n------------------------------------------------------------------------------------\n\n");
			SortStatus();
			DumpStatusList(f);
			fclose(f);
			ntsr++;
			nsr = 0;
			}
		}
	}

#endif

///////////////////////////////////////////////////////////////////////////////
//
//  Picture Parser
//
///////////////////////////////////////////////////////////////////////////////

//
//  Parse Picture Header
//

void PictureParser::ParsePictureHeader(void)
	{
	bool fullPel;
	BYTE fcode;

	if (bitStream->GetBits(32) != PICTURE_START_CODE) throw PictureHeaderSyntaxError();

	frameContinuationCounter = bitStream->GetBits(10);

	codingType = (PictureCodingType)(bitStream->GetBits(3));

	sliceParser->SetCodingType(codingType);

	isIPFrame = codingType != BIDIRECTIONAL_PREDICTIVE_CODED;

	bitStream->GetBits(16); // vbv delay

	if (codingType == PREDICTIVE_CODED || codingType == BIDIRECTIONAL_PREDICTIVE_CODED)
		{
		fullPel = bitStream->GetBool();
		fcode = (BYTE)bitStream->GetBits(3);
		sliceParser->SetForwardVector(fullPel, fcode);
		}

	if (codingType == BIDIRECTIONAL_PREDICTIVE_CODED)
		{
		fullPel = bitStream->GetBool();
		fcode = (BYTE)bitStream->GetBits(3);
		sliceParser->SetBackwardVector(fullPel, fcode);
		}

	while (bitStream->GetBits(1))
		bitStream->GetBits(8);

	bitStream->NextStartCode();

	frameRepeat = 1;
	}

//
//  Parse Picture Coding Extension
//

void PictureParser::ParsePictureCodingExtension(void)
	{
	BYTE fcodes[2][2];
	BYTE intraDCPrecision;

	if (bitStream->GetBits(32) != EXTENSION_START_CODE) throw PictureHeaderSyntaxError();
	if (bitStream->GetBits(4) != PICTURE_CODING_EXTENSION_ID) throw PictureHeaderSyntaxError();

	fcodes[0][0] = (BYTE)bitStream->GetBits(4);
	fcodes[0][1] = (BYTE)bitStream->GetBits(4);
	fcodes[1][0] = (BYTE)bitStream->GetBits(4);
	fcodes[1][1] = (BYTE)bitStream->GetBits(4);

	intraDCPrecision = (BYTE)bitStream->GetBits(2);
	pictureStructure = (PictureStructure)(bitStream->GetBits(2));

	pictureFlags = (BYTE)bitStream->GetBits(6);

	sliceParser->SetFCodes(fcodes[0][0], fcodes[0][1], fcodes[1][0], fcodes[1][1]);
	sliceParser->SetPictureParameters(intraDCPrecision, pictureStructure, pictureFlags);

	repeatFirstField = bitStream->GetBool();

	bitStream->GetBits(1);

	progressiveFrame = bitStream->GetBool();

	bitStream->GetBits(1);

	if (progressiveSequenceStructure)
		{
		if (repeatFirstField)
			{
			if (PF_TOP_FIELD_FIRST(pictureFlags))
				frameRepeat = 3;
			else
				frameRepeat = 2;

			repeatFirstField = false;
			}
		}

	bitStream->NextStartCode();
	}

//
//  Parse Quantizer Matrix Extension
//

void PictureParser::ParseQuantMatrixExtension(void)
	{
	QuantizationMatrix	mat;
	int i;

	if (bitStream->GetBits(4) != QUANT_MATRIX_EXTENSION_ID) throw PictureHeaderSyntaxError();

	if (bitStream->GetBits(1))
		{
		for (i=0; i<64; i++) mat[i] = bitStream->GetBits(8);
		sliceParser->SetQuantMatrix(LUMA_INTRA_QUANTMATRIX, mat);
		}
	if (bitStream->GetBits(1))
		{
		for (i=0; i<64; i++) mat[i] = bitStream->GetBits(8);
		sliceParser->SetQuantMatrix(LUMA_NONINTRA_QUANTMATRIX, mat);
		}
	if (bitStream->GetBits(1))
		{
		for (i=0; i<64; i++) mat[i] = bitStream->GetBits(8);
		sliceParser->SetQuantMatrix(CHROMA_INTRA_QUANTMATRIX, mat);
		}
	if (bitStream->GetBits(1))
		{
		for (i=0; i<64; i++) mat[i] = bitStream->GetBits(8);
		sliceParser->SetQuantMatrix(CHROMA_NONINTRA_QUANTMATRIX, mat);
		}

	bitStream->NextStartCode();
	}

//
//  Parse Picture Display Extension
//

void PictureParser::ParsePictureDisplayExtension(void)
	{
	int offset;

	if (bitStream->GetBits(4) != PICTURE_DISPLAY_EXTENSION_ID) throw PictureHeaderSyntaxError();

	offset = bitStream->GetBits(16);
	panScanOffset = (width << 13) - ((offset << 16) >> 4);

	bitStream->NextStartCode();
	}

//
//  Parse Extension And User Data
//

void PictureParser::ParseExtensionAndUserData(void)
	{
	for(;;)
		{
		if (bitStream->PeekBits(32) == EXTENSION_START_CODE)
			{
			bitStream->Advance(32);
			switch(bitStream->PeekBits(4))
				{
				case QUANT_MATRIX_EXTENSION_ID:
					ParseQuantMatrixExtension();
					break;
				case PICTURE_DISPLAY_EXTENSION_ID:
					ParsePictureDisplayExtension();
					break;
				default:
					throw PictureHeaderSyntaxError();
				}
			}
		else if (bitStream->PeekBits(32) == USER_DATA_START_CODE)
			{
			if (userDataDecoder)
				userDataDecoder->ParseUserData();
			else
				{
				bitStream->Advance(32);
				while (bitStream->PeekBits(24) != 0x000001) bitStream->Advance(8);
				}
			}
		else
			break;
		}

	bitStream->NextStartCode();
	}

bool PictureParser::WaitForPictureDataComplete(void)
	{
	__int64	startPos;

	switch (playbackMode)
		{
		case VDPM_PLAY_FORWARD:
			if (bitStream->HasBufferEnoughData(400 * 1024 * 8))
				{
				return bitStream->RefillBuffer(400 * 1024 * 8);
				}
			else
				{
				bitStream->MarkResetPosition();
				startPos = bitStream->CurrentLocation();
				do {
					bitStream->Advance(32);
					bitStream->NextStartCode();
					if (!bitStream->RefillBuffer(32))
						{
						bitStream->SetCurrentLocation(startPos);
						bitStream->RemoveResetPosition();
						return false;
						}
					} while (IS_SLICE_HEADER(bitStream->PeekBits(32)));

				if (pictureStructure != PS_FRAME_PICTURE)
					{
					do {
						bitStream->Advance(32);
						bitStream->NextStartCode();
						if (!bitStream->RefillBuffer(32))
							{
							bitStream->SetCurrentLocation(startPos);
							bitStream->RemoveResetPosition();
							return false;
							}
						} while (IS_SLICE_HEADER(bitStream->PeekBits(32)));
					}

				bitStream->SetCurrentLocation(startPos);
				bitStream->RemoveResetPosition();

				return true;
				}
			break;
		case VDPM_PLAY_BACKWARD:
		case VDPM_TRICKPLAY:
			return bitStream->RefillBuffer(64 * 1024 * 8);
			break;
		case VDPM_SCANNING:
			return bitStream->RefillBuffer(400 * 1024 * 8);
			break;
		}

	return false;
	}

//
//  Parse Picture Body
//

static int pictureCnt;

bool PictureParser::ParsePictureBody(void)
	{
	int sliceLevelScheduling;

	sliceLevelScheduling = 4;
	do {
		if (IsHigherPriorityTimedFiberReady(bitStream->AvailBits() < 8 * 500000 ? -1 : 6))
			{
			if (sliceParser->SuspendFrameDecoding())
				{
				YieldTimedFiber(0);

				sliceParser->ResumeFrameDecoding();
				}
			sliceLevelScheduling = 6;
			}

		sliceParser->Parse();
		} while (IS_SLICE_HEADER(bitStream->PeekBits(32)));

	if (pictureStructure != PS_FRAME_PICTURE)
		{
		sliceParser->DoneFirstFieldDecoding();

		try
			{
			bool oldIsIPFrame = isIPFrame;
			ParsePictureHeader();
			if (oldIsIPFrame != isIPFrame) return FALSE;
			ParsePictureCodingExtension();
			ParseExtensionAndUserData();
			}
		catch (PictureHeaderSyntaxError)
			{
			return FALSE;
			}

		if (WaitForPictureDataComplete())
			{
			sliceParser->BeginSecondFieldDecoding();

			sliceLevelScheduling = 4;

			do {
				if (IsHigherPriorityTimedFiberReady())
					{
					if (sliceParser->SuspendFrameDecoding())
						{
						YieldTimedFiber(0);

						sliceParser->ResumeFrameDecoding();
						}
					sliceLevelScheduling = 6;
					}

				sliceParser->Parse();
				} while (IS_SLICE_HEADER(bitStream->PeekBits(32)));
			}
		else
			{
			do {
				if (!bitStream->RefillBuffer()) return FALSE;

				bitStream->Advance(32);
				bitStream->NextStartCode();
				} while (IS_SLICE_HEADER(bitStream->PeekBits(32)));
			}
		}

	return TRUE;
	}

//
//  Skip Picture Body
//

bool PictureParser::SkipPictureBody(void)
	{
	do {
		if (!bitStream->RefillBuffer()) return FALSE;

		bitStream->Advance(32);
		bitStream->NextStartCode();
		} while (IS_SLICE_HEADER(bitStream->PeekBits(32)));

	if (pictureStructure != PS_FRAME_PICTURE)
		{
		ParsePictureHeader();
		ParsePictureCodingExtension();
		ParseExtensionAndUserData();

		do {
			if (!bitStream->RefillBuffer(16 * 1024 * 8)) return FALSE;

			bitStream->Advance(32);
			bitStream->NextStartCode();
			} while (IS_SLICE_HEADER(bitStream->PeekBits(32)));
		}

	return TRUE;
	}

//
//  Release Frame Buffers
//

void PictureParser::ReleaseFrameBuffers(void)
	{
	sliceParser->InvalidateFrameReferences();

	if (ipFrameBuffers[0]) delete ipFrameBuffers[0];
	if (ipFrameBuffers[1]) delete ipFrameBuffers[1];
	if (ipFrameBuffers[2]) delete ipFrameBuffers[2];
	if (bFrameBuffers[0])  delete bFrameBuffers[0];
	if (bFrameBuffers[1])  delete bFrameBuffers[1];

	ipFrameBuffers[0] = NULL;
	ipFrameBuffers[1] = NULL;
	ipFrameBuffers[2] = NULL;
	bFrameBuffers[0] = NULL;
	bFrameBuffers[1] = NULL;

	previousFrame = NULL;
	previousBFrameID = 0;

	sliceParser->EndFrameSequence();
	}

//
//  Allocate Frame Buffers
//

void PictureParser::AllocateFrameBuffers(void)
	{
	if (!ipFrameBuffers[0])
		{
		sliceParser->BeginFrameSequence();

		ipFrameBuffers[0] = sliceParser->AllocFrameStore(PREDICTIVE_CODED, display->SupportsStripeAccess());
		ipFrameBuffers[1] = sliceParser->AllocFrameStore(PREDICTIVE_CODED, display->SupportsStripeAccess());
		if (playbackMode == VDPM_PLAY_BACKWARD || playbackMode == VDPM_TRICKPLAY)
			ipFrameBuffers[2] = sliceParser->AllocFrameStore(PREDICTIVE_CODED, display->SupportsStripeAccess());

		bFrameBuffers[0] = sliceParser->AllocFrameStore(BIDIRECTIONAL_PREDICTIVE_CODED, display->SupportsStripeAccess());
		if (display->NeedsPreviousFrame())
			bFrameBuffers[1] = sliceParser->AllocFrameStore(BIDIRECTIONAL_PREDICTIVE_CODED, display->SupportsStripeAccess());
		}
	}

//
//  Pre Parse Pictures
//

void PictureParser::PreParsePicture(PictureCodingType & codingType)
	{
	ParsePictureHeader();
	if (vcs == VCS_MPEG_2)
		{
		ParsePictureCodingExtension();
		ParseExtensionAndUserData();
		}
	else
		ParseExtensionAndUserData();

	codingType = this->codingType;

	SkipPictureBody();
	}

//
//  Parse Temp Pictures
//

void PictureParser::ParseTempPicture(void)
	{
	PictureStructure	fieldDisplayMode;
	int decodedIPFrame;
	int displayTime;
	bool didDisplay;

	AllocateFrameBuffers();

	displayTime = (int)((__int64)lowFieldCount * (500000 / 16) / framesPerSecond + timeOffset);

	ParsePictureHeader();
	if (vcs == VCS_MPEG_2)
		{
		ParsePictureCodingExtension();
		ParseExtensionAndUserData();
		}
	else
		{
		ParseExtensionAndUserData();
		pictureStructure = PS_FRAME_PICTURE;
		fieldDisplayMode = PS_FRAME_PICTURE;
		sliceParser->SetPictureParameters(0, PS_FRAME_PICTURE, 0x10); // FRAME_PRED_FRAME_DCT
		}

	if (isIPFrame)
		{
		if (ipDisplayBuffer)
			{
			PostIPFrameBuffer(displayTime, FALSE);
			initialBFrameSkip = FALSE;
			ipDisplayBuffer = NULL;
			didDisplay = TRUE;
			}
		else
			didDisplay = FALSE;
		if (!WaitForPictureDataComplete()) return;

		if (playbackMode == VDPM_PLAY_BACKWARD)
			decodedIPFrame = 3 - (pastIPFrame + futureIPFrame);
		else
			decodedIPFrame = pastIPFrame;

		if (sliceParser->BeginFrameDecoding(ipFrameBuffers[futureIPFrame], ipFrameBuffers[futureIPFrame], ipFrameBuffers[decodedIPFrame], NULL, FALSE))
			{
			if (ParsePictureBody())
				{
				sliceParser->DoneFrameDecoding();
				}
			else
				{
				sliceParser->DoneFrameDecoding();
				return;
				}
			}
		else
			{
			if (!SkipPictureBody()) return;
			}

		switch (playbackMode)
			{
			case VDPM_PLAY_FORWARD:
			case VDPM_TRICKPLAY:
			case VDPM_SCANNING:
				pastIPFrame = futureIPFrame;
				futureIPFrame = decodedIPFrame;
				break;
			case VDPM_PLAY_BACKWARD:
				futureIPFrame = decodedIPFrame;
				break;
			}
		}
	else
		{
		SkipPictureBody();
		}

	if (didDisplay)
		{
		fieldCount+=2;
		if (vcs == VCS_MPEG_2)
			{
			if (lastIPRepeatFirstField)
				fieldCount++;
			if (pullDownReconstruction && !mixedPullDownSequence)
				lowFieldCount = (7 * (lowFieldCount + 32) + fieldCount * 16) >> 3;
			else
				lowFieldCount = (3 * (lowFieldCount + 32) + fieldCount * 16) >> 2;
			}
		else
			lowFieldCount = 16 * fieldCount;
		}
	}

//
//  Post Previous Frame
//

static int Delay32Pulldown[] = {0, 0, 9, 0, 0, -8, -8, -17, -17};

void PictureParser::PostPreviousFrame(void)
	{
	if (previousDisplayBuffer)
		{
		previousDisplayBuffer->CompleteDeinterlaceFrame();
		if (previousWasIPFrame)
			display->PostIPFrameBuffer(previousDisplayBuffer, previousDisplayTime);
		else
			display->PostBFrameBuffer(previousDisplayBuffer, previousDisplayTime);

		previousDisplayBuffer = NULL;
		}
	}

//
//  Post IP Frame Buffer
//

void PictureParser::PostIPFrameBuffer(int displayTime, bool hurryUp)
	{
	int delayTime;
	Inverse32PulldownHint	ophint = phint;

	if (bFrameBuffers[1])
		{
		if (isStreamPlayback)
			{
			delayTime = 0;

			if (previousDisplayBuffer)
				{
				ipDisplayBuffer->DeinterlaceFrame(previousDisplayBuffer, phint, hurryUp);

				if (ipDisplayBuffer->fmode != PS_FRAME_PICTURE &&
					 ipDisplayBuffer->mode == PS_FRAME_PICTURE) delayTime = Delay32Pulldown[phint];

#if FRAME_ANNOTATION
				previousDisplayBuffer->DebugPrint(8, 40, "%08lx -> %08lx", previousDisplayBuffer, ipDisplayBuffer);
				previousDisplayBuffer->DebugPrint(8, 41, "FrameType %d (3:2 %d->%d) PStruct (%d->%d), (%d->%d)",
					previousWasIPFrame, ophint, phint,
					previousDisplayBuffer->fmode, previousDisplayBuffer->mode,
					ipDisplayBuffer->fmode, ipDisplayBuffer->mode);
#endif

				if (previousWasIPFrame)
					display->PostIPFrameBuffer(previousDisplayBuffer, previousDisplayTime);
				else
					display->PostBFrameBuffer(previousDisplayBuffer, previousDisplayTime);

				previousDisplayBuffer = NULL;
				}
			else
				ipDisplayBuffer->DeinterlaceInitialFrame();

			previousDisplayBuffer = ipDisplayBuffer;
			previousDisplayTime = displayTime + delayTime;
			previousWasIPFrame = TRUE;
			}
		else
			{
			ipDisplayBuffer->CompleteDeinterlaceFrame();
			display->PostIPFrameBuffer(ipDisplayBuffer, displayTime);
			}
		}
	else
		{
#if FRAME_ANNOTATION
		ipDisplayBuffer->DebugPrint(8,  8, "IPFrame Disp# %3d", displayFrameCount++);
		ipDisplayBuffer->DebugPrint(8, 10, "Progr %d Repeat %d (%d)", (int)lastIPProgressiveFrame, (int)lastIPRepeatFirstField, (int)ipDisplayBuffer->mode);
#endif
		display->PostIPFrameBuffer(ipDisplayBuffer, displayTime);
		}
	}

//
//  Post B Frame Buffer
//

void PictureParser::PostBFrameBuffer(int displayTime, Inverse32PulldownHint bphint, bool hurryUp)
	{
	int delayTime;
	Inverse32PulldownHint	ophint = bphint;

	if (bFrameBuffers[1])
		{
		if (isStreamPlayback)
			{
			delayTime = 0;
			if (previousDisplayBuffer && bDisplayBuffer)
				{
				bDisplayBuffer->DeinterlaceFrame(previousDisplayBuffer, bphint, hurryUp);
				if (bphint == IPDH_UNKNOWN && !repeatFirstField) phint = IPDH_UNKNOWN;

				if (bDisplayBuffer->fmode != PS_FRAME_PICTURE &&
					 bDisplayBuffer->mode == PS_FRAME_PICTURE) delayTime = Delay32Pulldown[bphint];

#if FRAME_ANNOTATION
				previousDisplayBuffer->DebugPrint(8, 40, "%08lx -> %08lx", previousDisplayBuffer, bDisplayBuffer);
				previousDisplayBuffer->DebugPrint(8, 41, "FrameType %d (3:2 %d->%d) PStruct (%d->%d), (%d->%d)",
					previousWasIPFrame, ophint, bphint,
					previousDisplayBuffer->fmode, previousDisplayBuffer->mode,
					bDisplayBuffer->fmode, bDisplayBuffer->mode);
#endif

				if (previousWasIPFrame)
					display->PostIPFrameBuffer(previousDisplayBuffer, previousDisplayTime);
				else
					display->PostBFrameBuffer(previousDisplayBuffer, previousDisplayTime);

				previousDisplayBuffer = NULL;
				}
			else
				bDisplayBuffer->DeinterlaceInitialFrame();

			previousDisplayBuffer = bDisplayBuffer;
			previousDisplayTime = displayTime + delayTime;
			previousWasIPFrame = FALSE;
			}
		else
			{
			bDisplayBuffer->CompleteDeinterlaceFrame();
			display->PostBFrameBuffer(bDisplayBuffer, displayTime);
			}
		}
	else
		{
#if FRAME_ANNOTATION
		bDisplayBuffer->DebugPrint(8,  8, "BFrame  Disp# %3d", displayFrameCount++);
		bDisplayBuffer->DebugPrint(8, 10, "Progr %d Repeat %d (%d)", progressiveFrame, repeatFirstField, bDisplayBuffer->mode);
#endif
		display->PostBFrameBuffer(bDisplayBuffer, displayTime);
		}
	}

//
//  Parse Picture
//

void PictureParser::ParsePicture(void)
	{
	int displayTime, currentTime, newTimeStamp, deltaTime, timeStamp;
	bool isFieldMaterial, doDecode, didDisplay, thisRepeatFirstField;
	PictureStructure	fieldDisplayMode;
	DWORD deinterlaceMode;
	FrameStore * currentFrame, * currentDisplayFrame;
	PictureDisplayBuffer * currentDisplayBuffer;
	int decodedIPFrame;
	Inverse32PulldownHint	bphint = IPDH_UNKNOWN;

#if FRAME_STATISTICS
static	int enterTime, postTime, getTime;
static	char cts[] = {'X', 'I', 'P', 'B', 'x', 'i', 'p', 'b'};
#endif

	bool hurryUp;

	AllocateFrameBuffers();

	newTimeStamp = bitStream->GetCurrentTimeStamp();
	if (newTimeStamp == previousTimeStamp)
		newTimeStamp = INVALID_TIME_STAMP;
	else if (newTimeStamp != INVALID_TIME_STAMP)
		previousTimeStamp = newTimeStamp;

	ParsePictureHeader();
	if (vcs == VCS_MPEG_2)
		{
		ParsePictureCodingExtension();
		ParseExtensionAndUserData();

		pullDownSequence |= repeatFirstField;
		progressiveSequence |= progressiveFrame;

		progressiveHistory <<= 1;
		if (progressiveFrame) progressiveHistory |= 1;
		repeatFirstHistory <<= 1;
		progressiveDisplayHistory <<= 1;
		if (isIPFrame)
			{
			if (lastIPRepeatFirstField) repeatFirstHistory |= 1;
			if (lastIPProgressiveFrame) progressiveDisplayHistory |= 1;
			}
		else
			{
			if (repeatFirstField) repeatFirstHistory |= 1;
			if (progressiveFrame) progressiveDisplayHistory |= 1;
			}


		if (pullDownSequence)
			{
			DWORD upper = (progressiveHistory >> 8);
			DWORD lower = progressiveHistory & 0xff;

			if (((upper & 0x0000ff) == 0x0000ff ||
				  (upper & 0x00ff00) == 0x00ff00 ||
				  (upper & 0xff0000) == 0xff0000) && lower != 0xff) mixedPullDownSequence = TRUE;
			if ((progressiveHistory & 0x00ff) == 0x00fe) mixedPullDownSequence = TRUE;
			if ((progressiveHistory & 0xffff) == 0x578e) mixedPullDownSequence = TRUE;
//			if ((progressiveHistory & 0xffff) == 0x57fe) mixedPullDownSequence = TRUE;
			if ((progressiveHistory & 0x000f) == 0x0000) mixedPullDownSequence = TRUE;
			if ((progressiveHistory & 0x01ff) == 0x01c7) mixedPullDownSequence = FALSE;
			if ((progressiveHistory & 0x003f) == 0x003f) mixedPullDownSequence = FALSE;

			upper = repeatFirstHistory >> 16;
			lower = repeatFirstHistory & 0xffff;

			//if (lower == 0x0000) phint = IPDH_UNKNOWN;

			if ((repeatFirstHistory & 3) == 0) mixedPullDownSequence = TRUE;
			}

		switch (bobWeaveLevel)
			{
			case BWL_FORCE_BOB:
				isFieldMaterial = TRUE;
				break;
			case BWL_FORCE_WEAVE:
				isFieldMaterial = FALSE;
				break;
			case BWL_PREFERE_BOB:
				isFieldMaterial = !(PF_FRAME_PRED_FRAME_DCT(pictureFlags) && progressiveFrame);
				break;
			case BWL_PREFERE_WEAVE:
				isFieldMaterial = !(PF_FRAME_PRED_FRAME_DCT(pictureFlags) || progressiveSequence);
				break;
			case BWL_SMART_DECISION:
				isFieldMaterial = !(PF_FRAME_PRED_FRAME_DCT(pictureFlags) || progressiveSequence && !mixedPullDownSequence);
				break;
			}

		if (bFrameBuffers[1] && progressiveFrame) isFieldMaterial = FALSE;

		if (playbackMode == VDPM_PLAY_BACKWARD)
			{
			pictureFlags ^= 0x20; // invert top field first
			}

		if (pictureStructure == PS_FRAME_PICTURE)
			fieldDisplayMode = isFieldMaterial ? (PF_TOP_FIELD_FIRST(pictureFlags) ? PS_TOP_FIELD : PS_BOTTOM_FIELD) : pictureStructure;
		else
			fieldDisplayMode = pictureStructure;

		deinterlaceMode = display->GetDeinterlaceFlags();

		if (fieldDisplayMode == PS_FRAME_PICTURE)
			{
			if (!(deinterlaceMode & DEIF_DEINTERLACE_WEAVE))
				fieldDisplayMode = PF_TOP_FIELD_FIRST(pictureFlags) ? PS_TOP_FIELD : PS_BOTTOM_FIELD;
			}
		else
			{
			if (!(deinterlaceMode & DEIF_DEINTERLACE_BOB))
				fieldDisplayMode = PS_FRAME_PICTURE;
			}
		}
	else
		{
		ParseExtensionAndUserData();
		pictureStructure = PS_FRAME_PICTURE;
		fieldDisplayMode = PS_FRAME_PICTURE;
		isFieldMaterial = FALSE;
		sliceParser->SetPictureParameters(0, PS_FRAME_PICTURE, 0x10); // FRAME_PRED_FRAME_DCT
		}


#if FRAME_STATISTICS
	enterTime = display->CurrentTime();
#endif

	displayTime = (int)((__int64)lowFieldCount * (500000 / 16) / framesPerSecond + timeOffset);


	if (isIPFrame)
		{
		timeStamp = lastIPTimeStamp;
		lastIPTimeStamp = newTimeStamp;
		thisFrameRepeat = ipFrameRepeat;
		ipFrameRepeat = frameRepeat;
		}
	else
		{
		timeStamp = newTimeStamp;
		thisFrameRepeat = frameRepeat;
		}

	if (playbackMode != VDPM_PLAY_BACKWARD)
		{
		if (timeStamp >= 0)
			{
			deltaTime = displayTime - timeStamp;
			if (deltaTime < 0) deltaTime = -deltaTime;

			if (deltaTime < 200)
				timeStamp = (displayTime * 7 + timeStamp) >> 3;

			timeOffset += timeStamp - displayTime;
			displayTime = timeStamp;
			}
		}

	currentTime = display->CurrentTime();

	if (bFrameBuffers[1])
		hurryUp = (displayTime < currentTime + fieldTime * 13 / 4) && (fieldCount > 50);
	else
		hurryUp = (displayTime < currentTime + fieldTime * 5 / 4) && (fieldCount > 50);

	didDisplay = TRUE;

	if (alwaysHurryUp && framesPerSecond > 50) hurryUp = TRUE;

	frameDropCounter += frameDropIncrement;

#if NO_DROPPED_FRAMES
	if (isIPFrame || !initialBFrameSkip || playbackMode == VDPM_TRICKPLAY)
		{
		hurryUp = FALSE;
#elif ONLY_I_FRAMES
	if (codingType == INTRA_CODED)
		{
		hurryUp = FALSE;
#elif ONLY_IP_FRAMES
	if (isIPFrame)
		{
		hurryUp = FALSE;
#else
	if (isIPFrame || (displayTime >= currentTime && !initialBFrameSkip && frameDropCounter < 100) || playbackMode == VDPM_TRICKPLAY)
		{
		if (playbackMode == VDPM_TRICKPLAY) hurryUp = FALSE;
#endif
		if (hurryUp) perfmon.framesDegraded++;
		hurryUp = FALSE;
		if (isIPFrame)
			{
			if (ipDisplayBuffer)
				{
				if (bobWeaveLevel == BWL_SMART_DECISION &&
					(deinterlaceMode & DEIF_CAN_CHANGE_DEINTERLACE_DISPLAY) &&
					ipDisplayBuffer->mode == PS_FRAME_PICTURE &&
					fieldDisplayMode != PS_FRAME_PICTURE)
					{
					ipDisplayBuffer->SetFieldDisplayMode(PF_TOP_FIELD_FIRST(lastIPPictureFlags) ? PS_TOP_FIELD : PS_BOTTOM_FIELD, fieldTime);
					}

				if (ipDisplayBuffer->mode == PS_FRAME_PICTURE)
					perfmon.framesWeave++;
				else
					perfmon.framesBob++;

				PostIPFrameBuffer(displayTime, hurryUp);

				currentDisplayFrame = ipFrameBuffers[futureIPFrame];
				initialBFrameSkip = FALSE;
				ipDisplayBuffer = NULL;

				if (lastIPRepeatFirstField)
					{
					if (phint != IPDH_UNKNOWN ||
						 ((repeatFirstHistory & 0xffff) == 0xaaaa) ||
						 ((repeatFirstHistory & 0xffff) == 0x5555))
						phint = IPDH_FRAME_FRAME1;
					}
				else
					{
					switch (phint)
						{
						case IPDH_UNKNOWN:
							break;
						case IPDH_FRAME_FRAME1:
							phint = IPDH_FRAME_FRAME2;
							break;
						case IPDH_FRAME_FRAME2:
							if (PF_TOP_FIELD_FIRST(lastIPPictureFlags))
								phint = IPDH_FRAME_TOP;
							else
								phint = IPDH_FRAME_BOTTOM;
							break;
						case IPDH_FRAME_TOP:
							phint = IPDH_BOTTOM_TOP;
							if (lastIPProgressiveFrame) phint = IPDH_UNKNOWN;
							break;
						case IPDH_FRAME_BOTTOM:
							phint = IPDH_TOP_BOTTOM;
							if (lastIPProgressiveFrame) phint = IPDH_UNKNOWN;
							break;
						case IPDH_TOP_FRAME:
						case IPDH_BOTTOM_FRAME:
							phint = IPDH_FRAME_FRAME1;
							break;
						case IPDH_TOP_BOTTOM:
							phint = IPDH_TOP_FRAME;
							if (lastIPProgressiveFrame) phint = IPDH_UNKNOWN;
							break;
						case IPDH_BOTTOM_TOP:
							phint = IPDH_BOTTOM_FRAME;
							if (lastIPProgressiveFrame) phint = IPDH_UNKNOWN;
							break;
						}
					}
				}
			else
				{
				didDisplay = FALSE;
				currentDisplayFrame = NULL;
				}

			lastIPPictureFlags = pictureFlags;

#if FRAME_STATISTICS
			postTime = display->CurrentTime();
#endif
			if (!WaitForPictureDataComplete()) return;

			sliceParser->EndFrameReference(ipFrameBuffers[pastIPFrame]);

			currentDisplayBuffer = ipDisplayBuffer = display->GetIPFrameBuffer(displayTime + 3000000 / framesPerSecond);
			if (!ipDisplayBuffer) return;

#if FRAME_STATISTICS
			getTime = display->CurrentTime();
#endif

			ipDisplayBuffer->SetAspectRatio(aspectRatio, panScanOffset);
			ipDisplayBuffer->SetFieldDisplayMode(fieldDisplayMode, fieldTime);
			if (bFrameBuffers[1])
				ipDisplayBuffer->PrepareDeinterlaceDuringDecode(NULL);

			if (playbackMode == VDPM_PLAY_BACKWARD)
				decodedIPFrame = 3 - (pastIPFrame + futureIPFrame);
			else
				decodedIPFrame = pastIPFrame;

			YieldTimedFiber(-1);
			doDecode = sliceParser->BeginFrameDecoding(ipFrameBuffers[futureIPFrame], ipFrameBuffers[futureIPFrame], ipFrameBuffers[decodedIPFrame], ipDisplayBuffer, hurryUp);
			currentFrame = ipFrameBuffers[decodedIPFrame];

			sliceParser->BeginFrameReference(currentFrame);

			thisRepeatFirstField = lastIPRepeatFirstField;
			lastIPRepeatFirstField = repeatFirstField;
			lastIPProgressiveFrame = progressiveFrame;
			}
		else
			{
			if (previousDisplayBuffer && previousDisplayTime < currentTime)
				{
				PostPreviousFrame();
				}

			if (!WaitForPictureDataComplete()) return;

			currentDisplayBuffer = bDisplayBuffer = display->GetBFrameBuffer(displayTime);

#if FRAME_STATISTICS
			getTime = display->CurrentTime();
#endif
			if (!bDisplayBuffer) return;

			bDisplayBuffer->SetAspectRatio(aspectRatio, panScanOffset);
			bDisplayBuffer->SetFieldDisplayMode(fieldDisplayMode, fieldTime);
			bphint = phint;

			if (bFrameBuffers[1])
				{
				if (phint == IPDH_UNKNOWN || fieldDisplayMode == PS_FRAME_PICTURE)
					bDisplayBuffer->PrepareDeinterlaceDuringDecode(previousDisplayBuffer);
				else
					bDisplayBuffer->PrepareDeinterlaceDuringDecode(NULL);
				}

			if (bFrameBuffers[1])
				{
				currentFrame = bFrameBuffers[previousBFrameID];
				previousBFrameID = 1 - previousBFrameID;
				}
			else
				currentFrame = bFrameBuffers[0];

			currentDisplayFrame = currentFrame;
			YieldTimedFiber(-1);
			doDecode = sliceParser->BeginFrameDecoding(ipFrameBuffers[pastIPFrame], ipFrameBuffers[futureIPFrame], currentFrame, bDisplayBuffer, hurryUp);

			if (repeatFirstField)
				{
				if (phint != IPDH_UNKNOWN ||
					 ((repeatFirstHistory & 0xffff) == 0xaaaa) ||
					 ((repeatFirstHistory & 0xffff) == 0x5555))
					phint = IPDH_FRAME_FRAME1;
				}
			else
				{
				switch (phint)
					{
					case IPDH_UNKNOWN:
						break;
					case IPDH_FRAME_FRAME1:
						phint = IPDH_FRAME_FRAME2;
						break;
					case IPDH_FRAME_FRAME2:
						if (PF_TOP_FIELD_FIRST(pictureFlags))
							phint = IPDH_FRAME_TOP;
						else
							phint = IPDH_FRAME_BOTTOM;
						break;
					case IPDH_FRAME_TOP:
						phint = IPDH_BOTTOM_TOP;
						if (progressiveFrame) phint = IPDH_UNKNOWN;
						break;
					case IPDH_FRAME_BOTTOM:
						phint = IPDH_TOP_BOTTOM;
						if (progressiveFrame) phint = IPDH_UNKNOWN;
						break;
					case IPDH_TOP_FRAME:
					case IPDH_BOTTOM_FRAME:
						phint = IPDH_FRAME_FRAME1;
						break;
					case IPDH_TOP_BOTTOM:
						phint = IPDH_TOP_FRAME;
						if (progressiveFrame) phint = IPDH_UNKNOWN;
						break;
					case IPDH_BOTTOM_TOP:
						phint = IPDH_BOTTOM_FRAME;
						if (progressiveFrame) phint = IPDH_UNKNOWN;
						break;
					}
				}

			thisRepeatFirstField = repeatFirstField;
			}

		if (doDecode)
			{
			if (ParsePictureBody())
				{
				if (currentDisplayBuffer && !hurryUp &&
					 (deinterlaceMode & DEIF_CAN_CHANGE_DEINTERLACE_DISPLAY) &&
					 fieldDisplayMode == PS_FRAME_PICTURE &&
					 bobWeaveLevel == BWL_SMART_DECISION && !progressiveFrame)
					{
					if (currentDisplayBuffer->HasInterlaceArtifacts())
						{
						mixedPullDownSequence = TRUE;
						fieldDisplayMode = PF_TOP_FIELD_FIRST(pictureFlags) ? PS_TOP_FIELD : PS_BOTTOM_FIELD;
						currentDisplayBuffer->SetFieldDisplayMode(fieldDisplayMode, fieldTime);
						}
					}

				sliceParser->DoneFrameDecoding();

#if FRAME_ANNOTATION
				currentDisplayBuffer->DebugPrint(16,  9, "Decd# %3d", decodeFrameCount++);
#endif
				perfmon.framesDecoded++;
				}
			else
				{
				sliceParser->DoneFrameDecoding();
				PostBFrameBuffer(displayTime, bphint, FALSE);
				if (bFrameBuffers[1]) previousFrame = currentDisplayFrame;
				return;
				}
			}
		else
			{
			//
			// Don't decode to far into the future
			//

			if (fieldCount > 20)
				{
				if (displayTime - currentTime > 200)
					Wait(&event, currentTime + 200, FALSE);
				}

			if (!SkipPictureBody()) return;

			perfmon.framesDropped++;
			}

		if (isIPFrame)
			{
			switch (playbackMode)
				{
				case VDPM_PLAY_FORWARD:
					pastIPFrame = futureIPFrame;
					futureIPFrame = decodedIPFrame;
					break;
				case VDPM_PLAY_BACKWARD:
					futureIPFrame = pastIPFrame;
					pastIPFrame = decodedIPFrame;
					break;
				case VDPM_SCANNING:
					pastIPFrame = futureIPFrame;
					futureIPFrame = decodedIPFrame;
					break;
				case VDPM_TRICKPLAY:
					PostIPFrameBuffer(displayTime, FALSE);
					display->DoneStreaming();
					initialBFrameSkip = FALSE;
					ipDisplayBuffer = NULL;
					pastIPFrame = futureIPFrame;
					futureIPFrame = decodedIPFrame;
					break;
				}
			}
		else
			{
			if (bDisplayBuffer->mode == PS_FRAME_PICTURE)
				perfmon.framesWeave++;
			else
				perfmon.framesBob++;

			switch (playbackMode)
				{
				case VDPM_PLAY_FORWARD:
				case VDPM_PLAY_BACKWARD:
				case VDPM_SCANNING:
					PostBFrameBuffer(displayTime, bphint, hurryUp);
					break;
				case VDPM_TRICKPLAY:
					PostBFrameBuffer(displayTime, bphint, FALSE);
					display->DoneStreaming();
					break;
				}

#if FRAME_STATISTICS
			postTime = display->CurrentTime();
#endif
			}

		if (bFrameBuffers[1]) previousFrame = currentDisplayFrame;

#if FRAME_STATISTICS
		AddStatus(displayTime, enterTime, postTime, getTime, GetInternalTime() - display->CurrentTime(), cts[codingType + 4 * isFieldMaterial], FALSE, timeStamp, repeatFirstField, progressiveFrame, display->CurrentTime() - enterTime, frameContinuationCounter);
#endif
		}
	else
		{
#if FRAME_STATISTICS
		AddStatus(displayTime, enterTime, enterTime, enterTime, GetInternalTime() - display->CurrentTime(), cts[codingType + 4 * isFieldMaterial], TRUE, timeStamp, repeatFirstField, progressiveFrame, display->CurrentTime() - enterTime, frameContinuationCounter);
#endif

		//
		// Don't decode to far into the future
		//

		if (displayTime - currentTime > 200)
			Wait(&event, currentTime + 200, FALSE);

		PostPreviousFrame();
		phint = IPDH_UNKNOWN;

		SkipPictureBody();

		perfmon.framesDropped++;
		thisRepeatFirstField = repeatFirstField;

		if (frameDropCounter >= 100) frameDropCounter -= 100;
		}

	if (didDisplay)
		{
		fieldCount+=2*thisFrameRepeat;
		if (!progressiveSequenceStructure && vcs == VCS_MPEG_2)
			{
			if (thisRepeatFirstField)
				fieldCount++;

			if (pullDownReconstruction)
				{
				if ((progressiveDisplayHistory & 0x07) == 0x06)
					{
					lowFieldCount += 32;
					}
				else
					{
					switch (repeatFirstHistory & 0x03)
						{
						case 0x00: lowFieldCount += 32; break;
						case 0x01: lowFieldCount += 40; break;
						case 0x02: lowFieldCount += 40; break;
						case 0x03: lowFieldCount += 48; break;
						}
					}
				}
			else
				{
				lowFieldCount += 32;
				if (thisRepeatFirstField)
					lowFieldCount += 16;
				}
			}
		else
			lowFieldCount = 16 * fieldCount;
		}


	pictureCnt++;

	if (playbackMode != VDPM_SCANNING) bitStream->NextStartCode();

	PictureDecodingCompleted();
	}

//
//  Done Streaming
//

void PictureParser::DoneStreaming(void)
	{
	int displayTime;

	doneStreamingLock.Enter();
	if (ipDisplayBuffer)
		{
		if (lastIPTimeStamp >= 0)
			displayTime = lastIPTimeStamp;
		else
			displayTime = (int)((__int64)lowFieldCount * (500000 / 16) / framesPerSecond + timeOffset);

		if (bFrameBuffers[1])
			{
			if (previousDisplayBuffer)
				{
				ipDisplayBuffer->DeinterlaceFrame(previousDisplayBuffer, phint, FALSE);

				if (previousWasIPFrame)
					display->PostIPFrameBuffer(previousDisplayBuffer, previousDisplayTime);
				else
					display->PostBFrameBuffer(previousDisplayBuffer, previousDisplayTime);

				previousDisplayBuffer = NULL;
				}
			}

		ipDisplayBuffer->CompleteDeinterlaceFrame();
		display->PostIPFrameBuffer(ipDisplayBuffer, displayTime);
		}

	ipDisplayBuffer = NULL;
	progressiveSequence = FALSE;
	progressiveSequenceStructure = false;
	mixedPullDownSequence = FALSE;
	pullDownSequence = FALSE;
	progressiveHistory = 0xffffffff;
	repeatFirstHistory = 0x00000000;
	progressiveDisplayHistory = 0x00000000;

	display->DoneStreaming();
	doneStreamingLock.Leave();
	}

//
//  Set Image Size
//

void PictureParser::SetImageSize(int width, int height, int aspectRatio)
	{
	DWORD deinterlaceMode;

	if (aspectRatio == 3)
		this->aspectRatio = PDAR_16by9;
	else
		this->aspectRatio = PDAR_4by3;

	if (highQuality || bobWeaveLevel == BWL_FORCE_WEAVE)
		deinterlaceMode = DEIF_DEINTERLACE_WEAVE;
	else
		deinterlaceMode = DEIF_DEINTERLACE_BOB | DEIF_DEINTERLACE_WEAVE;

	display->SetPreferedDeinterlaceMode(deinterlaceMode);

	if (initialized &&
	//	(display->CheckDisplayBuffersLost() ||
	(
		 (width != this->width || height != this->height) ||
		 deinterlaceMode != currentDeinterlaceMode &&
		 !(display->GetDeinterlaceFlags() & DEIF_CAN_CHANGE_DEINTERLACE_DECODE)))
		{
		display->InvalidateDecodingBuffer();
		previousDisplayBuffer = NULL;

		if (width != this->width || height != this->height)
			{
			ReleaseFrameBuffers();
			}

		initialBFrameSkip = TRUE;
		ipDisplayBuffer = bDisplayBuffer = NULL;

		initialized = FALSE;
		}

	currentDeinterlaceMode = deinterlaceMode;

	if (!initialized)
		{
		this->width = width;
		this->height = height;

		sliceParser->SetImageSize(width, height);

		display->InitDisplay(width, height, sliceParser->MinimumStretch());

		futureIPFrame = 1;
		pastIPFrame = 0;

		initialized = TRUE;
		}

	panScanOffset = width << 13;
	}

//
//  Set Quantizer Matrix
//

void PictureParser::SetQuantMatrix(QuantMatrices type, const QuantizationMatrix & matrix)
	{
	sliceParser->SetQuantMatrix(type, matrix);
	}

//
//  Set Frame Rate
//

void PictureParser::SetFrameRate(int framesPerSecond)
	{
	this->framesPerSecond = framesPerSecond;
	if (framesPerSecond && playbackSpeed)
		fieldTime = 500000 / framesPerSecond;
	else
		fieldTime = 16;
	}

//
//  Set Closed GOP
//

void PictureParser::SetClosedGOP(void)
	{
	initialBFrameSkip = FALSE;
	}

//
//  Set Broken Link
//

void PictureParser::SetBrokenLink(void)
	{
	initialBFrameSkip = TRUE;
	}

//
//  Set Video Coding Standard
//

void PictureParser::SetVideoCodingStandard(VideoCodingStandard vcs)
	{
	this->vcs = vcs;
	sliceParser->SetVideoCodingStandard(vcs);
	}

void PictureParser::SetProgressiveSequence(bool progressiveSequence)
	{
	this->progressiveSequenceStructure = progressiveSequence;
	}

//
//  Pre Parse
//

void PictureParser::PreParse(PictureCodingType & codingType)
	{
	PreParsePicture(codingType);
	}

//
//  Parse
//

void PictureParser::Parse(PictureDecodeMode mode)
	{
	switch (mode)
		{
		case PPM_DECODE_AND_DISPLAY:
			ParsePicture();
			break;
		case PPM_DECODE_AND_DROP:
			ParseTempPicture();
			break;
		case PPM_DECODE_AND_KEEP:
			ParseTempPicture();
			break;
		}
	}

//
//  Constructor
//

PictureParser::PictureParser(GenericSliceParser * highQualitySliceParser,
                             GenericSliceParser * lowQualitySliceParser,
									  GenericPictureDisplay * display,
									  VideoBitStream * bitStream,
									  GenericProfile * globalProfile,
									  GenericProfile * profile) : TimingClient(display), event(FALSE, TRUE)
	{
	this->highQualitySliceParser = highQualitySliceParser;
	this->lowQualitySliceParser = lowQualitySliceParser;
	this->sliceParser = lowQualitySliceParser;

	this->display = display;
	this->bitStream = bitStream;
	this->globalProfile = globalProfile;
	this->profile = profile;

	currentDeinterlaceMode = 0;

	initialized = FALSE;

	ipFrameBuffers[0] = NULL;
	ipFrameBuffers[1] = NULL;
	ipFrameBuffers[2] = NULL;
	bFrameBuffers[0] = NULL;
	bFrameBuffers[1] = NULL;
	previousFrame = NULL;
	previousBFrameID = 0;
	previousDisplayBuffer = NULL;

	width = 0; height = 0;

	globalProfile->Read("VideoDecoder", "BobWeave", (int&)bobWeaveLevel, 4);
	globalProfile->Read("VideoDecoder", "PullDownReconstruction", pullDownReconstruction, TRUE);
	globalProfile->Read("VideoDecoder", "AlwaysHurryUp", alwaysHurryUp, FALSE);
	globalProfile->Read("VideoDecoder", "FrameDropIncrement", frameDropIncrement, 10, 0);
	}

PictureParser::~PictureParser(void)
	{
	if (ipFrameBuffers[0]) delete ipFrameBuffers[0];
	if (ipFrameBuffers[1]) delete ipFrameBuffers[1];
	if (ipFrameBuffers[2]) delete ipFrameBuffers[2];
	if (bFrameBuffers[0])  delete bFrameBuffers[0];
	if (bFrameBuffers[1])  delete bFrameBuffers[1];
	}

//
//  Begin Streaming
//

void PictureParser::BeginStreaming(VideoPlaybackMode playbackMode, bool highQuality)
	{
	doneStreamingLock.Enter();
#if FRAME_ANNOTATION
	decodeFrameCount = 0;
	displayFrameCount = 0;
#endif

	this->playbackMode = playbackMode;
	this->highQuality = highQuality;

	isStreamPlayback = (playbackMode == VDPM_PLAY_FORWARD || playbackMode == VDPM_PLAY_BACKWARD);

	sliceParser = highQuality ? highQualitySliceParser : lowQualitySliceParser;

	display->BeginStreaming(playbackMode == VDPM_SCANNING || playbackMode == VDPM_TRICKPLAY);

	if (initialized)
		{
		display->InvalidateDecodingBuffer();
		ReleaseFrameBuffers();

		initialized = FALSE;
		}

	fieldCount = 0;
	lowFieldCount = 0;
	previousTimeStamp = -1;
	timeOffset = 0;
	lastIPTimeStamp = 0;
	playbackSpeed = 0x10000;
	frameDropCounter = 0;

	progressiveSequence = FALSE;
	mixedPullDownSequence = FALSE;
	pullDownSequence = FALSE;
	progressiveHistory = 0xffffffff;

	ipDisplayBuffer = bDisplayBuffer = NULL;
	initialBFrameSkip = TRUE;
	phint = IPDH_UNKNOWN;

	sliceParser->InvalidateFrameReferences();
	doneStreamingLock.Leave();
	}

//
//  End Streaming
//

void PictureParser::EndStreaming(bool fullReset)
	{
	doneStreamingLock.Enter();
	display->EndStreaming(fullReset);
	sliceParser->InvalidateFrameReferences();

	previousDisplayBuffer = NULL;

	if (fullReset)
		{
		width = height = 0;
		}

#if FRAME_STATISTICS
	DumpStatus();
#endif
	doneStreamingLock.Leave();
	}

//
//  Start Streaming
//

void PictureParser::StartStreaming(int playbackSpeed)
	{
	doneStreamingLock.Enter();
	this->playbackSpeed = playbackSpeed;

	display->StartStreaming(playbackSpeed);

	if (framesPerSecond && playbackSpeed)
		fieldTime = 500000 / framesPerSecond;
	else
		fieldTime = 16;
	doneStreamingLock.Leave();
	}

//
//  Stop Streaming
//

void PictureParser::StopStreaming(void)
	{
	doneStreamingLock.Enter();
	display->StopStreaming();
	doneStreamingLock.Leave();
	}

//
//  Advance Frame
//

void PictureParser::AdvanceFrame(void)
	{
	display->AdvanceFrame();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\MPEGVideoStreamDecoder.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef MPEGVIDEOSTREAMDECODER_H
#define MPEGVIDEOSTREAMDECODER_H

#include "SliceParser.h"
#include "..\common\TimedFibers.h"
#include "library\common\profiles.h"

class MPEGVideoStreamDecoder : public VideoBitStream,
                          protected VideoStreamParser,
								  protected PictureParser,
								  private TimedFiber
	{
	protected:
		GenericPictureDisplay	*	display;
		GenericSliceParser		*	decoder;

		TimedFiberEvent				bufferRefillEvent;

		int								requestedBits;

		bool								completing;
		bool								terminate;
		bool								streamingCompleted;
		bool								streaming;
		int								endCodeReceived;
		int								endCodeCompleted;
		VideoPlaybackMode				playbackMode;

		void PictureDecodingCompleted(void);
		bool InternalIsBufferComplete(void);
		bool InternalRefillBuffer(int requestBits, bool lowDataPanic);

		void TrickSegmentRequested(void);
		void WaitForSegmentCompleted(void);
		bool IsSegmentCompleted(void);

		void FiberRoutine(void);
	public:
		MPEGVideoStreamDecoder(GenericPictureDisplay * display,
							   GenericSliceParser * highQualitySliceParser,
			               GenericSliceParser * lowQualitySliceParser,
								GenericProfile * globalProfile,
								GenericProfile * profile,
								StreamFlipCopy * streamFlipCopy);
		~MPEGVideoStreamDecoder(void);

		void BeginStreaming(VideoPlaybackMode playbackMode, bool highQuality);
		void StartStreaming(int playbackSpeed);
		void StopStreaming(void);
		void EndStreaming(bool fullReset);

		void SetLine21Decoder(Line21Decoder * line21Decoder) {VideoStreamParser::SetLine21Decoder(line21Decoder);}

		void AdvanceFrame(void);
		bool StreamingCompleted(void);
		DWORD VideoSegmentRequested(void);
		void SetFirstVideoSegment(DWORD seg);
		void SetLastVideoSegment(DWORD seg);
		void AdvanceTrickFrame(int by);

		bool EnoughDataToStart(void);

		DWORD SendData(BYTE * ptr, DWORD num);
		void CompleteData(void);

		virtual void RefillRequest(void) = 0;
		virtual void StreamCompleted(void) {}
		virtual void ScanCompleted(void) {}

		int DecodeWidth(void) {return width;}
		int DecodeHeight(void) {return height;}

		void SetErrorMessenger(ASyncErrorMessenger * errorMessenger) {VideoStreamParser::SetErrorMessenger(errorMessenger);}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\QFastISSEMotionComp.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef QFASTISSEMOTIONCOMP_H
#define QFASTISSEMOTIONCOMP_H

#include "GenericMMXMotionComp.h"

class FastISSEMotionComp : public GenericMMXMotionComp
	{
	public:
		void BiMotionCompensationUV(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal);

		void SBiMotionCompensationUV(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal);

		void BiMotionCompensationY(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal);

		void SBiMotionCompensationY(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal);

		void DBiMotionCompensationY(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr);

		void SDBiMotionCompensationY(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr);

		void IDBiMotionCompensationY(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist);

		void ISDBiMotionCompensationY(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist);

		void MotionCompensationUV(int yp, int xp, BYTE * prevp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal);

		void SMotionCompensationUV(int yp, int xp, BYTE * prevp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal);

		void MotionCompensationY(int yp, int xp, BYTE * prevp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal);

		void SMotionCompensationY(int yp, int xp, BYTE * prevp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal);

		void DMotionCompensationY(int yp, int xp, BYTE * prevp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr);

		void SDMotionCompensationY(int yp, int xp, BYTE * prevp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr);

		void IDMotionCompensationY(int yp, int xp, BYTE * prevp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist);

		void ISDMotionCompensationY(int yp, int xp, BYTE * prevp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist);

	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\QFastISSEMotionComp.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "QFastISSEMotionComp.h"

#pragma warning (disable : 4799)


static __forceinline void BiMotionCopyUV0000(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCompUV0000(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm0, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm1, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm1, mm2
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCopyUV0010(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCompUV0010(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm0, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm1, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm1, mm2
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCopyUV1010(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x02
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x0a
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCompUV1010(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x02
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm0, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x0a
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm1, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm1, mm2
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCopyUV0001(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCompUV0001(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm0, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm1, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm3, mm7
	pxor mm7, mm7
	packuswb	mm1, mm3
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm6, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm4, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm5, mm7
	pxor mm7, mm7
	packuswb	mm4, mm5
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCopyUV1001(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x02
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x0a
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x0a
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x02
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCompUV1001(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x02
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm0, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x0a
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm1, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm3, mm7
	pxor mm7, mm7
	packuswb	mm1, mm3
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x0a
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm6, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x02
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm4, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm5, mm7
	pxor mm7, mm7
	packuswb	mm4, mm5
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCopyUV0011(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x02
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCompUV0011(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x02
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm0, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm1, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm3, mm7
	pxor mm7, mm7
	packuswb	mm1, mm3
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm6, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm4, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm5, mm7
	pxor mm7, mm7
	packuswb	mm4, mm5
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCopyUV1011(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x02
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x02
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x0a
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x0a
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x02
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCompUV1011(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x02
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x02
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm0, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x0a
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm1, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm3, mm7
	pxor mm7, mm7
	packuswb	mm1, mm3
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x0a
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm6, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x02
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm4, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm5, mm7
	pxor mm7, mm7
	packuswb	mm4, mm5
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCopyUV0101(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCompUV0101(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm0, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm1, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm3, mm7
	pxor mm7, mm7
	packuswb	mm1, mm3
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm6, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm4, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm5, mm7
	pxor mm7, mm7
	packuswb	mm4, mm5
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCopyUV0111(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x02
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCompUV0111(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x02
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm0, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm1, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm3, mm7
	pxor mm7, mm7
	packuswb	mm1, mm3
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm6, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm4, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm5, mm7
	pxor mm7, mm7
	packuswb	mm4, mm5
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCopyUV1111(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x0a
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x02
////-------------
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x02
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x02
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x0a
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x0a
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x02
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCompUV1111(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x0a
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x02
////-------------
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x02
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x02
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm0, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x0a
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm1, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm3, mm7
	pxor mm7, mm7
	packuswb	mm1, mm3
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x0a
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm6, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x02
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm4, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm5, mm7
	pxor mm7, mm7
	packuswb	mm4, mm5
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

void FastISSEMotionComp::BiMotionCompensationUV(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal)
	{
	int f = ((ys & 1) << 3) | ((yp & 1) << 2) | ((xs & 1) << 1) | xp & 1;
	BYTE * temp;

	if (copy)
		{
		switch (f)
			{
			case 0:
				BiMotionCopyUV0000(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 1:
				temp = prevp; prevp = succp; succp = temp;
			case 2:
				BiMotionCopyUV0010(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 3:
				BiMotionCopyUV1010(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 4:
				temp = prevp; prevp = succp; succp = temp;
			case 8:
				BiMotionCopyUV0001(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 6:
				temp = prevp; prevp = succp; succp = temp;
			case 9:
				BiMotionCopyUV1001(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 5:
				temp = prevp; prevp = succp; succp = temp;
			case 10:
				BiMotionCopyUV0011(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 7:
				temp = prevp; prevp = succp; succp = temp;
			case 11:
				BiMotionCopyUV1011(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 12:
				BiMotionCopyUV0101(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 13:
				temp = prevp; prevp = succp; succp = temp;
			case 14:
				BiMotionCopyUV0111(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 15:
				BiMotionCopyUV1111(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			}
		}
	else
		{
		switch (f)
			{
			case 0:
				BiMotionCompUV0000(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 1:
				temp = prevp; prevp = succp; succp = temp;
			case 2:
				BiMotionCompUV0010(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 3:
				BiMotionCompUV1010(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 4:
				temp = prevp; prevp = succp; succp = temp;
			case 8:
				BiMotionCompUV0001(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 6:
				temp = prevp; prevp = succp; succp = temp;
			case 9:
				BiMotionCompUV1001(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 5:
				temp = prevp; prevp = succp; succp = temp;
			case 10:
				BiMotionCompUV0011(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 7:
				temp = prevp; prevp = succp; succp = temp;
			case 11:
				BiMotionCompUV1011(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 12:
				BiMotionCompUV0101(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 13:
				temp = prevp; prevp = succp; succp = temp;
			case 14:
				BiMotionCompUV0111(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 15:
				BiMotionCompUV1111(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			}
		}
	}

static __forceinline void SBiMotionCopyUV0000(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCompUV0000(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm0, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm1, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm1, mm2
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCopyUV0010(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCompUV0010(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm0, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm1, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm1, mm2
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCopyUV1010(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x02
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x0a
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCompUV1010(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x02
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm0, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x0a
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm1, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm1, mm2
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCopyUV0001(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCompUV0001(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm0, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm1, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm3, mm7
	pxor mm7, mm7
	packuswb	mm1, mm3
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm6, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm4, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm5, mm7
	pxor mm7, mm7
	packuswb	mm4, mm5
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCopyUV1001(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x02
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x0a
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x0a
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x02
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCompUV1001(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x02
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm0, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x0a
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm1, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm3, mm7
	pxor mm7, mm7
	packuswb	mm1, mm3
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x0a
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm6, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x02
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm4, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm5, mm7
	pxor mm7, mm7
	packuswb	mm4, mm5
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCopyUV0011(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x02
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCompUV0011(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x02
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm0, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm1, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm3, mm7
	pxor mm7, mm7
	packuswb	mm1, mm3
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm6, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm4, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm5, mm7
	pxor mm7, mm7
	packuswb	mm4, mm5
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCopyUV1011(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x02
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x02
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x0a
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x0a
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x02
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCompUV1011(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x02
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x02
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm0, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x0a
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm1, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm3, mm7
	pxor mm7, mm7
	packuswb	mm1, mm3
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x0a
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm6, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x02
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm4, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm5, mm7
	pxor mm7, mm7
	packuswb	mm4, mm5
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCopyUV0101(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCompUV0101(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm0, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm1, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm3, mm7
	pxor mm7, mm7
	packuswb	mm1, mm3
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm6, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm4, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm5, mm7
	pxor mm7, mm7
	packuswb	mm4, mm5
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCopyUV0111(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x02
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCompUV0111(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x02
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm0, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm1, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm3, mm7
	pxor mm7, mm7
	packuswb	mm1, mm3
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm6, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm4, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm5, mm7
	pxor mm7, mm7
	packuswb	mm4, mm5
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCopyUV1111(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x0a
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x02
////-------------
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x02
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x02
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x0a
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x0a
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x02
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCompUV1111(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x0a
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x02
////-------------
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x02
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x02
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm0, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x0a
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x0a
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm1, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm3, mm7
	pxor mm7, mm7
	packuswb	mm1, mm3
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x0a
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x0a
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	movq	mm7, [ebx + 8]
	punpcklwd	mm7, [ebx + 16 + 8]
	paddw	mm6, mm7
	movq	mm7, [ebx + 8]
	punpckhwd	mm7, [ebx + 16 + 8]
	paddw	mm2, mm7
	pxor mm7, mm7
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x02
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x02
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	movq	mm7, [ebx + 0]
	punpcklwd	mm7, [ebx + 16 + 0]
	paddw	mm4, mm7
	movq	mm7, [ebx + 0]
	punpckhwd	mm7, [ebx + 16 + 0]
	paddw	mm5, mm7
	pxor mm7, mm7
	packuswb	mm4, mm5
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

void FastISSEMotionComp::SBiMotionCompensationUV(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	int f = ((ys & 1) << 3) | ((yp & 1) << 2) | ((xs & 1) << 1) | xp & 1;
	BYTE * temp;

	if (copy)
		{
		switch (f)
			{
			case 0:
				SBiMotionCopyUV0000(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 1:
				temp = prevp; prevp = succp; succp = temp;
			case 2:
				SBiMotionCopyUV0010(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 3:
				SBiMotionCopyUV1010(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 4:
				temp = prevp; prevp = succp; succp = temp;
			case 8:
				SBiMotionCopyUV0001(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 6:
				temp = prevp; prevp = succp; succp = temp;
			case 9:
				SBiMotionCopyUV1001(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 5:
				temp = prevp; prevp = succp; succp = temp;
			case 10:
				SBiMotionCopyUV0011(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 7:
				temp = prevp; prevp = succp; succp = temp;
			case 11:
				SBiMotionCopyUV1011(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 12:
				SBiMotionCopyUV0101(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 13:
				temp = prevp; prevp = succp; succp = temp;
			case 14:
				SBiMotionCopyUV0111(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 15:
				SBiMotionCopyUV1111(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			}
		}
	else
		{
		switch (f)
			{
			case 0:
				SBiMotionCompUV0000(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 1:
				temp = prevp; prevp = succp; succp = temp;
			case 2:
				SBiMotionCompUV0010(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 3:
				SBiMotionCompUV1010(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 4:
				temp = prevp; prevp = succp; succp = temp;
			case 8:
				SBiMotionCompUV0001(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 6:
				temp = prevp; prevp = succp; succp = temp;
			case 9:
				SBiMotionCompUV1001(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 5:
				temp = prevp; prevp = succp; succp = temp;
			case 10:
				SBiMotionCompUV0011(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 7:
				temp = prevp; prevp = succp; succp = temp;
			case 11:
				SBiMotionCompUV1011(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 12:
				SBiMotionCompUV0101(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 13:
				temp = prevp; prevp = succp; succp = temp;
			case 14:
				SBiMotionCompUV0111(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 15:
				SBiMotionCompUV1111(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			}
		}
	}

static __forceinline void BiMotionCopyY0000(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCompY0000(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCopyY0010(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCompY0010(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCopyY1010(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCompY1010(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCopyY0001(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCompY0001(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCopyY1001(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCompY1001(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCopyY0011(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCompY0011(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCopyY1011(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCompY1011(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCopyY0101(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCompY0101(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCopyY0111(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCompY0111(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCopyY1111(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void BiMotionCompY1111(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	[ebx], mm4
	movq	[ebx + 8], mm6
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

void FastISSEMotionComp::BiMotionCompensationY(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal)
	{
	int f = ((ys & 1) << 3) | ((yp & 1) << 2) | ((xs & 1) << 1) | xp & 1;
	BYTE * temp;

	if (copy)
		{
		switch (f)
			{
			case 0:
				BiMotionCopyY0000(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 1:
				temp = prevp; prevp = succp; succp = temp;
			case 2:
				BiMotionCopyY0010(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 3:
				BiMotionCopyY1010(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 4:
				temp = prevp; prevp = succp; succp = temp;
			case 8:
				BiMotionCopyY0001(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 6:
				temp = prevp; prevp = succp; succp = temp;
			case 9:
				BiMotionCopyY1001(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 5:
				temp = prevp; prevp = succp; succp = temp;
			case 10:
				BiMotionCopyY0011(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 7:
				temp = prevp; prevp = succp; succp = temp;
			case 11:
				BiMotionCopyY1011(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 12:
				BiMotionCopyY0101(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 13:
				temp = prevp; prevp = succp; succp = temp;
			case 14:
				BiMotionCopyY0111(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 15:
				BiMotionCopyY1111(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			}
		}
	else
		{
		switch (f)
			{
			case 0:
				BiMotionCompY0000(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 1:
				temp = prevp; prevp = succp; succp = temp;
			case 2:
				BiMotionCompY0010(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 3:
				BiMotionCompY1010(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 4:
				temp = prevp; prevp = succp; succp = temp;
			case 8:
				BiMotionCompY0001(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 6:
				temp = prevp; prevp = succp; succp = temp;
			case 9:
				BiMotionCompY1001(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 5:
				temp = prevp; prevp = succp; succp = temp;
			case 10:
				BiMotionCompY0011(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 7:
				temp = prevp; prevp = succp; succp = temp;
			case 11:
				BiMotionCompY1011(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 12:
				BiMotionCompY0101(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 13:
				temp = prevp; prevp = succp; succp = temp;
			case 14:
				BiMotionCompY0111(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			case 15:
				BiMotionCompY1111(prevp, succp, sbpr, deltap, dbpr, dfinal);
				break;
			}
		}
	}

static __forceinline void SBiMotionCopyY0000(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCompY0000(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCopyY0010(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCompY0010(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCopyY1010(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCompY1010(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCopyY0001(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCompY0001(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCopyY1001(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCompY1001(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCopyY0011(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCompY0011(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCopyY1011(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCompY1011(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCopyY0101(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCompY0101(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCopyY0111(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCompY0111(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCopyY1111(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SBiMotionCompY1111(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [destp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	[eax], mm0
	movq	[eax + 8], mm1
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	[eax], mm4
	movq	[eax + 8], mm6
	add	eax, esi
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

void FastISSEMotionComp::SBiMotionCompensationY(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	int f = ((ys & 1) << 3) | ((yp & 1) << 2) | ((xs & 1) << 1) | xp & 1;
	BYTE * temp;

	if (copy)
		{
		switch (f)
			{
			case 0:
				SBiMotionCopyY0000(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 1:
				temp = prevp; prevp = succp; succp = temp;
			case 2:
				SBiMotionCopyY0010(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 3:
				SBiMotionCopyY1010(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 4:
				temp = prevp; prevp = succp; succp = temp;
			case 8:
				SBiMotionCopyY0001(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 6:
				temp = prevp; prevp = succp; succp = temp;
			case 9:
				SBiMotionCopyY1001(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 5:
				temp = prevp; prevp = succp; succp = temp;
			case 10:
				SBiMotionCopyY0011(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 7:
				temp = prevp; prevp = succp; succp = temp;
			case 11:
				SBiMotionCopyY1011(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 12:
				SBiMotionCopyY0101(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 13:
				temp = prevp; prevp = succp; succp = temp;
			case 14:
				SBiMotionCopyY0111(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 15:
				SBiMotionCopyY1111(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			}
		}
	else
		{
		switch (f)
			{
			case 0:
				SBiMotionCompY0000(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 1:
				temp = prevp; prevp = succp; succp = temp;
			case 2:
				SBiMotionCompY0010(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 3:
				SBiMotionCompY1010(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 4:
				temp = prevp; prevp = succp; succp = temp;
			case 8:
				SBiMotionCompY0001(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 6:
				temp = prevp; prevp = succp; succp = temp;
			case 9:
				SBiMotionCompY1001(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 5:
				temp = prevp; prevp = succp; succp = temp;
			case 10:
				SBiMotionCompY0011(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 7:
				temp = prevp; prevp = succp; succp = temp;
			case 11:
				SBiMotionCompY1011(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 12:
				SBiMotionCompY0101(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 13:
				temp = prevp; prevp = succp; succp = temp;
			case 14:
				SBiMotionCompY0111(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 15:
				SBiMotionCompY1111(prevp, succp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			}
		}
	}

static __forceinline void DBiMotionCopyY0000(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DBiMotionCompY0000(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DBiMotionCopyY0010(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DBiMotionCompY0010(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DBiMotionCopyY1010(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DBiMotionCompY1010(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DBiMotionCopyY0001(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DBiMotionCompY0001(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DBiMotionCopyY1001(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DBiMotionCompY1001(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DBiMotionCopyY0011(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DBiMotionCompY0011(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DBiMotionCopyY1011(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DBiMotionCompY1011(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DBiMotionCopyY0101(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DBiMotionCompY0101(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DBiMotionCopyY0111(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DBiMotionCompY0111(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DBiMotionCopyY1111(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DBiMotionCompY1111(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

void FastISSEMotionComp::DBiMotionCompensationY(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	int f = ((ys & 1) << 3) | ((yp & 1) << 2) | ((xs & 1) << 1) | xp & 1;
	BYTE * temp;

	if (copy)
		{
		switch (f)
			{
			case 0:
				DBiMotionCopyY0000(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 1:
				temp = prevp; prevp = succp; succp = temp;
			case 2:
				DBiMotionCopyY0010(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 3:
				DBiMotionCopyY1010(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 4:
				temp = prevp; prevp = succp; succp = temp;
			case 8:
				DBiMotionCopyY0001(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 6:
				temp = prevp; prevp = succp; succp = temp;
			case 9:
				DBiMotionCopyY1001(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 5:
				temp = prevp; prevp = succp; succp = temp;
			case 10:
				DBiMotionCopyY0011(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 7:
				temp = prevp; prevp = succp; succp = temp;
			case 11:
				DBiMotionCopyY1011(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 12:
				DBiMotionCopyY0101(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 13:
				temp = prevp; prevp = succp; succp = temp;
			case 14:
				DBiMotionCopyY0111(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 15:
				DBiMotionCopyY1111(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			}
		}
	else
		{
		switch (f)
			{
			case 0:
				DBiMotionCompY0000(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 1:
				temp = prevp; prevp = succp; succp = temp;
			case 2:
				DBiMotionCompY0010(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 3:
				DBiMotionCompY1010(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 4:
				temp = prevp; prevp = succp; succp = temp;
			case 8:
				DBiMotionCompY0001(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 6:
				temp = prevp; prevp = succp; succp = temp;
			case 9:
				DBiMotionCompY1001(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 5:
				temp = prevp; prevp = succp; succp = temp;
			case 10:
				DBiMotionCompY0011(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 7:
				temp = prevp; prevp = succp; succp = temp;
			case 11:
				DBiMotionCompY1011(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 12:
				DBiMotionCompY0101(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 13:
				temp = prevp; prevp = succp; succp = temp;
			case 14:
				DBiMotionCompY0111(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 15:
				DBiMotionCompY1111(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			}
		}
	}

static __forceinline void SDBiMotionCopyY0000(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
loop1:
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDBiMotionCompY0000(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
loop1:
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDBiMotionCopyY0010(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
loop1:
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDBiMotionCompY0010(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
loop1:
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDBiMotionCopyY1010(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
loop1:
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDBiMotionCompY1010(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
loop1:
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDBiMotionCopyY0001(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	edx, [succp]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDBiMotionCompY0001(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	edx, [succp]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDBiMotionCopyY1001(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	edx, [succp]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm5, [edx + esi + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
//// pavgb	mm6, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x74
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm3, [edx + esi + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + esi + 0]
//// pavgb	mm4, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x64
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDBiMotionCompY1001(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	edx, [succp]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm5, [edx + esi + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
//// pavgb	mm6, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x74
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm3, [edx + esi + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + esi + 0]
//// pavgb	mm4, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x64
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDBiMotionCopyY0011(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	edx, [succp]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDBiMotionCompY0011(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	edx, [succp]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDBiMotionCopyY1011(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	edx, [succp]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
//// pavgb	mm6, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x74
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + esi + 0]
//// pavgb	mm4, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x64
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDBiMotionCompY1011(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	edx, [succp]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
//// pavgb	mm6, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x74
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + esi + 0]
//// pavgb	mm4, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x64
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDBiMotionCopyY0101(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	mov	[prevp], ecx
	mov	edx, [succp]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm4, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm1, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDBiMotionCompY0101(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	mov	[prevp], ecx
	mov	edx, [succp]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm4, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm1, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDBiMotionCopyY0111(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	mov	[prevp], ecx
	mov	edx, [succp]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm4, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm1, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDBiMotionCompY0111(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	mov	[prevp], ecx
	mov	edx, [succp]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm4, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm1, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDBiMotionCopyY1111(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	add	ecx, [sbpr]
	mov	[prevp], ecx
	mov	edx, [succp]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm4, [ecx + esi + 0]
//// pavgb	mm4, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x64
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + esi + 8]
//// pavgb	mm6, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x74
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDBiMotionCompY1111(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	ebx, [deltap]
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	add	ecx, [sbpr]
	mov	[prevp], ecx
	mov	edx, [succp]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm4, [ecx + esi + 0]
//// pavgb	mm4, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x64
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + esi + 8]
//// pavgb	mm6, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x74
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

void FastISSEMotionComp::SDBiMotionCompensationY(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	int f = ((ys & 1) << 3) | ((yp & 1) << 2) | ((xs & 1) << 1) | xp & 1;
	BYTE * temp;

	if (copy)
		{
		switch (f)
			{
			case 0:
				SDBiMotionCopyY0000(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 1:
				temp = prevp; prevp = succp; succp = temp;
			case 2:
				SDBiMotionCopyY0010(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 3:
				SDBiMotionCopyY1010(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 4:
				temp = prevp; prevp = succp; succp = temp;
			case 8:
				SDBiMotionCopyY0001(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 6:
				temp = prevp; prevp = succp; succp = temp;
			case 9:
				SDBiMotionCopyY1001(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 5:
				temp = prevp; prevp = succp; succp = temp;
			case 10:
				SDBiMotionCopyY0011(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 7:
				temp = prevp; prevp = succp; succp = temp;
			case 11:
				SDBiMotionCopyY1011(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 12:
				SDBiMotionCopyY0101(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 13:
				temp = prevp; prevp = succp; succp = temp;
			case 14:
				SDBiMotionCopyY0111(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 15:
				SDBiMotionCopyY1111(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			}
		}
	else
		{
		switch (f)
			{
			case 0:
				SDBiMotionCompY0000(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 1:
				temp = prevp; prevp = succp; succp = temp;
			case 2:
				SDBiMotionCompY0010(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 3:
				SDBiMotionCompY1010(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 4:
				temp = prevp; prevp = succp; succp = temp;
			case 8:
				SDBiMotionCompY0001(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 6:
				temp = prevp; prevp = succp; succp = temp;
			case 9:
				SDBiMotionCompY1001(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 5:
				temp = prevp; prevp = succp; succp = temp;
			case 10:
				SDBiMotionCompY0011(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 7:
				temp = prevp; prevp = succp; succp = temp;
			case 11:
				SDBiMotionCompY1011(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 12:
				SDBiMotionCompY0101(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 13:
				temp = prevp; prevp = succp; succp = temp;
			case 14:
				SDBiMotionCompY0111(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 15:
				SDBiMotionCompY1111(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			}
		}
	}

static __forceinline void IDBiMotionCopyY0000(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	sub	eax, [dbpr]
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDBiMotionCompY0000(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	sub	eax, [dbpr]
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDBiMotionCopyY0010(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	sub	eax, [dbpr]
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDBiMotionCompY0010(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	sub	eax, [dbpr]
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDBiMotionCopyY1010(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	sub	eax, [dbpr]
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDBiMotionCompY1010(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	sub	eax, [dbpr]
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDBiMotionCopyY0001(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [dbpr]
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDBiMotionCompY0001(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [dbpr]
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDBiMotionCopyY1001(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [dbpr]
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDBiMotionCompY1001(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [dbpr]
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDBiMotionCopyY0011(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [dbpr]
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDBiMotionCompY0011(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [dbpr]
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDBiMotionCopyY1011(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [dbpr]
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDBiMotionCompY1011(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [dbpr]
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDBiMotionCopyY0101(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [dbpr]
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDBiMotionCompY0101(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [dbpr]
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDBiMotionCopyY0111(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [dbpr]
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDBiMotionCompY0111(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [dbpr]
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm4, [ecx + 0]
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm1, [ecx + 8]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDBiMotionCopyY1111(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [dbpr]
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDBiMotionCompY1111(BYTE * prevp, BYTE * succp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	mov	edx, [succp]
	mov	esi, [sbpr]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	add	ecx, [sbpr]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
loop1:
	pxor	mm7, mm7
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [dbpr]
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm4, [ecx + 0]
//// pavgb	mm4, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x61
	_emit	0x01
////-------------
	movq	mm5, [edx + 0]
//// pavgb	mm5, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6a
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + 8]
//// pavgb	mm6, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x71
	_emit	0x09
////-------------
	movq	mm2, [edx + 8]
//// pavgb	mm2, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [dbpr]
	add	edi, [ifbdist]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	pxor	mm7, mm7
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	ecx, esi
	add	edx, esi
	add	ebx, [dbpr]
	add	eax, [dbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

void FastISSEMotionComp::IDBiMotionCompensationY(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	int f = ((ys & 1) << 3) | ((yp & 1) << 2) | ((xs & 1) << 1) | xp & 1;
	BYTE * temp;

	if (copy)
		{
		switch (f)
			{
			case 0:
				IDBiMotionCopyY0000(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 1:
				temp = prevp; prevp = succp; succp = temp;
			case 2:
				IDBiMotionCopyY0010(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 3:
				IDBiMotionCopyY1010(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 4:
				temp = prevp; prevp = succp; succp = temp;
			case 8:
				IDBiMotionCopyY0001(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 6:
				temp = prevp; prevp = succp; succp = temp;
			case 9:
				IDBiMotionCopyY1001(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 5:
				temp = prevp; prevp = succp; succp = temp;
			case 10:
				IDBiMotionCopyY0011(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 7:
				temp = prevp; prevp = succp; succp = temp;
			case 11:
				IDBiMotionCopyY1011(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 12:
				IDBiMotionCopyY0101(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 13:
				temp = prevp; prevp = succp; succp = temp;
			case 14:
				IDBiMotionCopyY0111(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 15:
				IDBiMotionCopyY1111(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			}
		}
	else
		{
		switch (f)
			{
			case 0:
				IDBiMotionCompY0000(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 1:
				temp = prevp; prevp = succp; succp = temp;
			case 2:
				IDBiMotionCompY0010(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 3:
				IDBiMotionCompY1010(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 4:
				temp = prevp; prevp = succp; succp = temp;
			case 8:
				IDBiMotionCompY0001(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 6:
				temp = prevp; prevp = succp; succp = temp;
			case 9:
				IDBiMotionCompY1001(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 5:
				temp = prevp; prevp = succp; succp = temp;
			case 10:
				IDBiMotionCompY0011(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 7:
				temp = prevp; prevp = succp; succp = temp;
			case 11:
				IDBiMotionCompY1011(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 12:
				IDBiMotionCompY0101(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 13:
				temp = prevp; prevp = succp; succp = temp;
			case 14:
				IDBiMotionCompY0111(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 15:
				IDBiMotionCompY1111(prevp, succp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			}
		}
	}

static __forceinline void ISDBiMotionCopyY0000(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
loop1:
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	sub	eax, [sbpr]
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDBiMotionCompY0000(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
loop1:
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	sub	eax, [sbpr]
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDBiMotionCopyY0010(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
loop1:
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	sub	eax, [sbpr]
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDBiMotionCompY0010(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
loop1:
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	sub	eax, [sbpr]
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDBiMotionCopyY1010(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
loop1:
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	sub	eax, [sbpr]
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDBiMotionCompY1010(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	pxor	mm7, mm7
loop1:
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	sub	eax, [sbpr]
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xca
////-------------
	movq	mm2, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm2, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm1, mm2
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm5, [eax]
	movq	mm3, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm3, mm5
	movq [edi], mm0
	movq [edi + 8], mm3
	movq	mm6, [eax + 8]
	movq	mm3, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm3, mm6
	movq [edi + 16], mm1
	movq [edi + 24], mm3
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDBiMotionCopyY0001(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	edx, [succp]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [sbpr]
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDBiMotionCompY0001(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	edx, [succp]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [sbpr]
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDBiMotionCopyY1001(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	edx, [succp]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm5, [edx + esi + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
//// pavgb	mm6, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x74
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm3, [edx + esi + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + esi + 0]
//// pavgb	mm4, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x64
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [sbpr]
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm5, [edx + esi + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
//// pavgb	mm6, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x74
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm3, [edx + esi + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + esi + 0]
//// pavgb	mm4, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x64
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDBiMotionCompY1001(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	edx, [succp]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm5, [edx + esi + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
//// pavgb	mm6, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x74
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm3, [edx + esi + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + esi + 0]
//// pavgb	mm4, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x64
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [sbpr]
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm5, [edx + esi + 0]
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
//// pavgb	mm6, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x74
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm3, [edx + esi + 8]
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + esi + 0]
//// pavgb	mm4, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x64
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDBiMotionCopyY0011(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	edx, [succp]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [sbpr]
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDBiMotionCompY0011(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	edx, [succp]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [sbpr]
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDBiMotionCopyY1011(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	edx, [succp]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
//// pavgb	mm6, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x74
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + esi + 0]
//// pavgb	mm4, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x64
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [sbpr]
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
//// pavgb	mm6, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x74
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm4, [ecx + esi + 0]
//// pavgb	mm4, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x64
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDBiMotionCompY1011(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	edx, [succp]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
//// pavgb	mm6, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x74
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + esi + 0]
//// pavgb	mm4, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x64
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [sbpr]
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm6, [ecx + esi + 8]
//// pavgb	mm6, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x74
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm4, [ecx + esi + 0]
//// pavgb	mm4, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x64
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDBiMotionCopyY0101(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	mov	[prevp], ecx
	mov	edx, [succp]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm4, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm1, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [sbpr]
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm4, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm1, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDBiMotionCompY0101(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	mov	[prevp], ecx
	mov	edx, [succp]
	movq	mm3, [edx + 8]
	movq	mm2, [edx + 0]
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm4, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm1, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [sbpr]
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm4, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm1, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDBiMotionCopyY0111(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	mov	[prevp], ecx
	mov	edx, [succp]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm4, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm1, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [sbpr]
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm4, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm1, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDBiMotionCompY0111(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	movq	mm1, [ecx + 8]
	movq	mm0, [ecx + 0]
	add	ecx, [sbpr]
	mov	[prevp], ecx
	mov	edx, [succp]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm4, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm1, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [sbpr]
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm4, [ecx + esi + 0]
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + esi + 8]
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm1, [ecx + esi + 8]
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + esi + 0]
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDBiMotionCopyY1111(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	add	ecx, [sbpr]
	mov	[prevp], ecx
	mov	edx, [succp]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm4, [ecx + esi + 0]
//// pavgb	mm4, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x64
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + esi + 8]
//// pavgb	mm6, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x74
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [sbpr]
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm4, [ecx + esi + 0]
//// pavgb	mm4, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x64
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm6, [ecx + esi + 8]
//// pavgb	mm6, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x74
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDBiMotionCompY1111(BYTE * prevp, BYTE * succp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	ebx, [deltap]
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	esi, 0
	mov	eax, [uvdp]
	mov	edi, [fbp]
	mov	ecx, [prevp]
	movq	mm1, [ecx + 8]
//// pavgb	mm1, [ecx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x49
	_emit	0x09
////-------------
	movq	mm0, [ecx + 0]
//// pavgb	mm0, [ecx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x41
	_emit	0x01
////-------------
	add	ecx, [sbpr]
	mov	[prevp], ecx
	mov	edx, [succp]
	movq	mm3, [edx + 8]
//// pavgb	mm3, [edx + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5a
	_emit	0x09
////-------------
	movq	mm2, [edx + 0]
//// pavgb	mm2, [edx + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x52
	_emit	0x01
////-------------
	add	edx, [sbpr]
	mov	[succp], edx
loop1:
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm4, [ecx + esi + 0]
//// pavgb	mm4, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x64
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + esi + 8]
//// pavgb	mm6, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x74
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	sub	eax, [sbpr]
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm4, [ecx + esi + 0]
//// pavgb	mm4, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x64
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm5, [edx + esi + 0]
//// pavgb	mm5, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x6c
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm0, mm4
	_emit	0x0f
	_emit	0xe0
	_emit	0xc4
////-------------
//// pavgb	mm2, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xd5
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm2, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm2, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm2, [ebx + 8 + 0]
	packuswb	mm0, mm2
	movq	mm6, [ecx + esi + 8]
//// pavgb	mm6, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x74
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm2, [edx + esi + 8]
//// pavgb	mm2, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm1, mm6
	_emit	0x0f
	_emit	0xe0
	_emit	0xce
////-------------
//// pavgb	mm3, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xda
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	movq	mm3, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm3, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm3, [ebx + 8 + 16]
	packuswb	mm1, mm3
	mov	edx, [destp]
	movq	[edx + esi], mm0
	movq	[edx + esi + 8], mm1
	movq	mm3, [eax]
	movq	mm7, mm0
	punpcklbw	mm0, mm3
	punpckhbw	mm7, mm3
	movq [edi], mm0
	movq [edi + 8], mm7
	movq	mm3, [eax + 8]
	movq	mm7, mm1
	punpcklbw	mm1, mm3
	punpckhbw	mm7, mm3
	movq [edi + 16], mm1
	movq [edi + 24], mm7
	add	eax, [sbpr]
	add	edi, [ifbdist]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	pxor	mm7, mm7
	mov	ecx, [prevp]
	mov	edx, [succp]
	movq	mm1, [ecx + esi + 8]
//// pavgb	mm1, [ecx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x4c
	_emit	0x31
	_emit	0x09
////-------------
	movq	mm3, [edx + esi + 8]
//// pavgb	mm3, [edx + esi + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x5c
	_emit	0x32
	_emit	0x09
////-------------
//// pavgb	mm6, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xf1
////-------------
//// pavgb	mm2, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xd3
////-------------
//// pavgb	mm6, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xf2
////-------------
	movq	mm2, mm6
	punpcklbw	mm6, mm7
	punpckhbw	mm2, mm7
	paddw	mm6, [ebx + 16]
	paddw	mm2, [ebx + 8 + 16]
	packuswb	mm6, mm2
	movq	mm0, [ecx + esi + 0]
//// pavgb	mm0, [ecx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x44
	_emit	0x31
	_emit	0x01
////-------------
	movq	mm2, [edx + esi + 0]
//// pavgb	mm2, [edx + esi + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x54
	_emit	0x32
	_emit	0x01
////-------------
//// pavgb	mm4, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xe0
////-------------
//// pavgb	mm5, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xea
////-------------
//// pavgb	mm4, mm5
	_emit	0x0f
	_emit	0xe0
	_emit	0xe5
////-------------
	movq	mm5, mm4
	punpcklbw	mm4, mm7
	punpckhbw	mm5, mm7
	paddw	mm4, [ebx + 0]
	paddw	mm5, [ebx + 8 + 0]
	packuswb	mm4, mm5
	mov	edx, [destp]
	movq	[edx + esi], mm4
	movq	[edx + esi + 8], mm6
	movq	mm5, [eax]
	movq	mm7, mm4
	punpcklbw	mm4, mm5
	punpckhbw	mm7, mm5
	movq [edi], mm4
	movq [edi + 8], mm7
	movq	mm5, [eax + 8]
	movq	mm7, mm6
	punpcklbw	mm6, mm5
	punpckhbw	mm7, mm5
	movq [edi + 16], mm6
	movq [edi + 24], mm7
	add	edi, [fbbpr]
	add	esi, [sbpr]
	add	ebx, [dbpr]
	add	eax, [sbpr]
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

void FastISSEMotionComp::ISDBiMotionCompensationY(int yp, int xp, int ys, int xs, BYTE * prevp, BYTE * succp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	int f = ((ys & 1) << 3) | ((yp & 1) << 2) | ((xs & 1) << 1) | xp & 1;
	BYTE * temp;

	if (copy)
		{
		switch (f)
			{
			case 0:
				ISDBiMotionCopyY0000(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 1:
				temp = prevp; prevp = succp; succp = temp;
			case 2:
				ISDBiMotionCopyY0010(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 3:
				ISDBiMotionCopyY1010(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 4:
				temp = prevp; prevp = succp; succp = temp;
			case 8:
				ISDBiMotionCopyY0001(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 6:
				temp = prevp; prevp = succp; succp = temp;
			case 9:
				ISDBiMotionCopyY1001(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 5:
				temp = prevp; prevp = succp; succp = temp;
			case 10:
				ISDBiMotionCopyY0011(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 7:
				temp = prevp; prevp = succp; succp = temp;
			case 11:
				ISDBiMotionCopyY1011(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 12:
				ISDBiMotionCopyY0101(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 13:
				temp = prevp; prevp = succp; succp = temp;
			case 14:
				ISDBiMotionCopyY0111(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 15:
				ISDBiMotionCopyY1111(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			}
		}
	else
		{
		switch (f)
			{
			case 0:
				ISDBiMotionCompY0000(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 1:
				temp = prevp; prevp = succp; succp = temp;
			case 2:
				ISDBiMotionCompY0010(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 3:
				ISDBiMotionCompY1010(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 4:
				temp = prevp; prevp = succp; succp = temp;
			case 8:
				ISDBiMotionCompY0001(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 6:
				temp = prevp; prevp = succp; succp = temp;
			case 9:
				ISDBiMotionCompY1001(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 5:
				temp = prevp; prevp = succp; succp = temp;
			case 10:
				ISDBiMotionCompY0011(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 7:
				temp = prevp; prevp = succp; succp = temp;
			case 11:
				ISDBiMotionCompY1011(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 12:
				ISDBiMotionCompY0101(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 13:
				temp = prevp; prevp = succp; succp = temp;
			case 14:
				ISDBiMotionCompY0111(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 15:
				ISDBiMotionCompY1111(prevp, succp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			}
		}
	}

static __forceinline void MotionCopyUV00(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
	movq	mm1, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ebx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void MotionCompUV00(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 0]
	movq	mm6, [ebx + 16 + 0]
	punpcklwd	mm5, mm6
	paddw	mm0, mm5
	movq	mm5, [ebx + 0]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm0, mm4
	movq	mm1, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 8]
	movq	mm6, [ebx + 16 + 8]
	punpcklwd	mm5, mm6
	paddw	mm1, mm5
	movq	mm5, [ebx + 8]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm1, mm4
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ebx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void MotionCopyUV10(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x02
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x0a
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ebx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void MotionCompUV10(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x02
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 0]
	movq	mm6, [ebx + 16 + 0]
	punpcklwd	mm5, mm6
	paddw	mm0, mm5
	movq	mm5, [ebx + 0]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm0, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x0a
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 8]
	movq	mm6, [ebx + 16 + 8]
	punpcklwd	mm5, mm6
	paddw	mm1, mm5
	movq	mm5, [ebx + 8]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm1, mm4
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ebx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void MotionCopyUV01(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	movq	mm0, [eax]
	movq	mm1, [eax+8]
	add	eax, [sbpr]
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ebx, edi
	movq	mm0, [eax + 0]
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	[ebx], mm2
	movq	[ebx + 8], mm3
	add	ebx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void MotionCompUV01(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	movq	mm0, [eax]
	movq	mm1, [eax+8]
	add	eax, [sbpr]
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 0]
	movq	mm6, [ebx + 16 + 0]
	punpcklwd	mm5, mm6
	paddw	mm0, mm5
	movq	mm5, [ebx + 0]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm0, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 8]
	movq	mm6, [ebx + 16 + 8]
	punpcklwd	mm5, mm6
	paddw	mm1, mm5
	movq	mm5, [ebx + 8]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm1, mm4
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ebx, edi
	movq	mm0, [eax + 0]
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 0]
	movq	mm6, [ebx + 16 + 0]
	punpcklwd	mm5, mm6
	paddw	mm2, mm5
	movq	mm5, [ebx + 0]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm2, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 8]
	movq	mm6, [ebx + 16 + 8]
	punpcklwd	mm5, mm6
	paddw	mm3, mm5
	movq	mm5, [ebx + 8]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm3, mm4
	movq	[ebx], mm2
	movq	[ebx + 8], mm3
	add	ebx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void MotionCopyUV11(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	movq	mm0, [eax]
//// pavgb	mm0, [eax + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x02
////-------------
	movq	mm1, [eax+8]
//// pavgb	mm1, [eax+8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x0a
////-------------
	add	eax, [sbpr]
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x02
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x0a
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ebx, edi
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x02
////-------------
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x0a
////-------------
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	[ebx], mm2
	movq	[ebx + 8], mm3
	add	ebx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void MotionCompUV11(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	movq	mm0, [eax]
//// pavgb	mm0, [eax + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x02
////-------------
	movq	mm1, [eax+8]
//// pavgb	mm1, [eax+8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x0a
////-------------
	add	eax, [sbpr]
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x02
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 0]
	movq	mm6, [ebx + 16 + 0]
	punpcklwd	mm5, mm6
	paddw	mm0, mm5
	movq	mm5, [ebx + 0]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm0, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x0a
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 8]
	movq	mm6, [ebx + 16 + 8]
	punpcklwd	mm5, mm6
	paddw	mm1, mm5
	movq	mm5, [ebx + 8]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm1, mm4
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ebx, edi
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x02
////-------------
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 0]
	movq	mm6, [ebx + 16 + 0]
	punpcklwd	mm5, mm6
	paddw	mm2, mm5
	movq	mm5, [ebx + 0]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm2, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x0a
////-------------
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 8]
	movq	mm6, [ebx + 16 + 8]
	punpcklwd	mm5, mm6
	paddw	mm3, mm5
	movq	mm5, [ebx + 8]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm3, mm4
	movq	[ebx], mm2
	movq	[ebx + 8], mm3
	add	ebx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

void FastISSEMotionComp::MotionCompensationUV(int yp, int xp, BYTE * prevp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal)
	{
	int f = ((yp & 1) << 1) | xp & 1;

	if (copy)
		{
		switch (f)
			{
			case 0:
				MotionCopyUV00(prevp, sbpr, deltap, dbpr, dfinal);
				break;
			case 1:
				MotionCopyUV10(prevp, sbpr, deltap, dbpr, dfinal);
				break;
			case 2:
				MotionCopyUV01(prevp, sbpr, deltap, dbpr, dfinal);
				break;
			case 3:
				MotionCopyUV11(prevp, sbpr, deltap, dbpr, dfinal);
				break;
			}
		}
	else
		{
		switch (f)
			{
			case 0:
				MotionCompUV00(prevp, sbpr, deltap, dbpr, dfinal);
				break;
			case 1:
				MotionCompUV10(prevp, sbpr, deltap, dbpr, dfinal);
				break;
			case 2:
				MotionCompUV01(prevp, sbpr, deltap, dbpr, dfinal);
				break;
			case 3:
				MotionCompUV11(prevp, sbpr, deltap, dbpr, dfinal);
				break;
			}
		}
	}

static __forceinline void SMotionCopyUV00(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
	movq	mm1, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SMotionCompUV00(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 0]
	movq	mm6, [ebx + 16 + 0]
	punpcklwd	mm5, mm6
	paddw	mm0, mm5
	movq	mm5, [ebx + 0]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm0, mm4
	movq	mm1, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 8]
	movq	mm6, [ebx + 16 + 8]
	punpcklwd	mm5, mm6
	paddw	mm1, mm5
	movq	mm5, [ebx + 8]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm1, mm4
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SMotionCopyUV10(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x02
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x0a
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SMotionCompUV10(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x02
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 0]
	movq	mm6, [ebx + 16 + 0]
	punpcklwd	mm5, mm6
	paddw	mm0, mm5
	movq	mm5, [ebx + 0]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm0, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x0a
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 8]
	movq	mm6, [ebx + 16 + 8]
	punpcklwd	mm5, mm6
	paddw	mm1, mm5
	movq	mm5, [ebx + 8]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm1, mm4
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SMotionCopyUV01(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	movq	mm0, [eax]
	movq	mm1, [eax+8]
	add	eax, [sbpr]
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm0, [eax + 0]
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SMotionCompUV01(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	movq	mm0, [eax]
	movq	mm1, [eax+8]
	add	eax, [sbpr]
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 0]
	movq	mm6, [ebx + 16 + 0]
	punpcklwd	mm5, mm6
	paddw	mm0, mm5
	movq	mm5, [ebx + 0]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm0, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 8]
	movq	mm6, [ebx + 16 + 8]
	punpcklwd	mm5, mm6
	paddw	mm1, mm5
	movq	mm5, [ebx + 8]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm1, mm4
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm0, [eax + 0]
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 0]
	movq	mm6, [ebx + 16 + 0]
	punpcklwd	mm5, mm6
	paddw	mm2, mm5
	movq	mm5, [ebx + 0]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm2, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 8]
	movq	mm6, [ebx + 16 + 8]
	punpcklwd	mm5, mm6
	paddw	mm3, mm5
	movq	mm5, [ebx + 8]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm3, mm4
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SMotionCopyUV11(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	movq	mm0, [eax]
//// pavgb	mm0, [eax + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x02
////-------------
	movq	mm1, [eax+8]
//// pavgb	mm1, [eax+8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x0a
////-------------
	add	eax, [sbpr]
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x02
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x0a
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x02
////-------------
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x0a
////-------------
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SMotionCompUV11(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	movq	mm0, [eax]
//// pavgb	mm0, [eax + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x02
////-------------
	movq	mm1, [eax+8]
//// pavgb	mm1, [eax+8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x0a
////-------------
	add	eax, [sbpr]
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x02
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 0]
	movq	mm6, [ebx + 16 + 0]
	punpcklwd	mm5, mm6
	paddw	mm0, mm5
	movq	mm5, [ebx + 0]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm0, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x0a
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 8]
	movq	mm6, [ebx + 16 + 8]
	punpcklwd	mm5, mm6
	paddw	mm1, mm5
	movq	mm5, [ebx + 8]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm1, mm4
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x02
////-------------
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 0]
	movq	mm6, [ebx + 16 + 0]
	punpcklwd	mm5, mm6
	paddw	mm2, mm5
	movq	mm5, [ebx + 0]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm2, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 2]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x0a
////-------------
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	movq	mm5, [ebx + 8]
	movq	mm6, [ebx + 16 + 8]
	punpcklwd	mm5, mm6
	paddw	mm3, mm5
	movq	mm5, [ebx + 8]
	punpckhwd	mm5, mm6
	paddw	mm4, mm5
	packuswb	mm3, mm4
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

void FastISSEMotionComp::SMotionCompensationUV(int yp, int xp, BYTE * prevp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	int f = ((yp & 1) << 1) | xp & 1;

	if (copy)
		{
		switch (f)
			{
			case 0:
				SMotionCopyUV00(prevp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 1:
				SMotionCopyUV10(prevp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 2:
				SMotionCopyUV01(prevp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 3:
				SMotionCopyUV11(prevp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			}
		}
	else
		{
		switch (f)
			{
			case 0:
				SMotionCompUV00(prevp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 1:
				SMotionCompUV10(prevp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 2:
				SMotionCompUV01(prevp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 3:
				SMotionCompUV11(prevp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			}
		}
	}

static __forceinline void MotionCopyY00(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
	movq	mm1, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ebx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void MotionCompY00(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm1, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ebx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void MotionCopyY10(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ebx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void MotionCompY10(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ebx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void MotionCopyY01(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	movq	mm0, [eax]
	movq	mm1, [eax+8]
	add	eax, [sbpr]
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ebx, edi
	movq	mm0, [eax + 0]
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	[ebx], mm2
	movq	[ebx + 8], mm3
	add	ebx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void MotionCompY01(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	movq	mm0, [eax]
	movq	mm1, [eax+8]
	add	eax, [sbpr]
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ebx, edi
	movq	mm0, [eax + 0]
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	movq	[ebx], mm2
	movq	[ebx + 8], mm3
	add	ebx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void MotionCopyY11(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	movq	mm0, [eax]
//// pavgb	mm0, [eax + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm1, [eax+8]
//// pavgb	mm1, [eax+8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, [sbpr]
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ebx, edi
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	[ebx], mm2
	movq	[ebx + 8], mm3
	add	ebx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void MotionCompY11(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	movq	mm0, [eax]
//// pavgb	mm0, [eax + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm1, [eax+8]
//// pavgb	mm1, [eax+8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, [sbpr]
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	movq	[ebx], mm0
	movq	[ebx + 8], mm1
	add	ebx, edi
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	movq	[ebx], mm2
	movq	[ebx + 8], mm3
	add	ebx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

void FastISSEMotionComp::MotionCompensationY(int yp, int xp, BYTE * prevp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal)
	{
	int f = ((yp & 1) << 1) | xp & 1;

	if (copy)
		{
		switch (f)
			{
			case 0:
				MotionCopyY00(prevp, sbpr, deltap, dbpr, dfinal);
				break;
			case 1:
				MotionCopyY10(prevp, sbpr, deltap, dbpr, dfinal);
				break;
			case 2:
				MotionCopyY01(prevp, sbpr, deltap, dbpr, dfinal);
				break;
			case 3:
				MotionCopyY11(prevp, sbpr, deltap, dbpr, dfinal);
				break;
			}
		}
	else
		{
		switch (f)
			{
			case 0:
				MotionCompY00(prevp, sbpr, deltap, dbpr, dfinal);
				break;
			case 1:
				MotionCompY10(prevp, sbpr, deltap, dbpr, dfinal);
				break;
			case 2:
				MotionCompY01(prevp, sbpr, deltap, dbpr, dfinal);
				break;
			case 3:
				MotionCompY11(prevp, sbpr, deltap, dbpr, dfinal);
				break;
			}
		}
	}

static __forceinline void SMotionCopyY00(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
	movq	mm1, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SMotionCompY00(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm1, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SMotionCopyY10(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SMotionCompY10(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SMotionCopyY01(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	movq	mm0, [eax]
	movq	mm1, [eax+8]
	add	eax, [sbpr]
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm0, [eax + 0]
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SMotionCompY01(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	movq	mm0, [eax]
	movq	mm1, [eax+8]
	add	eax, [sbpr]
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm0, [eax + 0]
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SMotionCopyY11(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	movq	mm0, [eax]
//// pavgb	mm0, [eax + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm1, [eax+8]
//// pavgb	mm1, [eax+8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, [sbpr]
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SMotionCompY11(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	pxor	mm7, mm7
	movq	mm0, [eax]
//// pavgb	mm0, [eax + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm1, [eax+8]
//// pavgb	mm1, [eax+8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, [sbpr]
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

void FastISSEMotionComp::SMotionCompensationY(int yp, int xp, BYTE * prevp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal)
	{
	int f = ((yp & 1) << 1) | xp & 1;

	if (copy)
		{
		switch (f)
			{
			case 0:
				SMotionCopyY00(prevp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 1:
				SMotionCopyY10(prevp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 2:
				SMotionCopyY01(prevp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 3:
				SMotionCopyY11(prevp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			}
		}
	else
		{
		switch (f)
			{
			case 0:
				SMotionCompY00(prevp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 1:
				SMotionCompY10(prevp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 2:
				SMotionCompY01(prevp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			case 3:
				SMotionCompY11(prevp, sbpr, destp, deltap, dbpr, dfinal);
				break;
			}
		}
	}

static __forceinline void DMotionCopyY00(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
	movq	mm1, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	movq	mm2, [eax + 0]
	movq	mm3, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DMotionCompY00(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm1, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	movq	mm2, [eax + 0]
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm3, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, edi
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DMotionCopyY10(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DMotionCompY10(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, edi
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DMotionCopyY01(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	movq	mm0, [eax]
	movq	mm1, [eax+8]
	add	eax, [sbpr]
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	movq	mm0, [eax + 0]
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DMotionCompY01(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	movq	mm0, [eax]
	movq	mm1, [eax+8]
	add	eax, [sbpr]
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	movq	mm0, [eax + 0]
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, edi
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DMotionCopyY11(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	movq	mm0, [eax]
//// pavgb	mm0, [eax + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm1, [eax+8]
//// pavgb	mm1, [eax+8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, [sbpr]
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void DMotionCompY11(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	movq	mm0, [eax]
//// pavgb	mm0, [eax + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm1, [eax+8]
//// pavgb	mm1, [eax+8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, [sbpr]
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, edi
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

void FastISSEMotionComp::DMotionCompensationY(int yp, int xp, BYTE * prevp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	int f = ((yp & 1) << 1) | xp & 1;

	if (copy)
		{
		switch (f)
			{
			case 0:
				DMotionCopyY00(prevp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 1:
				DMotionCopyY10(prevp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 2:
				DMotionCopyY01(prevp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 3:
				DMotionCopyY11(prevp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			}
		}
	else
		{
		switch (f)
			{
			case 0:
				DMotionCompY00(prevp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 1:
				DMotionCompY10(prevp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 2:
				DMotionCompY01(prevp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 3:
				DMotionCompY11(prevp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			}
		}
	}

static __forceinline void SDMotionCopyY00(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
	movq	mm1, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	movq	mm2, [eax + 0]
	movq	mm3, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDMotionCompY00(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm1, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	movq	mm2, [eax + 0]
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm3, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDMotionCopyY10(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDMotionCompY10(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDMotionCopyY01(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	movq	mm0, [eax]
	movq	mm1, [eax+8]
	add	eax, [sbpr]
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	movq	mm0, [eax + 0]
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDMotionCompY01(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	movq	mm0, [eax]
	movq	mm1, [eax+8]
	add	eax, [sbpr]
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	movq	mm0, [eax + 0]
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDMotionCopyY11(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	movq	mm0, [eax]
//// pavgb	mm0, [eax + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm1, [eax+8]
//// pavgb	mm1, [eax+8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, [sbpr]
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void SDMotionCompY11(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	movq	mm0, [eax]
//// pavgb	mm0, [eax + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm1, [eax+8]
//// pavgb	mm1, [eax+8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, [sbpr]
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

void FastISSEMotionComp::SDMotionCompensationY(int yp, int xp, BYTE * prevp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr)
	{
	int f = ((yp & 1) << 1) | xp & 1;

	if (copy)
		{
		switch (f)
			{
			case 0:
				SDMotionCopyY00(prevp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 1:
				SDMotionCopyY10(prevp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 2:
				SDMotionCopyY01(prevp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 3:
				SDMotionCopyY11(prevp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			}
		}
	else
		{
		switch (f)
			{
			case 0:
				SDMotionCompY00(prevp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 1:
				SDMotionCompY10(prevp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 2:
				SDMotionCompY01(prevp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			case 3:
				SDMotionCompY11(prevp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr);
				break;
			}
		}
	}

static __forceinline void IDMotionCopyY00(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
	movq	mm1, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [ifbdist]
	add	ecx, edi
	movq	mm2, [eax + 0]
	movq	mm3, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	sub	ecx, edi
	movq	mm0, [eax + 0]
	movq	mm1, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	ecx, edi
	add	edx, [ifbdist]
	movq	mm2, [eax + 0]
	movq	mm3, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDMotionCompY00(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm1, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [ifbdist]
	add	ecx, edi
	movq	mm2, [eax + 0]
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm3, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	sub	ecx, edi
	movq	mm0, [eax + 0]
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm1, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	ecx, edi
	add	edx, [ifbdist]
	movq	mm2, [eax + 0]
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm3, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDMotionCopyY10(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [ifbdist]
	add	ecx, edi
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	sub	ecx, edi
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	ecx, edi
	add	edx, [ifbdist]
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDMotionCompY10(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [ifbdist]
	add	ecx, edi
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	sub	ecx, edi
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	ecx, edi
	add	edx, [ifbdist]
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDMotionCopyY01(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	movq	mm0, [eax]
	movq	mm1, [eax+8]
	add	eax, [sbpr]
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [ifbdist]
	add	ecx, edi
	movq	mm0, [eax + 0]
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	sub	ecx, edi
	movq	mm2, [eax + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	ecx, edi
	add	edx, [ifbdist]
	movq	mm0, [eax + 0]
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDMotionCompY01(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	movq	mm0, [eax]
	movq	mm1, [eax+8]
	add	eax, [sbpr]
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [ifbdist]
	add	ecx, edi
	movq	mm0, [eax + 0]
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	sub	ecx, edi
	movq	mm2, [eax + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	ecx, edi
	add	edx, [ifbdist]
	movq	mm0, [eax + 0]
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDMotionCopyY11(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	movq	mm0, [eax]
//// pavgb	mm0, [eax + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm1, [eax+8]
//// pavgb	mm1, [eax+8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, [sbpr]
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [ifbdist]
	add	ecx, edi
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	sub	ecx, edi
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	ecx, edi
	add	edx, [ifbdist]
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void IDMotionCompY11(BYTE * prevp, int sbpr, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	movq	mm0, [eax]
//// pavgb	mm0, [eax + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm1, [eax+8]
//// pavgb	mm1, [eax+8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, [sbpr]
	mov	edi, [dbpr]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [ifbdist]
	add	ecx, edi
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	sub	ecx, edi
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	ecx, edi
	add	edx, [ifbdist]
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, edi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, edi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

void FastISSEMotionComp::IDMotionCompensationY(int yp, int xp, BYTE * prevp, int sbpr, bool copy, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	int f = ((yp & 1) << 1) | xp & 1;

	if (copy)
		{
		switch (f)
			{
			case 0:
				IDMotionCopyY00(prevp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 1:
				IDMotionCopyY10(prevp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 2:
				IDMotionCopyY01(prevp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 3:
				IDMotionCopyY11(prevp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			}
		}
	else
		{
		switch (f)
			{
			case 0:
				IDMotionCompY00(prevp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 1:
				IDMotionCompY10(prevp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 2:
				IDMotionCompY01(prevp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 3:
				IDMotionCompY11(prevp, sbpr, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			}
		}
	}

static __forceinline void ISDMotionCopyY00(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
	movq	mm1, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [ifbdist]
	add	ecx, esi
	movq	mm2, [eax + 0]
	movq	mm3, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	sub	ecx, esi
	movq	mm0, [eax + 0]
	movq	mm1, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	ecx, esi
	add	edx, [ifbdist]
	movq	mm2, [eax + 0]
	movq	mm3, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDMotionCompY00(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm1, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [ifbdist]
	add	ecx, esi
	movq	mm2, [eax + 0]
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm3, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	sub	ecx, esi
	movq	mm0, [eax + 0]
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm1, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	ecx, esi
	add	edx, [ifbdist]
	movq	mm2, [eax + 0]
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm3, [eax + 8]
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDMotionCopyY10(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [ifbdist]
	add	ecx, esi
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	sub	ecx, esi
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	ecx, esi
	add	edx, [ifbdist]
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDMotionCompY10(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [ifbdist]
	add	ecx, esi
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	sub	ecx, esi
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	ecx, esi
	add	edx, [ifbdist]
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDMotionCopyY01(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	movq	mm0, [eax]
	movq	mm1, [eax+8]
	add	eax, [sbpr]
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [ifbdist]
	add	ecx, esi
	movq	mm0, [eax + 0]
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	sub	ecx, esi
	movq	mm2, [eax + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	ecx, esi
	add	edx, [ifbdist]
	movq	mm0, [eax + 0]
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDMotionCompY01(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	movq	mm0, [eax]
	movq	mm1, [eax+8]
	add	eax, [sbpr]
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [ifbdist]
	add	ecx, esi
	movq	mm0, [eax + 0]
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	sub	ecx, esi
	movq	mm2, [eax + 0]
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	ecx, esi
	add	edx, [ifbdist]
	movq	mm0, [eax + 0]
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDMotionCopyY11(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	movq	mm0, [eax]
//// pavgb	mm0, [eax + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm1, [eax+8]
//// pavgb	mm1, [eax+8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, [sbpr]
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [ifbdist]
	add	ecx, esi
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	sub	ecx, esi
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	ecx, esi
	add	edx, [ifbdist]
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

static __forceinline void ISDMotionCompY11(BYTE * prevp, int sbpr, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	__asm {
	mov	eax, [prevp]
	mov	ebx, [deltap]
	mov	ecx, [uvdp]
	mov	edx, [fbp]
	pxor	mm7, mm7
	mov esi, [fbbpr]
	sub esi, [ifbdist]
	mov [fbbpr], esi
	movq	mm0, [eax]
//// pavgb	mm0, [eax + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
	movq	mm1, [eax+8]
//// pavgb	mm1, [eax+8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
	add	eax, [sbpr]
	mov	edi, [destp]
	mov	esi, [sbpr]
loop1:
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	edx, [ifbdist]
	add	ecx, esi
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	sub	ecx, esi
	movq	mm2, [eax + 0]
//// pavgb	mm2, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x50
	_emit	0x01
////-------------
//// pavgb	mm0, mm2
	_emit	0x0f
	_emit	0xe0
	_emit	0xc2
////-------------
	movq	mm4, mm0
	punpcklbw	mm0, mm7
	punpckhbw	mm4, mm7
	paddw	mm0, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm0, mm4
	movq	mm3, [eax + 8]
//// pavgb	mm3, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x58
	_emit	0x09
////-------------
//// pavgb	mm1, mm3
	_emit	0x0f
	_emit	0xe0
	_emit	0xcb
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm1
	punpcklbw	mm1, mm7
	punpckhbw	mm4, mm7
	paddw	mm1, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm1, mm4
	add	ebx, [dbpr]
	movq	[edi], mm0
	movq	[edi + 8], mm1
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm0
	punpcklbw	mm0, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm0
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm1
	punpcklbw	mm1, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm1
	movq [edx + 24], mm4
	add	ecx, esi
	add	edx, [ifbdist]
	movq	mm0, [eax + 0]
//// pavgb	mm0, [eax + 0 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x40
	_emit	0x01
////-------------
//// pavgb	mm2, mm0
	_emit	0x0f
	_emit	0xe0
	_emit	0xd0
////-------------
	movq	mm4, mm2
	punpcklbw	mm2, mm7
	punpckhbw	mm4, mm7
	paddw	mm2, [ebx + 0]
	paddw	mm4, [ebx + 8 + 0]
	packuswb	mm2, mm4
	movq	mm1, [eax + 8]
//// pavgb	mm1, [eax + 8 + 1]
	_emit	0x0f
	_emit	0xe0
	_emit	0x48
	_emit	0x09
////-------------
//// pavgb	mm3, mm1
	_emit	0x0f
	_emit	0xe0
	_emit	0xd9
////-------------
	add	eax, esi
//// prefetch	[eax]
	_emit	0x0f
	_emit	0x18
	_emit	0x08
////-------------
	movq	mm4, mm3
	punpcklbw	mm3, mm7
	punpckhbw	mm4, mm7
	paddw	mm3, [ebx + 16]
	paddw	mm4, [ebx + 8 + 16]
	packuswb	mm3, mm4
	add	ebx, [dbpr]
	movq	[edi], mm2
	movq	[edi + 8], mm3
	add	edi, esi
	movq	mm5, [ecx]
	movq	mm4, mm2
	punpcklbw	mm2, mm5
	punpckhbw	mm4, mm5
	movq [edx], mm2
	movq [edx + 8], mm4
	movq	mm6, [ecx + 8]
	movq	mm4, mm3
	punpcklbw	mm3, mm6
	punpckhbw	mm4, mm6
	movq [edx + 16], mm3
	movq [edx + 24], mm4
	add	edx, [fbbpr]
	add	ecx, esi
	cmp	ebx, [dfinal]
	jne	loop1
	}
	}

void FastISSEMotionComp::ISDMotionCompensationY(int yp, int xp, BYTE * prevp, int sbpr, bool copy, BYTE * destp, short * deltap, int dbpr, short * dfinal, BYTE * uvdp, BYTE * fbp, int fbbpr, int ifbdist)
	{
	int f = ((yp & 1) << 1) | xp & 1;

	if (copy)
		{
		switch (f)
			{
			case 0:
				ISDMotionCopyY00(prevp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 1:
				ISDMotionCopyY10(prevp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 2:
				ISDMotionCopyY01(prevp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 3:
				ISDMotionCopyY11(prevp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			}
		}
	else
		{
		switch (f)
			{
			case 0:
				ISDMotionCompY00(prevp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 1:
				ISDMotionCompY10(prevp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 2:
				ISDMotionCompY01(prevp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			case 3:
				ISDMotionCompY11(prevp, sbpr, destp, deltap, dbpr, dfinal, uvdp, fbp, fbbpr, ifbdist);
				break;
			}
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\SliceParser.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#include <stdio.h>
#include <stdlib.h>
#include "SliceParser.h"
#include "MP2HuffTables.h"
#include <memory.h>
#include "MPEGStatistics.h"
#include "library\common\vddebug.h"

#define DUMP_MOTION_VECTORS	0

#if DUMP_MOTION_VECTORS
#include <stdio.h>
static FILE * mfile;
static int frameCount;
int vectorSumX[256], vectorSumY[256];
int vectorTotal;
#endif

static const int ScanTable[2][8][8] =
	{{{  0,  1,  5,  6, 14, 15, 27, 28},
	  {  2,  4,  7, 13, 16, 26, 29, 42},
	  {  3,  8, 12, 17, 25, 30, 41, 43},
	  {  9, 11, 18, 24, 31, 40, 44, 53},
	  { 10, 19, 23, 32, 39, 45, 52, 54},
	  { 20, 22, 33, 38, 46, 51, 55, 60},
	  { 21, 34, 37, 47, 50, 56, 59, 61},
	  { 35, 36, 48, 49, 57, 58, 62, 63}},
	 {{  0,  4,  6, 20, 22, 36, 38, 52},
	  {  1,  5,  7, 21, 23, 37, 39, 53},
	  {  2,  8, 19, 24, 34, 40, 50, 54},
	  {  3,  9, 18, 25, 35, 41, 51, 55},
	  { 10, 17, 26, 30, 42, 46, 56, 60},
	  { 11, 16, 27, 31, 43, 47, 57, 61},
	  { 12, 15, 28, 32, 44, 48, 58, 62},
	  { 13, 14, 29, 33, 45, 49, 59, 63}}};

unsigned char SliceParser::InverseScanTable[2][64];

const int SliceParser::QuantizerScale[2][32] =
	{{  0,  2,  4,  6,  8, 10, 12, 14,
	   16, 18, 20, 22, 24, 26, 28, 30,
		32, 34, 36, 38, 40, 42, 44, 46,
		48, 50, 52, 54, 56, 58, 60, 62},
	 {  0,  1,  2,  3,  4,  5,  6,  7,
	    8, 10, 12, 14, 16, 18, 20, 22,
		24, 28, 32, 36, 40, 44, 48, 52,
		56, 64, 72, 80, 88, 96,104,112}};

void SliceParser::InitInverseScanTable(void)
	{
	int i, x, y;

	for(i=0; i<2; i++)
		{
		for(x=0; x<8; x++)
			{
			for(y=0; y<8; y++)
				{
				InverseScanTable[i][ScanTable[i][y][x]] = 8 * x + y;
				}
			}
		}
	}

__forceinline void SliceParser::ParseMacroblockModes(void)
	{
	macroblockType = bitStream->GetSymbol(macroblockTypeTable);
	dctType = IS_MACROBLOCK_ALTERNATE_DCT(macroblockType);
	motionVectorCount = MACROBLOCK_MOTION_COUNT(macroblockType);
	predictionType = MACROBLOCK_PREDICT_TYPE(macroblockType);
	dmv = 0;
	}

static __forceinline int CalcMotionComponentField(int f, int & pmv, int delta)
	{
	int high, low, range, v;

	high = f - 1;
	low = -f;
	range = 2 * f;

	v = (pmv >> 1) + delta;
	if      (v < low)  v += range;
	else if (v > high) v -= range;
	pmv = v * 2;

	return v;
	}

static __forceinline int CalcMotionComponentFrame(int f, int & pmv, int delta)
	{
	int high, low, range, v;

	high = f - 1;
	low = -f;
	range = 2 * f;

	v = pmv + delta;
	if      (v < low)  v += range;
	else if (v > high) v -= range;
	pmv = v;

	return v;
	}

#if DUMP_MOTION_VECTORS
static void ProcessMVStatistic(int mx, int my)
	{
	if (mx < 0) mx = -mx;
	if (my < 0) my = -my;
	vectorSumX[mx]++;
	vectorSumY[my]++;
	vectorTotal++;
	}

static void DumpMVStatistic(void)
	{
	int i;

	if (mfile)
		{
		if (vectorTotal)
			{
			for(i=0; i<256; i++)
				{
				fprintf(mfile, "Size %3d X : %6d %3d%%  Y : %6d %3d%%\n",
					i,
					vectorSumX[i], 100 * vectorSumX[i] / vectorTotal,
					vectorSumY[i], 100 * vectorSumY[i] / vectorTotal);
				}
			}
		}
	}
#endif

__forceinline int CalcDualPrime(int vector, int m, int e, int dmv)
	{
	vector *= m;
	if (vector > 0)
		vector = (vector + 1) >> 1;
	else
		vector = vector >> 1;
	vector += e + dmv;

	return vector;
	}

__forceinline void SliceParser::CalcMotionComponents(void)
	{
	if (motionVectorCount == 1)
		{
		if (IS_MACROBLOCK_MOTION_FORWARD(macroblockType))
			{
			vectors[0][0][0] = CalcMotionComponentFrame(ffcodes[0][0], pmv[0][0][0], motionValue[0][0][0]);
			vectors[0][0][1] = CalcMotionComponentFrame(ffcodes[0][1], pmv[0][0][1], motionValue[0][0][1]);
			pmv[1][0][0] = pmv[0][0][0];
			pmv[1][0][1] = pmv[0][0][1];

#if DUMP_MOTION_VECTORS
		if (mfile) fprintf(mfile, "FW %d, %d ", vectors[0][0][0], vectors[0][0][1]);
		ProcessMVStatistic(vectors[0][0][0], vectors[0][0][1]);
#endif
			}
		if (IS_MACROBLOCK_MOTION_BACKWARD(macroblockType))
			{
			vectors[0][1][0] = CalcMotionComponentFrame(ffcodes[1][0], pmv[0][1][0], motionValue[0][1][0]);
			vectors[0][1][1] = CalcMotionComponentFrame(ffcodes[1][1], pmv[0][1][1], motionValue[0][1][1]);
			pmv[1][1][0] = pmv[0][1][0];
			pmv[1][1][1] = pmv[0][1][1];

#if DUMP_MOTION_VECTORS
		if (mfile) fprintf(mfile, "BW %d, %d ", vectors[0][1][0], vectors[0][1][1]);
		ProcessMVStatistic(vectors[0][1][0], vectors[0][1][1]);
#endif
			}
		}
	else if (motionVectorCount == 2)
		{
		if (predictionType == PT_16x8MC)
			{
			if (IS_MACROBLOCK_MOTION_FORWARD(macroblockType))
				{
				vectors[0][0][0] = CalcMotionComponentFrame(ffcodes[0][0], pmv[0][0][0], motionValue[0][0][0]);
				vectors[0][0][1] = CalcMotionComponentFrame(ffcodes[0][1], pmv[0][0][1], motionValue[0][0][1]);
				vectors[1][0][0] = CalcMotionComponentFrame(ffcodes[0][0], pmv[1][0][0], motionValue[1][0][0]);
				vectors[1][0][1] = CalcMotionComponentFrame(ffcodes[0][1], pmv[1][0][1], motionValue[1][0][1]);
#if DUMP_MOTION_VECTORS
		if (mfile) fprintf(mfile, "FW16x8 %d, %d | %d, %d", vectors[0][0][0], vectors[0][0][1], vectors[1][0][0], vectors[1][0][1]);
		ProcessMVStatistic(vectors[0][0][0], vectors[0][0][1]);
		ProcessMVStatistic(vectors[1][0][0], vectors[1][0][1]);
#endif
				}
			if (IS_MACROBLOCK_MOTION_BACKWARD(macroblockType))
				{
				vectors[0][1][0] = CalcMotionComponentFrame(ffcodes[1][0], pmv[0][1][0], motionValue[0][1][0]);
				vectors[0][1][1] = CalcMotionComponentFrame(ffcodes[1][1], pmv[0][1][1], motionValue[0][1][1]);
				vectors[1][1][0] = CalcMotionComponentFrame(ffcodes[1][0], pmv[1][1][0], motionValue[1][1][0]);
				vectors[1][1][1] = CalcMotionComponentFrame(ffcodes[1][1], pmv[1][1][1], motionValue[1][1][1]);
#if DUMP_MOTION_VECTORS
		if (mfile) fprintf(mfile, "BW16x8 %d, %d | %d, %d", vectors[0][1][0], vectors[0][1][1], vectors[1][1][0], vectors[1][1][1]);
		ProcessMVStatistic(vectors[0][1][0], vectors[0][1][1]);
		ProcessMVStatistic(vectors[1][1][0], vectors[1][1][1]);
#endif
				}
			}
		else
			{
			if (IS_MACROBLOCK_MOTION_FORWARD(macroblockType))
				{
				vectors[0][0][0] = CalcMotionComponentFrame(ffcodes[0][0], pmv[0][0][0], motionValue[0][0][0]);
				vectors[0][0][1] = CalcMotionComponentField(ffcodes[0][1], pmv[0][0][1], motionValue[0][0][1]);
				vectors[1][0][0] = CalcMotionComponentFrame(ffcodes[0][0], pmv[1][0][0], motionValue[1][0][0]);
				vectors[1][0][1] = CalcMotionComponentField(ffcodes[0][1], pmv[1][0][1], motionValue[1][0][1]);
#if DUMP_MOTION_VECTORS
		if (mfile) fprintf(mfile, "FW %d, %d | %d, %d", vectors[0][0][0], vectors[0][0][1], vectors[1][0][0], vectors[1][0][1]);
		ProcessMVStatistic(vectors[0][0][0], vectors[0][0][1]);
		ProcessMVStatistic(vectors[1][0][0], vectors[1][0][1]);
#endif
				}
			if (IS_MACROBLOCK_MOTION_BACKWARD(macroblockType))
				{
				vectors[0][1][0] = CalcMotionComponentFrame(ffcodes[1][0], pmv[0][1][0], motionValue[0][1][0]);
				vectors[0][1][1] = CalcMotionComponentField(ffcodes[1][1], pmv[0][1][1], motionValue[0][1][1]);
				vectors[1][1][0] = CalcMotionComponentFrame(ffcodes[1][0], pmv[1][1][0], motionValue[1][1][0]);
				vectors[1][1][1] = CalcMotionComponentField(ffcodes[1][1], pmv[1][1][1], motionValue[1][1][1]);
#if DUMP_MOTION_VECTORS
		if (mfile) fprintf(mfile, "BW %d, %d | %d, %d", vectors[0][1][0], vectors[0][1][1], vectors[1][1][0], vectors[1][1][1]);
		ProcessMVStatistic(vectors[0][1][0], vectors[0][1][1]);
		ProcessMVStatistic(vectors[1][1][0], vectors[1][1][1]);
#endif
				}
			}
		}
	else if (motionVectorCount == 4)
		{
		if (IS_MACROBLOCK_MOTION_FORWARD(macroblockType))
			{
			vectors[1][0][0] = vectors[0][0][0] = CalcMotionComponentFrame(ffcodes[0][0], pmv[0][0][0], motionValue[0][0][0]);
			if (pictureStructure == PS_FRAME_PICTURE)
				{
				vectors[1][0][1] = vectors[0][0][1] = CalcMotionComponentField(ffcodes[0][1], pmv[0][0][1], motionValue[0][0][1]);

				if (PF_TOP_FIELD_FIRST(pictureFlags))
					{
					vectors[2][0][0] = CalcDualPrime(vectors[0][0][0], 1,  0, dmvector[0]);
					vectors[2][0][1] = CalcDualPrime(vectors[0][0][1], 1, -1, dmvector[1]);

					vectors[3][0][0] = CalcDualPrime(vectors[0][0][0], 3,  0, dmvector[0]);
					vectors[3][0][1] = CalcDualPrime(vectors[0][0][1], 3, +1, dmvector[1]);
					}
				else
					{
					vectors[2][0][0] = CalcDualPrime(vectors[0][0][0], 3,  0, dmvector[0]);
					vectors[2][0][1] = CalcDualPrime(vectors[0][0][1], 3, -1, dmvector[1]);

					vectors[3][0][0] = CalcDualPrime(vectors[0][0][0], 1,  0, dmvector[0]);
					vectors[3][0][1] = CalcDualPrime(vectors[0][0][1], 1, +1, dmvector[1]);
					}
				}
			else
				{
				vectors[1][0][1] = vectors[0][0][1] = CalcMotionComponentFrame(ffcodes[0][1], pmv[0][0][1], motionValue[0][0][1]);
				if (pictureStructure == PS_TOP_FIELD)
					{
					vectors[2][0][0] = CalcDualPrime(vectors[1][0][0], 1,  0, dmvector[0]);
					vectors[2][0][1] = CalcDualPrime(vectors[1][0][1], 1, -1, dmvector[1]);
					}
				else
					{
					vectors[2][0][0] = CalcDualPrime(vectors[1][0][0], 1,  0, dmvector[0]);
					vectors[2][0][1] = CalcDualPrime(vectors[1][0][1], 1, +1, dmvector[1]);
					}
				}

			pmv[1][0][0] = pmv[0][0][0];
			pmv[1][0][1] = pmv[0][0][1];

#if DUMP_MOTION_VECTORS
		if (mfile) fprintf(mfile, "FW %d, %d ", vectors[0][0][0], vectors[0][0][1]);
#endif
			}
		}
	else if (pictureCodingType == PREDICTIVE_CODED)
		{
		ResetPMV();
		vectors[0][0][0] = 0; vectors[0][0][1] = 0;
		vectors[1][0][0] = 0; vectors[1][0][1] = 0;
		motionVerticalFieldSelect[0][0] = currentFieldID;
		}
	else
		{
		ResetPMV();
		motionVerticalFieldSelect[0][0] = currentFieldID;
		motionVerticalFieldSelect[0][1] = currentFieldID;
		}
	}

__forceinline void SliceParser::ResetPMV(void)
	{
	memset(pmv, 0, sizeof(pmv));
	}

__forceinline void SliceParser::ResetPredictors(void)
	{
	dcPredictor[0] = dcLumaPredictorInitializer;
	dcPredictor[1] = dcChromaUPredictorInitializer;
	dcPredictor[2] = dcChromaVPredictorInitializer;
	}

__forceinline void SliceParser::ParseCodedBlockPattern(void)
	{
#if _M_IX86
	__asm
		{
		mov	ecx, [BSBits]
		mov	edx, VIDEO_STREAM_BUFFER_MASK

		mov	edi, [this]
		and	edx, ecx

		shr	edx, 5

		mov	ebx, [VideoStreamBuffer + 4 + edx * 4]
		mov	eax, [VideoStreamBuffer +     edx * 4]

		shld	eax, ebx, cl
		mov	ebx, 0x3f

		test	eax, 0xc0000000
		je		longCode

		shr	eax, 27
		movzx	eax, [codedBlockPattern420 + eax].extPatternTable;

		and	ebx, eax
		shr	eax, 6

		lea	ecx, [ecx + eax + 3]
		jmp	doneCode
longCode:
		shr	eax, 23
		movzx	eax, [codedBlockPattern420 + 32 + eax].extPatternTable;

		and	ebx, eax
		shr	eax, 6

		lea	ecx, [ecx + eax + 6]
doneCode:
		mov	[BSBits], ecx

		mov	[edi].codedBlockPattern, ebx
		}
#else
	codedBlockPattern = bitStream->GetSymbol(&codedBlockPattern420);
#endif
	}


#pragma warning (disable : 4035)

__forceinline int SliceParser::GetMotionVector(int fcode, HuffmanTable * table)
	{
#if _M_IX86
	__asm
		{
		mov	esi, [BSBits]
		mov	edx, VIDEO_STREAM_BUFFER_MASK

		mov	ecx, esi
		and	edx, esi

		shr	edx, 5
		//

		//
		//

		mov	ebx, [VideoStreamBuffer + 4 + edx * 4]
		mov	eax, [VideoStreamBuffer +     edx * 4]

		shld	eax, ebx, cl

		test	eax, 0xc0000000
		js		zero

		mov	edx, eax
		jne	one

		shr	eax, 22
		mov	ebx, [table]

		add	esi, 9

		mov	eax, [ebx + 4 * eax]
		mov	ecx, 0x000000ff

		and	ecx, eax
		and	eax, 0x00000f00

		shl	edx, cl

		add	esi, ecx
		mov	ebx, edx

		sar	edx, 31
		and	ebx, 0x7fffffff

		shr	ebx, 23
		mov	ecx, [fcode]

		or		eax, ebx
		sub	esi, ecx

		shr	eax, cl

		add	eax, 1
		//

		xor	eax, edx
		and	edx, 0x00000001

		add	eax, edx
		jmp	done
one:
		and	eax, 0x1fffffff
		mov	ecx, [fcode]

		shl	edx, 2
		sub	esi, ecx

		sar	edx, 31
		add	ecx, 21

		shr	eax, cl

		add	esi, 11
		add	eax, 1

		xor	eax, edx

		sub	eax, edx
		jmp	done
zero:
		add	esi, 1
		xor	eax, eax
done:
		mov	[BSBits], esi
		}
#else
	DWORD res, sym, num;
	int vec;

	res = bitStream->Peek();

	if (res & 0x80000000)
		{
		bitStream->Advance(1);

		return 0;
		}
	else if (res & 0xc0000000)
		{
		vec = ((res & 0x1fffffff) >> (fcode + 21)) + 1;
		if (res & 0x20000000) vec = -vec;

		bitStream->Advance(11 - fcode);

		return vec;
		}
	else
		{
		sym = table->FindFlatSymbol(res << 2);
		num = sym & 0xff;
		res <<= num;

		vec = (((sym & 0x00000f00) + ((res & 0x7fffffff) >> 23)) >> fcode) + 1;
		if (res & 0x80000000) vec = - vec;

		bitStream->Advance(9 + num - fcode);

		return vec;
		}

#endif
	}

#pragma warning (default : 4035)

__forceinline void SliceParser::ParseMotionVector(int r, int s)
	{
	motionValue[r][s][0] = GetMotionVector(ifcodes[s][0], &motionCodes);
	motionValue[r][s][1] = GetMotionVector(ifcodes[s][1], &motionCodes);
#if DUMP_MOTION_VECTORS
	if (mfile) fprintf(mfile, "(%d, %d) ", motionValue[r][s][0], motionValue[r][s][1]);
#endif
	}

__forceinline void SliceParser::ParseDMVMotionVector(int s)
	{
	motionValue[0][s][0] = GetMotionVector(ifcodes[s][0], &motionCodes);
	if (bitStream->GetBit())
		dmvector[0] = 1 - 2 * bitStream->GetBit();
	else
		dmvector[0] = 0;

	motionValue[0][s][1] = GetMotionVector(ifcodes[s][1], &motionCodes);
	if (bitStream->GetBit())
		dmvector[1] = 1 - 2 * bitStream->GetBit();
	else
		dmvector[1] = 0;
	motionVectorCount = 4;
	}

void SliceParser::ParseMotionVectors(int s)
	{
	if (motionVectorCount == 1)
		{
		if (IS_MACROBLOCK_DUAL_PRIME_PREDICTION(macroblockType))
			{
			motionVerticalFieldSelect[0][s] = 0;
			motionVerticalFieldSelect[0][s] = 1;
			ParseDMVMotionVector(s);
			}
		else
			{
			if (predictionType != PT_FRAME_BASED)
				{
				motionVerticalFieldSelect[0][s] = bitStream->GetBit();
				}
			ParseMotionVector(0, s);
			}
		}
	else
		{
		motionVerticalFieldSelect[0][s] = bitStream->GetBit();
		ParseMotionVector(0, s);
		motionVerticalFieldSelect[1][s] = bitStream->GetBit();
		ParseMotionVector(1, s);
		}
	}

void SliceParser::ExecuteSkippedMacroblock(int mx, int my)
	{
	codedBlockPattern = 0x00;
	MotionCompensation(mx, my, TRUE, TRUE);
	}

__forceinline void SliceParser::SkipMacroblocks(int num)
	{
	int m, mx, my;

	if (num)
		{
		if (pictureCodingType != INTRA_CODED)
			{
			macroblockType &= ~MF_INTRA;

			ResetPredictors();
			switch (pictureStructure)
				{
				case PS_FRAME_PICTURE:
					if (pictureCodingType == PREDICTIVE_CODED)
						{
						ResetPMV();
						vectors[0][0][0] = 0; vectors[0][0][1] = 0;
						vectors[0][1][0] = 0; vectors[0][1][1] = 0;
						}
					else
						{
						vectors[0][0][0] = pmv[0][0][0];
						vectors[0][0][1] = pmv[0][0][1];
						vectors[0][1][0] = pmv[0][1][0];
						vectors[0][1][1] = pmv[0][1][1];
						}

					predictionType = PT_FRAME_BASED;
					break;
				case PS_TOP_FIELD:
					if (pictureCodingType == PREDICTIVE_CODED)
						{
						ResetPMV();
						vectors[0][0][0] = 0; vectors[0][0][1] = 0;
						vectors[0][1][0] = 0; vectors[0][1][1] = 0;
						motionVerticalFieldSelect[0][0] = 0;
						}
					else
						{
						vectors[0][0][0] = pmv[0][0][0];
						vectors[0][0][1] = pmv[0][0][1];
						vectors[0][1][0] = pmv[0][1][0];
						vectors[0][1][1] = pmv[0][1][1];
						motionVerticalFieldSelect[0][0] = 0;
						motionVerticalFieldSelect[0][1] = 0;
						}

					predictionType = PT_FIELD_BASED;
					break;
				case PS_BOTTOM_FIELD:
					if (pictureCodingType == PREDICTIVE_CODED)
						{
						ResetPMV();
						vectors[0][0][0] = 0; vectors[0][0][1] = 0;
						vectors[0][1][0] = 0; vectors[0][1][1] = 0;
						motionVerticalFieldSelect[0][0] = 1;
						}
					else
						{
						vectors[0][0][0] = pmv[0][0][0];
						vectors[0][0][1] = pmv[0][0][1];
						vectors[0][1][0] = pmv[0][1][0];
						vectors[0][1][1] = pmv[0][1][1];
						motionVerticalFieldSelect[0][0] = 1;
						motionVerticalFieldSelect[0][1] = 1;
						}

					predictionType = PT_FIELD_BASED;
					break;
				}


			for(m=0; m<num; m++)
				{
				mx = macroblockX * 16;
				my = macroblockY * 16;
				if (my >= pictureHeight) return;

				ExecuteSkippedMacroblock(mx, my);

				macroblockAddress++;
				macroblockX++;
				if (macroblockX == macroblocksPerRow)
					{
					macroblockX = 0;
					macroblockY ++;
					}
				}
			}
		else
			{
			macroblockAddress += num;
			macroblockX = macroblockAddress % macroblocksPerRow;
			macroblockY = macroblockAddress / macroblocksPerRow;
			errorInSlice = true;
			}
		}
	}

#pragma warning (disable : 4035)

__forceinline int SliceParser::GetMacroblockAddressIncrement(HuffmanTable * table)
	{
#if _M_IX86
	__asm
		{
		mov	ecx, [BSBits]
		mov	eax, 1

		mov	edx, VIDEO_STREAM_BUFFER_MASK
		mov	esi, [table]

loop1:
		and	edx, ecx

		shr	edx, 5

		mov	ebx, [VideoStreamBuffer + 4 + edx * 4]
		mov	edx, [VideoStreamBuffer +     edx * 4]

		shld	edx, ebx, cl

		test	edx, 0xfe000000
		js		one

		jne	code

		// check for macroblock stuffing, only for MPEG 1 needed,
		// but does not matter here
		test	edx, 0x00e00000
		jne	stuff

		add	eax, 33
stuff:
		add	ecx, 11

		mov	edx, VIDEO_STREAM_BUFFER_MASK
		jmp	loop1

code:
		mov	ebx, edx
		mov	edi, 0x000000ff

		shr	ebx, 24
		and	edx, 0x00ff0000

		shr	edx, 16
		mov	esi, [esi + 4 * ebx]

		test	esi, 1
		jne	hit1

		mov	esi, [esi + 4 * edx]
hit1:
		and	edi, esi
		dec	eax

		shr	edi, 1
		dec	ecx

		sar	esi, 8
		add	ecx, edi

		add	eax, esi
one:
		add	ecx, 1

		mov	[BSBits], ecx
		}
#else
	DWORD res;
	DWORD sym;
	DWORD escape;

	escape = 0;

	for(;;)
		{
		res = bitStream->Peek();

		if (res & 0x80000000)
			{
			bitStream->Advance(1);

			return escape + 1;
			}
		else if (res & 0xfe000000)
			{
			sym = table->FindSymbol(res);

			bitStream->Advance((sym >> 1) & 0x7f);

			return (((int)sym) >> 8) + escape;
			}
		else
			{
			if (!(res & 0x00e0000))
				{
				escape += 33;
				}

			bitStream->Advance(11);
			}
		}
#endif
	}

#pragma warning (default : 4035)

//
//  Parse Intra Macroblock
//

void SliceParser::ParseIntraMacroblock(int mx, int my)
	{
//	DP("Intra MB");
	codedBlockPattern = 0x3f;

	intraDCTable = &dctDCSizeLuminance;
	ParseIntraBlock(0, 0);
	ParseIntraBlock(1, 0);
	ParseIntraBlock(2, 0);
	ParseIntraBlock(3, 0);
	intraDCTable = &dctDCSizeChrominance;
	ParseIntraBlock(4, 1);
	ParseIntraBlock(5, 2);

	if (my < pictureHeight) MotionCompensation(mx, my, FALSE, FALSE);
	}

//
//  Parse Pattern Macroblock
//

void SliceParser::ParsePatternMacroblock(int mx, int my)
	{
//	DP("Pattern MB");
	bool hasYDCT, hasUVDCT;

	ClearBlocks();

	hasYDCT = FALSE;
	hasUVDCT = FALSE;

	if ((codedBlockPattern & 0x3c) != 0)
		{
		intraDCTable = &dctDCSizeLuminance;
		if (codedBlockPattern & 0x20) ParseNonIntraBlock(0, 0);
		if (codedBlockPattern & 0x10) ParseNonIntraBlock(1, 0);
		if (codedBlockPattern & 0x08) ParseNonIntraBlock(2, 0);
		if (codedBlockPattern & 0x04) ParseNonIntraBlock(3, 0);
		hasYDCT = TRUE;
		}
	if ((codedBlockPattern & 0x03) != 0)
		{
		intraDCTable = &dctDCSizeChrominance;
		if (codedBlockPattern & 0x02) ParseNonIntraBlock(4, 1);
		if (codedBlockPattern & 0x01) ParseNonIntraBlock(5, 2);
		hasUVDCT = TRUE;
		}

	CalcMotionComponents();


	if (my < pictureHeight) MotionCompensation(mx, my, !hasYDCT, !hasUVDCT);
	}

//
//  Parse Skipped Macroblock
//

void SliceParser::ParseSkippedMacroblock(int mx, int my)
	{
//	DP("Skipped MB");
	codedBlockPattern = 0x0;

	CalcMotionComponents();

	if (my < pictureHeight) MotionCompensation(mx, my, TRUE, TRUE);
	}

//
//  Parse Macroblock
//

__forceinline bool SliceParser::ParseMacroblock(void)
	{
	int macroblockAddressIncrement;

	macroblockAddressIncrement = GetMacroblockAddressIncrement(&macroBlockAddressIncrement) - macroblockAddressDecrement;
	if (macroblockAddressIncrement < 0)
		{
		macroblockAddress += macroblockAddressIncrement;
		macroblockX = macroblockAddress % macroblocksPerRow;
		macroblockY = macroblockAddress / macroblocksPerRow;
		macroblockAddressIncrement = 0;
		errorInPicture = true;
		DP("Error in macroblock address calculation");
		}
	macroblockAddressDecrement = 1;

	SkipMacroblocks(macroblockAddressIncrement);

#if DUMP_MOTION_VECTORS
	if (mfile) fprintf(mfile, "MX %3d MY %3d : ", macroblockX, macroblockY);
#endif

	if (macroblockAddress < finalMacroblockAddress)
		{
		ParseMacroblockModes();

		if (IS_MACROBLOCK_QUANT(macroblockType))
			{
			SetQuantScaleCode(bitStream->GetBits(5));
			}

#if DUMP_MOTION_VECTORS
		if (mfile) fprintf(mfile, "MD %02x Q %2d ", macroblockType, quantizerScaleCode);
#endif


		if (IS_MACROBLOCK_INTRA(macroblockType))
			{
			//
			//  Intra Macroblock
			//

#if DUMP_MOTION_VECTORS
			if (mfile) fprintf(mfile, "INTRA ");
#endif

			if (PF_CONCEALMENT_MOTION_VECTORS(pictureFlags))
				{
#if DUMP_MOTION_VECTORS
				if (mfile) fprintf(mfile, "CMV ");
#endif

				macroblockType |= MF_MOTION_FORWARD;

				if (pictureStructure == PS_FRAME_PICTURE)
					predictionType = PT_FRAME_BASED;
				else
					predictionType = PT_FIELD_BASED;

				motionVectorCount = 1;
				ParseMotionVectors(0);
				bitStream->Advance(1);
				CalcMotionComponents();
				}
			else
				{
				ResetPMV();
				}

			ParseIntraMacroblock(macroblockX * 16, macroblockY * 16);
			}
		else if (pictureCodingType != INTRA_CODED)
			{
			//
			//  Non Intra Macroblock
			//

#if DUMP_MOTION_VECTORS
			if (mfile) fprintf(mfile, "NON INTRA ");
#endif

			if (IS_MACROBLOCK_MOTION_FORWARD(macroblockType))
				ParseMotionVectors(0);

			if (IS_MACROBLOCK_MOTION_BACKWARD(macroblockType))
				ParseMotionVectors(1);

			ResetPredictors();

			if (IS_MACROBLOCK_PATTERN(macroblockType))
				{
				ParseCodedBlockPattern();

#if DUMP_MOTION_VECTORS
			if (mfile) fprintf(mfile, "CBP %02x ", codedBlockPattern);
#endif

				ParsePatternMacroblock(macroblockX * 16, macroblockY * 16);
				}
			else
				{
				ParseSkippedMacroblock(macroblockX * 16, macroblockY * 16);
				}

			}
		else
			return false;
		}
	else
		return false;

#if DUMP_MOTION_VECTORS
	if (mfile) fprintf(mfile, "\n");
#endif

	macroblockAddress++;
	macroblockX++;
	if (macroblockX == macroblocksPerRow)
		{
		macroblockX = 0;
		macroblockY ++;
		}

	return true;
	}

//
//  Parse MPEG-2 Slice
//

void SliceParser::ParseMPEG2Slice(void)
	{
	DWORD startCode;
   int newSliceVerticalPosition;
	bool errorInSlice;

	frameIsComplete = false;
	errorInSlice = false;

	startCode = bitStream->GetBits(32);
	newSliceVerticalPosition = (startCode & 0xff) - 1;
#if DUMP_MOTION_VECTORS
	if (mfile) fprintf(mfile, "%08lx : ", (DWORD)(bitStream->CurrentLocation()));
	if (mfile) fprintf(mfile, "Slice %d\n", newSliceVerticalPosition);
#endif
	if (newSliceVerticalPosition > sliceVerticalPosition)
		{
		sliceVerticalPosition = newSliceVerticalPosition;

		macroblockAddress = macroblocksPerRow * sliceVerticalPosition;
		macroblockX = 0;
		macroblockY = sliceVerticalPosition;

		directAccess = FALSE;
		if (macroblockY * 16 < pictureHeight)
			{
			if (display)
				{
				directAccess = AttemptDirectAccess();
				}

			macroblockAddressDecrement = 1;

			for(;;)
				{
				numFLines = 8;

				ResetPredictors();
				ResetPMV();

				SetQuantScaleCode(bitStream->GetBits(5));

				if (bitStream->PeekBits(1))
					{
					bitStream->GetBits(9);
					while (bitStream->PeekBits(1))
						{
						bitStream->GetBits(9);
						}
					}
				bitStream->GetBit();

				do	{
	#if DUMP_MOTION_VECTORS
					if (mfile) fprintf(mfile, "%08lx : ", (DWORD)(bitStream->CurrentLocation()));
	#endif
					if (!ParseMacroblock()) errorInSlice = true;
					} while (!errorInSlice && macroblockAddress < finalMacroblockAddress && bitStream->PeekBits(23) != 0);

				bitStream->NextStartCode();

				if (errorInSlice)
					{
					errorInPicture = true;
					}

				if (!errorInSlice && bitStream->PeekBits(32) == startCode)
					{
					bitStream->Advance(32);
					macroblockAddressDecrement = macroblockX + 1;
					}
				else
					break;
				}
			}
		else
			errorInPicture = true;

		if (display)
			{
			if (directAccess)
				DoneDirectAccess();
			else if (stripeAccess && !errorInPicture)
				display->CopyStripe(sliceVerticalPosition * 16, pictureStructure);
			}
		}
	else
		{
		errorInPicture = true;
		if (startCode >= 0x00000101 && startCode <= 0x000001a0)
			{
			bitStream->Advance(8);
			bitStream->NextStartCode();
			}
		}

	if (!errorInPicture && macroblockAddress == finalMacroblockAddress)
		{
		if (!bitStream->IsBufferUnderflow())
			{
			MarkFrameComplete();
			frameIsComplete = true;
			}
		}
	}

void SliceParser::MarkFrameComplete(void)
	{
	if (display) display->MarkFrameComplete();
	}

void SliceParser::ParseMPEG1Slice(void)
	{
	DWORD startCode;

	frameIsComplete = false;
	errorInSlice = false;

	startCode = bitStream->GetBits(32);
	sliceVerticalPosition = (startCode & 0xff) - 1;

	if (sliceVerticalPosition < stopMacroblockY)
		{
		macroblockAddress = macroblocksPerRow * macroblockY + macroblockX;
		macroblockAddressDecrement = macroblockAddress + 1 - macroblocksPerRow * sliceVerticalPosition;

		directAccess = FALSE;

		numFLines = 8;

		ResetPredictors();
		ResetPMV();

		SetQuantScaleCode(bitStream->GetBits(5));

		if (bitStream->PeekBits(1))
			{
			bitStream->GetBits(9);
			while (bitStream->PeekBits(1))
				{
				bitStream->GetBits(9);
				}
			}
		bitStream->GetBit();

		do	{
			if (!ParseMacroblock()) errorInSlice = true;
			} while (!errorInSlice && macroblockAddress < finalMacroblockAddress && bitStream->PeekBits(23) != 0);

		bitStream->NextStartCode();

		if (errorInSlice)
			{
			errorInPicture = true;
			}

		if (!errorInPicture && macroblockAddress == finalMacroblockAddress)
			{
			if (!bitStream->IsBufferUnderflow())
				{
				MarkFrameComplete();
				frameIsComplete = true;
				}
			}
		}
	else
		{
		bitStream->Advance(8);
		bitStream->NextStartCode();

		errorInPicture = true;
		}
	}

void SliceParser::SetFCodes(BYTE fc00, BYTE fc01, BYTE fc10, BYTE fc11)
	{
	fcodes[0][0] = fc00;
	fcodes[0][1] = fc01;
	fcodes[1][0] = fc10;
	fcodes[1][1] = fc11;
	ifcodes[0][0] = 9-fc00;
	ifcodes[0][1] = 9-fc01;
	ifcodes[1][0] = 9-fc10;
	ifcodes[1][1] = 9-fc11;
	ffcodes[0][0] = 1 << (fc00 + 3);
	ffcodes[0][1] = 1 << (fc01 + 3);
	ffcodes[1][0] = 1 << (fc10 + 3);
	ffcodes[1][1] = 1 << (fc11 + 3);
	}

void SliceParser::SetPictureParameters(BYTE intraDCPrecision,
		                    PictureStructure pictureStructure,
								  BYTE pictureFlags)
	{
	this->intraDCPrecision = intraDCPrecision;
	this->pictureStructure = pictureStructure;
	this->pictureFlags = pictureFlags;

	if (PF_INTRA_VLC_FORMAT(pictureFlags))
		intraNonDCTable = &dctCoefficientOne;
	else
		intraNonDCTable = &dctCoefficientZero;

	if (PF_ALTERNATE_SCAN(pictureFlags))
		scanTable = inverseScanTable[1];
	else
		scanTable = inverseScanTable[0];

	if (pictureStructure != PS_FRAME_PICTURE)
		{
		switch (pictureCodingType)
			{
			case INTRA_CODED:
				macroblockTypeTable = &iFieldMacroBlockType;
				break;
			case PREDICTIVE_CODED:
				macroblockTypeTable = &pFieldMacroBlockType;
				break;
			case BIDIRECTIONAL_PREDICTIVE_CODED:
				macroblockTypeTable = &bFieldMacroBlockType;
				break;
			}
		}
	else if (PF_FRAME_PRED_FRAME_DCT(pictureFlags))
		{
		switch (pictureCodingType)
			{
			case INTRA_CODED:
				macroblockTypeTable = &iFrameMacroBlockTypeFPFD;
				break;
			case PREDICTIVE_CODED:
				macroblockTypeTable = &pFrameMacroBlockTypeFPFD;
				break;
			case BIDIRECTIONAL_PREDICTIVE_CODED:
				macroblockTypeTable = &bFrameMacroBlockTypeFPFD;
				break;
			}
		}
	else
		{
		switch (pictureCodingType)
			{
			case INTRA_CODED:
				macroblockTypeTable = &iFrameMacroBlockType;
				break;
			case PREDICTIVE_CODED:
				macroblockTypeTable = &pFrameMacroBlockType;
				break;
			case BIDIRECTIONAL_PREDICTIVE_CODED:
				macroblockTypeTable = &bFrameMacroBlockType;
				break;
			}
		}

	dcLumaPredictorInitializer = brightness << intraDCPrecision;
	dcChromaUPredictorInitializer = uBrightness << intraDCPrecision;
	dcChromaVPredictorInitializer = vBrightness << intraDCPrecision;

	sliceVerticalPosition = -1;
	}

void SliceParser::SetCodingType(PictureCodingType pictureCodingType)
	{
	this->pictureCodingType = pictureCodingType;
	}

void SliceParser::SetForwardVector(bool fullPel, BYTE fcode)
	{
	this->forwardFullPel = fullPel;
	this->forwardFCode = fcode;
	fcodes [0][0] = fcodes [0][1] = fcode;
	ifcodes[0][0] = ifcodes[0][1] = 9-fcode;
	ffcodes[0][0] = ffcodes[0][1] = 1 << (fcode + 3);
	}

void SliceParser::SetBackwardVector(bool fullPel, BYTE fcode)
	{
	this->backwardFullPel = fullPel;
	this->backwardFCode = fcode;
	fcodes [1][0] = fcodes [1][1] = fcode;
	ifcodes[1][0] = ifcodes[1][1] = 9-fcode;
	ffcodes[1][0] = ffcodes[1][1] = 1 << (fcode + 3);
	}

void SliceParser::SetImageSize(int width, int height)
	{
	this->width = width;
	this->height = height;
	this->height16 = height - 16;

	macroblocksPerRow = width / 16;
	}

void SliceParser::SetQuantMatrix(QuantMatrices type, const QuantizationMatrix & matrix)
	{
	int i;

	for(i=0; i<64; i++)
		{
		quantMatrix[type][InverseScanTable[0][i]] = matrix[i];
		}
	}

bool SliceParser::BeginFrameDecoding(FrameStore * pred, FrameStore * succ, FrameStore * curr, PictureDisplayBuffer * display, bool hurryUp)
	{
#if DUMP_MOTION_VECTORS
	if (mfile)
		{
		DumpMVStatistic();
		}
	if (mfile) fclose(mfile);
	mfile = NULL;
	char fname[100];
	wsprintf(fname, "c:\\mvectors\\frame%03d.txt", frameCount);
	frameCount++;
	mfile = fopen(fname, "w");
	fprintf(mfile, "Coding Type %d Pred %08lx Succ %08lx Curr %08lx PF %08lx\n",
		pictureCodingType, pred, succ, curr, pictureFlags);
#endif

	frameIsComplete = false;
	errorInPicture = false;

	if (display) display->MarkFrameIncomplete();

	predFrame = pred;
	succFrame = succ;
	curFrame = curr;
	this->display = display;

	predFields[0] = predFrame;
	predFields[1] = predFrame;

	motionVerticalFieldSelect[0][0] = 0;
	motionVerticalFieldSelect[0][1] = 0;
	motionVerticalFieldSelect[1][0] = 0;
	motionVerticalFieldSelect[1][1] = 0;

	currentFieldID = (pictureStructure == PS_BOTTOM_FIELD) ? 1 : 0;

	if (display && vcs == VCS_MPEG_2)
		stripeAccess = display->BeginStripeAccess(curr, 16, pictureStructure);
	else
		stripeAccess = FALSE;

	pictureHeight = (pictureStructure == PS_FRAME_PICTURE) ? height : height >> 1;
	macroblockX = 0;
	macroblockY = 0;
	stopMacroblockY = pictureHeight >> 4;
	finalMacroblockAddress = macroblocksPerRow * stopMacroblockY;

	return TRUE;
	}

void SliceParser::DoneFrameDecoding(void)
	{
	if (stripeAccess)
		{
		display->DoneStripeAccess();
		}
	else if (display)
		{
		display->CopyFrame(curFrame);
		}

#if DUMP_MOTION_VECTORS
	DumpMVStatistic();
	if (mfile) fclose(mfile);
	mfile = NULL;
#endif
	}

void SliceParser::DoneFirstFieldDecoding(void)
	{
	}

void SliceParser::BeginSecondFieldDecoding(void)
	{
	currentFieldID = (pictureStructure == PS_BOTTOM_FIELD) ? 1 : 0;

	if (pictureCodingType == PREDICTIVE_CODED)
		{
		predFields[currentFieldID] = predFrame;
		predFields[1-currentFieldID] = curFrame;
		}

#if DUMP_MOTION_VECTORS
	if (mfile) fprintf(mfile, "Coding Type %d PF %08lx\n",
		pictureCodingType, pictureFlags);
#endif
	}

bool SliceParser::SuspendFrameDecoding(void)
	{
	if (stripeAccess) display->DoneStripeAccess();

	return TRUE;
	}

void SliceParser::ResumeFrameDecoding(void)
	{
	if (stripeAccess) display->BeginStripeAccess(curFrame, 16, pictureStructure);
	}
/*
FrameStore * SliceParser::AllocFrameStore(PictureCodingType type, bool stripeOptimized)
	{
	return new FrameStore(width, height, stripeOptimized);
	}
*/
void SliceParser::Parse(void)
	{
	if (vcs == VCS_MPEG_2)
		ParseMPEG2Slice();
	else
		ParseMPEG1Slice();
	}

SliceParser::SliceParser(VideoBitStream * bitStream)
	{
	this->bitStream = bitStream;

	InitInverseScanTable();
	inverseScanTable[0] = &(InverseScanTable[0][0]);
	inverseScanTable[1] = &(InverseScanTable[1][0]);

	brightness = 128;
	uBrightness = 128;
	vBrightness = 128;
	}

void SliceParser::SetQuantScaleCode(int code)
	{
	quantizerScaleCode = (BYTE)code;
	}

void SliceParser::SetVideoCodingStandard(VideoCodingStandard vcs)
	{
	this->vcs = vcs;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\SliceParser.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef SLICEPARSER_H
#define SLICEPARSER_H

#include "PictureParser.h"
#include "Mp2HuffTables.h"

#define SPCCF_BRIGHTNESS					0x00000001l
#define SPCCF_CONTRAST						0x00000002l
#define SPCCF_HUE								0x00000004l
#define SPCCF_SATURATION					0x00000008l
#define SPCCF_SHARPNESS						0x00000010l
#define SPCCF_GAMMA							0x00000020l
#define SPCCF_RED_BRIGHTNESS				0x00001000l
#define SPCCF_BLUE_BRIGHTNESS				0x00002000l
#define SPCCF_GREEN_BRIGHTNESS			0x00004000l

class SliceParser : public GenericSliceParser
	{
	protected:
		PadOnQWord				pad0;

		static unsigned char	InverseScanTable[2][64];
		static const int		QuantizerScale[2][32];

		BYTE						fcodes[2][2];
		BYTE						intraDCPrecision;
		PictureStructure		pictureStructure;
		BYTE						pictureFlags;
		PictureCodingType		pictureCodingType;
		bool						forwardFullPel;
		BYTE						forwardFCode;
		bool						backwardFullPel;
		BYTE						backwardFCode;
		int						width, height;
		int						height16; // height - 16

		int						ffcodes[2][2];
		int						ifcodes[2][2];
		int						currentFieldID;
		int						stopMacroblockY;
		int						pictureHeight;

		QuantizationMatrix	quantMatrix[4];

		int						macroblockAddressDecrement;
		int						macroblocksPerRow;
		HuffmanTable		*	intraNonDCTable;
		unsigned char		*	scanTable;
		HuffmanTable		*	intraDCTable;
		unsigned char		*	inverseScanTable[2];

		HuffmanTable		*	macroblockTypeTable;

		BYTE						quantizerScaleCode;

		int						sliceVerticalPosition;
		int						macroblockAddress;
		int						macroblockX, macroblockY;
		int						macroblockType;
		bool						dctType;

		PredictionType			predictionType;
		int						motionVectorCount;
		int						dmv;

		int						motionVerticalFieldSelect[2][2];
		int						motionValue[2][2][2];

		int						codedBlockPattern;
		int						dcPredictor[3];
		int						dcLumaPredictorInitializer;
		int						dcChromaUPredictorInitializer;
		int						dcChromaVPredictorInitializer;

		int						numFLines;

		int						pmv[2][2][2];
		int						vectors[4][2][2];
		int						dmvector[2];

		FrameStore			*	predFrame;
		FrameStore			*	succFrame;
		FrameStore			*	curFrame;
		FrameStore			*	predFields[2];
		PictureDisplayBuffer * display;
		VideoBitStream		*	bitStream;

		bool						directAccess;
		bool						stripeAccess;

		int						finalMacroblockAddress;

		int						brightness, uBrightness, vBrightness;

		bool						frameIsComplete, errorInPicture, errorInSlice;

		VideoCodingStandard	vcs;
	private:
//		int	pad00;
	protected:

		virtual void MotionCompensation(int mx, int my, bool copyY, bool copyUV) = 0;
		virtual void ParseBlock(int n, int yuvType) {}
		virtual void ParseIntraBlock(int n, int yuvType) {ParseBlock(n, yuvType);}
		virtual void ParseNonIntraBlock(int n, int yuvType) {ParseBlock(n, yuvType);}
		virtual void ClearBlocks(void) = 0;
		virtual void SetQuantScaleCode(int code);
		virtual void ExecuteSkippedMacroblock(int mx, int my);

		virtual bool AttemptDirectAccess(void) {return FALSE;}
		virtual void DoneDirectAccess(void) {}

		void InitInverseScanTable(void);

		void CalcMotionComponents(void);
		void SkipMacroblocks(int num);
		void ResetPredictors(void);
		void ResetPMV(void);
		void ParseMacroblockModes(void);
		int GetMacroblockAddressIncrement(HuffmanTable * table);
		int GetMotionVector(int fcode, HuffmanTable * table);

		void ParseCodedBlockPattern(void);
		void ParseMotionVector(int r, int s);
		void ParseDMVMotionVector(int s);
		void ParseMotionVectors(int s);

		bool ParseMacroblock(void);

		void ParseMPEG2Slice(void);
		void ParseMPEG1Slice(void);

		virtual void ParseIntraMacroblock(int mx, int my);
		virtual void ParsePatternMacroblock(int mx, int my);
		virtual void ParseSkippedMacroblock(int mx, int my);

		virtual void MarkFrameComplete(void);
	public:
		void SetFCodes(BYTE fc00, BYTE fc01, BYTE fc10, BYTE fc11);
		void SetPictureParameters(BYTE intraDCPrecision,
		                          PictureStructure pictureStructure,
									  	  BYTE pictureFlags);
		void SetCodingType(PictureCodingType pictureCodingType);
		void SetForwardVector(bool fullPel, BYTE fcode);
		void SetBackwardVector(bool fullPel, BYTE fcode);
		void SetImageSize(int width, int height);
		void SetQuantMatrix(QuantMatrices type, const QuantizationMatrix & matrix);
		void SetVideoCodingStandard(VideoCodingStandard vcd);

		bool BeginFrameDecoding(FrameStore * pred, FrameStore * succ, FrameStore * curr, PictureDisplayBuffer * display, bool hurryUp);
		bool SuspendFrameDecoding(void);
		void DoneFirstFieldDecoding(void);
		void BeginSecondFieldDecoding(void);
		void ResumeFrameDecoding(void);
		void DoneFrameDecoding(void);

		FrameStore * AllocFrameStore(PictureCodingType type, bool stripeOptimized) = 0;

		void Parse(void);

		virtual void SetBitStream(VideoBitStream * bitStream) {this->bitStream = bitStream;}

		SliceParser(VideoBitStream * bitStream);

		virtual void SetBrightness(int brightness, int uBrightness, int vBrightness)
			{
			this->brightness = brightness;
			this->uBrightness = uBrightness;
			this->vBrightness = vBrightness;
			}

		virtual void SetContrast(int contrast) {}

		virtual void SetSaturation(int saturation) {}

		virtual DWORD QueryColorControl(void) {return SPCCF_BRIGHTNESS |
				                                        SPCCF_RED_BRIGHTNESS |
															       SPCCF_BLUE_BRIGHTNESS |
																	 SPCCF_GREEN_BRIGHTNESS;}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\VideoStreamParser.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "VideoStreamParser.h"
#include "Mp2HuffTables.h"
#include "..\common\PerformanceMonitor.h"
#include "library\common\vddebug.h"
#define VIONA_VERSION	1
#define ONLY_EXTERNAL_VISIBLE
#include "library\hardware\mpeg2dec\generic\mp2eldec.h"

static const QuantizationMatrix DefIntraQuantMatrix = {
	0x08, 0x10, 0x10, 0x13, 0x10, 0x13, 0x16, 0x16,
	0x16, 0x16, 0x16, 0x16, 0x1A, 0x18, 0x1A, 0x1B,
	0x1B, 0x1B, 0x1A, 0x1A, 0x1A, 0x1A, 0x1B, 0x1B,
	0x1B, 0x1D, 0x1D, 0x1D, 0x22, 0x22, 0x22, 0x1D,
	0x1D, 0x1D, 0x1B, 0x1B, 0x1D, 0x1D, 0x20, 0x20,
	0x22, 0x22, 0x25, 0x26, 0x25, 0x23, 0x23, 0x22,
	0x23, 0x26, 0x26, 0x28, 0x28, 0x28, 0x30, 0x30,
	0x2E, 0x2E, 0x38, 0x38, 0x3A, 0x45, 0x45, 0x53
	};

const static int PictureRate[]    = {     0, 23976, 24000, 25000,
												  29970, 30000, 50000, 59940,
												  60000, 30002,     0,     0,
												  30001,     0,     0,     0};

void VideoStreamParser::ParseSequenceHeader(void)
	{
	QuantizationMatrix	mat;
	int i;

	if (bitStream->GetBits(32) != SEQUENCE_HEADER_CODE)
		{
//		::OutputDebugString("No sequence header\n");
		throw VideoStreamSyntaxError(1);
		}

	sequenceWidth = (WORD)bitStream->GetBits(12);
	sequenceHeight = (WORD)bitStream->GetBits(12);
	sequenceAspectRatio = bitStream->GetBits(4); // aspect ratio

	if (sequenceWidth > 720 || sequenceHeight > 576) throw VideoStreamSyntaxError(2);

	pictureParser->SetImageSize((sequenceWidth + 15) & ~15, (sequenceHeight + 15) & ~15, sequenceAspectRatio);


	sequenceFPS = bitStream->GetBits(4); // frame rate code
	if (!PictureRate[sequenceFPS]) throw VideoStreamSyntaxError(3);

	pictureParser->SetFrameRate(PictureRate[sequenceFPS]);
	bitStream->GetBits(18); // bit rate value;

	if (!bitStream->GetBits(1)) throw VideoStreamSyntaxError(4);

	bitStream->GetBits(10); // vbv buffer size
	bitStream->GetBits(1); // constrained parameter flag

	if (bitStream->GetBits(1))
		{
		for (i=0; i<64; i++) mat[i] = bitStream->GetBits(8);
		pictureParser->SetQuantMatrix(LUMA_INTRA_QUANTMATRIX, mat);
		pictureParser->SetQuantMatrix(CHROMA_INTRA_QUANTMATRIX, mat);
		usingDefaultQuantizerTable[0] = FALSE;
		}
	else if (!usingDefaultQuantizerTable[0])
		{
		pictureParser->SetQuantMatrix(LUMA_INTRA_QUANTMATRIX, DefIntraQuantMatrix);
		pictureParser->SetQuantMatrix(CHROMA_INTRA_QUANTMATRIX, DefIntraQuantMatrix);
		usingDefaultQuantizerTable[0] = TRUE;
		}

	if (bitStream->GetBits(1))
		{
		for (i=0; i<64; i++) mat[i] = bitStream->GetBits(8);
		pictureParser->SetQuantMatrix(LUMA_NONINTRA_QUANTMATRIX, mat);
		pictureParser->SetQuantMatrix(CHROMA_NONINTRA_QUANTMATRIX, mat);
		usingDefaultQuantizerTable[1] = FALSE;
		}
	else if (!usingDefaultQuantizerTable[1])
		{
		for(i=0; i<64; i++) mat[i] = 16;
		pictureParser->SetQuantMatrix(LUMA_NONINTRA_QUANTMATRIX, mat);
		pictureParser->SetQuantMatrix(CHROMA_NONINTRA_QUANTMATRIX, mat);
		usingDefaultQuantizerTable[1] = TRUE;
		}


	hasValidSequenceHeader = TRUE;

	bitStream->NextStartCode();
	}

void VideoStreamParser::ParseExtensionAndUserData(void)
	{
	DWORD ext;

	for(;;)
		{
		if (bitStream->PeekBits(32) == EXTENSION_START_CODE)
			{
			bitStream->Advance(32);
			switch(ext = bitStream->PeekBits(4))
				{
				case SEQUENCE_DISPLAY_EXTENSION_ID:
					ParseSequenceDisplayExtension();
					break;
				case SEQUENCE_EXTENSION_ID:
					ParseSequenceExtension();
					break;
				default:
//					PMMSGX("Unknown sequence extension %02x\n", ext);
//					bitStream->NextStartCode();
					throw VideoStreamSyntaxError(5);
				}
			}
		else if (bitStream->PeekBits(32) == USER_DATA_START_CODE)
			{
			ParseUserData();
//			bitStream->Advance(32);
//			while (bitStream->PeekBits(24) != 0x000001) bitStream->Advance(8);
			}
		else
			break;
		}
	bitStream->NextStartCode();
	}

void VideoStreamParser::ParseSequenceExtension(void)
	{
	if (bitStream->GetBits(4) != SEQUENCE_EXTENSION_ID) throw VideoStreamSyntaxError(6);

	bitStream->GetBits(8); // profile and level
	progressiveSequence = bitStream->GetBits(1) !=0; // progressive sequence
	pictureParser->SetProgressiveSequence(progressiveSequence);
	bitStream->GetBits(2); // chroma format
	bitStream->GetBits(2); // horizontal size extension
	bitStream->GetBits(2); // vertical size extension
	bitStream->GetBits(12); // bit rate extension

	if (!bitStream->GetBits(1)) throw VideoStreamSyntaxError(7);

	bitStream->GetBits(8); // vbv buffer size extension
	bitStream->GetBits(1); // low delay
	bitStream->GetBits(2); // frame rate extension n
	bitStream->GetBits(5); // frame rate extension m

	bitStream->NextStartCode();
	}

void VideoStreamParser::ParseSequenceDisplayExtension(void)
	{
	if (bitStream->GetBits(4) != SEQUENCE_DISPLAY_EXTENSION_ID) throw VideoStreamSyntaxError(8);

	bitStream->GetBits(3); // video format
	if (bitStream->GetBits(1)) // color description
		{
		bitStream->GetBits(8); // color primaries
		bitStream->GetBits(8); // transfer characteristics
		bitStream->GetBits(8); // matrix coefficients
		}

	bitStream->GetBits(14); // display horizontal size
	if (!bitStream->GetBits(1)) throw VideoStreamSyntaxError(9);
	bitStream->GetBits(14); // display vertical size

	bitStream->NextStartCode();
	}

void VideoStreamParser::ParseGroupOfPicturesHeader(void)
	{
	if (bitStream->GetBits(32) != GROUP_START_CODE) throw VideoStreamSyntaxError(10);

	bitStream->GetBits(25); // time code
	if (bitStream->GetBits(1)) pictureParser->SetClosedGOP();
	if (bitStream->GetBits(1)) pictureParser->SetBrokenLink();

	bitStream->NextStartCode();
	}

void VideoStreamParser::PreParseVideoSequence(void)
	{
	DWORD header;
	int i, prev;
	int displayPosition;

	numGOPFrames = 0;

	if (bitStream->PeekBits(32) == SEQUENCE_HEADER_CODE)
		{
		do {
			ParseSequenceHeader();
			if (bitStream->PeekBits(32) == EXTENSION_START_CODE)
				{
				pictureParser->SetVideoCodingStandard(VCS_MPEG_2);
				bitStream->Advance(32);

				ParseSequenceExtension();
				ParseExtensionAndUserData();
				do {
					if (bitStream->PeekBits(32) == GROUP_START_CODE)
						{
						ParseGroupOfPicturesHeader();
						ParseExtensionAndUserData();
						}

					if (!bitStream->RefillBuffer()) return;
					header = bitStream->PeekBits(32);
					while (header != PICTURE_START_CODE &&
							 header != GROUP_START_CODE &&
							 header != SEQUENCE_HEADER_CODE &&
							 header != SEQUENCE_END_CODE)
						{
						bitStream->Advance(8);
						bitStream->NextStartCode();
						if (!bitStream->RefillBuffer()) return;
						header = bitStream->PeekBits(32);
						}

					while (header == PICTURE_START_CODE)
						{
						gopFrameData[gopFrameDataIndex][numGOPFrames].position = bitStream->CurrentLocation();
						pictureParser->PreParse(gopFrameData[gopFrameDataIndex][numGOPFrames].codingType);
						numGOPFrames++;

						if (!bitStream->RefillBuffer()) return;
						header = bitStream->PeekBits(32);
						while (header != PICTURE_START_CODE &&
								 header != GROUP_START_CODE &&
								 header != SEQUENCE_HEADER_CODE &&
								 header != SEQUENCE_END_CODE)
							{
							bitStream->Advance(8);
							bitStream->NextStartCode();
							if (!bitStream->RefillBuffer()) return;
							header = bitStream->PeekBits(32);
							}
						}

					} while (header == GROUP_START_CODE);
				}
			} while (header == SEQUENCE_HEADER_CODE);
		}
	else
		throw VideoStreamSyntaxError(11);

	if (header == SEQUENCE_END_CODE)
		{
		bitStream->Advance(32);
		}

	nextGOPPosition = bitStream->CurrentLocation();

	displayPosition = 0;
	prev = -1;

	firstGOPIPFrame = -1;
	for(i=0; i<numGOPFrames; i++)
		{
		if (gopFrameData[gopFrameDataIndex][i].codingType != BIDIRECTIONAL_PREDICTIVE_CODED)
			{
			if (firstGOPIPFrame == -1) firstGOPIPFrame = i;
			lastGOPIPFrame = i;

			if (prev >= 0)
				{
				gopFrameData[gopFrameDataIndex][prev].displayPosition = displayPosition;
				displayPosition++;
				}

			prev = i;
			}
		else
			{
			gopFrameData[gopFrameDataIndex][i].displayPosition = displayPosition;
			displayPosition++;
			}

		if (gopFrameData[gopFrameDataIndex][i].codingType == INTRA_CODED)
			{
			lastGOPIFrame = i;
			}

		}

	gopFrameData[gopFrameDataIndex][prev].displayPosition = displayPosition;

	for(i=0; i<numGOPFrames; i++)
		{
		gopFrameData[gopFrameDataIndex][gopFrameData[gopFrameDataIndex][i].displayPosition].displayFrame = i;
		}
	}

void VideoStreamParser::ParseVideoSequenceTrick(void)
	{
	bool backward, prevGOPValid, nextGOPPrefetched;
	int numGOPPrefetched;
	int targetFrameID;
	int frameID, frame, i;
	__int64 currentGOPPosition;
	int prevLastGOPIFrame, prevNumFrames;
	int lastIPFrameDecoded;

	gopFrameDataIndex = 0;
	backward = FALSE;
	prevGOPValid = FALSE;
	nextGOPPrefetched = FALSE;
	currentGOPPosition = 0;
	numGOPPrefetched = 0;

	bitStream->MarkResetPosition();

	PreParseVideoSequence();

	requestedFrameID = currentFrameID = gopFrameData[gopFrameDataIndex][firstGOPIPFrame].displayPosition;
	bitStream->SetCurrentLocation(gopFrameData[gopFrameDataIndex][firstGOPIPFrame].position);
	pictureParser->Parse(PPM_DECODE_AND_DISPLAY);
	lastIPFrameDecoded = 0;

	while (!terminate)
		{
		targetFrameID = requestedFrameID;

		while (!terminate && targetFrameID != currentFrameID)
			{
			if (requestedFrameID > currentFrameID)
				{
				if (backward)
					{
					if (prevGOPValid)
						{
						bitStream->SetCurrentLocation(currentGOPPosition);
						bitStream->MarkResetPosition();

						prevGOPValid = FALSE;
						}
					if (nextGOPPrefetched)
						{
						WaitForSegmentCompleted();
						currentSegmentIndex++;
						nextGOPPrefetched = FALSE;
						}
					bitStream->SetFillLocation(nextGOPPosition);
					currentSegmentIndex += numGOPPrefetched;
					numGOPPrefetched = 0;
					lastIPFrameDecoded = -1;
					backward = FALSE;
					}

				frameID = targetFrameID - firstFrameID;
				while (frameID >= numGOPFrames)
					{
					if (numGOPPrefetched || nextGOPPrefetched || currentSegmentIndex < lastSegmentIndex)
						{
						frameID -= numGOPFrames;
						firstFrameID += numGOPFrames;

						currentGOPPosition = nextGOPPosition;
						prevGOPValid = TRUE;
						prevLastGOPIFrame = lastGOPIFrame;
						prevNumFrames = numGOPFrames;
						gopFrameDataIndex = 1 - gopFrameDataIndex;
						bitStream->SetCurrentLocation(currentGOPPosition);

						if (numGOPPrefetched)
							{
							numGOPPrefetched--;
							}
						else if (nextGOPPrefetched)
							{
							nextGOPPrefetched = FALSE;
							}
						else
							{
							currentSegmentIndex++;
							TrickSegmentRequested();
							}

						bitStream->RefillBuffer();
						bitStream->NextStartCode();

						PreParseVideoSequence();
						}
					else
						{
						frameID = numGOPFrames - 1;
						firstFrameID = targetFrameID - frameID;

						if (errorMessenger) errorMessenger->PostErrorMessage(GNR_FRAME_ADVANCE_BOUNDARY_REACHED);
						}
					}

				if (frameID >= gopFrameData[gopFrameDataIndex][firstGOPIPFrame].displayPosition)
					{
					if (prevGOPValid)
						{
						bitStream->SetCurrentLocation(currentGOPPosition);
						bitStream->MarkResetPosition();

						prevGOPValid = FALSE;
						}
					if (!nextGOPPrefetched)
						{
						if (currentSegmentIndex < lastSegmentIndex && numGOPPrefetched < 2)
							{
							currentSegmentIndex++;
							TrickSegmentRequested();
							nextGOPPrefetched = TRUE;
							}
						}
					else if (IsSegmentCompleted())
						{
						numGOPPrefetched++;
						nextGOPPrefetched = FALSE;
						}
					}
				else if (prevGOPValid)
					{
					i = prevLastGOPIFrame;
					while (i < prevNumFrames)
						{
						if (gopFrameData[1 - gopFrameDataIndex][i].codingType != BIDIRECTIONAL_PREDICTIVE_CODED)
							{
							bitStream->SetCurrentLocation(gopFrameData[1 - gopFrameDataIndex][i].position);
							pictureParser->Parse(PPM_DECODE_AND_KEEP);
							}
						i++;
						}

					bitStream->SetCurrentLocation(currentGOPPosition);
					bitStream->MarkResetPosition();

					prevGOPValid = FALSE;
					}

				frame = gopFrameData[gopFrameDataIndex][frameID].displayFrame;

				i = frame;

				while (gopFrameData[gopFrameDataIndex][i].codingType != INTRA_CODED) i--;
				if (i <= lastIPFrameDecoded && frame > lastIPFrameDecoded) i = lastIPFrameDecoded + 1;

				while (i < frame)
					{
					if (gopFrameData[gopFrameDataIndex][i].codingType != BIDIRECTIONAL_PREDICTIVE_CODED)
						{
						bitStream->SetCurrentLocation(gopFrameData[gopFrameDataIndex][i].position);
						pictureParser->Parse(PPM_DECODE_AND_KEEP);
						lastIPFrameDecoded = i;
						}
					i++;
					}

				bitStream->SetCurrentLocation(gopFrameData[gopFrameDataIndex][i].position);
				pictureParser->Parse(PPM_DECODE_AND_DISPLAY);
				if (gopFrameData[gopFrameDataIndex][i].codingType != BIDIRECTIONAL_PREDICTIVE_CODED)
					lastIPFrameDecoded = i;

				currentFrameID = targetFrameID;
				}
			else
				{
				if (!backward)
					{
					if (prevGOPValid)
						{
						bitStream->SetCurrentLocation(currentGOPPosition);
						bitStream->MarkResetPosition();

						prevGOPValid = FALSE;
						}
					if (nextGOPPrefetched)
						{
						WaitForSegmentCompleted();
						currentSegmentIndex--;
						nextGOPPrefetched = FALSE;
						}
					bitStream->SetFillLocation(nextGOPPosition);
					currentSegmentIndex -= numGOPPrefetched;
					numGOPPrefetched = 0;

					// fill in here
					backward = TRUE;
					lastIPFrameDecoded = -1;
					}

				frameID = targetFrameID - firstFrameID;
				while (frameID < gopFrameData[gopFrameDataIndex][firstGOPIPFrame].displayPosition)
					{
					if (numGOPPrefetched || nextGOPPrefetched || currentSegmentIndex > firstSegmentIndex)
						{
						currentGOPPosition = nextGOPPosition;
						prevGOPValid = TRUE;
						prevLastGOPIFrame = lastGOPIFrame;
						prevNumFrames = numGOPFrames;
						lastIPFrameDecoded = -1;
						gopFrameDataIndex = 1 - gopFrameDataIndex;
						bitStream->SetCurrentLocation(currentGOPPosition);

						if (numGOPPrefetched)
							numGOPPrefetched--;
						else if (nextGOPPrefetched)
							nextGOPPrefetched = FALSE;
						else
							{
							currentSegmentIndex--;
							TrickSegmentRequested();
							}

						bitStream->RefillBuffer();
						bitStream->NextStartCode();

						PreParseVideoSequence();

						frameID += numGOPFrames;
						firstFrameID -= numGOPFrames;
						}
					else
						{
						frameID = gopFrameData[gopFrameDataIndex][firstGOPIPFrame].displayPosition;
						firstFrameID = targetFrameID - frameID;
						if (errorMessenger) errorMessenger->PostErrorMessage(GNR_FRAME_ADVANCE_BOUNDARY_REACHED);
						}
					}

				if (frameID < numGOPFrames)
					{
					if (prevGOPValid)
						{
						bitStream->SetCurrentLocation(currentGOPPosition);
						bitStream->MarkResetPosition();

						prevGOPValid = FALSE;
						}
					if (!nextGOPPrefetched)
						{
						if (currentSegmentIndex > firstSegmentIndex  && numGOPPrefetched < 2)
							{
							currentSegmentIndex--;
							TrickSegmentRequested();
							nextGOPPrefetched = TRUE;
							}
						}
					else if (IsSegmentCompleted())
						{
						numGOPPrefetched++;
						nextGOPPrefetched = FALSE;
						}

					frame = gopFrameData[gopFrameDataIndex][frameID].displayFrame;

					i = frame;

					while (gopFrameData[gopFrameDataIndex][i].codingType != INTRA_CODED) i--;
					if (i <= lastIPFrameDecoded && frame > lastIPFrameDecoded) i = lastIPFrameDecoded + 1;

					while (i < frame)
						{
						if (gopFrameData[gopFrameDataIndex][i].codingType != BIDIRECTIONAL_PREDICTIVE_CODED)
							{
							bitStream->SetCurrentLocation(gopFrameData[gopFrameDataIndex][i].position);
							pictureParser->Parse(PPM_DECODE_AND_KEEP);
							lastIPFrameDecoded = i;
							}
						i++;
						}

					bitStream->SetCurrentLocation(gopFrameData[gopFrameDataIndex][i].position);
					pictureParser->Parse(PPM_DECODE_AND_DISPLAY);
					if (gopFrameData[gopFrameDataIndex][i].codingType != BIDIRECTIONAL_PREDICTIVE_CODED)
						lastIPFrameDecoded = i;
					}
				else if (prevGOPValid)
					{
					i = lastGOPIFrame;
					while (i < numGOPFrames)
						{
						if (gopFrameData[gopFrameDataIndex][i].codingType != BIDIRECTIONAL_PREDICTIVE_CODED)
							{
							bitStream->SetCurrentLocation(gopFrameData[gopFrameDataIndex][i].position);
							pictureParser->Parse(PPM_DECODE_AND_KEEP);
							}
						i++;
						}

					frame = gopFrameData[1 - gopFrameDataIndex][frameID - numGOPFrames].displayFrame;

					i = 0;

					while (i < frame)
						{
						if (gopFrameData[1 - gopFrameDataIndex][i].codingType != BIDIRECTIONAL_PREDICTIVE_CODED)
							{
							bitStream->SetCurrentLocation(gopFrameData[1 - gopFrameDataIndex][i].position);
							pictureParser->Parse(PPM_DECODE_AND_KEEP);
							}
						i++;
						}

					bitStream->SetCurrentLocation(gopFrameData[1 - gopFrameDataIndex][i].position);
					pictureParser->Parse(PPM_DECODE_AND_DISPLAY);

					bitStream->SetCurrentLocation(currentGOPPosition);
					bitStream->MarkResetPosition();

					lastIPFrameDecoded = -1;
					prevGOPValid = FALSE;
					}
				else
					{
					frame = gopFrameData[1 - gopFrameDataIndex][frameID - numGOPFrames].displayFrame;
					bitStream->SetCurrentLocation(gopFrameData[1 - gopFrameDataIndex][frame].position);
					pictureParser->Parse(PPM_DECODE_AND_DISPLAY);
					}

				currentFrameID = targetFrameID;
				}

			targetFrameID = requestedFrameID;
			}
		event.WaitForever();
		}
	}

void VideoStreamParser::ParseVideoSequenceReverse(void)
	{
	int pastIFrame, futureIFrame;
	int pastIPFrame, futureIPFrame;
	int currentFrame;
	__int64 tempNextGOPPosition;
	int tempNumGOPFrames;

	gopFrameDataIndex = 0;

	bitStream->MarkResetPosition();

	PreParseVideoSequence();
	if (!bitStream->RefillBuffer()) return;

	bitStream->SetCurrentLocation(gopFrameData[gopFrameDataIndex][lastGOPIFrame].position);

	pictureParser->Parse(PPM_DECODE_AND_DISPLAY);
	futureIFrame = lastGOPIFrame;

	pastIFrame = futureIFrame;
	for(;;)
		{
		do {
			pastIFrame--;
			} while (pastIFrame >= 0 && gopFrameData[gopFrameDataIndex][pastIFrame].codingType != INTRA_CODED);

		if (pastIFrame < 0)
			{
			// no more I Frames before this GOP

			gopFrameDataIndex = 1 - gopFrameDataIndex;
			bitStream->SetCurrentLocation(nextGOPPosition);
			tempNextGOPPosition = nextGOPPosition;
			tempNumGOPFrames = numGOPFrames;

			PreParseVideoSequence();
			if (!bitStream->RefillBuffer()) return;

			pastIFrame = lastGOPIFrame;

			pastIPFrame = lastGOPIPFrame;
			futureIPFrame = futureIFrame;

			currentFrame = pastIFrame;
			while (currentFrame != pastIPFrame)
				{
				bitStream->SetCurrentLocation(gopFrameData[gopFrameDataIndex][currentFrame].position);
				pictureParser->Parse(PPM_DECODE_AND_DROP);

				do {
					currentFrame++;
					} while (gopFrameData[gopFrameDataIndex][currentFrame].codingType == BIDIRECTIONAL_PREDICTIVE_CODED);
				}

			bitStream->SetCurrentLocation(gopFrameData[gopFrameDataIndex][currentFrame].position);
			pictureParser->Parse(PPM_DECODE_AND_DISPLAY);

			currentFrame = futureIPFrame;
			do {
				currentFrame++;
				} while (currentFrame < tempNumGOPFrames && gopFrameData[1 - gopFrameDataIndex][currentFrame].codingType == BIDIRECTIONAL_PREDICTIVE_CODED);
			currentFrame--;

			while (currentFrame > futureIPFrame)
				{
				bitStream->SetCurrentLocation(gopFrameData[1 - gopFrameDataIndex][currentFrame].position);
				pictureParser->Parse(PPM_DECODE_AND_DISPLAY);
				currentFrame--;
				}

			futureIPFrame = pastIPFrame;

			bitStream->SetCurrentLocation(tempNextGOPPosition);
			bitStream->MarkResetPosition();
			}
		else
			{
			pastIPFrame = futureIFrame;
			futureIPFrame = futureIFrame;
			}

		while (pastIPFrame != pastIFrame)
			{
			do {
				pastIPFrame--;
				} while (gopFrameData[gopFrameDataIndex][pastIPFrame].codingType == BIDIRECTIONAL_PREDICTIVE_CODED);

			currentFrame = pastIFrame;
			while (currentFrame != pastIPFrame)
				{
				bitStream->SetCurrentLocation(gopFrameData[gopFrameDataIndex][currentFrame].position);
				pictureParser->Parse(PPM_DECODE_AND_DROP);

				do {
					currentFrame++;
					} while (gopFrameData[gopFrameDataIndex][currentFrame].codingType == BIDIRECTIONAL_PREDICTIVE_CODED);
				}

			bitStream->SetCurrentLocation(gopFrameData[gopFrameDataIndex][currentFrame].position);
			pictureParser->Parse(PPM_DECODE_AND_DISPLAY);

			currentFrame = futureIPFrame;
			do {
				currentFrame++;
				} while (currentFrame < numGOPFrames && gopFrameData[gopFrameDataIndex][currentFrame].codingType == BIDIRECTIONAL_PREDICTIVE_CODED);
			currentFrame--;

			while (currentFrame > futureIPFrame)
				{
				bitStream->SetCurrentLocation(gopFrameData[gopFrameDataIndex][currentFrame].position);
				pictureParser->Parse(PPM_DECODE_AND_DISPLAY);
				currentFrame--;
				}

			futureIPFrame = pastIPFrame;
			}

		futureIFrame = pastIFrame;
		}
	}

void VideoStreamParser::ParseMPEG1GroupOfPictures(DWORD & header)
	{
	do {
		ParseGroupOfPicturesHeader();
		ParseExtensionAndUserData();
		do {
			pictureParser->Parse(PPM_DECODE_AND_DISPLAY);
			if (!bitStream->RefillBuffer()) return;
			header = bitStream->PeekBits(32);
			while ((playbackMode == VDPM_SCANNING || header != PICTURE_START_CODE &&
								     header != GROUP_START_CODE &&
								     header != SEQUENCE_END_CODE) &&
					 header != SEQUENCE_HEADER_CODE)
				{

				bitStream->Advance(8);
				bitStream->NextStartCode();
				if (!bitStream->RefillBuffer()) return;
				header = bitStream->PeekBits(32);
				}
			} while (bitStream->PeekBits(32) == PICTURE_START_CODE);
		} while (bitStream->PeekBits(32) == GROUP_START_CODE);
	}

void VideoStreamParser::ParseVideoSequence(void)
	{
	DWORD header;
	__int64 videoBitBufferPosition;

	if (bitStream->PeekBits(32) == SEQUENCE_HEADER_CODE)
		{
		ParseSequenceHeader();
		if (bitStream->PeekBits(32) == EXTENSION_START_CODE)
			{
			pictureParser->SetVideoCodingStandard(VCS_MPEG_2);
			bitStream->Advance(32);

			ParseSequenceExtension();
			do {
				ParseExtensionAndUserData();
				do {
					if (bitStream->PeekBits(32) == GROUP_START_CODE)
						{
						ParseGroupOfPicturesHeader();
						ParseExtensionAndUserData();
						}

					if (!bitStream->RefillBuffer()) return;
					header = bitStream->PeekBits(32);
					while (header != PICTURE_START_CODE &&
							 header != GROUP_START_CODE &&
							 header != SEQUENCE_HEADER_CODE &&
							 header != SEQUENCE_END_CODE)
						{
						bitStream->Advance(8);
						bitStream->NextStartCode();
						if (!bitStream->RefillBuffer()) return;
						header = bitStream->PeekBits(32);
						}

					while (header == PICTURE_START_CODE)
						{
						pictureParser->Parse(PPM_DECODE_AND_DISPLAY);
						if (!bitStream->RefillBuffer()) return;
						header = bitStream->PeekBits(32);
						while (header != PICTURE_START_CODE &&
								 header != GROUP_START_CODE &&
								 header != SEQUENCE_HEADER_CODE &&
								 header != SEQUENCE_END_CODE)
							{
							bitStream->Advance(8);
							bitStream->NextStartCode();
							if (!bitStream->RefillBuffer()) return;
							header = bitStream->PeekBits(32);
							}

						videoBitBufferPosition = bitStream->CurrentLocation();
						perfmon.videoBitsProcessed += videoBitBufferPosition - prevVideoBitBufferPosition;
						prevVideoBitBufferPosition = videoBitBufferPosition;
						}

					} while (header == GROUP_START_CODE);

				if (header != SEQUENCE_END_CODE)
					{
					ParseSequenceHeader();
					if (bitStream->GetBits(32) == EXTENSION_START_CODE)
						ParseSequenceExtension();
					else
						throw VideoStreamSyntaxError(12);
					}
				} while (bitStream->PeekBits(32) != SEQUENCE_END_CODE);

			bitStream->Advance(32);
			}
		else
			{
			pictureParser->SetVideoCodingStandard(VCS_MPEG_1);

			do {
				ParseExtensionAndUserData();

				ParseMPEG1GroupOfPictures(header);

				if (header != SEQUENCE_END_CODE)
					{
					ParseSequenceHeader();
					}

				} while (bitStream->PeekBits(32) != SEQUENCE_END_CODE);
			}
		}
	else if (bitStream->PeekBits(32) == GROUP_START_CODE)
		{
		pictureParser->SetImageSize((sequenceWidth + 15) & ~15, (sequenceHeight + 15) & ~15, sequenceAspectRatio);
		pictureParser->SetFrameRate(PictureRate[sequenceFPS]);
		pictureParser->SetVideoCodingStandard(VCS_MPEG_1);

		do {
			ParseMPEG1GroupOfPictures(header);

			if (header != SEQUENCE_END_CODE)
				{
				ParseSequenceHeader();
				}

			} while (bitStream->PeekBits(32) != SEQUENCE_END_CODE);
		}
	else
		throw VideoStreamSyntaxError(13);
	}

VideoStreamParser::VideoStreamParser(GenericPictureParser * pictureParser, VideoBitStream * bitStream)
	: MPEGUserDataDecoder(bitStream), event(FALSE, TRUE)
	{
	this->pictureParser = pictureParser;
	this->bitStream = bitStream;
	prevVideoBitBufferPosition = 0;
	hasValidSequenceHeader = FALSE;
	errorMessenger = NULL;
	pictureParser->SetUserDataDecoder(this);
	}

void VideoStreamParser::Parse(void)
	{
	QuantizationMatrix mat;
	int i;
	DWORD bits;

	for(i=0; i<64; i++) mat[i] = 16;

	pictureParser->SetQuantMatrix(LUMA_INTRA_QUANTMATRIX, DefIntraQuantMatrix);
	pictureParser->SetQuantMatrix(CHROMA_INTRA_QUANTMATRIX, DefIntraQuantMatrix);
	pictureParser->SetQuantMatrix(LUMA_NONINTRA_QUANTMATRIX, mat);
	pictureParser->SetQuantMatrix(CHROMA_NONINTRA_QUANTMATRIX, mat);

	usingDefaultQuantizerTable[0] = TRUE;
	usingDefaultQuantizerTable[1] = TRUE;

	if (!bitStream->RefillBuffer(1400000)) return;

	bits = bitStream->PeekBits(32);
	while (!(bits == SEQUENCE_HEADER_CODE ||
		      hasValidSequenceHeader && bits == GROUP_START_CODE))
		{
		bitStream->Advance(8);

		bitStream->NextStartCode();

		if (!bitStream->RefillBuffer()) return;

		bits = bitStream->PeekBits(32);
		}

	try
		{
		switch (playbackMode)
			{
			case VDPM_PLAY_FORWARD:
				ParseVideoSequence();
				break;
			case VDPM_PLAY_BACKWARD:
				ParseVideoSequenceReverse();
				break;
			case VDPM_SCANNING:
				ParseVideoSequence();
				break;
			case VDPM_TRICKPLAY:
				ParseVideoSequenceTrick();
				break;
			}
		}
	catch(PictureHeaderSyntaxError)
		{
		PMMSG("Picture header syntax error\n");
		}
	catch (VideoStreamSyntaxError e)
		{
		PMMSGX("Video stream syntax error %d\n", e.subCode);
		}
	}


void VideoStreamParser::BeginStreaming(VideoPlaybackMode playbackMode)
	{
	this->playbackMode = playbackMode;
	switch (playbackMode)
		{
		case VDPM_PLAY_FORWARD:
		case VDPM_PLAY_BACKWARD:
		case VDPM_SCANNING:
			break;
		case VDPM_TRICKPLAY:
			terminate = FALSE;
			currentFrameID = 2;
			firstFrameID = 0;
			requestedFrameID = 2;
			currentSegmentIndex = 0x80000000;
			firstSegmentIndex = 0x00000000;
			lastSegmentIndex = 0xffffffff;
			break;
		}
	}

void VideoStreamParser::EndStreaming(bool fullReset)
	{
	terminate = TRUE;
	switch (playbackMode)
		{
		case VDPM_PLAY_FORWARD:
		case VDPM_PLAY_BACKWARD:
		case VDPM_SCANNING:
			break;
		case VDPM_TRICKPLAY:
			event.SetEvent();
			break;
		}
	playbackMode = VDPM_PLAY_FORWARD;
	prevVideoBitBufferPosition = 0;
	if (fullReset) hasValidSequenceHeader = FALSE;
	}

void VideoStreamParser::SetFirstVideoSegment(DWORD seg)
	{
	firstSegmentIndex = seg;
	}

void VideoStreamParser::SetLastVideoSegment(DWORD seg)
	{
	lastSegmentIndex = seg;
	}

DWORD VideoStreamParser::VideoSegmentRequested(void)
	{
	return currentSegmentIndex;
	}

void VideoStreamParser::AdvanceTrickFrame(int by)
	{
	requestedFrameID += by;
	event.SetEvent();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\SPUDecoder\SPUBitStream.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef SPUBITSTREAM_H
#define SPUBITSTREAM_H


#include "driver\SoftwareCinemaster\Common\Prelude.h"
#include "..\common\bitstreams.h"

#define SPU_STREAM_BUFFER_SIZE	(1 << 14)
#define SPU_STREAM_BUFFER_MASK	(SPU_STREAM_BUFFER_SIZE * 32 - 1)

extern DWORD SPUStreamBuffer[SPU_STREAM_BUFFER_SIZE+1];
extern int SPUSBits;

class SPUBitStream	: public BitStream
	{
	public:
		SPUBitStream(void);

		virtual ~SPUBitStream(void);

		int AddData(BYTE * ptr, int num);

		void StuffBuffer(void) {}

		virtual int AvailBits(void);

		BYTE GetByte(void);

		void GetBytes(BYTE * buffer, int num);

		void Advance(int bits);

		void ScrambleBuffer(void) {}

		void DescrambleBuffer(int numBits) {}
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\SPUDecoder\SPUBitStream.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#include "SPUBitStream.h"

DWORD		SPUStreamBuffer[SPU_STREAM_BUFFER_SIZE+1];
int		SPUSBits;

SPUBitStream::SPUBitStream(void)
	: BitStream(SPUStreamBuffer, SPU_STREAM_BUFFER_SIZE, SPUSBits, NULL, TRUE)
	{
	}

SPUBitStream::~SPUBitStream(void)
	{
	}

BYTE SPUBitStream::GetByte(void)
	{
	BYTE b;

	b = ((BYTE *)buffer)[(bsbits & SPU_STREAM_BUFFER_MASK)>> 3];
	bsbits += 8;

	return b;
	}

void SPUBitStream::GetBytes(BYTE * buffer, int num)
	{
	while (num)
		{
		*buffer++ = GetByte();
		num--;
		}
	}

int SPUBitStream::AvailBits(void)
	{
	int avail;

	first = ((bsbits & mask) >> 3);

	if (first > last)
		avail = (size * 4 - (first - last)) * 8;
	else
		avail = (last - first) * 8;

	if (avail > lastAvail) avail = 0;
	else lastAvail = avail;

	return avail;
	}

void SPUBitStream::Advance(int bits)
	{
	bsbits += bits;
	}

int SPUBitStream::AddData(BYTE * ptr, int num)
	{
	int done;

	first = ((bsbits & mask) >> 5) << 2;

	if (first > last)
		{
		done = first-last-4;
		if (done > 0)
			{
			if (done > num) done = num;
			memcpy(((char *)buffer)+last, ptr, done);
			last += done;
			}
		else
			done = 0;
		}
	else if (first)
		{
		done = size * 4 - last;
		if (done)
			{
			if (done > num) done = num;
			memcpy(((char *)buffer)+last, ptr, done);
			last += done;
			}
		if (done < num)
			{
			ptr += done;
			num -= done;
			if (num > first-4) num = first-4;
			if (num > 0)
				{
				bufferStart += size * 32;

				memcpy(buffer, ptr, num);
				last = num;
				done += num;
				}
			}
		else if (last == size * 4)
			{
			bufferStart += size * 32;
			last = 0;
			}
		}
	else
		{
		done = size * 4 - last - 4;
		if (done > 0)
			{
			if (done > num) done = num;
			memcpy(((char *)buffer)+last, ptr, done);
			last += done;
			}
		else
			done = 0;
		}

	buffer[size] = buffer[0];
	lastAvail = size * 32;

	return done;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\MPEGDecoder\VideoStreamParser.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef VIDEOSTREAMPARSER_H
#define VIDEOSTREAMPARSER_H

#include "huffdec.h"
#include "MPEGUserDataDecoder.h"
#include "..\common\TimedFibers.h"
#include "..\common\ASyncErrorMessages.h"

typedef int QuantizationMatrix[64];

enum QuantMatrices
	{
	LUMA_INTRA_QUANTMATRIX,
	LUMA_NONINTRA_QUANTMATRIX,
	CHROMA_INTRA_QUANTMATRIX,
	CHROMA_NONINTRA_QUANTMATRIX
	};

enum VideoCodingStandard
	{
	VCS_MPEG_1,
	VCS_MPEG_2
	};

enum VideoPlaybackMode
	{
	VDPM_PLAY_FORWARD,
	VDPM_PLAY_BACKWARD,
	VDPM_SCANNING,
	VDPM_TRICKPLAY
	};

enum PictureCodingType
	{
	INTRA_CODED	= 1,
	PREDICTIVE_CODED = 2,
	BIDIRECTIONAL_PREDICTIVE_CODED = 3
	};

enum PictureDecodeMode
	{
	PPM_DECODE_AND_DISPLAY,
	PPM_DECODE_AND_DROP,
	PPM_DECODE_AND_KEEP,
	};

class GenericPictureParser
	{
	protected:
		MPEGUserDataDecoder * userDataDecoder;
	public:
		void SetUserDataDecoder(MPEGUserDataDecoder * userDataDecoder) {this->userDataDecoder = userDataDecoder;}
		virtual void SetVideoCodingStandard(VideoCodingStandard vcd) = 0;
		virtual void SetFrameRate(int framesPerSecond) = 0;
		virtual void SetImageSize(int width, int height, int aspectRatio) = 0;
		virtual void SetQuantMatrix(QuantMatrices type, const QuantizationMatrix & matrix) = 0;
		virtual void SetClosedGOP(void) = 0;
		virtual void SetBrokenLink(void) = 0;
		virtual void SetProgressiveSequence(bool progressiveSequence) = 0;

		virtual void Parse(PictureDecodeMode mode) = 0;
		virtual void PreParse(PictureCodingType & codingType) = 0;
	};

class VideoStreamSyntaxError : public Exception
	{
	public:
		int	subCode;
		VideoStreamSyntaxError(int subCode) {this->subCode = subCode;}
	};

class PictureHeaderSyntaxError : public Exception {};

class VideoStreamParser : public MPEGUserDataDecoder
	{
	protected:
		GenericPictureParser	*	pictureParser;
		VideoBitStream			*	bitStream;
		VideoPlaybackMode			playbackMode;
		__int64						prevVideoBitBufferPosition;
		TimedFiberEvent			event;
		volatile bool				terminate;

		struct GOPFrameData
			{
			PictureCodingType		codingType;
			__int64					position;
			int						displayPosition;
			int						displayFrame;
			} gopFrameData[2][32];

		int							gopFrameDataIndex;
		int							numGOPFrames;
		int							currentGOPFrame;
		int							firstGOPIPFrame;
		int							lastGOPIPFrame;
		int							lastGOPIFrame;
		__int64						nextGOPPosition;
		volatile int				requestedFrameID;
		int							currentFrameID;
		int							firstFrameID;
		DWORD							currentSegmentIndex;
		DWORD							firstSegmentIndex, lastSegmentIndex;

		bool							usingDefaultQuantizerTable[2];
		bool							hasValidSequenceHeader;
		bool							progressiveSequence;

		int							sequenceWidth, sequenceHeight, sequenceFPS, sequenceAspectRatio;
		ASyncErrorMessenger	*	errorMessenger;

		enum GOPFrameState
			{
			GFS_INITIAL,
			GFS_PREFRAMES,
			GFS_POSTFRAMES
			};

		void PreParseVideoSequence(void);
		void ParseVideoSequenceReverse(void);
		void ParseVideoSequenceTrick(void);

		void ParseVideoSequence(void);
		void ParseMPEG1GroupOfPictures(DWORD & header);

		void ParseSequenceHeader(void);
		void ParseExtensionAndUserData(void);
		void ParseSequenceExtension(void);
		void ParseSequenceDisplayExtension(void);
		void ParseGroupOfPicturesHeader(void);

		virtual void TrickSegmentRequested(void) = 0;
		virtual void WaitForSegmentCompleted(void) = 0;
		virtual bool IsSegmentCompleted(void) = 0;
	public:
		VideoStreamParser(GenericPictureParser * pictureParser, VideoBitStream * bitStream);

		void BeginStreaming(VideoPlaybackMode playbackMode);
		void EndStreaming(bool fullReset);

		void Parse(void);

		DWORD VideoSegmentRequested(void);
		void SetFirstVideoSegment(DWORD seg);
		void SetLastVideoSegment(DWORD seg);
		void AdvanceTrickFrame(int by);

		void SetErrorMessenger(ASyncErrorMessenger * errorMessenger) {this->errorMessenger = errorMessenger;}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\SPUDecoder\SPUDecoder.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef SPUDECODER_H
#define SPUDECODER_H

#include "..\video\VideoDisplay.h"
#include "..\video\FrameStore.h"
#include "SPUBitStream.h"
#include "SPUDisplay.h"


class SPUDecoder
	{
	protected:
		SPUBitStream				*	stream;
		SPUDisplay					*	display;
		volatile bool					terminate;
		bool								enable;
	public:
		SPUDecoder(SPUBitStream	*	stream,
					  SPUDisplay	*	display);

		virtual ~SPUDecoder(void);

		void Parse(void);

		void BeginStreaming(bool highQuality);

		void StartStreaming(int playbackSpeed);

		void StopStreaming(void);

		void EndStreaming(bool fullReset);

		void EnableSPU(bool enable) {display->EnableSPU(enable);}
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\SPUDecoder\SPUDisplay.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef SPUDISPLAY_H
#define SPUDISPLAY_H

#include "..\video\VideoDisplay.h"
#include "..\video\FrameStore.h"
#include "..\common\TimedFibers.h"

enum XSPUButtonState
	{
	XSBS_DISABLED,
	XSBS_SELECTED,
	XSBS_ACTIVATED
	};


#define NUM_OSD_BITMAPS		16

class SPUDisplay : private TimedFiber
	{
	protected:
		GenericPictureDisplay	*	display;
		TimedFiberMutex				lock;
		TimedFiberEvent				event, queueEvent;

		volatile bool					terminate;
		volatile bool					pause;
		bool								streaming;

		SPUColorEntry					palette[16];
		DWORD								newSelectedColors, newActiveColors;
		DWORD								normalColors, selectedColors, activeColors;
		int								buttonX, buttonY, buttonW, buttonH;
		XSPUButtonState				buttonState;
		bool								buttonChanged;
		bool								osdActive;
		SPUDisplayBufferFactory	*	highQualityOsdFactory, * lowQualityOsdFactory;
		TimingClient					timingClient;
		bool								enable;

		struct OSDPendingQueue
			{
			int						startTime, stopTime;
			bool						posted, forced;
			DWORD						colors;
			SPUDisplayBuffer	*	map;
			XSPUButtonState		buttonState;
			} pendingQueue[NUM_OSD_BITMAPS];

		struct OSDAvailQueue
			{
			SPUDisplayBuffer	*	map;
			} availQueue[NUM_OSD_BITMAPS];

		volatile int					osdFirst, osdLast, osdAvail;

		void FiberRoutine(void);
	public:
		SPUDisplay(GenericPictureDisplay * display, SPUDisplayBufferFactory * highQualityOsdFactory, SPUDisplayBufferFactory * lowQualityOsdFactory);

		virtual ~SPUDisplay(void);

		void BeginStreaming(bool highQuality);

		void StartStreaming(int playbackSpeed);

		void StopStreaming(void);

		void EndStreaming(bool fullReset);


			// Hack for MS Navigator, if data discontinuity for
			// video arrives after the new subpicture data.
		void VideoDisplayBeginStreaming(void);

		void SetButtonState(XSPUButtonState state);

		void SetButtonPosition(int x, int y, int w, int h);

		void SetButtonColors(DWORD selected, DWORD active);

		void SetPalette(int entry, int y, int u, int v);

		void PostOSDBitmap(SPUDisplayBuffer * map, int startTime, DWORD colors, bool forced);

		void PostOSDStopTime(int stopTime);

		SPUDisplayBuffer * GetOSDBitmap(void);

		void EnableSPU(bool enable);
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\SPUDecoder\SPUDisplay.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#include "SPUDisplay.h"
#include "library\common\vddebug.h"
#include "..\common\TimedFibers.h"

#define DUMP_SPU_EVENTS		0

//
//  Fiber Routine
//

void SPUDisplay::FiberRoutine(void)
	{
	int time, stop, osdNext, start, num;

	lock.Enter();

	while (!terminate)
		{
		if (osdFirst != osdLast)
			{
			time = display->CurrentTime();
			start = pendingQueue[osdFirst].startTime;
			stop = pendingQueue[osdFirst].stopTime;

			osdNext = (osdFirst + 1) % NUM_OSD_BITMAPS;
			if (stop < time)
				{
				display->PostOSDBitmap(pendingQueue[osdFirst].map, pendingQueue[osdFirst].startTime, pendingQueue[osdFirst].stopTime);
				availQueue[osdAvail].map = pendingQueue[osdFirst].map;
				availQueue[osdAvail].map->ReleaseBuffer();
				osdAvail++;
				osdFirst = osdNext;
				queueEvent.SetEvent();
				}
			else
				{
				if (!pendingQueue[osdFirst].posted || buttonChanged || buttonState != pendingQueue[osdFirst].buttonState)
					{
					pendingQueue[osdFirst].map->SetColorTable(palette);
					if (buttonState != pendingQueue[osdFirst].buttonState)
						{
						switch (buttonState)
							{
							case XSBS_DISABLED:
#if DUMP_SPU_EVENTS
								OutputDebugString("Setting button to disabled\n");
#endif
								pendingQueue[osdFirst].map->SetButton(buttonX, buttonY, buttonW, buttonH, pendingQueue[osdFirst].colors);
								break;
							case XSBS_SELECTED:
#if DUMP_SPU_EVENTS
								OutputDebugString("Setting button to selected\n");
#endif
								pendingQueue[osdFirst].map->SetButton(buttonX, buttonY, buttonW, buttonH, selectedColors);
								break;
							case XSBS_ACTIVATED:
#if DUMP_SPU_EVENTS
								OutputDebugString("Setting button to activated\n");
#endif
								pendingQueue[osdFirst].map->SetButton(buttonX, buttonY, buttonW, buttonH, activeColors);
								break;
							}
						}

					pendingQueue[osdFirst].posted = TRUE;
					buttonChanged = FALSE;
					}

				if (enable || pendingQueue[osdFirst].forced)
					{
					pendingQueue[osdFirst].map->CalculateNonTransparentRegion();
					display->PostOSDBitmap(pendingQueue[osdFirst].map, pendingQueue[osdFirst].startTime, pendingQueue[osdFirst].stopTime);
					}

				num = display->NumOSDBitmapPreview() - 1;
				while (num && osdNext != osdLast)
					{
					if (!pendingQueue[osdNext].posted)
						{
						pendingQueue[osdNext].map->SetColorTable(palette);
						pendingQueue[osdNext].posted = TRUE;
						}
					if (enable || pendingQueue[osdNext].forced)
						{
						pendingQueue[osdNext].map->CalculateNonTransparentRegion();
						display->PostOSDBitmap(pendingQueue[osdNext].map, pendingQueue[osdNext].startTime, pendingQueue[osdNext].stopTime);
						}

					osdNext = (osdNext + 1) % NUM_OSD_BITMAPS;
					num--;
					}

				if (pause)
					{
					lock.Leave();
					event.WaitForever();
					lock.Enter();
					}
				else
					{
					lock.Leave();
					if (start > time)
						{
						timingClient.Wait(&event, start);
						}
					else 	if (stop != 0x7fffffff)
						{
						timingClient.Wait(&event, stop);
						}
					else
						{
						event.WaitForever();
						}
					lock.Enter();
					}
				}
			}
		else
			{
			//
			// Nothing to do, wait for better times
			//

			lock.Leave();
//			DP("SPUWaitForeverBegin");
			event.WaitForever();
//			DP("SPUWaitForeverEnd");
			lock.Enter();
			}
		}

	queueEvent.SetEvent();
	lock.Leave();
	}

//
//  Constructor
//

SPUDisplay::SPUDisplay(GenericPictureDisplay * display, SPUDisplayBufferFactory * highQualityOsdFactory, SPUDisplayBufferFactory * lowQualityOsdFactory)
	: event(FALSE, TRUE), queueEvent(FALSE, TRUE), TimedFiber(7), timingClient(display)
	{
	this->display = display;
	this->highQualityOsdFactory = highQualityOsdFactory;
	this->lowQualityOsdFactory = lowQualityOsdFactory;

	osdAvail = 0;
	streaming = FALSE;
	}

//
//  Begin Streaming
//

void SPUDisplay::BeginStreaming(bool highQuality)
	{
	int i;
	SPUDisplayBufferFactory	*	osdFactory = highQuality ? highQualityOsdFactory : lowQualityOsdFactory;

	terminate = FALSE;
	pause = TRUE;

	osdFirst = osdLast = 0;
	osdActive = FALSE;
	buttonChanged = FALSE;
	buttonState = XSBS_DISABLED;
	buttonX = buttonY = buttonW = buttonH = 0;
	newSelectedColors = selectedColors = 0x00000000;
	newActiveColors = activeColors = 0x00000000;

	for(i=0; i<display->NumOSDBitmapPreview() + 1; i++)
		{
		availQueue[i].map = osdFactory->CreateSPUDisplayBuffer();
		}
	osdAvail = display->NumOSDBitmapPreview() + 1;

	streaming = TRUE;

	SetFiberPriority(1);
	StartFiber();
	}

//
//  Start Streaming
//

void SPUDisplay::StartStreaming(int playbackSpeed)
	{
	pause = FALSE;
	event.SetEvent();
	}

//
//  Stop Streaming
//

void SPUDisplay::StopStreaming(void)
	{
	pause = TRUE;
	event.SetEvent();
	}

//
//  End Streaming
//

void SPUDisplay::EndStreaming(bool fullReset)
	{
	if (streaming)
		{
		terminate = TRUE;
		event.SetEvent();
		CompleteFiber();

		display->InvalidateOSDBitmaps();

		lock.Enter();

		while (osdAvail)
			{
			osdAvail--;
			delete availQueue[osdAvail].map;
			}

		while (osdFirst != osdLast)
			{
			delete pendingQueue[osdFirst].map;
			osdFirst = (osdFirst + 1) % NUM_OSD_BITMAPS;
			}

		streaming = FALSE;
		lock.Leave();
		}
	}

void SPUDisplay::VideoDisplayBeginStreaming(void)
	{
	int i;

	lock.Enter();

	if (osdFirst != osdLast)
		{
		i = osdFirst;
		while (i != osdLast)
			{
			pendingQueue[i].posted = false;
			i = (i + 1) % NUM_OSD_BITMAPS;
			}

		event.SetEvent();
		}

	lock.Leave();
	}

//
//  Destructor
//

SPUDisplay::~SPUDisplay(void)
	{
	if (streaming) EndStreaming(TRUE);
	}

//
//  Set Button State
//

void SPUDisplay::SetButtonState(XSPUButtonState state)
	{
	lock.Enter();

#if DUMP_SPU_EVENTS
		{
		char buffer[100];
		wsprintf(buffer, "Set button %d was %d\n", state, buttonState);
		OutputDebugString(buffer);
		}
#endif

	if (buttonState != state)
		{
		buttonState = state;
		buttonChanged = TRUE;
		}

	if (buttonChanged)
		{
		event.SetEvent();
		}


	lock.Leave();
	}

//
//  Set Button Position
//

void SPUDisplay::SetButtonPosition(int x, int y, int w, int h)
	{
	lock.Enter();

	if (x != buttonX || y != buttonY || w != buttonW || h != buttonH)
		{
		buttonChanged = TRUE;

		buttonX = x;
		buttonY = y;
		buttonW = w;
		buttonH = h;

		selectedColors = newSelectedColors;
		activeColors = newActiveColors;

		if (buttonState != XSBS_DISABLED)
			{
			event.SetEvent();
			}
		}

	lock.Leave();
	}

//
//  Set Button Colors
//

void SPUDisplay::SetButtonColors(DWORD selected, DWORD active)
	{
	this->newSelectedColors = selected;
	this->newActiveColors = active;
	}

//
//  Set Palette
//

void SPUDisplay::SetPalette(int entry, int y, int u, int v)
	{
	palette[entry].y = (BYTE)y;
	palette[entry].u = (BYTE)u;
	palette[entry].v = (BYTE)v;
	}

//
//  Post OSD Bitmap
//

void SPUDisplay::PostOSDBitmap(SPUDisplayBuffer * map, int startTime, DWORD colors, bool forced)
	{
	int osdNext, osdCur;

	lock.Enter();

	osdNext = (osdLast + 1) % NUM_OSD_BITMAPS;
	while (!terminate && osdNext == osdFirst)
		{
		lock.Leave();
		queueEvent.WaitForever();
		lock.Enter();
		osdNext = (osdLast + 1) % NUM_OSD_BITMAPS;
		}

	if (!terminate)
		{
		if (osdLast != osdFirst)
			{
			osdCur = (osdLast + NUM_OSD_BITMAPS - 1) % NUM_OSD_BITMAPS;
			if (pendingQueue[osdCur].stopTime > startTime)
				pendingQueue[osdCur].stopTime = startTime;
			}

		pendingQueue[osdLast].map = map;
		pendingQueue[osdLast].colors = colors;
		pendingQueue[osdLast].startTime = startTime;
		pendingQueue[osdLast].stopTime = 0x7fffffff;
		pendingQueue[osdLast].posted = FALSE;
		pendingQueue[osdLast].forced = forced;
		pendingQueue[osdLast].buttonState = XSBS_DISABLED;
		osdLast = osdNext;
		event.SetEvent();
		}
	else
		delete map;

	lock.Leave();
	}

//
//  Post OSD Stop Time
//

void SPUDisplay::PostOSDStopTime(int stopTime)
	{
	int osdCur;

	lock.Enter();

	if (!terminate && osdLast != osdFirst)
		{
		osdCur = (osdLast + NUM_OSD_BITMAPS - 1) % NUM_OSD_BITMAPS;
		pendingQueue[osdCur].stopTime = stopTime;
		event.SetEvent();
		}

	lock.Leave();
	}

//
//  Get OSD Bitmap
//

SPUDisplayBuffer * SPUDisplay::GetOSDBitmap(void)
	{
	SPUDisplayBuffer * map;

	lock.Enter();

	while (!terminate && osdAvail == 0)
		{
		lock.Leave();
		queueEvent.WaitForever();
		lock.Enter();
		}

	if (!terminate)
		{
		osdAvail--;
		map = availQueue[osdAvail].map;
		}
	else
		map = NULL;

	lock.Leave();

	return map;
	}

//
//  Enable SPU
//

void SPUDisplay::EnableSPU(bool enable)
	{
	int i;

	lock.Enter();

	if (this->enable != enable)
		{
		this->enable = enable;

		if (streaming)
			{
			if (!enable)
				{
				i = osdFirst;

				while (i != osdLast)
					{
					if (!pendingQueue[i].forced)
						display->PostOSDBitmap(pendingQueue[i].map, 0, 0);
					i = (i + 1) % NUM_OSD_BITMAPS;
					}
				}
			else
				{
				event.SetEvent();
				}
			}
		}

	lock.Leave();
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\SPUDecoder\SPUDecoder.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "SPUDecoder.h"
#include "library\common\vddebug.h"

#define DUMP_SPU_EVENTS		0

SPUDecoder::SPUDecoder(SPUBitStream		*	stream,
			              SPUDisplay		*	display)
	{
	this->stream = stream;
	this->display = display;
	}

SPUDecoder::~SPUDecoder(void)
	{
	}

#define FSTA_DSP		0x00
#define STA_DSP		0x01
#define STP_DSP		0x02
#define SET_COLOR		0x03
#define SET_CONTR		0x04
#define SET_DAREA		0x05
#define SET_DSPAX		0x06
#define CHG_COLCON	0x07
#define CMD_END		0xff

void SPUDecoder::Parse(void)
	{
	int size;
	BYTE u, l;
	int packetStartTime, startTime;
	BYTE * cur, * final, * exit;
	int current, next, ext;
	bool hasStartCommand, hasDisplayArea, hasDisplayData, hasColor, hasContrast, hasChanged;
	bool isCurrentStarted;
	WORD color, contrast;
	int startX, stopX, startY, stopY;
	int oddData, evenData;
	SPUDisplayBuffer	*	map;
	BYTE * buffer, * chcon;
	int cmd;
	DWORD colorCont;
	int	uniqueID;
	bool forced;

	uniqueID = 0x00000001;
	isCurrentStarted = FALSE;

	bool firstShot = FALSE;

	buffer = new BYTE[54000];

	while (!terminate && stream->RefillBuffer(16))
		{
		u = stream->GetByte();
		l = stream->GetByte();
		size = MAKEWORD(l, u);
		if (size)
			{
			if (size >= 2 && size < 54000)
				{
				if (!stream->RefillBuffer(size * 8 - 16)) break;

				packetStartTime = stream->GetCurrentTimeStamp() + 1;

#if DUMP_SPU_EVENTS
					{
					char buffer[100];
					wsprintf(buffer, "SPU : PacketStartTime %d\n", packetStartTime);
					OutputDebugString(buffer);
					}
#endif

				stream->GetBytes(buffer + 2, size - 2);
				next = MAKEWORD(buffer[3], buffer[2]);

				hasStartCommand = FALSE;
				hasDisplayArea = FALSE;
				hasDisplayData = FALSE;
				hasColor = FALSE;
				hasContrast = FALSE;
				hasChanged = TRUE;
				exit = buffer + size;

				do {
					if (next > size-4) break;

					current = next;
					cur = buffer + next;
					next = MAKEWORD(cur[3], cur[2]);
					startTime = packetStartTime + (int)MAKEWORD(cur[1], cur[0]) * 1024 / 90;

#if DUMP_SPU_EVENTS
					{
					char buffer[100];
					wsprintf(buffer, "SPU : StartTime %d\n", startTime);
					OutputDebugString(buffer);
					}
#endif

					final = buffer + next;
					cur += 4;
					chcon = NULL;
					forced = FALSE;

					while (cur < exit && cur != final && (cmd = *cur++) != CMD_END)
						{
#if DUMP_SPU_EVENTS
					{
					char buffer[100];
					wsprintf(buffer, "SPU : Command %02x\n", cmd);
					OutputDebugString(buffer);
					}
#endif
						switch (cmd)
							{
							case STP_DSP:
								if (isCurrentStarted)
									{
									display->PostOSDStopTime(startTime);
									isCurrentStarted = FALSE;
									}

								hasStartCommand = FALSE;
								hasChanged = TRUE;
								break;
							case FSTA_DSP:
								forced = TRUE;
							case STA_DSP:
								hasStartCommand = TRUE;
								hasChanged = TRUE;
								isCurrentStarted = TRUE;
								break;
							case SET_COLOR:
								color = MAKEWORD(cur[1], cur[0]);
								cur += 2;
								hasColor = TRUE;
								hasChanged = TRUE;
								break;
							case SET_CONTR:
								contrast = MAKEWORD(cur[1], cur[0]);
								cur += 2;
								hasContrast = TRUE;
								hasChanged = TRUE;
								break;
							case SET_DAREA:
								startX = *cur++;
								stopX = *cur++;
								startX = (startX << 4) | (stopX >> 4);
								stopX = ((stopX & 0x0f) << 8) | *cur++;

								startY = *cur++;
								stopY = *cur++;
								startY = (startY << 4) | (stopY >> 4);
								stopY = ((stopY & 0x0f) << 8) | *cur++;

#if DUMP_SPU_EVENTS
					{
					char buffer[100];
					wsprintf(buffer, "SPU : DisplayArea %d, %d - %d, %d\n",
						startX, startY, stopX, stopY);
					OutputDebugString(buffer);
					}
#endif
								uniqueID++;
								hasDisplayArea = TRUE;
								hasChanged = TRUE;
								break;
							case SET_DSPAX:
								evenData = MAKEWORD(cur[1], cur[0]);
								oddData = MAKEWORD(cur[3], cur[2]);
								cur += 4;

								uniqueID++;
								hasDisplayData = TRUE;
								hasChanged = TRUE;
								break;
							case CHG_COLCON:
								chcon = cur;
								ext = MAKEWORD(cur[1], cur[0]);
								cur += ext;

								break;
							default:
								ext = MAKEWORD(cur[1], cur[0]);
								cur += ext;
							}
						}

					if (hasStartCommand && hasDisplayArea && hasDisplayData &&
						 hasColor && hasContrast)
						{
						map = display->GetOSDBitmap();
						if (map)
							{
							colorCont = ((DWORD)color << 16) | contrast;

							map->SetImage(buffer + oddData, buffer + evenData,	exit,

														startX, startY, stopX - startX + 1, stopY - startY + 1,
														colorCont, chcon, uniqueID);

							display->PostOSDBitmap(map, startTime, colorCont, forced);

							hasChanged = FALSE;
							}
						}
					} while (!terminate && next > current && cur < exit);
				}
			else
				{
				stream->Advance(stream->AvailBits());
				}
			}
		}

	delete[] buffer;
	}

void SPUDecoder::BeginStreaming(bool highQuality)
	{
	terminate = FALSE;
	display->BeginStreaming(highQuality);
	}

void SPUDecoder::StartStreaming(int playbackSpeed)
	{
	display->StartStreaming(playbackSpeed);
	}

void SPUDecoder::StopStreaming(void)
	{
	display->StopStreaming();
	}

void SPUDecoder::EndStreaming(bool fullReset)
	{
	terminate = TRUE;
	display->EndStreaming(fullReset);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\SPUDecoder\SPUDisplayBuffer.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "SPUDisplayBuffer.h"
#include "..\common\timedfibers.h"
#include "library\common\vddebug.h"

#define ADVANCENB(n)	\
	if (bits >= n)					\
		{								\
		buff <<= n;					\
		bits -= n;					\
		}								\
	else								\
		{								\
		buff <<= bits;				\
		buff |= *map++;			\
		if (map >= limit) return;	\
		buff <<= (n - bits);		\
		bits = bits + 8 - n;		\
		}

////////////////////////////////////////////////////////////////////
//
//  SPU Display Buffer
//
////////////////////////////////////////////////////////////////////

void SPUDisplayBuffer::CalculateNonTransparentRegion(void)
	{
	nonTransparentTop = top;
	nonTransparentHeight = height;
	}

////////////////////////////////////////////////////////////////////
//
//  Decoded SPU Display Buffer
//
////////////////////////////////////////////////////////////////////

void DecodedSPUDisplayBuffer::SetColorTable(SPUColorEntry * colorTable)
	{
	int i;

	for(i=0; i<16; i++)
		nativeColorTable[i] = colorTable[i];

	RebuildPalette();
	}

void DecodedSPUDisplayBuffer::RebuildPalette(void)
	{
	int c, t, i;

	for(i=0; i<usedColorSets*4; i++)
		{
		c = XTBF(16 + 4 * (i & 3), 4, colorSet[i >> 2]);
		t = XTBF(     4 * (i & 3), 4, colorSet[i >> 2]);
		translatedColorTable[i] = nativeColorTable[c];
		if (t == 0)
			translatedColorTable[i].t = 0;
		else
			translatedColorTable[i].t = t + 1;
		}
	}

void DecodedSPUDisplayBuffer::SetImage(BYTE * odd, BYTE * even, BYTE * limit, int left, int top, int width, int height, DWORD color, BYTE * colcon, DWORD uniqueID)
	{
	int chstart, chstop, chnum, chcolpred, chcolumn;
	DWORD chColor;
	int i, j;

	this->uniqueID = uniqueID;
	buttonChangePending = FALSE;

	DecodeRectangle(odd, even, limit, left, top, width, height);

	colorSet[0] = color;
	usedColorSets = 1;

	if (colcon)
		{
		colcon += 2;
		chstart = MAKEWORD(colcon[1], colcon[0]);
		chstop  = MAKEWORD(colcon[3], colcon[2]);
		while (chstart != 0x0fff && chstop != 0xffff)
			{
			chnum = chstop >> 12;
			chstop &= 0x0fff;

			colcon += 4;

			if (chnum)
				{
				chcolpred = MAKEWORD(colcon[1], colcon[0]);
				for(i=1; i<=chnum; i++)
					{
					chColor = MAKELONG4(colcon[5], colcon[4], colcon[3], colcon[2]);

					if (i != chnum)
						chcolumn = MAKEWORD(colcon[7], colcon[6]);
					else
						chcolumn = (left + width);

					for(j=0; j<usedColorSets; j++) if (chColor == colorSet[j]) break;
					if (j > 0 && j < 4)
						{
						if (j == usedColorSets)
							{
							colorSet[j] = chColor;
							usedColorSets++;
							}

						MarkAlternateColorRect(chcolpred, chstart, chcolumn - chcolpred, chstop - chstart + 1, j);
						}

					chcolpred = chcolumn;

					colcon += 6;
					}
				}

			chstart = MAKEWORD(colcon[1], colcon[0]);
			chstop  = MAKEWORD(colcon[3], colcon[2]);
			}
		}

	changed = TRUE;
	}

//
//  Set Button
//

void DecodedSPUDisplayBuffer::SetButton(int buttonLeft, int buttonTop, int buttonWidth, int buttonHeight, DWORD color)
	{
	if (usedColorSets > 1)
		{
		if (color == colorSet[0])
			{
			RemoveAlternateColors();
			usedColorSets = 1;
			RebuildPalette();

			buttonChangePending = FALSE;
			changed = TRUE;
			}
		else
			{
			if (this->buttonLeft != buttonLeft || this->buttonTop != buttonTop ||
				 this->buttonWidth != buttonWidth || this->buttonHeight != buttonHeight)
				{
				buttonChangePending = TRUE;

				this->buttonLeft = buttonLeft;
				this->buttonTop = buttonTop;
				this->buttonWidth = buttonWidth;
				this->buttonHeight = buttonHeight;
				}
			else if (!buttonChangePending && color != colorSet[1])
				{
				colorSet[1] = color;
				RebuildPalette();
				}

			this->buttonColor = color;

			changed = TRUE;
			}
		}
	else if (color != colorSet[0])
		{
		MarkAlternateColorRect(buttonLeft, buttonTop, buttonWidth, buttonHeight, 1);
		this->buttonLeft = buttonLeft;
		this->buttonTop = buttonTop;
		this->buttonWidth = buttonWidth;
		this->buttonHeight = buttonHeight;
		this->buttonColor = color;

		usedColorSets = 2;
		colorSet[1] = color;
		RebuildPalette();

		buttonChangePending = FALSE;
		changed = TRUE;
		}
	}

//
//  Perform Button Change
//

void DecodedSPUDisplayBuffer::PerformButtonChange(void)
	{
	if (buttonChangePending)
		{
		RemoveAlternateColors();
		colorSet[1] = buttonColor;
		RebuildPalette();
		MarkAlternateColorRect(buttonLeft, buttonTop, buttonWidth, buttonHeight, 1);

		buttonChangePending = FALSE;
		}
	}

void DecodedSPUDisplayBuffer::DecodeFieldRectangle2BPP(BYTE * map, BYTE * limit, int preLeft, int width, bool odd, int & topEmpty, int & bottomEmpty, DWORD * nonZeroLines)
	{
	static DWORD maps[] = {0x00000000, 0x55555555, 0xaaaaaaaa, 0xffffffff};
	static DWORD masks[] = {0x00000000, 0xc0000000, 0xf0000000, 0xfc000000,
		                     0xff000000, 0xffc00000, 0xfff00000, 0xfffc0000,
									0xffff0000, 0xffffc000, 0xfffff000, 0xfffffc00,
									0xffffff00, 0xffffffc0, 0xfffffff0, 0xfffffffc,
									0xffffffff};
	int x, y, px;
	int buff;
	int bits;
	int ntwo;
	int pix;
	DWORD color;
	int stride = bytesPerRow / 2 - (preLeft + width + 15) / 16;

	DWORD * rowoptr = (DWORD *)(image + bytesPerRow * odd);
	DWORD obuff;
	int  obits;
	int	framePixOr;
	int	linePixOr;

	topEmpty = bottomEmpty = 0;
	framePixOr = 0;

	buff = (int)(*map++) << 8;
	bits = 0;
	for(y = odd; y < height; y+=2)
		{
        DWORD * optr = rowoptr;
		ADVANCENB(bits)
		linePixOr = 0;
		obits = 16 - preLeft;
		obuff = 0;
		x = 0;
		while (x < width)
			{
			if      (buff & 0xc000)
				{
				ntwo = (buff >> 14) & 3;
				pix = (buff >> 12) & 3;
				ADVANCENB(4)
				}
			else if (buff & 0xf000)
				{
				ntwo = (buff >> 10) & 15;
				pix = (buff >> 8) & 3;
				ADVANCENB(8)
				}
			else if (buff & 0xfc00)
				{
				ADVANCENB(4)
				ntwo = (buff >> 10) & 63;
				pix = (buff >> 8) & 3;
				ADVANCENB(8)
				}
			else if (buff & 0xff00)
				{
				ADVANCENB(6)
				ntwo = (buff >> 8) & 255;
				ADVANCENB(2)
				pix = (buff >> 8) & 3;
				ADVANCENB(8)
				}
			else
				{
				ADVANCENB(8)
				ntwo = width - x;
				pix = (buff >> 8) & 3;
				ADVANCENB(8)
				}

			linePixOr |= pix;

            px = x;
            x += ntwo;

            if (x > width)
            {
                ntwo -= x - width;
                x = width;
            }

			color = maps[pix];

			if (obits > ntwo)
				{
				obuff = (obuff >> 2 * ntwo) | (color & masks[ntwo]);
				obits -= ntwo;
				}
			else
				{
				if (obits < 16)
					{
					obuff = (obuff >> 2 * obits) | (color & masks[obits]);
					*optr++ = obuff;
					ntwo-=obits;
					}
				while (ntwo >= 16)
					{
					*optr++ = color;
					ntwo -= 16;
					}
				obits = 16 - ntwo;
				obuff = color;
				}
			}

		if (obits < 16)
			{
			obuff >>= 2 * obits;
			*optr++ = obuff;
			}

		rowoptr += stride * 2;
		framePixOr |= linePixOr;
		if (!framePixOr) topEmpty++;
		bottomEmpty++;
		if (linePixOr) bottomEmpty = 0;

		if (!(y & 0x1e)) YieldTimedFiber(0);
		}
	}

void DecodedSPUDisplayBuffer::DecodeFieldRectangle4BPP(BYTE * map, BYTE * limit, int preLeft, int width, bool odd, int & topEmpty, int & bottomEmpty, DWORD * nonZeroLines)
	{
	static DWORD maps[] = {0x00000000, 0x11111111, 0x22222222, 0x33333333};
	static DWORD masks[] = {0x00000000, 0xf0000000, 0xff000000, 0xfff00000,
									0xffff0000, 0xfffff000, 0xffffff00, 0xfffffff0,
									0xffffffff};
	int x, y, px;
	int buff;
	int bits;
	int ntwo;
	int pix;
	DWORD color, nonZeroLine;

	DWORD * rowoptr = (DWORD *)(image + bytesPerRow * odd);
	DWORD obuff;
	int  obits;
	int	framePixOr;
	int	linePixOr;

	topEmpty = bottomEmpty = 0;
	framePixOr = 0;

	buff = (int)(*map++) << 8;
	bits = 0;
	nonZeroLine = 0;
	for(y = odd; y < height; y+=2)
		{
        DWORD * optr = rowoptr;
		ADVANCENB(bits)
		linePixOr = 0;
		obits = 8 - preLeft;
		obuff = 0;
		x = 0;
		while (x < width)
			{
			if      (buff & 0xc000)
				{
				ntwo = (buff >> 14) & 3;
				pix = (buff >> 12) & 3;
				ADVANCENB(4)
				}
			else if (buff & 0xf000)
				{
				ntwo = (buff >> 10) & 15;
				pix = (buff >> 8) & 3;
				ADVANCENB(8)
				}
			else if (buff & 0xfc00)
				{
				ADVANCENB(4)
				ntwo = (buff >> 10) & 63;
				pix = (buff >> 8) & 3;
				ADVANCENB(8)
				}
			else if (buff & 0xff00)
				{
				ADVANCENB(6)
				ntwo = (buff >> 8) & 255;
				ADVANCENB(2)
				pix = (buff >> 8) & 3;
				ADVANCENB(8)
				}
			else
				{
				ADVANCENB(8)
				ntwo = width - x;
				pix = (buff >> 8) & 3;
				ADVANCENB(8)
				}

			linePixOr |= pix;

            px = x;
            x += ntwo;

            if (x > width)
            {
                ntwo -= x - width;
                x = width;
            }

			color = maps[pix];

			if (obits > ntwo)
				{
				obuff = (obuff >> 4 * ntwo) | (color & masks[ntwo]);
				obits -= ntwo;
				}
			else
				{
				if (obits < 8)
					{
					obuff = (obuff >> 4 * obits) | (color & masks[obits]);
					*optr++ = obuff;
					ntwo-=obits;
					}
				while (ntwo >= 8)
					{
					*optr++ = color;
					ntwo -= 8;
					}
				obits = 8 - ntwo;
				obuff = color;
				}
			}

		if (obits < 8)
			{
			obuff >>= 4 * obits;
			*optr++ = obuff;
			}

		rowoptr += bytesPerRow / sizeof(DWORD) * 2;
		framePixOr |= linePixOr;
		if (!framePixOr) topEmpty++;
		bottomEmpty++;
		if (linePixOr) bottomEmpty = 0;
		nonZeroLine >>= 2;
		if (linePixOr) nonZeroLine |= 0xc0000000;
		if ((y & 0x1e) == 0x1e) nonZeroLines[y >> 5] = nonZeroLine;


		if (!(y & 0x1e)) YieldTimedFiber(0);
		}

	if ((height & 0x1e) != 0)
		{
		nonZeroLines[height >> 5] = nonZeroLine >> (32 - (height & 0x1e));
		}
	}

//
//  Constructor
//

DecodedSPUDisplayBuffer::DecodedSPUDisplayBuffer(void)
	{
	image = NULL;
	halfImage = NULL;
	}

//
//  Destructor
//

DecodedSPUDisplayBuffer::~DecodedSPUDisplayBuffer(void)
	{
	if (image) delete[] image;
	if (halfImage) delete[] halfImage;
	}

//
//  Calculate Non Transparent Region
//

void DecodedSPUDisplayBuffer::CalculateNonTransparentRegion(void)
	{
	if (usedColorSets == 1 && translatedColorTable[0].t == 0)
		{
		nonTransparentTop = top + topEmpty;
		nonTransparentHeight = height - topEmpty - bottomEmpty;

		if (nonTransparentHeight < 0)
			{
			nonTransparentHeight = 0;
			topEmpty = bottomEmpty = 0;
			}
		}
	else
		SPUDisplayBuffer::CalculateNonTransparentRegion();
	}

////////////////////////////////////////////////////////////////////
//
//  Decoded SPU Display Buffer 4 Bits/Pixel
//
////////////////////////////////////////////////////////////////////

void DecodedSPUDisplayBuffer4BPP::DecodeRectangle(BYTE * odd, BYTE * even, BYTE * limit, int left, int top, int width, int height)
	{
	int preLeft, i;
	int evenTopEmpty, oddTopEmpty, evenBottomEmpty, oddBottomEmpty;

	preLeft = left & 7;

	this->left = left - preLeft;
	this->top = top;
	this->width = (width + preLeft + 7) & ~7;
	this->height = height;

	bytesPerRow = this->width >> 1;

	if (halfImage)
		{
		delete[] halfImage;
		halfImage = NULL;
		}
	if (image) delete[] image;
	image = new BYTE[bytesPerRow * (height + 2)];

	DecodeFieldRectangle4BPP(even, limit, preLeft, width, FALSE, evenTopEmpty, evenBottomEmpty, mainNonZeroLinesMap);
	DecodeFieldRectangle4BPP(odd, limit, preLeft, width, TRUE, oddTopEmpty, oddBottomEmpty, extNonZeroLinesMap);

	for(i=0; i<18; i++)
		{
		mainNonZeroLinesMap[i] = (mainNonZeroLinesMap[i] & 0x55555555) | (extNonZeroLinesMap[i] & 0xaaaaaaaa);
		}
	nonZeroLinesMap = mainNonZeroLinesMap;

	topEmpty = 2 * min(evenTopEmpty, oddTopEmpty);
	bottomEmpty = 2 * min(evenBottomEmpty, oddBottomEmpty);

	minAlternateTop = height;
	maxAlternateBottom = 0;
	}

//
//  Mark alternate color rectangle
//

void DecodedSPUDisplayBuffer4BPP::MarkAlternateColorRect(int alternateLeft, int alternateTop, int alternateWidth, int alternateHeight, int val)
	{
	int x, y, w, lx, rx, h;
	DWORD * mp;
	DWORD mask, lmask, rmask;

	if (val)
		{
		//
		//  Correct top border and height
		//

		for(y=0; y<18; y++)
			extNonZeroLinesMap[y] = mainNonZeroLinesMap[y];

		if (alternateTop < top)
			{
			alternateHeight -= top - alternateTop;
			alternateTop = 0;
			}
		else
			alternateTop -= top;

		//
		//  Correct left border and width
		//

		if (alternateLeft < left)
			{
			alternateWidth -= left - alternateLeft;
			alternateLeft = 0;
			}
		else
			alternateLeft -= left;

		h = alternateHeight;

		if (alternateLeft + alternateWidth > width) alternateWidth = width - alternateLeft;
		if (alternateTop + alternateHeight > height) h = height - alternateTop;

		if (alternateTop < minAlternateTop) minAlternateTop = alternateTop;
		if (h + alternateTop > maxAlternateBottom) maxAlternateBottom = h + alternateTop;

		lx = alternateLeft & 7;
		rx = (alternateLeft + alternateWidth) & 7;

		w = ((int)alternateWidth - (8-lx) - rx) >> 3;
		mask = (DWORD)val * 0x44444444;	// Dithering mask
		lmask = mask << 4 * lx;				// Left rim mask
		rmask = mask >> 4 * (8 - rx);		// Right rim mask

		mp = (DWORD *)(image + alternateTop * bytesPerRow) + (alternateLeft >> 3);
		for(y=0; y<h; y++)
			{
			mp[0] |= lmask;
			for(x=0; x<w; x++)
				{
				mp[x+1] |= mask;
				}
			if (rx && rmask)
				mp[w+1] |= rmask;
			mp += bytesPerRow >> 2;
			}

		for(y=alternateTop; y<alternateTop + h; y++)
			{
			extNonZeroLinesMap[y >> 5] |= (1 << (y & 31));
			}

		nonZeroLinesMap = extNonZeroLinesMap;
		}

	if (halfImage)
		{
		delete[] halfImage;
		halfImage = NULL;
		}
	}

//
//  Remove alternate colors
//

void DecodedSPUDisplayBuffer4BPP::RemoveAlternateColors(void)
	{
	int x, y, w;
	DWORD * mp;

	w = width >> 3;

	mp = (DWORD *)image;

	for(y=0; y<height; y++)
		{
		for(x=0; x<w; x++)
			{
			mp[x] &= 0x33333333;
			}
		mp += bytesPerRow >> 2;
		}

	minAlternateTop = height;
	maxAlternateBottom = 0;

	nonZeroLinesMap = mainNonZeroLinesMap;

	if (halfImage)
		{
		delete[] halfImage;
		halfImage = NULL;
		}
	}

////////////////////////////////////////////////////////////////////
//
//  Full Width MMX SPU Display Buffer
//
////////////////////////////////////////////////////////////////////

void FullWidthMMXSPUDisplayBuffer::RebuildPalette(void)
	{
	int i, j, k;
	DWORD tmul[16], yu[16], yv[16], y[16], u[16], v[16];
	int num;

	DecodedSPUDisplayBuffer::RebuildPalette();

	num = 4 * usedColorSets;

	for(i=0; i<num; i++)
		{
		k = translatedColorTable[i].t;
		if (k == 15) k = 16;
		tmul[i] = (DWORD)(16 - k) * 0x00010001;
		y[i] = (DWORD)(translatedColorTable[i].y) * k;
		u[i] = (DWORD)(translatedColorTable[i].u) * k;
		v[i] = (DWORD)(translatedColorTable[i].v) * k;

		yu[i] = (u[i] << 16) | y[i];
		yv[i] = (v[i] << 16) | y[i];
		}

	for(i=0; i<num; i++)
		{
		for(j=0; j<num; j++)
			{
			k = i * 16 + j;

			colorLookup[k].l = yv[j];
			colorLookup[k].h = yu[i];
			transparencyLookup[k].l = tmul[j];
			transparencyLookup[k].h = tmul[i];

			byteColorTransparencyLookup[k].l =
				(y[j] >> 4) |
				(y[i] >> 4 << 8) |
				(v[j] >> 4 << 16) |
				(u[i] >> 4 << 24);
			byteColorTransparencyLookup[k].h =
				tmul[j] | (tmul[i] << 8);

			hcolorLookup1[k].l = yv[j] + (yu[i] & 0x0000ffff);
			hcolorLookup1[k].h = yu[i] & 0xffff0000;
			htransparencyLookup1[k].l = tmul[j] + (tmul[i] & 0x0000ffff);
			htransparencyLookup1[k].h = tmul[i] & 0xffff0000;
			hcolorLookup2[k].l = yv[j] & 0xffff0000;
			hcolorLookup2[k].h = yu[i] + (yv[j] & 0x0000ffff);
			htransparencyLookup2[k].l = tmul[j] & 0xffff0000;
			htransparencyLookup2[k].h = tmul[i] + (tmul[j] & 0x0000ffff);
			}
		}

	}

static inline DWORD PackDWORDEvenBits(DWORD d)
	{
	d = (d & 0x11111111) | ((d >> 1) & 0x22222222);
	d = (d & 0x03030303) | ((d >> 2) & 0x0c0c0c0c);
	d = (d & 0x000f000f) | ((d >> 4) & 0x00f000f0);
	d = (d & 0x000000ff) | ((d >> 8) & 0x0000ff00);

	return d;
	}

void FullWidthMMXSPUDisplayBuffer::GetDisplayParameters(int decodeWidth, int decodeHeight,
			                                               int & xosdstart, int & xosdstop,
			                                               int & yosdstart, int & yosdstop,
																		  DWORD * & nonZeroLinesMap, int & yoffset,
			                                               BYTE * & po, int & obpr)
	{
	int x, y, lo, ro;
	BYTE * spo, * dpo;

	switch (decodeWidth)
		{
		case 720:
		case 360:
			xosdstart = left;
			xosdstop  = left + width;
			obpr      = bytesPerRow;
			po        = image + bytesPerRow * (nonTransparentTop - top);
			break;
		case 704:
			xosdstart = left - 8;
			xosdstop  = left + width - 16;
			obpr      = bytesPerRow;
			po        = image + bytesPerRow * (nonTransparentTop - top);
			if (xosdstart < 0)
				{
				po -= (xosdstart >> 1);
				xosdstart = 0;
				}
			if (xosdstop > decodeWidth)
				xosdstop = decodeWidth;
			yoffset   = top;
			nonZeroLinesMap = this->nonZeroLinesMap;
			break;
		case 352:
			xosdstart = left - 8;
			xosdstop  = left + width - 16;
			xosdstart >>= 1;
			xosdstop >>= 1;

			if (xosdstart < 0)
				{
				po -= (xosdstart >> 2);
				xosdstart = 0;
				}
			if (xosdstop > decodeWidth)
				xosdstop = decodeWidth;

			obpr      = bytesPerRow >> 1;
			if (xosdstart & 4)
				{
				xosdstart -= 4;
				obpr += 2;
				lo = 2;
				}
			else
				lo = 0;

			if (xosdstop & 4)
				{
				xosdstop += 4;
				obpr += 2;
				ro = 2;
				}
			else
				ro = 0;

			if (!halfImage)
				{
				halfImage = new BYTE[obpr * height];

				spo = image;
				dpo = halfImage;
				for(y=0; y<height; y++)
					{
					for(x=0; x<lo; x++)
						dpo[x] = 0;
					for(x=0; x<ro; x++)
						dpo[obpr-ro+x] = 0;
					for(x=0; x<bytesPerRow; x+=2)
						{
						dpo[(lo + x) >> 1] = (spo[x+1] & 0xf0) | (spo[x] >> 4);
						}
					dpo += obpr;
					spo += bytesPerRow;
					}
				}


			po        = halfImage + obpr * (nonTransparentTop - top);
			break;
		}

	switch (decodeHeight)
		{
		case 480:
		case 576:
			yosdstart = nonTransparentTop;
			yosdstop  = nonTransparentTop + nonTransparentHeight;

			nonZeroLinesMap = this->nonZeroLinesMap;
			yoffset   = top;
			break;
		case 240:
		case 288:
//			po += obpr * (nonTransparentTop - top);
			yosdstart = nonTransparentTop >> 1;
			yosdstop = (nonTransparentTop + nonTransparentHeight) >> 1;
			obpr *= 2;
			yoffset   = top >> 1;

			for(y = 0; y<9; y++)
				{
				halfNonZeroLinesMap[y] = PackDWORDEvenBits(this->nonZeroLinesMap[2*y]) | (PackDWORDEvenBits(this->nonZeroLinesMap[2*y+1]) << 16);
				}
			nonZeroLinesMap = halfNonZeroLinesMap;

			break;
		}

	if (translatedColorTable[0].t != 0) nonZeroLinesMap = NULL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\SPUDecoder\SPUDisplayBuffer.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef SPUDISPLAYBUFFER_H
#define SPUDISPLAYBUFFER_H

#include "driver\SoftwareCinemaster\Common\Prelude.h"

struct SPUColorEntry
	{
	BYTE y, u, v, t;
	};

class SPUDisplayBuffer
	{
	public:
		int				left, top, width, height;
		bool				changed;
		int				nonTransparentTop, nonTransparentHeight;
		DWORD				mainNonZeroLinesMap[18], extNonZeroLinesMap[18];
		DWORD			*	nonZeroLinesMap;

		virtual ~SPUDisplayBuffer(void) {}

		virtual void SetColorTable(SPUColorEntry * colorTable) = 0;
		virtual void SetImage(BYTE * odd, BYTE * even, BYTE * limit, int left, int top, int width, int height, DWORD color, BYTE * colcon, DWORD uniqueID) = 0;
		virtual void SetButton(int buttonLeft, int buttonTop, int buttonWidth, int buttonHeight, DWORD color) = 0;
		virtual void PerformButtonChange(void) {}
		virtual void ReleaseBuffer(void) {}
		virtual void RestoreBuffer(void) {}

		virtual void CalculateNonTransparentRegion(void);
	};

class SPUDisplayBufferFactory
	{
	public:
		virtual SPUDisplayBuffer * CreateSPUDisplayBuffer(void) = 0;
	};

class DecodedSPUDisplayBuffer : public SPUDisplayBuffer
	{
	protected:
		virtual void MarkAlternateColorRect(int aleft, int atop, int awidth, int aheight, int val) = 0;
		virtual void RemoveAlternateColors(void) = 0;
		virtual void DecodeRectangle(BYTE * odd, BYTE * even, BYTE * limit, int left, int top, int width, int height) = 0;
		virtual void RebuildPalette(void);

		void DecodeFieldRectangle4BPP(BYTE * map, BYTE * limit, int preLeft, int width, bool odd, int & topEmpty, int & bottomEmpty, DWORD * nonZeroLines);
		void DecodeFieldRectangle2BPP(BYTE * map, BYTE * limit, int preLeft, int width, bool odd, int & topEmpty, int & bottomEmpty, DWORD * nonZeroLines);

		void CalculateNonTransparentRegion(void);

		DWORD				halfNonZeroLinesMap[18];
		DWORD				colorSet[4];

		bool				buttonChangePending;
	public:
		int				usedColorSets;
		int				bytesPerRow;
		BYTE			*	image;
		BYTE			*	halfImage;

		int				buttonLeft, buttonTop, buttonWidth, buttonHeight;
		DWORD				buttonColor;

		int				topEmpty, bottomEmpty;

		PadOnQWord		pad0;

		SPUColorEntry	nativeColorTable[16];
		SPUColorEntry	translatedColorTable[16];

		DWORD				uniqueID;
		int				visibleTop, visibleBottom;


		DecodedSPUDisplayBuffer(void);
		~DecodedSPUDisplayBuffer(void);

		void SetColorTable(SPUColorEntry * colorTable);
		void SetImage(BYTE * odd, BYTE * even, BYTE * limit, int left, int top, int width, int height, DWORD color, BYTE * colcon, DWORD uniqueID);
		void SetButton(int buttonLeft, int buttonTop, int buttonWidth, int buttonHeight, DWORD color);
		void PerformButtonChange(void);
	};

class DecodedSPUDisplayBuffer4BPP : public DecodedSPUDisplayBuffer
	{
	protected:
		void MarkAlternateColorRect(int aleft, int atop, int awidth, int aheight, int val);
		void RemoveAlternateColors(void);
		void DecodeRectangle(BYTE * odd, BYTE * even, BYTE * limit, int left, int top, int width, int height);
	public:
		int	minAlternateTop, maxAlternateBottom;
	};


class FullWidthMMXSPUDisplayBuffer : public DecodedSPUDisplayBuffer4BPP
	{
	protected:
		void RebuildPalette(void);
	public:
		PadOnQWord		pad1;

		DDWORD		colorLookup[256];
		DDWORD		transparencyLookup[256];
		DDWORD		hcolorLookup1[256];
		DDWORD		htransparencyLookup1[256];
		DDWORD		hcolorLookup2[256];
		DDWORD		htransparencyLookup2[256];
		DDWORD		byteColorTransparencyLookup[256];

		void GetDisplayParameters(int decodeWidth, int decodeHeight,
			                       int & xosdstart, int & xosdstop,
			                       int & yosdstart, int & yosdstop,
										  DWORD * & nonZeroLinesMap, int & yoffset,
			                       BYTE * & po, int & obpr);
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\SPUDecoder\SPUStreamDecoder.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef SPUSTREAMDECODER_H
#define SPUSTREAMDECODER_H

#include "SPUDecoder.h"
#include "..\common\TimedFibers.h"

class SPUStreamDecoder : public SPUBitStream,
                         protected SPUDecoder,
								 private TimedFiber
	{
	protected:
		TimedFiberEvent				bufferRefillEvent;

		bool								completing;
		bool								terminate;
		bool								streamingCompleted;
		bool								streaming;

		int								requestedBits;

		void FiberRoutine(void);

		bool InternalIsBufferComplete(void);
		bool InternalRefillBuffer(int requestBits, bool lowDataPanic);
	public:
		SPUStreamDecoder(SPUDisplay * display);
		~SPUStreamDecoder(void);

		void BeginStreaming(bool highQuality);
		void StartStreaming(int playbackSpeed);
		void StopStreaming(void);
		void EndStreaming(bool fullReset);

			// Hack for MS Navigator
		void VideoDisplayBeginStreaming(void) {display->VideoDisplayBeginStreaming();}

		void EnableSPU(bool enable) {SPUDecoder::EnableSPU(enable);}

		bool StreamingCompleted(void);

		DWORD SendData(BYTE * ptr, DWORD num);
		void CompleteData(void);

		virtual void RefillRequest(void) = 0;
		virtual void StreamCompleted(void) {}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\SPUDecoder\SPUStreamDecoder.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#include "SPUStreamDecoder.h"

#pragma warning(disable : 4355)
SPUStreamDecoder::SPUStreamDecoder(SPUDisplay * display)
	 : SPUDecoder(this, display), bufferRefillEvent(FALSE, TRUE), TimedFiber(8)
	{
//	InitializeCriticalSection(&lock);
	streaming = FALSE;
	}
#pragma warning(default : 4355)

SPUStreamDecoder::~SPUStreamDecoder(void)
	{
	if (streaming) EndStreaming(TRUE);

//	DeleteCriticalSection(&lock);
	}

void SPUStreamDecoder::FiberRoutine(void)
	{
	Parse();

	streamingCompleted = TRUE;
	StreamCompleted();
	}

void SPUStreamDecoder::BeginStreaming(bool highQuality)
	{
	terminate = FALSE;
	completing = FALSE;
	streamingCompleted = FALSE;

	SPUDecoder::BeginStreaming(highQuality);

	streaming = TRUE;

	SetFiberPriority(1);
	StartFiber();
	}

void SPUStreamDecoder::StartStreaming(int playbackSpeed)
	{
	SPUDecoder::StartStreaming(playbackSpeed);
	}

void SPUStreamDecoder::StopStreaming(void)
	{
	SPUDecoder::StopStreaming();
	}

void SPUStreamDecoder::EndStreaming(bool fullReset)
	{
	if (streaming)
		{
		terminate = TRUE;
		bufferRefillEvent.SetEvent();
		SPUDecoder::EndStreaming(fullReset);
		CompleteFiber();
		FlushBuffer();
		streaming = FALSE;
		}
	}

DWORD SPUStreamDecoder::SendData(BYTE * ptr, DWORD num)
	{
	DWORD done;

//	EnterCriticalSection(&lock);

	done = AddData(ptr, num);

	if (AvailBits() > requestedBits) bufferRefillEvent.SetEvent();

//	LeaveCriticalSection(&lock);

	return done;
	}

void SPUStreamDecoder::CompleteData(void)
	{
//	EnterCriticalSection(&lock);

	if (!completing)
		{
		StuffBuffer();
		completing = TRUE;
		bufferRefillEvent.SetEvent();
		}

//	LeaveCriticalSection(&lock);
	}

bool SPUStreamDecoder::InternalIsBufferComplete(void)
	{
	return completing;
	}

bool SPUStreamDecoder::InternalRefillBuffer(int requestBits, bool lowDataPanic)
	{
//	EnterCriticalSection(&lock);

	requestedBits = requestBits;

	while (!terminate && !completing && requestBits > AvailBits())
		{
		RefillRequest();

//		LeaveCriticalSection(&lock);
		bufferRefillEvent.Wait(100);
//		EnterCriticalSection(&lock);
		}

	if (!terminate && !completing && AvailBits() < 8 * SPU_STREAM_BUFFER_SIZE) RefillRequest();

//	LeaveCriticalSection(&lock);

	return !terminate && (completing && AvailBits() > 0 || AvailBits() >= requestBits);
	}

bool SPUStreamDecoder::StreamingCompleted(void)
	{
	return streamingCompleted;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\FrameStore.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "FrameStore.h"
#include "..\common\TimedFibers.h"
#include "library\common\vddebug.h"

#define MEASURE_SCALE_TIME		0
#define MEASURE_OSD_TIME		0

#pragma warning (disable : 4799 4731)

FrameStore::FrameStore(void)
	{
	width = height = bytesPerRow = 0;
	stripeMask = 0;
	iyb = yb = iuvb = uvb = NULL;
	precision = 8;
	}

FrameStore::FrameStore(GenericMMXYUVVideoConverter	*	yuvConverter, int width, int height, bool stripe)
	{
	this->width = width;
	this->height = height;
	this->yuvConverter = yuvConverter;

	bytesPerRow = ((width + 31) & ~31);

	if (stripe)
		mainStripeMask = 0x0000001f;
	else
		mainStripeMask = 0xffffffff;

	stripeMask = 0xffffffff;

	iyb = new BYTE[bytesPerRow * (height + 32)+ 28];
	yb = iyb + ((32 - ((int)iyb & 31)) & 31);
	iuvb = new BYTE[bytesPerRow * (height / 2 + 32) + 28];
	uvb = iuvb + ((32 - ((int)iuvb & 31)) & 31);

	precision = 8;

	maxybFrame = yb + (height - 15) * bytesPerRow;
	maxybField = yb + (height - 14) * bytesPerRow;
	}

FrameStore::~FrameStore(void)
	{
	if (iyb)  delete[] iyb;
	if (iuvb) delete[] iuvb;
	}

void FrameStore::EnableStripeMode(bool stripe)
	{
	if (stripe)
		stripeMask = mainStripeMask;
	else
		stripeMask = 0xffffffff;
	}

void FrameStore::DrawRect(int x, int y, int w, int h, unsigned yuv)
	{
	BYTE yy, uu, vv;
	int xi, yi;
	BPTR yp, uvp;
	int stride;

	yy = ((yuv >> 16) & 0xff) >> (8 - precision);
	uu = ((yuv >>  8) & 0xff) >> (8 - precision);
	vv = ((yuv      ) & 0xff) >> (8 - precision);

	GetPP(x, y, yp, uvp, stride);

	for(yi=0; yi<h; yi++)
		{
		for(xi=0; xi<w; xi+=2)
			{
			yp[xi] = yy; yp[xi+1] = yy;
			uvp[xi] = uu; uvp[xi+1] = vv;
			}
		yp += stride;
		if (yi & 1) uvp += stride;
		}
	}


static inline void ConvertLineToRGB32_P8D1(BYTE * py, BYTE * puv, BYTE * pm, int w)
	{
	static MMXQShort short80 = {0x0080, 0x0080, 0x0080, 0x0080};
	static MMXQShort muluv1 = {453, 359, 453, 359};
	static MMXQShort muluv2 = {88, 183, 88, 183};


	if (w)
		{
		__asm
			{
			mov			eax, [pm]
			mov			ebx, [py]
			mov			edx, [puv]
			mov			ecx, w
			pxor			mm7, mm7
loop1:
			movd			mm0, [edx]
			movd			mm4, [ebx]

			punpcklbw	mm0, mm7
			punpcklbw	mm4, mm7

			psubsw		mm0, [short80]		// V3 U2 V1 U0

			psllw			mm0, 8
			movq			mm1, mm0

			pmulhw		mm0, [muluv1]

			punpckldq	mm2, mm0
			punpckhwd	mm2, mm0

			movq			mm0, mm2				// V3 V1 U2 U0
			punpcklwd	mm0, mm0				// U2 U2 U0 U0
			punpckhwd	mm2, mm2				// V3 V3 V1 V1

			paddsw		mm0, mm4				// Y + U	* 1.772 -> B
			paddsw		mm2, mm4				// Y + V * 1.402 -> R

			pmaddwd		mm1, [muluv2]		// v * 0.714 + u * 0.344
			psrld			mm1, 16
			movq			mm3, mm1
			pslld			mm3, 16
			por			mm1, mm3				// VU VU VU VU
			psubsw		mm4, mm1				// Y - 0.714 * V - 0.344 * U

			packuswb		mm0, mm2				// R R R R B B B B
			packuswb		mm4, mm7				// 0 0 0 0 G G G G

			movq			mm1, mm0
			punpcklbw	mm0, mm4				// G B G B G B G B
			punpckhbw	mm1, mm4				// 0 R 0 R 0 R 0 R

			movq			mm2, mm0
			punpcklwd	mm0, mm1				// 0 R G B 0 R G B
			punpckhwd	mm2, mm1

			movq			[eax], mm0
			movq			[eax + 8], mm2

			add			edx, 4
			add			ebx, 4
			add			eax, 16
			sub			ecx, 4
			jne			loop1
			}
		}
	}

static inline void ConvertLineToRGB32_P8D2(BYTE * py, BYTE * puv, BYTE * pm, int w)
	{
	if (w)
		{
		}
	}

static inline void ConvertLineToRGB32_P8DS(BYTE * py, BYTE * puv, BYTE * pm, int w, int s)
	{
	if (w)
		{
		}
	}

static inline void ConvertLineToRGB15_P8D1(BYTE * py, BYTE * puv, BYTE * pm, int w)
	{
	static MMXQShort short80 = {0x0080, 0x0080, 0x0080, 0x0080};
	static MMXQShort muluv1 = {453, 359, 453, 359};
	static MMXQShort muluv2 = {88, 183, 88, 183};
	static MMXQShort addround = {0x7f00, 0x7f00, 0x7f00, 0x7f00};
	static MMXQShort mask15 = {0x00f8, 0x00f8, 0x00f8, 0x00f8};
	static MMXQShort maskn15 = {0x0007, 0x0007, 0x0007, 0x0007};
	static MMXQShort error = {0x4231, 0x1234, 0x1531, 0x4bdf};

	if (w)
		{
		__asm
			{
			mov			eax, [pm]
			mov			ebx, [py]
			mov			edx, [puv]
			mov			ecx, w
			pxor			mm7, mm7
			movq			mm6, [addround]
			movq			mm5, [error]
loop1:
			movd			mm0, [edx]
			movd			mm4, [ebx]

			punpcklbw	mm0, mm7

			punpcklbw	mm4, mm7
			paddsw		mm4, mm6
			movq			mm1, mm5
			pand			mm1, [maskn15]
			paddsw		mm4, mm1

			psubsw		mm0, [short80]		// V3 U2 V1 U0

			psllw			mm0, 8
			movq			mm1, mm0

			pmulhw		mm0, [muluv1]

			punpckldq	mm2, mm0
			punpckhwd	mm2, mm0

			movq			mm0, mm2				// V3 V1 U2 U0
			punpcklwd	mm0, mm0				// U2 U2 U0 U0
			punpckhwd	mm2, mm2				// V3 V3 V1 V1

			paddsw		mm0, mm4				// Y + U	* 1.772 -> B
			paddsw		mm2, mm4				// Y + V * 1.402 -> R

			pmaddwd		mm1, [muluv2]		// v * 0.714 + u * 0.344
			psrld			mm1, 16
			movq			mm3, mm1
			pslld			mm3, 16
			por			mm1, mm3				// VU VU VU VU
			psubsw		mm4, mm1				// Y - 0.714 * V - 0.344 * U

			psubusw		mm0, mm6
			psubusw		mm2, mm6
			psubusw		mm4, mm6

			movq			mm1, mm5
			psrlq			mm5, 1
			paddd			mm5, mm1

			pand			mm2, [mask15]
			pand			mm4, [mask15]

			psllw			mm4, 2
			psllw			mm2, 7
			psrlw			mm0, 3
			por			mm2, mm4
			por			mm0, mm2

			movq			[eax], mm0

			add			edx, 4
			add			ebx, 4
			add			eax, 8
			sub			ecx, 4
			jne			loop1

			movq			[error], mm5
			}
		}
	}


static inline void ConvertLineToRGB15ThroughOSD_P8D1(BYTE * py, BYTE * puv, BYTE * pm, int w, BYTE * po, DDWORD * dd)
	{
	static MMXQShort short80 = {0x0080, 0x0080, 0x0080, 0x0080};
	static MMXQShort muluv1 = {453, 359, 453, 359};
	static MMXQShort muluv2 = {88, 183, 88, 183};
	static MMXQShort addround = {0x7f00, 0x7f00, 0x7f00, 0x7f00};
	static MMXQShort mask15 = {0x00f8, 0x00f8, 0x00f8, 0x00f8};
	static MMXQShort maskn15 = {0x0007, 0x0007, 0x0007, 0x0007};
	static MMXQShort error = {0x4231, 0x1234, 0x1531, 0x4bdf};

	if (w)
		{
		__asm
			{
			mov			eax, [pm]
			mov			ebx, [py]
			mov			edi, [puv]
			mov			esi, [po]

			mov			ecx, [w]
			push			ebp
			mov			ebp, [dd]

			movq			mm6, [addround]
			movq			mm5, [error]
loop1:
			movd			mm0, [edi]
			movd			mm4, [ebx]

			pxor			mm7, mm7
			punpcklbw	mm0, mm7
			punpcklbw	mm4, mm7
			//
			// OSD Processing
			//

			movzx			edx, BYTE PTR [esi]
			movq			mm7, [ebp + edx * 8 + 2048]

			punpckldq	mm1, mm7
			punpckhwd	mm1, mm7

			movzx			edx, BYTE PTR [esi+1]
			movq			mm7, [ebp + edx * 8 + 2048]

			punpckldq	mm2, mm7
			punpckhwd	mm2, mm7

			movq			mm3, mm1
			punpckldq	mm3, mm2
			punpckhdq	mm1, mm2

			pmullw		mm0, mm1
			pmullw		mm4, mm3

			movzx			edx, BYTE PTR [esi]
			movq			mm7, [ebp + edx * 8]

			punpckldq	mm1, mm7
			punpckhwd	mm1, mm7

			movzx			edx, BYTE PTR [esi+1]
			movq			mm7, [ebp + edx * 8]

			punpckldq	mm2, mm7
			punpckhwd	mm2, mm7

			movq			mm3, mm1
			punpckldq	mm3, mm2
			punpckhdq	mm1, mm2

			paddw			mm0, mm1
			paddw			mm4, mm3

			psrlw			mm0, 4
			psrlw			mm4, 4

			//
			//	Post OSD Processing
			//
			paddsw		mm4, mm6
			movq			mm1, mm5
			pand			mm1, [maskn15]
			paddsw		mm4, mm1

			psubsw		mm0, [short80]		// V3 U2 V1 U0

			psllw			mm0, 8
			movq			mm1, mm0

			pmulhw		mm0, [muluv1]

			punpckldq	mm2, mm0
			punpckhwd	mm2, mm0

			movq			mm0, mm2				// V3 V1 U2 U0
			punpcklwd	mm0, mm0				// U2 U2 U0 U0
			punpckhwd	mm2, mm2				// V3 V3 V1 V1

			paddsw		mm0, mm4				// Y + U	* 1.772 -> B
			paddsw		mm2, mm4				// Y + V * 1.402 -> R

			pmaddwd		mm1, [muluv2]		// v * 0.714 + u * 0.344
			psrld			mm1, 16
			movq			mm3, mm1
			pslld			mm3, 16
			por			mm1, mm3				// VU VU VU VU
			psubsw		mm4, mm1				// Y - 0.714 * V - 0.344 * U

			psubusw		mm0, mm6
			psubusw		mm2, mm6
			psubusw		mm4, mm6

			movq			mm1, mm5
			psrlq			mm5, 1
			paddd			mm5, mm1

			pand			mm2, [mask15]
			pand			mm4, [mask15]

			psllw			mm4, 2
			psllw			mm2, 7
			psrlw			mm0, 3
			por			mm2, mm4
			por			mm0, mm2

			movq			[eax], mm0

			add			esi, 2
			add			edi, 4
			add			ebx, 4
			add			eax, 8
			sub			ecx, 4
			jne			loop1

			pop			ebp

			movq			[error], mm5
			}
		}
	}

static inline void ConvertLineToRGB15ThroughOSD_P8D2(BYTE * py, BYTE * puv, BYTE * pm, int w, BYTE * po, DDWORD * dd)
	{
	}

static inline void ConvertLineToRGB15ThroughOSD_P8DS(BYTE * py, BYTE * puv, BYTE * pm, int w,
																	BYTE * po, DDWORD * dd, int s)
	{
	}

static inline void ConvertLineToRGB15_P8D2(BYTE * py, BYTE * puv, BYTE * pm, int w)
	{
	static MMXQShort short80a = {0x0100, 0x0100, 0x0100, 0x0100};
	static MMXQShort muluv1 = {453, 359, 453, 359};
	static MMXQShort muluv2 = {88, 183, 88, 183};
	static MMXQShort addround = {0x7f00, 0x7f00, 0x7f00, 0x7f00};
	static MMXQShort mask15 = {0x00f8, 0x00f8, 0x00f8, 0x00f8};
	static MMXQShort maskn15 = {0x0007, 0x0007, 0x0007, 0x0007};
	static MMXQShort error = {0x4231, 0x1234, 0x1531, 0x4bdf};
	static MMXQShort maskY = {0x00ff, 0x00ff, 0x00ff, 0x00ff};

	if (w)
		{
		__asm
			{
			mov			eax, [pm]
			mov			ebx, [py]
			mov			edx, [puv]
			mov			ecx, w
			pxor			mm7, mm7
			movq			mm6, [addround]
			movq			mm5, [error]
loop1:
			movq			mm0, [edx]
			movq			mm4, [ebx]

			movq			mm1, [maskY]
			pand			mm1, mm4
			psrlw			mm4, 8
			paddw			mm4, mm1
			psrlw			mm4, 1

			punpckldq	mm2, mm0
			punpckhwd	mm2, mm0

			punpckldq	mm0, mm2
			punpckhbw	mm0, mm2

			movq			mm1, [maskY]
			pand			mm1, mm0
			psrlw			mm0, 8
			paddw			mm0, mm1

			paddsw		mm4, mm6
			movq			mm1, mm5
			pand			mm1, [maskn15]
			paddsw		mm4, mm1

			psubsw		mm0, [short80a]		// V3 U2 V1 U0

			psllw			mm0, 7
			movq			mm1, mm0

			pmulhw		mm0, [muluv1]

			punpckldq	mm2, mm0
			punpckhwd	mm2, mm0

			movq			mm0, mm2				// V3 V1 U2 U0
			punpcklwd	mm0, mm0				// U2 U2 U0 U0
			punpckhwd	mm2, mm2				// V3 V3 V1 V1

			paddsw		mm0, mm4				// Y + U	* 1.772 -> B
			paddsw		mm2, mm4				// Y + V * 1.402 -> R

			pmaddwd		mm1, [muluv2]		// v * 0.714 + u * 0.344
			psrld			mm1, 16
			movq			mm3, mm1
			pslld			mm3, 16
			por			mm1, mm3				// VU VU VU VU
			psubsw		mm4, mm1				// Y - 0.714 * V - 0.344 * U

			psubusw		mm0, mm6
			psubusw		mm2, mm6
			psubusw		mm4, mm6

			movq			mm1, mm5
			psrlq			mm5, 1
			paddd			mm5, mm1

			pand			mm2, [mask15]
			pand			mm4, [mask15]

			psllw			mm4, 2
			psllw			mm2, 7
			psrlw			mm0, 3
			por			mm2, mm4
			por			mm0, mm2

			movq			[eax], mm0

			add			edx, 8
			add			ebx, 8
			add			eax, 8
			sub			ecx, 4
			jne			loop1

			movq			[error], mm5
			}
		}
	}

static inline void ConvertLineToRGB15_P8DS(BYTE * py, BYTE * puv, BYTE * pm, int w, int s)
	{
	int x;
	int xs;

	int y, u, v, r, g, b, ry, gy, by;

	WORD * pp = (WORD *)pm;

	xs = 1 << s;

	for(x = 0; x < w; x += 2 * xs)
		{
		u = puv[x]   + puv[x+xs]   - 256;
		v = puv[x+1] + puv[x+xs+1] - 256;

		r =  (359 * v)          >> 9;
		g = -(183 * v + 88 * u) >> 9;
		b =  (453 * u)          >> 9;

		y = py[x];

		ry = r + y;
		gy = g + y;
		by = b + y;

		*pp++ = ((ry & 0xf8) << 7) | ((gy & 0xf8) << 2) | ((by & 0xf8) >> 3);

		y = py[x+xs];

		ry = r + y;
		gy = g + y;
		by = b + y;

		*pp++ = ((ry & 0xf8) << 7) | ((gy & 0xf8) << 2) | ((by & 0xf8) >> 3);
		}
	}

static inline void ConvertLineToRGB16_P8D1(BYTE * py, BYTE * puv, BYTE * pm, int w)
	{
	static MMXQShort short80 = {0x0080, 0x0080, 0x0080, 0x0080};
	static MMXQShort muluv1 = {453, 359, 453, 359};
	static MMXQShort muluv2 = {88, 183, 88, 183};
	static MMXQShort addround = {0x7f00, 0x7f00, 0x7f00, 0x7f00};
	static MMXQShort mask15 = {0x00f8, 0x00f8, 0x00f8, 0x00f8};
	static MMXQShort maskn15 = {0x0007, 0x0007, 0x0007, 0x0007};
	static MMXQShort error = {0x4231, 0x1234, 0x1531, 0x4bdf};

	if (w)
		{
		__asm
			{
			mov			eax, [pm]
			mov			ebx, [py]
			mov			edx, [puv]
			mov			ecx, w
			pxor			mm7, mm7
			movq			mm6, [addround]
			movq			mm5, [error]
loop1:
			movd			mm0, [edx]
			movd			mm4, [ebx]

			punpcklbw	mm0, mm7

			punpcklbw	mm4, mm7
			paddsw		mm4, mm6
			movq			mm1, mm5
			pand			mm1, [maskn15]
			paddsw		mm4, mm1

			psubsw		mm0, [short80]		// V3 U2 V1 U0

			psllw			mm0, 8
			movq			mm1, mm0

			pmulhw		mm0, [muluv1]

			punpckldq	mm2, mm0
			punpckhwd	mm2, mm0

			movq			mm0, mm2				// V3 V1 U2 U0
			punpcklwd	mm0, mm0				// U2 U2 U0 U0
			punpckhwd	mm2, mm2				// V3 V3 V1 V1

			paddsw		mm0, mm4				// Y + U	* 1.772 -> B
			paddsw		mm2, mm4				// Y + V * 1.402 -> R

			pmaddwd		mm1, [muluv2]		// v * 0.714 + u * 0.344
			psrld			mm1, 16
			movq			mm3, mm1
			pslld			mm3, 16
			por			mm1, mm3				// VU VU VU VU
			psubsw		mm4, mm1				// Y - 0.714 * V - 0.344 * U

			psubusw		mm0, mm6
			psubusw		mm2, mm6
			psubusw		mm4, mm6

			movq			mm1, mm5
			psrlq			mm5, 1
			paddd			mm5, mm1

			pand			mm2, [mask15]
			pand			mm4, [mask15]

			psllw			mm4, 3
			psllw			mm2, 8
			psrlw			mm0, 3
			por			mm2, mm4
			por			mm0, mm2

			movq			[eax], mm0

			add			edx, 4
			add			ebx, 4
			add			eax, 8
			sub			ecx, 4
			jne			loop1

			movq			[error], mm5
			}
		}
	}

static inline void ConvertLineToRGB16_P8D2(BYTE * py, BYTE * puv, BYTE * pm, int w)
	{
	if (w)
		{
		}
	}

static inline void ConvertLineToRGB16_P8DS(BYTE * py, BYTE * puv, BYTE * pm, int w, int s)
	{
	if (w)
		{
		}
	}

void FrameStore::ConvertToYUVStripe(BYTE * topMap, BYTE * bottomMap,
			                           int mwidth, int mheight, int mstride,
												int sstart, int sheight,
												bool lace, bool singleField, PictureStructure fmode,
											   VideoDownscaleFilterLevelSet filterLevel,
												FullWidthMMXSPUDisplayBuffer * osd)
	{
	int xscale, yfraction, xfraction;
	VideoDownscaleFilterLevel	filterLevelX, filterLevelY;
	YUVVideoConverterParameter  vcp;
	BYTE * pmb, * pmt;
	GenericMMXYUVVideoConverter::ConvertStripeFunction		convertStripe;

	mwidth = (mwidth + 3) & ~3;

	xfraction = 0x10000 * width / mwidth;
	yfraction = 0x10000 * height / mheight;
	xscale = 0;
	while ((mwidth << xscale) < width) xscale++;

	if (yfraction > 0x20000)
		filterLevelY = filterLevel.halfY;
	else
		filterLevelY = filterLevel.fullY;

	if (xfraction > 0x20000)
		filterLevelX = filterLevel.halfX;
	else
		filterLevelX = filterLevel.fullX;

	if (!(singleField && fmode == PS_BOTTOM_FIELD))
		{
		convertStripe = yuvConverter->convertStripes[precision - 7][osd != NULL][filterLevelX][filterLevelY];

		vcp.xfraction = xfraction;
		vcp.yfraction = yfraction;
		vcp.xscale = xscale;

		vcp.width = width;
		vcp.height = height;
		vcp.mwidth = mwidth;

		vcp.stripeMask = stripeMask;

		vcp.bpr = bytesPerRow;
		vcp.mbpr = mstride;

		if (bottomMap != NULL) lace = true;

		if (osd)
			{
			vcp.dd = osd->colorLookup;
			osd->GetDisplayParameters(width, height, vcp.xosdstart, vcp.xosdstop, vcp.yosdstart, vcp.yosdstop,
				                       vcp.osdNonZeroMap, vcp.yosdoffset, vcp.po, vcp.obpr);
			}

		if (yfraction != 0x10000)
			{
			switch (filterLevelY)
				{
				case VSQL_BINARY:
				case VSQL_DROP:
					break;
				case VSQL_LINEAR:
				case VSQL_FOUR_TAP:
					if (sstart > 0)
						{
						sstart -= 2;
						sheight += 2;
						}

					if (sstart + sheight < height)
						sheight -= 2;
					break;
				case VSQL_EIGHT_TAP:
					if (sstart > 0)
						{
						sstart -= 4;
						sheight += 4;
						}

					if (sstart + sheight < height)
						sheight -= 4;
					break;
				}
			}

		if (fmode == PS_FRAME_PICTURE)
			{
			vcp.ystart = sstart * mheight / height;
			vcp.ystop = (sstart + sheight) * mheight / height;
			}
		else
			{
			vcp.bpr *= 2;
			vcp.obpr *= 2;

			vcp.ystart = sstart * mheight / height;
			vcp.ystop = (sstart + sheight) * mheight / height;
			}

		vcp.py = yb;
		vcp.puv = uvb;

		if (fmode == PS_BOTTOM_FIELD)
			{
			vcp.py += bytesPerRow;
			vcp.puv += bytesPerRow;
			}

		if (fmode == PS_FRAME_PICTURE && lace && !singleField)
			{
			vcp.ystart >>= 1;
			vcp.ystop >>= 1;
			vcp.yosdstart >>= 1;
			vcp.yosdstop >>= 1;

			if (bottomMap)
				pmb = bottomMap + vcp.ystart * vcp.mbpr;
			else
				{
				pmb = topMap + (2 * vcp.ystart + 1) * vcp.mbpr;
				vcp.mbpr *= 2;
				}
			pmt = topMap + vcp.ystart * vcp.mbpr;

			vcp.ycount = vcp.ystart * yfraction;
			vcp.bpr *= 2;
			vcp.obpr *= 2;
			vcp.stripeMask >>= 1;

			vcp.pm = pmt;
			(yuvConverter->*convertStripe)(vcp);
			vcp.pm = pmb;
			vcp.py += bytesPerRow;
			vcp.puv += bytesPerRow;
			vcp.po += vcp.obpr >> 1;
			(yuvConverter->*convertStripe)(vcp);
			}
		else
			{
			if (lace && singleField)
				{
				vcp.yfraction >>= 1;
				vcp.yosdstart >>= 1;
				vcp.yosdstop >>= 1;

				if (fmode == PS_FRAME_PICTURE)
					{
					vcp.bpr *= 2;
					vcp.obpr *= 2;
					vcp.stripeMask >>= 1;
					}
				else
					{
					vcp.ystart *= 2;
					vcp.ystop *= 2;
					}

				vcp.pm = topMap + vcp.ystart * vcp.mbpr;
				}
			else
				{
				switch (fmode)
					{
					case PS_FRAME_PICTURE:
						vcp.pm  = topMap + vcp.ystart * vcp.mbpr;
						break;
					case PS_TOP_FIELD:
						if (!bottomMap) vcp.mbpr *= 2;
						vcp.pm  = topMap + vcp.ystart * vcp.mbpr;
						break;
					case PS_BOTTOM_FIELD:
						if (bottomMap)
							vcp.pm  = bottomMap + vcp.ystart * vcp.mbpr;
						else
							{
							vcp.mbpr *= 2;
							vcp.pm = topMap + mstride + vcp.ystart * vcp.mbpr;
							}
						break;
					}
				}

			vcp.ycount = vcp.ystart * vcp.yfraction;

			(yuvConverter->*convertStripe)(vcp);
			}
		}
	}

void FrameStore::ConvertToYUVStripePanScan(BYTE * topMap, BYTE * bottomMap,
			                                  int mwidth, int mheight, int mstride, int xoffset,
												       int sstart, int sheight,
												       bool lace, bool singleField, PictureStructure fmode,
												       VideoDownscaleFilterLevelSet filterLevel,
												       FullWidthMMXSPUDisplayBuffer * osd)
	{
	int xscale, yfraction, xfraction;
	VideoDownscaleFilterLevel	filterLevelX, filterLevelY;
	YUVVideoConverterParameter  vcp;
	BYTE * pmb, * pmt;
	GenericMMXYUVVideoConverter::ConvertStripeFunction		convertStripe;

	mwidth = (mwidth + 3) & ~3;

	xfraction = 0x10000 * width / mwidth;
	yfraction = 0x10000 * height / mheight;
	xscale = 0;
	while ((mwidth << xscale) < width) xscale++;

	if (yfraction > 0x20000)
		filterLevelY = filterLevel.halfY;
	else
		filterLevelY = filterLevel.fullY;

	if (xfraction > 0x20000)
		filterLevelX = filterLevel.halfX;
	else
		filterLevelX = filterLevel.fullX;

	if (!(singleField && fmode == PS_BOTTOM_FIELD))
		{
		if (osd != NULL)
			convertStripe = GenericMMXYUVVideoConverter::ConvertStripeToYUVPSThroughOSD_P8F2;
		else
			convertStripe = GenericMMXYUVVideoConverter::ConvertStripeToYUVPS_P8F2;

		vcp.xfraction = xfraction;
		vcp.yfraction = yfraction;
		vcp.xscale = xscale;
		vcp.xoffset = xoffset;

		vcp.width = width;
		vcp.height = height;
		vcp.mwidth = mwidth;

		vcp.stripeMask = stripeMask;

		vcp.bpr = bytesPerRow;
		vcp.mbpr = mstride;

		if (bottomMap != NULL) lace = true;

		if (osd)
			{
			vcp.dd = osd->colorLookup;
			osd->GetDisplayParameters(width, height, vcp.xosdstart, vcp.xosdstop, vcp.yosdstart, vcp.yosdstop,
				                       vcp.osdNonZeroMap, vcp.yosdoffset, vcp.po, vcp.obpr);
			}

		if (yfraction != 0x10000)
			{
			switch (filterLevelY)
				{
				case VSQL_BINARY:
				case VSQL_DROP:
					break;
				case VSQL_LINEAR:
				case VSQL_FOUR_TAP:
					if (sstart > 0)
						{
						sstart -= 2;
						sheight += 2;
						}

					if (sstart + sheight < height)
						sheight -= 2;
					break;
				case VSQL_EIGHT_TAP:
					if (sstart > 0)
						{
						sstart -= 4;
						sheight += 4;
						}

					if (sstart + sheight < height)
						sheight -= 4;
					break;
				}
			}

		if (fmode == PS_FRAME_PICTURE)
			{
			vcp.ystart = sstart * mheight / height;
			vcp.ystop = (sstart + sheight) * mheight / height;
			}
		else
			{
			vcp.bpr *= 2;
			vcp.obpr *= 2;

			vcp.ystart = sstart * mheight / height;
			vcp.ystop = (sstart + sheight) * mheight / height;
			}

		vcp.py = yb;
		vcp.puv = uvb;

		if (fmode == PS_BOTTOM_FIELD)
			{
			vcp.py += bytesPerRow;
			vcp.puv += bytesPerRow;
			}

		if (fmode == PS_FRAME_PICTURE && lace && !singleField)
			{
			vcp.ystart >>= 1;
			vcp.ystop >>= 1;
			vcp.yosdstart >>= 1;
			vcp.yosdstop >>= 1;

			if (bottomMap)
				pmb = bottomMap + vcp.ystart * vcp.mbpr;
			else
				{
				pmb = topMap + (2 * vcp.ystart + 1) * vcp.mbpr;
				vcp.mbpr *= 2;
				}
			pmt = topMap + vcp.ystart * vcp.mbpr;

			vcp.ycount = vcp.ystart * yfraction;
			vcp.bpr *= 2;
			vcp.obpr *= 2;
			vcp.stripeMask >>= 1;

			vcp.pm = pmt;
			(yuvConverter->*convertStripe)(vcp);
			vcp.pm = pmb;
			vcp.py += bytesPerRow;
			vcp.puv += bytesPerRow;
			vcp.po += vcp.obpr >> 1;
			(yuvConverter->*convertStripe)(vcp);
			}
		else
			{
			if (lace && singleField)
				{
				vcp.yfraction >>= 1;
				vcp.yosdstart >>= 1;
				vcp.yosdstop >>= 1;

				if (fmode == PS_FRAME_PICTURE)
					{
					vcp.bpr *= 2;
					vcp.obpr *= 2;
					vcp.stripeMask >>= 1;
					}
				else
					{
					vcp.ystart *= 2;
					vcp.ystop *= 2;
					}

				vcp.pm = topMap + vcp.ystart * vcp.mbpr;
				}
			else
				{
				switch (fmode)
					{
					case PS_FRAME_PICTURE:
						vcp.pm  = topMap + vcp.ystart * vcp.mbpr;
						break;
					case PS_TOP_FIELD:
						if (!bottomMap) vcp.mbpr *= 2;
						vcp.pm  = topMap + vcp.ystart * vcp.mbpr;
						break;
					case PS_BOTTOM_FIELD:
						if (bottomMap)
							vcp.pm  = bottomMap + vcp.ystart * vcp.mbpr;
						else
							{
							vcp.mbpr *= 2;
							vcp.pm = topMap + mstride + vcp.ystart * vcp.mbpr;
							}
						break;
					}
				}

			vcp.ycount = vcp.ystart * vcp.yfraction;

			(yuvConverter->*convertStripe)(vcp);
			}
		}
	}

void FrameStore::ConvertToYUVStripePanScanAverageDeinterlace(BYTE * topMap,
			                                                    int mwidth, int mheight, int mstride, int xoffset,
												                         int sstart, int sheight,
												                         bool lace,
												                         VideoDownscaleFilterLevelSet filterLevel,
												                         FullWidthMMXSPUDisplayBuffer * osd)
	{
	int xscale, yfraction, xfraction;
	VideoDownscaleFilterLevel	filterLevelX, filterLevelY;
	YUVVideoConverterParameter  vcp;

	mwidth = (mwidth + 3) & ~3;

	xfraction = 0x10000 * width / mwidth;
	yfraction = 0x10000 * height / mheight;
	xscale = 0;
	while ((mwidth << xscale) < width) xscale++;

	if (yfraction > 0x20000)
		filterLevelY = filterLevel.halfY;
	else
		filterLevelY = filterLevel.fullY;

	if (xfraction > 0x20000)
		filterLevelX = filterLevel.halfX;
	else
		filterLevelX = filterLevel.fullX;

	vcp.xfraction = xfraction;
	vcp.yfraction = yfraction;
	vcp.xoffset = xoffset;
	vcp.xscale = xscale;

	vcp.width = width;
	vcp.height = height;
	vcp.mwidth = mwidth;

	vcp.stripeMask = stripeMask;

	vcp.bpr = bytesPerRow;
	vcp.mbpr = mstride;

	if (osd)
		{
		vcp.dd = osd->colorLookup;
		osd->GetDisplayParameters(width, height, vcp.xosdstart, vcp.xosdstop, vcp.yosdstart, vcp.yosdstop,
				                    vcp.osdNonZeroMap, vcp.yosdoffset, vcp.po, vcp.obpr);
		}

	if (sstart > 0)
		{
		sstart -= 2;
		sheight += 2;
		}

	if (sstart + sheight < height)
		sheight -= 2;

	vcp.ystart = sstart * mheight / height;
	vcp.ystop = (sstart + sheight) * mheight / height;

	vcp.py = yb;
	vcp.puv = uvb;

	vcp.pm  = topMap + vcp.ystart * mstride;

	vcp.ycount = vcp.ystart * yfraction;

	if (lace)
		{
		if (osd)
			yuvConverter->ConvertStripeToYUVPSAIThroughOSD_P8F2(vcp);
		else
			yuvConverter->ConvertStripeToYUVPSAI_P8F2(vcp);
		}
	else
		{
		if (osd)
			yuvConverter->ConvertStripeToYUVPSThroughOSD_P8F2(vcp);
		else
			yuvConverter->ConvertStripeToYUVPS_P8F2(vcp);
		}
	}

void FrameStore::ConvertToYUVStripePanScanDeinterlace(BYTE * previousMap, BYTE * currentMap, BYTE * nextMap, FrameStore * previous,
                                                      int mwidth, int mheight, int mstride, int xoffset,
															         int sstart, int sheight,
															         bool topFieldFirst, DWORD flags,
															         VideoDownscaleFilterLevelSet filterLevel,
															         FullWidthMMXSPUDisplayBuffer * osd)
	{
	int xscale, yfraction, xfraction;
	VideoDownscaleFilterLevel	filterLevelX, filterLevelY;
	YUVVideoConverterParameter  vcp;

	mwidth = (mwidth + 3) & ~3;

	xfraction = 0x10000 * width / mwidth;
	yfraction = 0x10000 * height / mheight;
	xscale = 0;
	while ((mwidth << xscale) < width) xscale++;

	if (yfraction > 0x20000)
		filterLevelY = filterLevel.halfY;
	else
		filterLevelY = filterLevel.fullY;

	if (xfraction > 0x20000)
		filterLevelX = filterLevel.halfX;
	else
		filterLevelX = filterLevel.fullX;

	vcp.xfraction = xfraction;
	vcp.yfraction = yfraction;
	vcp.xoffset = xoffset;
	vcp.xscale = xscale;

	vcp.width = width;
	vcp.height = height;
	vcp.mwidth = mwidth;

	vcp.stripeMask = stripeMask;
	vcp.topField = topFieldFirst;

	vcp.bpr = bytesPerRow;
	vcp.mbpr = mstride;

	if (osd)
		{
		vcp.dd = osd->colorLookup;
		osd->GetDisplayParameters(width, height, vcp.xosdstart, vcp.xosdstop, vcp.yosdstart, vcp.yosdstop,
				                    vcp.osdNonZeroMap, vcp.yosdoffset, vcp.po, vcp.obpr);
		}

	if (sstart > 0)
		{
		sstart -= 2;
		sheight += 2;
		}

	if (sstart + sheight < height)
		sheight -= 2;

	vcp.ystart = sstart * mheight / height;
	vcp.ystop = (sstart + sheight) * mheight / height;

	if (topFieldFirst)
		{
		vcp.py = yb;
		vcp.puv = uvb;
		vcp.ppy = previous->yb;
		vcp.ppuv = previous->uvb;
		vcp.pytb = yb;
		vcp.puvtb = uvb;

		vcp.pm  = currentMap + vcp.ystart * mstride;
		vcp.ppm = previousMap + vcp.ystart * mstride;
		vcp.pmt = currentMap + vcp.ystart * mstride;
		vcp.pmb = nextMap + vcp.ystart * mstride;

		vcp.deinterlaceFlags = flags;
		}
	else
		{
		vcp.ppy = yb;
		vcp.ppuv = uvb;
		vcp.py = previous->yb;
		vcp.puv = previous->uvb;
		vcp.pytb = yb;
		vcp.puvtb = uvb;

		vcp.ppm = currentMap + vcp.ystart * mstride;
		vcp.pm  = previousMap + vcp.ystart * mstride;
		vcp.pmb = currentMap + vcp.ystart * mstride;
		vcp.pmt = nextMap + vcp.ystart * mstride;

		vcp.deinterlaceFlags = flags;
		}

	vcp.ycount = vcp.ystart * yfraction;

	if (osd)
		yuvConverter->ConvertStripeToYUVPSDI2ThroughOSD_P8F2(vcp);
	else
		yuvConverter->ConvertStripeToYUVPSDI2_P8F2(vcp);
	}

void FrameStore::ConvertToYUVStripePanScanInterpolate(BYTE * map, FrameStore * previous,
			                                             int mwidth, int mheight, int mstride, int xoffset,
												                  int sstart, int sheight,
												                  VideoDownscaleFilterLevelSet filterLevel,
												                  FullWidthMMXSPUDisplayBuffer * osd)
	{
	int xscale, yfraction, xfraction;
	VideoDownscaleFilterLevel	filterLevelX, filterLevelY;
	YUVVideoConverterParameter  vcp;

	mwidth = (mwidth + 3) & ~3;

	xfraction = 0x10000 * width / mwidth;
	yfraction = 0x10000 * height / mheight;
	xscale = 0;
	while ((mwidth << xscale) < width) xscale++;

	if (yfraction > 0x20000)
		filterLevelY = filterLevel.halfY;
	else
		filterLevelY = filterLevel.fullY;

	if (xfraction > 0x20000)
		filterLevelX = filterLevel.halfX;
	else
		filterLevelX = filterLevel.fullX;

	vcp.xfraction = xfraction;
	vcp.yfraction = yfraction;
	vcp.xoffset = xoffset;
	vcp.xscale = xscale;

	vcp.width = width;
	vcp.height = height;
	vcp.mwidth = mwidth;

	vcp.stripeMask = stripeMask;

	vcp.bpr = bytesPerRow;
	vcp.mbpr = mstride;

	if (osd)
		{
		vcp.dd = osd->colorLookup;
		osd->GetDisplayParameters(width, height, vcp.xosdstart, vcp.xosdstop, vcp.yosdstart, vcp.yosdstop,
				                    vcp.osdNonZeroMap, vcp.yosdoffset, vcp.po, vcp.obpr);
		}

	vcp.ystart = sstart * mheight / height;
	vcp.ystop = (sstart + sheight) * mheight / height;

	vcp.py = yb;
	vcp.puv = uvb;
	vcp.ppy = previous->yb;
	vcp.ppuv = previous->uvb;

	vcp.pm = map + vcp.ystart * mstride;

	vcp.ycount = vcp.ystart * yfraction;

	if (osd)
		yuvConverter->ConvertStripeToYUVPSA2ThroughOSD_P8F2(vcp);
	else
		yuvConverter->ConvertStripeToYUVPSA2_P8F2(vcp);
	}

void FrameStore::ConvertToYUVStripePanScanDeinterlaceStretch(BYTE * topMap, BYTE * bottomMap,
			                                                    int mwidth, int mheight, int mstride, int xoffset,
																             int sstart, int sheight,
																             DWORD flags,
																             VideoDownscaleFilterLevelSet filterLevel,
																             FullWidthMMXSPUDisplayBuffer * osd)
	{
	int xscale, yfraction, xfraction;
	VideoDownscaleFilterLevel	filterLevelX, filterLevelY;
	YUVVideoConverterParameter  vcp;

	mwidth = (mwidth + 3) & ~3;

	xfraction = 0x10000 * width / mwidth;
	yfraction = 0x10000 * height / mheight;
	xscale = 0;
	while ((mwidth << xscale) < width) xscale++;

	if (yfraction > 0x20000)
		filterLevelY = filterLevel.halfY;
	else
		filterLevelY = filterLevel.fullY;

	if (xfraction > 0x20000)
		filterLevelX = filterLevel.halfX;
	else
		filterLevelX = filterLevel.fullX;

	vcp.xfraction = xfraction;
	vcp.yfraction = yfraction;
	vcp.xoffset = xoffset;
	vcp.xscale = xscale;

	vcp.width = width;
	vcp.height = height;
	vcp.mwidth = mwidth;

	vcp.stripeMask = stripeMask;

	vcp.bpr = bytesPerRow;
	vcp.mbpr = mstride;

	if (osd)
		{
		vcp.dd = osd->colorLookup;
		osd->GetDisplayParameters(width, height, vcp.xosdstart, vcp.xosdstop, vcp.yosdstart, vcp.yosdstop,
				                    vcp.osdNonZeroMap, vcp.yosdoffset, vcp.po, vcp.obpr);
		}

	if (sstart > 0)
		{
		sstart -= 2;
		sheight += 2;
		}

	if (sstart + sheight < height)
		sheight -= 2;

	vcp.ystart = sstart * mheight / height;
	vcp.ystop = (sstart + sheight) * mheight / height;

	vcp.py = yb;
	vcp.puv = uvb;

	vcp.pmt = topMap + vcp.ystart * mstride;
	vcp.pmb = bottomMap + vcp.ystart * mstride;

	vcp.deinterlaceFlags = flags;

	vcp.ycount = vcp.ystart * yfraction;

	if (osd)
		yuvConverter->ConvertStripeToYUVPSSI2ThroughOSD_P8F2(vcp);
	else
		yuvConverter->ConvertStripeToYUVPSSI2_P8F2(vcp);
	}

void FrameStore::ConvertToYUVStripeLetterbox(BYTE * topMap, BYTE * bottomMap,
			                                    int mwidth, int mheight, int mstride,
												         int sstart, int sheight,
												         bool lace, bool singleField, PictureStructure fmode,
											            VideoDownscaleFilterLevelSet filterLevel,
												         FullWidthMMXSPUDisplayBuffer * osd)
	{
	int xscale, yfraction, xfraction;
	BYTE * pmt, * pmb, * pm;
	int bpr, mbpr, obpr;
	VideoDownscaleFilterLevel	filterLevelX, filterLevelY;
	int sstop;

	YUVVideoConverterParameter  vcp;

	mwidth = (mwidth + 3) & ~3;

	xfraction = 0x10000 * width / mwidth;
	yfraction = 0x10000 * height / mheight;
	xscale = 0;
	while ((mwidth << xscale) < width) xscale++;

	if (yfraction > 0x20000)
		filterLevelY = filterLevel.halfY;
	else
		filterLevelY = filterLevel.fullY;

	if (xfraction > 0x20000)
		filterLevelX = filterLevel.halfX;
	else
		filterLevelX = filterLevel.fullX;

	if (!(singleField && fmode == PS_BOTTOM_FIELD))
		{
		bpr = bytesPerRow;
		mbpr = mstride;

		if (bottomMap != NULL) lace = true;

		if (osd)
			{
			vcp.dd = osd->colorLookup;
			osd->GetDisplayParameters(width, height, vcp.xosdstart, vcp.xosdstop, vcp.yosdstart, vcp.yosdstop,
											  vcp.osdNonZeroMap, vcp.yosdoffset, vcp.po, obpr);
			}

		if (yfraction != 0x10000)
			{
			switch (filterLevelY)
				{
				case VSQL_BINARY:
				case VSQL_DROP:
					break;
				case VSQL_LINEAR:
				case VSQL_FOUR_TAP:
					if (sstart > 0)
						{
						sstart -= 2;
						sheight += 2;
						}

					if (sstart + sheight < height)
						sheight -= 2;
					break;
				case VSQL_EIGHT_TAP:
					if (sstart > 0)
						{
						sstart -= 4;
						sheight += 4;
						}

					if (sstart + sheight < height)
						sheight -= 4;
					break;
				}
			}

		vcp.lboffset = height >> 3;

		sstop = sstart + sheight;
		if (sstart != 0)
			{
			sstart = ((sstart * 3) >> 2) + vcp.lboffset;
			}

		if (sstop != height)
			{
			sstop = ((sstop * 3) >> 2) + vcp.lboffset;
			}
		sheight = sstop - sstart;

		if (fmode == PS_FRAME_PICTURE)
			{
			vcp.ystart = sstart * mheight / height;
			vcp.ystop = (sstart + sheight) * mheight / height;
			}
		else
			{
			bpr *= 2;
			obpr *= 2;

			vcp.ystart = sstart * mheight / height;
			vcp.ystop = (sstart + sheight) * mheight / height;
			}


		vcp.width = width;
		vcp.xscale = xscale;
		vcp.py = yb;
		vcp.puv = uvb;

		if (fmode == PS_BOTTOM_FIELD)
			{
			vcp.py += bytesPerRow;
			vcp.puv += bytesPerRow;
			}

		if (fmode == PS_FRAME_PICTURE && lace && !singleField)
			{
			vcp.ystart >>= 1;
			vcp.ystop >>= 1;
			vcp.yosdstart >>= 1;
			vcp.yosdstop >>= 1;
			vcp.lboffset >>= 1;

			if (bottomMap)
				pmb = bottomMap + vcp.ystart * mbpr;
			else
				{
				pmb = topMap + (2 * vcp.ystart + 1) * mbpr;
				mbpr *= 2;
				}
			pmt = topMap + vcp.ystart * mbpr;

			vcp.height = height >> 1;
			vcp.pm = pmt;
			vcp.bpr = bpr * 2;
			vcp.mbpr = mbpr;
			vcp.obpr = 2 * obpr;
			vcp.ycount = vcp.ystart * yfraction;
			vcp.yfraction = yfraction;
			vcp.stripeMask = stripeMask >> 1;

			if (osd)
				yuvConverter->ConvertStripeToYUVLBThroughOSD_P8DSY2(vcp);
			else
				yuvConverter->ConvertStripeToYUVLB_P8DSY2(vcp);

			vcp.py += bpr;
			vcp.puv += bpr;
			vcp.pm = pmb;
			vcp.po += obpr;

			if (osd)
				yuvConverter->ConvertStripeToYUVLBThroughOSD_P8DSY2(vcp);
			else
				yuvConverter->ConvertStripeToYUVLB_P8DSY2(vcp);
			}
		else
			{
			if (lace && singleField)
				{
				yfraction >>= 1;
				vcp.yosdstart >>= 1;
				vcp.yosdstop >>= 1;

				if (fmode == PS_FRAME_PICTURE)
					{
					bpr *= 2;
					obpr *= 2;
					stripeMask >>= 1;
					}
				else
					{
					vcp.ystart *= 2;
					vcp.ystop *= 2;
					}

				pm = topMap + vcp.ystart * mbpr;
				}
			else
				{
				switch (fmode)
					{
					case PS_FRAME_PICTURE:
						pm  = topMap + vcp.ystart * mbpr;
						break;
					case PS_TOP_FIELD:
						if (!bottomMap) mbpr *= 2;
						pm  = topMap + vcp.ystart * mbpr;
						break;
					case PS_BOTTOM_FIELD:
						if (bottomMap)
							pm  = bottomMap + vcp.ystart * mbpr;
						else
							{
							mbpr *= 2;
							pm = topMap + mstride + vcp.ystart * mbpr;
							}
						break;
					}
				}

			vcp.height = height;
			vcp.pm = pm;
			vcp.bpr = bpr;
			vcp.mbpr = mbpr;
			vcp.obpr = obpr;
			vcp.ycount = vcp.ystart * yfraction;
			vcp.yfraction = yfraction;
			vcp.stripeMask = stripeMask;

			if (osd)
				yuvConverter->ConvertStripeToYUVLBThroughOSD_P8DSY2(vcp);
			else
				yuvConverter->ConvertStripeToYUVLB_P8DSY2(vcp);
			}
		}
	}

void FrameStore::ConvertToYUVStripeLetterboxAverageDeinterlace(BYTE * topMap,
																					int mwidth, int mheight, int mstride,
																					int sstart, int sheight,
																					bool lace,
																					VideoDownscaleFilterLevelSet filterLevel,
																					FullWidthMMXSPUDisplayBuffer * osd)
	{
	int xscale, yfraction, xfraction;
	BYTE * pm;
	int bpr, mbpr, obpr;
	VideoDownscaleFilterLevel	filterLevelX, filterLevelY;
	int sstop;

	YUVVideoConverterParameter  vcp;

	mwidth = (mwidth + 3) & ~3;

	xfraction = 0x10000 * width / mwidth;
	yfraction = 0x10000 * height / mheight;
	xscale = 0;
	while ((mwidth << xscale) < width) xscale++;

	if (yfraction > 0x20000)
		filterLevelY = filterLevel.halfY;
	else
		filterLevelY = filterLevel.fullY;

	if (xfraction > 0x20000)
		filterLevelX = filterLevel.halfX;
	else
		filterLevelX = filterLevel.fullX;

	bpr = bytesPerRow;
	mbpr = mstride;

	if (osd)
		{
		vcp.dd = osd->colorLookup;
		osd->GetDisplayParameters(width, height, vcp.xosdstart, vcp.xosdstop, vcp.yosdstart, vcp.yosdstop,
										  vcp.osdNonZeroMap, vcp.yosdoffset, vcp.po, obpr);
		}

	if (sstart > 0)
		{
		sstart -= 2;
		sheight += 2;
		}

	if (sstart + sheight < height)
		sheight -= 2;

	vcp.lboffset = height >> 3;

	sstop = sstart + sheight;
	if (sstart != 0)
		{
		sstart = ((sstart * 3) >> 2) + vcp.lboffset;
		}

	if (sstop != height)
		{
		sstop = ((sstop * 3) >> 2) + vcp.lboffset;
		}
	sheight = sstop - sstart;

	vcp.ystart = sstart * mheight / height;
	vcp.ystop = (sstart + sheight) * mheight / height;

	vcp.width = width;
	vcp.xscale = xscale;
	vcp.py = yb;
	vcp.puv = uvb;

	pm = topMap + vcp.ystart * mbpr;

	vcp.height = height;
	vcp.pm = pm;
	vcp.bpr = bpr;
	vcp.mbpr = mbpr;
	vcp.obpr = obpr;
	vcp.ycount = vcp.ystart * yfraction;
	vcp.yfraction = yfraction;
	vcp.stripeMask = stripeMask;

	if (lace)
		{
		if (osd)
			yuvConverter->ConvertStripeToYUVLBAIThroughOSD_P8DSY2(vcp);
		else
			yuvConverter->ConvertStripeToYUVLBAI_P8DSY2(vcp);
		}
	else
		{
		if (osd)
			yuvConverter->ConvertStripeToYUVLBThroughOSD_P8DSY2(vcp);
		else
			yuvConverter->ConvertStripeToYUVLB_P8DSY2(vcp);
		}
	}

void FrameStore::ConvertToYUVStripeLetterboxDeinterlace(BYTE * previousMap, BYTE * currentMap, BYTE * nextMap, FrameStore * previous,
                                                        int mwidth, int mheight, int mstride,
															           int sstart, int sheight,
															           bool topFieldFirst, DWORD flags,
															           VideoDownscaleFilterLevelSet filterLevel,
															           FullWidthMMXSPUDisplayBuffer * osd)
	{
	int xscale, yfraction, xfraction;
	VideoDownscaleFilterLevel	filterLevelX, filterLevelY;
	YUVVideoConverterParameter  vcp;
	int sstop;

	mwidth = (mwidth + 3) & ~3;

	xfraction = 0x10000 * width / mwidth;
	yfraction = 0x10000 * height / mheight;
	xscale = 0;
	while ((mwidth << xscale) < width) xscale++;

	if (yfraction > 0x20000)
		filterLevelY = filterLevel.halfY;
	else
		filterLevelY = filterLevel.fullY;

	if (xfraction > 0x20000)
		filterLevelX = filterLevel.halfX;
	else
		filterLevelX = filterLevel.fullX;

	vcp.xfraction = xfraction;
	vcp.yfraction = yfraction;
	vcp.xscale = xscale;

	vcp.width = width;
	vcp.height = height;
	vcp.mwidth = mwidth;

	vcp.stripeMask = stripeMask;
	vcp.topField = topFieldFirst;

	vcp.bpr = bytesPerRow;
	vcp.mbpr = mstride;

	if (osd)
		{
		vcp.dd = osd->colorLookup;
		osd->GetDisplayParameters(width, height, vcp.xosdstart, vcp.xosdstop, vcp.yosdstart, vcp.yosdstop,
				                    vcp.osdNonZeroMap, vcp.yosdoffset, vcp.po, vcp.obpr);
		}

	if (sstart > 0)
		{
		sstart -= 2;
		sheight += 2;
		}

	if (sstart + sheight < height)
		sheight -= 2;

	vcp.lboffset = height >> 3;

	sstop = sstart + sheight;
	if (sstart != 0)
		{
		sstart = ((sstart * 3) >> 2) + vcp.lboffset;
		}

	if (sstop != height)
		{
		sstop = ((sstop * 3) >> 2) + vcp.lboffset;
		}
	sheight = sstop - sstart;

	vcp.ystart = sstart * mheight / height;
	vcp.ystop = (sstart + sheight) * mheight / height;

	if (topFieldFirst)
		{
		vcp.py = yb;
		vcp.puv = uvb;
		vcp.ppy = previous->yb;
		vcp.ppuv = previous->uvb;
		vcp.pytb = yb;
		vcp.puvtb = uvb;

		vcp.pm  = currentMap + vcp.ystart * mstride;
		vcp.ppm = previousMap + vcp.ystart * mstride;
		vcp.pmt = currentMap + vcp.ystart * mstride;
		vcp.pmb = nextMap + vcp.ystart * mstride;

		vcp.deinterlaceFlags = flags;
		}
	else
		{
		vcp.ppy = yb;
		vcp.ppuv = uvb;
		vcp.py = previous->yb;
		vcp.puv = previous->uvb;
		vcp.pytb = yb;
		vcp.puvtb = uvb;

		vcp.ppm = currentMap + vcp.ystart * mstride;
		vcp.pm  = previousMap + vcp.ystart * mstride;
		vcp.pmb = currentMap + vcp.ystart * mstride;
		vcp.pmt = nextMap + vcp.ystart * mstride;

		vcp.deinterlaceFlags = flags;
		}

	vcp.ycount = vcp.ystart * yfraction;

	if (osd)
		yuvConverter->ConvertStripeToYUVLBDI2ThroughOSD_P8DS(vcp);
	else
		yuvConverter->ConvertStripeToYUVLBDI2_P8DS(vcp);
	}

void FrameStore::ConvertToYUVStripeLetterboxInterpolate(BYTE * map, FrameStore * previous,
			                                               int mwidth, int mheight, int mstride,
												                    int sstart, int sheight,
												                    VideoDownscaleFilterLevelSet filterLevel,
												                    FullWidthMMXSPUDisplayBuffer * osd)
	{
	int xscale, yfraction, xfraction;
	VideoDownscaleFilterLevel	filterLevelX, filterLevelY;
	YUVVideoConverterParameter  vcp;
	int sstop;

	mwidth = (mwidth + 3) & ~3;

	xfraction = 0x10000 * width / mwidth;
	yfraction = 0x10000 * height / mheight;
	xscale = 0;
	while ((mwidth << xscale) < width) xscale++;

	if (yfraction > 0x20000)
		filterLevelY = filterLevel.halfY;
	else
		filterLevelY = filterLevel.fullY;

	if (xfraction > 0x20000)
		filterLevelX = filterLevel.halfX;
	else
		filterLevelX = filterLevel.fullX;

	vcp.xfraction = xfraction;
	vcp.yfraction = yfraction;
	vcp.xscale = xscale;

	vcp.width = width;
	vcp.height = height;
	vcp.mwidth = mwidth;

	vcp.stripeMask = stripeMask;

	vcp.bpr = bytesPerRow;
	vcp.mbpr = mstride;

	if (osd)
		{
		vcp.dd = osd->colorLookup;
		osd->GetDisplayParameters(width, height, vcp.xosdstart, vcp.xosdstop, vcp.yosdstart, vcp.yosdstop,
				                    vcp.osdNonZeroMap, vcp.yosdoffset, vcp.po, vcp.obpr);
		}

	vcp.lboffset = height >> 3;

	sstop = sstart + sheight;
	if (sstart != 0)
		{
		sstart = ((sstart * 3) >> 2) + vcp.lboffset;
		}

	if (sstop != height)
		{
		sstop = ((sstop * 3) >> 2) + vcp.lboffset;
		}
	sheight = sstop - sstart;

	vcp.ystart = sstart * mheight / height;
	vcp.ystop = (sstart + sheight) * mheight / height;

	vcp.py = yb;
	vcp.puv = uvb;
	vcp.ppy = previous->yb;
	vcp.ppuv = previous->uvb;

	vcp.pm = map + vcp.ystart * mstride;

	vcp.ycount = vcp.ystart * yfraction;

	if (osd)
		yuvConverter->ConvertStripeToYUVLBA2ThroughOSD_P8DS(vcp);
	else
		yuvConverter->ConvertStripeToYUVLBA2_P8DS(vcp);
	}

void FrameStore::ConvertToYUVStripeLetterboxDeinterlaceStretch(BYTE * topMap, BYTE * bottomMap,
			                                                      int mwidth, int mheight, int mstride,
																               int sstart, int sheight,
																               DWORD flags,
																               VideoDownscaleFilterLevelSet filterLevel,
																               FullWidthMMXSPUDisplayBuffer * osd)
	{
	int xscale, yfraction, xfraction;
	VideoDownscaleFilterLevel	filterLevelX, filterLevelY;
	YUVVideoConverterParameter  vcp;
	int sstop;

	mwidth = (mwidth + 3) & ~3;

	xfraction = 0x10000 * width / mwidth;
	yfraction = 0x10000 * height / mheight;
	xscale = 0;
	while ((mwidth << xscale) < width) xscale++;

	if (yfraction > 0x20000)
		filterLevelY = filterLevel.halfY;
	else
		filterLevelY = filterLevel.fullY;

	if (xfraction > 0x20000)
		filterLevelX = filterLevel.halfX;
	else
		filterLevelX = filterLevel.fullX;

	vcp.xfraction = xfraction;
	vcp.yfraction = yfraction;
	vcp.xscale = xscale;

	vcp.width = width;
	vcp.height = height;
	vcp.mwidth = mwidth;

	vcp.stripeMask = stripeMask;

	vcp.bpr = bytesPerRow;
	vcp.mbpr = mstride;

	if (osd)
		{
		vcp.dd = osd->colorLookup;
		osd->GetDisplayParameters(width, height, vcp.xosdstart, vcp.xosdstop, vcp.yosdstart, vcp.yosdstop,
				                    vcp.osdNonZeroMap, vcp.yosdoffset, vcp.po, vcp.obpr);
		}

	if (sstart > 0)
		{
		sstart -= 2;
		sheight += 2;
		}

	if (sstart + sheight < height)
		sheight -= 2;

	vcp.lboffset = height >> 3;

	sstop = sstart + sheight;
	if (sstart != 0)
		{
		sstart = ((sstart * 3) >> 2) + vcp.lboffset;
		}

	if (sstop != height)
		{
		sstop = ((sstop * 3) >> 2) + vcp.lboffset;
		}
	sheight = sstop - sstart;

	vcp.ystart = sstart * mheight / height;
	vcp.ystop = (sstart + sheight) * mheight / height;

	vcp.py = yb;
	vcp.puv = uvb;

	vcp.pmt = topMap + vcp.ystart * mstride;
	vcp.pmb = bottomMap + vcp.ystart * mstride;

	vcp.deinterlaceFlags = flags;

	vcp.ycount = vcp.ystart * yfraction;

	if (osd)
		yuvConverter->ConvertStripeToYUVLBSI2ThroughOSD_P8DS(vcp);
	else
		yuvConverter->ConvertStripeToYUVLBSI2_P8DS(vcp);
	}

void FrameStore::ConvertToYUVStripeLetterboxSingleInverse32Pulldown(BYTE * topMap, FrameStore * previous,
			                                                           int mwidth, int mheight, int mstride,
												                                int sstart, int sheight,
												                                Inverse32PulldownHint phint,
												                                VideoDownscaleFilterLevelSet filterLevel,
												                                FullWidthMMXSPUDisplayBuffer * osd)
	{
	int xscale, yfraction, xfraction;
	VideoDownscaleFilterLevel	filterLevelX, filterLevelY;
	YUVVideoConverterParameter  vcp;
	enum {CTY_FRAME, CTY_FRAME_FIELD, CTY_FIELD_FIELD} ctype;
	int sstop;

	mwidth = (mwidth + 3) & ~3;

	xfraction = 0x10000 * width / mwidth;
	yfraction = 0x10000 * height / mheight;
	xscale = 0;
	while ((mwidth << xscale) < width) xscale++;

	if (yfraction > 0x20000)
		filterLevelY = filterLevel.halfY;
	else
		filterLevelY = filterLevel.fullY;

	if (xfraction > 0x20000)
		filterLevelX = filterLevel.halfX;
	else
		filterLevelX = filterLevel.fullX;

	vcp.xfraction = xfraction;
	vcp.yfraction = yfraction;
	vcp.xscale = xscale;

	vcp.width = width;
	vcp.height = height;
	vcp.mwidth = mwidth;

	vcp.stripeMask = stripeMask;

	vcp.bpr = bytesPerRow;
	vcp.mbpr = mstride;

	if (osd)
		{
		vcp.dd = osd->colorLookup;
		osd->GetDisplayParameters(width, height, vcp.xosdstart, vcp.xosdstop, vcp.yosdstart, vcp.yosdstop,
				                    vcp.osdNonZeroMap, vcp.yosdoffset, vcp.po, vcp.obpr);
		}

	if (sstart > 0)
		{
		sstart -= 2;
		sheight += 2;
		}

	if (sstart + sheight < height)
		sheight -= 2;

	vcp.lboffset = height >> 3;

	sstop = sstart + sheight;
	if (sstart != 0)
		{
		sstart = ((sstart * 3) >> 2) + vcp.lboffset;
		}

	if (sstop != height)
		{
		sstop = ((sstop * 3) >> 2) + vcp.lboffset;
		}
	sheight = sstop - sstart;

	vcp.ystart = sstart * mheight / height;
	vcp.ystop = (sstart + sheight) * mheight / height;

	switch (phint)
		{
		case IPDH_FRAME_FRAME1:
		case IPDH_FRAME_FRAME2:
			ctype = CTY_FRAME;
			vcp.py = yb;
			vcp.puv = uvb;
			break;
		case IPDH_TOP_FRAME:
			ctype = CTY_FRAME_FIELD;
			vcp.py = yb;
			vcp.puv = uvb;
			vcp.ppy = previous->yb;
			vcp.ppuv = previous->uvb;
			vcp.topField = true;
			break;
		case IPDH_BOTTOM_FRAME:
			ctype = CTY_FRAME_FIELD;
			vcp.py = yb;
			vcp.puv = uvb;
			vcp.ppy = previous->yb;
			vcp.ppuv = previous->uvb;
			vcp.topField = false;
			break;
		case IPDH_BOTTOM_TOP:
			ctype = CTY_FIELD_FIELD;
			vcp.py = yb;
			vcp.puv = uvb;
			vcp.ppy = previous->yb;
			vcp.ppuv = previous->uvb;
			break;
		case IPDH_TOP_BOTTOM:
			ctype = CTY_FIELD_FIELD;
			vcp.py = previous->yb;
			vcp.puv = previous->uvb;
			vcp.ppy = yb;
			vcp.ppuv = uvb;
			break;
		case IPDH_FRAME_TOP:
			ctype = CTY_FRAME_FIELD;
			vcp.py = previous->yb;
			vcp.puv = previous->uvb;
			vcp.ppy = yb;
			vcp.ppuv = uvb;
			vcp.topField = true;
			break;
		case IPDH_FRAME_BOTTOM:
			ctype = CTY_FRAME_FIELD;
			vcp.py = previous->yb;
			vcp.puv = previous->uvb;
			vcp.ppy = yb;
			vcp.ppuv = uvb;
			vcp.topField = false;
			break;
		}

	vcp.pm  = topMap + vcp.ystart * mstride;

	vcp.ycount = vcp.ystart * yfraction;


	switch (ctype)
		{
		case CTY_FRAME:
			if (osd)
				yuvConverter->ConvertStripeToYUVLBThroughOSD_P8DSY2(vcp);
			else
				yuvConverter->ConvertStripeToYUVLB_P8DSY2(vcp);
			break;
		case CTY_FRAME_FIELD:
			if (osd)
				yuvConverter->ConvertStripeToYUVLB32PDFrameFieldThroughOSD_P8DS(vcp);
			else
				yuvConverter->ConvertStripeToYUVLB32PDFrameField_P8DS(vcp);
			break;
		case CTY_FIELD_FIELD:
			if (osd)
				yuvConverter->ConvertStripeToYUVLB32PDFieldFieldThroughOSD_P8DS(vcp);
			else
				yuvConverter->ConvertStripeToYUVLB32PDFieldField_P8DS(vcp);
			break;
		}
	}

void FrameStore::ConvertToYUVStripeAverageDeinterlace(BYTE * topMap,
			                                             int mwidth, int mheight, int mstride,
												                  int sstart, int sheight,
												                  bool lace,
												                  VideoDownscaleFilterLevelSet filterLevel,
												                  FullWidthMMXSPUDisplayBuffer * osd)
	{
	int xscale, yfraction, xfraction;
	VideoDownscaleFilterLevel	filterLevelX, filterLevelY;
	YUVVideoConverterParameter  vcp;

	mwidth = (mwidth + 3) & ~3;

	xfraction = 0x10000 * width / mwidth;
	yfraction = 0x10000 * height / mheight;
	xscale = 0;
	while ((mwidth << xscale) < width) xscale++;

	if (yfraction > 0x20000)
		filterLevelY = filterLevel.halfY;
	else
		filterLevelY = filterLevel.fullY;

	if (xfraction > 0x20000)
		filterLevelX = filterLevel.halfX;
	else
		filterLevelX = filterLevel.fullX;

	vcp.xfraction = xfraction;
	vcp.yfraction = yfraction;
	vcp.xscale = xscale;

	vcp.width = width;
	vcp.height = height;
	vcp.mwidth = mwidth;

	vcp.stripeMask = stripeMask;

	vcp.bpr = bytesPerRow;
	vcp.mbpr = mstride;

	if (osd)
		{
		vcp.dd = osd->colorLookup;
		osd->GetDisplayParameters(width, height, vcp.xosdstart, vcp.xosdstop, vcp.yosdstart, vcp.yosdstop,
				                    vcp.osdNonZeroMap, vcp.yosdoffset, vcp.po, vcp.obpr);
		}

	if (sstart > 0)
		{
		sstart -= 2;
		sheight += 2;
		}

	if (sstart + sheight < height)
		sheight -= 2;

	vcp.ystart = sstart * mheight / height;
	vcp.ystop = (sstart + sheight) * mheight / height;

	vcp.py = yb;
	vcp.puv = uvb;

	vcp.pm  = topMap + vcp.ystart * mstride;

	vcp.ycount = vcp.ystart * yfraction;

	if (lace)
		{
		switch (filterLevelY)
			{
			case VSQL_BINARY:
			case VSQL_DROP:
				switch (filterLevelX)
					{
					case VSQL_BINARY:
						if (osd)
							yuvConverter->ConvertStripeToYUVAIThroughOSD_P8DS(vcp);
						else
							yuvConverter->ConvertStripeToYUVAI_P8DS(vcp);
						break;
					case VSQL_DROP:
					case VSQL_LINEAR:
					case VSQL_FOUR_TAP:
					case VSQL_EIGHT_TAP:
						if (osd)
							yuvConverter->ConvertStripeToYUVAIThroughOSD_P8F2(vcp);
						else
							yuvConverter->ConvertStripeToYUVAI_P8F2(vcp);
						break;
					}
				break;
			case VSQL_LINEAR:
			case VSQL_FOUR_TAP:
			case VSQL_EIGHT_TAP:
				switch (filterLevelX)
					{
					case VSQL_BINARY:
						if (osd)
							yuvConverter->ConvertStripeToYUVAIThroughOSD_P8DSY2(vcp);
						else
							yuvConverter->ConvertStripeToYUVAI_P8DSY2(vcp);
						break;
					case VSQL_DROP:
					case VSQL_LINEAR:
					case VSQL_FOUR_TAP:
					case VSQL_EIGHT_TAP:
						if (osd)
							yuvConverter->ConvertStripeToYUVAIThroughOSD_P8F2Y2(vcp);
						else
							yuvConverter->ConvertStripeToYUVAI_P8F2Y2(vcp);
						break;
					}
				break;
			}
		}
	else
		{
		switch (filterLevelX)
			{
			case VSQL_BINARY:
				if (osd)
					yuvConverter->ConvertStripeToYUVThroughOSD_P8DS(vcp);
				else
					yuvConverter->ConvertStripeToYUV_P8DS(vcp);
				break;
			case VSQL_DROP:
			case VSQL_LINEAR:
			case VSQL_FOUR_TAP:
			case VSQL_EIGHT_TAP:
				if (osd)
					yuvConverter->ConvertStripeToYUVThroughOSD_P8F2(vcp);
				else
					yuvConverter->ConvertStripeToYUV_P8F2(vcp);
				break;
			}
		}
	}

void FrameStore::ConvertToYUVStripeSingleDeinterlace(BYTE * topMap, FrameStore * previous,
			                                            int mwidth, int mheight, int mstride,
												                 int sstart, int sheight,
												                 bool topField,
												                 VideoDownscaleFilterLevelSet filterLevel,
												                 FullWidthMMXSPUDisplayBuffer * osd)
	{
	int xscale, yfraction, xfraction;
	VideoDownscaleFilterLevel	filterLevelX, filterLevelY;
	YUVVideoConverterParameter  vcp;

	mwidth = (mwidth + 3) & ~3;

	xfraction = 0x10000 * width / mwidth;
	yfraction = 0x10000 * height / mheight;
	xscale = 0;
	while ((mwidth << xscale) < width) xscale++;

	if (yfraction > 0x20000)
		filterLevelY = filterLevel.halfY;
	else
		filterLevelY = filterLevel.fullY;

	if (xfraction > 0x20000)
		filterLevelX = filterLevel.halfX;
	else
		filterLevelX = filterLevel.fullX;

	vcp.xfraction = xfraction;
	vcp.yfraction = yfraction;
	vcp.xscale = xscale;

	vcp.width = width;
	vcp.height = height;
	vcp.mwidth = mwidth;

	vcp.stripeMask = stripeMask;
	vcp.topField = topField;

	vcp.bpr = bytesPerRow;
	vcp.mbpr = mstride;

	if (osd)
		{
		vcp.dd = osd->colorLookup;
		osd->GetDisplayParameters(width, height, vcp.xosdstart, vcp.xosdstop, vcp.yosdstart, vcp.yosdstop,
				                    vcp.osdNonZeroMap, vcp.yosdoffset, vcp.po, vcp.obpr);
		}

	if (sstart > 0)
		{
		sstart -= 2;
		sheight += 2;
		}

	if (sstart + sheight < height)
		sheight -= 2;

	vcp.ystart = sstart * mheight / height;
	vcp.ystop = (sstart + sheight) * mheight / height;

	vcp.py = yb;
	vcp.puv = uvb;
	vcp.ppy = previous->yb;

	vcp.pm  = topMap + vcp.ystart * mstride;

	vcp.ycount = vcp.ystart * yfraction;

	switch (filterLevelY)
		{
		case VSQL_BINARY:
		case VSQL_DROP:
			switch (filterLevelX)
				{
				case VSQL_BINARY:
					if (osd)
						yuvConverter->ConvertStripeToYUVDIThroughOSD_P8DS(vcp);
					else
						yuvConverter->ConvertStripeToYUVDI_P8DS(vcp);
					break;
				case VSQL_DROP:
				case VSQL_LINEAR:
				case VSQL_FOUR_TAP:
				case VSQL_EIGHT_TAP:
					if (osd)
						yuvConverter->ConvertStripeToYUVDIThroughOSD_P8F2(vcp);
					else
						yuvConverter->ConvertStripeToYUVDI_P8F2(vcp);
					break;
				}
			break;
		case VSQL_LINEAR:
		case VSQL_FOUR_TAP:
		case VSQL_EIGHT_TAP:
			switch (filterLevelX)
				{
				case VSQL_BINARY:
					if (osd)
						yuvConverter->ConvertStripeToYUVDIThroughOSD_P8DSY2(vcp);
					else
						yuvConverter->ConvertStripeToYUVDI_P8DSY2(vcp);
					break;
				case VSQL_DROP:
				case VSQL_LINEAR:
				case VSQL_FOUR_TAP:
				case VSQL_EIGHT_TAP:
					if (osd)
						yuvConverter->ConvertStripeToYUVDIThroughOSD_P8F2Y2(vcp);
					else
						yuvConverter->ConvertStripeToYUVDI_P8F2Y2(vcp);
					break;
				}
			break;
		}
	}

void FrameStore::ConvertToYUVStripeSingleInverse32Pulldown(BYTE * topMap, FrameStore * previous,
			                                                    int mwidth, int mheight, int mstride,
												                         int sstart, int sheight,
												                         Inverse32PulldownHint phint,
												                         VideoDownscaleFilterLevelSet filterLevel,
												                         FullWidthMMXSPUDisplayBuffer * osd)
	{
	int xscale, yfraction, xfraction;
	VideoDownscaleFilterLevel	filterLevelX, filterLevelY;
	YUVVideoConverterParameter  vcp;
	enum {CTY_FRAME, CTY_FRAME_FIELD, CTY_FIELD_FIELD} ctype;

	mwidth = (mwidth + 3) & ~3;

	xfraction = 0x10000 * width / mwidth;
	yfraction = 0x10000 * height / mheight;
	xscale = 0;
	while ((mwidth << xscale) < width) xscale++;

	if (yfraction > 0x20000)
		filterLevelY = filterLevel.halfY;
	else
		filterLevelY = filterLevel.fullY;

	if (xfraction > 0x20000)
		filterLevelX = filterLevel.halfX;
	else
		filterLevelX = filterLevel.fullX;

	vcp.xfraction = xfraction;
	vcp.yfraction = yfraction;
	vcp.xscale = xscale;

	vcp.width = width;
	vcp.height = height;
	vcp.mwidth = mwidth;

	vcp.stripeMask = stripeMask;

	vcp.bpr = bytesPerRow;
	vcp.mbpr = mstride;

	if (osd)
		{
		vcp.dd = osd->colorLookup;
		osd->GetDisplayParameters(width, height, vcp.xosdstart, vcp.xosdstop, vcp.yosdstart, vcp.yosdstop,
				                    vcp.osdNonZeroMap, vcp.yosdoffset, vcp.po, vcp.obpr);
		}

	if (sstart > 0)
		{
		sstart -= 2;
		sheight += 2;
		}

	if (sstart + sheight < height)
		sheight -= 2;

	vcp.ystart = sstart * mheight / height;
	vcp.ystop = (sstart + sheight) * mheight / height;

	switch (phint)
		{
		case IPDH_FRAME_FRAME1:
		case IPDH_FRAME_FRAME2:
			ctype = CTY_FRAME;
			vcp.py = yb;
			vcp.puv = uvb;
			break;
		case IPDH_TOP_FRAME:
			ctype = CTY_FRAME_FIELD;
			vcp.py = yb;
			vcp.puv = uvb;
			vcp.ppy = previous->yb;
			vcp.ppuv = previous->uvb;
			vcp.topField = true;
			break;
		case IPDH_BOTTOM_FRAME:
			ctype = CTY_FRAME_FIELD;
			vcp.py = yb;
			vcp.puv = uvb;
			vcp.ppy = previous->yb;
			vcp.ppuv = previous->uvb;
			vcp.topField = false;
			break;
		case IPDH_BOTTOM_TOP:
			ctype = CTY_FIELD_FIELD;
			vcp.py = yb;
			vcp.puv = uvb;
			vcp.ppy = previous->yb;
			vcp.ppuv = previous->uvb;
			break;
		case IPDH_TOP_BOTTOM:
			ctype = CTY_FIELD_FIELD;
			vcp.py = previous->yb;
			vcp.puv = previous->uvb;
			vcp.ppy = yb;
			vcp.ppuv = uvb;
			break;
		case IPDH_FRAME_TOP:
			ctype = CTY_FRAME_FIELD;
			vcp.py = previous->yb;
			vcp.puv = previous->uvb;
			vcp.ppy = yb;
			vcp.ppuv = uvb;
			vcp.topField = true;
			break;
		case IPDH_FRAME_BOTTOM:
			ctype = CTY_FRAME_FIELD;
			vcp.py = previous->yb;
			vcp.puv = previous->uvb;
			vcp.ppy = yb;
			vcp.ppuv = uvb;
			vcp.topField = false;
			break;
		}

	vcp.pm  = topMap + vcp.ystart * mstride;

	vcp.ycount = vcp.ystart * yfraction;


	switch (filterLevelX)
		{
		case VSQL_BINARY:
			switch (ctype)
				{
				case CTY_FRAME:
					if (osd)
						yuvConverter->ConvertStripeToYUVThroughOSD_P8DS(vcp);
					else
						yuvConverter->ConvertStripeToYUV_P8DS(vcp);
					break;
				case CTY_FRAME_FIELD:
					if (osd)
						yuvConverter->ConvertStripeToYUV32PDFrameFieldThroughOSD_P8DS(vcp);
					else
						yuvConverter->ConvertStripeToYUV32PDFrameField_P8DS(vcp);
					break;
				case CTY_FIELD_FIELD:
					if (osd)
						yuvConverter->ConvertStripeToYUV32PDFieldFieldThroughOSD_P8DS(vcp);
					else
						yuvConverter->ConvertStripeToYUV32PDFieldField_P8DS(vcp);
					break;
				}
		case VSQL_DROP:
		case VSQL_LINEAR:
		case VSQL_FOUR_TAP:
		case VSQL_EIGHT_TAP:
			switch (ctype)
				{
				case CTY_FRAME:
					if (osd)
						yuvConverter->ConvertStripeToYUVThroughOSD_P8F2(vcp);
					else
						yuvConverter->ConvertStripeToYUV_P8F2(vcp);
					break;
				case CTY_FRAME_FIELD:
					if (osd)
						yuvConverter->ConvertStripeToYUV32PDFrameFieldThroughOSD_P8F2(vcp);
					else
						yuvConverter->ConvertStripeToYUV32PDFrameField_P8F2(vcp);
					break;
				case CTY_FIELD_FIELD:
					if (osd)
						yuvConverter->ConvertStripeToYUV32PDFieldFieldThroughOSD_P8F2(vcp);
					else
						yuvConverter->ConvertStripeToYUV32PDFieldField_P8F2(vcp);
					break;
				}
		}
	}

void FrameStore::ConvertToYUVStripeDeinterlace(BYTE * previousMap, BYTE * currentMap, BYTE * nextMap, FrameStore * previous,
                                               int mwidth, int mheight, int mstride,
															  int sstart, int sheight,
															  bool topFieldFirst, DWORD flags,
															  VideoDownscaleFilterLevelSet filterLevel,
															  FullWidthMMXSPUDisplayBuffer * osd)
	{
	int xscale, yfraction, xfraction;
	VideoDownscaleFilterLevel	filterLevelX, filterLevelY;
	YUVVideoConverterParameter  vcp;

	mwidth = (mwidth + 3) & ~3;

	xfraction = 0x10000 * width / mwidth;
	yfraction = 0x10000 * height / mheight;
	xscale = 0;
	while ((mwidth << xscale) < width) xscale++;

	if (yfraction > 0x20000)
		filterLevelY = filterLevel.halfY;
	else
		filterLevelY = filterLevel.fullY;

	if (xfraction > 0x20000)
		filterLevelX = filterLevel.halfX;
	else
		filterLevelX = filterLevel.fullX;

	vcp.xfraction = xfraction;
	vcp.yfraction = yfraction;
	vcp.xscale = xscale;

	vcp.width = width;
	vcp.height = height;
	vcp.mwidth = mwidth;

	vcp.stripeMask = stripeMask;
	vcp.topField = topFieldFirst;

	vcp.bpr = bytesPerRow;
	vcp.mbpr = mstride;

	if (osd)
		{
		vcp.dd = osd->colorLookup;
		osd->GetDisplayParameters(width, height, vcp.xosdstart, vcp.xosdstop, vcp.yosdstart, vcp.yosdstop,
				                    vcp.osdNonZeroMap, vcp.yosdoffset, vcp.po, vcp.obpr);
		}

	if (sstart > 0)
		{
		sstart -= 2;
		sheight += 2;
		}

	if (sstart + sheight < height)
		sheight -= 2;

	vcp.ystart = sstart * mheight / height;
	vcp.ystop = (sstart + sheight) * mheight / height;

	if (topFieldFirst)
		{
		vcp.py = yb;
		vcp.puv = uvb;
		vcp.ppy = previous->yb;
		vcp.ppuv = previous->uvb;
		vcp.pytb = yb;
		vcp.puvtb = uvb;

		vcp.pm  = currentMap + vcp.ystart * mstride;
		vcp.ppm = previousMap + vcp.ystart * mstride;
		vcp.pmt = currentMap + vcp.ystart * mstride;
		vcp.pmb = nextMap + vcp.ystart * mstride;

		vcp.deinterlaceFlags = flags;
		}
	else
		{
		vcp.ppy = yb;
		vcp.ppuv = uvb;
		vcp.py = previous->yb;
		vcp.puv = previous->uvb;
		vcp.pytb = yb;
		vcp.puvtb = uvb;

		vcp.ppm = currentMap + vcp.ystart * mstride;
		vcp.pm  = previousMap + vcp.ystart * mstride;
		vcp.pmb = currentMap + vcp.ystart * mstride;
		vcp.pmt = nextMap + vcp.ystart * mstride;

		vcp.deinterlaceFlags = flags;
		}

	vcp.ycount = vcp.ystart * yfraction;

	switch (filterLevelX)
		{
		case VSQL_BINARY:
			if (osd)
				yuvConverter->ConvertStripeToYUVDI2ThroughOSD_P8DS(vcp);
			else
				yuvConverter->ConvertStripeToYUVDI2_P8DS(vcp);
			break;
		case VSQL_DROP:
		case VSQL_LINEAR:
		case VSQL_FOUR_TAP:
		case VSQL_EIGHT_TAP:
			if (osd)
				yuvConverter->ConvertStripeToYUVDI2ThroughOSD_P8F2(vcp);
			else
				yuvConverter->ConvertStripeToYUVDI2_P8F2(vcp);
			break;
		}
	}

void FrameStore::ConvertToYUVStripeDeinterlaceStretch(BYTE * topMap, BYTE * bottomMap,
			                                               int mwidth, int mheight, int mstride,
																        int sstart, int sheight,
																        DWORD flags,
																        VideoDownscaleFilterLevelSet filterLevel,
																        FullWidthMMXSPUDisplayBuffer * osd)
	{
	int xscale, yfraction, xfraction;
	VideoDownscaleFilterLevel	filterLevelX, filterLevelY;
	YUVVideoConverterParameter  vcp;

	mwidth = (mwidth + 3) & ~3;

	xfraction = 0x10000 * width / mwidth;
	yfraction = 0x10000 * height / mheight;
	xscale = 0;
	while ((mwidth << xscale) < width) xscale++;

	if (yfraction > 0x20000)
		filterLevelY = filterLevel.halfY;
	else
		filterLevelY = filterLevel.fullY;

	if (xfraction > 0x20000)
		filterLevelX = filterLevel.halfX;
	else
		filterLevelX = filterLevel.fullX;

	vcp.xfraction = xfraction;
	vcp.yfraction = yfraction;
	vcp.xscale = xscale;

	vcp.width = width;
	vcp.height = height;
	vcp.mwidth = mwidth;

	vcp.stripeMask = stripeMask;

	vcp.bpr = bytesPerRow;
	vcp.mbpr = mstride;

	if (osd)
		{
		vcp.dd = osd->colorLookup;
		osd->GetDisplayParameters(width, height, vcp.xosdstart, vcp.xosdstop, vcp.yosdstart, vcp.yosdstop,
				                    vcp.osdNonZeroMap, vcp.yosdoffset, vcp.po, vcp.obpr);
		}

	if (sstart > 0)
		{
		sstart -= 2;
		sheight += 2;
		}

	if (sstart + sheight < height)
		sheight -= 2;

	vcp.ystart = sstart * mheight / height;
	vcp.ystop = (sstart + sheight) * mheight / height;

	vcp.py = yb;
	vcp.puv = uvb;

	vcp.pmt = topMap + vcp.ystart * mstride;
	vcp.pmb = bottomMap + vcp.ystart * mstride;

	vcp.deinterlaceFlags = flags;

	vcp.ycount = vcp.ystart * yfraction;

	switch (filterLevelX)
		{
		case VSQL_BINARY:
			if (osd)
				yuvConverter->ConvertStripeToYUVSI2ThroughOSD_P8DS(vcp);
			else
				yuvConverter->ConvertStripeToYUVSI2_P8DS(vcp);
			break;
		case VSQL_DROP:
		case VSQL_LINEAR:
		case VSQL_FOUR_TAP:
		case VSQL_EIGHT_TAP:
			if (osd)
				yuvConverter->ConvertStripeToYUVSI2ThroughOSD_P8F2(vcp);
			else
				yuvConverter->ConvertStripeToYUVSI2_P8F2(vcp);
			break;
		}
	}

void FrameStore::ConvertToYUVStripeInterpolate(BYTE * map, FrameStore * previous,
			                                        int mwidth, int mheight, int mstride,
												             int sstart, int sheight,
												             VideoDownscaleFilterLevelSet filterLevel,
												             FullWidthMMXSPUDisplayBuffer * osd)
	{
	int xscale, yfraction, xfraction;
	VideoDownscaleFilterLevel	filterLevelX, filterLevelY;
	YUVVideoConverterParameter  vcp;

	mwidth = (mwidth + 3) & ~3;

	xfraction = 0x10000 * width / mwidth;
	yfraction = 0x10000 * height / mheight;
	xscale = 0;
	while ((mwidth << xscale) < width) xscale++;

	if (yfraction > 0x20000)
		filterLevelY = filterLevel.halfY;
	else
		filterLevelY = filterLevel.fullY;

	if (xfraction > 0x20000)
		filterLevelX = filterLevel.halfX;
	else
		filterLevelX = filterLevel.fullX;

	vcp.xfraction = xfraction;
	vcp.yfraction = yfraction;
	vcp.xscale = xscale;

	vcp.width = width;
	vcp.height = height;
	vcp.mwidth = mwidth;

	vcp.stripeMask = stripeMask;

	vcp.bpr = bytesPerRow;
	vcp.mbpr = mstride;

	if (osd)
		{
		vcp.dd = osd->colorLookup;
		osd->GetDisplayParameters(width, height, vcp.xosdstart, vcp.xosdstop, vcp.yosdstart, vcp.yosdstop,
				                    vcp.osdNonZeroMap, vcp.yosdoffset, vcp.po, vcp.obpr);
		}

	vcp.ystart = sstart * mheight / height;
	vcp.ystop = (sstart + sheight) * mheight / height;

	vcp.py = yb;
	vcp.puv = uvb;
	vcp.ppy = previous->yb;
	vcp.ppuv = previous->uvb;

	vcp.pm = map + vcp.ystart * mstride;

	vcp.ycount = vcp.ystart * yfraction;

	switch (filterLevelX)
		{
		case VSQL_BINARY:
			if (osd)
				yuvConverter->ConvertStripeToYUVA2ThroughOSD_P8DS(vcp);
			else
				yuvConverter->ConvertStripeToYUVA2_P8DS(vcp);
			break;
		case VSQL_DROP:
		case VSQL_LINEAR:
		case VSQL_FOUR_TAP:
		case VSQL_EIGHT_TAP:
			if (osd)
				yuvConverter->ConvertStripeToYUVA2ThroughOSD_P8F2(vcp);
			else
				yuvConverter->ConvertStripeToYUVA2_P8F2(vcp);
			break;
		}
	}

void FrameStore::ConvertToRGBStripe(int depth, BYTE * map,
			                 int mwidth, int mheight, int mstride,
								  int sstart, int sheight, bool lace, PictureStructure fmode,
								  BYTE * bottomMap)
	{
	switch (depth)
		{
		case 15:
			ConvertToRGB15Stripe(map, mwidth, mheight, mstride,
								      sstart, sheight, lace, fmode, bottomMap);
			break;
		case 16:
			ConvertToRGB16Stripe(map, mwidth, mheight, mstride,
								      sstart, sheight, lace, fmode, bottomMap);
			break;
		case 32:
			ConvertToRGB32Stripe(map, mwidth, mheight, mstride,
								      sstart, sheight, lace, fmode, bottomMap);
			break;
		}
	}

void FrameStore::ConvertToRGBThroughOSDStripe(int depth, BYTE * map, FullWidthMMXSPUDisplayBuffer * osd,
			                                 int mwidth, int mheight, int mstride,
														int sstart, int sheight,
														bool lace, PictureStructure fmode,
														BYTE * bottomMap)
	{
	switch (depth)
		{
		case 15:
			ConvertToRGB15ThroughOSDStripe(map, osd, mwidth, mheight, mstride,
													 sstart, sheight, lace, fmode, bottomMap);
			break;
		}
	}

void FrameStore::ConvertToRGB32Stripe(BYTE * map,
			                 int mwidth, int mheight, int mstride,
								  int sstart, int sheight, bool lace, PictureStructure fmode,
								  BYTE * bottomMap)
	{
	BYTE * py, * puv, * pm, * pmt, * pmb;
	int mbpr, ybpr, uvbpr;
	int xscale, yscale, ystep;
	int ystart, ystop;
	int w;
	int y, bpr;

	xscale = 0;
	while (mwidth << xscale < width) xscale++;
	yscale = 0;
	while (mheight << yscale < height) yscale++;

	if (!yscale || fmode != PS_BOTTOM_FIELD)
		{
		bpr = bytesPerRow;

		if (fmode != PS_FRAME_PICTURE) bpr *= 2;

		ybpr = bpr << yscale;
		if (yscale)
			uvbpr = bpr << (yscale - 1);
		else
			uvbpr = 0;
		mbpr = mstride;

		ystart = sstart;
		ystop = ystart + sheight;

		w = width;

		ystep = 1 << yscale;

		py  = yb + bpr * (ystart & stripeMask);
		puv = uvb + bpr * ((ystart & stripeMask) >> 1);

		if (fmode == PS_BOTTOM_FIELD)
			{
			py += bytesPerRow;
			puv += bytesPerRow;
			}

		if (lace && fmode == PS_FRAME_PICTURE && !yscale)
			{
			pmt = map + (ystart >> 1) * mstride;
			if (bottomMap)
				pmb = bottomMap + (ystart >> 1) * mstride;
			else
				pmb = pmt + (mheight >> 1) * mstride;

			if (precision == 8)
				{
				switch (xscale)
					{
					case 0:
						for(y = ystart; y < ystop; y += ystep)
							{
							if (y & 1)
								{
								ConvertLineToRGB32_P8D1(py, puv + bytesPerRow, pmb, w);
								pmb  += mbpr;
								if (y & 2)
									{
									puv += 2 * bytesPerRow;
									}
								}
							else
								{
								ConvertLineToRGB32_P8D1(py, puv, pmt, w);
								pmt  += mbpr;
								}

							py  += ybpr;
							puv += uvbpr;
							}
						break;
					case 1:
						for(y = ystart; y < ystop; y += ystep)
							{
							if (y & 1)
								{
								ConvertLineToRGB32_P8D2(py, puv + bytesPerRow, pmb, w);
								pmb  += mbpr;
								if (y & 2)
									{
									puv += 2 * bytesPerRow;
									}
								}
							else
								{
								ConvertLineToRGB32_P8D2(py, puv, pmt, w);
								pmt  += mbpr;
								}

							py  += ybpr;
							puv += uvbpr;
							}
						break;
					default:
						for(y = ystart; y < ystop; y += ystep)
							{
							if (y & 1)
								{
								ConvertLineToRGB32_P8DS(py, puv + bytesPerRow, pmb, w, xscale);
								pmb  += mbpr;
								if (y & 2)
									{
									puv += 2 * bytesPerRow;
									}
								}
							else
								{
								ConvertLineToRGB32_P8DS(py, puv, pmt, w, xscale);
								pmt  += mbpr;
								}

							py  += ybpr;
							puv += uvbpr;
							}
						break;
					}
				}
			}
		else
			{
			switch (fmode)
				{
				case PS_FRAME_PICTURE:
					pm  = map + (ystart >> yscale) * mstride;
					break;
				case PS_TOP_FIELD:
					pm  = map + (ystart >> yscale) * mstride;
					break;
				case PS_BOTTOM_FIELD:
					if (bottomMap)
						pm  = bottomMap + (ystart >> yscale) * mstride;
					else
						pm  = map + ((ystart + (mheight >> 1)) >> yscale) * mstride;
					break;
				}

			if (precision == 8)
				{
				switch (xscale)
					{
					case 0:
						for(y = ystart; y < ystop; y += ystep)
							{
							ConvertLineToRGB32_P8D1(py, puv, pm, w);

							py  += ybpr;
							puv += uvbpr;
							pm  += mbpr;
							if (y & 1) puv += bpr;
							}
						break;
					case 1:
						for(y = ystart; y < ystop; y += ystep)
							{
							ConvertLineToRGB32_P8D2(py, puv, pm, w);

							py  += ybpr;
							puv += uvbpr;
							pm  += mbpr;
							if (y & 1) puv += bpr;
							}
						break;
					default:
						for(y = ystart; y < ystop; y += ystep)
							{
							ConvertLineToRGB32_P8DS(py, puv, pm, w, xscale);

							py  += ybpr;
							puv += uvbpr;
							pm  += mbpr;
							if (y & 1) puv += bpr;
							}
						break;
					}
				}
			}
		}
	}

	//
	// map     : Base pointer of display memory
   // osd     : OSD bitmap to alpha blend with
   // mwidth  : width of display buffer
   // mheight : height of display buffer (both fields)
   // mstride : distance between two lines of the same field (or
   //           frame in non laced mode)
   // sstart  : slice start in source coordinates
   // sheight : slice height in source coordinates
   // lace    : target buffer resembles interlaced format
   // fmode   : Structure of source picture
   //
void FrameStore::ConvertToRGB15ThroughOSDStripe(BYTE * map, FullWidthMMXSPUDisplayBuffer * osd,
		                                  int mwidth, int mheight, int mstride,
		 										    int sstart, int sheight,
													 bool lace, PictureStructure fmode, BYTE * bottomMap)
	{
	BYTE * py, * puv, * pm, * po, * pmt, *pmb;
	DDWORD * dd = osd->colorLookup;
	int mbpr, ybpr, uvbpr, obpr;
	int xscale, yscale, ystep;
	int ystart, ystop, yosdstart, yosdstop;
	int xosdstart, xosdstop;
	int w, lw, ow, rw;
	int y, bpr, oobpr;

	//
	// Calculate scaling factors based on binary scale using
	// frame buffer size an video display buffer size
	//
	xscale = 0;
	while (mwidth << xscale < width) xscale++;
	yscale = 0;
	while (mheight << yscale < height) yscale++;

	//
	// If picture is in native size, or not the second field
	// of field encoded material
	//
	if (!yscale || fmode != PS_BOTTOM_FIELD)
		{
		//
		// Cache bytes per row of frame buffer and osd buffer
		//
		bpr = bytesPerRow;
		oobpr = osd->bytesPerRow;

		//
		// If the source material is not frame based, we only
		// have a single field so we work with double strides
		// on the source side.
		//
		if (fmode != PS_FRAME_PICTURE)
			{
			bpr *= 2;
			oobpr *= 2;
			if (yscale) yscale--;
			}

		//
		// Calculate source and osd bytes per row based on scaling
		// factor
		//
		ybpr = bpr << yscale;
		if (yscale)
			uvbpr = bpr << (yscale - 1);
		else
			uvbpr = 0;
		obpr = oobpr << yscale;

		//
		// Target bytes per row is always the given one, because
		// we have to fill the display buffer completely
		//
		mbpr = mstride;

		//
		// Calculate first line of and first line after update
		// region
		//
		ystart = sstart;
		ystop = ystart + sheight;

		//
		// Clip OSD region into update region
		//
		yosdstart = osd->nonTransparentTop;
		if (yosdstart < ystart) yosdstart = ystart;
		else if (yosdstart > ystop) yosdstart = ystop;
		yosdstop = osd->nonTransparentTop + osd->nonTransparentHeight;
		if (yosdstop > ystop) yosdstop = ystop;

		//
		// Calculate nonscaled horizontal source coordinates
		//
		xosdstart = osd->left;
		xosdstop = osd->left + osd->width;

		w = width;
		lw = xosdstart;
		ow = xosdstop - xosdstart;
		rw = width - xosdstop;

		//
		// Step in source frame buffer based on scaling
		//
		ystep = 1 << yscale;

		//
		// Calculate source pointers
		//
		py  = yb + bpr * (ystart & stripeMask);
		puv = uvb + bpr * ((ystart & stripeMask) >> 1);
		po  = osd->image + oobpr * (yosdstart - osd->top);

		//
		// If this is the bottom field in a field encoded picture
		// we have to go one line down to reach the first source
		// line of interest
		//
		if (fmode == PS_BOTTOM_FIELD)
			{
			py += bytesPerRow;
			puv += bytesPerRow;
			po += osd->bytesPerRow;
			}

		//
		// If the frame buffer is split, and the source mode is
		// frame based, and we are not vertically subsampling,
		// then we have to use the split transfer routine.
		//
		if (lace && fmode == PS_FRAME_PICTURE && !yscale)
			{
			//
			// Calculate target address
			//
			pmt = map + (ystart >> 1) * mstride;
			if (bottomMap)
				pmb = bottomMap + (ystart >> 1) * mstride;
			else
				pmb = pmt + (mheight >> 1) * mstride;

			switch (xscale)
				{
				case 0:
					for(y = ystart; y < yosdstart; y += ystep)
						{
						if (y & 1)
							{
							ConvertLineToRGB15_P8D1(py, puv + bytesPerRow, pmb, w);
							pmb  += mbpr;
							if (y & 2)
								{
								puv += 2 * bytesPerRow;
								}
							}
						else
							{
							ConvertLineToRGB15_P8D1(py, puv, pmt, w);
							pmt  += mbpr;
							}

						py  += ybpr;
						puv += uvbpr;
						}
					for(; y < yosdstop; y += ystep)
						{
						if (y & 1)
							{
							ConvertLineToRGB15_P8D1(py, puv + bytesPerRow, pmb, lw);
							ConvertLineToRGB15ThroughOSD_P8D1(py + xosdstart, puv + bytesPerRow + xosdstart, pmb + (xosdstart << 1), ow, po, dd);
							ConvertLineToRGB15_P8D1(py + xosdstop, puv + bytesPerRow + xosdstop, pmb + (xosdstop << 1), rw);

							pmb  += mbpr;
							if (y & 2)
								{
								puv += 2 * bytesPerRow;
								}
							}
						else
							{
							ConvertLineToRGB15_P8D1(py, puv, pmt, lw);
							ConvertLineToRGB15ThroughOSD_P8D1(py + xosdstart, puv + xosdstart, pmt + (xosdstart << 1), ow, po, dd);
							ConvertLineToRGB15_P8D1(py + xosdstop, puv + xosdstop, pmt + (xosdstop << 1), rw);
							pmt  += mbpr;
							}

						py  += ybpr;
						puv += uvbpr;
						po  += obpr;
						}
					for(; y < ystop; y += ystep)
						{
						if (y & 1)
							{
							ConvertLineToRGB15_P8D1(py, puv + bytesPerRow, pmb, w);
							pmb  += mbpr;
							if (y & 2)
								{
								puv += 2 * bytesPerRow;
								}
							}
						else
							{
							ConvertLineToRGB15_P8D1(py, puv, pmt, w);
							pmt  += mbpr;
							}

						py  += ybpr;
						puv += uvbpr;
						}
					break;
				case 1:
					for(y = ystart; y < yosdstart; y += ystep)
						{
						if (y & 1)
							{
							ConvertLineToRGB15_P8D2(py, puv + bytesPerRow, pmb, w);
							pmb  += mbpr;
							if (y & 2)
								{
								puv += 2 * bytesPerRow;
								}
							}
						else
							{
							ConvertLineToRGB15_P8D2(py, puv, pmt, w);
							pmt  += mbpr;
							}

						py  += ybpr;
						puv += uvbpr;
						}
					for(; y < yosdstop; y += ystep)
						{
						if (y & 1)
							{
							ConvertLineToRGB15_P8D2(py, puv + bytesPerRow, pmb, lw);
							ConvertLineToRGB15ThroughOSD_P8D2(py + xosdstart, puv + bytesPerRow + xosdstart, pmb + xosdstart, ow, po, dd);
							ConvertLineToRGB15_P8D2(py + xosdstop, puv + bytesPerRow + xosdstop, pmb + xosdstop, rw);

							pmb  += mbpr;
							if (y & 2)
								{
								puv += 2 * bytesPerRow;
								}
							}
						else
							{
							ConvertLineToRGB15_P8D2(py, puv, pmt, lw);
							ConvertLineToRGB15ThroughOSD_P8D2(py + xosdstart, puv + xosdstart, pmt + xosdstart, ow, po, dd);
							ConvertLineToRGB15_P8D2(py + xosdstop, puv + xosdstop, pmt + xosdstop, rw);
							pmt  += mbpr;
							}

						py  += ybpr;
						puv += uvbpr;
						po  += obpr;
						}
					for(; y < ystop; y += ystep)
						{
						if (y & 1)
							{
							ConvertLineToRGB15_P8D2(py, puv + bytesPerRow, pmb, w);
							pmb  += mbpr;
							if (y & 2)
								{
								puv += 2 * bytesPerRow;
								}
							}
						else
							{
							ConvertLineToRGB15_P8D2(py, puv, pmt, w);
							pmt  += mbpr;
							}

						py  += ybpr;
						puv += uvbpr;
						}
					break;
				default:
					for(y = ystart; y < yosdstart; y += ystep)
						{
						if (y & 1)
							{
							ConvertLineToRGB15_P8DS(py, puv + bytesPerRow, pmb, w, xscale);
							pmb  += mbpr;
							if (y & 2)
								{
								puv += 2 * bytesPerRow;
								}
							}
						else
							{
							ConvertLineToRGB15_P8DS(py, puv, pmt, w, xscale);
							pmt  += mbpr;
							}

						py  += ybpr;
						puv += uvbpr;
						}
					for(; y < yosdstop; y += ystep)
						{
						if (y & 1)
							{
							ConvertLineToRGB15_P8DS(py, puv + bytesPerRow, pmb, lw, xscale);
							ConvertLineToRGB15ThroughOSD_P8DS(py + xosdstart, puv + bytesPerRow + xosdstart, pmb + (xosdstart >> (xscale - 1)), ow, po, dd, xscale);
							ConvertLineToRGB15_P8DS(py + xosdstop, puv + bytesPerRow + xosdstop, pmb + (xosdstop >> (xscale - 1)), rw, xscale);

							pmb  += mbpr;
							if (y & 2)
								{
								puv += 2 * bytesPerRow;
								}
							}
						else
							{
							ConvertLineToRGB15_P8DS(py, puv, pmt, lw, xscale);
							ConvertLineToRGB15ThroughOSD_P8DS(py + xosdstart, puv + xosdstart, pmt + (xosdstart >> (xscale - 1)), ow, po, dd, xscale);
							ConvertLineToRGB15_P8DS(py + xosdstop, puv + xosdstop, pmt + (xosdstop >> (xscale - 1)), rw, xscale);
							pmt  += mbpr;
							}

						py  += ybpr;
						puv += uvbpr;
						po  += obpr;
						}
					for(; y < ystop; y += ystep)
						{
						if (y & 1)
							{
							ConvertLineToRGB15_P8DS(py, puv + bytesPerRow, pmb, w, xscale);
							pmb  += mbpr;
							if (y & 2)
								{
								puv += 2 * bytesPerRow;
								}
							}
						else
							{
							ConvertLineToRGB15_P8DS(py, puv, pmt, w, xscale);
							pmt  += mbpr;
							}

						py  += ybpr;
						puv += uvbpr;
						}
					break;
				}
			}
		else
			{
			switch (fmode)
				{
				case PS_FRAME_PICTURE:
					pm  = map + (ystart >> yscale) * mstride;
					break;
				case PS_TOP_FIELD:
					pm  = map + (ystart >> yscale) * mstride;
					break;
				case PS_BOTTOM_FIELD:
					if (bottomMap)
						pm  = bottomMap + (ystart >> yscale) * mstride;
					else
						pm  = map + ((ystart + (mheight >> 1)) >> yscale) * mstride;
					break;
				}

			switch (xscale)
				{
				case 0:
					for(y = ystart; y < yosdstart; y += ystep)
						{
						ConvertLineToRGB15_P8D1(py, puv, pm, w);

						py  += ybpr;
						puv += uvbpr;
						pm  += mbpr;
						if (y & 1) puv += bpr;
						}
					for(; y < yosdstop; y += ystep)
						{
						ConvertLineToRGB15_P8D1(py, puv, pm, lw);
						ConvertLineToRGB15ThroughOSD_P8D1(py + xosdstart, puv + xosdstart, pm + (xosdstart << 1), ow, po, dd);
						ConvertLineToRGB15_P8D1(py + xosdstop, puv + xosdstop, pm + (xosdstop << 1), rw);

						py  += ybpr;
						puv += uvbpr;
						pm  += mbpr;
						po  += obpr;
						if (y & 1) puv += bpr;
						}
					for(; y < ystop; y += ystep)
						{
						ConvertLineToRGB15_P8D1(py, puv, pm, w);

						py  += ybpr;
						puv += uvbpr;
						pm  += mbpr;
						if (y & 1) puv += bpr;
						}
					break;
				case 1:
					for(y = ystart; y < yosdstart; y += ystep)
						{
						ConvertLineToRGB15_P8D2(py, puv, pm, w);

						py  += ybpr;
						puv += uvbpr;
						pm  += mbpr;
						if (y & 1) puv += bpr;
						}
					for(; y < yosdstop; y += ystep)
						{
						ConvertLineToRGB15_P8D2(py, puv, pm, lw);
						ConvertLineToRGB15ThroughOSD_P8D2(py + xosdstart, puv + xosdstart, pm + xosdstart, ow, po, dd);
						ConvertLineToRGB15_P8D2(py + xosdstop, puv + xosdstop, pm + xosdstop, rw);

						py  += ybpr;
						puv += uvbpr;
						pm  += mbpr;
						po  += obpr;
						if (y & 1) puv += bpr;
						}
					for(; y < ystop; y += ystep)
						{
						ConvertLineToRGB15_P8D2(py, puv, pm, w);

						py  += ybpr;
						puv += uvbpr;
						pm  += mbpr;
						if (y & 1) puv += bpr;
						}
					break;
				default:
					for(y = ystart; y < yosdstart; y += ystep)
						{
						ConvertLineToRGB15_P8DS(py, puv, pm, w, xscale);

						py  += ybpr;
						puv += uvbpr;
						pm  += mbpr;
						if (y & 1) puv += bpr;
						}
					for(; y < yosdstop; y += ystep)
						{
						ConvertLineToRGB15_P8DS(py, puv, pm, lw, xscale);
						ConvertLineToRGB15ThroughOSD_P8DS(py + xosdstart, puv + xosdstart, pm + (xosdstart >> (xscale - 1)), ow, po, dd, xscale);
						ConvertLineToRGB15_P8DS(py + xosdstop, puv + xosdstop, pm + (xosdstop >> (xscale - 1)), rw, xscale);

						py  += ybpr;
						puv += uvbpr;
						pm  += mbpr;
						po  += obpr;
						if (y & 1) puv += bpr;
						}
					for(; y < ystop; y += ystep)
						{
						ConvertLineToRGB15_P8DS(py, puv, pm, w, xscale);

						py  += ybpr;
						puv += uvbpr;
						pm  += mbpr;
						if (y & 1) puv += bpr;
						}
					break;
				}
			}
		}
	}

void FrameStore::ConvertToRGB15Stripe(BYTE * map,
			                 int mwidth, int mheight, int mstride,
								  int sstart, int sheight, bool lace, PictureStructure fmode,
								  BYTE * bottomMap)
	{
	BYTE * py, * puv, * pm, * pmt, * pmb;
	int mbpr, ybpr, uvbpr;
	int xscale, yscale, ystep;
	int ystart, ystop;
	int w;
	int y, bpr;

	xscale = 0;
	while (mwidth << xscale < width) xscale++;
	yscale = 0;
	while (mheight << yscale < height) yscale++;

	if (!yscale || fmode != PS_BOTTOM_FIELD)
		{
		bpr = bytesPerRow;

		if (fmode != PS_FRAME_PICTURE) bpr *= 2;

		ybpr = bpr << yscale;
		if (yscale)
			uvbpr = bpr << (yscale - 1);
		else
			uvbpr = 0;
		mbpr = mstride;

		ystart = sstart;
		ystop = ystart + sheight;

		w = width;

		ystep = 1 << yscale;

		py  = yb + bpr * (ystart & stripeMask);
		puv = uvb + bpr * ((ystart & stripeMask) >> 1);

		if (fmode == PS_BOTTOM_FIELD)
			{
			py += bytesPerRow;
			puv += bytesPerRow;
			}

		if (lace && fmode == PS_FRAME_PICTURE && !yscale)
			{
			pmt = map + (ystart >> 1) * mstride;
			if (bottomMap)
				pmb = bottomMap + (ystart >> 1) * mstride;
			else
				pmb = pmt + (mheight >> 1) * mstride;

			if (precision == 8)
				{
				switch (xscale)
					{
					case 0:
						for(y = ystart; y < ystop; y += ystep)
							{
							if (y & 1)
								{
								ConvertLineToRGB15_P8D1(py, puv + bytesPerRow, pmb, w);
								pmb  += mbpr;
								if (y & 2)
									{
									puv += 2 * bytesPerRow;
									}
								}
							else
								{
								ConvertLineToRGB15_P8D1(py, puv, pmt, w);
								pmt  += mbpr;
								}

							py  += ybpr;
							puv += uvbpr;
							}
						break;
					case 1:
						for(y = ystart; y < ystop; y += ystep)
							{
							if (y & 1)
								{
								ConvertLineToRGB15_P8D2(py, puv + bytesPerRow, pmb, w);
								pmb  += mbpr;
								if (y & 2)
									{
									puv += 2 * bytesPerRow;
									}
								}
							else
								{
								ConvertLineToRGB15_P8D2(py, puv, pmt, w);
								pmt  += mbpr;
								}

							py  += ybpr;
							puv += uvbpr;
							}
						break;
					default:
						for(y = ystart; y < ystop; y += ystep)
							{
							if (y & 1)
								{
								ConvertLineToRGB15_P8DS(py, puv + bytesPerRow, pmb, w, xscale);
								pmb  += mbpr;
								if (y & 2)
									{
									puv += 2 * bytesPerRow;
									}
								}
							else
								{
								ConvertLineToRGB15_P8DS(py, puv, pmt, w, xscale);
								pmt  += mbpr;
								}

							py  += ybpr;
							puv += uvbpr;
							}
						break;
					}
				}
			}
		else
			{
			switch (fmode)
				{
				case PS_FRAME_PICTURE:
					pm  = map + (ystart >> yscale) * mstride;
					break;
				case PS_TOP_FIELD:
					pm  = map + (ystart >> yscale) * mstride;
					break;
				case PS_BOTTOM_FIELD:
					if (bottomMap)
						pm  = bottomMap + (ystart >> yscale) * mstride;
					else
						pm  = map + ((ystart + (mheight >> 1)) >> yscale) * mstride;
					break;
				}

			if (precision == 8)
				{
				switch (xscale)
					{
					case 0:
						for(y = ystart; y < ystop; y += ystep)
							{
							ConvertLineToRGB15_P8D1(py, puv, pm, w);

							py  += ybpr;
							puv += uvbpr;
							pm  += mbpr;
							if (y & 1) puv += bpr;
							}
						break;
					case 1:
						for(y = ystart; y < ystop; y += ystep)
							{
							ConvertLineToRGB15_P8D2(py, puv, pm, w);

							py  += ybpr;
							puv += uvbpr;
							pm  += mbpr;
							if (y & 1) puv += bpr;
							}
						break;
					default:
						for(y = ystart; y < ystop; y += ystep)
							{
							ConvertLineToRGB15_P8DS(py, puv, pm, w, xscale);

							py  += ybpr;
							puv += uvbpr;
							pm  += mbpr;
							if (y & 1) puv += bpr;
							}
						break;
					}
				}
			}
		}
	}

void FrameStore::ConvertToRGB16Stripe(BYTE * map,
			                 int mwidth, int mheight, int mstride,
								  int sstart, int sheight, bool lace, PictureStructure fmode,
								  BYTE * bottomMap)
	{
	BYTE * py, * puv, * pm, * pmt, * pmb;
	int mbpr, ybpr, uvbpr;
	int xscale, yscale, ystep;
	int ystart, ystop;
	int w;
	int y, bpr;

	xscale = 0;
	while (mwidth << xscale < width) xscale++;
	yscale = 0;
	while (mheight << yscale < height) yscale++;

	if (!yscale || fmode != PS_BOTTOM_FIELD)
		{
		bpr = bytesPerRow;

		if (fmode != PS_FRAME_PICTURE) bpr *= 2;

		ybpr = bpr << yscale;
		if (yscale)
			uvbpr = bpr << (yscale - 1);
		else
			uvbpr = 0;
		mbpr = mstride;

		ystart = sstart;
		ystop = ystart + sheight;

		w = width;

		ystep = 1 << yscale;

		py  = yb + bpr * (ystart & stripeMask);
		puv = uvb + bpr * ((ystart & stripeMask) >> 1);

		if (fmode == PS_BOTTOM_FIELD)
			{
			py += bytesPerRow;
			puv += bytesPerRow;
			}

		if (lace && fmode == PS_FRAME_PICTURE && !yscale)
			{
			pmt = map + (ystart >> 1) * mstride;
			if (bottomMap)
				pmb = bottomMap + (ystart >> 1) * mstride;
			else
				pmb = pmt + (mheight >> 1) * mstride;

			if (precision == 8)
				{
				switch (xscale)
					{
					case 0:
						for(y = ystart; y < ystop; y += ystep)
							{
							if (y & 1)
								{
								ConvertLineToRGB16_P8D1(py, puv + bytesPerRow, pmb, w);
								pmb  += mbpr;
								if (y & 2)
									{
									puv += 2 * bytesPerRow;
									}
								}
							else
								{
								ConvertLineToRGB16_P8D1(py, puv, pmt, w);
								pmt  += mbpr;
								}

							py  += ybpr;
							puv += uvbpr;
							}
						break;
					case 1:
						for(y = ystart; y < ystop; y += ystep)
							{
							if (y & 1)
								{
								ConvertLineToRGB16_P8D2(py, puv + bytesPerRow, pmb, w);
								pmb  += mbpr;
								if (y & 2)
									{
									puv += 2 * bytesPerRow;
									}
								}
							else
								{
								ConvertLineToRGB16_P8D2(py, puv, pmt, w);
								pmt  += mbpr;
								}

							py  += ybpr;
							puv += uvbpr;
							}
						break;
					default:
						for(y = ystart; y < ystop; y += ystep)
							{
							if (y & 1)
								{
								ConvertLineToRGB16_P8DS(py, puv + bytesPerRow, pmb, w, xscale);
								pmb  += mbpr;
								if (y & 2)
									{
									puv += 2 * bytesPerRow;
									}
								}
							else
								{
								ConvertLineToRGB16_P8DS(py, puv, pmt, w, xscale);
								pmt  += mbpr;
								}

							py  += ybpr;
							puv += uvbpr;
							}
						break;
					}
				}
			}
		else
			{
			switch (fmode)
				{
				case PS_FRAME_PICTURE:
					pm  = map + (ystart >> yscale) * mstride;
					break;
				case PS_TOP_FIELD:
					pm  = map + (ystart >> yscale) * mstride;
					break;
				case PS_BOTTOM_FIELD:
					if (bottomMap)
						pm  = bottomMap + (ystart >> yscale) * mstride;
					else
						pm  = map + ((ystart + (mheight >> 1)) >> yscale) * mstride;
					break;
				}

			if (precision == 8)
				{
				switch (xscale)
					{
					case 0:
						for(y = ystart; y < ystop; y += ystep)
							{
							ConvertLineToRGB16_P8D1(py, puv, pm, w);

							py  += ybpr;
							puv += uvbpr;
							pm  += mbpr;
							if (y & 1) puv += bpr;
							}
						break;
					case 1:
						for(y = ystart; y < ystop; y += ystep)
							{
							ConvertLineToRGB16_P8D2(py, puv, pm, w);

							py  += ybpr;
							puv += uvbpr;
							pm  += mbpr;
							if (y & 1) puv += bpr;
							}
						break;
					default:
						for(y = ystart; y < ystop; y += ystep)
							{
							ConvertLineToRGB16_P8DS(py, puv, pm, w, xscale);

							py  += ybpr;
							puv += uvbpr;
							pm  += mbpr;
							if (y & 1) puv += bpr;
							}
						break;
					}
				}
			}
		}
	}


static inline int GetFrameDistance(BYTE * fp1, BYTE * fp2, int stride)
	{
	int diff;

	__asm
		{
		mov			edi, [fp1]
		mov			esi, [fp2]
		mov			eax, [stride]
		mov			ecx, 16
		pxor			mm6, mm6
		pxor			mm7, mm7
loop1:
		movq			mm0, [edi]
		movq			mm1, [esi]
		movq			mm3, [edi+8]
		movq			mm4, [esi+8]
		add			edi, eax
		add			esi, eax
		dec			ecx

		movq			mm2, mm0
		psubusb		mm0, mm1
		psubusb		mm1, mm2
		por			mm0, mm1
		movq			mm1, mm0
		punpcklbw	mm0, mm7
		punpckhbw	mm1, mm7
		pmaddwd		mm0, mm0
		pmaddwd		mm1, mm1
		paddd			mm6, mm0
		paddd			mm6, mm1

		movq			mm5, mm3
		psubusb		mm3, mm4
		psubusb		mm4, mm5
		por			mm3, mm4
		movq			mm4, mm3
		punpcklbw	mm3, mm7
		punpckhbw	mm4, mm7
		pmaddwd		mm3, mm3
		pmaddwd		mm4, mm4
		paddd			mm6, mm0
		paddd			mm6, mm1

		jne			loop1

		movq			mm0, mm6
		psrlq			mm0, 32
		paddd			mm0, mm6
		movd			[diff], mm0
		}

	return diff;
	}


static inline int GetFrameFieldDistance(BYTE * feven, BYTE * fodd, int stride)
	{
	int sumdouble, sumsingle;
	int diff;

	__asm
		{
		mov			edi, [feven]
		mov			esi, [fodd]
		mov			eax, [stride]
		mov			ecx, 8

		pxor			mm5, mm5
		pxor			mm6, mm6
		pxor			mm7, mm7
loop1:
		movq			mm0, [edi]
		movq			mm1, [esi]
		movq			mm2, [edi+eax]
		add			edi, eax
		add			esi, eax
		dec			ecx

		movq			mm3, mm0
		movq			mm4, mm2
		psubusb		mm3, mm2
		psubusb		mm4, mm0
		por			mm3, mm4

		movq			mm4, mm1
		psubusb		mm4, mm0
		psubusb		mm0, mm1
		por			mm4, mm0

		movq			mm0, mm2
		psubusb		mm0, mm1
		psubusb		mm1, mm2
		por			mm1, mm0

		paddusb		mm1, mm4

		movq			mm0, mm1
		punpcklbw	mm1, mm7
		punpckhbw	mm0, mm7
		paddw			mm5, mm1
		paddw			mm5, mm0

		movq			mm0, mm3
		punpcklbw	mm3, mm7
		punpckhbw	mm0, mm7
		paddw			mm6, mm3
		paddw			mm6, mm0

		jne			loop1

		movq			mm2, mm5
		movq			mm3, mm6
		punpcklwd	mm5, mm7
		punpcklwd	mm6, mm7
		punpckhwd	mm2, mm7
		punpckhwd	mm3, mm7
		paddd			mm5, mm2
		paddd			mm6, mm3

		movq			mm2, mm5
		movq			mm3, mm6

		psrlq			mm2, 32
		psrlq			mm3, 32

		paddd			mm5, mm2
		paddd			mm6, mm3

		movd			[sumsingle], mm5
		movd			[sumdouble], mm6
		}

	diff = (sumsingle * 4 - sumdouble * 5);

	return diff;
	}

static inline int Get32PulldownFrameDistance(BYTE * fp1, BYTE * fp2, int bpr, int width, int height)
	{
	bpr *= 2;
	int diff = 0;
	int d = bpr * (height >> 4);
	int dw = (width >> 3) & ~15;

	diff += GetFrameDistance(fp1 + 2 * d + 2 * dw, fp2 + 2 * d + 2 * dw, bpr);
	diff += GetFrameDistance(fp1 + 6 * d + 2 * dw, fp2 + 6 * d + 2 * dw, bpr);
	diff += GetFrameDistance(fp1 + 2 * d + 6 * dw, fp2 + 2 * d + 6 * dw, bpr);
	diff += GetFrameDistance(fp1 + 6 * d + 6 * dw, fp2 + 6 * d + 6 * dw, bpr);

	diff += GetFrameDistance(fp1 + 3 * d + 3 * dw, fp2 + 3 * d + 3 * dw, bpr);
	diff += GetFrameDistance(fp1 + 5 * d + 3 * dw, fp2 + 5 * d + 3 * dw, bpr);
	diff += GetFrameDistance(fp1 + 3 * d + 5 * dw, fp2 + 3 * d + 5 * dw, bpr);
	diff += GetFrameDistance(fp1 + 5 * d + 5 * dw, fp2 + 5 * d + 5 * dw, bpr);

	return diff;
	}

#define THRESHOLD32	100000

bool FrameStore::Detect32PulldownFrame(FrameStore * previousFrame, Inverse32PulldownHint & phint, DWORD & history)
	{
	BYTE * fp1, * fp2, * ip1, * ip2;
	int diff, i;
	int l1, l2;

	switch (phint)
		{
		case IPDH_UNKNOWN:
			fp1 = yb;
			fp2 = previousFrame->yb;
			ip1 = yb + bytesPerRow;
			ip2 = previousFrame->yb + bytesPerRow;

			diff = Get32PulldownFrameDistance(ip1, ip2, bytesPerRow, width, height) -
					 Get32PulldownFrameDistance(fp1, fp2, bytesPerRow, width, height);

			history <<= 2;
			if (diff < -THRESHOLD32)
				history |= 0;
			else if (diff < 0)
				history |= 1;
			else if (diff < THRESHOLD32)
				history |= 2;
			else
				history |= 3;

			l1 = l2 = 256;
			for(i=0; i<30; i+=10)
				{
				switch ((history >> (i + 0)) & 3)
					{
					case 0:
						l2 = 0;
						break;
					case 1:
						l1 = l1 >> 1;
						l2 = 0;
						break;
					case 2:
						l2 = l2 >> 1;
						l1 = 0;
						break;
					case 3:
						l1 = 0;
						break;
					}
				switch ((history >> (i + 4)) & 3)
					{
					case 0:
						l1 = 0;
						break;
					case 1:
						l2 = l2 >> 1;
						l1 = 0;
						break;
					case 2:
						l1 = l1 >> 1;
						l2 = 0;
						break;
					case 3:
						l2 = 0;
						break;
					}
				}

				{
				char buffer[100];
				wsprintf(buffer, "Diff %8d l1 %3d l2 %3d\n", diff, l1, l2);
				OutputDebugString(buffer);
				}

			return FALSE;
			break;
		case IPDH_FRAME_FRAME1:
		case IPDH_FRAME_FRAME2:
		case IPDH_BOTTOM_TOP:
		case IPDH_TOP_BOTTOM:
			return TRUE;
			break;
		case IPDH_TOP_FRAME:
		case IPDH_FRAME_TOP:
			fp1 = yb;
			fp2 = previousFrame->yb;
			ip1 = yb + bytesPerRow;
			ip2 = previousFrame->yb + bytesPerRow;
			break;
		case IPDH_BOTTOM_FRAME:
		case IPDH_FRAME_BOTTOM:
			fp1 = yb + bytesPerRow;
			fp2 = previousFrame->yb + bytesPerRow;
			ip1 = yb;
			ip2 = previousFrame->yb;
			break;
		}

	diff = Get32PulldownFrameDistance(ip1, ip2, bytesPerRow, width, height) -
		    Get32PulldownFrameDistance(fp1, fp2, bytesPerRow, width, height);

	return diff > 0;
	}

bool FrameStore::Is32PulldownFrame(FrameStore * previousFrame, Inverse32PulldownHint phint)
	{
	BYTE * fp1, * fp2, * ip1, * ip2;

	switch (phint)
		{
		case IPDH_UNKNOWN:
			return FALSE;
			break;
		case IPDH_FRAME_FRAME1:
		case IPDH_FRAME_FRAME2:
		case IPDH_BOTTOM_TOP:
		case IPDH_TOP_BOTTOM:
			return TRUE;
			break;
		case IPDH_TOP_FRAME:
		case IPDH_FRAME_TOP:
			fp1 = yb;
			fp2 = previousFrame->yb;
			ip1 = yb + bytesPerRow;
			ip2 = previousFrame->yb + bytesPerRow;
			break;
		case IPDH_BOTTOM_FRAME:
		case IPDH_FRAME_BOTTOM:
			fp1 = yb + bytesPerRow;
			fp2 = previousFrame->yb + bytesPerRow;
			ip1 = yb;
			ip2 = previousFrame->yb;
			break;
		}

	int diff = 0;
	int bpr = 2 * bytesPerRow;
	int d = bpr * (height >> 4);
	int dw = (width >> 3) & ~15;

	diff += GetFrameDistance(fp1 + 2 * d + 2 * dw, fp2 + 2 * d + 2 * dw, bpr);
	diff += GetFrameDistance(fp1 + 6 * d + 2 * dw, fp2 + 6 * d + 2 * dw, bpr);
	diff += GetFrameDistance(fp1 + 2 * d + 6 * dw, fp2 + 2 * d + 6 * dw, bpr);
	diff += GetFrameDistance(fp1 + 6 * d + 6 * dw, fp2 + 6 * d + 6 * dw, bpr);

	diff += GetFrameDistance(fp1 + 3 * d + 3 * dw, fp2 + 3 * d + 3 * dw, bpr);
	diff += GetFrameDistance(fp1 + 5 * d + 3 * dw, fp2 + 5 * d + 3 * dw, bpr);
	diff += GetFrameDistance(fp1 + 3 * d + 5 * dw, fp2 + 3 * d + 5 * dw, bpr);
	diff += GetFrameDistance(fp1 + 5 * d + 5 * dw, fp2 + 5 * d + 5 * dw, bpr);

	diff -= GetFrameDistance(ip1 + 2 * d + 2 * dw, ip2 + 2 * d + 2 * dw, bpr);
	diff -= GetFrameDistance(ip1 + 6 * d + 2 * dw, ip2 + 6 * d + 2 * dw, bpr);
	diff -= GetFrameDistance(ip1 + 2 * d + 6 * dw, ip2 + 2 * d + 6 * dw, bpr);
	diff -= GetFrameDistance(ip1 + 6 * d + 6 * dw, ip2 + 6 * d + 6 * dw, bpr);

	diff -= GetFrameDistance(ip1 + 3 * d + 3 * dw, ip2 + 3 * d + 3 * dw, bpr);
	diff -= GetFrameDistance(ip1 + 5 * d + 3 * dw, ip2 + 5 * d + 3 * dw, bpr);
	diff -= GetFrameDistance(ip1 + 3 * d + 5 * dw, ip2 + 3 * d + 5 * dw, bpr);
	diff -= GetFrameDistance(ip1 + 5 * d + 5 * dw, ip2 + 5 * d + 5 * dw, bpr);

	return diff <= 0;
	}
void FrameStore::ConvertToRGB(BYTE * map)
	{
	int x, y;
	int cr, cg, cb;
	int cy, cu, cv;
	BYTE * py, * puv, * pm;
	int dbpr = (width * 3 + 3) & ~ 3;
	int shl = 8 - precision;

	py = yb;
	puv = uvb;
	pm = map + height * dbpr;

	for(y = 0; y<height; y++)
		{
		pm -= dbpr;
		for(x = 0; x<width / 2; x++)
			{
			cy = (*py++ << shl);
			cu = (int)(*puv++ << shl) - 128;
			cv = (int)(*puv++ << shl) - 128;

			cr = (cy*1000 + 1402 * cv) / 1000;
			cg = (cy*1000 -  714 * cv -  344*cu) / 1000;
			cb = (cy*1000 + 1772 * cu) / 1000;

			if (cr > 255) cr = 255; else if (cr<0) cr = 0;
			if (cg > 255) cg = 255; else if (cg<0) cg = 0;
			if (cb > 255) cb = 255; else if (cb<0) cb = 0;

			*pm++ = (BYTE)cb;
			*pm++ = (BYTE)cg;
			*pm++ = (BYTE)cr;

			cy = (*py++ << shl);

			cr = (cy*1000 + 1402 * cv) / 1000;
			cg = (cy*1000 -  714 * cv -  344*cu) / 1000;
			cb = (cy*1000 + 1772 * cu) / 1000;

			if (cr > 255) cr = 255; else if (cr<0) cr = 0;
			if (cg > 255) cg = 255; else if (cg<0) cg = 0;
			if (cb > 255) cb = 255; else if (cb<0) cb = 0;

			*pm++ = (BYTE)cb;
			*pm++ = (BYTE)cg;
			*pm++ = (BYTE)cr;
			}
		pm -= width * 3;
		if (!(y & 1))
			{
			puv -= width;
			}
		}
	}

TiledFrameStore::TiledFrameStore(GenericMMXYUVVideoConverter	*	yuvConverter, int width, int height, bool stripe)
	{
	this->width = width;
	this->height = height;
	this->yuvConverter = yuvConverter;

	bytesPerRow = ((width + 31) & ~31);
	bytesPerTile = ((height + 7) & ~7) * 8;

	stripeMask = 0xffffffff;

	iyb = new BYTE[bytesPerTile * (width >> 3) + 31];
	yb = iyb + ((32 - ((int)iyb & 31)) & 31);
	iuvb = new BYTE[(bytesPerTile >> 1) * (width >> 3) + 31];
	uvb = iuvb + ((32 - ((int)iuvb & 31)) & 31);
	precision = 8;

	maxybFrame = yb + width * bytesPerTile - 8 * 15;
	maxybField = yb + width * bytesPerTile - 8 * 14;
	}

#pragma warning (default : 4799 4731)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\FrameStore.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef FRAMESTORE_H
#define FRAMESTORE_H

#include "driver\SoftwareCinemaster\Common\Prelude.h"
#include "..\spudecoder\SPUDisplayBuffer.h"
#include "GenericMMXYUVConverter.h"
#include "XMMXYUVConverter.h"

enum PictureStructure
	{
	PS_TOP_FIELD = 1,
	PS_BOTTOM_FIELD = 2,
	PS_FRAME_PICTURE = 3
	};

enum Inverse32PulldownHint
	{
	IPDH_UNKNOWN,
	IPDH_FRAME_FRAME1,
	IPDH_FRAME_FRAME2,
	IPDH_FRAME_TOP,
	IPDH_FRAME_BOTTOM,
	IPDH_TOP_FRAME,
	IPDH_BOTTOM_FRAME,
	IPDH_TOP_BOTTOM,
	IPDH_BOTTOM_TOP
	};

struct VideoDownscaleFilterLevelSet
	{
	VideoDownscaleFilterLevel	fullX : 8;
	VideoDownscaleFilterLevel	fullY : 8;
	VideoDownscaleFilterLevel	halfX : 8;
	VideoDownscaleFilterLevel	halfY : 8;
	};

static const VideoDownscaleFilterLevelSet	MinimumVideoDownscaleFilterLevelSet  = {VSQL_BINARY, VSQL_BINARY, VSQL_BINARY, VSQL_BINARY};

class FrameStore
	{
	protected:
		int			width, height, bytesPerRow;
		BYTE		*	iyb, * iuvb;
		BYTE		*	yb, * uvb, *maxybFrame, *maxybField;
		int			precision;
		int			stripeMask, mainStripeMask;

		GenericMMXYUVVideoConverter	*	yuvConverter;

		void ConvertToRGB32Stripe(BYTE * map,
										  int mwidth, int mheight, int mstride,
										  int sstart, int sheight, bool lace, PictureStructure fmode,
										  BYTE * bottomMap);
		void ConvertToRGB15Stripe(BYTE * map,
										  int mwidth, int mheight, int mstride,
										  int sstart, int sheight, bool lace, PictureStructure fmode,
										  BYTE * bottomMap);
		void ConvertToRGB16Stripe(BYTE * map,
										  int mwidth, int mheight, int mstride,
										  int sstart, int sheight, bool lace, PictureStructure fmode,
										  BYTE * bottomMap);

		void ConvertToRGB15ThroughOSDStripe(BYTE * map, FullWidthMMXSPUDisplayBuffer * osd,
			                                 int mwidth, int mheight, int mstride,
														int sstart, int sheight,
														bool lace, PictureStructure fmode,
														BYTE * bottomMap);

	public:
		FrameStore(GenericMMXYUVVideoConverter	*	yuvConverter, int width, int height, bool stripe = false);
		FrameStore(void);
		virtual ~FrameStore(void);

		bool IsFullFrame(void) {return stripeMask == 0xffffffff;}
		void EnableStripeMode(bool stripe);

		void SetPrecision(int prec) {precision = prec;}

		void ConvertToRGB(BYTE * map);


			//
			//	topMap          : target topMap or full map if bottomMap = NULL
			// bottomMap	    : target bottomMap, or NULL if interleaved bitmap
			// mwidth, mheight : target rectangle of full frame
			// mstride         : bytes per line in target map
			// sstart, sheight : vertical slice position
			// lace            : source material is interlaced, split U and V.  If the
			//                   bottom map is non NULL, lace has to be true
			// singleField     : the bottom field is dropped. The bottomMap argument
			//                   is ignored
			// fmode           : Picture structure of source picture
			// osd             : OSD bitmap which is to be overlayed
			//
		virtual void ConvertToYUVStripe(BYTE * topMap, BYTE * bottomMap,
			                             int mwidth, int mheight, int mstride,
												  int sstart, int sheight,
												  bool lace, bool singleField, PictureStructure fmode,
												  VideoDownscaleFilterLevelSet filterLevel,
												  FullWidthMMXSPUDisplayBuffer * osd = NULL);

			//
			//	topMap          : target topMap or full map if bottomMap = NULL
			// bottomMap	    : target bottomMap, or NULL if interleaved bitmap
			// mwidth, mheight : target rectangle of full frame
			// mstride         : bytes per line in target map
			// xoffset         : horizontal offset in 65536th of a pixel
			// sstart, sheight : vertical slice position
			// lace            : source material is interlaced, split U and V.  If the
			//                   bottom map is non NULL, lace has to be true
			// singleField     : the bottom field is dropped. The bottomMap argument
			//                   is ignored
			// fmode           : Picture structure of source picture
			// osd             : OSD bitmap which is to be overlayed
			//
		virtual void ConvertToYUVStripePanScan(BYTE * topMap, BYTE * bottomMap,
			                                    int mwidth, int mheight, int mstride, int xoffset,
												         int sstart, int sheight,
												         bool lace, bool singleField, PictureStructure fmode,
												         VideoDownscaleFilterLevelSet filterLevel,
												         FullWidthMMXSPUDisplayBuffer * osd = NULL);

		virtual void ConvertToYUVStripePanScanAverageDeinterlace(BYTE * topMap,
			                                                      int mwidth, int mheight, int mstride, int xoffset,
 												                           int sstart, int sheight,
												                           bool lace,
												                           VideoDownscaleFilterLevelSet filterLevel,
												                           FullWidthMMXSPUDisplayBuffer * osd = NULL);

		virtual void ConvertToYUVStripePanScanDeinterlace(BYTE * previousMap, BYTE * currentMap, BYTE * nextMap, FrameStore * previous,
			                                               int mwidth, int mheight, int mstride, int xoffset,
																        int sstart, int sheight,
																        bool topFieldFirst, DWORD flags,
																        VideoDownscaleFilterLevelSet filterLevel,
																        FullWidthMMXSPUDisplayBuffer * osd = NULL);

		virtual void ConvertToYUVStripePanScanInterpolate(BYTE * map, FrameStore * previous,
			                                               int mwidth, int mheight, int mstride, int xoffset,
												                    int sstart, int sheight,
												                    VideoDownscaleFilterLevelSet filterLevel,
												                    FullWidthMMXSPUDisplayBuffer * osd = NULL);

		virtual void ConvertToYUVStripePanScanDeinterlaceStretch(BYTE * topMap, BYTE * bottomMap,
			                                                      int mwidth, int mheight, int mstride, int xoffset,
																               int sstart, int sheight,
																               DWORD flags,
																               VideoDownscaleFilterLevelSet filterLevel,
																               FullWidthMMXSPUDisplayBuffer * osd = NULL);

		virtual void ConvertToYUVStripeLetterbox(BYTE * topMap, BYTE * bottomMap,
			                                      int mwidth, int mheight, int mstride,
												           int sstart, int sheight,
												           bool lace, bool singleField, PictureStructure fmode,
												           VideoDownscaleFilterLevelSet filterLevel,
												           FullWidthMMXSPUDisplayBuffer * osd = NULL);

		virtual void ConvertToYUVStripeLetterboxAverageDeinterlace(BYTE * topMap,
																					  int mwidth, int mheight, int mstride,
																					  int sstart, int sheight,
																					  bool lace,
																					  VideoDownscaleFilterLevelSet filterLevel,
																					  FullWidthMMXSPUDisplayBuffer * osd = NULL);

		virtual void ConvertToYUVStripeLetterboxDeinterlace(BYTE * previousMap, BYTE * currentMap, BYTE * nextMap, FrameStore * previous,
			                                                 int mwidth, int mheight, int mstride,
																          int sstart, int sheight,
																          bool topFieldFirst, DWORD flags,
																          VideoDownscaleFilterLevelSet filterLevel,
																          FullWidthMMXSPUDisplayBuffer * osd = NULL);

		virtual void ConvertToYUVStripeLetterboxInterpolate(BYTE * map, FrameStore * previous,
			                                                 int mwidth, int mheight, int mstride,
												                      int sstart, int sheight,
												                      VideoDownscaleFilterLevelSet filterLevel,
												                      FullWidthMMXSPUDisplayBuffer * osd = NULL);

		virtual void ConvertToYUVStripeLetterboxDeinterlaceStretch(BYTE * topMap, BYTE * bottomMap,
			                                                        int mwidth, int mheight, int mstride,
																                 int sstart, int sheight,
																                 DWORD flags,
																                 VideoDownscaleFilterLevelSet filterLevel,
																                 FullWidthMMXSPUDisplayBuffer * osd = NULL);

		virtual void ConvertToYUVStripeLetterboxSingleInverse32Pulldown(BYTE * topMap, FrameStore * previous,
			                                                             int mwidth, int mheight, int mstride,
												                                  int sstart, int sheight,
												                                  Inverse32PulldownHint phint,
												                                  VideoDownscaleFilterLevelSet filterLevel,
												                                  FullWidthMMXSPUDisplayBuffer * osd = NULL);

		virtual void ConvertToYUVStripeSingleDeinterlace(BYTE * topMap, FrameStore * previous,
			                                              int mwidth, int mheight, int mstride,
												                   int sstart, int sheight,
												                   bool topField,
												                   VideoDownscaleFilterLevelSet filterLevel,
												                   FullWidthMMXSPUDisplayBuffer * osd = NULL);

		virtual void ConvertToYUVStripeAverageDeinterlace(BYTE * topMap,
			                                               int mwidth, int mheight, int mstride,
												                    int sstart, int sheight,
												                    bool lace,
												                    VideoDownscaleFilterLevelSet filterLevel,
												                    FullWidthMMXSPUDisplayBuffer * osd = NULL);

		virtual void ConvertToYUVStripeSingleInverse32Pulldown(BYTE * topMap, FrameStore * previous,
			                                                    int mwidth, int mheight, int mstride,
												                         int sstart, int sheight,
												                         Inverse32PulldownHint phint,
												                         VideoDownscaleFilterLevelSet filterLevel,
												                         FullWidthMMXSPUDisplayBuffer * osd = NULL);

		virtual void ConvertToYUVStripeDeinterlace(BYTE * previousMap, BYTE * currentMap, BYTE * nextMap, FrameStore * previous,
			                                        int mwidth, int mheight, int mstride,
																 int sstart, int sheight,
																 bool topFieldFirst, DWORD flags,
																 VideoDownscaleFilterLevelSet filterLevel,
																 FullWidthMMXSPUDisplayBuffer * osd = NULL);

		virtual void ConvertToYUVStripeDeinterlaceStretch(BYTE * topMap, BYTE * bottomMap,
			                                               int mwidth, int mheight, int mstride,
																        int sstart, int sheight,
																        DWORD flags,
																        VideoDownscaleFilterLevelSet filterLevel,
																        FullWidthMMXSPUDisplayBuffer * osd = NULL);

		virtual void ConvertToYUVStripeInterpolate(BYTE * map, FrameStore * previous,
			                                        int mwidth, int mheight, int mstride,
												             int sstart, int sheight,
												             VideoDownscaleFilterLevelSet filterLevel,
												             FullWidthMMXSPUDisplayBuffer * osd = NULL);

		virtual void ConvertToRGBThroughOSDStripe(int depth, BYTE * map, FullWidthMMXSPUDisplayBuffer * osd,
			                                       int mwidth, int mheight, int mstride,
																int sstart, int sheight,
																bool lace, PictureStructure fmode,
																BYTE * bottomMap = NULL);

		virtual void ConvertToRGBStripe(int depth, BYTE * map,
			                             int mwidth, int mheight, int mstride,
												  int sstart, int sheight, bool lace, PictureStructure fmode,
												  BYTE * bottomMap = NULL);

		virtual bool Is32PulldownFrame(FrameStore * previousFrame, Inverse32PulldownHint phint);

		virtual bool Detect32PulldownFrame(FrameStore * previousFrame, Inverse32PulldownHint & phint, DWORD & history);

		virtual bool IsRenderingComplete(void) {return TRUE;}


		void PutY(int x, int y, BYTE val) {yb[x+y*bytesPerRow] = val;}
		void PutU(int x, int y, BYTE val) {uvb[2*x+y*bytesPerRow] = val;}
		void PutV(int x, int y, BYTE val) {uvb[2*x+y*bytesPerRow+1] = val;}

		void DrawRect(int x, int y, int w, int h, unsigned yuv);

		void GetPP(int x, int y, BPTR & yp, BPTR & uvp, int & stride)
			{
			y &= stripeMask;
			stride = bytesPerRow;
			yp = yb + x + y * bytesPerRow;
			x >>= 1;
			y >>= 1;
			uvp = uvb + 2*x + y * bytesPerRow;
			}

		void GetMPP(int x, int y, BPTR & yp, BPTR & uvp, int & stride)
			{
			y &= stripeMask;
			stride = bytesPerRow;
			y *= bytesPerRow;
			yp = yb + x + y;
			uvp = uvb + x + (y >> 1);
			}

		void GetIMPP(int f, int x, int y, BPTR & yp, BPTR & uvp, int & stride)
			{
			y &= stripeMask;
			stride = 2 * bytesPerRow;
			yp = yb + x + (2 * y + f) * bytesPerRow;
			uvp = uvb + x + (y + f) * bytesPerRow;
			}

		bool GetYPP(int x, int y, BPTR & yp)
			{
			yp = yb + x + y * bytesPerRow;
			return yp >= yb && yp < maxybFrame && x >= 0 && x < width;
			}

		void GetUVPP(int x, int y, BPTR & uvp)
			{
			uvp = uvb + 2*x + y * bytesPerRow;
			}

		void GetPPF(int f, int x, int y, BPTR & yp, BPTR & uvp)
			{
			yp = yb + x + (2 * y + f) * bytesPerRow;
			x >>= 1;
			y >>= 1;
			uvp = uvb + 2*x + (2 * y + f) * bytesPerRow;
			}

		bool GetYPPF(int f, int x, int y, BPTR & yp)
			{
			yp = yb + x + (2 * y + f) * bytesPerRow;
			return yp >= yb && yp < maxybField && x >= 0 && x < width;
			}

		void GetUVPPF(int f, int x, int y, BPTR & uvp)
			{
			uvp = uvb + 2*x + (2 * y + f) * bytesPerRow;
			}

		int GetY(int x, int y) {return yb[x+y*bytesPerRow];}
		int GetU(int x, int y) {return uvb[2*x+y*bytesPerRow];}
		int GetV(int x, int y) {return uvb[2*x+y*bytesPerRow+1];}

		int Width(void) {return width;}
		int Height(void) {return height;}
		int Stride(void) {return bytesPerRow;}
	};

class TiledFrameStore : public FrameStore
	{
	protected:
		int bytesPerTile;
	public:
		TiledFrameStore(GenericMMXYUVVideoConverter	*	yuvConverter, int width, int height, bool stripe = false);

		int Stride(void) {return bytesPerTile;}

		void GetMPP(int x, int y, BPTR & yp, BPTR & uvp, int & stride)
			{
			y &= stripeMask;
			stride = bytesPerTile;
			yp = yb + (x & 7) + (x >> 3) * bytesPerTile + y * 8;
			uvp = uvb + (x & 7) + (x >> 3) * (bytesPerTile >> 1) + (y >> 1) * 8;
			}

		void GetIMPP(int f, int x, int y, BPTR & yp, BPTR & uvp, int & stride)
			{
			y &= stripeMask;
			stride = bytesPerTile;
			yp = yb + (x & 7) + (x >> 3) * bytesPerTile + (2 * y + f) * 8;
			uvp = uvb + (x & 7) + (x >> 3) * (bytesPerTile >> 1) + (y + f) * 8;
			}

		bool GetYPP(int x, int y, BPTR & yp)
			{
			yp = yb + (x & 7) + (x >> 3) * bytesPerTile + y * 8;
			return yp >= yb && yp < maxybFrame;
			}

		void GetUVPP(int x, int y, BPTR & uvp)
			{
			uvp = uvb + (x & 3) * 2 + (x >> 2) * (bytesPerTile >> 1) + y * 8;
			}

		bool GetYPPF(int f, int x, int y, BPTR & yp)
			{
			yp = yb + (x & 7) + (x >> 3) * bytesPerTile + (2 * y + f) * 8;
			return yp >= yb && yp < maxybField && x >= 0 && x < width;
			}

		void GetUVPPF(int f, int x, int y, BPTR & uvp)
			{
			uvp = uvb + (x & 3) * 2 + (x >> 2) * (bytesPerTile >> 1) + (2 * y + f) * 8;
			}
	};

//#include "..\mpegDecoder\SplitYUVFrameBuffer.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\Ctvout.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef _cTvOut_HPP_
#define _cTvOut_HPP_

#ifdef INITGUIDS
	#include <initguid.h>
#endif

//{ebb5845f-ca80-11cf-bd3c-008029e89281}
DEFINE_GUID(CLSID_TvOut, 0xebb5845f, 0xca80, 0x11cf, 0xbd, 0x3c, 0x00, 0x80, 0x29, 0xe8, 0x92, 0x81);

#endif //_cTvOut_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\GenericMMXYUVConverter.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "GenericMMXYUVConverter.h"
#include "..\common\TimedFibers.h"

#define MEASURE_SCALE_TIME				0
#define MEASURE_XSCALE_TIME			0
#define MEASURE_DEINTERLACE_TIME		0

MMXShort<4> sinctab[128];
MMXShort<4> sinctabxSet[16][128];
MMXShort<4> sinctaby[128];
MMXShort<4> sinctabySet[16][128];

#pragma warning (disable : 4799 4731)


#include <math.h>

static inline double sinc(double x)
	{
	if (x != 0.0)
		return sin(x) / x;
	else
		return 1.0;
	}

static const double pi = 3.14159265359;

double bessi0(double x)
//Returns the modified Bessel function I0(x) for any real x.
	{
	double ax,ans;
	double y;						// Accumulate polynomials in double precision.

	if ((ax=fabs(x)) < 3.75)
		{								// Polynomial fit
		y=x/3.75;
		y*=y;
		ans=1.0+y*(3.5156229+y*(3.0899424+y*(1.2067492
				+y*(0.2659732+y*(0.360768e-1+y*0.45813e-2)))));
		}
	else
		{
		y=3.75/ax;
		ans=(exp(ax)/sqrt(ax))*(0.39894228+y*(0.1328592e-1
				+y*(0.225319e-2+y*(-0.157565e-2+y*(0.916281e-2
				+y*(-0.2057706e-1+y*(0.2635537e-1+y*(-0.1647633e-1
				+y*0.392377e-2))))))));
		}

	return ans;
	}


int RoundFloat2Int(double f)
	{
	return ((int)(f - floor(f)<0.5 ? floor(f) : ceil(f)));
	}

void LPFCoefficients(double stop_freq_ratio, int numOfTaps,int	beta,int fractN, int fractD, double * coefsW)
	{
	double coefs[100];
	double window[100];
	double sumCoefs = 0;
	double sumCoefsW = 0;
	int n;
	double currFrac = (double)fractN/(double)fractD;
	double fbeta = beta*1.23;	// emperically found to counter beta being spread over numOfTaps*fractD
	double xn, x;

	for (n=0; n<numOfTaps; n++)
		{
		// do variable width sinc
//		double x = 2.0*pi*stop_freq_ratio*(n-((numOfTaps-1.0+currFrac-0.5)/2.0));
		xn = currFrac - (n-floor((numOfTaps-1.0)/2.0));
		x = 2.0*pi*stop_freq_ratio*xn;

		if (x==0)
			{
			coefs[n] = 2.0*stop_freq_ratio*1.0;
			}
		else
			{
			coefs[n] = 2.0*stop_freq_ratio*sin(x)/x;
			}
		sumCoefs += coefs[n];
		window[n] = bessi0(fbeta * sqrt(1 - (2 * xn / numOfTaps) * (2 * xn / numOfTaps))) / bessi0(fbeta);
//			bessi0(fbeta* sqrt(fabs(1.0 - pow(1.0-(2.0*((n*fractD)-fractN+fractD-1)/(numOfTaps*fractD-1.0)),2))))/bessi0(fbeta);
		coefsW[n] = coefs[n]*window[n];
		sumCoefsW += coefsW[n];
		}

	// normallize the gain of the coefs to 1.0
	for (n=0; n<numOfTaps; n++)
		{
		coefs[n] = coefs[n]*1.0/sumCoefs;
		coefsW[n] = coefsW[n]*1.0/sumCoefsW;
		}

	} /*end of routine */

void InitFrameStoreScalerTables(void)
	{
	double c0, c1, c2, c3;
	int i0, i1, i2, i3;
	double cs;
	int i, j;

	for(i=0; i<128; i++)
		{
		c0 = c1 = c2 = c3 = 0;

		c0 += sinc(pi * ((double)i  / 128  + 1));
		c1 += sinc(pi * ((double)i  / 128     ));
		c2 += sinc(pi * ((double)i  / 128  - 1));
		c3 += sinc(pi * ((double)i  / 128  - 2));

		cs = c0 + c1 + c2 + c3;

		c0 = c0 * 16384 / cs;
		c1 = c1 * 16384 / cs;
		c2 = c2 * 16384 / cs;
		c3 = c3 * 16384 / cs;

		sinctab[i][0] = (short)floor(c0 + 0.5);
		sinctab[i][1] = (short)floor(c1 + 0.5);
		sinctab[i][2] = (short)floor(c2 + 0.5);
		sinctab[i][3] = (short)floor(c3 + 0.5);

		c0 = c0 / 256;
		c1 = c1 / 256;
		c2 = c2 / 256;
		c3 = c3 / 256;

		double t = 0.5;


		do {
			i0 = (int)floor(c0 + t);
			i1 = (int)floor(c1 + t);
			i2 = (int)floor(c2 + t);
			i3 = (int)floor(c3 + t);

			t += 0.01;
			} while (i0 + i1 + i2 + i3 < 64);

		while (i0 + i1 + i2 + i3 > 64)
			{
			t -= 0.01;

			i0 = (int)floor(c0 + t);
			i1 = (int)floor(c1 + t);
			i2 = (int)floor(c2 + t);
			i3 = (int)floor(c3 + t);
			}

		sinctaby[i][0] = (short)i0;
		sinctaby[i][1] = (short)i1;
		sinctaby[i][2] = (short)i2;
		sinctaby[i][3] = (short)i3;
		}

	double fw[4];

	for(j=0; j<16; j++)
		{
		for(i=0; i<128; i++)
			{
			LPFCoefficients((j + 1) / 32., 4, 2, i, 128, fw);

			double t = 0.5;


			do {
				i0 = (int)floor(fw[0] * 64 + t);
				i1 = (int)floor(fw[1] * 64 + t);
				i2 = (int)floor(fw[2] * 64 + t);
				i3 = (int)floor(fw[3] * 64 + t);

				t += 0.01;
				} while (i0 + i1 + i2 + i3 < 64);

			while (i0 + i1 + i2 + i3 > 64)
				{
				t -= 0.01;

				i0 = (int)floor(fw[0] * 64 + t);
				i1 = (int)floor(fw[1] * 64 + t);
				i2 = (int)floor(fw[2] * 64 + t);
				i3 = (int)floor(fw[3] * 64 + t);
				}

			sinctabySet[j][i][0] = (short)i0;
			sinctabySet[j][i][1] = (short)i1;
			sinctabySet[j][i][2] = (short)i2;
			sinctabySet[j][i][3] = (short)i3;

			i0 = (int)floor(fw[0] * 16384 + 0.5);
			i1 = (int)floor(fw[1] * 16384 + 0.5);
			i2 = (int)floor(fw[2] * 16384 + 0.5);
			i3 = (int)floor(fw[3] * 16384 + 0.5);

			sinctabxSet[j][i][0] = (short)i0;
			sinctabxSet[j][i][1] = (short)i1;
			sinctabxSet[j][i][2] = (short)i2;
			sinctabxSet[j][i][3] = (short)i3;
			}
		}
	}

GenericMMXYUVVideoConverter::GenericMMXYUVVideoConverter(void)
	{
	int x, y;

	for(x = VSQL_BINARY; x <= VSQL_EIGHT_TAP; x++)
		{
		for(y = VSQL_BINARY; y <= VSQL_EIGHT_TAP; y++)
			{
			convertStripes[0][0][x][y] = ConvertStripeToYUV_P7DS;
			convertStripes[0][1][x][y] = ConvertStripeToYUVThroughOSD_P7DS;

			switch (y)
				{
				case VSQL_BINARY:
				case VSQL_DROP:
					switch (x)
						{
						case VSQL_BINARY:
							convertStripes[1][0][x][y] = ConvertStripeToYUV_P8DS;
							convertStripes[1][1][x][y] = ConvertStripeToYUVThroughOSD_P8DS;
							break;
						case VSQL_DROP:
						case VSQL_LINEAR:
							convertStripes[1][0][x][y] = ConvertStripeToYUV_P8F2;
							convertStripes[1][1][x][y] = ConvertStripeToYUVThroughOSD_P8F2;
							break;
						case VSQL_FOUR_TAP:
						case VSQL_EIGHT_TAP:
							convertStripes[1][0][x][y] = ConvertStripeToYUV_P8F4;
							convertStripes[1][1][x][y] = ConvertStripeToYUVThroughOSD_P8F4;
							break;
						}
					break;
				case VSQL_LINEAR:
					switch (x)
						{
						case VSQL_BINARY:
							convertStripes[1][0][x][y] = ConvertStripeToYUV_P8DSY2;
							convertStripes[1][1][x][y] = ConvertStripeToYUVThroughOSD_P8DSY2;
							break;
						case VSQL_DROP:
						case VSQL_LINEAR:
							convertStripes[1][0][x][y] = ConvertStripeToYUV_P8F2Y2;
							convertStripes[1][1][x][y] = ConvertStripeToYUVThroughOSD_P8F2Y2;
							break;
						case VSQL_FOUR_TAP:
						case VSQL_EIGHT_TAP:
							convertStripes[1][0][x][y] = ConvertStripeToYUV_P8F4Y2;
							convertStripes[1][1][x][y] = ConvertStripeToYUVThroughOSD_P8F4Y2;
							break;
						}
					break;
				case VSQL_FOUR_TAP:
				case VSQL_EIGHT_TAP:
					switch (x)
						{
						case VSQL_BINARY:
						case VSQL_DROP:
						case VSQL_LINEAR:
							convertStripes[1][0][x][y] = ConvertStripeToYUV_P8F2Y4;
							convertStripes[1][1][x][y] = ConvertStripeToYUVThroughOSD_P8F2Y4;
							break;
						case VSQL_FOUR_TAP:
						case VSQL_EIGHT_TAP:
							convertStripes[1][0][x][y] = ConvertStripeToYUV_P8F4Y4;
							convertStripes[1][1][x][y] = ConvertStripeToYUVThroughOSD_P8F4Y4;
							break;
						}
					break;
				}

			}
		}
	}


#pragma warning (default : 4799 4731)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\av.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

/*--
Copyright (c) Microsoft Corporation

Module Name:

    av.h

Abstract:

    This module contains the public data structures and procedure
    prototypes to identify AV packs and program TV encoder

--*/

#ifndef _AV_H
#define _AV_H

#ifdef __cplusplus
extern "C" {
#endif


//
// TV encoder options
//
#define AV_OPTION_MACROVISION_MODE			1
#define AV_OPTION_ENABLE_CC					2
#define AV_OPTION_DISABLE_CC				3
#define AV_OPTION_SEND_CC_DATA				4
#define AV_OPTION_CC_STATUS					5
#define AV_OPTION_AV_CAPABILITIES			6
#define AV_OPTION_PACK_REMOVED				7
#define AV_OPTION_NEW_PACK					8
#define AV_OPTION_BLANK_SCREEN				9
#define AV_OPTION_MACROVISION_COMMIT        10
#define AV_OPTION_FLICKER_FILTER			11
#define AV_OPTION_CGMS                      18
#define AV_OPTION_WIDESCREEN                19

//
// CGMS modes
//

#define AV_CGMS_UNRESTRICTED                0
#define AV_CGMS_ONECOPY                     1
#define AV_CGMS_NOCOPIES                    3


//
// Macrovision modes
//
#define TV_MV_OFF                         0
#define TV_MV_AGC_ONLY                    1
#define TV_MV_TWO_STRIPES_PLUS_AGC        2
#define TV_MV_FOUR_STRIPES_PLUS_AGC       3


typedef LONG NTSTATUS;


NTSTATUS WINAPI
AvSendTVEncoderOption(
    IN  PVOID RegisterBase,
    IN  ULONG Option,
    IN  ULONG Param,
    OUT PULONG Result
    );

//
// Example:
//
// AvSendTVEncoderOption(0, AV_OPTION_MACROVISION_MODE, TV_MV_OFF, &Result);
//


#ifdef __cplusplus
}
#endif

#endif // _AV_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\GenericMMXYUVConverter.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef GENERICMMXYUVCONVERTER_H
#define GENERICMMXYUVCONVERTER_H

#include "driver\SoftwareCinemaster\Common\Prelude.h"

enum VideoDownscaleFilterLevel
	{
	VSQL_BINARY,
	VSQL_DROP,
	VSQL_LINEAR,
	VSQL_FOUR_TAP,
	VSQL_EIGHT_TAP
	};

#define DIFEF_ENABLE_TOP_DEINTERLACE		1
#define DIFEF_ENABLE_TOP_COPY					2
#define DIFEF_ENABLE_BOTTOM_DEINTERLACE	4
#define DIFEF_ENABLE_BOTTOM_COPY				8

#define DIFEF_ENABLE_BOTH_DEINTERLACE		( DIFEF_ENABLE_TOP_DEINTERLACE | DIFEF_ENABLE_BOTTOM_DEINTERLACE )
#define DIFEF_ENABLE_BOTH_COPY				( DIFEF_ENABLE_TOP_COPY	| DIFEF_ENABLE_BOTTOM_COPY )
#define DIFEF_ENABLE_BOTH_ALL					( DIFEF_ENABLE_BOTH_DEINTERLACE | DIFEF_ENABLE_BOTH_COPY )

void InitFrameStoreScalerTables(void);

struct YUVVideoConverterParameter
	{
	int width, height, mwidth;

	int ystart, ystop, ycount, yfraction;
	int xscale, xfraction, xoffset;

	BYTE * ppy, * py, * ppuv, * puv, * pytb, * puvtb;
	int bpr;

	BYTE * pm, * ppm, * pmt, * pmb;
	int mbpr;

	int yosdstart, yosdstop, yosdoffset;
	int xosdstart, xosdstop;
	BYTE * po;
	int obpr;
	DDWORD * dd;
	DWORD * osdNonZeroMap;
	int lboffset;

	int stripeMask;
	bool topField;
	DWORD	deinterlaceFlags; // DIFEF_...
	};

class GenericMMXYUVVideoConverter
	{
	protected:
		PadOnQWord	pad0;
		BYTE			yuvcache[2880];
	public:
		typedef void (GenericMMXYUVVideoConverter::*ConvertStripeFunction)(const YUVVideoConverterParameter & p);

		// [bits][osd][x][y]
		ConvertStripeFunction	convertStripes[2][2][5][5];

		GenericMMXYUVVideoConverter(void);

		//////
		//
		// horizontal binary ratio scaler, vertical line drop
		//
		virtual void ConvertStripeToYUV_P7DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVThroughOSD_P7DS(const YUVVideoConverterParameter & p) {}



		virtual void ConvertStripeToYUV_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVThroughOSD_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUV_P8DSY2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVThroughOSD_P8DSY2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUV_P8DSY4(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVThroughOSD_P8DSY4(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUV_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVThroughOSD_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUV_P8F2Y2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVThroughOSD_P8F2Y2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUV_P8F2Y4(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVThroughOSD_P8F2Y4(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUV_P8F4(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVThroughOSD_P8F4(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUV_P8F4Y2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVThroughOSD_P8F4Y2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUV_P8F4Y4(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVThroughOSD_P8F4Y4(const YUVVideoConverterParameter & p) {}


		//////
		//
		// horizontal linear interpolation, vertical line drop and pan scan stretching
		//
		virtual void ConvertStripeToYUVPS_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVPSThroughOSD_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVPSAI_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVPSAIThroughOSD_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVPSDI2_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVPSDI2ThroughOSD_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVPSA2_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVPSA2ThroughOSD_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVPSSI2_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVPSSI2ThroughOSD_P8F2(const YUVVideoConverterParameter & p) {}

		//////
		//
		// horizontal binary ratio scaler, vertical linear interpolation
		//
		virtual void ConvertStripeToYUVLB_P8DSY2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVLBThroughOSD_P8DSY2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVLBAI_P8DSY2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVLBAIThroughOSD_P8DSY2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVLBDI2_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVLBDI2ThroughOSD_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVLBA2_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVLBA2ThroughOSD_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVLBSI2_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVLBSI2ThroughOSD_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVLB32PDFieldField_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVLB32PDFieldFieldThroughOSD_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVLB32PDFrameField_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVLB32PDFrameFieldThroughOSD_P8DS(const YUVVideoConverterParameter & p) {}

		//////
		//
		// horizontal binary ratio scaler, vertical linear interpolation
		//
		virtual void ConvertStripeToYUVDI_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVDIThroughOSD_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVDI_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVDIThroughOSD_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVDI_P8DSY2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVDIThroughOSD_P8DSY2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVDI_P8F2Y2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVDIThroughOSD_P8F2Y2(const YUVVideoConverterParameter & p) {}

		//////
		//
		// horizontal binary ratio scaler, vertical linear interpolation
		//
		virtual void ConvertStripeToYUVAI_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVAIThroughOSD_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVAI_P8DSY2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVAIThroughOSD_P8DSY2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVAI_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVAIThroughOSD_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVAI_P8F2Y2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVAIThroughOSD_P8F2Y2(const YUVVideoConverterParameter & p) {}

		//////
		//
		// horizontal binary ratio scaler, vertical linear interpolation
		//
		virtual void ConvertStripeToYUV32PDFieldField_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUV32PDFieldFieldThroughOSD_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUV32PDFrameField_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUV32PDFrameFieldThroughOSD_P8DS(const YUVVideoConverterParameter & p) {}

		//////
		//
		// horizontal binary ratio scaler, vertical linear interpolation
		//
		virtual void ConvertStripeToYUV32PDFieldField_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUV32PDFieldFieldThroughOSD_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUV32PDFrameField_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUV32PDFrameFieldThroughOSD_P8F2(const YUVVideoConverterParameter & p) {}

		//////
		//
		// horizontal binary ratio scaler, vertical linear interpolation
		//
		virtual void ConvertStripeToYUVDI2_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVDI2ThroughOSD_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVDI2_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVDI2ThroughOSD_P8F2(const YUVVideoConverterParameter & p) {}


		//////
		//
		// horizontal binary ratio scaler, vertical linear interpolation
		//
		virtual void ConvertStripeToYUVSI2_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVSI2ThroughOSD_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVSI2_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVSI2ThroughOSD_P8F2(const YUVVideoConverterParameter & p) {}

		//////
		//
		// horizontal binary ratio scaler, vertical linear interpolation
		//
		virtual void ConvertStripeToYUVA2_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVA2ThroughOSD_P8DS(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVA2_P8F2(const YUVVideoConverterParameter & p) {}
		virtual void ConvertStripeToYUVA2ThroughOSD_P8F2(const YUVVideoConverterParameter & p) {}



	};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\MacrovisionEncoder.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "MacrovisionEncoder.h"
#include "tvout.h"
#include "av.h"


static const GUID BroeselGuid = { 0x2c62061, 0x1097, 0x11d1, { 0x92, 0xf, 0x0, 0xa0, 0x24, 0xdf, 0x15, 0x6e } };


extern "C"
	{
	extern volatile DWORD *D3D__GpuReg;
	}


WindowsMacrovisionEncoder::WindowsMacrovisionEncoder(void)
	{

	ULONG Result;

	prevMacrovisionLevel = 0;
	AvSendTVEncoderOption((void *)D3D__GpuReg, AV_OPTION_MACROVISION_MODE, 0, &Result);

	}

WindowsMacrovisionEncoder::~WindowsMacrovisionEncoder(void)
	{

	ULONG Result;

	D3DDevice_BlockUntilVerticalBlank();
	AvSendTVEncoderOption((void *)D3D__GpuReg, AV_OPTION_MACROVISION_MODE, 0, &Result);

	D3DDevice_BlockUntilVerticalBlank();
	AvSendTVEncoderOption((void *)D3D__GpuReg, AV_OPTION_MACROVISION_COMMIT, 0, &Result);


	}


bool WindowsMacrovisionEncoder::Initialize(void)
	{
	return TRUE;
	}

bool WindowsMacrovisionEncoder::SetMacrovisionLevel(int level)
	{

	ULONG Result;
    char stringBuffer[200];

	if (level != prevMacrovisionLevel)
		{
	    wsprintf(stringBuffer, "Set Macrovision level %d\n", level);
		OutputDebugString(stringBuffer);

		prevMacrovisionLevel = level;

		D3DDevice_BlockUntilVerticalBlank();
		AvSendTVEncoderOption((void *)D3D__GpuReg, AV_OPTION_MACROVISION_MODE, level, &Result);

		D3DDevice_BlockUntilVerticalBlank();
		AvSendTVEncoderOption((void *)D3D__GpuReg, AV_OPTION_MACROVISION_COMMIT, level, &Result);

		}

	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\MacrovisionEncoder.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef MACROVISIONENCODER_H
#define MACROVISIONENCODER_H

#include "driver\SoftwareCinemaster\Common\Prelude.h"
#undef INITGUIDS
#include "ctvout.h"
#include "tvcaps.h"
#include "tvmvis.h"
#include "tvstat.h"

class MacrovisionEncoder
	{
	public:
		virtual ~MacrovisionEncoder(void) {}
		virtual bool Initialize(void) = 0;
		virtual bool SetMacrovisionLevel(int level) = 0;
	};

class WindowsMacrovisionEncoder : public MacrovisionEncoder
	{
	protected:
		DWORD						macrovisionKey;
		int						prevMacrovisionLevel;
		bool						macrovisionEnabled;
		HINSTANCE user32Inst;
	public:
		WindowsMacrovisionEncoder(void);
		~WindowsMacrovisionEncoder(void);

		bool Initialize(void);
		bool SetMacrovisionLevel(int level);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\Tvmvis.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef _TVmvis_HPP_
#define _TVmvis_HPP_

#ifdef INITGUIDS
#include <initguid.h>
#endif

//Use Guidgen.exe to generate new unique GUIDs.
//{F1506F63-896F-11d0-9445-008029E64916}
DEFINE_GUID(IID_ITVOutMacrovision, 0xF1506F63, 0x896F, 0x11d0, 0x94, 0x45, 0x00, 0x80, 0x29, 0xE6, 0x49, 0x16);

#undef INTERFACE
#define INTERFACE ITVOutMacrovision

DECLARE_INTERFACE_(ITVOutMacrovision, IUnknown)
{
 	//IUnknown members;
 	STDMETHOD(QueryInterface) (THIS_ REFIID, LPVOID*) PURE;
 	STDMETHOD_(ULONG, AddRef) (THIS) PURE;
 	STDMETHOD_(ULONG, Release) (THIS) PURE;


	// Returns TRUE in <lpbIsTrue> if any macrovision mode is
	// currently enabled.
	STDMETHOD( IsMacrovisionOn )	(THIS_ WORD wCard, LPBOOL lpbIsTrue) PURE;

	// Used to start a macrovision session. The macrovision mode is
	// equvalent to the macrovision mode bits in the DVD stream.
	// <lpdwKey> is generated by the driver and used to authenticate
	// all future transactions.
	STDMETHOD( SetMacrovisionOn )	(THIS_ WORD wCard, DWORD dwMode, LPDWORD lpdwKey) PURE;

	// Used to modify the mode of an active macrovision session.
	// The macrovision mode is equvalent to the macrovision mode bits in
	// the DVD stream. <lpdwKey> must be the same one that was returned
	// as part of an earlier <SetMacrovisionOn> call
	STDMETHOD( ResetMacrovision )	(THIS_ WORD wCard, DWORD dwMode, DWORD dwKey) PURE;

	// Used to end a macrovision session. <lpdwKey> must be the same one
	// that was returned as part of an earlier <SetMacrovisionOn> call.
	// After this call <lpdwKey> is no longer valid.
	STDMETHOD( SetMacrovisionOff )	(THIS_ WORD wCard, DWORD dwKey) PURE;

 	//ITVOutMacrovision members
};  typedef ITVOutMacrovision *LPITVOutMacrovision;

#endif //_TVmvis_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\Tvcaps.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef _ITvOutCaps_HPP_
#define _ITvOutCaps_HPP_

#ifdef INITGUIDS
#include <initguid.h>
#endif

//Use Guidgen.exe to generate new unique GUIDs.
//{F1506F60-896F-11d0-9445-008029E64916}
DEFINE_GUID(IID_ITvOutCaps, 0xF1506F60, 0x896F, 0x11d0, 0x94, 0x45, 0x00, 0x80, 0x29, 0xE6, 0x49, 0x16);

#undef INTERFACE
#define INTERFACE ITvOutCaps

DECLARE_INTERFACE_(ITvOutCaps, IUnknown)
{
 	//IUnknown members;
 	STDMETHOD(QueryInterface) (THIS_ REFIID, LPVOID*) PURE;
 	STDMETHOD_(ULONG, AddRef) (THIS) PURE;
 	STDMETHOD_(ULONG, Release) (THIS) PURE;

	// Returns the number of ATI display devices in the systems (typically 1)
	STDMETHOD( GetNumCards )		(THIS_ LPDWORD lpdwNumCards)PURE;

	// Returns the current version # of the driver in standard microsoft format
	STDMETHOD( GetDriverVersion )	(THIS_ LPDWORD lpdwDriverVersion)PURE;

	// Returns the current version # of ImpacTV chip on the specified card
	// returns 0 for no TV Out installed, 1 for ImpacTV I, and 2 for ImpacTV II
	STDMETHOD( GetTVOutVersion )	(THIS_ WORD wCard, LPDWORD lpdwTVOutVersion)PURE;

	// Returns a bitfield of TV standards supported on a specific card including
	// 1 for NTSC, 2 for PAL, all other bits reserved
	STDMETHOD( GetTVOutStandards )	(THIS_ WORD wCard, LPDWORD lpdwStandards)PURE;

	// Returns BOOL TRUE if the specified card supports macrovision
	STDMETHOD( IsMacrovisionSupported )(THIS_ WORD wCard, LPBOOL lpbHasMacrovision)PURE;

	// Used to query for supported TV Out resolutions on a specific card.
	// Pass indexes incrementing from 0. Each time <lpIsGoodMode> retunrs
	// TRUE, <lprcMode> will contain a new rectangle for a supported screen
	// size. When <lpIsGoodMode> returns FALSE, no additional sizes are supported.
	STDMETHOD( GetSupportedMode )	(THIS_ WORD wCard, WORD wIndex, LPRECT lprcMode, LPBOOL lpbIsGoodMode)PURE;

 	//ITvOutCaps members
};  typedef ITvOutCaps *LPITvOutCaps;

#endif //_ITvOutCaps_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\tvout.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// the follow file defines the VIDEO_PARAMETER structure and calling parameters
// change to the ChangeDisplaySettingEx() Win32 API.
//
// The audience for this file are Win32 developers who want to call
// ChangeDisplaySettingEx with the CDS_VIDEOPARAMETERS flag set, and
// display driver developers who want to implement the VIDEO_PARAMETERS
// escape in their Control() function.

// Display driver Escape value to get/set the parameters.
//
#define VIDEO_PARAMETERS        3077    // escape value used in Control()

// Flags for ChangeDisplaySettings
// these must match the flags in WINUSER.H

#define CDS_UPDATEREGISTRY  0x00000001
#define CDS_TEST            0x00000002
#define CDS_FULLSCREEN      0x00000004
#define CDS_GLOBAL          0x00000008
#define CDS_SET_PRIMARY     0x00000010
#define CDS_VIDEOPARAMETERS 0x00000020
#define CDS_NORESET			 0x10000000

/* Return values for ChangeDisplaySettings */
#define DISP_CHANGE_SUCCESSFUL       0
#define DISP_CHANGE_RESTART          1
#define DISP_CHANGE_FAILED          -1
#define DISP_CHANGE_BADMODE         -2
#define DISP_CHANGE_NOTUPDATED      -3
#define DISP_CHANGE_BADFLAGS        -4
#define DISP_CHANGE_BADPARAM        -5
#define DISP_CHANGE_BADESC          -6

// the GUID for this structure is:
//    {02C62061-1097-11d1-920F-00A024DF156E}
// or  static const GUID <<name>> = { 0x2c62061, 0x1097, 0x11d1, { 0x92, 0xf, 0x0, 0xa0, 0x24, 0xdf, 0x15, 0x6e } };
// or DEFINE_GUID(<<name>>,           0x2c62061, 0x1097, 0x11d1,   0x92, 0xf, 0x0, 0xa0, 0x24, 0xdf, 0x15, 0x6e);

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID {          // size is 16 // same as winnt.h
    DWORD Data1;
    WORD   Data2;
    WORD   Data3;
    BYTE  Data4[8];
} GUID;
#endif

typedef struct _VIDEOPARAMETERS {
    GUID  Guid;                         // GUID for this structure
    DWORD dwOffset;                     // leave it 0 for now.
    DWORD dwCommand;                    // VP_COMMAND_*            SET or GET
    DWORD dwFlags;                      // bitfield, defined below SET or GET
    DWORD dwMode;                       // bitfield, defined below SET or GET
    DWORD dwTVStandard;                 // bitfield, defined below SET or GET
    DWORD dwAvailableModes;             // bitfield, defined below GET
    DWORD dwAvailableTVStandard;        // bitfield, defined below GET
    DWORD dwFlickerFilter;              // value                   SET or GET
    DWORD dwOverScanX;                  // value                   SET or GET
    DWORD dwOVerScanY;                  //                         SET or GET
    DWORD dwMaxUnscaledX;               // value                   SET or GET
    DWORD dwMaxUnscaledY;               //                         SET or GET
    DWORD dwPositionX;                  // value                   SET or GET
    DWORD dwPositionY;                  //                         SET or GET
    DWORD dwBrightness;                 // value                   SET or GET
    DWORD dwContrast;                   // value                   SET or GET
    DWORD dwCPType;                     // copy protection type    SET or GET
    DWORD dwCPCommand;                  // VP_CP_CMD_
    DWORD dwCPStandard;                 // what TV standards CP is available on. GET
    DWORD dwCPKey;
    DWORD bCP_APSTriggerBits;           // (a dword for alignment) SET(bits 0 and 1 valid).
    BYTE  bOEMCopyProtection[256];      // oem specific copy protection data SET or GET
} VIDEOPARAMETERS, *PVIDEOPARAMETERS, FAR *LPVIDEOPARAMETERS;

#define VP_COMMAND_GET          0x0001  // size set, return caps.
                                        // returned Flags = 0 if not supported.
#define VP_COMMAND_SET          0x0002  // size and params set.

#define VP_FLAGS_TV_MODE        0x0001
#define VP_FLAGS_TV_STANDARD    0x0002
#define VP_FLAGS_FLICKER        0x0004
#define VP_FLAGS_OVERSCAN       0x0008
#define VP_FLAGS_MAX_UNSCALED   0x0010  // do not use on SET
#define VP_FLAGS_POSITION       0x0020
#define VP_FLAGS_BRIGHTNESS     0x0040
#define VP_FLAGS_CONTRAST       0x0080
#define VP_FLAGS_COPYPROTECT    0x0100

#define VP_MODE_WIN_GRAPHICS    0x0001
#define VP_MODE_TV_PLAYBACK     0x0002  // optimize for TV video playback

#define VP_TV_STANDARD_NTSC_M   0x0001  //        75 IRE Setup
#define VP_TV_STANDARD_NTSC_M_J 0x0002  // Japan,  0 IRE Setup
#define VP_TV_STANDARD_PAL_B    0x0004
#define VP_TV_STANDARD_PAL_D    0x0008
#define VP_TV_STANDARD_PAL_H    0x0010
#define VP_TV_STANDARD_PAL_I    0x0020
#define VP_TV_STANDARD_PAL_M    0x0040
#define VP_TV_STANDARD_PAL_N    0x0080
#define VP_TV_STANDARD_SECAM_B  0x0100
#define VP_TV_STANDARD_SECAM_D  0x0200
#define VP_TV_STANDARD_SECAM_G  0x0400
#define VP_TV_STANDARD_SECAM_H  0x0800
#define VP_TV_STANDARD_SECAM_K  0x1000
#define VP_TV_STANDARD_SECAM_K1 0x2000
#define VP_TV_STANDARD_SECAM_L  0x4000
#define VP_TV_STANDARD_WIN_VGA  0x8000

#define VP_CP_TYPE_APS_TRIGGER  0x0001  // DVD trigger bits only
#define VP_CP_TYPE_MACROVISION  0x0002  // full macrovision data available

#define VP_CP_CMD_ACTIVATE      0x0001  // CP command type
#define VP_CP_CMD_DEACTIVATE    0x0002
#define VP_CP_CMD_CHANGE        0x0004


typedef struct _MACROVISION {
    WORD    wVersion;
    WORD    wFlags;
    BYTE    bCPCData;
    BYTE    bCPSData[34];
} MACROVISION, *PMACROVISION, FAR *LPMACROVISION;

#define MV_FLAGS_CPC_ONLY   0x0001
#define MV_FLAGS_CPS_ONLY   0x0002      // dont know if this is valid or not.
#define MV_FLAGS_CPC_CPS    0x0004      // both 8 bit and 132 bits are def'ed.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\Tvstat.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef _TVStat_HPP_
#define _TVStat_HPP_

#ifdef INITGUIDS
#include <initguid.h>
#endif

//Use Guidgen.exe to generate new unique GUIDs.
//{F1506F61-896F-11d0-9445-008029E64916}
DEFINE_GUID(IID_ITVOutStatus, 0xF1506F61, 0x896F, 0x11d0, 0x94, 0x45, 0x00, 0x80, 0x29, 0xE6, 0x49, 0x16);

#undef INTERFACE
#define INTERFACE ITVOutStatus

DECLARE_INTERFACE_(ITVOutStatus, IUnknown)
{
 	//IUnknown members;
 	STDMETHOD(QueryInterface) (THIS_ REFIID, LPVOID*) PURE;
 	STDMETHOD_(ULONG, AddRef) (THIS) PURE;
 	STDMETHOD_(ULONG, Release) (THIS) PURE;


	// Returns BOOL TRUE in <lpbIsTrue> if TV Out currently detects
	// a connected device
	STDMETHOD( IsTVConnected )			(THIS_ WORD wCard, LPBOOL lpbIsTrue) PURE;

	// Returns BOOL TRUE in <lpbIsTrue> if TV Out is currently enabled.
	STDMETHOD( IsTVEnabled )			(THIS_ WORD wCard, LPBOOL lpbIsTrue) PURE;

	// Returns BOOL TRUE in <lpbIsTrue> if analog passthough is currently enabled.
	STDMETHOD( IsAnalogPassThruEnabled ) (THIS_ WORD wCard, LPBOOL lpbIsTrue) PURE;

	// Returns BOOL TRUE in <lpbIsTrue> if multimedia mode
	// (digital passthough) is currently enabled.
	STDMETHOD( IsMultmediaEnabled )		(THIS_ WORD wCard, LPBOOL lpbIsTrue) PURE;

	// Returns the currently active standard in <lpdwStandard>. This value
	// is a single bit from those defined for the GetTVOutStandards method.
	STDMETHOD( GetCurrentStandard )		(THIS_ WORD wCard, LPDWORD lpdwStandard) PURE;

 	//ITVOutStatus members
};  typedef ITVOutStatus *LPITVOutStatus;

#endif //_TVStat_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\Tvmmed.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef _TVmmed_HPP_
#define _TVmmed_HPP_

#ifdef INITGUIDS
#include <initguid.h>
#endif

//Use Guidgen.exe to generate new unique GUIDs.
//{F1506F62-896F-11d0-9445-008029E64916}
DEFINE_GUID(IID_ITVOutMultiMedia, 0xF1506F62, 0x896F, 0x11d0, 0x94, 0x45, 0x00, 0x80, 0x29, 0xE6, 0x49, 0x16);

#undef INTERFACE
#define INTERFACE ITVOutMultiMedia

DECLARE_INTERFACE_(ITVOutMultiMedia, IUnknown)
{
 	//IUnknown members;
 	STDMETHOD(QueryInterface) (THIS_ REFIID, LPVOID*) PURE;
 	STDMETHOD_(ULONG, AddRef) (THIS) PURE;
 	STDMETHOD_(ULONG, Release) (THIS) PURE;


	// Returns TRUE in <lpbIsTrue> if multimedia (digital passthrough)
	// mode is currently enabled, FALSE otherwise.
	STDMETHOD( IsMultimediaEnabled)		(THIS_ WORD wCard, LPBOOL lpbIsTrue) PURE;

	// Returns TRUE if the analog cross-bar passthough (BPX feature) is
	// currently enabled, FALSE otherwise. This is not supported on any
	// current hardware
	STDMETHOD( IsAnalogPassThruEnabled)	(THIS_ WORD wCard, LPBOOL lpbIsTrue) PURE;

	// Call to enable or disable multimedia (digital passthough) mode.
	STDMETHOD( SetMultimediaMode)		(THIS_ WORD wCard, BOOL	bOn) PURE;

	// Call to enable or disable analog passthough mode. Does nothing
	// on cards which do not support analog passthrough.
	STDMETHOD( SetAnalogPassThruMode)	(THIS_ WORD wCard, BOOL	bOn) PURE;

	//ITVOutMultiMedia members
};  typedef ITVOutMultiMedia *LPITVOutMultiMedia;

#endif //_TVmmed_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\VideoDisplay.cpp ===
//depot/xbox-aug01-final/private/ui/dvd/driver/softwarecinemaster/Video/VideoDisplay.cpp#2 - edit change 18236 (text)
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#include "VideoDisplay.h"
#include "..\common\PerformanceMonitor.h"
#include "library\common\vddebug.h"

#define DUMP_FLIP_TIMES			0
//
//  Fiber Routine
//
#if DUMP_FLIP_TIMES

struct
	{
	int	time, streamTime;
	int	numTimes;
	int	times[16];
	int	avail;
	} dispinfo[40000];
int dispcnt;

#endif

void GenericPictureDisplay::FiberRoutine(void)
	{
	int time, delay, displayTime;

	secondField = FALSE;

	for(;;)
		{
		isPaused = TRUE;
		event.WaitForever();
		if (terminate)
			{
			queueEvent.SetEvent();

			return;
			}
		else if ((!pause || step || !noOfDisplayFrames) && numDisplayBuffers)
			{
			isPaused = FALSE;

			lock.Enter();

			while ((!(pause && (completed || !pendingQueue[0] || !display || display->frame && display->frame->IsFullFrame())) || step || !noOfDisplayFrames) && !terminate)
				{
				switch (numDisplayBuffers)
					{
					case 2:
						if (!pendingQueue[1])
							{
							lock.Leave();
							event.WaitForever();
							lock.Enter();
							}
						else
							{
							time = CurrentTime();

							if (step || time >= timeQueue[1])
								{
								if (pendingQueue[1] != display)
									{
									nextAvail = display;
									display = pendingQueue[1];
									display->DisplayFrame(display->mode);
									noOfDisplayFrames++;

									}


								pendingQueue[1] = NULL;
								step = FALSE;

								queueEvent.SetEvent();
								}
							else
								{
								if (timeQueue[1] - time > 100)
									{
									lock.Leave();
									event.Wait(100);
									lock.Enter();
									if (pendingQueue[1])
										{
										if (pendingQueue[1] != display)
											{
											nextAvail = display;
											display = pendingQueue[1];
											display->DisplayFrame(display->mode);
											noOfDisplayFrames++;

											}

										pendingQueue[1] = NULL;

										queueEvent.SetEvent();
										}
									}
								else
									{
									lock.Leave();
#if HALF_PLAYBACK_SPEED
									delay = 2 * (timeQueue[1] - time);
#else
									delay = timeQueue[1] - time;
#endif
									YieldFiber(delay, TRUE);

									lock.Enter();
									}
								}
							}
						break;
					case 3:
					case 4:
					case 5:
					case 6:
						if (nextAvail && nextAvail->DisplayCompleted())
							{
							if (nextAvail->referenceCount)
								{
								nextAvail->state = PDBS_REFERENCED;
								nextAvail = NULL;
								}
							else
								{
								nextAvail->state = PDBS_IDLE;
								availQueue[firstAvail] = nextAvail;
								firstAvail = (firstAvail + 1) & 15;
								nextAvail = NULL;
								queueEvent.SetEvent();
								}
							}

						if (!pendingQueue[0])
							{
							secondField = FALSE;
							lock.Leave();

							if (nextAvail && firstAvail == lastAvail)
								{
								event.Wait(nextAvail->DisplayCompletionDelay());
								}
							else if (nextAvail)
								{
								event.Wait(100);
								}
							else
								{
								event.WaitForever();
								}
							lock.Enter();
							}
						else
							{
							time = CurrentTime();

							if (step || !noOfDisplayFrames || time + 1 >= timeQueue[0])
								{
#if DUMP_FLIP_TIMES
								dispinfo[dispcnt].time = GetInternalTime();
								dispinfo[dispcnt].streamTime = time;
								int i = 0;
								while (i < 4 && pendingQueue[i])
									{
									dispinfo[dispcnt].times[i] = timeQueue[i];
									i++;
									}
								dispinfo[dispcnt].numTimes = i;
								dispinfo[dispcnt].avail = (firstAvail - lastAvail) & 15;
								dispcnt++;
#endif

								if (!secondField || displayMode == PS_FRAME_PICTURE)
									{
									if (nextAvail)
										{
										if (nextAvail->referenceCount)
											{
											nextAvail->state = PDBS_REFERENCED;
											nextAvail = NULL;
											}
										else
											{
											nextAvail->state = PDBS_IDLE;
											availQueue[firstAvail] = nextAvail;
											firstAvail = (firstAvail + 1) & 15;
											nextAvail = NULL;
											queueEvent.SetEvent();
											}
										}
									nextAvail = display;
									if (nextAvail) nextAvail->state = PDBS_DISPLAYCOMPLETING;
									}

								if (!secondField || display->fmode == PS_FRAME_PICTURE)
									{
									while (pendingQueue[1] && (time > timeQueue[1] + 2 * pendingQueue[1]->fieldTime && !step || step && secondField))
										{
										OutputDebugString("Drop 1\n");
										if (!secondField || displayMode == PS_FRAME_PICTURE)
											{
											if (pendingQueue[0]->referenceCount)
												{
												pendingQueue[0]->state = PDBS_REFERENCED;
												}
											else
												{
												pendingQueue[0]->state = PDBS_IDLE;
												availQueue[firstAvail] = pendingQueue[0];
												firstAvail = (firstAvail + 1) & 15;
												queueEvent.SetEvent();
												}
											}
										else
											{
											if (nextAvail)
												{
												if (nextAvail->referenceCount)
													{
													nextAvail->state = PDBS_REFERENCED;
													nextAvail = NULL;
													}
												else
													{
													nextAvail->state = PDBS_IDLE;
													availQueue[firstAvail] = nextAvail;
													firstAvail = (firstAvail + 1) & 15;
													nextAvail = NULL;
													queueEvent.SetEvent();
													}
												}
											nextAvail = display;
											if (nextAvail) nextAvail->state = PDBS_DISPLAYCOMPLETING;
											}

										pendingQueue[0] = pendingQueue[1];
										timeQueue[0] = timeQueue[1];
										pendingQueue[1] = pendingQueue[2];
										timeQueue[1] = timeQueue[2];
										pendingQueue[2] = pendingQueue[3];
										timeQueue[2] = timeQueue[3];
										pendingQueue[3] = NULL;

										secondField = FALSE;
										}
									}

								displayTime = timeQueue[0];
								display = pendingQueue[0];
								displayMode = display->mode;
								if (secondField || display->mode == PS_FRAME_PICTURE || display->fmode == PS_FRAME_PICTURE && displayTime + display->fieldTime <= time || step)
									{
									pendingQueue[0] = pendingQueue[1];
									timeQueue[0] = timeQueue[1];
									pendingQueue[1] = pendingQueue[2];
									timeQueue[1] = timeQueue[2];
									pendingQueue[2] = pendingQueue[3];
									timeQueue[2] = timeQueue[3];
									pendingQueue[3] = NULL;

									secondField = FALSE;
									if      (displayMode == PS_TOP_FIELD)    displayMode = PS_BOTTOM_FIELD;
									else if (displayMode == PS_BOTTOM_FIELD) displayMode = PS_TOP_FIELD;
									}
								else
									{
									timeQueue[0] += display->fieldTime;
									secondField = TRUE;
									}

								display->state = PDBS_DISPLAYING;
								noOfDisplayFrames++;
								lock.Leave();
								display->DisplayFrame(displayMode);
								lock.Enter();
								queueEvent.SetEvent();
								if (step)
									{
									UpdateTimer(displayTime);
									}
								step = FALSE;
								}
							else
								{
								lock.Leave();

								if (nextAvail && firstAvail == lastAvail)
									{
									int t1 = timeQueue[0] - time;
									int t2 = nextAvail->DisplayCompletionDelay();

									event.Wait(min(t1, t2), TRUE);
									}
								else
									{
									event.Wait(timeQueue[0] - time, TRUE);
									}

								lock.Enter();
								}
							}
						break;
					default:
						lock.Leave();
						event.WaitForever();
						lock.Enter();
						break;
					}
				}

			lock.Leave();
			if (terminate)
				{
				queueEvent.SetEvent();

				return;
				}
			}
		}
	}

//
//  Constructor
//

#pragma warning(disable : 4355)
GenericPictureDisplay::GenericPictureDisplay(void) :
	event(FALSE, TRUE), queueEvent(FALSE, TRUE), TimedFiber(6), timingClient(this)
	{
	numDisplayBuffers = 0;
	display = NULL; nextAvail = NULL;
	macrovisionEncoder = NULL;
	streaming = FALSE;
	preferedDeinterlaceMode = DEIF_DEINTERLACE_WEAVE | DEIF_DEINTERLACE_BOB;
	spuDeferData.map = NULL;
	presentationMode = PDPM_FULLSIZE;
	errorMessenger = NULL;
	}
#pragma warning(default : 4355)

//
//  Destructor
//

GenericPictureDisplay::~GenericPictureDisplay(void)
	{
	if (streaming) EndStreaming(TRUE);
	}

//
//  Init Display
//

void GenericPictureDisplay::InitDisplay(int width, int height, int minStretch)
	{
	int i, j;

	if (!numDisplayBuffers)
		{
		AllocateDisplayBuffers();
		ClearDisplayBuffers();
		}

	if (numDisplayBuffers == 2 || scanning)
		{
		display = displayBuffers[0];
		nextAvail = displayBuffers[1];
		pendingQueue[1] = NULL;
		}
	else if (numDisplayBuffers >= 3)
		{
		if (!display)
			{
			display = displayBuffers[numDisplayBuffers - 1];
			display->mode = PS_FRAME_PICTURE;
			}

		for(i=0; i<numDisplayBuffers; i++)
			{
			displayBuffers[i]->referenceCount = 0;
			}

		i = 0;
		for(j=0; j<numDisplayBuffers-1; j++)
			{
			if (displayBuffers[i] == display) i++;

			availQueue[j] = displayBuffers[i];
			availQueue[j]->state = PDBS_IDLE;
			i++;
			}
		display->state = PDBS_DISPLAYING;

		pendingQueue[0] = NULL;
		pendingQueue[1] = NULL;
		pendingQueue[2] = NULL;
		pendingQueue[3] = NULL;
		firstAvail = numDisplayBuffers - 1;
		lastAvail = 0;
		display->DisplayFrame(display->mode);
		}
	else
		{
		display = NULL;
		nextAvail = 0;
		}
	}

//
//  Hide Display
//

void GenericPictureDisplay::HideDisplay(void)
	{
	display = NULL;
	if (numDisplayBuffers) FreeDisplayBuffers();
	}

//
//  Obtain IP Frame Buffer Reference
//

void GenericPictureDisplay::ObtainIPFrameBufferReference(PictureDisplayBuffer * frame)
	{
	lock.Enter();
	frame->referenceCount++;
	lock.Leave();
	}

//
//  Release IP Frame Buffer Reference
//

void GenericPictureDisplay::ReleaseIPFrameBufferReference(PictureDisplayBuffer * frame)
	{
	lock.Enter();
	frame->referenceCount--;

	if (!frame->referenceCount && frame->state == PDBS_REFERENCED)
		{
		frame->state = PDBS_IDLE;
		availQueue[firstAvail] = frame;
		firstAvail = (firstAvail + 1) & 15;
		queueEvent.SetEvent();
		}

	lock.Leave();
	}

//
//  Invalidate decoding buffer
//

void GenericPictureDisplay::InvalidateDecodingBuffer(void)
	{
	int i;

	lock.Enter();

	for(i=0; i<numDisplayBuffers; i++)
		displayBuffers[i]->InvalidateBuffer();

	lock.Leave();
	}

//
//  Begin streaming
//

void GenericPictureDisplay::BeginStreaming(bool scanning)
	{
	int i;

	lock.Enter();

	this->scanning = scanning;

	terminate = FALSE;
	pause = TRUE;
	step = FALSE;
	if (!numDisplayBuffers) display = NULL;
	nextAvail = NULL;

	for(i=0; i<NUMOSDPREVIEW; i++)
		osdMap[i] = NULL;

	spuDeferData.map = NULL;
	initialDisplayTime = 0;

	if (!scanning)
		{
		SetFiberPriority(4);
		StartFiber();
		}

	ResetTimer();

	streaming = TRUE;
	completed = FALSE;
	noOfDisplayFrames = 0;

	lock.Leave();
	}

//
//  End streaming
//

void GenericPictureDisplay::EndStreaming(bool fullReset)
	{
	lock.Enter();

	int i;

	if (streaming)
		{
		terminate = TRUE;
		queueEvent.SetEvent();
		if (!scanning)
			{
			event.SetEvent();
			lock.Leave();
			CompleteFiber();
			lock.Enter();
			}
		for(i=0; i<NUMOSDPREVIEW; i++)
			osdMap[i] = NULL;
		spuDeferData.map = NULL;
		pendingQueue[0] = NULL;
		pendingQueue[1] = NULL;
		pendingQueue[2] = NULL;
		pendingQueue[3] = NULL;
		streaming = FALSE;
		}

	lock.Leave();
	}

//
//  Start streaming
//

void GenericPictureDisplay::StartStreaming(int playbackSpeed)
	{
	pause = FALSE;
	if (!scanning)
		{
		EndFreezeDisplay();

		SetPlaybackSpeed(playbackSpeed);

		StartTimer();
		event.SetEvent();
		queueEvent.SetEvent();
		}
	}

//
//  Stop streaming
//

void GenericPictureDisplay::StopStreaming(void)
	{
	int timeOut;

	if (!scanning)
		{
		lock.Enter();

		pause = TRUE;
		event.SetEvent();

		timeOut = 10;

		//
		// Timeout condition in case, no data is sent at all...
		//
		while (!isPaused && (noOfDisplayFrames > 0 || timeOut > 0))
			{
			lock.Leave();
			YieldTimedFiber(20);
			timeOut--;
			lock.Enter();
			}

		StopTimer();

		BeginFreezeDisplay();

		lock.Leave();
		}
	else
		pause = TRUE;
	}

//
//  Done streaming
//

void GenericPictureDisplay::DoneStreaming(void)
	{
	int timeout;

	lock.Enter();

	timeout = GetInternalTime() + 200;

	while (!pause && !terminate && !(display && (numDisplayBuffers == 2 ?
			 (nextAvail != 0) : ((firstAvail - lastAvail & 15) == numDisplayBuffers - 1))) &&
			 GetInternalTime() < timeout)
		{
		lock.Leave();
		event.SetEvent();
		YieldTimedFiber(1);
		lock.Enter();
		}

	completed = TRUE;

	if (!terminate && display)
		{
		if (spuDeferData.map)
			{
			spuDeferData.map->PerformButtonChange();
			PrepareOSDBitmap(spuDeferData.map);

			osdMap[spuDeferData.mid] = spuDeferData.map;
			osdStartTime[spuDeferData.mid] = spuDeferData.startTime;
			osdStopTime[spuDeferData.mid] = spuDeferData.stopTime;

			if (osdStopTime[spuDeferData.mid] < CurrentTime()) osdMap[spuDeferData.mid] = NULL;

			spuDeferData.map = NULL;
			}

		SPUDisplayBuffer * map = FindOSDBitmap(0x7fffffff);

		if (map)
			display->UpdateOSDBitmap(map);
		}

	lock.Leave();
	}

//
//  Find OSD Bitmap
//

SPUDisplayBuffer * GenericPictureDisplay::FindOSDBitmap(int time)
	{
	int i;

	for(i=0; i<NUMOSDPREVIEW; i++)
		{
		if (osdMap[i] && (time == 0x7fffffff || time >= osdStartTime[i] && time <= osdStopTime[i]))
			return osdMap[i];
		}

	return NULL;
	}

//
//  Advance frame
//

void GenericPictureDisplay::AdvanceFrame(void)
	{
	if (pause)
		{
		step = TRUE;
		event.SetEvent();
		}
	}

//
//  Post IP Frame Buffer
//

void GenericPictureDisplay::PostIPFrameBuffer(PictureDisplayBuffer * frame, int displayTime)
	{
	lock.Enter();

	completed = FALSE;
	if (!initialDisplayTime) initialDisplayTime = displayTime;

	frame->DoneDecoding();

	if (numDisplayBuffers == 2 || scanning)
		{
		while (!terminate && !scanning && pendingQueue[1])
			{
			lock.Leave();
			queueEvent.WaitForever();
			lock.Enter();
			}
		if (!terminate)
			{
			if (!scanning && displayTime > CurrentTime())
				{
				pendingQueue[1] = frame;
				timeQueue[1] = displayTime;
				event.SetEvent();
				}
			else
				{
				nextAvail = display;
				display = frame;
				noOfDisplayFrames++;
				display->DisplayFrame(display->mode);
				}
			}
		}
	else
		{
		if (frame->IsFrameComplete())
			{
			frame->state = PDBS_PENDING;

			while (!terminate && pendingQueue[3])
				{
				lock.Leave();
				queueEvent.WaitForever();
				lock.Enter();
				}

			if (!terminate)
				{
				if (!pendingQueue[0])
					{
					if (displayTime < CurrentTime())
						{
						pendingQueue[0] = frame;
						timeQueue[0] = displayTime;
						event.SetEvent();
						}
					else
						{
						pendingQueue[0] = frame;
						timeQueue[0] = displayTime;
						event.SetEvent();
						}
					}
				else if (!pendingQueue[1])
					{
					pendingQueue[1] = frame;
					timeQueue[1] = displayTime;
					}
				else if (!pendingQueue[2])
					{
					pendingQueue[2] = frame;
					timeQueue[2] = displayTime;
					}
				else
					{
					pendingQueue[3] = frame;
					timeQueue[3] = displayTime;
					}
				}
			}
		else
			{
			if (frame->referenceCount)
				{
				frame->state = PDBS_REFERENCED;
				}
			else
				{
				frame->state = PDBS_IDLE;
				availQueue[firstAvail] = frame;
				firstAvail = (firstAvail + 1) & 15;
				}
			}
		}

	lock.Leave();
	}

//
//  Get IP Frame Buffer
//

PictureDisplayBuffer * GenericPictureDisplay::GetIPFrameBuffer(int approxDisplayTime)
	{
	PictureDisplayBuffer * buffer;

	int startTime = GetInternalTime();

	lock.Enter();

	if (spuDeferData.map)
		{
		spuDeferData.map->PerformButtonChange();
		PrepareOSDBitmap(spuDeferData.map);

		osdMap[spuDeferData.mid] = spuDeferData.map;
		osdStartTime[spuDeferData.mid] = spuDeferData.startTime;
		osdStopTime[spuDeferData.mid] = spuDeferData.stopTime;

		if (osdStopTime[spuDeferData.mid] < CurrentTime()) osdMap[spuDeferData.mid] = NULL;

		spuDeferData.map = NULL;
		}

	if (numDisplayBuffers == 2 || scanning)
		{
		while (!scanning && !terminate && !nextAvail)
			{
			lock.Leave();
			queueEvent.WaitForever();
			lock.Enter();
			}

		if (!terminate && nextAvail)
			{
			buffer = nextAvail;
			nextAvail = NULL;
			while (!terminate && !buffer->DisplayCompleted())
				{
				lock.Leave();
				YieldTimedFiber(1);
				lock.Enter();
				}

			if (terminate)
				{
				buffer = NULL;
				}
			}
		else
			buffer = NULL;
		}
	else if (numDisplayBuffers >= 3)
		{
		while (!terminate && (firstAvail == lastAvail ||
			     (pause && pendingQueue[0])))
			{
			event.SetEvent();
			lock.Leave();
			queueEvent.WaitForever();
			lock.Enter();
			}
		if (!terminate)
			{
			buffer = availQueue[lastAvail];
			lastAvail = (lastAvail + 1) & 15;

			while (!terminate &&!(buffer->DisplayCompleted()))
				YieldTimedFiber(buffer->DisplayCompletionDelay());
			}
		else
			buffer = NULL;
		}
	else
		buffer = NULL;

	if (buffer)
		{
		buffer->BeginDecoding(FindOSDBitmap(approxDisplayTime));
		buffer->state = PDBS_DECODING;
		}

	lock.Leave();

	return buffer;
	}

//
//  Post B Frame Buffer
//

void GenericPictureDisplay::PostBFrameBuffer(PictureDisplayBuffer * frame, int displayTime)
	{
	lock.Enter();

	completed = FALSE;
	frame->DoneDecoding();

	if (numDisplayBuffers != 2)
		{
		if (scanning)
			{
			if (!terminate)
				{
				nextAvail = display;
				display = frame;
				noOfDisplayFrames++;
				display->DisplayFrame(display->mode);
				}
			}
		else
			{
			if (frame->IsFrameComplete())
				{
				frame->state = PDBS_PENDING;

				while (!terminate && pendingQueue[3])
					{
					lock.Leave();
					queueEvent.WaitForever();
					lock.Enter();
					}

				if (!terminate)
					{
					if (!pendingQueue[0])
						{
						if (displayTime < CurrentTime())
							{
							pendingQueue[0] = frame;
							timeQueue[0] = displayTime;
							event.SetEvent();
							}
						else
							{
							pendingQueue[0] = frame;
							timeQueue[0] = displayTime;
							event.SetEvent();
							}
						}
					else if (!pendingQueue[1])
						{
						pendingQueue[1] = frame;
						timeQueue[1] = displayTime;
						}
					else if (!pendingQueue[2])
						{
						pendingQueue[2] = frame;
						timeQueue[2] = displayTime;
						}
					else
						{
						pendingQueue[3] = frame;
						timeQueue[3] = displayTime;
						}
					}
				}
			else
				{
				if (frame->referenceCount)
					{
					frame->state = PDBS_REFERENCED;
					}
				else
					{
					frame->state = PDBS_IDLE;
					availQueue[firstAvail] = frame;
					firstAvail = (firstAvail + 1) & 15;
					}
				}
			}
		}

	lock.Leave();
	}

//
//  Get B Frame Buffer
//

PictureDisplayBuffer * GenericPictureDisplay::GetBFrameBuffer(int displayTime)
	{
	PictureDisplayBuffer * buffer;

	int startTime = GetInternalTime();

	lock.Enter();

	if (scanning)
		{
		if (!terminate && nextAvail)
			{
			buffer = nextAvail;
			nextAvail = NULL;
			while (!terminate && !buffer->DisplayCompleted())
				{
				lock.Leave();
				YieldTimedFiber(1);
				lock.Enter();
				}

			if (terminate)
				{
				buffer = NULL;
				}
			}
		else
			buffer = NULL;
		}
	else if (numDisplayBuffers == 2)
		{
		if (terminate)
			{
			buffer = NULL;
			}
		else if (displayTime <= CurrentTime())
			{
			buffer = display;
			}
		else
			{
			while (!terminate && pendingQueue[1])
				{
				lock.Leave();
				queueEvent.WaitForever();
				lock.Enter();
				}

			if (terminate)
				buffer = NULL;
			else if (displayTime <= CurrentTime())
				{
				buffer = display;
				}
			else
				{
				pendingQueue[1] = display;
				timeQueue[1] = displayTime;
				event.SetEvent();
				while (!terminate && pendingQueue[1])
					{
					lock.Leave();
					queueEvent.WaitForever();
					lock.Enter();
					}
				if (terminate)
					buffer = NULL;
				else
					buffer = display;
				}
			}
		}
	else if (numDisplayBuffers >= 3)
		{
		while (!terminate && firstAvail == lastAvail)
			{
			event.SetEvent();
			lock.Leave();
			queueEvent.WaitForever();
			lock.Enter();
			}

		if (!terminate)
			{
			buffer = availQueue[lastAvail];
			lastAvail = (lastAvail + 1 ) & 15;

			while (!terminate &&!(buffer->DisplayCompleted()))
				YieldTimedFiber(buffer->DisplayCompletionDelay());
			}
		else
			buffer = NULL;
		}
	else
		buffer = NULL;

	if (buffer)
		{
		buffer->BeginDecoding(FindOSDBitmap(displayTime));
		buffer->state = PDBS_DECODING;
		}

	lock.Leave();

	return buffer;
	}

//
//  Final Frame Is Displayed
//

bool GenericPictureDisplay::FinalFrameIsDisplayed(void)
	{
	return (display && (numDisplayBuffers == 2 ?
		    (nextAvail != 0) : ((firstAvail - lastAvail & 15) + (nextAvail != 0) == numDisplayBuffers - 1)));
	}

//
//  Update OSD Bitmap
//

void GenericPictureDisplay::UpdateOSDBitmap(SPUDisplayBuffer * map)
	{
	if (display && (numDisplayBuffers == 2 ?
		(nextAvail != 0) : ((firstAvail - lastAvail & 15) + (nextAvail != 0) == numDisplayBuffers - 1)))
		{
		display->UpdateOSDBitmap(map);
		}
	}

//
//  Defer Update OSD Bitmap
//

bool GenericPictureDisplay::DeferUpdateOSDBitmap(SPUDisplayBuffer * map, int mid, int startTime, int stopTime)
	{
	if (!terminate && streaming && !pause && !completed)
		{
		spuDeferData.map = map;
		spuDeferData.mid = mid;
		spuDeferData.startTime = startTime;
		spuDeferData.stopTime = stopTime;

		return TRUE;
		}
	else
		return FALSE;
	}

//
//  Post OSD Bitmap
//

void GenericPictureDisplay::PostOSDBitmap(SPUDisplayBuffer * map, int startTime, int stopTime)
	{
	int	time, mid;
	int i;

	lock.Enter();

	if (!terminate)
		{
		time = CurrentTime();

		if (spuDeferData.map)
			{
			if (spuDeferData.map == map)
				{
				spuDeferData.startTime = startTime;
				spuDeferData.stopTime = stopTime;

				lock.Leave();

				return;
				}

			spuDeferData.map->PerformButtonChange();
			PrepareOSDBitmap(spuDeferData.map);

			osdMap[spuDeferData.mid] = spuDeferData.map;
			osdStartTime[spuDeferData.mid] = spuDeferData.startTime;
			osdStopTime[spuDeferData.mid] = spuDeferData.stopTime;

			if (osdStopTime[spuDeferData.mid] < CurrentTime()) osdMap[spuDeferData.mid] = NULL;

			spuDeferData.map = NULL;
			}

		for(i=0; i<NUMOSDPREVIEW; i++)
			{
			if (osdStopTime[i] < time) osdMap[i] = NULL;
			}

		for(mid = 0; mid<NUMOSDPREVIEW; mid++)
			{
			if (map == osdMap[mid]) break;
			}

		if (mid == NUMOSDPREVIEW)
			{
			for(mid = 0; mid<NUMOSDPREVIEW; mid++)
				{
				if (!osdMap[mid]) break;
				}
			}

		if (mid == NUMOSDPREVIEW)
			{
			mid = 0;
			for(i=1; i<NUMOSDPREVIEW; i++)
				{
				if (osdStartTime[i] < osdStartTime[mid]) mid = i;
				}
			}

		if (map != osdMap[mid] || !DeferUpdateOSDBitmap(map, mid, startTime, stopTime))
			{
			osdMap[mid] = map;
			osdStartTime[mid] = startTime;
			osdStopTime[mid] = stopTime;

			if (osdStopTime[mid] < time) osdMap[mid] = NULL;

			if (osdMap[mid])
				{
				osdMap[mid]->PerformButtonChange();
				PrepareOSDBitmap(osdMap[mid]);

				if (startTime <= time && stopTime >= time)
					UpdateOSDBitmap(osdMap[mid]);
				}
			}
		}

	lock.Leave();
	}

//
//  Invalidate OSD Bitmaps
//

void GenericPictureDisplay::InvalidateOSDBitmaps(void)
	{
	int i;

	lock.Enter();

	spuDeferData.map = NULL;

	for(i=0; i<NUMOSDPREVIEW; i++)
		osdMap[i] = NULL;

	lock.Leave();
	}

//
//  Set Video Start Time
//

void GenericPictureDisplay::SetVideoStartTiming(int startTime)
	{
	if (startTime > CurrentTime())
		{
		UpdateTimer(startTime);
		event.SetEvent();
		}
	}

void GenericPictureDisplay::SetDisplayPresentationMode(PictureDisplayPresentationMode presentationMode)
	{
	DP("Presentationmode %d", presentationMode);
//	if (presentationMode == PDPM_PANSCAN) presentationMode = PDPM_LETTERBOXED;
	this->presentationMode = presentationMode;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\winsockperfmon\WinSockPerfMon.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\XBoxDisplay.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef XBOXDISPLAY
#define XBOXDISPLAY

#include "driver\SoftwareCinemaster\Common\Prelude.h"
#include "VideoDisplay.h"
#include "library\common\profiles.h"
#include "..\common\ASyncErrorMessages.h"

//#define USE_TEXTURE_SURFACES
#undef USE_TEXTURE_SURFACES

#define RAV_COLOR_KEY  	D3DCOLOR_XRGB(0xff, 0x80, 0xd0)


#ifdef USE_TEXTURE_SURFACES
typedef LPDIRECT3DTEXTURE8 LPDIRECTDRAWSURFACE;
typedef LPDIRECT3DTEXTURE8 LPDIRECTDRAWSURFACE3;
#else
typedef LPDIRECT3DSURFACE8 LPDIRECTDRAWSURFACE;
typedef LPDIRECT3DSURFACE8 LPDIRECTDRAWSURFACE3;
#endif
#define DD_OK D3D_OK


class XBoxDisplayBuffer;

class XBoxDisplay : public GenericPictureDisplay
    {
    friend class XBoxDisplayBuffer;
    protected:
        bool                            macrovisionHideDisplay;
        bool                            enforceFlipSync;
        VideoDownscaleFilterLevelSet    downscaleFilter;
        LPDIRECTDRAWSURFACE             lpDDSOverlay;
        DWORD                           colorKeyColor;
        PictureStructure                currentDisplayMode;
        int                             decodeWidth, decodeHeight;
        TimedFiberMutex                 lock;
        XBoxDisplayBuffer				* currentDisplayBuffer, * previousDisplayBuffer;
		  bool									 overlayOpen;
		  DWORD									previousVBlankCount;


        virtual Error OpenOverlay(void);
        virtual void InitFrameBufferDisplay(void){}
        virtual void CloseOverlay(void);
        virtual void FreeDisplayBuffers(void);
        void ClearSurface(LPDIRECTDRAWSURFACE surface);
        void AllocateDisplayBuffers(void);
		void ClearDisplayBuffers(void) {}
        DWORD GetDeinterlaceFlags(void);

#ifdef USE_TEXTURE_SURFACES
		HRESULT RenderFrame(LPDIRECTDRAWSURFACE surf);
#endif


    public:
        int                     flipDoneTime;
        bool                    displayFreezeMode;
        LPDIRECTDRAWSURFACE     lpDDSecondary;
		int						sourceLeft, sourceTop, sourceWidth, sourceHeight;
		int						destLeft, destTop, destWidth, destHeight;
		int						outputLeft, outputTop, outputWidth, outputHeight;
		bool					sourceAdapt;
		bool					destAdapt;
		  bool					overlayAvailable;
		  int					horizScan;
        VideoCopyMode           eCGMSMode;

        XBoxDisplay(HINSTANCE hinst, GenericProfile * profile, GenericProfile * globalProfile);
        virtual ~XBoxDisplay(void);
        void InitDisplay(int width, int height, int minStretch);
        void EnableDisplay(bool enable);
        void UpdateDisplay(void);
        bool GetDisplayRect(RECT & rc);
        void EraseRectangle(const RECT & rc);

        virtual void SetColorKeyColor(DWORD color);

        void BeginFreezeDisplay(void);
        void EndFreezeDisplay(void);
        virtual void DisplayFrame(XBoxDisplayBuffer * buffer, PictureStructure mode);
        bool SupportsStripeAccess(void);
        bool NeedsPreviousFrame(void);
        void SetCropRectangle(WORD left, WORD top, WORD right, WORD bottom) { }
        virtual void SetSourceRectangle(bool autoAdapt, WORD left, WORD top, WORD width, WORD height);
        virtual void SetDestRectangle(bool autoAdapt, WORD left, WORD top, WORD width, WORD height);
        virtual void SetClientRectangle(bool autoAdapt, WORD left, WORD top, WORD width, WORD height);
        virtual void SetOutputRectangle(WORD left, WORD top, WORD width, WORD height);
		void GetDisplayWidth(short & w) { w = 640; }
		void GetDisplayHeight(short & h) { h = 480; }
        Error CheckHardwareResources(void) {GNRAISE_OK;}
        void SetMacrovisionLevel(int level);
        void SetCGMSMode(VideoCopyMode eCGMSMode);
        virtual bool FlipOverlay(LPDIRECTDRAWSURFACE to, DWORD flags);
        void CalculateFlipDoneTime(void);

    };


class GenericDirectXDisplay : public XBoxDisplay {};

class DirectXDisplay : public XBoxDisplay {};

class XBoxDisplayBuffer : public PictureDisplayBuffer
    {
    friend class XBoxDisplay;
    private:
        TimedFiberMutex         lock;

        XBoxDisplay          * display;
        LPDIRECTDRAWSURFACE      lpDDSurface, lpDDSecondary, lpDDPrevious;
        D3DSURFACE_DESC         desc, desc2, desc3;
		D3DLOCKED_RECT			xLock, xLock2, xLock3;
        int                     width, height;

        BYTE                    * lpSurface, * lpSecondary, * lpPrevious;

        LPDIRECTDRAWSURFACE     lpSurface1, lpSurface2;

        int                     lPitch;
        bool                    flipped;
        bool                    firstFieldDeinterlaced;
        int                     flipDoneTime;
		unsigned int			flipDoneField;
        int                     voffset;

        int                     lastUnlockTime;
        int                     deinterlaceY;
        int                     sstart;
        XBoxDisplayBuffer    * previousFrame;

        int                     decodeWidth, decodeHeight;

        bool Lock1Surface(LPDIRECTDRAWSURFACE & lpDDSurface1);
        bool Lock2Surfaces(LPDIRECTDRAWSURFACE & lpDDSurface1, LPDIRECTDRAWSURFACE & lpDDSurface2);
        bool Lock3Surfaces(LPDIRECTDRAWSURFACE & lpDDSurface1, LPDIRECTDRAWSURFACE & lpDDSurface2, LPDIRECTDRAWSURFACE & lpDDSurface3);

//        bool IsFlipStatusCompleted(LPDIRECTDRAWSURFACE lpDDSurface);

        void DeinterlaceSurfaces(LPDIRECTDRAWSURFACE lpDDTop, LPDIRECTDRAWSURFACE lpDDBottom, PictureStructure mode, FrameStore * frame, FrameStore * previous, FullWidthMMXSPUDisplayBuffer * cosd, FullWidthMMXSPUDisplayBuffer * posd, bool hurryUp);
    public:
        XBoxDisplayBuffer(XBoxDisplay             * display,
                                    LPDIRECTDRAWSURFACE lpDDSurface,
                                    LPDIRECTDRAWSURFACE lpDDSecondary,
                                    int                 width,
                                    int                 height);
        ~XBoxDisplayBuffer(void);

        void DisplayFrame(PictureStructure mode);

        bool DisplayCompleted(void);

        int DisplayCompletionDelay(void);

        bool BeginStripeAccess(FrameStore * frame, int sheight, PictureStructure fmode);
        bool NeedsFrameDataWithDirectYUVAccess(void);

        void DoneStripeAccess(void);

        void ClearFrame(void);

        void CopyStripe(int ss, PictureStructure fmode);

        bool AttemptDirectStripeYUVAccess(int width, int height, int ss, BPTR & p, BPTR & ip, int & stride);

        void DoneDirectStripeAccess(PictureStructure fmode);

        void UpdateOSDBitmap(SPUDisplayBuffer * map);

        void CopyFrame(FrameStore * frame);
        bool DeinterlaceFrame(PictureDisplayBuffer * previous, Inverse32PulldownHint & phint, bool hurryUp);
        bool CompleteDeinterlaceFrame(void);
        bool PrepareDeinterlaceDuringDecode(PictureDisplayBuffer * previous);
        bool DeinterlaceInitialFrame(void);

        bool HasInterlaceArtifacts(void);

        LPDIRECTDRAWSURFACE GetDirectDrawSurface(void) {return lpDDSurface;}

        void __cdecl DebugPrint(int x, int y, char * format, ...);
    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\YUVFrameDebug.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "YUVFrameDebug.h"

static BYTE CSet[] = {
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........

                      0x00,   // ........
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x00,   // ........
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x00,   // ........

                      0x00,   // ........
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x22,   // ..#...#.
                      0x44,   // .#...#..
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........

                      0x00,   // ........
                      0x36,   // ..##.##.
                      0x36,   // ..##.##.
                      0x7f,   // .#######
                      0x7e,   // .######.
                      0xfe,   // #######.
                      0x6c,   // .##.##..
                      0x6c,   // .##.##..
                      0x00,   // ........

                      0x00,   // ........
                      0x18,   // ...##...
                      0x3e,   // ..#####.
                      0x60,   // .##.....
                      0x3c,   // ..####..
                      0x06,   // .....##.
                      0x7c,   // .#####..
                      0x18,   // ...##...
                      0x00,   // ........

                      0x00,   // ........
                      0x60,   // .##.....
                      0x66,   // .##..##.
                      0x0c,   // ....##..
                      0x18,   // ...##...
                      0x30,   // ..##....
                      0x66,   // .##..##.
                      0x06,   // .....##.
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........

                      0x00,   // ........
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x08,   // ....#...
                      0x10,   // ...#....
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........

                      0x00,   // ........
                      0x0c,   // ....##..
                      0x18,   // ...##...
                      0x30,   // ..##....
                      0x30,   // ..##....
                      0x30,   // ..##....
                      0x18,   // ...##...
                      0x0c,   // ....##..
                      0x00,   // ........

                      0x00,   // ........
                      0x30,   // ..##....
                      0x18,   // ...##...
                      0x0c,   // ....##..
                      0x0c,   // ....##..
                      0x0c,   // ....##..
                      0x18,   // ...##...
                      0x30,   // ..##....
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x18,   // ...##...
                      0x7e,   // .######.
                      0x3c,   // ..####..
                      0x66,   // .##..##.
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x7e,   // .######.
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x00,   // ........
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x10,   // ...#....
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x7e,   // .######.
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x00,   // ........

                      0x00,   // ........
                      0x06,   // .....##.
                      0x06,   // .....##.
                      0x0c,   // ....##..
                      0x18,   // ...##...
                      0x30,   // ..##....
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x00,   // ........

                      0x00,	// ........
                      0x3c,	// ..####..
							 0x66,	// .##..##.
                      0x66,	// .##.###.
                      0x66,	// .######.
                      0x66,	// .###.##.
                      0x66,	// .##..##.
							 0x3c,	// ..####..
                      0x00,	// ........

                      0x00,	// ........
                      0x18,	// ...##...
							 0x38,	// ..###...
                      0x78,	// .####...
                      0x18,	// ...##...
                      0x18,	// ...##...
                      0x18,	// ...##...
							 0x7e,	// .######.
                      0x00,	// ........

                      0x00,	// ........
                      0x3c,	// ..####..
							 0x66,	// .##..##.
                      0x06,	// .....##.
                      0x3c,	// ..####..
                      0x60,	// .##.....
                      0x60,	// .##.....
							 0x7e,	// .######.
                      0x00,	// ........

                      0x00,	// ........
                      0x3c,	// ..####..
							 0x66,	// .##..##.
							 0x06,	// .....##.
                      0x1c,	// ...###..
                      0x06,	// .....##.
                      0x66,	// .##..##.
							 0x3c,	// ..####..
                      0x00,	// ........

                      0x00,	// ........
                      0x1c,	// ...###..
							 0x3c,	// ..####..
                      0x6c,	// .##.##..
                      0x6c,	// .##.##..
                      0x7e,	// .######.
                      0x0c,	// ....##..
							 0x0c,	// ....##..
                      0x00,	// ........

                      0x00,	// ........
                      0x7e,	// .######.
							 0x60,	// .##.....
							 0x60,	// .##.....
                      0x7e,	// .#####..
                      0x06,	// .....##.
                      0x66,	// .##..##.
							 0x3c,	// ..####..
                      0x00,	// ........

                      0x00,	// ........
                      0x3c,	// ..####..
							 0x66,	// .##..##.
							 0x60,	// .##.....
                      0x7c,	// .#####..
                      0x66,	// .##..##.
                      0x66,	// .##..##.
							 0x3c,	// ..####..
                      0x00,	// ........

                      0x00,	// ........
                      0x7e,	// .######.
							 0x06,	// .....##.
                      0x0c,	// ....##..
                      0x18,	// ...##...
                      0x18,	// ...##...
                      0x18,	// ...##...
							 0x18,	// ...##...
                      0x00,	// ........

                      0x00,	// ........
                      0x3c,	// ..####..
							 0x66,	// .##..##.
							 0x66,	// .##..##.
                      0x3c,	// ..####..
                      0x66,	// .##..##.
                      0x66,	// .##..##.
							 0x3c,	// ..####..
                      0x00,	// ........

                      0x00,	// ........
                      0x3c,	// ..####..
							 0x66,	// .##..##.
							 0x66,	// .##..##.
                      0x3e,	// ..#####.
                      0x06,	// .....##.
                      0x66,	// .##..##.
							 0x3c,	// ..####..
                      0x00,	// ........

                      0x00,   // ........
                      0x00,   // ........
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x00,   // ........
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x00,   // ........
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x00,   // ........
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x10,   // ...#....
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x06,   // .....##.
                      0x18,   // ...##...
                      0x60,   // .##.....
                      0x18,   // ...##...
                      0x06,   // .....##.
                      0x00,   // ........
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x7e,   // .######.
                      0x00,   // ........
                      0x7e,   // .######.
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x60,   // .##.....
                      0x18,   // ...##...
                      0x06,   // .....##.
                      0x18,   // ...##...
                      0x60,   // .##.....
                      0x00,   // ........
                      0x00,   // ........

                      0x00,   // ........
                      0x3c,   // ..####..
                      0x66,   // .##..##.
                      0x06,   // .....##.
                      0x0c,   // ....##..
                      0x18,   // ...##...
                      0x00,   // ........
                      0x18,   // ...##...
                      0x00,	// ........

                      0x00,   // ........
                      0x3c,   // ..####..
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x6e,   // .##.###.
                      0x6e,   // .##.###.
                      0x60,   // .##.....
                      0x3c,   // ..####..
                      0x00,   // ........

                      0x00,   // ........
                      0x18,   // ...##...
                      0x3c,   // ..####..
                      0x66,   // .##..##.
                      0x7e,   // .######.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x00,   // ........

                      0x00,   // ........
                      0x7c,   // .#####..
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x7c,   // .#####..
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x7c,   // .#####..
                      0x00,   // ........

                      0x00,   // ........
                      0x3c,   // ..####..
                      0x66,   // .##..##.
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x66,   // .##..##.
                      0x3c,   // ..####..
                      0x00,   // ........

                      0x00,   // ........
                      0x7c,   // .#####..
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x7c,   // .#####..
                      0x00,   // ........

                      0x00,   // ........
                      0x7e,   // .######.
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x7c,   // .#####..
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x7e,   // .######.
                      0x00,   // ........

                      0x00,   // ........
                      0x7e,   // .######.
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x7c,   // .#####..
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x00,   // ........

                      0x00,   // ........
                      0x3c,   // ..####..
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x6e,   // .##.###.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x3c,   // ..####..
                      0x00,   // ........

                      0x00,   // ........
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x7e,   // .######.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x00,   // ........

                      0x00,   // ........
                      0x3c,   // ..####..
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x3c,   // ..####..
                      0x00,   // ........

                      0x00,   // ........
                      0x7e,   // .######.
                      0x06,   // .....##.
                      0x06,   // .....##.
                      0x06,   // .....##.
                      0x06,   // .....##.
                      0x66,   // .##..##.
                      0x3c,   // ..####..
                      0x00,   // ........

                      0x00,   // ........
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x6c,   // .##.##..
                      0x78,   // .####...
                      0x6c,   // .##.##..
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x00,   // ........

                      0x00,   // ........
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x7e,   // .######.
                      0x00,   // ........

                      0x00,   // ........
                      0x63,   // .##...##
                      0x77,   // .###.###
                      0x7f,   // .#######
                      0x6b,   // .##.#.##
                      0x63,   // .##...##
                      0x63,   // .##...##
                      0x63,   // .##...##
                      0x00,   // ........

                      0x00,   // ........
                      0x66,   // .##..##.
                      0x76,   // .###.##.
                      0x7e,   // .######.
                      0x7e,   // .######.
                      0x6e,   // .##.###.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x00,   // ........

                      0x00,   // ........
                      0x3c,   // ..####..
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x3c,   // ..####..
                      0x00,   // ........

                      0x00,   // ........
                      0x7c,   // .#####..
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x7c,   // .#####..
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x00,   // ........

                      0x00,   // ........
                      0x3c,   // ..####..
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x6c,   // .##.##..
                      0x36,   // ..##.##.
                      0x00,   // ........

                      0x00,   // ........
                      0x7c,   // .#####..
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x7c,   // .#####..
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x00,   // ........

                      0x00,   // ........
                      0x3c,   // ..####..
                      0x66,   // .##..##.
                      0x60,   // .##.....
                      0x3c,   // ..####..
                      0x06,   // .....##.
                      0x66,   // .##..##.
                      0x3c,   // ..####..
                      0x00,   // ........

                      0x00,   // ........
                      0x7e,   // .######.
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x00,   // ........

                      0x00,   // ........
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x3c,   // ..####..
                      0x00,   // ........

                      0x00,   // ........
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x7e,   // .######.
                      0x3c,   // ..####..
                      0x18,   // ...##...
                      0x00,   // ........

                      0x00,   // ........
                      0x63,   // .##...##
                      0x63,   // .##...##
                      0x63,   // .##...##
                      0x6b,   // .##.#.##
                      0x7f,   // .#######
                      0x77,   // .###.###
                      0x63,   // .##...##
                      0x00,   // ........

                      0x00,   // ........
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x7e,   // .######.
                      0x3c,   // ..####..
                      0x7e,   // .######.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x00,   // ........

                      0x00,   // ........
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x3c,   // ..####..
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x00,   // ........

                      0x00,   // ........
                      0x7e,   // .######.
                      0x06,   // .....##.
                      0x0c,   // ....##..
                      0x18,   // ...##...
                      0x30,   // ..##....
                      0x60,   // .##.....
                      0x7e,   // .######.
                      0x00,   // ........

                      0x00,   // ........
                      0x3c,   // ..####..
                      0x30,   // ..##....
                      0x30,   // ..##....
                      0x30,   // ..##....
                      0x30,   // ..##....
                      0x30,   // ..##....
                      0x3c,   // ..####..
                      0x00,   // ........

                      0x00,   // ........
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x30,   // ..##....
                      0x18,   // ...##...
                      0x0c,   // ....##..
                      0x06,   // .....##.
                      0x06,   // .....##.
                      0x00,   // ........

                      0x00,   // ........
                      0x3c,   // ..####..
                      0x0c,   // ....##..
                      0x0c,   // ....##..
                      0x0c,   // ....##..
                      0x0c,   // ....##..
                      0x0c,   // ....##..
                      0x3c,   // ..####..
                      0x00,   // ........

                      0x00,   // ........
                      0x18,   // ...##...
                      0x3c,   // ..####..
                      0x66,   // .##..##.
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0xff,   // ########

                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x08,   // ....#...
                      0x10,   // ...#....
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x3c,   // ..####..
                      0x06,   // .....##.
                      0x3e,   // ..#####.
                      0x66,   // .##..##.
                      0x3a,   // ..###.#.
                      0x00,   // ........

                      0x00,   // ........
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x7c,   // .#####..
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x7c,   // .#####..
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x3c,   // ..####..
                      0x66,   // .##..##.
                      0x60,   // .##.....
                      0x66,   // .##..##.
                      0x3c,   // ..####..
                      0x00,   // ........

                      0x00,   // ........
                      0x06,   // .....##.
                      0x06,   // .....##.
                      0x06,   // .....##.
                      0x3e,   // ..#####.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x3e,   // ..#####.
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x3c,   // ..####..
                      0x66,   // .##..##.
                      0x7e,   // .######.
                      0x60,   // .##.....
                      0x3c,   // ..####..
                      0x00,   // ........

                      0x00,   // ........
                      0x0c,   // ....##..
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x7e,   // .######.
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x3a,   // ..###.#.
                      0x66,   // .##..##.
                      0x3e,   // ..#####.
                      0x06,   // .....##.
                      0x3c,   // ..####..

                      0x00,   // ........
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x7c,   // .#####..
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x18,   // ...##...
                      0x00,   // ........
                      0x38,   // ..###...
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x3c,   // ..####..
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x18,   // ...##...
                      0x00,   // ........
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x30,   // ..##....

                      0x00,   // ........
                      0x60,   // .##.....
                      0x60,   // .##.....
                      0x66,   // .##..##.
                      0x6c,   // .##.##..
                      0x78,   // .####...
                      0x6c,   // .##.##..
                      0x66,   // .##..##.
                      0x00,   // ........

                      0x00,   // ........
                      0x30,   // ..##....
                      0x30,   // ..##....
                      0x30,   // ..##....
                      0x30,   // ..##....
                      0x30,   // ..##....
                      0x30,   // ..##....
                      0x18,   // ...##...
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x76,   // .###.##.
                      0x6b,   // .##.#.##
                      0x6b,   // .##.#.##
                      0x6b,   // .##.#.##
                      0x6b,   // .##.#.##
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x7c,   // .#####..
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x3c,   // ..####..
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x3c,   // ..####..
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x7c,   // .#####..
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x7c,   // .#####..
                      0x60,   // .##.....
                      0x60,   // .##.....

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x3e,   // ..#####.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x3e,   // ..#####.
                      0x06,   // .....##.
                      0x06,   // .....##.

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x2c,   // ..#.##..
                      0x36,   // ..##.##.
                      0x30,   // ..##....
                      0x30,   // ..##....
                      0x30,   // ..##....
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x3c,   // ..####..
                      0x60,   // .##.....
                      0x3c,   // ..####..
                      0x06,   // .....##.
                      0x3c,   // ..####..
                      0x00,   // ........

                      0x00,   // ........
                      0x08,   // ....#...
                      0x18,   // ...##...
                      0x7e,   // .######.
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x0c,   // ....##..
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x3a,   // ..###.#.
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x3c,   // ..####..
                      0x18,   // ...##...
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x63,   // .##...##
                      0x63,   // .##...##
                      0x6b,   // .##.#.##
                      0x7f,   // .#######
                      0x2a,   // ..#.#.#.
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x66,   // .##..##.
                      0x3c,   // ..####..
                      0x18,   // ...##...
                      0x3c,   // ..####..
                      0x66,   // .##..##.
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x66,   // .##..##.
                      0x3e,   // ..#####.
                      0x06,   // .....##.
                      0x1c,   // ...###..

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x7e,   // .######.
                      0x0c,   // ....##..
                      0x18,   // ...##...
                      0x30,   // ..##....
                      0x7e,   // .######.
                      0x00,   // ........

                      0x00,   // ........
                      0x0c,   // ....##..
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x30,   // ..##....
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x0c,   // ....##..
                      0x00,   // ........

                      0x00,   // ........
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x00,   // ........

                      0x00,   // ........
                      0x30,   // ..##....
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x0c,   // ....##..
                      0x18,   // ...##...
                      0x18,   // ...##...
                      0x30,   // ..##....
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x38,   // ..###...
                      0x6b,   // .##.#.##
                      0x0e,   // ....###.
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........

                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00,   // ........
                      0x00};	// ........

static void PutChar(BYTE * dp, DWORD bpr, char c)
	{
   if ((c < 32) || (c>127)) c = (char)128;

   BYTE * gfx = &(CSet[(c-32) * 9]);
	WORD * wpix = (WORD *)dp;
	int offset = (bpr - 16) >> 1;
	int i, j;
	BYTE shift;

	for(i=0; i<9; i++)
		{
		shift = *gfx++;
		for(j=0; j<8; j++)
			{
			if (shift & 0x80)
				*wpix++ = 0x80ff;
			else
				*wpix++ = 0x8000;
			shift <<= 1;
			}
		wpix+=offset;
		}
   }

void __cdecl YUVD_WriteString(BYTE * yuvp, DWORD bpr, int x, int y, char * format, ...)
	{
	char buffer[256];
	int i;

	wvsprintf(buffer, format, (LPSTR)(&format+1));

	yuvp += 16 * x + bpr * (10 * y);
	i = 0;
	while (buffer[i])
		{
		PutChar(yuvp, bpr, buffer[i]);
		i++;
		yuvp += 16;
		}
	}

static void PutChar2(BYTE * dp, DWORD bpr, char c)
	{
   if ((c < 32) || (c>127)) c = (char)128;

   BYTE * gfx = &(CSet[(c-32) * 9]);
	DWORD * wpix = (DWORD *)dp;
	int offset = (bpr - 32) >> 2;
	int i, j;
	BYTE shift;

	for(i=0; i<9; i++)
		{
		shift = *gfx++;
		for(j=0; j<8; j++)
			{
			if (shift & 0x80)
				*wpix++ = 0x80ff80ff;
			else
				*wpix++ = 0x80008000;
			shift <<= 1;
			}
		wpix+=offset;
		}
   }

void __cdecl YUVD_WriteString2(BYTE * yuvp, DWORD bpr, int x, int y, char * format, ...)
	{
	char buffer[256];
	int i;

	wvsprintf(buffer, format, (LPSTR)(&format+1));

	yuvp += 32 * x + bpr * (20 * y);
	i = 0;
	while (buffer[i])
		{
		PutChar2(yuvp, bpr, buffer[i]);
		i++;
		yuvp += 32;
		}
	}

void YUVD_DrawChart(BYTE * yuvp, DWORD bpr, int x, int y, int w, int h, int l, int * data)
	{
	int ix, iy, iv;
	WORD * wpix = (WORD *)(yuvp + bpr * y) + x;
	int wpr = bpr / 2;

	for(iy = 0; iy<h; iy++)
		{
		iv = data[iy];
		if (iv < 0) iv = 0; else if (iv > w) iv = w;

		if (iv >= l)
			{
			for(ix=0; ix<l; ix++)
				wpix[ix] = 0x8020;
			for(;ix<iv; ix++)
				wpix[ix] = 0x80ff;
			for(;ix<w; ix++)
				wpix[ix] = 0x8020;
			}
		else
			{
			for(ix=0; ix<iv; ix++)
				wpix[ix] = 0x8020;
			for(;ix<l; ix++)
				wpix[ix] = 0x80ff;
			for(;ix<w; ix++)
				wpix[ix] = 0x8020;
			}

		wpix += wpr;
		}
	}

void YUVD_DrawChart2(BYTE * yuvp, DWORD bpr, int x, int y, int w, int h, int l, int * data1, int * data2)
	{
	int ix, iy, iv, iw;
	WORD * wpix = (WORD *)(yuvp + bpr * y) + x;
	int wpr = bpr / 2;

	for(iy = 0; iy<h; iy++)
		{
		iv = data1[iy];
		iw = data2[iy];

		if (iv < 0) iv = 0; else if (iv > w) iv = w;
		if (iw < 0) iw = 0; else if (iw > w) iw = w;

		if      (iw >= iv && iv >= l)
			{
			for(ix=0; ix<l; ix++)
				wpix[ix] = 0x8020;
			for(;ix<iv; ix++)
				wpix[ix] = 0x80ff;
			for(;ix<iw; ix++)
				wpix[ix] = 0x8080;
			for(;ix<w; ix++)
				wpix[ix] = 0x8020;
			}
		else if (iv >= iw && iw >= l)
			{
			for(ix=0; ix<l; ix++)
				wpix[ix] = 0x8020;
			for(;ix<iw; ix++)
				wpix[ix] = 0x8080;
			for(;ix<iv; ix++)
				wpix[ix] = 0x80ff;
			for(;ix<w; ix++)
				wpix[ix] = 0x8020;
			}
		else if (iv >= iw && iv <= l)
			{
			for(ix=0; ix<iw; ix++)
				wpix[ix] = 0x8020;
			for(; ix<iv; ix++)
				wpix[ix] = 0x8080;
			for(;ix<l; ix++)
				wpix[ix] = 0x80ff;
			for(;ix<w; ix++)
				wpix[ix] = 0x8020;
			}
		else if (iw >= iv && iw <= l)
			{
			for(ix=0; ix<iv; ix++)
				wpix[ix] = 0x8020;
			for(; ix<iw; ix++)
				wpix[ix] = 0x80ff;
			for(;ix<l; ix++)
				wpix[ix] = 0x8080;
			for(;ix<w; ix++)
				wpix[ix] = 0x8020;
			}
		else if (iw >= iv)
			{
			for(ix=0; ix<iv; ix++)
				wpix[ix] = 0x8020;
			for(;ix<l; ix++)
				wpix[ix] = 0x80ff;
			for(; ix<iw; ix++)
				wpix[ix] = 0x8080;
			for(;ix<w; ix++)
				wpix[ix] = 0x8020;
			}
		else
			{
			for(ix=0; ix<iw; ix++)
				wpix[ix] = 0x8020;
			for(;ix<l; ix++)
				wpix[ix] = 0x8080;
			for(; ix<iv; ix++)
				wpix[ix] = 0x80ff;
			for(;ix<w; ix++)
				wpix[ix] = 0x8020;
			}

		wpix += wpr;
		}
	}

void YUVD_DrawFlow(BYTE * yuvp, DWORD bpr, int x, int y, int w, int h, int l)
	{
	int ix, iy;
	WORD * wpix = (WORD *)(yuvp + bpr * y) + x;
	int wpr = bpr / 2;
	int dl = 0x10000 / w;
	int wl;

	for(iy = 0; iy<h; iy++)
		{
		wl = l * 0x100 + 0x800000;
		for(ix=0; ix<w; ix++)
			{
			wpix[ix] = wl >> 8;
			wl = (wl + dl) & 0x80ffff;
			}
		wpix += wpr;
		}
	}

#define DIB_HEADER_MARKER     ((WORD) ('M' << 8) | 'B')

static void YUV2RGB(BYTE cy, BYTE cu, BYTE cv, BYTE & cr, BYTE & cg, BYTE & cb)
	{
	int iy = cy;
	int iu = (int)cu - 128;
	int iv = (int)cv - 128;

	int ir = (256 * iy + 351 * iu) >> 8;
	int ig = (256 * iy - 179 * iu - 86 * iv) >> 8;
	int ib = (256 * iy + 443 * iv) >> 8;

	if (ir < 0) cr = 0; else if (ir > 255) cr = 255; else cr = (BYTE)ir;
	if (ig < 0) cg = 0; else if (ig > 255) cg = 255; else cg = (BYTE)ig;
	if (ib < 0) cb = 0; else if (ib > 255) cb = 255; else cb = (BYTE)ib;
	}


typedef struct tagBITMAPINFOHEADER{
        DWORD      biSize;
        LONG       biWidth;
        LONG       biHeight;
        WORD       biPlanes;
        WORD       biBitCount;
        DWORD      biCompression;
        DWORD      biSizeImage;
        LONG       biXPelsPerMeter;
        LONG       biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} BITMAPINFOHEADER, FAR *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;


/* constants for the biCompression field */
#define BI_RGB        0L
#define BI_RLE8       1L
#define BI_RLE4       2L
#define BI_BITFIELDS  3L


#include <pshpack2.h>
typedef struct tagBITMAPFILEHEADER {
        WORD    bfType;
        DWORD   bfSize;
        WORD    bfReserved1;
        WORD    bfReserved2;
        DWORD   bfOffBits;
} BITMAPFILEHEADER, FAR *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;


void YUVD_SavePicture(BYTE * yuvp, DWORD bpr, int width, int height, char * fname, int no)
	{
	HANDLE file;
	int x, y;
	BYTE rgbline[720 * 3];
	BITMAPFILEHEADER bmfHdr;
	BITMAPINFOHEADER bmih;
	DWORD done;
	BYTE * pp, * dp;
	char dname[100];

	wsprintf(dname, "%s%04d.bmp", fname, no);

	bmih.biSize = sizeof(BITMAPINFOHEADER);
	bmih.biWidth = width;
	bmih.biHeight = height;
	bmih.biPlanes = 1;
	bmih.biBitCount = 24;
	bmih.biCompression = BI_RGB;
	bmih.biSizeImage = width * height * 3;
	bmih.biXPelsPerMeter = 0;
	bmih.biYPelsPerMeter = 0;
	bmih.biClrUsed = 0;
	bmih.biClrImportant = 0;

	bmfHdr.bfType = DIB_HEADER_MARKER;
	bmfHdr.bfSize = bmih.biSize + bmih.biSizeImage + sizeof(BITMAPFILEHEADER);
	bmfHdr.bfReserved1 = 0;
	bmfHdr.bfReserved2 = 0;
	bmfHdr.bfOffBits = (DWORD)sizeof(BITMAPFILEHEADER) + bmih.biSize;

	file = ::CreateFile(dname, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (file != INVALID_HANDLE_VALUE)
		{
		::WriteFile(file, &bmfHdr, sizeof(BITMAPFILEHEADER), &done, NULL);
		::WriteFile(file, &bmih, bmih.biSize, &done, NULL);

		for(y=0; y<height; y++)
			{
			pp = yuvp + bpr * (height - y - 1);
			dp = rgbline;

			for(x=0; x<width; x+=2)
				{
				YUV2RGB(pp[0], pp[3], pp[1], dp[2], dp[1], dp[0]);
				YUV2RGB(pp[2], pp[3], pp[1], dp[5], dp[4], dp[3]);

				pp += 4;
				dp += 6;
				}

			::WriteFile(file, rgbline, 3 * width, &done, NULL);
			}


		::CloseHandle(file);
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\YUVFrameDebug.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef YUVFRAMEDEBUG_H
#define YUVFRAMEDEBUG_H

#include "driver\SoftwareCinemaster\Common\Prelude.h"

void __cdecl YUVD_WriteString(BYTE * yuvp, DWORD bpr, int x, int y, char * format, ...);

void __cdecl YUVD_WriteString2(BYTE * yuvp, DWORD bpr, int x, int y, char * format, ...);

void YUVD_DrawChart(BYTE * yuvp, DWORD bpr, int x, int y, int w, int h, int l, int * data);

void YUVD_DrawChart2(BYTE * yuvp, DWORD bpr, int x, int y, int w, int h, int l, int * data1, int * data2);

void YUVD_DrawFlow(BYTE * yuvp, DWORD bpr, int x, int y, int w, int h, int l);

void YUVD_SavePicture(BYTE * yupb, DWORD bpr, int width, int height, char * fname, int no);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\XMMXYUVConverter.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "..\common\MMXExtensionMacros.h"
#include "XMMXYUVConverter.h"
#include "..\common\TimedFibers.h"

#pragma warning (disable : 4799 4731)


#define MEASURE_SCALE_TIME				0
#define MEASURE_XSCALE_TIME			0
#define MEASURE_DEINTERLACE_TIME		0

extern MMXShort<4> sinctab[128];
extern MMXShort<4> sinctabxSet[16][128];
extern MMXShort<4> sinctaby[128];
extern MMXShort<4> sinctabySet[16][128];


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// XMMX optimized versions of the YUV converter routines
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//
// Convert a single Y line and a pair of UV lines into a YUY2 line
// by averaging the UV lines
//
static inline void ConvertLineToYUV_P8D1MUV(BYTE * py, BYTE * puv, BYTE * pm, int w, int bpr) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXInt<2> mask7 = {0x7f7f7f7f, 0x7f7f7f7f};

	if (w)
		{
		__asm
			{
			mov			eax, [pm]
			mov			ebx, [py]
			mov			edx, [puv]
			mov			ecx, [w]
			mov			esi, [bpr]

	loop2:
			movq			mm0, [ebx]

			movq			mm1, [edx]
			movq			mm2, [edx+2*esi]

			pavgb			(mm1, mm2)

			movq			mm2, mm0
			punpcklbw	mm0, mm1
			punpckhbw	mm2, mm1

			movq			[eax], mm0

			movq			[eax+8], mm2

			add			ebx, 8
			add			edx, 8
			add			eax, 16
			sub			ecx, 8
			jne			loop2
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8D1MUV) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}

static inline void ConvertLineToYUV_P8D1MY(BYTE * py, BYTE * puv, BYTE * pm, int w, int bpr) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXInt<2> mask7 = {0x7f7f7f7f, 0x7f7f7f7f};

	if (w)
		{
		__asm
			{
			mov			eax, [pm]
			mov			ebx, [py]
			mov			edx, [puv]
			mov			ecx, [w]
			mov			esi, [bpr]

	loop2:
			movq			mm1, [edx]

			movq			mm0, [ebx]
			movq			mm2, [ebx+2*esi]

			pavgb			(mm0, mm2)

			movq			mm2, mm0
			punpcklbw	mm0, mm1
			punpckhbw	mm2, mm1

			movq			[eax], mm0

			movq			[eax+8], mm2

			add			ebx, 8
			add			edx, 8
			add			eax, 16
			sub			ecx, 8
			jne			loop2
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8D1MY) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}

static inline void ConvertLineToYUV_P8D1MYUV(BYTE * py, BYTE * puv, BYTE * pm, int w, int bpr)	// XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXInt<2> mask7 = {0x7f7f7f7f, 0x7f7f7f7f};

	if (w)
		{
		__asm
			{
			mov			eax, [pm]
			mov			ebx, [py]
			mov			edx, [puv]
			mov			ecx, [w]
			mov			esi, [bpr]

	loop2:
			movq			mm0, [ebx]
			movq			mm2, [ebx+2*esi]

			pavgb			(mm0, mm2)

			movq			mm1, [edx]
			movq			mm2, [edx+2*esi]

			pavgb			(mm1, mm2)

			movq			mm2, mm0
			punpcklbw	mm0, mm1
			punpckhbw	mm2, mm1

			movq			[eax], mm0

			movq			[eax+8], mm2

			add			ebx, 8
			add			edx, 8
			add			eax, 16
			sub			ecx, 8
			jne			loop2
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8D1MYUV) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}





static inline void ConvertLineToYUVThroughOSD_P8D1MUV(BYTE * py, BYTE * puv, BYTE * pm, int w, int bpr, BYTE * po, DDWORD * dd) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXInt<2> mask7 = {0x7f7f7f7f, 0x7f7f7f7f};

	__asm
		{
		xor			ecx, ecx
		mov			esi, [po]
		mov			ebx, [pm]
		mov			edx, [puv]

		movq			mm6, [mask7]
		pxor			mm7, mm7
loop2:
		mov			edi, [py]
		movq			mm0, [edi+ecx]

		mov			edi, [bpr]
		movq			mm1, [edx]
		movq			mm2, [edx + 2 * edi]

		pavgb			(mm1, mm2)

		movq			mm2, mm0
		punpcklbw	mm0, mm1
		punpckhbw	mm2, mm1

		movq			mm1, mm0
		punpcklbw	mm0, mm7
		punpckhbw	mm1, mm7

		movq			mm3, mm2
		punpcklbw	mm2, mm7
		punpckhbw	mm3, mm7

		mov			edi, [dd]

		movzx			eax, BYTE PTR [esi]
		pmullw		mm0, [edi + eax * 8 + 2048]
		movq			mm4, [edi + eax * 8]
		paddw			mm0, mm4
		psrlw			mm0, 4

		movzx			eax, [esi+1]
		pmullw		mm1, [edi + eax * 8 + 2048]
		movq			mm5, [edi + eax * 8]
		paddw			mm1, mm5
		psrlw			mm1, 4

		packuswb		mm0, mm1
		movq			[ebx+2*ecx], mm0

		movzx			eax, BYTE PTR [esi+2]
		pmullw		mm2, [edi + eax * 8 + 2048]
		movq			mm5, [edi + eax * 8]
		paddw			mm2, mm5

		movzx			eax, BYTE PTR [esi+3]

		pmullw		mm3, [edi + eax * 8 + 2048]
		paddw			mm3, [edi + eax * 8]
		psrlw			mm2, 4
		psrlw			mm3, 4
		packuswb		mm2, mm3

		movq			[ebx+2*ecx+8], mm2

		add			esi, 4
		add			edx, 8
		add			ecx, 8
		cmp			ecx, [w]
		jne			loop2
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT ThroughOSD_P8D1MUV) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}



///////////////////////////////////////////////////////////////////////////////
//
// eight bit conversion routines with binary x scaling and no y scaling
//

//
// Convert a pair of single Y and UV into a YUY2 line, downscaling horizontaly
// by a factor of two
//
static inline void ConvertLineToYUV_P8D2MUV(BYTE * py, BYTE * puv, BYTE * pm, int w, int bpr) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXQShort masklow = {0x00ff, 0x00ff, 0x00ff, 0x00ff};

	if (w)
		{
		__asm
			{
			mov			eax, [pm]
			mov			ebx, [py]
			mov			edx, [puv]
			mov			ecx, [w]
			mov			esi, [bpr]
			movq			mm6, [masklow]

	loop2:
			movq			mm0, [ebx]
			movq			mm1, [edx]
			movq			mm2, [edx+2*esi]

			movq			mm3, mm0
			pand			mm3, mm6
			psrlw			mm0, 8
			pavgb			(mm0, mm3)


			pxor			mm7, mm7
			pavgb			(mm1, mm2)
			pshufw		(mm3, mm1, 0xB1)
			pavgb			(mm3, mm1)
			pshufw		(mm1, mm3, 0xD0)
			punpckhbw   mm7, mm1

			por			mm0, mm7

			movq			[eax], mm0

			add			ebx, 8
			add			edx, 8
			add			eax, 8
			sub			ecx, 8
			jne			loop2
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8D2MUV) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}

static inline void ConvertLineToYUV_P8D2MYUV(BYTE * py, BYTE * puv, BYTE * pm, int w, int bpr)	// XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXQShort masklow = {0x00ff, 0x00ff, 0x00ff, 0x00ff};

	if (w)
		{
		__asm
			{
			mov			eax, [pm]
			mov			ebx, [py]
			mov			edx, [puv]
			mov			ecx, [w]
			mov			esi, [bpr]
			movq			mm6, [masklow]
			pxor			mm7, mm7

	loop2:


			movq			mm0, [ebx]
			movq			mm4, [ebx+2*esi]
			movq			mm1, [edx]
			movq			mm2, [edx+2*esi]

			pavgb			(mm0, mm4)
			movq			mm3, mm0
			psllq			mm0, 8
			pavgb			(mm0, mm3)
			psrlw			mm0, 8

			pxor			mm7, mm7
			pavgb			(mm1, mm2)
			pshufw		(mm3, mm1, 0xB1)
			pavgb			(mm3, mm1)
			pshufw		(mm1, mm3, 0xD0)
			punpckhbw   mm7, mm1


			por			mm0, mm7

			movq			[eax], mm0

			add			ebx, 8
			add			edx, 8
			add			eax, 8
			sub			ecx, 8
			jne			loop2
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8D2MYUV) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}

static inline void ConvertLineToYUV_P8D2MY(BYTE * py, BYTE * puv, BYTE * pm, int w, int bpr) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXQShort masklow = {0x00ff, 0x00ff, 0x00ff, 0x00ff};

	if (w)
		{
		__asm
			{
			mov			eax, [pm]
			mov			ebx, [py]
			mov			edx, [puv]
			mov			ecx, [w]
			mov			esi, [bpr]
			movq			mm6, [masklow]

	loop2:
			movq			mm0, [ebx]
			movq			mm4, [ebx+2*esi]
			movq			mm1, [edx]

			pavgb			(mm0, mm4)
			movq			mm3, mm0
			psllq			mm0, 8
			pavgb			(mm0, mm3)
			psrlw			mm0, 8

			pxor			mm7, mm7
			pshufw		(mm3, mm1, 0xB1)
			pavgb			(mm3, mm1)
			pshufw		(mm3, mm3, 0xD0)
			punpckhbw	mm7, mm3

			por			mm0, mm7

			movq			[eax], mm0

			add			ebx, 8
			add			edx, 8
			add			eax, 8
			sub			ecx, 8
			jne			loop2
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8D2MY) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}

//
// Convert a single Y line and a pair of UV lines into a YUY2 line
// by averaging the UV lines and downscaling by two
//
static inline void ConvertLineToYUV_P8D2(BYTE * py, BYTE * puv, BYTE * pm, int w) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif

	static MMXDWORD<2> lwrbytes = {0x00ff00ff, 0x00ff00ff};

	if (w)
		{
		__asm
			{
			mov	eax,	[pm]
			mov	ebx,	[py]
			mov	edx,	[puv]
			mov	ecx,  [w]

			add	eax, ecx
			add	ebx, ecx
			add	edx, ecx
			neg	ecx

			movq	mm7, [lwrbytes]

loop1:


			movq			mm0, [ebx+ecx]
			movq			mm3, mm0
			psrlq			mm3, 8
			pavgb			(mm3, mm0)
			pand			mm3, mm7


			movq			mm1, [edx+ecx]
			pshufw		(mm2, mm1, 0xB1)
			pavgb			(mm2, mm1)
			pshufw		(mm2, mm2, 0xDC)
			pxor			mm6, mm6
			punpckhbw	mm6, mm2
			por			mm6, mm3

			movq	[eax+ecx], mm6
			add	ecx, 8

			jne	loop1
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8D2) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}

//
// Convert a pair of single Y and UV into a YUY2 line, downscaling
// by two and merging with an osd bitmap
//
static inline void ConvertLineToYUVThroughOSD_P8D2(BYTE * py, BYTE * puv, BYTE * pm, int w, BYTE * po, DDWORD * dd) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif

	static MMXDWORD<2> lwrbytes = {0x00ff00ff, 0x00ff00ff};

	if (w)
		{
		__asm
			{
			mov	esi,	[pm]
			mov	ebx,	[py]
			mov	edx,	[puv]
			mov	ecx,  [w]
			mov	edi,  [po]

			push	ebp
			mov	ebp,	[dd]

			add	esi, ecx
			add	ebx, ecx
			add	edx, ecx

			shr	ecx, 1

			lea	edi, [edi+ecx]

			neg	ecx

			movq	mm7, [lwrbytes]

loop1:



			movq			mm0, [ebx+2*ecx]
			movq			mm3, mm0
			psrlq			mm3, 8
			pavgb			(mm3, mm0)
			pand			mm3, mm7


			movq			mm1, [edx+2*ecx]
			pshufw		(mm6, mm1, 0xB1)
			pavgb			(mm6, mm1)
			pshufw		(mm6, mm6, 0xDC)
			pxor			mm2, mm2
			punpckhbw	mm2, mm6
			por			mm2, mm3

			pxor			mm0, mm0

			movq			mm1, mm2
			punpcklbw	mm2, mm0

			punpckhbw	mm1, mm0

			movzx			eax, BYTE PTR [edi+ecx]

			movq			mm3, [ebp + eax * 8 + 2048 + 4096]

			movq			mm4, [ebp + eax * 8 + 4096]

			movzx			eax, BYTE PTR [edi+ecx+1]

			paddw			mm3, [ebp + eax * 8 + 2048 + 8192]

			paddw			mm4, [ebp + eax * 8 + 8192]

			pmullw		mm2, mm3

			paddw			mm2, mm4

			movzx			eax, BYTE PTR [edi+ecx+2]

			movq			mm3, [ebp + eax * 8 + 2048 + 4096]

			movq			mm4, [ebp + eax * 8 + 4096]

			movzx			eax, BYTE PTR [edi+ecx+3]

			paddw			mm3, [ebp + eax * 8 + 2048 + 8192]

			paddw			mm4, [ebp + eax * 8 + 8192]

			pmullw		mm1, mm3

			paddw			mm1, mm4

			psrlw			mm2, 5

			psrlw			mm1, 5

			packuswb		mm2, mm1

			movq	[esi+ 2 * ecx], mm2

			add	ecx, 4
			jne	loop1

			pop	ebp
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT ThroughOSD_P8D2) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}


///////////////////////////////////////////////////////////////////////////////
//
// eight bit conversion routines with linear x scaling and no y scaling
//



//
// convert a pair of single y and uv lines into a yuy2 line, by using linear
// scaling, always interpolating 9 pixels in line down to 8 pixels
//
// w = number of source pixels to do, w is multiple of 8
//
static inline void ConvertLineToYUV_P8F2_928FIX(BYTE * py, BYTE * puv, BYTE * pm, int w) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif

	static MMXQUShort LeftLow   = { 0x0008, 0x0007, 0x0006, 0x0005 };
	static MMXQUShort LeftHigh  = { 0x0004, 0x0003, 0x0002, 0x0001 };

	static MMXQUShort RightLow  = { 0x0000, 0x0001, 0x0002, 0x0003 };
	static MMXQUShort RightHigh = { 0x0004, 0x0005, 0x0006, 0x0007 };

	if (w)
		{
		__asm
			{
			mov			eax, [pm]
			mov			ebx, [py]
			mov			edx, [puv]
			mov			ecx, [w]

			pxor			mm7, mm7

	loop2:


			// unpack 9 bytes of Y data from bytes to words
			// 0-7
			movq			mm0, [ebx]				// py7 py6 py5 py4 py3 py2 py1 py0
			movq			mm1, mm0					// py7 py6 py5 py4 py3 py2 py1 py0
			punpcklbw	mm0, mm7					//     py3     py2     py1     py0
			punpckhbw	mm1, mm7					//     py7     py6     py5     py4
			// 1-8
			movq			mm2, [ebx+1]			// py8 py7 py6 py5 py4 py3 py2 py1
			movq			mm3, mm2					// py8 py7 py6 py5 py4 py3 py2 py1
			punpcklbw	mm2, mm7					//     py4     py3     py2     py1
			punpckhbw	mm3, mm7					//     py8     py7     py6     py5

			// interpolate pixels
			// 0-3
			pmullw		mm0, [LeftLow]
			psraw			mm0, 3
			// 4-7
			pmullw		mm1, [LeftHigh]
			psraw			mm1, 3
			// 1-4
			pmullw		mm2, [RightLow]
			psraw			mm2, 3
			// 5-9
			pmullw		mm3, [RightHigh]
			psraw			mm3, 3


			// add pixels together to get new 8
			paddw			mm0, mm2					//      n3      n2      n1      n0
			paddw			mm3, mm1					//      n7      n6      n5      n4

			// pack pixels again to store
			packuswb		mm0, mm3					//  n7  n6  n5  n4  n3  n2  n1  n0
			movq			mm1, mm0					//  n7  n6  n5  n4  n3  n2  n1  n0

			// interleave y pixels with uv data
			movq			mm2, [edx]				// uv7 uv6 uv5 uv4 uv3 uv2 uv1 uv0
			punpcklbw	mm0, mm2
			punpckhbw	mm1, mm2


			// store 8 bytes
			movq			[eax], mm0
			movq			[eax + 8], mm1

			add			eax, 16
			add			edx, 8
			add			ebx, 9

			sub			ecx, 16

			jne			loop2
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8F2_928FIX) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}





///////////////////////////////////////////////////////////////////////////////
//
// eight bit conversion routines with no x scaling and linear y scaling
//

static inline void ConvertLineToYUV_P8D1Y2(BYTE * py0, BYTE * py1, BYTE * puv, BYTE * pm, int w, int lo) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXQShort full = {0x0100, 0x0100, 0x0100, 0x0100};

	if (w)
		{
		__asm
			{
			mov			eax, [pm]
			mov			esi, [py0]
			mov			edi, [py1]
			mov			edx, [puv]
			mov			ecx, [w]

			movd			mm6, [lo]
			pshufw		(mm6, mm6, 0x00)

			movq			mm7, [full]
			psubw			mm7, mm6
			pxor			mm5, mm5

			lea			eax, [eax+2*ecx]
			add			esi, ecx
			add			edi, ecx
			add			edx, ecx
			neg			ecx

	loop2:


			movq			mm0, [esi+ecx]
			movq			mm2, mm0
			punpcklbw	mm0, mm5
			punpckhbw	mm2, mm5

			movq			mm1, [edi+ecx]
			movq			mm3, mm1
			punpcklbw	mm1, mm5
			punpckhbw	mm3, mm5

			pmullw		mm0, mm7
			pmullw		mm1, mm6
			paddw			mm0, mm1
			psrlw			mm0, 8
			pmullw		mm2, mm7
			pmullw		mm3, mm6
			paddw			mm2, mm3
			psrlw			mm2, 8
			packuswb		mm0, mm2

			movq			mm1, [edx+ecx]

			movq			mm2, mm0
			punpcklbw	mm0, mm1
			punpckhbw	mm2, mm1

			movq			[eax+2*ecx], mm0
			movq			[eax+2*ecx+8], mm2

			add			ecx, 8
			jne			loop2
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8D1Y2) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}

static inline void ConvertLineToYUVThroughOSD_P8D1Y2(BYTE * py0, BYTE * py1, BYTE * puv, BYTE * pm, int w,	BYTE * po, DDWORD * dd, int lo) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXQShort full = {0x0100, 0x0100, 0x0100, 0x0100};

	__asm
		{
		mov			ecx, [w]
		xor			ebx, ebx
		mov			edi, [pm]

		movd			mm6, [lo]
		pshufw		(mm6, mm6, 0x00)

		movq			mm7, [full]
		psubw			mm7, mm6
		pxor			mm5, mm5
loop2:
		mov			esi, [py0]
		mov			edx, [py1]

		movq			mm0, [esi+2*ebx]

		movq			mm1, [edx+2*ebx]

		movq			mm2, mm0
		punpcklbw	mm0, mm5
		punpckhbw	mm2, mm5
		movq			mm3, mm1
		punpcklbw	mm1, mm5
		punpckhbw	mm3, mm5

		pmullw		mm0, mm7
		pmullw		mm1, mm6
		paddw			mm0, mm1
		psrlw			mm0, 8
		pmullw		mm2, mm7
		pmullw		mm3, mm6
		paddw			mm2, mm3
		psrlw			mm2, 8
		packuswb		mm0, mm2

		mov			esi, [puv]

		movq			mm1, [esi+2*ebx]

		movq			mm2, mm0
		punpcklbw	mm0, mm1
		punpckhbw	mm2, mm1

		movq			mm1, mm0
		punpcklbw	mm0, mm5
		punpckhbw	mm1, mm5

		movq			mm3, mm2
		punpcklbw	mm2, mm5
		punpckhbw	mm3, mm5

		mov			esi, [po]
		mov			edx, [dd]

		movzx			eax, BYTE PTR [esi+ebx]
		pmullw		mm0, [edx + eax * 8 + 2048]
		paddw			mm0, [edx + eax * 8]
		psrlw			mm0, 4

		movzx			eax, BYTE PTR [esi+ebx+1]
		pmullw		mm1, [edx + eax * 8 + 2048]
		paddw			mm1, [edx + eax * 8]
		psrlw			mm1, 4

		movzx			eax, BYTE PTR [esi+ebx+2]
		pmullw		mm2, [edx + eax * 8 + 2048]
		paddw			mm2, [edx + eax * 8]
		psrlw			mm2, 4

		movzx			eax, BYTE PTR [esi+ebx+3]
		pmullw		mm3, [edx + eax * 8 + 2048]
		paddw			mm3, [edx + eax * 8]
		psrlw			mm3, 4

		packuswb		mm0, mm1
		packuswb		mm2, mm3

		movq			[edi+4*ebx], mm0
		movq			[edi+4*ebx+8], mm2

		add			ebx, 4
		sub			ecx, 8
		jne			loop2
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT ThroughOSD_P8D1Y2) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}



///////////////////////////////////////////////////////////////////////////////
//
// eight bit conversion routines with binary x scaling and linear y scaling
//

static inline void ConvertLineToYUV_P8D2Y2(BYTE * py0, BYTE * py1, BYTE * puv, BYTE * pm, int w, int lo) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXQShort full = {0x0080, 0x0080, 0x0080, 0x0080};
	static MMXQShort masklow = {0x00ff, 0x00ff, 0x00ff, 0x00ff};

	if (w)
		{
		__asm
			{
			mov			eax, [pm]
			mov			esi, [py0]
			mov			edi, [py1]
			mov			edx, [puv]
			mov			ecx, [w]

			add			eax, ecx
			add			edx, ecx
			add			esi, ecx
			add			edi, ecx
			neg			ecx

			movd			mm6, [lo]
			pshufw		(mm6, mm6, 0x00)

			psrlw			mm6, 1
			movq			mm7, [full]
			psubw			mm7, mm6
			pxor			mm5, mm5
loop1:



			movq			mm0, [esi+ecx]

			movq			mm1, mm0
			psrlw			mm0, 8
			pand			mm1, [masklow]
			paddw			mm0, mm1

			movq			mm1, [edi+ecx]
			movq			mm2, mm1
			psrlw			mm1, 8
			pand			mm2, [masklow]
			paddw			mm1, mm2

			pmullw		mm0, mm7
			pmullw		mm1, mm6
			paddw			mm0, mm1
			psrlw			mm0, 8
			packuswb		mm0, mm0


			movq			mm2, [edx+ecx]
			pshufw		(mm1, mm2, 0xB1)
			pavgb			(mm1, mm2)
			pshufw		(mm1, mm1, 0xDC)

			punpcklbw	mm0, mm1

			movq			[eax+ecx], mm0
			add			ecx, 8
			jne			loop1
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8D2Y2) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}



static inline void ConvertLineToYUVThroughOSD_P8D2Y2(BYTE * py0, BYTE * py1, BYTE * puv, BYTE * pm, int w,BYTE * po, DDWORD * dd, int lo) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXQShort full = {0x0080, 0x0080, 0x0080, 0x0080};
	static MMXQShort masklow = {0x00ff, 0x00ff, 0x00ff, 0x00ff};

	if (w)
		{
		__asm
			{
			mov			ecx, [w]
			xor			ebx, ebx
			mov			edi, [pm]

			movd			mm6, [lo]
			pshufw		(mm6, mm6, 0x00)

			psrlw			mm6, 1
			movq			mm7, [full]
			psubw			mm7, mm6
			pxor			mm5, mm5
loop1:
			mov			esi, [py0]
			mov			edx, [py1]

			movq			mm0, [esi+2*ebx]

			movq			mm1, mm0
			psrlw			mm0, 8
			pand			mm1, [masklow]
			paddw			mm0, mm1

			movq			mm1, [edx+2*ebx]
			mov			edx, [puv]

			movq			mm2, mm1
			psrlw			mm1, 8
			pand			mm2, [masklow]
			paddw			mm1, mm2

			pmullw		mm0, mm7
			pmullw		mm1, mm6
			paddw			mm0, mm1
			psrlw			mm0, 8
			packuswb		mm0, mm0

			movq			mm2, [edx+2*ebx]
			pshufw		(mm1, mm2, 0xB1)
			pavgb			(mm1, mm2)
			pshufw		(mm1, mm1, 0xDC)

			punpcklbw	mm0, mm1

			movq			mm1, mm0
			punpcklbw	mm0, mm5
			punpckhbw	mm1, mm5

			mov			esi, [po]
			mov			edx, [dd]

			movzx			eax, BYTE PTR [esi+ebx]
			movq			mm3, [edx + eax * 8 + 2048 + 4096]
			movq			mm4, [edx + eax * 8 + 4096]
			movzx			eax, BYTE PTR [esi+ebx+1]
			paddw			mm3, [edx + eax * 8 + 2048 + 8192]
			paddw			mm4, [edx + eax * 8 + 8192]
			pmullw		mm0, mm3
			paddw			mm0, mm4

			movzx			eax, BYTE PTR [esi+ebx+2]
			movq			mm3, [edx + eax * 8 + 2048 + 4096]
			movq			mm4, [edx + eax * 8 + 4096]
			movzx			eax, BYTE PTR [esi+ebx+3]
			paddw			mm3, [edx + eax * 8 + 2048 + 8192]
			paddw			mm4, [edx + eax * 8 + 8192]
			pmullw		mm1, mm3
			paddw			mm1, mm4

			psrlw			mm0, 5
			psrlw			mm1, 5

			packuswb		mm0, mm1

			movq			[edi+ 2 * ebx], mm0

			add			ebx, 4
			sub			ecx, 8
			jne			loop1
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT ThroughOSD_P8D2Y2) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}


///////////////////////////////////////////////////////////////////////////////
//
// eight bit conversion routines with linear x scaling and linear y scaling
//
static inline void ConvertLineToYUV_P8F2Y2(BYTE * py0, BYTE * py1, BYTE * puv, BYTE * pm, int w, int xcount, int xfraction, int lo) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXQShort negate = {0x7fff, 0x0000, 0x7fff, 0x0000};
	static MMXQShort full = {0x0100, 0x0100, 0x0100, 0x0100};

	if (w)
		{
		__asm
			{
			mov			eax, [py0]
			mov			ebx, [py1]
			mov			edx, [pm]
			mov			ecx, [w]
			mov			esi, [xcount]

			movd			mm6, [lo]
			pshufw		(mm6, mm6, 0x00)

			movq			mm7, [full]
			psubw			mm7, mm6
			pxor			mm5, mm5
	loop2:
			mov			edi, esi
			shr			edi, 16

			movd			mm0, [eax+edi]
			movd			mm3, [ebx+edi]
			movd			mm1, esi
			add			esi, [xfraction]

			and			edi, 0xfffffffe
			add			edi, [puv]
			movd			mm4, [edi]

			mov			edi, esi
			shr			edi, 16

			movd			mm2, [eax+edi]

			punpcklwd	mm0, mm2
			punpcklbw	mm0, mm5

			movd			mm2, [ebx+edi]

			punpcklwd	mm3, mm2
			punpcklbw	mm3, mm5

			pmullw		mm0, mm7
			pmullw		mm3, mm6
			paddw			mm0, mm3
			psrlw			mm0, 8

			movd			mm3, esi
			add			esi, [xfraction]

			punpckldq	mm1, mm3
			psrld			mm1, 1
			pand			mm1, [negate]
			movq			mm3, mm1
			pslld			mm1, 16
			por			mm1, mm3
			pxor			mm1, [negate]

			pmaddwd		mm0, mm1
			psrld			mm0, 15

			packssdw		mm0, mm0
			packuswb		mm0, mm0
			punpcklbw	mm0, mm4

			movd			[edx], mm0

			add			edx, 4

			sub			ecx, 2
			jne			loop2
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8F2Y2) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}

///////////////////////////////////////////////////////////////////////////////
//
// eight bit conversion routines with four tap x scaling and no y scaling
//



///////////////////////////////////////////////////////////////////////////////
//
// eight bit conversion routines with no x scaling and four tap y scaling
//

static inline void ConvertLineToYUVThroughOSD_P8D1Y4(BYTE * py0, BYTE * py1, BYTE * py2, BYTE * py3, BYTE * puv, BYTE * pm, int w, BYTE * po, DDWORD * dd, short * filter) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	if (w)
		{
		__asm
			{
			mov			eax, [filter]

			movq			mm0, [eax]				// f7f6 f5f4 f3f2 f1f0

			pshufw		(mm1, mm0, 0x55)
			pshufw		(mm2, mm0, 0xAA)
			pshufw		(mm3, mm0, 0xFF)
			pshufw		(mm0, mm0, 0x00)

			xor			ecx, ecx
			mov			edi, [py0]
			mov			esi, [po]
			mov			ebx, [py1]

			pxor			mm7, mm7
	loop1:
			movd			mm4, [edi]
			punpcklbw	mm4, mm7

			movd			mm5, [ebx]
			punpcklbw	mm5, mm7

			mov			edx, [py2]
			mov			eax, [py3]

			pmullw		mm4, mm0
			pmullw		mm5, mm1
			paddsw		mm4, mm5

			movd			mm6, [edx + ecx]
			movd			mm5, [eax + ecx]

			punpcklbw	mm6, mm7
			pmullw		mm6, mm2
			paddsw		mm4, mm6

			add			edi, 8
			movd			mm6, [edi - 4]
			punpcklbw	mm6, mm7

			punpcklbw	mm5, mm7
			pmullw		mm5, mm3
			paddsw		mm4, mm5

			movd			mm5, [ebx + 4]
			punpcklbw	mm5, mm7
			psraw			mm4, 6

			pmullw		mm6, mm0
			pmullw		mm5, mm1
			paddsw		mm6, mm5

			movd			mm5, [edx + ecx + 4]

			punpcklbw	mm5, mm7
			pmullw		mm5, mm2
			paddsw		mm6, mm5

			movd			mm5, [eax + ecx + 4]

			punpcklbw	mm5, mm7
			pmullw		mm5, mm3
			paddsw		mm6, mm5

			movzx			eax, BYTE PTR [esi]
			add			ebx, 8
			psraw			mm6, 6

			mov			edx, [puv]
			packuswb		mm4, mm6
			movq			mm6, [edx + ecx]

			movq			mm5, mm4
			punpcklbw	mm4, mm6
			punpckhbw	mm5, mm6

			movq			mm6, mm4
			punpcklbw	mm4, mm7
			punpckhbw	mm6, mm7

			mov			edx, [dd]

			pmullw		mm4, [edx + eax * 8 + 2048]

			paddw			mm4, [edx + eax * 8]
			psrlw			mm4, 4

			movzx			eax, BYTE PTR [esi+1]

			pmullw		mm6, [edx + eax * 8 + 2048]

			paddw			mm6, [edx + eax * 8]
			psrlw			mm6, 4

			packuswb		mm4, mm6

			movq			mm6, mm5
			punpcklbw	mm5, mm7
			punpckhbw	mm6, mm7

			movzx			eax, BYTE PTR [esi+2]
			pmullw		mm5, [edx + eax * 8 + 2048]
			paddw			mm5, [edx + eax * 8]
			psrlw			mm5, 4

			movzx			eax, BYTE PTR [esi+3]
			pmullw		mm6, [edx + eax * 8 + 2048]
			paddw			mm6, [edx + eax * 8]
			psrlw			mm6, 4

			add			ecx, 8
			add			esi, 4
			cmp			ecx, [w]

			packuswb		mm5, mm6
			mov			eax, [pm]

			movq			[eax+2*ecx-16], mm4
			movq			[eax+2*ecx-8], mm5

			jne			loop1
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT ThroughOSD_P8D1Y4) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}

static inline void ConvertLineToYUV_P8D1Y4(BYTE * py0, BYTE * py1, BYTE * py2, BYTE * py3, BYTE * puv, BYTE * pm, int w, short * filter) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	if (w)
		{
		__asm
			{
			mov			eax, [filter]

			movq			mm0, [eax]


			pshufw		(mm1, mm0, 0x55)
			pshufw		(mm2, mm0, 0xAA)
			pshufw		(mm3, mm0, 0xFF)
			pshufw		(mm0, mm0, 0x00)

			mov			ecx, [w]
			xor			ebx, ebx
			mov			edi, [pm]

			pxor			mm7, mm7
	loop1:
			mov			eax, [py0]

			movd			mm4, [eax + 2 * ebx]

			mov			eax, [py1]
			movd			mm5, [eax + 2 * ebx]

			punpcklbw	mm4, mm7
			punpcklbw	mm5, mm7

			pmullw		mm4, mm0
			pmullw		mm5, mm1
			paddsw		mm4, mm5

			mov			eax, [py2]
			movd			mm5, [eax + 2 * ebx]

			punpcklbw	mm5, mm7
			pmullw		mm5, mm2
			paddsw		mm4, mm5

			mov			eax, [py3]
			movd			mm5, [eax + 2 * ebx]

			punpcklbw	mm5, mm7
			pmullw		mm5, mm3
			paddsw		mm4, mm5

			mov			eax, [py0]
			movd			mm6, [eax + 2 * ebx + 4]
			psraw			mm4, 6

			mov			eax, [py1]
			movd			mm5, [eax + 2 * ebx + 4]

			punpcklbw	mm6, mm7
			punpcklbw	mm5, mm7

			pmullw		mm6, mm0
			pmullw		mm5, mm1
			paddsw		mm6, mm5

			mov			eax, [py2]
			movd			mm5, [eax + 2 * ebx + 4]

			punpcklbw	mm5, mm7
			pmullw		mm5, mm2
			paddsw		mm6, mm5

			mov			eax, [py3]
			movd			mm5, [eax + 2 * ebx + 4]

			punpcklbw	mm5, mm7
			pmullw		mm5, mm3
			paddsw		mm6, mm5

			psraw			mm6, 6
			packuswb		mm4, mm6

			mov			eax, [puv]
			movq			mm6, [eax + 2 * ebx]
			movq			mm5, mm4
			punpcklbw	mm4, mm6
			punpckhbw	mm5, mm6

			movq			[edi+4*ebx], mm4
			movq			[edi+4*ebx+8], mm5

			add			ebx, 4
			sub			ecx, 8
			jne			loop1
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8D1Y4) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}


static inline void ConvertLineToYUV_P8D1Y4MUV(BYTE * py0, BYTE * py1, BYTE * py2, BYTE * py3, BYTE * puv0, BYTE * puv1, BYTE * pm, int w, short * filter) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	if (w)
		{
		__asm
			{
			mov			eax, [filter]

			movq			mm0, [eax]


			pshufw		(mm1, mm0, 0x55)
			pshufw		(mm2, mm0, 0xAA)
			pshufw		(mm3, mm0, 0xFF)
			pshufw		(mm0, mm0, 0x00)

			mov			ecx, [w]
			xor			ebx, ebx
			mov			edi, [pm]

			pxor			mm7, mm7
	loop1:
			mov			eax, [py0]

			movd			mm4, [eax + 2 * ebx]

			mov			eax, [py1]
			movd			mm5, [eax + 2 * ebx]

			punpcklbw	mm4, mm7
			punpcklbw	mm5, mm7

			pmullw		mm4, mm0
			pmullw		mm5, mm1
			paddsw		mm4, mm5

			mov			eax, [py2]
			movd			mm5, [eax + 2 * ebx]

			punpcklbw	mm5, mm7
			pmullw		mm5, mm2
			paddsw		mm4, mm5

			mov			eax, [py3]
			movd			mm5, [eax + 2 * ebx]
			prefetcht0	[eax + 2 * ebx + 32]

			punpcklbw	mm5, mm7
			pmullw		mm5, mm3
			paddsw		mm4, mm5

			psraw			mm4, 6


			mov			eax, [puv0]
			movd			mm5, [eax + 2 * ebx]
			mov			eax, [puv1]
			movd			mm6, [eax + 2 * ebx]

			pavgb			(mm5, mm6)

			packuswb		mm4, mm4

			punpcklbw	mm4, mm5

			movq			[edi+4*ebx], mm4

			add			ebx, 2
			sub			ecx, 4
			jne			loop1
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8D1Y4MUV) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}

static inline void ConvertLineToYUVThroughOSD_P8D1Y4MUV(BYTE * py0, BYTE * py1, BYTE * py2, BYTE * py3, BYTE * puv0, BYTE * puv1, BYTE * pm, int w, BYTE * po, DDWORD * dd, short * filter) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	if (w)
		{
		__asm
			{
			mov			eax, [filter]

			movq			mm0, [eax]


			pshufw		(mm1, mm0, 0x55)
			pshufw		(mm2, mm0, 0xAA)
			pshufw		(mm3, mm0, 0xFF)
			pshufw		(mm0, mm0, 0x00)

			mov			ecx, [w]
			xor			ebx, ebx
			mov			edi, [pm]
			mov			esi, [po]

			pxor			mm7, mm7
	loop1:
			mov			eax, [py0]

			movd			mm4, [eax + 2 * ebx]

			mov			eax, [py1]
			movd			mm5, [eax + 2 * ebx]

			punpcklbw	mm4, mm7
			punpcklbw	mm5, mm7

			pmullw		mm4, mm0
			pmullw		mm5, mm1
			paddsw		mm4, mm5

			mov			eax, [py2]
			movd			mm5, [eax + 2 * ebx]

			punpcklbw	mm5, mm7
			pmullw		mm5, mm2
			paddsw		mm4, mm5

			mov			eax, [py3]
			movd			mm5, [eax + 2 * ebx]

			punpcklbw	mm5, mm7
			pmullw		mm5, mm3
			paddsw		mm4, mm5

			psraw			mm4, 6

			mov			eax, [puv0]
			movd			mm5, [eax + 2 * ebx]
			mov			eax, [puv1]
			movd			mm6, [eax + 2 * ebx]

			pavgb			(mm5, mm6)

			packuswb		mm4, mm4

			punpcklbw	mm4, mm5

			movzx			eax, BYTE PTR [esi+ebx]

			movq			mm6, mm4
			punpcklbw	mm4, mm7
			punpckhbw	mm6, mm7

			mov			edx, [dd]

			pmullw		mm4, [edx + eax * 8 + 2048]

			paddw			mm4, [edx + eax * 8]
			psrlw			mm4, 4

			movzx			eax, BYTE PTR [esi+ebx+1]

			pmullw		mm6, [edx + eax * 8 + 2048]

			paddw			mm6, [edx + eax * 8]
			psrlw			mm6, 4

			packuswb		mm4, mm6

			movq			[edi+4*ebx], mm4

			add			ebx, 2
			sub			ecx, 4
			jne			loop1
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT ThroughOSD_P8D1Y4MUV) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}


///////////////////////////////////////////////////////////////////////////////
//
// eight bit deinterlacing routines
//

///////////////////////////////////////////////////////////////////////////////
//
// eight bit scaling routines
//



static inline void ScaleYUVLines_P8Y2(BYTE * spm1, BYTE * spm2, BYTE * dpm, int w, int lo) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif

	static MMXQShort full = {0x0100, 0x0100, 0x0100, 0x0100};

	if (w)
		{
		__asm
			{
			mov			eax, [dpm]
			mov			esi, [spm1]
			mov			edi, [spm2]
			mov			ecx, [w]

			sub			esi, eax
			sub			edi, eax

			movd			mm6, [lo]

			pshufw		(mm6, mm6, 0x00)

			movq			mm7, [full]
			psubw			mm7, mm6
			pxor			mm5, mm5
	loop2:
			movq			mm0, [esi+eax]
			movq			mm2, mm0

			movq			mm1, [edi+eax]
			movq			mm3, mm1

			punpcklbw	mm0, mm5
			pmullw		mm0, mm7

			punpcklbw	mm1, mm5
			pmullw		mm1, mm6

			punpckhbw	mm2, mm5
			pmullw		mm2, mm7

			punpckhbw	mm3, mm5
			pmullw		mm3, mm6

			paddw			mm0, mm1
			psrlw			mm0, 8

			paddw			mm2, mm3
			psrlw			mm2, 8

			packuswb		mm0, mm2
			add			eax, 8

			movq			[eax-8], mm0
			sub			ecx, 4
			jne			loop2
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "OPT P8Y2) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}

static inline void ScaleYUVLine_P8F2(BYTE * spm, BYTE * dpm, int w, int xcount, int xfraction) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXQUShort negate = {0x7fff, 0x0000, 0x7fff, 0x0000};
	static MMXQUShort lower = {0x00ff, 0x00ff, 0x00ff, 0x00ff};
	static MMXQUShort upper = {0xff00, 0xff00, 0xff00, 0xff00};
	static MMXQUShort fullneg = {0xffff, 0x0000, 0xffff, 0x0000};
	static MMXQUShort mask15 = {0x7fff, 0x7fff, 0x7fff, 0x7fff};

	if (w)
		{
		__asm
			{
			mov			eax, [dpm]
			mov			ebx, [spm]
			mov			ecx, [w]
			mov			esi, [xcount]
			mov			edx, [xfraction]

			movd			mm6, esi
			movd			mm7, edx
			paddd			mm7, mm6


			punpcklwd	mm6, mm7
			punpcklwd	mm6, mm6
			psrlw			mm6, 1
			pxor			mm6, [negate]

			movd			mm7, edx
			pshufw		(mm7, mm7, 0x00)

			pxor			mm7, [fullneg]
			psubw			mm7, [fullneg]

			movq			mm4, [lower]
			movq			mm5, [mask15]
			mov			edi, esi
	loop2:
			shr			esi, 16
			movd			mm0, [ebx+2*esi]
			and			esi, 0xfffffffe

			movd			mm3, [ebx+2*esi]

			add			edi, edx
			mov			esi, edi
			shr			edi, 16

			movd			mm1, [ebx+2*edi]
			punpckldq	mm0, mm1

			add			esi, edx
			mov			edi, esi
			shr			esi, 16

			movd			mm2, [ebx+2*esi]
			pand			mm0, mm4
			and			esi, 0xfffffffe

			pmaddwd		mm0, mm6
			paddw			mm6, mm7

			psrld			mm0, 15
			pand			mm6, mm5

			movd			mm1, [ebx+2*esi]
			punpckldq	mm3, mm1

			add			edi, edx
			mov			esi, edi
			shr			edi, 16

			movd			mm1, [ebx+2*edi]
			add			esi, edx
			mov			edi, esi

			pand			mm3, [upper]
			punpckldq	mm2, mm1
			pand			mm2, mm4

			pmaddwd		mm2, mm6
			psrld			mm2, 15
			packssdw		mm0, mm2

			por			mm0, mm3
			paddw			mm6, mm7

			movq			[eax], mm0
			pand			mm6, mm5

			add			eax, 8

			sub			ecx, 4
			jne			loop2
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "OPT P8F2) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}



///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////



static inline void ConvertLineToYUV_P8D1I4(BYTE * py, BYTE * puv, BYTE * py2, int bpr, BYTE * pm, int w) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXInt<2> full80  = {0x80808080, 0x80808080};	// 1000 0000 1000 0000 1000 0000 1000 0000
	static MMXInt<2> mask7   = {0x7f7f7f7f, 0x7f7f7f7f};	// 0111 1111 0111 1111 0111 1111 0111 1111
	static MMXInt<2> maxdiff = {0x0f0f0f0f, 0x0f0f0f0f};	// 0000 1111 0000 1111 0000 1111 0000 1111
	static MMXInt<2> zero    = {0x00000000, 0x00000000};	// 0000 0000 0000 0000 0000 0000 0000 0000
	static MMXInt<2> border  = {0x0a0a0a0a, 0x0a0a0a0a};	// 0000 1010 0000 1010 0000 1010 0000 1010

	if (w)
		{
		__asm
			{
			mov			eax,	[pm]
			mov			ebx,	[py]
			mov			edx,	[puv]
			mov			ecx,  [w]
			mov			esi,	[py2]
			mov			edi,  [bpr]

			add			esi,  edi

			movq			mm3, [esi+2*edi]
	loop1:
			prefetcht0	[esi+2*edi + 48]

			movq			mm5, [ebx]
			movq			mm0, mm5

			movq			mm4, [esi]
			psubusb		mm5, mm4
			movq			mm1, mm4

			movq			mm6, [ebx+2*edi]
			psubusb		mm4, mm6
			paddusb		mm5, mm4

			movq			mm7, [border]
			psubusb		mm5, mm7

			psubusb		mm6, mm3
			paddusb		mm6, mm4

			movq			mm2, [ebx+2*edi]
			psubusb		mm6, mm7
			pxor			mm4, mm4

			pcmpeqb		mm5, mm4
			pcmpeqb		mm6, mm4

			por			mm5, mm6
			movq			mm6, mm2

			psubusb		mm6, mm1

			psubusb		mm3, mm2
			psubusb		mm1, mm0

			paddusb		mm3, mm6
			paddusb		mm1, mm6

			movq			mm6, [esi]
			psubusb		mm3, mm7
			psubusb		mm1, mm7

			pcmpeqb		mm3, mm4
			pcmpeqb		mm1, mm4

			movq			mm4, [ebx + edi]
			por			mm5, mm3

			prefetcht0	[ebx + edi + 48]
			por			mm5, mm1

			pavgb			(mm0, mm2)

			movq			mm3, mm4
			movq			mm1, mm0

			// mm0, mm1, mm2
			pmaxub		(mm4, mm0)
			pmaxub		(mm0, mm6)
			pmaxub		(mm3, mm6)

			// mm0, mm2, mm3
			pminub		(mm3, mm0)
			pminub		(mm4, mm3)

			movq			mm3, [esi+2*edi+8]

			add			esi, 8

			add			ebx, 8

			movq			mm0, [edx]
			pand			mm4, mm5

			pandn			mm5, mm1

			por			mm5, mm4

			add			edx, 8

			movq			mm4, mm5

			punpcklbw	mm4, mm0

			movq			[eax], mm4
			punpckhbw	mm5, mm0

			movq			[eax+8], mm5

			sub			ecx, 8
			lea			eax, [eax + 16]
			jne			loop1
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8D1I4) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}




static inline void ConvertLineToYUV_P8D1I4MUV(BYTE * py, BYTE * puv, BYTE * py2, int bpr, BYTE * pm, int w) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXInt<2> full80 = {0x80808080, 0x80808080};
	static MMXInt<2> mask7 = {0x7f7f7f7f, 0x7f7f7f7f};
	static MMXInt<2> maxdiff = {0x0f0f0f0f, 0x0f0f0f0f};
	static MMXInt<2> zero = {0x00000000, 0x00000000};
	static MMXInt<2> border = {0x0a0a0a0a, 0x0a0a0a0a};

	if (w)
		{
		__asm
			{
			mov			eax,	[pm]
			mov			ebx,	[py]
			mov			edx,	[puv]
			mov			ecx,  [w]
			mov			esi,	[py2]
			mov			edi,  [bpr]

			add			esi,  edi

			movq			mm3, [esi+2*edi]
	loop1:
			prefetcht0	[esi + 2*edi + 40]
			movq			mm5, [ebx]
			movq			mm0, mm5

			movq			mm4, [esi]
			psubusb		mm5, mm4
			movq			mm1, mm4

			movq			mm6, [ebx+2*edi]
			psubusb		mm4, mm6
			paddusb		mm5, mm4

			movq			mm7, [border]
			psubusb		mm5, mm7

			psubusb		mm6, mm3
			paddusb		mm6, mm4

			movq			mm2, [ebx+2*edi]
			prefetcht0	[edx + 2*edi+48]
			psubusb		mm6, mm7
			pxor			mm4, mm4

			pcmpeqb		mm5, mm4
			pcmpeqb		mm6, mm4

			por			mm5, mm6
			movq			mm6, mm2

			psubusb		mm6, mm1

			psubusb		mm3, mm2
			psubusb		mm1, mm0

			paddusb		mm3, mm6
			paddusb		mm1, mm6

			movq			mm6, [esi]
			psubusb		mm3, mm7
			psubusb		mm1, mm7

			movq			mm7, [mask7]
			pcmpeqb		mm3, mm4
			pcmpeqb		mm1, mm4

			movq			mm4, [ebx + edi]
			por			mm5, mm3

			prefetcht0	[ebx + edi + 56]
			pavgb			(mm0, mm2)

			por			mm5, mm1

			movq			mm3, mm4
			movq			mm1, mm0


			// mm0, mm1, mm2
			pmaxub		(mm4, mm0)
			pmaxub		(mm0, mm6)
			pmaxub		(mm3, mm6)

			// mm0, mm2, mm3
			pminub		(mm3, mm0)
			pminub		(mm4, mm3)

			movq			mm3, [esi+2*edi+8]
			add			esi, 8

			add			ebx, 8

			movq			mm0, [edx]
			pand			mm4, mm5

			movq			mm6, [edx + 2 * edi]
			pandn			mm5, mm1

			por			mm5, mm4

			pavgb			(mm0, mm6)

			add			edx, 8

			movq			mm4, mm5

			punpcklbw	mm4, mm0

			movq			[eax], mm4
			punpckhbw	mm5, mm0

			movq			[eax+8], mm5

			sub			ecx, 8
			lea			eax, [eax + 16]
			jne			loop1
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8D1I4MUV) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}

static inline void ConvertLineToYUV_P8D2I4(BYTE * py, BYTE * puv, BYTE * py2, int bpr, BYTE * pm, int w) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXInt<2> full80 = {0x80808080, 0x80808080};
	static MMXInt<2> mask7 = {0x7f7f7f7f, 0x7f7f7f7f};
	static MMXInt<2> maxdiff = {0x0f0f0f0f, 0x0f0f0f0f};
	static MMXInt<2> zero = {0x00000000, 0x00000000};
	static MMXInt<2> border = {0x0a0a0a0a, 0x0a0a0a0a};
	static MMXQShort masklow = {0x00ff, 0x00ff, 0x00ff, 0x00ff};

	if (w)
		{
		__asm
			{
			mov			eax,	[pm]
			mov			ebx,	[py]
			mov			edx,	[puv]
			mov			ecx,  [w]
			mov			esi,	[py2]
			mov			edi,  [bpr]

			add			esi,  edi

			movq			mm3, [esi+2*edi]
	loop1:
			movq			mm5, [ebx]
			movq			mm0, mm5

			movq			mm4, [esi]
			psubusb		mm5, mm4
			movq			mm1, mm4

			movq			mm6, [ebx+2*edi]
			psubusb		mm4, mm6
			paddusb		mm5, mm4

			movq			mm7, [border]
			psubusb		mm5, mm7

			psubusb		mm6, mm3
			paddusb		mm6, mm4

			movq			mm2, [ebx+2*edi]
			psubusb		mm6, mm7
			pxor			mm4, mm4

			pcmpeqb		mm5, mm4
			pcmpeqb		mm6, mm4

			por			mm5, mm6
			movq			mm6, mm2

			psubusb		mm6, mm1

			psubusb		mm3, mm2
			psubusb		mm1, mm0

			paddusb		mm3, mm6
			paddusb		mm1, mm6

			movq			mm6, [esi]
			psubusb		mm3, mm7
			psubusb		mm1, mm7

			pcmpeqb		mm3, mm4
			pcmpeqb		mm1, mm4

			movq			mm4, [ebx + edi]
			por			mm5, mm3

			por			mm5, mm1

			pavgb			(mm0, mm2)

			movq			mm3, mm4

			movq			mm1, mm0


			// mm0, mm1, mm2
			pmaxub		(mm4, mm0)
			pmaxub		(mm0, mm6)
			pmaxub		(mm3, mm6)

			// mm0, mm2, mm3
			pminub		(mm3, mm0)
			pminub		(mm4, mm3)

			movq			mm3, [esi+2*edi+8]
			add			esi, 8

			add			ebx, 8

			movq			mm0, [edx]
			pand			mm4, mm5

			pandn			mm5, mm1

			por			mm5, mm4

			add			edx, 8

			movq			mm4, mm5
			pand			mm4, [masklow]
			psrlw			mm5, 8

			pavgb			(mm5, mm4)

			pxor			mm7, mm7

			pshufw		(mm1, mm0, 0xD8)
			pshufw		(mm0, mm0, 0x8D)
			pavgb			(mm1, mm0)
			punpckhbw	mm7, mm1

			por			mm5, mm7

			movq			[eax], mm5

			sub			ecx, 8
			lea			eax, [eax + 8]
			jne			loop1
			}
		}

#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8D2I4) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}

static inline void ConvertLineToYUV_P8D2I4MUV(BYTE * py, BYTE * puv, BYTE * py2, int bpr, BYTE * pm, int w) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXInt<2> full80 = {0x80808080, 0x80808080};
	static MMXInt<2> mask7 = {0x7f7f7f7f, 0x7f7f7f7f};
	static MMXInt<2> maxdiff = {0x0f0f0f0f, 0x0f0f0f0f};
	static MMXInt<2> zero = {0x00000000, 0x00000000};
	static MMXInt<2> border = {0x0a0a0a0a, 0x0a0a0a0a};
	static MMXQShort masklow = {0x00ff, 0x00ff, 0x00ff, 0x00ff};

	if (w)
		{
		__asm
			{
			mov			eax,	[pm]
			mov			ebx,	[py]
			mov			edx,	[puv]
			mov			ecx,  [w]
			mov			esi,	[py2]
			mov			edi,  [bpr]

			add			esi,  edi

			movq			mm3, [esi+2*edi]
	loop1:
			movq			mm5, [ebx]
			movq			mm0, mm5

			movq			mm4, [esi]
			psubusb		mm5, mm4
			movq			mm1, mm4

			movq			mm6, [ebx+2*edi]
			psubusb		mm4, mm6
			paddusb		mm5, mm4

			movq			mm7, [border]
			psubusb		mm5, mm7

			psubusb		mm6, mm3
			paddusb		mm6, mm4

			movq			mm2, [ebx+2*edi]
			psubusb		mm6, mm7
			pxor			mm4, mm4

			pcmpeqb		mm5, mm4
			pcmpeqb		mm6, mm4

			por			mm5, mm6
			movq			mm6, mm2

			psubusb		mm6, mm1

			psubusb		mm3, mm2
			psubusb		mm1, mm0

			paddusb		mm3, mm6
			paddusb		mm1, mm6

			movq			mm6, [esi]
			psubusb		mm3, mm7
			psubusb		mm1, mm7

			pcmpeqb		mm3, mm4
			pcmpeqb		mm1, mm4

			movq			mm4, [ebx + edi]
			por			mm5, mm3
			por			mm5, mm1

			pavgb			(mm0, mm2)

			movq			mm3, mm4

			movq			mm1, mm0


			// mm0, mm1, mm2
			pmaxub		(mm4, mm0)
			pmaxub		(mm0, mm6)
			pmaxub		(mm3, mm6)

			// mm0, mm2, mm3
			pminub		(mm3, mm0)
			pminub		(mm4, mm3)

			movq			mm3, [esi+2*edi+8]
			add			esi, 8

			add			ebx, 8

			movq			mm0, [edx]
			pand			mm4, mm5

			movq			mm2, [edx+edi]
			pandn			mm5, mm1

			por			mm5, mm4

			add			edx, 8

			movq			mm4, mm5
			pand			mm4, [masklow]
			psrlw			mm5, 8

			pavgb			(mm5, mm4)

			pxor			mm7, mm7

			pshufw		(mm1, mm0, 0xD8)
			pshufw		(mm0, mm0, 0x8D)
			pavgb			(mm1, mm0)

			pshufw		(mm0, mm2, 0xD8)
			pshufw		(mm2, mm2, 0x8D)
			pavgb			(mm0, mm2)

			pavgb			(mm1, mm0)

			punpckhbw	mm7, mm1

			por			mm5, mm7

			movq			[eax], mm5

			sub			ecx, 8
			lea			eax, [eax + 8]
			jne			loop1

			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8D2I4MUV) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}

static inline void ConvertLineToYUVThroughOSD_P8D1I4(BYTE * py, BYTE * puv, BYTE * py2, int bpr, BYTE * pm, int w, BYTE * po, DDWORD * dd) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXInt<2> full80 = {0x80808080, 0x80808080};
	static MMXInt<2> mask7 = {0x7f7f7f7f, 0x7f7f7f7f};
	static MMXInt<2> maxdiff = {0x0f0f0f0f, 0x0f0f0f0f};
	static MMXInt<2> border = {0x0a0a0a0a, 0x0a0a0a0a};
	static MMXInt<2> zero = {0x00000000, 0x00000000};

	if (w)
		{
		py2 += bpr;

		__asm
			{
			mov			ecx, 0
			mov			esi, [w]
			shr			esi, 1
			mov			edi, [py]
			mov			edx, [dd]
	loop1:
			mov			eax, [bpr]
			mov			ebx, [py2]

			movq			mm0, [edi]
			movq			mm2, [edi+2*eax]

			pavgb			(mm0, mm2)

			movq			mm1, [ebx + 2 * ecx]
			movq			mm2, [edi + eax]

			// mm0, mm1, mm2
			movq			mm3, mm2
			pmaxub		(mm2, mm0)
			pmaxub		(mm0, mm1)
			pmaxub		(mm3, mm1)

			// mm0, mm2, mm3
			pminub		(mm3, mm0)
			pminub		(mm2, mm3)

			mov			eax, [puv]
			movq			mm6, [eax + 2 * ecx]

			movq			mm4, mm2
			punpcklbw	mm4, mm6
			punpckhbw	mm2, mm6

			pxor			mm7, mm7

			movq			mm0, mm4
			punpcklbw	mm0, mm7
			punpckhbw	mm4, mm7

			movq			mm1, mm2
			punpcklbw	mm1, mm7
			punpckhbw	mm2, mm7

			mov			ebx, [po]

			movzx			eax, BYTE PTR [ebx + ecx]
			pmullw		mm0, [edx + eax * 8 + 2048]
			paddw			mm0, [edx + eax * 8]

			movzx			eax, BYTE PTR [ebx + ecx + 1]
			pmullw		mm4, [edx + eax * 8 + 2048]
			paddw			mm4, [edx + eax * 8]

			movzx			eax, BYTE PTR [ebx + ecx + 2]
			pmullw		mm1, [edx + eax * 8 + 2048]
			paddw			mm1, [edx + eax * 8]

			movzx			eax, BYTE PTR [ebx + ecx + 3]
			pmullw		mm2, [edx + eax * 8 + 2048]
			paddw			mm2, [edx + eax * 8]

			psrlw			mm0, 4
			psrlw			mm4, 4
			psrlw			mm1, 4
			psrlw			mm2, 4

			packuswb		mm0, mm4
			packuswb		mm1, mm2

			mov			eax, [pm]
			movq			[eax + 4 * ecx], mm0
			movq			[eax + 4 * ecx + 8], mm1

			add			edi, 8
			add			ecx, 4
			cmp			ecx, esi
			jne			loop1
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT ThroughOSD_P8D1I4) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}

static inline void ConvertLineToYUVThroughOSD_P8D1I4MUV(BYTE * py, BYTE * puv, BYTE * py2, int bpr, BYTE * pm, int w, BYTE * po, DDWORD * dd) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXInt<2> full80 = {0x80808080, 0x80808080};
	static MMXInt<2> mask7 = {0x7f7f7f7f, 0x7f7f7f7f};
	static MMXInt<2> maxdiff = {0x0f0f0f0f, 0x0f0f0f0f};
	static MMXInt<2> border = {0x0a0a0a0a, 0x0a0a0a0a};
	static MMXInt<2> zero = {0x00000000, 0x00000000};

	if (w)
		{
		py2 += bpr;

		__asm
			{
			mov			ecx, 0
			mov			esi, [w]
			shr			esi, 1
			mov			edi, [py]
			mov			edx, [dd]
	loop1:
			mov			eax, [bpr]
			mov			ebx, [py2]

			movq			mm0, [edi]
			movq			mm2, [edi+2*eax]

			pavgb			(mm0, mm2)

			movq			mm1, [ebx + 2 * ecx]
			movq			mm2, [edi + eax]

			// mm0, mm1, mm2
			movq			mm3, mm2
			pmaxub		(mm2, mm0)
			pmaxub		(mm0, mm1)
			pmaxub		(mm3, mm1)

			// mm0, mm2, mm3
			pminub		(mm3, mm0)
			pminub		(mm2, mm3)

			mov			ebx, [puv]
			movq			mm6, [ebx + 2 * ecx]
			lea			ebx, [ebx + 2 * eax]
			movq			mm5, [ebx + 2 * ecx]

			pavgb			(mm6, mm5)

			movq			mm4, mm2
			punpcklbw	mm4, mm6
			punpckhbw	mm2, mm6

			pxor			mm7, mm7

			movq			mm0, mm4
			punpcklbw	mm0, mm7
			punpckhbw	mm4, mm7

			movq			mm1, mm2
			punpcklbw	mm1, mm7
			punpckhbw	mm2, mm7

			mov			ebx, [po]

			movzx			eax, BYTE PTR [ebx + ecx]
			pmullw		mm0, [edx + eax * 8 + 2048]
			paddw			mm0, [edx + eax * 8]

			movzx			eax, BYTE PTR [ebx + ecx + 1]
			pmullw		mm4, [edx + eax * 8 + 2048]
			paddw			mm4, [edx + eax * 8]

			movzx			eax, BYTE PTR [ebx + ecx + 2]
			pmullw		mm1, [edx + eax * 8 + 2048]
			paddw			mm1, [edx + eax * 8]

			movzx			eax, BYTE PTR [ebx + ecx + 3]
			pmullw		mm2, [edx + eax * 8 + 2048]
			paddw			mm2, [edx + eax * 8]

			psrlw			mm0, 4
			psrlw			mm4, 4
			psrlw			mm1, 4
			psrlw			mm2, 4

			packuswb		mm0, mm4
			packuswb		mm1, mm2

			mov			eax, [pm]
			movq			[eax + 4 * ecx], mm0
			movq			[eax + 4 * ecx + 8], mm1

			add			edi, 8
			add			ecx, 4
			cmp			ecx, esi
			jne			loop1
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT ThroughOSD_P8D1I4MUV) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}


static inline void ConvertLineToYUVThroughOSD_P8D2I4(BYTE * py, BYTE * puv, BYTE * py2, int bpr, BYTE * pm, int w, BYTE * po, DDWORD * dd) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXInt<2> full80 = {0x80808080, 0x80808080};
	static MMXInt<2> mask7 = {0x7f7f7f7f, 0x7f7f7f7f};
	static MMXInt<2> maxdiff = {0x0f0f0f0f, 0x0f0f0f0f};
	static MMXInt<2> border = {0x0a0a0a0a, 0x0a0a0a0a};
	static MMXInt<2> zero = {0x00000000, 0x00000000};
	static MMXQShort masklow = {0x00ff, 0x00ff, 0x00ff, 0x00ff};

	if (w)
		{
		py2 += bpr;

		__asm
			{
			mov			ecx, 0
			mov			esi, [w]
			shr			esi, 1
			mov			edi, [py]
			mov			edx, [dd]
	loop1:
			mov			eax, [bpr]
			mov			ebx, [py2]

			movq			mm0, [edi]
			movq			mm2, [edi+2*eax]

			pavgb			(mm0, mm2)

			movq			mm1, [ebx + 2 * ecx]
			movq			mm2, [edi + eax]

			// mm0, mm1, mm2
			movq			mm3, mm2
			pmaxub		(mm2, mm0)
			pmaxub		(mm0, mm1)
			pmaxub		(mm3, mm1)

			// mm0, mm2, mm3
			pminub		(mm3, mm0)
			pminub		(mm2, mm3)

//////////////
			mov			eax, [puv]
			movq			mm6, [eax + 2 * ecx]


			movq			mm4, mm2
			pand			mm4, [masklow]
			psrlw			mm2, 8
			pavgb			(mm2, mm4)

			pxor			mm7, mm7


			pshufw		(mm1, mm6, 0xB1)
			pavgb			(mm1, mm6)
			pshufw		(mm1, mm1, 0xD0)
			punpckhbw	mm1, mm7
			psllw			mm1, 8


			por			mm2, mm1

//////////////

			pxor			mm0, mm0

			movq			mm1, mm2
			punpcklbw	mm2, mm0
			punpckhbw	mm1, mm0

			mov			ebx, [po]

			movzx			eax, BYTE PTR [ebx + ecx]
			movq			mm3, [edx + eax * 8 + 2048 + 4096]
			movq			mm4, [edx + eax * 8 + 4096]
			movzx			eax, BYTE PTR [ebx + ecx+1]
			paddw			mm3, [edx + eax * 8 + 2048 + 8192]
			paddw			mm4, [edx + eax * 8 + 8192]

			pmullw		mm2, mm3

			paddw			mm2, mm4

			movzx			eax, BYTE PTR [ebx + ecx + 2]
			movq			mm3, [edx + eax * 8 + 2048 + 4096]
			movq			mm4, [edx + eax * 8 + 4096]
			movzx			eax, BYTE PTR [ebx + ecx + 3]
			paddw			mm3, [edx + eax * 8 + 2048 + 8192]
			paddw			mm4, [edx + eax * 8 + 8192]

			pmullw		mm1, mm3

			paddw			mm1, mm4

			psrlw			mm2, 5

			psrlw			mm1, 5

			packuswb		mm2, mm1

			mov			eax, [pm]
			movq			[eax + 2 * ecx], mm2

			add			edi, 8
			add			ecx, 4
			cmp			ecx, esi
			jne			loop1
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT ThroughOSD_P8D2I4) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}



static inline void ConvertLineToYUV_P8D1M(BYTE * py, BYTE * puv, BYTE * ppy, BYTE * ppuv, BYTE * pm, int w) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXInt<2> round = {0x00010001, 0x00010001};

	if (w)
		{
		__asm
			{
			mov			eax,	[pm]
			mov			ebx,	[py]
			mov			edx,	[puv]
			mov			ecx,  [w]
			mov			esi,	[ppy]
			mov			edi,	[ppuv]

			lea			eax, [eax+2*ecx]
			add			ebx, ecx
			add			edx, ecx
			add			esi, ecx
			add			edi, ecx
			neg			ecx

			pxor			mm6, mm6

	loop2:

			movq			mm0, [ebx+ecx]
			movq			mm2, [esi+ecx]

			pavgb			(mm0, mm2)

			movq			mm2, mm0

			movq			mm1, [edx+ecx]
			movq			mm3, [edi+ecx]

			pavgb			(mm1, mm3)

			punpcklbw	mm0, mm1

			punpckhbw	mm2, mm1

			movq			[eax+2*ecx], mm0

			movq			[eax+2*ecx+8], mm2

			add			ecx, 8

			jnc			loop2
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8D1M) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}

static inline void ConvertLineToYUVThroughOSD_P8D1M(BYTE * py, BYTE * puv, BYTE * ppy, BYTE * ppuv, BYTE * pm, int w, BYTE * po, DDWORD * dd) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	if (w)
		{
		__asm
			{
			mov			ecx, 0
			mov			edi, [w]
			shr			edi, 1
			mov			edx, [dd]
			mov			esi, [po]

			pxor			mm6, mm6

	loop2:
			mov			eax, [py]
			mov			ebx, [puv]

			movq			mm0, [eax + 2 * ecx]
			movq			mm2, [ebx + 2 * ecx]
			movq			mm1, mm0
			punpcklbw	mm0, mm2
			punpckhbw	mm1, mm2

			mov			eax, [ppy]
			mov			ebx, [ppuv]

			movq			mm2, [eax + 2 * ecx]
			movq			mm4, [ebx + 2 * ecx]
			movq			mm3, mm2
			punpcklbw	mm2, mm4
			punpckhbw	mm3, mm4


			movq			mm4, mm0
			movq			mm5, mm2
			punpcklbw	mm0, mm6
			punpcklbw	mm2, mm6
			pavgb			(mm0, mm2)

			movzx			eax, BYTE PTR [esi + ecx]
			pmullw		mm0, [edx + eax * 8 + 2048]
			paddw			mm0, [edx + eax * 8]

			punpckhbw	mm4, mm6
			punpckhbw	mm5, mm6
			pavgb			(mm4, mm5)

			movzx			eax, BYTE PTR [esi + ecx + 1]
			pmullw		mm4, [edx + eax * 8 + 2048]
			paddw			mm4, [edx + eax * 8]

			movq			mm2, mm1
			movq			mm5, mm3
			punpcklbw	mm1, mm6
			punpcklbw	mm3, mm6
			pavgb			(mm1, mm3)

			movzx			eax, BYTE PTR [esi + ecx + 2]
			pmullw		mm1, [edx + eax * 8 + 2048]
			paddw			mm1, [edx + eax * 8]

			punpckhbw	mm2, mm6
			punpckhbw	mm5, mm6
			pavgb			(mm2, mm5)

			// order is mm0, mm4, mm1, mm3

			movzx			eax, BYTE PTR [esi + ecx + 3]
			pmullw		mm2, [edx + eax * 8 + 2048]
			paddw			mm2, [edx + eax * 8]

			psrlw			mm0, 4
			psrlw			mm4, 4
			psrlw			mm1, 4
			psrlw			mm2, 4

			packuswb		mm0, mm4
			packuswb		mm1, mm2

			mov			eax, [pm]

			movq			[eax + 4 * ecx], mm0

			movq			[eax + 4 * ecx+8], mm1

			add			ecx, 4
			cmp			ecx, edi
			jne			loop2
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT ThroughOSD_P8D1M) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}


static inline void ConvertLineToYUV_P8D2M(BYTE * py, BYTE * puv, BYTE * ppy, BYTE * ppuv, BYTE * pm, int w) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXQShort masklow = {0x00ff, 0x00ff, 0x00ff, 0x00ff};
	static MMXInt<2> round = {0x00020002, 0x00020002};

	if (w)
		{
		__asm
			{
			mov			eax, [pm]

			mov			ebx, [py]
			mov			edx, [puv]

			mov			esi, [ppy]
			mov			edi, [ppuv]

			mov			ecx, [w]

			movq			mm6, [masklow]
			pxor			mm7, mm7

	loop2:

			/////////////////////////////////////////////////////////////////
			movq			mm0, [ebx]			//	py7 py6 py5 py4 py3 py2 py1 py0
			movq			mm4, [esi]			// pp7 pp6 pp5 pp4 pp3 pp2 pp1 pp0
			movq			mm1, [edx]			// uv7 uv6 uv5 uv4 uv3 uv2 uv1 uv0
			movq			mm2, [edi]			// pv7 pv6 pv5 pv4 pv3 pv2 pv1 pv0

			/////////////////////////////////////////////////////////////////
			movq			mm3, mm0				//	py7 py6 py5 py4 py3 py2 py1 py0
			pand			mm3, mm6				//	    py6     py4     py2     py0
			psrlw			mm0, 8				//	    py7     py5     py3     py1
			pavgb			(mm0, mm3)

			movq			mm3, mm4				// pp7 pp6 pp5 pp4 pp3 pp2 pp1 pp0
			pand			mm3, mm6				//     pp6     pp4     pp2     pp0
			psrlw			mm4, 8				//     pp7     pp5     pp3     pp1
			pavgb			(mm4, mm3)

			pavgb			(mm0, mm4)
			/////////////////////////////////////////////////////////////////

													// uv7 uv6 uv5 uv4 uv3 uv2 uv1 uv0 (mm1)
			pshufw		(mm3, mm1, 0xB1)	// uv5 uv4 uv7 uv6 uv1 uv0 uv3 uv2
			pavgb			(mm1, mm3)			// u75 u64 u57 u46 u31 u20 u13 u02
			pshufw		(mm1, mm1, 0xD0)	// u75 u64 u31 u20 xxx xxx xxx xxx
			punpckhbw	mm1, mm7				//     u75     u64     u31     u20


			pshufw		(mm3, mm2, 0xB1)
			pavgb			(mm2, mm3)
			pshufw		(mm2, mm2, 0xD0)
			punpckhbw	mm2, mm7

			pavgb			(mm1, mm2)

			psllw			mm1, 8

			por			mm0, mm1

			movq			[eax], mm0

			add			ebx, 8
			add			edx, 8
			add			eax, 8
			add			esi, 8
			add			edi, 8
			sub			ecx, 8
			jne			loop2
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8D2M) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}

static inline void ConvertLineToYUVThroughOSD_P8D2M(BYTE * py, BYTE * puv, BYTE * ppy, BYTE * ppuv, BYTE * pm, int w, BYTE * po, DDWORD * dd) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXQShort masklow = {0x00ff, 0x00ff, 0x00ff, 0x00ff};
	static MMXInt<2> round = {0x00020002, 0x00020002};

	if (w)
		{
		__asm
			{
			mov			eax, [pm]
			mov			esi, [po]

			mov			ebx, [py]
			mov			edx, [ppy]

			xor			ecx, ecx

			movq			mm6, [masklow]
			movq			mm5, [round]
			pxor			mm7, mm7

	loop2:
			movq			mm0, [ebx+ecx]

			movq			mm4, [edx+ecx]

			movq			mm3, mm0
			pand			mm3, mm6
			psrlw			mm0, 8
			pavgb			(mm0, mm3)

			mov			edi, [puv]
			movq			mm1, [edi+ecx]

			mov			edi, [ppuv]
			movq			mm2, [edi+ecx]

			movq			mm3, mm4
			pand			mm3, mm6
			psrlw			mm4, 8
			pavgb			(mm4, mm3)

			pavgb			(mm0, mm4)


			pshufw		(mm3, mm1, 0xB1)
			pavgb			(mm1, mm3)
			pshufw		(mm1, mm1, 0xD0)
			punpckhbw	mm1, mm7


			pshufw		(mm3, mm2, 0xB1)
			pavgb			(mm2, mm3)
			pshufw		(mm2, mm2, 0xD0)
			punpckhbw	mm2, mm7


			pavgb			(mm1, mm2)
			psllw			mm1, 8

			por			mm0, mm1

			movq			mm1, mm0
			punpcklbw	mm0, mm7
			punpckhbw	mm1, mm7

			mov			edi, [dd]

			movzx			eax, BYTE PTR [esi]
			movq			mm3, [edi + eax * 8 + 2048 + 4096]
			movq			mm4, [edi + eax * 8 + 4096]
			movzx			eax, BYTE PTR [esi+1]
			paddw			mm3, [edi + eax * 8 + 2048 + 8192]
			paddw			mm4, [edi + eax * 8 + 8192]

			pmullw		mm0, mm3

			paddw			mm0, mm4

			movzx			eax, BYTE PTR [esi + 2]
			movq			mm3, [edi + eax * 8 + 2048 + 4096]
			movq			mm4, [edi + eax * 8 + 4096]
			movzx			eax, BYTE PTR [esi + 3]
			paddw			mm3, [edi + eax * 8 + 2048 + 8192]
			paddw			mm4, [edi + eax * 8 + 8192]

			pmullw		mm1, mm3

			paddw			mm1, mm4

			psrlw			mm0, 5

			psrlw			mm1, 5

			packuswb		mm0, mm1


			mov			edi, [pm]
			movq			[edi+ecx], mm0

			add			esi, 4
			add			ecx, 8
			cmp			ecx, [w]
			jne			loop2
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT ThroughOSD_P8D2M) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}


static inline void ConvertLineToYUVThroughOSD_P8D1MV(BYTE * py, BYTE * puv, int bpr, BYTE * pm, int w, BYTE * po, DDWORD * dd) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	if (w)
		{
		BYTE * final = py + w;

		__asm
			{
			mov			esi,	[pm]
			mov			ebx,	[py]
			mov			edx,	[puv]
			mov			edi,  [dd]
			mov			ecx,  [po]

			pxor			mm7, mm7

	loop2:
			mov			eax,	[bpr]

			movq			mm0, [ebx]
			movq			mm1, [ebx + eax]
			movq			mm2, [ebx + 2 * eax]
			pavgb			(mm0, mm2)
			pavgb			(mm1, mm0)
			movq			mm0, mm1
			punpcklbw	mm0, mm7
			punpckhbw	mm1, mm7

			movq			mm4, [edx]
			movq			mm5, [edx + eax]
			movq			mm6, [edx + 2 * eax]
			pavgb			(mm4, mm6)
			pavgb			(mm5, mm4)
			movq			mm4, mm5
			punpcklbw	mm4, mm7
			punpckhbw	mm5, mm7

			movq			mm2, mm0
			movq			mm3, mm1
			punpcklwd	mm0, mm4
			punpckhwd	mm2, mm4
			punpcklwd	mm1, mm5
			punpckhwd	mm3, mm5

			movzx			eax, BYTE PTR [ecx]
			pmullw		mm0, [edi + eax * 8 + 2048]
			paddw			mm0, [edi + eax * 8]

			movzx			eax, BYTE PTR [ecx + 1]
			pmullw		mm2, [edi + eax * 8 + 2048]
			paddw			mm2, [edi + eax * 8]

			movzx			eax, BYTE PTR [ecx + 2]
			pmullw		mm1, [edi + eax * 8 + 2048]
			paddw			mm1, [edi + eax * 8]

			movzx			eax, BYTE PTR [ecx + 3]
			pmullw		mm3, [edi + eax * 8 + 2048]
			paddw			mm3, [edi + eax * 8]

			psrlw			mm0, 4
			psrlw			mm2, 4
			psrlw			mm1, 4
			psrlw			mm3, 4

			packuswb		mm0, mm2
			packuswb		mm1, mm3

			movq			[esi], mm0
			movq			[esi+8], mm1

			add			esi, 16
			add			ebx, 8
			add			edx, 8
			add			ecx, 4
			cmp			ebx, [final]
			jne			loop2
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT ThroughOSD_P8D1MV) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}


// new       -> 01/26/2000
// optimized -> 02/09/2000
static inline void ConvertLineToYUVThroughOSD_P8D1MV(BYTE * py0, BYTE * puv0, BYTE * py1, BYTE * puv1, BYTE * py2, BYTE * puv2, BYTE * pm, int w, BYTE * po, DDWORD * dd)
	{
	if (w)
		{
		__asm
			{
			xor			ecx, ecx
			mov			ebx, [po]
			mov			edx, [pm]

			pxor			mm7, mm7

	loop2:
			mov			esi, [py0]
			mov			edi, [py1]
			mov			eax, [py2]

			movq			mm0, [edi+ecx]
			movq			mm1, [esi+ecx]
			movq			mm2, [eax+ecx]
			pavgb			(mm1, mm2)
			pavgb			(mm0, mm1)

			mov			esi, [puv0]
			mov			edi, [puv1]
			mov			eax, [puv2]

			movq			mm4, [edi+ecx]
			movq			mm5, [esi+ecx]
			movq			mm6, [eax+ecx]
			pavgb			(mm5, mm6)
			pavgb			(mm4, mm5)

			movq			mm1, mm0
			punpcklbw	mm0, mm4
			punpckhbw	mm1, mm4
			movq			mm2, mm0
			punpcklbw	mm0, mm7
			punpckhbw	mm2, mm7
			movq			mm3, mm1
			punpcklbw	mm1, mm7
			punpckhbw	mm3, mm7

			mov			edi, [dd]

			movzx			eax, BYTE PTR [ebx]
			pmullw		mm0, [edi + eax * 8 + 2048]
			paddw			mm0, [edi + eax * 8]

			movzx			eax, BYTE PTR [ebx + 1]
			pmullw		mm2, [edi + eax * 8 + 2048]
			paddw			mm2, [edi + eax * 8]

			movzx			eax, BYTE PTR [ebx + 2]
			pmullw		mm1, [edi + eax * 8 + 2048]
			paddw			mm1, [edi + eax * 8]

			movzx			eax, BYTE PTR [ebx + 3]
			pmullw		mm3, [edi + eax * 8 + 2048]
			paddw			mm3, [edi + eax * 8]

			psrlw			mm0, 4
			psrlw			mm2, 4
			psrlw			mm1, 4
			psrlw			mm3, 4

			packuswb		mm0, mm2
			packuswb		mm1, mm3

			movq			[edx], mm0
			movq			[edx+8], mm1

			add			edx, 16
			add			ebx, 4
			add			ecx, 8
			cmp			ecx, [w]
			jne			loop2
			}
		}

	}
// <- optimized 02/09/2000
// <- new       01/26/2000

static inline void ConvertLineToYUV_P8D1MV(BYTE * py, BYTE * puv, int bpr, BYTE * pm, int w) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	if (w)
		{
		__asm
			{
			mov			eax,	[pm]
			mov			ebx,	[py]
			mov			edx,	[puv]
			mov			ecx,  [w]
			mov			esi,	[bpr]

			pxor			mm6, mm6

	loop2:

			movq			mm1, [ebx]
			movq			mm0, [ebx + esi]
			movq			mm2, [ebx + 2 * esi]
			pavgb			(mm1, mm2)
			pavgb			(mm0, mm1)

			movq			mm1, [edx]
			movq			mm4, [edx + esi]
			movq			mm7, [edx + 2 * esi]
			pavgb			(mm1, mm7)
			pavgb			(mm4, mm1)

			movq			mm1, mm0
			punpcklbw	mm0, mm4
			punpckhbw	mm1, mm4

			movq			[eax], mm0
			movq			[eax+8], mm1

			add			eax, 16
			add			ebx, 8
			add			edx, 8
			sub			ecx, 8
			jne			loop2
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8D1MV) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}


// new        -> 01/26/2000
// optimized  -> 02/09/2000
static inline void ConvertLineToYUV_P8D1MV(BYTE * py0, BYTE * puv0, BYTE * py1, BYTE * puv1, BYTE * py2, BYTE * puv2, BYTE * pm, int w)
	{
	if (w)
		{
		__asm
			{
			xor			ebx,	ebx
			mov			eax,	[pm]

			pxor			mm6, mm6

	loop2:
			mov			esi, [py0]
			mov			edi, [py1]
			mov			edx, [py2]

			movq			mm0, [edi + ebx]
			movq			mm1, [esi + ebx]
			movq			mm2, [edx + ebx]
			pavgb			(mm1, mm2)
			pavgb			(mm0, mm1)

			mov			esi, [puv0]
			mov			edi, [puv1]
			mov			edx, [puv2]

			movq			mm4, [edi + ebx]
			movq			mm5, [esi + ebx]
			movq			mm6, [edx + ebx]
			pavgb			(mm5, mm6)
			pavgb			(mm4, mm5)

			movq			mm1, mm0
			punpcklbw	mm0, mm4
			punpckhbw	mm1, mm4

			movq			[eax+2*ebx], mm0
			movq			[eax+2*ebx+8], mm1

			add			ebx, 8
			cmp			ebx, [w]
			jne			loop2
			}
		}

	}
// <- optimized 02/09/2000
// <- new 01/26/2000

static inline void ConvertLineToYUVThroughOSD_P8D2MV(BYTE * py, BYTE * puv, int bpr, BYTE * pm, int w, BYTE * po, DDWORD * dd) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXQShort masklow = {0x00ff, 0x00ff, 0x00ff, 0x00ff};

	if (w)
		{
		BYTE * final = py + w;

		__asm
			{
			mov			esi,	[pm]
			mov			ebx,	[py]
			mov			edx,	[puv]
			mov			edi,  [dd]
			mov			ecx,  [po]

			pxor			mm7, mm7
			movq			mm6, [masklow]

	loop2:
			mov			eax,	[bpr]

			movq			mm1, [ebx]
			movq			mm0, [ebx + eax]
			movq			mm2, [ebx + 2 * eax]
			pavgb			(mm1, mm2)
			pavgb			(mm0, mm1)

			movq			mm5, [edx]
			movq			mm4, [edx + eax]
			movq			mm3, [edx + 2 * eax]
			pavgb			(mm5, mm3)
			pavgb			(mm4, mm5)

			movq			mm1, mm0
			pand			mm1, mm6
			psrlw			mm0, 8
			pavgb			(mm0, mm1)

			punpckldq	mm1, mm4
			punpckhwd	mm1, mm4

			movq			mm2, mm1
			punpcklbw	mm1, mm7
			punpckhbw	mm2, mm7
			pavgb			(mm1, mm2)

			psllw			mm1, 8

			por			mm0, mm1

//////////////

			movq			mm1, mm0
			punpcklbw	mm0, mm7
			punpckhbw	mm1, mm7

			movzx			eax, BYTE PTR [ecx]
			movq			mm3, [edi + eax * 8 + 2048 + 4096]
			movq			mm4, [edi + eax * 8 + 4096]
			movzx			eax, BYTE PTR [ecx+1]
			paddw			mm3, [edi + eax * 8 + 2048 + 8192]
			paddw			mm4, [edi + eax * 8 + 8192]

			pmullw		mm0, mm3

			paddw			mm0, mm4

			movzx			eax, BYTE PTR [ecx + 2]
			movq			mm3, [edi + eax * 8 + 2048 + 4096]
			movq			mm4, [edi + eax * 8 + 4096]
			movzx			eax, BYTE PTR [ecx + 3]
			paddw			mm3, [edi + eax * 8 + 2048 + 8192]
			paddw			mm4, [edi + eax * 8 + 8192]

			pmullw		mm1, mm3

			paddw			mm1, mm4

			psrlw			mm0, 5

			psrlw			mm1, 5

			packuswb		mm0, mm1


			movq			[esi], mm0

			add			esi, 8
			add			ebx, 8
			add			edx, 8
			add			ecx, 4
			cmp			ebx, [final]
			jne			loop2
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT ThroughOSD_P8D2MV) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}

// new        -> 01/26/2000
// optimized  -> 02/09/2000
static inline void ConvertLineToYUVThroughOSD_P8D2MV(BYTE * py0, BYTE * puv0, BYTE * py1, BYTE * puv1, BYTE * py2, BYTE * puv2, BYTE * pm, int w, BYTE * po, DDWORD * dd)
	{
	static MMXQShort masklow = {0x00ff, 0x00ff, 0x00ff, 0x00ff};

	if (w)
		{
		__asm
			{
			xor			ecx, ecx
			mov			ebx, [po]
			mov			edx, [pm]

			pxor			mm7, mm7
			movq			mm6, [masklow]

	loop2:
			mov			esi, [py0]
			mov			edi, [py1]
			mov			eax, [py2]

			movq			mm0, [edi+ecx]
			movq			mm1, [esi+ecx]
			movq			mm2, [eax+ecx]
			pavgb			(mm1, mm2)
			pavgb			(mm0, mm1)

			mov			esi, [puv0]
			mov			edi, [puv1]
			mov			eax, [puv2]

			movq			mm4, [edi+ecx]
			movq			mm5, [esi+ecx]
			movq			mm3, [eax+ecx]
			pavgb			(mm5, mm3)
			pavgb			(mm4, mm5)

			movq			mm1, mm0
			pand			mm1, mm6
			psrlw			mm0, 8
			pavgb			(mm0, mm1)

			punpckldq	mm1, mm4
			punpckhwd	mm1, mm4

			movq			mm2, mm1
			punpcklbw	mm1, mm7
			punpckhbw	mm2, mm7
			pavgb			(mm1, mm2)

			psllw			mm1, 8

			por			mm0, mm1

//////////////

			movq			mm1, mm0
			punpcklbw	mm0, mm7
			punpckhbw	mm1, mm7
			mov			edi, [dd]

			movzx			eax, BYTE PTR [ebx]
			movq			mm3, [edi + eax * 8 + 2048 + 4096]
			movq			mm4, [edi + eax * 8 + 4096]
			movzx			eax, BYTE PTR [ebx+1]
			paddw			mm3, [edi + eax * 8 + 2048 + 8192]
			paddw			mm4, [edi + eax * 8 + 8192]

			pmullw		mm0, mm3

			paddw			mm0, mm4

			movzx			eax, BYTE PTR [ebx + 2]
			movq			mm3, [edi + eax * 8 + 2048 + 4096]
			movq			mm4, [edi + eax * 8 + 4096]
			movzx			eax, BYTE PTR [ebx + 3]
			paddw			mm3, [edi + eax * 8 + 2048 + 8192]
			paddw			mm4, [edi + eax * 8 + 8192]

			pmullw		mm1, mm3

			paddw			mm1, mm4

			psrlw			mm0, 5

			psrlw			mm1, 5

			packuswb		mm0, mm1


			movq			[edx], mm0

			add			edx, 8
			add			ebx, 4
			add			ecx, 8
			cmp			ecx, [w]
			jne			loop2

			}
		}
	}
// <- optimized 02/09/2000
// <- new       01/26/2000


static inline void ConvertLineToYUV_P8D2MV(BYTE * py, BYTE * puv, int bpr, BYTE * pm, int w) // XMMX
	{
#if MEASURE_DEINTERLACE_TIME
	static __int64 dctSumTime;
	static bool initial = true;
	static int dctCount;
	__int64 t3, t4;

	ReadPerformanceCounter(t3);
#endif
	static MMXQShort masklow = {0x00ff, 0x00ff, 0x00ff, 0x00ff};

	if (w)
		{
		__asm
			{
			mov			eax,	[pm]
			mov			ebx,	[py]
			mov			edx,	[puv]
			mov			ecx,  [w]
			mov			esi,	[bpr]

			movq			mm7, [masklow]
			pxor			mm6, mm6

	loop2:

			movq			mm1, [ebx]
			movq			mm0, [ebx + esi]
			movq			mm2, [ebx + 2 * esi]
			pavgb			(mm1, mm2)
			pavgb			(mm0, mm1)

			movq			mm5, [edx]
			movq			mm4, [edx + esi]
			movq			mm3, [edx + 2 * esi]
			pavgb			(mm5, mm3)
			pavgb			(mm4, mm5)

			movq			mm1, mm0
			pand			mm1, mm7
			psrlw			mm0, 8
			pavgb			(mm0, mm1)

			punpckldq	mm1, mm4
			punpckhwd	mm1, mm4

			movq			mm2, mm1
			punpcklbw	mm1, mm6
			punpckhbw	mm2, mm6
			pavgb			(mm1, mm2)

			psllw			mm1, 8

			por			mm0, mm1

			movq			[eax], mm0

			add			eax, 8
			add			ebx, 8
			add			edx, 8
			sub			ecx, 8
			jne			loop2
			}
		}
#if MEASURE_DEINTERLACE_TIME
		ReadPerformanceCounter(t4);

		dctSumTime += t4 - t3;
		dctCount++;

		if (!(dctCount & 65535))
			{
			if (initial)
				{
				dctSumTime = 0;
				dctCount = 0;
				initial = false;
				}
			else
				{
				char buffer[100];
				wsprintf(buffer, "(OPT P8D2MV) SCALE %8d : %d.%02d\n", dctCount, (int)(dctSumTime / dctCount), (int)(100 * dctSumTime / dctCount % 100));
				OutputDebugString(buffer);
				}
			}
#endif
	}

// new        -> 01/26/2000
// optimized  -> 02/09/2000
static inline void ConvertLineToYUV_P8D2MV(BYTE * py0, BYTE * puv0, BYTE * py1, BYTE * puv1, BYTE * py2, BYTE * puv2, BYTE * pm, int w)
	{
	static MMXQShort masklow = {0x00ff, 0x00ff, 0x00ff, 0x00ff};

	if (w)
		{
		__asm
			{
			xor			ebx,	ebx
			mov			eax,	[pm]

			movq			mm7, [masklow]
			pxor			mm6, mm6

	loop2:
			mov			esi, [py0]
			mov			edi, [py1]
			mov			edx, [py2]

			movq			mm0, [edi+ebx]
			movq			mm1, [esi+ebx]
			movq			mm2, [edx+ebx]
			pavgb			(mm1, mm2)
			pavgb			(mm0, mm1)

			mov			esi, [puv0]
			mov			edi, [puv1]
			mov			edx, [puv2]


			movq			mm4, [edi + ebx]
			movq			mm5, [esi + ebx]
			movq			mm3, [edx + ebx]
			pavgb			(mm5, mm3)
			pavgb			(mm4, mm5)


			movq			mm1, mm0
			pand			mm1, mm7
			psrlw			mm0, 8
			pavgb			(mm0, mm1)

			punpckldq	mm1, mm4
			punpckhwd	mm1, mm4

			movq			mm2, mm1
			punpcklbw	mm1, mm6
			punpckhbw	mm2, mm6
			pavgb			(mm1, mm2)
			psllw			mm1, 8

			por			mm0, mm1

			movq			[eax+ebx], mm0

			add			ebx, 8
			cmp			ebx, [w]
			jne			loop2
			}

		}
	}
// <- optimized 02/09/2000
// <- new       01/26/2000

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// NON XMMX optimized  YUV converter routines
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
// seven bit conversion routines
//

static inline void ConvertLineToYUV_P7D1(BYTE * py, BYTE * puv, BYTE * pm, int w)
	{
	if (w)
		{
		__asm
			{
			mov			eax,	[pm]
			mov			ebx,	[py]
			mov			edx,	[puv]
			mov			ecx,  [w]

			lea			eax, [eax+2*ecx]
			add			ebx, ecx
			add			edx, ecx
			neg			ecx

			movq			mm0, [ebx+ecx]

			movq			mm1, [edx+ecx]
			psllq			mm0, 1

			psllq			mm1, 1
			add			ecx, 8
			je				done2
	loop2:
			movq			mm2, mm0
			punpcklbw	mm0, mm1

			movq			mm3, [ebx+ecx]
			punpckhbw	mm2, mm1

			movq			[eax+2*ecx-16], mm0
			movq			mm0, mm3

			movq			mm1, [edx+ecx]
			psllq			mm0, 1

			movq			[eax+2*ecx-8], mm2
			psllq			mm1, 1

			add			ecx, 8
			jne			loop2
	done2:
			movq			mm2, mm0
			punpcklbw	mm0, mm1

			movq			[eax+2*ecx-16], mm0
			punpckhbw	mm2, mm1

			movq			[eax+2*ecx-8], mm2
			}
		}
	}

static inline void ConvertLineToYUVThroughOSD_P7D1(BYTE * py, BYTE * puv, BYTE * pm, int w,
																	BYTE * po, DDWORD * dd)
	{
	__asm
		{
		mov			esi, [pm]
		mov			ebx, [py]
		mov			edx, [puv]
		mov			ecx, [w]
		mov			edi, [po]

		push			ebp
		mov			ebp, [dd]

		shr			ecx, 1

		lea			esi, [esi+4*ecx]
		lea			ebx, [ebx+2*ecx]
		lea			edx, [edx+2*ecx]
		lea			edi, [edi+ecx]
		neg			ecx

		pxor			mm7, mm7
loop2:
		movq			mm0, [ebx+2*ecx]

		movq			mm1, [edx+2*ecx]
		psllq			mm0, 1

		psllq			mm1, 1
		movq			mm2, mm0

		punpcklbw	mm0, mm1
		xor			eax, eax

		punpckhbw	mm2, mm1
		mov			al, [edi+ecx]

		movq			mm1, mm0
		punpcklbw	mm0, mm7

		pmullw		mm0, [ebp + eax * 8 + 2048]
		punpckhbw	mm1, mm7

		movq			mm4, [ebp + eax * 8]
		movq			mm3, mm2

		punpcklbw	mm2, mm7
		xor			eax, eax

		paddw			mm0, mm4
		mov			al, [edi+ecx+1]

		punpckhbw	mm3, mm7
		psrlw			mm0, 4

		pmullw		mm1, [ebp + eax * 8 + 2048]

		movq			mm5, [ebp + eax * 8]
		//

		xor			eax, eax
		//

		paddw			mm1, mm5
		mov			al, [edi+ecx+2]

		psrlw			mm1, 4
		//

		pmullw		mm2, [ebp + eax * 8 + 2048]
		packuswb		mm0, mm1

		movq			mm5, [ebp + eax * 8]
		//

		movq			[esi+4*ecx], mm0
		//

		paddw			mm2, mm5
		xor			eax, eax

		mov			al, [edi+ecx+3]

		pmullw		mm3, [ebp + eax * 8 + 2048]

		paddw			mm3, [ebp + eax * 8]
		psrlw			mm2, 4

		psrlw			mm3, 4

		packuswb		mm2, mm3

		movq			[esi+4*ecx+8], mm2

		add			ecx, 4
		jne			loop2

		pop			ebp
		}
	}

static inline void ConvertLineToYUV_P7D2(BYTE * py, BYTE * puv, BYTE * pm, int w)
	{
	static MMXDWORD<2> shlmsk2y = {0x00ff00ff, 0x00ff00ff};
	static MMXDWORD<2> shlmsk2u = {0x0000ff00, 0x0000ff00};
	static MMXDWORD<2> shlmsk2v = {0xff000000, 0xff000000};

	if (w)
		{
		__asm
			{
			mov	eax,	[pm]
			mov	ebx,	[py]
			mov	edx,	[puv]
			mov	ecx,  [w]

			add	eax, ecx
			add	ebx, ecx
			add	edx, ecx
			neg	ecx

			movq	mm7, [shlmsk2y]
			movq	mm6, [shlmsk2u]
			movq	mm5, [shlmsk2v]

			movq	mm0, [ebx+ecx]

			movq	mm1, [edx+ecx]
			movq	mm3, mm0

			movq	mm2, mm1
			movq	mm4, mm1

			pand	mm0, mm7
			psllq	mm1, 8

			psllq	mm2, 16
			pand	mm1, mm6

			pand	mm2, mm5
			por	mm0, mm1

			por	mm2, mm0
			psrlq	mm3, 8

			pand	mm3, mm7
			add	ecx, 8

			movq	mm1, mm4
			psrlq	mm4, 8

			pand	mm4, mm6
			pand	mm1, mm5

			por	mm3, mm4
			je		done1
loop1:
			movq	mm0, [ebx+ecx]
			por	mm3, mm1

			movq	mm1, [edx+ecx]
			paddb	mm2, mm3

			movq	mm3, mm0
			movq	mm4, mm1

			movq	[eax+ecx-8], mm2
			movq	mm2, mm1

			pand	mm0, mm7
			psllq	mm1, 8

			psllq	mm2, 16
			pand	mm1, mm6

			pand	mm2, mm5
			por	mm0, mm1

			por	mm2, mm0
			psrlq	mm3, 8

			movq	mm1, mm4
			psrlq	mm4, 8

			pand	mm3, mm7
			pand	mm4, mm6

			pand	mm1, mm5
			add	ecx, 8

			por	mm3, mm4
			jne	loop1
done1:
			por	mm3, mm1

			paddb	mm2, mm3

			movq	[eax+ecx-8], mm2
			}
		}
	}

static inline void ConvertLineToYUVThroughOSD_P7D2(BYTE * py, BYTE * puv, BYTE * pm, int w,
	                                                BYTE * po, DDWORD * dd)
	{
	static MMXDWORD<2> shlmsk2y = {0x00ff00ff, 0x00ff00ff};
	static MMXDWORD<2> shlmsk2u = {0x0000ff00, 0x0000ff00};
	static MMXDWORD<2> shlmsk2v = {0xff000000, 0xff000000};

	if (w)
		{
		__asm
			{
			mov	esi,	[pm]
			mov	ebx,	[py]
			mov	edx,	[puv]
			mov	ecx,  [w]

			add	esi, ecx
			add	ebx, ecx
			add	edx, ecx
			neg	ecx

			movq	mm7, [shlmsk2y]
			movq	mm6, [shlmsk2u]
			movq	mm5, [shlmsk2v]

loop1:
			movq	mm0, [ebx+ecx]

			movq	mm1, [edx+ecx]
			movq	mm3, mm0

			movq	mm2, mm1
			movq	mm4, mm1

			pand	mm0, mm7

			psllq	mm1, 8

			psllq	mm2, 16
			pand	mm1, mm6

			pand	mm2, mm5
			por	mm0, mm1

			por	mm2, mm0

			psrlq	mm3, 8

			pand	mm3, mm7

			movq	mm1, mm4
			psrlq	mm4, 8

			pand	mm4, mm6
			pand	mm1, mm5

			por	mm3, mm4
			por	mm3, mm1

			paddb	mm2, mm3

			movq	[esi+ecx], mm2

			add	ecx, 8
			jne	loop1
			}
		}

	__asm
		{
		mov			esi, [pm]
		mov			edi, [po]
		mov			ebx, [dd]
		mov			ecx, [w]

		shr	ecx, 1

		lea	esi, [esi+2*ecx]
		lea	edi, [edi+ecx]
		neg	ecx

		pxor			mm0, mm0
loop2:
		movq			mm1, [esi+2*ecx]

		movq			mm2, mm1
		punpcklbw	mm1, mm0

		punpckhbw	mm2, mm0
		xor			eax, eax

		mov			al, [edi+ecx]

		movq			mm3, [ebx + eax * 8 + 2048 + 4096]

		movq			mm4, [ebx + eax * 8 + 4096]

		xor			eax, eax

		mov			al, [edi+ecx+1]

		paddw			mm3, [ebx + eax * 8 + 2048 + 8192]

		paddw			mm4, [ebx + eax * 8 + 8192]

		pmullw		mm1, mm3

		paddw			mm1, mm4

		xor			eax, eax

		mov			al, [edi+ecx+2]

		movq			mm3, [ebx + eax * 8 + 2048 + 4096]

		movq			mm4, [ebx + eax * 8 + 4096]

		xor			eax, eax

		mov			al, [edi+ecx+3]

		paddw			mm3, [ebx + eax * 8 + 2048 + 8192]

		paddw			mm4, [ebx + eax * 8 + 8192]

		pmullw		mm2, mm3

		paddw			mm2, mm4

		psrlw			mm1, 5

		psrlw			mm2, 5

		packuswb		mm1, mm2

		movq			[esi+2*ecx], mm1

		add			ecx, 4
		jne			loop2
		}
	}

static inline void ConvertLineToYUV_P7DS(BYTE * py, BYTE * puv, BYTE * pm, int w, int s)
	{
	int x;
	int xs;

	xs = 1 << s;

	for(x = 0; x < w; x += 2 * xs)
		{
		*pm++ = py[x] << 1;
		*pm++ = puv[x] << 1;
		*pm++ = py[x+xs] << 1;
		*pm++ = puv[x+xs+1] << 1;
		}
	}

static inline void ConvertLineToYUVThroughOSD_P7DS(BYTE * py, BYTE * puv, BYTE * pm, int w,
																	BYTE * po, DDWORD * dd, int s)
	{
	ConvertLineToYUV_P7DS(py, puv, pm, w, s);
	}

///////////////////////////////////////////////////////////////////////////////

void XMMXYUVVideoConverter::ConvertStripeToYUV_P7DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	switch (p.xscale)
		{
		case 0:
			for(y = p.ystart; y < p.ystop; y++)
				{
				hi = (ycount >> 16) & p.stripeMask;

				lpy = p.py + p.bpr * hi;
				lpuv = p.puv + p.bpr * (hi >> 1);

				ConvertLineToYUV_P7D1(lpy, lpuv, pm, p.width);

				ycount += p.yfraction;
				pm += p.mbpr;
				}
			break;
		case 1:
			for(y = p.ystart; y < p.ystop; y++)
				{
				hi = (ycount >> 16) & p.stripeMask;

				lpy = p.py + p.bpr * hi;
				lpuv = p.puv + p.bpr * (hi >> 1);

				ConvertLineToYUV_P7D2(lpy, lpuv, pm, p.width);

				ycount += p.yfraction;
				pm += p.mbpr;
				}
			break;
		default:
			for(y = p.ystart; y < p.ystop; y++)
				{
				hi = (ycount >> 16) & p.stripeMask;

				lpy = p.py + p.bpr * hi;
				lpuv = p.puv + p.bpr * (hi >> 1);

				ConvertLineToYUV_P7DS(lpy, lpuv, pm, p.width, p.xscale);

				ycount += p.yfraction;
				pm += p.mbpr;
				}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVThroughOSD_P7DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv, * lpo;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	switch (p.xscale)
		{
		case 0:
			for(y = p.ystart; y < p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy = p.py + p.bpr * (hi & p.stripeMask);
				lpuv = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);

				if (hi >= p.yosdstart && hi < p.yosdstop)
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					ConvertLineToYUV_P7D1(lpy, lpuv, pm, p.xosdstart);
					ConvertLineToYUVThroughOSD_P7D1(lpy + p.xosdstart, lpuv + p.xosdstart, pm + (p.xosdstart << 1), p.xosdstop - p.xosdstart, lpo, p.dd);
					ConvertLineToYUV_P7D1(lpy + p.xosdstop, lpuv + p.xosdstop, pm + (p.xosdstop << 1), p.width - p.xosdstop);
					}
				else
					{
					ConvertLineToYUV_P7D1(lpy, lpuv, pm, p.width);
					}

				ycount += p.yfraction;
				pm += p.mbpr;
				}
			break;
		case 1:
			for(y = p.ystart; y < p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy = p.py + p.bpr * (hi & p.stripeMask);
				lpuv = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);

				if (hi >= p.yosdstart && hi < p.yosdstop)
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					ConvertLineToYUV_P7D2(lpy, lpuv, pm, p.xosdstart);
					ConvertLineToYUVThroughOSD_P7D2(lpy + p.xosdstart, lpuv + p.xosdstart, pm + p.xosdstart, p.xosdstop - p.xosdstart, lpo, p.dd);
					ConvertLineToYUV_P7D2(lpy + p.xosdstop, lpuv + p.xosdstop, pm + p.xosdstop, p.width - p.xosdstop);
					}
				else
					{
					ConvertLineToYUV_P7D2(lpy, lpuv, pm, p.width);
					}

				ycount += p.yfraction;
				pm += p.mbpr;
				}
			break;
		default:
			for(y = p.ystart; y < p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy = p.py + p.bpr * (hi & p.stripeMask);
				lpuv = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);

				if (hi >= p.yosdstart && hi < p.yosdstop)
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					ConvertLineToYUV_P7DS(lpy, lpuv, pm, p.xosdstart, p.xscale);
					ConvertLineToYUVThroughOSD_P7DS(lpy + p.xosdstart, lpuv + p.xosdstart, pm + (p.xosdstart >> (p.xscale - 1)), p.xosdstop - p.xosdstart, lpo, p.dd, p.xscale);
					ConvertLineToYUV_P7DS(lpy + p.xosdstop, lpuv + p.xosdstop, pm + (p.xosdstop >> (p.xscale - 1)), p.width - p.xosdstop, p.xscale);
					}
				else
					{
					ConvertLineToYUV_P7DS(lpy, lpuv, pm, p.width, p.xscale);
					}

				ycount += p.yfraction;
				pm += p.mbpr;
				}
		}
	}

///////////////////////////////////////////////////////////////////////////////
//
// eight bit conversion routines without scaling
//

//
// Convert a pair of single Y and UV into a YUY2 line
//
static inline void ConvertLineToYUV_P8D1(BYTE * py, BYTE * puv, BYTE * pm, int w)
	{
	if (w)
		{
		__asm
			{
			mov			eax,	[pm]
			mov			ebx,	[py]
			mov			edx,	[puv]
			mov			ecx,  [w]

			lea			eax, [eax+2*ecx]
			add			ebx, ecx
			add			edx, ecx
			neg			ecx

			movq			mm0, [ebx+ecx]

			movq			mm1, [edx+ecx]

			add			ecx, 8
			je				done
	loop2:
			movq			mm2, mm0
			punpcklbw	mm0, mm1

			movq			mm3, [ebx+ecx]
			punpckhbw	mm2, mm1

			movq			[eax+2*ecx-16], mm0
			movq			mm0, mm3

			movq			mm1, [edx+ecx]

			movq			[eax+2*ecx-8], mm2

			add			ecx, 8
			jne			loop2
	done:

			movq			mm2, mm0
			punpcklbw	mm0, mm1

			movq			[eax+2*ecx-16], mm0
			punpckhbw	mm2, mm1

			movq			[eax+2*ecx-8], mm2
			}
		}
	}



//
// Convert a pair of single Y and UV into a YUY2 line, and merging with an osd
// bitmap
//
static inline void ConvertLineToYUVThroughOSD_P8D1(BYTE * py, BYTE * puv, BYTE * pm, int w,
																	BYTE * po, DDWORD * dd)
	{
	__asm
		{
		mov			esi, [pm]
		mov			ebx, [py]
		mov			edx, [puv]
		mov			ecx, [w]
		mov			edi, [po]

		push			ebp
		mov			ebp, [dd]

		shr			ecx, 1

		lea			esi, [esi+4*ecx]
		lea			ebx, [ebx+2*ecx]
		lea			edx, [edx+2*ecx]
		lea			edi, [edi+ecx]
		neg			ecx

		pxor			mm7, mm7
loop2:
		movq			mm0, [ebx+2*ecx]

		movq			mm1, [edx+2*ecx]

		movq			mm2, mm0

		punpcklbw	mm0, mm1
		xor			eax, eax

		punpckhbw	mm2, mm1
		mov			al, [edi+ecx]

		movq			mm1, mm0
		punpcklbw	mm0, mm7

		pmullw		mm0, [ebp + eax * 8 + 2048]
		punpckhbw	mm1, mm7

		movq			mm4, [ebp + eax * 8]
		movq			mm3, mm2

		punpcklbw	mm2, mm7
		xor			eax, eax

		paddw			mm0, mm4
		mov			al, [edi+ecx+1]

		punpckhbw	mm3, mm7
		psrlw			mm0, 4

		pmullw		mm1, [ebp + eax * 8 + 2048]

		movq			mm5, [ebp + eax * 8]
		//

		xor			eax, eax
		//

		paddw			mm1, mm5
		mov			al, [edi+ecx+2]

		psrlw			mm1, 4
		//

		pmullw		mm2, [ebp + eax * 8 + 2048]
		packuswb		mm0, mm1

		movq			mm5, [ebp + eax * 8]
		//

		movq			[esi+4*ecx], mm0
		//

		paddw			mm2, mm5
		xor			eax, eax

		mov			al, [edi+ecx+3]

		pmullw		mm3, [ebp + eax * 8 + 2048]

		paddw			mm3, [ebp + eax * 8]
		psrlw			mm2, 4

		psrlw			mm3, 4

		packuswb		mm2, mm3

		movq			[esi+4*ecx+8], mm2

		add			ecx, 4
		jne			loop2

		pop			ebp
		}
	}

static inline void ConvertLineToYUVWithOSD_P8D1(BYTE * py, BYTE * puv, BYTE * pm, int width,
																int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
	ConvertLineToYUV_P8D1(py, puv, pm, xosdstart);
	ConvertLineToYUVThroughOSD_P8D1(py + xosdstart, puv + xosdstart, pm + (xosdstart << 1), xosdstop - xosdstart, po, dd);
	ConvertLineToYUV_P8D1(py + xosdstop, puv + xosdstop, pm + (xosdstop << 1), width - xosdstop);
	}



static inline void ConvertLineToYUVWithOSD_P8D1MUV(BYTE * py, BYTE * puv, int bpr, BYTE * pm, int width,
																   int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
	ConvertLineToYUV_P8D1MUV(py, puv, pm, xosdstart, bpr);
	ConvertLineToYUVThroughOSD_P8D1MUV(py + xosdstart, puv + xosdstart, pm + (xosdstart << 1), xosdstop - xosdstart, bpr, po, dd);
	ConvertLineToYUV_P8D1MUV(py + xosdstop, puv + xosdstop, pm + (xosdstop << 1), width - xosdstop, bpr);
	}

static inline void ConvertLineToYUVWithOSD_P8D1MY(BYTE * py, BYTE * puv, int bpr, BYTE * pm, int width,
																   int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
	ConvertLineToYUV_P8D1(py, puv, pm, xosdstart);
	ConvertLineToYUVThroughOSD_P8D1(py + xosdstart, puv + xosdstart, pm + (xosdstart << 1), xosdstop - xosdstart, po, dd);
	ConvertLineToYUV_P8D1(py + xosdstop, puv + xosdstop, pm + (xosdstop << 1), width - xosdstop);
	}

static inline void ConvertLineToYUVWithOSD_P8D1MYUV(BYTE * py, BYTE * puv, int bpr, BYTE * pm, int width,
																   int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
	ConvertLineToYUV_P8D1MUV(py, puv, pm, xosdstart, bpr);
	ConvertLineToYUVThroughOSD_P8D1MUV(py + xosdstart, puv + xosdstart, pm + (xosdstart << 1), xosdstop - xosdstart, bpr, po, dd);
	ConvertLineToYUV_P8D1MUV(py + xosdstop, puv + xosdstop, pm + (xosdstop << 1), width - xosdstop, bpr);
	}

///////////////////////////////////////////////////////////////////////////////
//
// eight bit conversion routines with binary x scaling and no y scaling
//











static inline void ConvertLineToYUVWithOSD_P8D2(BYTE * py, BYTE * puv, BYTE * pm, int width,
																int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
	ConvertLineToYUV_P8D2(py, puv, pm, xosdstart);
	ConvertLineToYUVThroughOSD_P8D2(py + xosdstart, puv + xosdstart, pm + xosdstart, xosdstop - xosdstart, po, dd);
	ConvertLineToYUV_P8D2(py + xosdstop, puv + xosdstop, pm + xosdstop, width - xosdstop);
	}

///////////////////////////////////////////////////////////////////////////////
//
// eight bit conversion routines with linear x scaling and no y scaling
//

//
// convert a pair of single y and uv lines into a yuy2 line, by using linear
// scaling.
//
static inline void ConvertLineToYUV_P8F2(BYTE * py, BYTE * puv, BYTE * pm, int w, int xcount, int xfraction)
	{
	static MMXQUShort negate = {0x7fff, 0x0000, 0x7fff, 0x0000};
	static MMXQUShort fullneg = {0xffff, 0x0000, 0xffff, 0x0000};
	static MMXQUShort mask15 = {0x7fff, 0x7fff, 0x7fff, 0x7fff};

	if (w)
		{
		__asm
			{
			mov			eax, [pm]
			mov			ebx, [py]
			mov			edx, [puv]
			mov			ecx, [w]
			mov			esi, [xcount]
			push			ebp
			mov			ebp, [xfraction]

			movd			mm6, esi
			movd			mm7, ebp
			paddd			mm7, mm6

			punpcklwd	mm6, mm7
			punpcklwd	mm6, mm6
			psrlw			mm6, 1
			pxor			mm6, [negate]

			movd			mm7, ebp
			punpcklwd	mm7, mm7
			punpcklwd	mm7, mm7
			pxor			mm7, [fullneg]
			psubw			mm7, [fullneg]

			pxor			mm5, mm5
			movq			mm4, [mask15]
	loop2:
			mov			edi, esi
			shr			esi, 16

			movd			mm0, [ebx+esi]
			add			edi, ebp

			and			esi, 0xfffffffe
			movd			mm3, [edx+esi]

			mov			esi, edi
			shr			edi, 16

			movd			mm1, [ebx+edi]
			add			esi, ebp

			punpcklwd	mm0, mm1
			punpcklbw	mm0, mm5

			pmaddwd		mm0, mm6
			psrld			mm0, 15

			paddw			mm6, mm7
			pand			mm6, mm4

			mov			edi, esi
			shr			esi, 16

			movd			mm2, [ebx+esi]
			add			edi, ebp

			and			esi, 0xfffffffe
			movd			mm1, [edx+esi]
			punpcklwd	mm3, mm1

			mov			esi, edi
			shr			edi, 16

			movd			mm1, [ebx+edi]
			add			esi, ebp

			punpcklwd	mm2, mm1
			punpcklbw	mm2, mm5

			pmaddwd		mm2, mm6
			psrld			mm2, 15

			paddw			mm6, mm7
			pand			mm6, mm4

			packssdw		mm0, mm2
			packuswb		mm0, mm0

			punpcklbw	mm0, mm3

			movq			[eax], mm0

			add			eax, 8

			sub			ecx, 4
			jne			loop2

			pop			ebp
			}
		}
	}

//
// convert a pair of single y and uv lines into a yuy2 line, by using linear
// scaling, and merging with an OSD bitmap
//
static inline void ConvertLineToYUV_P8F2ThroughOSD(BYTE * py, BYTE * puv, BYTE * pm, int w, int xcount, int xfraction, BYTE * po, DDWORD * dd)
	{
	static MMXQShort negate = {0x7fff, 0x0000, 0x7fff, 0x0000};

	if (w)
		{
		__asm
			{
			mov			ebx, [py]
			mov			edx, [puv]
			mov			ecx, [w]
			xor			esi, esi
			movd			mm5, [xcount]
			movd			mm6, [xfraction]

			pxor			mm7, mm7
	loop2:
			movd			edi, mm5
			shr			edi, 16

			movd			mm0, [ebx+edi]
			movq			mm1, mm5
			paddd			mm5, mm6

			and			edi, 0xfffe
			movd			mm4, [edx+edi]

			movd			edi, mm5
			shr			edi, 16

			movd			mm2, [ebx+edi]
			movq			mm3, mm5
			paddd			mm5, mm6

			punpcklwd	mm0, mm2
			punpcklbw	mm0, mm7

			punpckldq	mm1, mm3
			psrld			mm1, 1
			pand			mm1, [negate]
			movq			mm3, mm1
			pslld			mm1, 16
			por			mm1, mm3
			pxor			mm1, [negate]

			pmaddwd		mm0, mm1
			psrld			mm0, 15

			packssdw		mm0, mm0
			packuswb		mm0, mm0
			punpcklbw	mm0, mm4

			punpcklbw	mm0, mm7
			mov			edi, [dd]
			mov			eax, [po]
			movzx			eax, BYTE PTR [eax + esi]
			pmullw		mm0, [edi + eax * 8 + 2048]
			paddw			mm0, [edi + eax * 8]
			psrlw			mm0, 4
			packuswb		mm0, mm0

			mov			eax, [pm]
			movd			[eax+4*esi], mm0

			inc			esi

			sub			ecx, 2
			jne			loop2
			}
		}
	}

static inline void ConvertLineToYUV_P8F2WithOSD(BYTE * py, BYTE * puv, BYTE * pm, int width, int xoffset, int xfraction, int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
	ConvertLineToYUV_P8F2(py, puv, pm, xosdstart, xoffset, xfraction);
	ConvertLineToYUV_P8F2ThroughOSD(py, puv, pm + (xosdstart << 1), xosdstop - xosdstart, xoffset + xfraction * xosdstart, xfraction, po, dd);
	ConvertLineToYUV_P8F2(py, puv, pm + (xosdstop << 1), width - xosdstop, xoffset + xfraction * xosdstop, xfraction);
	}





static inline void ConvertLineToYUVWithOSD_P8D1Y2(BYTE * py0, BYTE * py1, BYTE * puv, BYTE * pm, int width,
																  int xosdstart, int xosdstop, BYTE * po, DDWORD * dd, int lo)
	{
	ConvertLineToYUV_P8D1Y2(py0, py1, puv, pm, xosdstart, lo);
	ConvertLineToYUVThroughOSD_P8D1Y2(py0 + xosdstart, py1 + xosdstart, puv + xosdstart, pm + (xosdstart << 1), xosdstop - xosdstart, po, dd, lo);
	ConvertLineToYUV_P8D1Y2(py0 + xosdstop, py1 + xosdstop, puv + xosdstop, pm + (xosdstop << 1), width - xosdstop, lo);
	}

///////////////////////////////////////////////////////////////////////////////
//
// eight bit conversion routines with binary x scaling and linear y scaling
//





static inline void ConvertLineToYUVWithOSD_P8D2Y2(BYTE * py0, BYTE * py1, BYTE * puv, BYTE * pm, int width,
																  int xosdstart, int xosdstop, BYTE * po, DDWORD * dd, int lo)
	{
	ConvertLineToYUV_P8D2Y2(py0, py1, puv, pm, xosdstart, lo);
	ConvertLineToYUVThroughOSD_P8D2Y2(py0 + xosdstart, py1 + xosdstart, puv + xosdstart, pm + xosdstart, xosdstop - xosdstart, po, dd, lo);
	ConvertLineToYUV_P8D2Y2(py0 + xosdstop, py1 + xosdstop, puv + xosdstop, pm + xosdstop, width - xosdstop, lo);
	}



///////////////////////////////////////////////////////////////////////////////
//
// eight bit conversion routines with four tap x scaling and no y scaling
//

static inline void ConvertLineToYUV_P8F4(BYTE * py, BYTE * puv, BYTE * pm, int w, int xcount, int xfraction, MMXQShort * filter)
	{
	BYTE * final;

	xfraction >>= 6;
	xcount >>= 6;
	final = pm + 2 * ((w + 3) & ~3);

	__asm
		{
		mov			edx, [filter]

		mov			esi, [py]
		movd			mm5, [xcount]
		movd			mm6, [xfraction]
		mov			edi, [puv]
		mov			eax, [pm]

		pxor			mm7, mm7

		movd			ebx, mm5
		shr			ebx, 10

		movd			mm0, [esi + ebx]
		punpcklbw	mm0, mm7

		and			ebx, 0xfffe
		movzx			ecx, WORD PTR [edi + ebx]

		movd			ebx, mm5
		paddd			mm5, mm6
		and			ebx, 0x000003f8
		pmaddwd		mm0, [edx + ebx]
		dec			esi

		movd			ebx, mm5
		shr			ebx, 10

		movd			mm1, [esi + ebx]
		punpcklbw	mm1, mm7

		movd			ebx, mm5
		paddd			mm5, mm6
		and			ebx, 0x000003f8
		pmaddwd		mm1, [edx + ebx]

		movd			ebx, mm5
		shr			ebx, 10

		movd			mm2, [esi + ebx]
		punpcklbw	mm2, mm7

		and			ebx, 0xfffe
		movzx			ebx, WORD PTR [edi + ebx]
		shl			ebx, 16
		or				ecx, ebx

		movd			ebx, mm5
		paddd			mm5, mm6
		and			ebx, 0x000003f8
		pmaddwd		mm2, [edx + ebx]

		movd			ebx, mm5
		shr			ebx, 10

		movd			mm3, [esi + ebx]
		punpcklbw	mm3, mm7

		movd			ebx, mm5
		paddd			mm5, mm6
		and			ebx, 0x000003f8
		pmaddwd		mm3, [edx + ebx]

		add			eax, 8

		movq			mm4, mm0
		punpckldq	mm0, mm1
		punpckhdq	mm4, mm1
		paddd			mm4, mm0

		cmp			eax, [final]

		movq			mm1, mm2
		punpckldq	mm2, mm3
		punpckhdq	mm1, mm3
		paddd			mm2, mm1

		psrad			mm4, 14
		psrad			mm2, 14
		packssdw		mm4, mm2
		packuswb		mm4, mm4

		movd			mm1, ecx
		punpcklbw	mm4, mm1

		je				done1

		sub			eax, 8
loop1:
		movd			ebx, mm5
		shr			ebx, 10
		movd			mm0, [esi + ebx]
		punpcklbw	mm0, mm7

		and			ebx, 0xfffe
		movzx			ecx, WORD PTR [edi + ebx]

		movd			ebx, mm5
		paddd			mm5, mm6
		and			ebx, 0x000003f8
		pmaddwd		mm0, [edx + ebx]

		movd			ebx, mm5
		shr			ebx, 10
		movd			mm1, [esi + ebx]
		punpcklbw	mm1, mm7

		movd			ebx, mm5
		paddd			mm5, mm6
		and			ebx, 0x000003f8
		pmaddwd		mm1, [edx + ebx]

		movd			ebx, mm5
		shr			ebx, 10

		movd			mm2, [esi + ebx]
		punpcklbw	mm2, mm7

		and			ebx, 0xfffe
		movzx			ebx, WORD PTR [edi + ebx]
		shl			ebx, 16
		or				ecx, ebx

		movd			ebx, mm5
		paddd			mm5, mm6
		and			ebx, 0x000003f8
		pmaddwd		mm2, [edx + ebx]

		movd			ebx, mm5
		shr			ebx, 10

		movd			mm3, [esi + ebx]
		punpcklbw	mm3, mm7

		movd			ebx, mm5
		paddd			mm5, mm6
		and			ebx, 0x000003f8
		pmaddwd		mm3, [edx + ebx]

		movq			[eax], mm4
		add			eax, 8

		movq			mm4, mm0
		punpckldq	mm0, mm1
		punpckhdq	mm4, mm1
		paddd			mm4, mm0

		cmp			eax, [final]

		movq			mm1, mm2
		punpckldq	mm2, mm3
		punpckhdq	mm1, mm3
		paddd			mm2, mm1

		psrad			mm4, 14
		psrad			mm2, 14
		packssdw		mm4, mm2
		packuswb		mm4, mm4

		movd			mm1, ecx
		punpcklbw	mm4, mm1

		jne			loop1
done1:
		movq			[eax], mm4
		}
	}





static inline void ConvertLineToYUVWithOSD_P8D1Y4(BYTE * py0, BYTE * py1, BYTE * py2, BYTE * py3, BYTE * puv, BYTE * pm, int width, int xosdstart, int xosdstop, BYTE * po, DDWORD * dd, short * filter)
	{
	ConvertLineToYUV_P8D1Y4(py0, py1, py2, py3, puv, pm, xosdstart, filter);
	ConvertLineToYUVThroughOSD_P8D1Y4(py0 + xosdstart, py1 + xosdstart, py2 + xosdstart, py3 + xosdstart, puv + xosdstart, pm + (xosdstart << 1), xosdstop - xosdstart, po, dd, filter);
	ConvertLineToYUV_P8D1Y4(py0 + xosdstop, py1 + xosdstop, py2 + xosdstop, py3 + xosdstop, puv + xosdstop, pm + (xosdstop << 1), width - xosdstop, filter);
	}





static inline void ConvertLineToYUVWithOSD_P8D1Y4MUV(BYTE * py0, BYTE * py1, BYTE * py2, BYTE * py3, BYTE * puv0, BYTE * puv1, BYTE * pm, int width, int xosdstart, int xosdstop, BYTE * po, DDWORD * dd, short * filter)
	{
	ConvertLineToYUV_P8D1Y4MUV(py0, py1, py2, py3, puv0, puv1, pm, xosdstart, filter);
	ConvertLineToYUVThroughOSD_P8D1Y4MUV(py0 + xosdstart, py1 + xosdstart, py2 + xosdstart, py3 + xosdstart, puv0 + xosdstart, puv1 + xosdstart, pm + (xosdstart << 1), xosdstop - xosdstart, po, dd, filter);
	ConvertLineToYUV_P8D1Y4MUV(py0 + xosdstop, py1 + xosdstop, py2 + xosdstop, py3 + xosdstop, puv0 + xosdstop, puv0 + xosdstop, pm + (xosdstop << 1), width - xosdstop, filter);
	}


static inline void ConvertLineToYUV_P8D2Y4(BYTE * py0, BYTE * py1, BYTE * py2, BYTE * py3, BYTE * puv, BYTE * pm, int w, short * filter)
	{
	}

static inline void ConvertLineToYUVThroughOSD_P8D2Y4(BYTE * py0, BYTE * py1, BYTE * py2, BYTE * py3, BYTE * puv, BYTE * pm, int w, BYTE * po, DDWORD * dd, short * filter)
	{
	}

static inline void ConvertLineToYUVWithOSD_P8D2Y4(BYTE * py0, BYTE * py1, BYTE * py2, BYTE * py3, BYTE * puv, BYTE * pm, int width, int xosdstart, int xosdstop, BYTE * po, DDWORD * dd, short * filter)
	{
	ConvertLineToYUV_P8D2Y4(py0, py1, py2, py3, puv, pm, xosdstart, filter);
	ConvertLineToYUVThroughOSD_P8D2Y4(py0 + xosdstart, py1 + xosdstart, py2 + xosdstart, py3 + xosdstart, puv + xosdstart, pm + xosdstart, xosdstop - xosdstart, po, dd, filter);
	ConvertLineToYUV_P8D2Y4(py0 + xosdstop, py1 + xosdstop, py2 + xosdstop, py3 + xosdstop, puv + xosdstop, pm + xosdstop, width - xosdstop, filter);
	}


///////////////////////////////////////////////////////////////////////////////
//
// eight bit deinterlacing routines
//

///////////////////////////////////////////////////////////////////////////////
//
// eight bit scaling routines
//

static inline void ScaleYUVLine_P8F4(BYTE * spm, BYTE * dpm, int w, int xcount, int xfraction, MMXQShort * filter)
	{
	static MMXQUShort lower = {0x00ff, 0x00ff, 0x00ff, 0x00ff};
	static MMXQUShort upper = {0xff00, 0xff00, 0xff00, 0xff00};

	BYTE * final;

	xfraction >>= 6;
	xcount >>= 6;
	final = dpm + 2 * ((w + 3) & ~3);

	__asm
		{
		mov			edx, [filter]

		mov			esi, [spm]
		movd			mm5, [xcount]
		movd			mm6, [xfraction]
		mov			eax, [dpm]

		movd			ebx, mm5
		shr			ebx, 10

		movq			mm0, [esi + 2 * ebx]
		pand			mm0, [lower]

		and			ebx, 0xfffe
		movd			mm7, [esi + 2 * ebx]

		movd			ebx, mm5
		paddd			mm5, mm6
		and			ebx, 0x000003f8
		pmaddwd		mm0, [edx + ebx]
		sub			esi, 2

		movd			ebx, mm5
		shr			ebx, 10

		movq			mm1, [esi + 2 * ebx]
		pand			mm1, [lower]

		movd			ebx, mm5
		paddd			mm5, mm6
		and			ebx, 0x000003f8
		pmaddwd		mm1, [edx + ebx]

		movd			ebx, mm5
		shr			ebx, 10

		movq			mm2, [esi + 2 * ebx]
		pand			mm2, [lower]

		and			ebx, 0xfffe
		punpckldq	mm7, [esi + 2 * ebx + 2]
		psrlw			mm7, 8

		movd			ebx, mm5
		paddd			mm5, mm6
		and			ebx, 0x000003f8
		pmaddwd		mm2, [edx + ebx]

		movd			ebx, mm5
		shr			ebx, 10

		movq			mm3, [esi + 2 * ebx]
		pand			mm3, [lower]

		movd			ebx, mm5
		paddd			mm5, mm6
		and			ebx, 0x000003f8
		pmaddwd		mm3, [edx + ebx]

		add			eax, 8

		movq			mm4, mm0
		punpckldq	mm0, mm1
		punpckhdq	mm4, mm1
		paddd			mm4, mm0

		cmp			eax, [final]

		movq			mm1, mm2
		punpckldq	mm2, mm3
		punpckhdq	mm1, mm3
		paddd			mm2, mm1

		psrad			mm4, 14
		psrad			mm2, 14
		packssdw		mm4, mm2
		packuswb		mm4, mm4
		packuswb		mm7, mm7

		punpcklbw	mm4, mm7

		je				done1

		sub			eax, 8
loop1:
		movq			mm3, [lower]
		movd			ebx, mm5
		shr			ebx, 10

		movq			mm0, [esi + 2 * ebx]
		pand			mm0, mm3
		and			ebx, 0xfffe

		movd			mm7, [esi + 2 * ebx + 2]
		movd			ebx, mm5
		and			ebx, 0x000003f8

		pmaddwd		mm0, [edx + ebx]
		paddd			mm5, mm6

		movd			ebx, mm5
		shr			ebx, 10
		movq			mm1, [esi + 2 * ebx]

		pand			mm1, mm3
		movd			ebx, mm5
		and			ebx, 0x000003f8

		pmaddwd		mm1, [edx + ebx]
		paddd			mm5, mm6

		movd			ebx, mm5
		shr			ebx, 10
		movq			mm2, [esi + 2 * ebx]

		pand			mm2, mm3

		and			ebx, 0xfffe
		punpckldq	mm7, [esi + 2 * ebx + 2]
		psrlw			mm7, 8

		movd			ebx, mm5
		paddd			mm5, mm6
		and			ebx, 0x000003f8
		pmaddwd		mm2, [edx + ebx]

		movd			ebx, mm5
		shr			ebx, 10

		pand			mm3, [esi + 2 * ebx]

		movd			ebx, mm5
		paddd			mm5, mm6
		and			ebx, 0x000003f8
		pmaddwd		mm3, [edx + ebx]

		movq			[eax], mm4
		add			eax, 8

		movq			mm4, mm0
		punpckldq	mm0, mm1
		punpckhdq	mm4, mm1
		paddd			mm4, mm0

		cmp			eax, [final]

		movq			mm1, mm2
		punpckldq	mm2, mm3
		punpckhdq	mm1, mm3
		paddd			mm2, mm1

		psrad			mm4, 14
		psrad			mm2, 14
		packssdw		mm4, mm2
		packuswb		mm4, mm4
		packuswb		mm7, mm7

		punpcklbw	mm4, mm7

		jne			loop1
done1:
		movq			[eax], mm4
		}
	}





static inline void ScaleYUVLine_P8F2ThroughOSD(BYTE * spm, BYTE * dpm, int w, int xcount, int xfraction, BYTE * po, DDWORD * dd)
	{
	static MMXQUShort negate = {0x7fff, 0x0000, 0x7fff, 0x0000};
	static MMXQUShort lower = {0x00ff, 0x00ff, 0x00ff, 0x00ff};
	static MMXQUShort upper = {0xff00, 0xff00, 0xff00, 0xff00};
	static MMXQUShort fullneg = {0xffff, 0x0000, 0xffff, 0x0000};
	static MMXQUShort mask15 = {0x7fff, 0x7fff, 0x7fff, 0x7fff};

	if (w)
		{
		__asm
			{
			mov			ebx, [spm]
			mov			ecx, [w]
			xor			esi, esi
			movd			mm5, [xcount]
			movd			mm6, [xfraction]

			pxor			mm7, mm7
	loop2:
			movd			edi, mm5
			shr			edi, 16

			movd			mm0, [ebx+2*edi]
			movq			mm1, mm5
			paddd			mm5, mm6

			and			edi, 0xfffe
			movd			mm4, [ebx+2*edi]

			movd			edi, mm5
			shr			edi, 16

			movd			mm2, [ebx+2*edi]
			movq			mm3, mm5
			paddd			mm5, mm6

			punpckldq	mm0, mm2
			pand			mm0, [lower]

			punpckldq	mm1, mm3
			psrld			mm1, 1
			pand			mm1, [negate]
			movq			mm3, mm1
			pslld			mm1, 16
			por			mm1, mm3
			pxor			mm1, [negate]

			pmaddwd		mm0, mm1
			psrld			mm0, 15

			packssdw		mm0, mm0
			packuswb		mm0, mm0
			psrlw			mm4, 8
			packuswb		mm4, mm4
			punpcklbw	mm0, mm4

			punpcklbw	mm0, mm7
			mov			edi, [dd]
			mov			eax, [po]
			movzx			eax, BYTE PTR [eax + esi]
			pmullw		mm0, [edi + eax * 8 + 2048]
			paddw			mm0, [edi + eax * 8]
			psrlw			mm0, 4
			packuswb		mm0, mm0

			mov			eax, [dpm]
			movd			[eax+4*esi], mm0

			inc			esi

			sub			ecx, 2
			jne			loop2
			}
		}
	}

static inline void ScaleYUVLine_P8F2WithOSD(BYTE * spm, BYTE * dpm, int width, int xoffset, int xfraction, int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
	ScaleYUVLine_P8F2(spm, dpm, xosdstart, xoffset, xfraction);
	ScaleYUVLine_P8F2ThroughOSD(spm, dpm + (xosdstart << 1), xosdstop - xosdstart, xoffset + xfraction * xosdstart, xfraction, po, dd);
	ScaleYUVLine_P8F2(spm, dpm + (xosdstop << 1), width - xosdstop, xoffset + xfraction * xosdstop, xfraction);
	}

///////////////////////////////////////////////////////////////////////////////
//
// eight bit scaling routines
//


static inline void ConvertLineToYUV_P8DS(BYTE * py, BYTE * puv, BYTE * pm, int w, int s)
	{
	int x;
	int xs;

	xs = 1 << s;

	for(x = 0; x < w; x += 2 * xs)
		{
		*pm++ = py[x];
		*pm++ = puv[x];
		*pm++ = py[x+xs];
		*pm++ = puv[x+xs+1];
		}
	}

static inline void ConvertLineToYUVThroughOSD_P8DS(BYTE * py, BYTE * puv, BYTE * pm, int w,
																	BYTE * po, DDWORD * dd, int s)
	{
	ConvertLineToYUV_P8DS(py, puv, pm, w, s);
	}

static inline void ConvertLineToYUVWithOSD_P8DS(BYTE * py, BYTE * puv, BYTE * pm, int width, int xscale,
																int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
	ConvertLineToYUV_P8DS(py, puv, pm, xosdstart, xscale);
	ConvertLineToYUVThroughOSD_P8DS(py + xosdstart, puv + xosdstart, pm + (xosdstart >> (xscale - 1)), xosdstop - xosdstart, po, dd, xscale);
	ConvertLineToYUV_P8DS(py + xosdstop, puv + xosdstop, pm + (xosdstop >> (xscale - 1)), width - xosdstop, xscale);
	}







static inline void ConvertLineToYUVWithOSD_P8D1I4(BYTE * py, BYTE * puv, BYTE * ppy, int bpr, BYTE * pm, int width, int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
//	ConvertLineToYUV_P8D1I4(py, puv, ppy, bpr, pm, width);

	ConvertLineToYUV_P8D1I4(py, puv, ppy, bpr, pm, xosdstart);
	ConvertLineToYUVThroughOSD_P8D1I4(py + xosdstart, puv + xosdstart, ppy + xosdstart, bpr, pm + (xosdstart << 1), xosdstop - xosdstart, po, dd);
	ConvertLineToYUV_P8D1I4(py + xosdstop, puv + xosdstop, ppy + xosdstop, bpr, pm + (xosdstop << 1), width - xosdstop);
	}



static inline void ConvertLineToYUVWithOSD_P8D1I4MUV(BYTE * py, BYTE * puv, BYTE * ppy, int bpr, BYTE * pm, int width, int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
//	ConvertLineToYUV_P8D1I4MUV(py, puv, ppy, bpr, pm, width);

	ConvertLineToYUV_P8D1I4MUV(py, puv, ppy, bpr, pm, xosdstart);
	ConvertLineToYUVThroughOSD_P8D1I4MUV(py + xosdstart, puv + xosdstart, ppy + xosdstart, bpr, pm + (xosdstart << 1), xosdstop - xosdstart, po, dd);
	ConvertLineToYUV_P8D1I4MUV(py + xosdstop, puv + xosdstop, ppy + xosdstop, bpr, pm + (xosdstop << 1), width - xosdstop);
	}



static inline void ConvertLineToYUVWithOSD_P8D2I4(BYTE * py, BYTE * puv, BYTE * ppy, int bpr, BYTE * pm, int width, int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
	ConvertLineToYUV_P8D2I4(py, puv, ppy, bpr, pm, xosdstart);
	ConvertLineToYUVThroughOSD_P8D2I4(py + xosdstart, puv + xosdstart, ppy + xosdstart, bpr, pm + xosdstart, xosdstop - xosdstart, po, dd);
	ConvertLineToYUV_P8D2I4(py + xosdstop, puv + xosdstop, ppy + xosdstop, bpr, pm + xosdstop, width - xosdstop);
	}





static inline void ConvertLineToYUVWithOSD_P8D1M(BYTE * py, BYTE * puv, BYTE * ppy, BYTE * ppuv, BYTE * pm, int width, int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
	ConvertLineToYUV_P8D1M(py, puv, ppy, ppuv, pm, xosdstart);
	ConvertLineToYUVThroughOSD_P8D1M(py + xosdstart, puv + xosdstart, ppy + xosdstart, ppuv + xosdstart, pm + (xosdstart << 1), xosdstop - xosdstart, po, dd);
	ConvertLineToYUV_P8D1M(py + xosdstop, puv + xosdstop, ppy + xosdstop, ppuv + xosdstop, pm + (xosdstop << 1), width - xosdstop);
	}





static inline void ConvertLineToYUVWithOSD_P8D2M(BYTE * py, BYTE * puv, BYTE * ppy, BYTE * ppuv, BYTE * pm, int width, int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
	ConvertLineToYUV_P8D2M(py, puv, ppy, ppuv, pm, xosdstart);
	ConvertLineToYUVThroughOSD_P8D2M(py + xosdstart, puv + xosdstart, ppy + xosdstart, ppuv + xosdstart, pm + xosdstart, xosdstop - xosdstart, po, dd);
	ConvertLineToYUV_P8D2M(py + xosdstop, puv + xosdstop, ppy + xosdstop, ppuv + xosdstop, pm + xosdstop, width - xosdstop);
	}





static inline void ConvertLineToYUVWithOSD_P8D1MV(BYTE * py, BYTE * puv, int bpr, BYTE * pm, int width, int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
	ConvertLineToYUV_P8D1MV(py, puv, bpr, pm, xosdstart);
	ConvertLineToYUVThroughOSD_P8D1MV(py + xosdstart, puv + xosdstart, bpr, pm + (xosdstart << 1), xosdstop - xosdstart, po, dd);
	ConvertLineToYUV_P8D1MV(py + xosdstop, puv + xosdstop, bpr, pm + (xosdstop << 1), width - xosdstop);
	}


// new -> 01/26/2000
static inline void ConvertLineToYUVWithOSD_P8D1MV(BYTE * py0, BYTE * puv0, BYTE * py1, BYTE * puv1, BYTE * py2, BYTE * puv2, BYTE * pm, int width, int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
	ConvertLineToYUV_P8D1MV(py0, puv0, py1, puv1, py2, puv2, pm, xosdstart);
	ConvertLineToYUVThroughOSD_P8D1MV(py0 + xosdstart, puv0 + xosdstart, py1 + xosdstart, puv1 + xosdstart, py2 + xosdstart, puv2 + xosdstart, pm + (xosdstart << 1), xosdstop - xosdstart, po, dd);
	ConvertLineToYUV_P8D1MV(py0 + xosdstop, puv0 + xosdstop, py1 + xosdstop, puv1 + xosdstop, py2 + xosdstop, puv2 + xosdstop, pm + (xosdstop << 1), width - xosdstop);
	}
// <- new 01/26/2000


static inline void ConvertLineToYUVWithOSD_P8D2MV(BYTE * py, BYTE * puv, int bpr, BYTE * pm, int width, int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
	ConvertLineToYUV_P8D2MV(py, puv, bpr, pm, xosdstart);
	ConvertLineToYUVThroughOSD_P8D2MV(py + xosdstart, puv + xosdstart, bpr, pm + xosdstart, xosdstop - xosdstart, po, dd);
	ConvertLineToYUV_P8D2MV(py + xosdstop, puv + xosdstop, bpr, pm + xosdstop, width - xosdstop);
	}

// new -> 01/26/2000
static inline void ConvertLineToYUVWithOSD_P8D2MV(BYTE * py0, BYTE * puv0, BYTE * py1, BYTE * puv1, BYTE * py2, BYTE * puv2, BYTE * pm, int width, int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
	ConvertLineToYUV_P8D2MV(py0, puv0, py1, puv1, py2, puv2 , pm, xosdstart);
	ConvertLineToYUVThroughOSD_P8D2MV(py0 + xosdstart, puv0 + xosdstart, py1 + xosdstart, puv1 + xosdstart, py2 + xosdstart, puv2 + xosdstart, pm + xosdstart, xosdstop - xosdstart, po, dd);
	ConvertLineToYUV_P8D2MV(py0 + xosdstop, puv0 + xosdstop, py1 + xosdstop, puv1 + xosdstop, py2 + xosdstop, puv2 + xosdstop, pm + xosdstop, width - xosdstop);
	}
// <- new 01/26/2000

static inline void ConvertLineToYUVWithOSD_P8D2MUV(BYTE * py, BYTE * puv, int bpr, BYTE * pm, int width, int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
	ConvertLineToYUV_P8D2(py, puv, pm, xosdstart);
	ConvertLineToYUVThroughOSD_P8D2(py + xosdstart, puv + xosdstart, pm + xosdstart, xosdstop - xosdstart, po, dd);
	ConvertLineToYUV_P8D2(py + xosdstop, puv + xosdstop, pm + xosdstop, width - xosdstop);
	}

static inline void ConvertLineToYUVWithOSD_P8D2MY(BYTE * py, BYTE * puv, int bpr, BYTE * pm, int width, int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
	ConvertLineToYUV_P8D2(py, puv, pm, xosdstart);
	ConvertLineToYUVThroughOSD_P8D2(py + xosdstart, puv + xosdstart, pm + xosdstart, xosdstop - xosdstart, po, dd);
	ConvertLineToYUV_P8D2(py + xosdstop, puv + xosdstop, pm + xosdstop, width - xosdstop);
	}

static inline void ConvertLineToYUVWithOSD_P8D2MYUV(BYTE * py, BYTE * puv, int bpr, BYTE * pm, int width, int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
	ConvertLineToYUV_P8D2(py, puv, pm, xosdstart);
	ConvertLineToYUVThroughOSD_P8D2(py + xosdstart, puv + xosdstart, pm + xosdstart, xosdstop - xosdstart, po, dd);
	ConvertLineToYUV_P8D2(py + xosdstop, puv + xosdstop, pm + xosdstop, width - xosdstop);
	}

static inline void SharpenYUVLine(BYTE * spyuv, BYTE * dpyuv, int w)
	{
	static __int64 masklow  = 0x00ff00ff00ff00ff;
	static __int64 maskhigh	= 0xff00ff00ff00ff00;

	__asm
		{
		mov			esi, [spyuv]
		mov			edi, [dpyuv]
		mov			ecx, [w]
		shr			ecx, 1
loop1:
		movq			mm0, [esi-2]
		movq			mm1, [esi]
		movq			mm2, [esi+2]
		movq			mm3, mm1
		movq			mm4, mm1

		pand			mm0, [masklow]
		pand			mm1, [masklow]
		pand			mm2, [masklow]
		psrlw			mm3, 8
		packuswb		mm3, mm3
		paddw			mm0, mm2
		paddw			mm1, mm1
		psubw			mm1, mm0



		punpcklbw	mm1, mm3
		movq			[edi], mm1
		add			esi, 8
		add			edi, 8
		sub			ecx, 4
		jne			loop1

		mov			ecx, [w]
		shr			ecx, 1
loop2:
		movq			mm1, [esi]
		movq			[edi], mm1
		add			esi, 8
		add			edi, 8
		sub			ecx, 4
		jne			loop2
		}
	}



// new -> 01/25/2000
static inline void BlackOutLine(BYTE * pm, int width)
	{
	static MMXQUShort fill = {0x8000, 0x8000, 0x8000, 0x8000};

	if (width)
		{
		__asm
			{
			mov		eax, [pm]
			mov		ecx, [width]
			movq		mm0, [fill]
loop1:
			movq		[eax], mm0
			add		eax, 8
			sub		ecx, 4
			jne		loop1
			}
		}
	}
// <- new 01/25/2000


// new -> 01/25/2000
static inline void BlackOutLineThroughOSD(BYTE * pm, int width, BYTE * po, DDWORD * dd)
	{
	static MMXQShort fill = {0x0000, 0x0080, 0x0000, 0x0080};

	if (width)
		{
		__asm
			{
			mov			esi, [pm]
			mov			ecx, [width]
			mov			edi, [po]
			mov			ebx, [dd]
	loop2:
			movzx			eax, BYTE PTR [edi]
			movq			mm0, [fill]
			pmullw		mm0, [ebx + eax * 8 + 2048]
			paddw			mm0, [ebx + eax * 8]
			psrlw			mm0, 4
			movzx			eax, BYTE PTR [edi+1]
			movq			mm1, [fill]
			pmullw		mm1, [ebx + eax * 8 + 2048]
			paddw			mm1, [ebx + eax * 8]
			psrlw			mm1, 4
			packuswb		mm0, mm1
			movq			[esi], mm0
			add			edi, 2
			add			esi, 8
			sub			ecx, 4
			jne			loop2
			}
		}
	}
// <- new 01/25/2000

// new -> 01/25/2000
static inline void BlackOutLineWithOSD(BYTE * pm, int width,
													int xosdstart, int xosdstop, BYTE * po, DDWORD * dd)
	{
	BlackOutLine(pm, xosdstart);
	BlackOutLineThroughOSD(pm + (xosdstart << 1), xosdstop - xosdstart, po, dd);
	BlackOutLine(pm + (xosdstop << 1), width - xosdstop);
	}
// <- new 01/25/2000

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

void XMMXYUVVideoConverter::ConvertStripeToYUV_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	switch (p.xscale)
		{
		case 0:
			for(y = p.ystart; y < p.ystop; y++)
				{
				hi = (ycount >> 16) & p.stripeMask;

				lpy = p.py + p.bpr * hi;
				lpuv = p.puv + p.bpr * (hi >> 1);

				ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);

				ycount += p.yfraction;
				pm += p.mbpr;
				}
			break;
		case 1:
			for(y = p.ystart; y < p.ystop; y++)
				{
				hi = (ycount >> 16) & p.stripeMask;

				lpy = p.py + p.bpr * hi;
				lpuv = p.puv + p.bpr * (hi >> 1);

				ConvertLineToYUV_P8D2(lpy, lpuv, pm, p.width);

				ycount += p.yfraction;
				pm += p.mbpr;
				}
			break;
		default:
			for(y = p.ystart; y < p.ystop; y++)
				{
				hi = (ycount >> 16) & p.stripeMask;

				lpy = p.py + p.bpr * hi;
				lpuv = p.puv + p.bpr * (hi >> 1);

				ConvertLineToYUV_P8DS(lpy, lpuv, pm, p.width, p.xscale);

				ycount += p.yfraction;
				pm += p.mbpr;
				}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVThroughOSD_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv, * lpo;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	switch (p.xscale)
		{
		case 0:
			for(y = p.ystart; y < p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy = p.py + p.bpr * (hi & p.stripeMask);
				lpuv = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);

				if (hi >= p.yosdstart && hi < p.yosdstop)
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
					}
				else
					{
					ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
					}

				ycount += p.yfraction;
				pm += p.mbpr;
				}
			break;
		case 1:
			for(y = p.ystart; y < p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy = p.py + p.bpr * (hi & p.stripeMask);
				lpuv = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);

				if (hi >= p.yosdstart && hi < p.yosdstop)
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					ConvertLineToYUVWithOSD_P8D2(lpy, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
					}
				else
					{
					ConvertLineToYUV_P8D2(lpy, lpuv, pm, p.width);
					}

				ycount += p.yfraction;
				pm += p.mbpr;
				}
			break;
		default:
			for(y = p.ystart; y < p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy = p.py + p.bpr * (hi & p.stripeMask);
				lpuv = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);

				if (hi >= p.yosdstart && hi < p.yosdstop)
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					ConvertLineToYUVWithOSD_P8DS(lpy, lpuv, pm, p.width, p.xscale, p.xosdstart, p.xosdstop, lpo, p.dd);
					}
				else
					{
					ConvertLineToYUV_P8DS(lpy, lpuv, pm, p.width, p.xscale);
					}

				ycount += p.yfraction;
				pm += p.mbpr;
				}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUV_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	if (p.xfraction == 0x10000)
		{
		ConvertStripeToYUV_P8DS(p);
		}
	else
		{
		for(y = p.ystart; y < p.ystop; y++)
			{
			hi = (ycount >> 16) & p.stripeMask;

			lpy  = p.py  + p.bpr * hi;
			lpuv = p.puv + p.bpr * (hi >> 1);

			ConvertLineToYUV_P8F2(lpy, lpuv, pm, p.mwidth, 0, p.xfraction);

			ycount += p.yfraction;
			pm += p.mbpr;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVThroughOSD_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv, * lpo;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	if (p.xfraction == 0x10000)
		{
		ConvertStripeToYUVThroughOSD_P8DS(p);
		}
	else
		{
		for(y = p.ystart; y < p.ystop; y++)
			{
			hi = ycount >> 16;

			lpy  = p.py +  p.bpr * (hi & p.stripeMask);
			lpuv = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);

			if (hi >= p.yosdstart && hi < p.yosdstop)
				{
				lpo = p.po + p.obpr * (hi - p.yosdstart);

				ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
				}
			else
				{
				ConvertLineToYUV_P8F2(lpy, lpuv, pm, p.mwidth, 0, p.xfraction);
				}

			ycount += p.yfraction;
			pm += p.mbpr;
			}
		}
	}


void XMMXYUVVideoConverter::ConvertStripeToYUV_P8DSY2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy0, * lpy1, * lpuv;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	int hi, lo;

	if (p.yfraction == 0x10000 || p.xscale > 1)
		{
		ConvertStripeToYUV_P8DS(p);
		}
	else
		{
		switch (p.xscale)
			{
			case 0:
				for(y = p.ystart; y < p.ystop; y++)
					{
					hi = (ycount >> 16) & p.stripeMask;
					lo = (ycount & 0xffff) >> 8;

					lpy0 = p.py + p.bpr * hi;
					lpy1 = p.py + p.bpr * ((hi + 1) & p.stripeMask);

					lpuv = p.puv + p.bpr * (hi >> 1);

					if (lo)
						ConvertLineToYUV_P8D1Y2(lpy0, lpy1, lpuv, pm, p.width, lo);
					else
						ConvertLineToYUV_P8D1(lpy0, lpuv, pm, p.width);

					ycount += p.yfraction;
					pm += p.mbpr;
					}
				break;
			case 1:
				for(y = p.ystart; y < p.ystop; y++)
					{
					hi = (ycount >> 16) & p.stripeMask;
					lo = (ycount & 0xffff) >> 8;

					lpy0 = p.py + p.bpr * hi;
					lpy1 = p.py + p.bpr * ((hi + 1) & p.stripeMask);

					lpuv = p.puv + p.bpr * (hi >> 1);

					if (lo)
						ConvertLineToYUV_P8D2Y2(lpy0, lpy1, lpuv, pm, p.width, lo);
					else
						ConvertLineToYUV_P8D2(lpy0, lpuv, pm, p.width);

					ycount += p.yfraction;
					pm += p.mbpr;
					}
				break;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVThroughOSD_P8DSY2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy0, * lpy1, * lpuv, * lpo;
	int hi, lo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	if (p.yfraction == 0x10000 || p.xscale > 1)
		ConvertStripeToYUVThroughOSD_P8DS(p);
	else
		{
		switch (p.xscale)
			{
			case 0:
				for(y = p.ystart; y < p.ystop; y++)
					{
					hi = ycount >> 16;
					lo = (ycount & 0xffff) >> 8;

					lpy0 = p.py + p.bpr * (hi & p.stripeMask);
					lpy1 = p.py + p.bpr * ((hi + 1) & p.stripeMask);

					lpuv = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);


					if (hi >= p.yosdstart && hi < p.yosdstop)
						{
						lpo = p.po + p.obpr * (hi - p.yosdstart);

						if (lo)
							ConvertLineToYUVWithOSD_P8D1Y2(lpy0, lpy1, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd, lo);
						else
							ConvertLineToYUVWithOSD_P8D1(lpy0, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
						}
					else
						{
						if (lo)
							ConvertLineToYUV_P8D1Y2(lpy0, lpy1, lpuv, pm, p.width, lo);
						else
							ConvertLineToYUV_P8D1(lpy0, lpuv, pm, p.width);
						}

					ycount += p.yfraction;
					pm += p.mbpr;
					}
				break;
			case 1:
				for(y = p.ystart; y < p.ystop; y++)
					{
					hi = ycount >> 16;
					lo = (ycount & 0xffff) >> 8;

					lpy0 = p.py + p.bpr * (hi & p.stripeMask);
					lpy1 = p.py + p.bpr * ((hi + 1) & p.stripeMask);

					lpuv = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);


					if (hi >= p.yosdstart && hi < p.yosdstop)
						{
						lpo = p.po + p.obpr * (hi - p.yosdstart);

						if (lo)
							ConvertLineToYUVWithOSD_P8D2Y2(lpy0, lpy1, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd, lo);
						else
							ConvertLineToYUVWithOSD_P8D2(lpy0, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
						}
					else
						{
						if (lo)
							ConvertLineToYUV_P8D2Y2(lpy0, lpy1, lpuv, pm, p.width, lo);
						else
							ConvertLineToYUV_P8D2(lpy0, lpuv, pm, p.width);
						}

					ycount += p.yfraction;
					pm += p.mbpr;
					}
				break;
			}
		}
	}


void XMMXYUVVideoConverter::ConvertStripeToYUV_P8F2Y2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy0, * lpy1, * lpuv;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	int hi, lo;

	if (p.yfraction == 0x10000)
		{
		ConvertStripeToYUV_P8F2(p);
		}
	else if (p.xscale == 0x10000)
		{
		ConvertStripeToYUV_P8DSY2(p);
		}
	else
		{
		for(y = p.ystart; y < p.ystop; y++)
			{
			hi = (ycount >> 16) & p.stripeMask;
			lo = (ycount & 0xffff) >> 8;

			lpy0 = p.py + p.bpr * hi;
			lpy1 = p.py + p.bpr * ((hi + 1) & p.stripeMask);

			lpuv = p.puv + p.bpr * (hi >> 1);

			if (lo)
				ConvertLineToYUV_P8F2Y2(lpy0, lpy1, lpuv, pm, p.mwidth, 0, p.xfraction, lo);
			else
				ConvertLineToYUV_P8F2(lpy0, lpuv, pm, p.mwidth, 0, p.xfraction);

			ycount += p.yfraction;
			pm += p.mbpr;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVThroughOSD_P8F2Y2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy0, * lpy1, * lpuv, * lpo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	int hi, lo;

	if (p.yfraction == 0x10000)
		{
		ConvertStripeToYUVThroughOSD_P8F2(p);
		}
	else if (p.xscale == 0x10000)
		{
		ConvertStripeToYUVThroughOSD_P8DSY2(p);
		}
	else
		{
		for(y = p.ystart; y < p.ystop; y++)
			{
			hi = ycount >> 16;
			lo = (ycount & 0xffff) >> 8;

			lpy0 = p.py + p.bpr * (hi & p.stripeMask);
			lpy1 = p.py + p.bpr * ((hi + 1) & p.stripeMask);

			lpuv = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);

			if (hi >= p.yosdstart && hi < p.yosdstop)
				{
				lpo = p.po + p.obpr * (hi - p.yosdstart);

				if (lo)
					ConvertLineToYUVWithOSD_P8D1Y2(lpy0, lpy1, lpuv, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd, lo);
				else
					ConvertLineToYUVWithOSD_P8D1(lpy0, lpuv, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);

				ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
				}
			else
				{
				if (lo)
					ConvertLineToYUV_P8F2Y2(lpy0, lpy1, lpuv, pm, p.mwidth, 0, p.xfraction, lo);
				else
					ConvertLineToYUV_P8F2(lpy0, lpuv, pm, p.mwidth, 0, p.xfraction);
				}

			ycount += p.yfraction;
			pm += p.mbpr;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUV_P8DSY4(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy0, * lpy1, * lpy2, * lpy3, * lpuv;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	int hi, lo;
	MMXQShort * sinctabyt;

	if (p.yfraction == 0x10000 || p.xscale > 1)
		ConvertStripeToYUV_P8DS(p);
	else
		{
		sinctabyt = &(sinctabySet[0x100000 / p.yfraction][0]);

		switch (p.xscale)
			{
			case 0:
				for(y = p.ystart; y < p.ystop; y++)
					{
					hi = ycount >> 16;
					lo = (ycount >> 9) & 0x7f;

					lpuv = p.puv + ((hi & p.stripeMask) >> 1) * p.bpr;
					lpy1 = p.py + ((hi + 0) & p.stripeMask) * p.bpr;

					if (hi > 0)
						lpy0 = p.py + ((hi - 1) & p.stripeMask) * p.bpr;
					else
						lpy0 = p.py + ((hi + 0) & p.stripeMask) * p.bpr;

					if (hi < p.height - 2)
						{
						lpy2 = p.py + ((hi + 1) & p.stripeMask) * p.bpr;
						lpy3 = p.py + ((hi + 2) & p.stripeMask) * p.bpr;
						}
					else if (hi < p.height - 1)
						{
						lpy2 = lpy3 = p.py + ((hi + 1) & p.stripeMask) * p.bpr;
						}
					else
						{
						lpy2 = lpy3 = lpy1;
						}

					ConvertLineToYUV_P8D1Y4(lpy0, lpy1, lpy2, lpy3, lpuv, pm, p.width, sinctabyt[lo].a);

					ycount += p.yfraction;
					pm  += p.mbpr;
					}
				break;
			case 1:
				for(y = p.ystart; y < p.ystop; y++)
					{
					hi = ycount >> 16;
					lo = (ycount >> 9) & 0x7f;

					lpuv = p.puv + ((hi & p.stripeMask) >> 1) * p.bpr;
					lpy1 = p.py + ((hi + 0) & p.stripeMask) * p.bpr;

					if (hi > 0)
						lpy0 = p.py + ((hi - 1) & p.stripeMask) * p.bpr;
					else
						lpy0 = p.py + ((hi + 0) & p.stripeMask) * p.bpr;

					if (hi < p.height - 2)
						{
						lpy2 = p.py + ((hi + 1) & p.stripeMask) * p.bpr;
						lpy3 = p.py + ((hi + 2) & p.stripeMask) * p.bpr;
						}
					else if (hi < p.height - 1)
						{
						lpy2 = lpy3 = p.py + ((hi + 1) & p.stripeMask) * p.bpr;
						}
					else
						{
						lpy2 = lpy3 = lpy1;
						}

					ConvertLineToYUV_P8D2Y4(lpy0, lpy1, lpy2, lpy3, lpuv, pm, p.width, sinctabyt[lo].a);

					ycount += p.yfraction;
					pm  += p.mbpr;
					}
				break;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVThroughOSD_P8DSY4(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy0, * lpy1, * lpy2, * lpy3, * lpuv, * lpo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	int hi, lo;
	MMXQShort * sinctabyt;

	if (p.yfraction == 0x10000)
		ConvertStripeToYUV_P8F2(p);
	else
		{
		sinctabyt = &(sinctabySet[0x100000 / p.yfraction][0]);

		switch (p.xscale)
			{
			case 0:
				for(y = p.ystart; y < p.ystop; y++)
					{
					hi = ycount >> 16;
					lo = (ycount >> 9) & 0x7f;

					lpuv = p.puv + ((hi & p.stripeMask) >> 1) * p.bpr;
					lpy1 = p.py + ((hi + 0) & p.stripeMask) * p.bpr;

					if (hi > 0)
						lpy0 = p.py + ((hi - 1) & p.stripeMask) * p.bpr;
					else
						lpy0 = p.py + ((hi + 0) & p.stripeMask) * p.bpr;

					if (hi < p.height - 2)
						{
						lpy2 = p.py + ((hi + 1) & p.stripeMask) * p.bpr;
						lpy3 = p.py + ((hi + 2) & p.stripeMask) * p.bpr;
						}
					else if (hi < p.height - 1)
						{
						lpy2 = lpy3 = p.py + ((hi + 1) & p.stripeMask) * p.bpr;
						}
					else
						{
						lpy2 = lpy3 = lpy1;
						}

					if (hi >= p.yosdstart && hi < p.yosdstop)
						{
						lpo = p.po + p.obpr * (hi - p.yosdstart);

						ConvertLineToYUVWithOSD_P8D1Y4(lpy0, lpy1, lpy2, lpy3, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd, sinctabyt[lo].a);
						}
					else
						ConvertLineToYUV_P8D1Y4(lpy0, lpy1, lpy2, lpy3, lpuv, pm, p.width, sinctabyt[lo].a);

					ycount += p.yfraction;
					pm += p.mbpr;
					}
				break;
			case 1:
				for(y = p.ystart; y < p.ystop; y++)
					{
					hi = ycount >> 16;
					lo = (ycount >> 9) & 0x7f;

					lpuv = p.puv + ((hi & p.stripeMask) >> 1) * p.bpr;
					lpy1 = p.py + ((hi + 0) & p.stripeMask) * p.bpr;

					if (hi > 0)
						lpy0 = p.py + ((hi - 1) & p.stripeMask) * p.bpr;
					else
						lpy0 = p.py + ((hi + 0) & p.stripeMask) * p.bpr;

					if (hi < p.height - 2)
						{
						lpy2 = p.py + ((hi + 1) & p.stripeMask) * p.bpr;
						lpy3 = p.py + ((hi + 2) & p.stripeMask) * p.bpr;
						}
					else if (hi < p.height - 1)
						{
						lpy2 = lpy3 = p.py + ((hi + 1) & p.stripeMask) * p.bpr;
						}
					else
						{
						lpy2 = lpy3 = lpy1;
						}

					if (hi >= p.yosdstart && hi < p.yosdstop)
						{
						lpo = p.po + p.obpr * (hi - p.yosdstart);

						ConvertLineToYUVWithOSD_P8D2Y4(lpy0, lpy1, lpy2, lpy3, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd, sinctabyt[lo].a);
						}
					else
						ConvertLineToYUV_P8D2Y4(lpy0, lpy1, lpy2, lpy3, lpuv, pm, p.width, sinctabyt[lo].a);

					ycount += p.yfraction;
					pm += p.mbpr;
					}
				break;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUV_P8F2Y4(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy0, * lpy1, * lpy2, * lpy3, * lpuv;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	int hi, lo;
	MMXQShort * sinctabyt;

	if (p.yfraction == 0x10000)
		ConvertStripeToYUV_P8F2(p);
	else if (p.xfraction == 0x10000)
		ConvertStripeToYUV_P8DSY4(p);
	else
		{
		sinctabyt = &(sinctabySet[0x100000 / p.yfraction][0]);

		for(y = p.ystart; y < p.ystop; y++)
			{
			hi = ycount >> 16;
			lo = (ycount >> 9) & 0x7f;

			lpuv = p.puv + ((hi & p.stripeMask) >> 1) * p.bpr;
			lpy1 = p.py + ((hi + 0) & p.stripeMask) * p.bpr;

			if (hi > 0)
				lpy0 = p.py + ((hi - 1) & p.stripeMask) * p.bpr;
			else
				lpy0 = lpy1;

			if (hi < p.height - 2)
				{
				lpy2 = p.py + ((hi + 1) & p.stripeMask) * p.bpr;
				lpy3 = p.py + ((hi + 2) & p.stripeMask) * p.bpr;
				}
			else if (hi < p.height - 1)
				{
				lpy2 = lpy3 = p.py + ((hi + 1) & p.stripeMask) * p.bpr;
				}
			else
				{
				lpy2 = lpy3 = lpy1;
				}

			ConvertLineToYUV_P8D1Y4(lpy0, lpy1, lpy2, lpy3, lpuv, yuvcache, p.width, sinctabyt[lo].a);
			ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);

			ycount += p.yfraction;
			pm  += p.mbpr;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVThroughOSD_P8F2Y4(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy0, * lpy1, * lpy2, * lpy3, * lpuv, * lpo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	int hi, lo;
	MMXQShort * sinctabyt;

	if (p.yfraction == 0x10000)
		ConvertStripeToYUVThroughOSD_P8F2(p);
	else if (p.xfraction == 0x10000)
		ConvertStripeToYUVThroughOSD_P8DSY4(p);
	else
		{
		sinctabyt = &(sinctabySet[0x100000 / p.yfraction][0]);

		for(y = p.ystart; y < p.ystop; y++)
			{
			hi = ycount >> 16;
			lo = (ycount >> 9) & 0x7f;

			lpuv = p.puv + ((hi & p.stripeMask) >> 1) * p.bpr;
			lpy1 = p.py + ((hi + 0) & p.stripeMask) * p.bpr;

			if (hi > 0)
				lpy0 = p.py + ((hi - 1) & p.stripeMask) * p.bpr;
			else
				lpy0 = p.py + ((hi + 0) & p.stripeMask) * p.bpr;

			if (hi < p.height - 2)
				{
				lpy2 = p.py + ((hi + 1) & p.stripeMask) * p.bpr;
				lpy3 = p.py + ((hi + 2) & p.stripeMask) * p.bpr;
				}
			else if (hi < p.height - 1)
				{
				lpy2 = lpy3 = p.py + ((hi + 1) & p.stripeMask) * p.bpr;
				}
			else
				{
				lpy2 = lpy3 = lpy1;
				}

			if (hi >= p.yosdstart && hi < p.yosdstop)
				{
				lpo = p.po + p.obpr * (hi - p.yosdstart);

				ConvertLineToYUVWithOSD_P8D1Y4(lpy0, lpy1, lpy2, lpy3, lpuv, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd, sinctabyt[lo].a);
				}
			else
				ConvertLineToYUV_P8D1Y4(lpy0, lpy1, lpy2, lpy3, lpuv, yuvcache, p.width, sinctabyt[lo].a);

			ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);

			ycount += p.yfraction;
			pm += p.mbpr;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUV_P8F4(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	MMXQShort * sinctabxt;

	if (p.xfraction == 0x10000)
		{
		ConvertStripeToYUV_P8DS(p);
		}
	else
		{
		sinctabxt = &(sinctabxSet[0x100000 / p.xfraction][0]);

		for(y = p.ystart; y < p.ystop; y++)
			{
			hi = (ycount >> 16) & p.stripeMask;

			lpy = p.py + p.bpr * hi;
			lpuv = p.puv + p.bpr * (hi >> 1);

			ConvertLineToYUV_P8F4(lpy, lpuv, pm, p.mwidth, 0, p.xfraction, sinctabxt);

			ycount += p.yfraction;
			pm += p.mbpr;
			}
		}
	}


void XMMXYUVVideoConverter::ConvertStripeToYUVThroughOSD_P8F4(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv, * lpo;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	MMXQShort * sinctabxt;

	if (p.xfraction == 0x10000)
		{
		ConvertStripeToYUVThroughOSD_P8DS(p);
		}
	else
		{
		sinctabxt = &(sinctabxSet[0x100000 / p.xfraction][0]);

		for(y = p.ystart; y < p.ystop; y++)
			{
			hi = ycount >> 16;

			lpy = p.py + p.bpr * (hi & p.stripeMask);
			lpuv = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);

			if (hi >= p.yosdstart && hi < p.yosdstop)
				{
				lpo = p.po + p.obpr * (hi - p.yosdstart);

				ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);

				ScaleYUVLine_P8F4(yuvcache, pm, p.mwidth, 0, p.xfraction, sinctabxt);
				}
			else
				{
				ConvertLineToYUV_P8F4(lpy, lpuv, pm, p.mwidth, 0, p.xfraction, sinctabxt);
				}

			ycount += p.yfraction;
			pm += p.mbpr;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUV_P8F4Y2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy0, * lpy1, * lpuv;
	int hi, lo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	MMXQShort * sinctabxt;

	if (p.yfraction == 0x10000)
		ConvertStripeToYUV_P8F4(p);
	else if (p.xfraction == 0x10000)
		ConvertStripeToYUV_P8DSY2(p);
	else
		{
		sinctabxt = &(sinctabxSet[0x100000 / p.xfraction][0]);

		for(y = p.ystart; y < p.ystop; y++)
			{
			hi = (ycount >> 16) & p.stripeMask;
			lo = (ycount & 0xffff) >> 8;

			lpy0 = p.py + p.bpr * hi;
			lpy1 = p.py + p.bpr * ((hi + 1) & p.stripeMask);

			lpuv = p.puv + p.bpr * (hi >> 1);

			if (lo)
				{
				ConvertLineToYUV_P8D1Y2(lpy0, lpy1, lpuv, yuvcache, p.width, lo);
				ScaleYUVLine_P8F4(yuvcache, pm, p.mwidth, 0, p.xfraction, sinctabxt);
				}
			else
				ConvertLineToYUV_P8F4(lpy0, lpuv, pm, p.mwidth, 0, p.xfraction, sinctabxt);

			ycount += p.yfraction;
			pm += p.mbpr;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVThroughOSD_P8F4Y2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy0, * lpy1, * lpuv, * lpo;
	int hi, lo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	MMXQShort * sinctabxt;

	if (p.yfraction == 0x10000)
		ConvertStripeToYUVThroughOSD_P8F4(p);
	else if (p.xfraction == 0x10000)
		ConvertStripeToYUVThroughOSD_P8DSY2(p);
	else
		{
		sinctabxt = &(sinctabxSet[0x100000 / p.xfraction][0]);

		for(y = p.ystart; y < p.ystop; y++)
			{
			hi = ycount >> 16;
			lo = (ycount & 0xffff) >> 8;

			lpy0 = p.py + p.bpr * (hi & p.stripeMask);
			lpy1 = p.py + p.bpr * ((hi + 1) & p.stripeMask);

			lpuv = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);

			if (hi >= p.yosdstart && hi < p.yosdstop)
				{
				lpo = p.po + p.obpr * (hi - p.yosdstart);

				if (lo)
					ConvertLineToYUVWithOSD_P8D1Y2(lpy0, lpy1, lpuv, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd, lo);
				else
					ConvertLineToYUVWithOSD_P8D1(lpy0, lpuv, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);

				ScaleYUVLine_P8F4(yuvcache, pm, p.mwidth, 0, p.xfraction, sinctabxt);
				}
			else
				{
				if (lo)
					{
					ConvertLineToYUV_P8D1Y2(lpy0, lpy1, lpuv, yuvcache, p.width, lo);
					ScaleYUVLine_P8F4(yuvcache, pm, p.mwidth, 0, p.xfraction, sinctabxt);
					}
				else
					ConvertLineToYUV_P8F4(lpy0, lpuv, pm, p.mwidth, 0, p.xfraction, sinctabxt);
				}

			ycount += p.yfraction;
			pm += p.mbpr;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUV_P8F4Y4(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy0, * lpy1, * lpy2, * lpy3, * lpuv;
	int hi, lo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	MMXQShort * sinctabyt;
	MMXQShort * sinctabxt;

	if (p.yfraction == 0x10000)
		ConvertStripeToYUV_P8F4(p);
	else if (p.xfraction == 0x10000)
		ConvertStripeToYUV_P8DSY4(p);
	else
		{
		sinctabyt = &(sinctabySet[0x100000 / p.yfraction][0]);
		sinctabxt = &(sinctabxSet[0x100000 / p.xfraction][0]);

		for(y = p.ystart; y < p.ystop; y++)
			{
			hi = ycount >> 16;
			lo = (ycount >> 9) & 0x7f;

			lpuv = p.puv + ((hi & p.stripeMask) >> 1) * p.bpr;
			lpy1 = p.py + ((hi + 0) & p.stripeMask) * p.bpr;

			if (hi > 0)
				lpy0 = p.py + ((hi - 1) & p.stripeMask) * p.bpr;
			else
				lpy0 = lpy1;

			if (hi < p.height - 2)
				{
				lpy2 = p.py + ((hi + 1) & p.stripeMask) * p.bpr;
				lpy3 = p.py + ((hi + 2) & p.stripeMask) * p.bpr;
				}
			else if (hi < p.height - 1)
				{
				lpy2 = lpy3 = p.py + ((hi + 1) & p.stripeMask) * p.bpr;
				}
			else
				{
				lpy2 = lpy3 = lpy1;
				}

			ConvertLineToYUV_P8D1Y4(lpy0, lpy1, lpy2, lpy3, lpuv, yuvcache, p.width, sinctabyt[lo].a);
			ScaleYUVLine_P8F4(yuvcache, pm, p.mwidth, 0, p.xfraction, sinctabxt);

			ycount += p.yfraction;
			pm  += p.mbpr;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVThroughOSD_P8F4Y4(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpuv, * lpo, * lpy0, * lpy1, * lpy2, * lpy3;
	int hi, lo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	MMXQShort * sinctabyt;
	MMXQShort * sinctabxt;

	if (p.yfraction == 0x10000)
		ConvertStripeToYUVThroughOSD_P8F4(p);
	else if (p.xfraction == 0x10000)
		ConvertStripeToYUVThroughOSD_P8DSY4(p);
	else
		{
		sinctabyt = &(sinctabySet[0x100000 / p.yfraction][0]);
		sinctabxt = &(sinctabxSet[0x100000 / p.xfraction][0]);

		for(y = p.ystart; y < p.ystop; y++)
			{
			hi = ycount >> 16;
			lo = (ycount >> 9) & 0x7f;

			lpuv = p.puv + ((hi & p.stripeMask) >> 1) * p.bpr;
			lpy1 = p.py + ((hi + 0) & p.stripeMask) * p.bpr;

			if (hi > 0)
				lpy0 = p.py + ((hi - 1) & p.stripeMask) * p.bpr;
			else
				lpy0 = p.py + ((hi + 0) & p.stripeMask) * p.bpr;

			if (hi < p.height - 2)
				{
				lpy2 = p.py + ((hi + 1) & p.stripeMask) * p.bpr;
				lpy3 = p.py + ((hi + 2) & p.stripeMask) * p.bpr;
				}
			else if (hi <p. height - 1)
				{
				lpy2 = lpy3 = p.py + ((hi + 1) & p.stripeMask) * p.bpr;
				}
			else
				{
				lpy2 = lpy3 = lpy1;
				}

			if (hi >= p.yosdstart && hi < p.yosdstop)
				{
				lpo = p.po + p.obpr * (hi - p.yosdstart);

				ConvertLineToYUVWithOSD_P8D1Y4(lpy0, lpy1, lpy2, lpy3, lpuv, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd, sinctabyt[lo].a);
				}
			else
				ConvertLineToYUV_P8D1Y4(lpy0, lpy1, lpy2, lpy3, lpuv, yuvcache, p.width, sinctabyt[lo].a);

			ScaleYUVLine_P8F4(yuvcache, pm, p.mwidth, 0, p.xfraction, sinctabxt);

			ycount += p.yfraction;
			pm += p.mbpr;
			}
		}
	}

#define PANSCAN_FRACTION		0xc000

void XMMXYUVVideoConverter::ConvertStripeToYUVPS_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv;
	int hi;
	BYTE * pm = p.pm;
	int ycount = p.ycount;

	if (p.xfraction == 0x10000)
		{
		for(y = p.ystart; y < p.ystop; y++)
			{
			hi = (ycount >> 16) & p.stripeMask;

			lpy = p.py + p.bpr * hi;
			lpuv = p.puv + p.bpr * (hi >> 1);

			ConvertLineToYUV_P8F2(lpy, lpuv, pm, p.mwidth, p.xoffset, PANSCAN_FRACTION);

			ycount += p.yfraction;
			pm += p.mbpr;
			}
		}
	}


void XMMXYUVVideoConverter::ConvertStripeToYUVPSThroughOSD_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv, * lpo;
	int hi;
	BYTE * pm = p.pm;
	int ycount = p.ycount;

	if (p.xfraction == 0x10000)
		{
		for(y = p.ystart; y < p.ystop; y++)
			{
			hi = ycount >> 16;

			lpuv = p.puv + ((hi & p.stripeMask) >> 1) * p.bpr;
			lpy = p.py + ((hi + 0) & p.stripeMask) * p.bpr;

			if (hi >= p.yosdstart && hi < p.yosdstop)
				{
				lpo = p.po + p.obpr * (hi - p.yosdstart);

				ConvertLineToYUV_P8F2WithOSD(lpy, lpuv, pm, p.width, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
				}
			else
				ConvertLineToYUV_P8F2(lpy, lpuv, pm, p.mwidth, p.xoffset, PANSCAN_FRACTION);

			ycount += p.yfraction;
			pm += p.mbpr;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVPSAI_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	if (p.xfraction == 0x10000)
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;

			lpy  = p.py  + p.bpr * hi;
			lpuv = p.puv + p.bpr * (hi >> 1);

			if (hi >= 2 && hi < p.height - 1)
				{
				ConvertLineToYUV_P8D1MV(lpy - p.bpr, lpuv - p.bpr, p.bpr, yuvcache, p.width);
				ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, p.xoffset, PANSCAN_FRACTION);
				}
			else
				ConvertLineToYUV_P8F2(lpy, lpuv, pm, p.mwidth, p.xoffset, PANSCAN_FRACTION);

			pm += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVPSAIThroughOSD_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv, * lpo;
	int hi, yo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	if (p.xfraction == 0x10000)
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;

			lpy  = p.py  + p.bpr * hi;
			lpuv = p.puv + p.bpr * (hi >> 1);

			yo = hi - p.yosdoffset;

			if (hi >= 2 && hi < p.height - 1)
				ConvertLineToYUV_P8D1MV(lpy - p.bpr, lpuv - p.bpr, p.bpr, yuvcache, p.width);
			else
				ConvertLineToYUV_P8D1(lpy, lpuv, yuvcache, p.width);

			if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
				{
				lpo = p.po + p.obpr * (hi - p.yosdstart);

				ScaleYUVLine_P8F2WithOSD(yuvcache, pm, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
				}
			else
				{
				ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, p.xoffset, PANSCAN_FRACTION);
				}


			pm += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}



// new-> 01/25/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVPSDI2_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv, * lppuv, * lpytb, * lpuvtb;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	BYTE * ppm = p.ppm;
	BYTE * pmt = p.pmt;
	BYTE * pmb = p.pmb;
	int dbpr = p.bpr * 2;

	if (p.xfraction == 0x10000)
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;

			lpy  = p.py  + p.bpr * (hi & ~1);
			lppy = p.ppy + p.bpr * (hi & ~1);
			lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);
			lpytb = p.pytb + p.bpr * (hi & ~1);
			lpuvtb = p.puvtb + p.bpr * ((hi >> 1) & ~1);

			if (hi < p.height - 4)
				{
				switch (hi & 3)
					{
					case 0:
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							ConvertLineToYUV_P8F2(lpytb, lpuvtb, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION);
						break;
					case 1:
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							{
							ConvertLineToYUV_P8D1I4(lpy, lpuv, lppy, p.bpr, yuvcache, p.width);
							ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, p.xoffset, PANSCAN_FRACTION);
							}
						break;
					case 2:
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							{
							ConvertLineToYUV_P8D1MUV(lpytb, lpuvtb, yuvcache, p.width, p.bpr);
							ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION);
							}
						break;
					case 3:
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							{
							ConvertLineToYUV_P8D1I4MUV(lpy, lpuv, lppy, p.bpr, yuvcache, p.width);
							ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, p.xoffset, PANSCAN_FRACTION);
							}
						break;
					}
				}
			else
				{
				if ((hi & 1) != 0)
					{
					if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
						ConvertLineToYUV_P8F2(lpy, lpuv, pm, p.mwidth, p.xoffset, PANSCAN_FRACTION);
					}
				else
					{
					if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
						ConvertLineToYUV_P8F2(lpytb, lpuvtb, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION);
					}
				}

			hi = ycount >> 16;

			lpy   = p.py   + p.bpr * (hi | 1);
			lppy  = p.ppy  + p.bpr * (hi | 1);
			lppuv = p.ppuv + p.bpr * ((hi >> 1) | 1);
			lpytb = p.pytb + p.bpr * (hi | 1);
			lpuvtb = p.puvtb + p.bpr * ((hi >> 1) | 1);

			if (hi >= 4)
				{
				switch (hi & 3)
					{
					case 0:
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							{
							ConvertLineToYUV_P8D1I4MUV(lppy - dbpr, lppuv - dbpr, lpy - dbpr, p.bpr, yuvcache, p.width);
							ScaleYUVLine_P8F2(yuvcache, ppm, p.mwidth, p.xoffset, PANSCAN_FRACTION);
							}
						break;
					case 1:
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							{
							ConvertLineToYUV_P8D1MUV(lpytb, lpuvtb - dbpr, yuvcache, p.width, p.bpr);
							ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION);
							}
						break;
					case 2:
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							{
							ConvertLineToYUV_P8D1I4(lppy - dbpr, lppuv, lpy - dbpr, p.bpr, yuvcache, p.width);
							ScaleYUVLine_P8F2(yuvcache, ppm, p.mwidth, p.xoffset, PANSCAN_FRACTION);
							}
						break;
					case 3:
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							ConvertLineToYUV_P8F2(lpytb, lpuvtb, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION);
						break;
					}
				}
			else
				{
				if ((hi & 1) == 0)
					{
					if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
						ConvertLineToYUV_P8F2(lppy, lppuv, ppm, p.mwidth, p.xoffset, PANSCAN_FRACTION);
					}
				else
					{
					if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
						ConvertLineToYUV_P8F2(lpytb, lpuvtb, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION);
					}
				}

			pm += p.mbpr;
			ppm += p.mbpr;
			pmb += p.mbpr;
			pmt += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}
// <-new 01/25/2000

// new-> 01/25/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVPSDI2ThroughOSD_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv, * lppuv, * lpytb, * lpuvtb, * lpo;
	int hi, yo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	BYTE * ppm = p.ppm;
	BYTE * pmt = p.pmt;
	BYTE * pmb = p.pmb;
	int dbpr = p.bpr * 2;

	if (p.xfraction == 0x10000)
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;

			lpy  = p.py  + p.bpr * (hi & ~1);
			lppy = p.ppy + p.bpr * (hi & ~1);
			lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);
			lpytb = p.pytb + p.bpr * (hi & ~1);
			lpuvtb = p.puvtb + p.bpr * ((hi >> 1) & ~1);

			yo = hi - p.yosdoffset;

			if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
				{
				lpo = p.po + p.obpr * (hi - p.yosdstart);

				if (hi < p.height - 4)
					{
					switch (hi & 3)
						{
						case 0:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								{
								ConvertLineToYUV_P8D1(lpytb, lpuvtb, yuvcache, p.width);
								ScaleYUVLine_P8F2WithOSD(yuvcache, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
								}
							break;
						case 1:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1I4(lpy, lpuv, lppy, p.bpr, yuvcache, p.width);
								ScaleYUVLine_P8F2WithOSD(yuvcache, pm, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
								}
							break;
						case 2:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								{
								ConvertLineToYUV_P8D1(lpytb, lpuvtb, yuvcache, p.width);
								ScaleYUVLine_P8F2WithOSD(yuvcache, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
								}
							break;
						case 3:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1I4(lpy, lpuv, lppy, p.bpr, yuvcache, p.width);
								ScaleYUVLine_P8F2WithOSD(yuvcache, pm, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
								}
							break;
						}
					}
				else
					{
					if ((hi & 1) != 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							{
							ConvertLineToYUV_P8D1(lpy, lpuv, yuvcache, p.width);
							ScaleYUVLine_P8F2WithOSD(yuvcache, pm, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							{
							ConvertLineToYUV_P8D1(lpytb, lpuvtb, yuvcache, p.width);
							ScaleYUVLine_P8F2WithOSD(yuvcache, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						}
					}
				}
			else
				{
				if (hi < p.height - 4)
					{
					switch (hi & 3)
						{
						case 0:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUV_P8F2(lpytb, lpuvtb, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION);
							break;
						case 1:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1I4(lpy, lpuv, lppy, p.bpr, yuvcache, p.width);
								ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, p.xoffset, PANSCAN_FRACTION);
								}
							break;
						case 2:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								{
								ConvertLineToYUV_P8D1MUV(lpytb, lpuvtb, yuvcache, p.width, p.bpr);
								ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION);
								}
							break;
						case 3:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1I4MUV(lpy, lpuv, lppy, p.bpr, yuvcache, p.width);
								ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, p.xoffset, PANSCAN_FRACTION);
								}
							break;
						}
					}
				else
					{
					if ((hi & 1) != 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							ConvertLineToYUV_P8F2(lpy, lpuv, pm, p.mwidth, p.xoffset, PANSCAN_FRACTION);
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							ConvertLineToYUV_P8F2(lpytb, lpuvtb, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION);
						}
					}
				}

			hi = ycount >> 16;

			lpy   = p.py   + p.bpr * (hi | 1);
			lppy  = p.ppy  + p.bpr * (hi | 1);
			lppuv = p.ppuv + p.bpr * ((hi >> 1) | 1);
			lpytb = p.pytb + p.bpr * (hi | 1);
			lpuvtb = p.puvtb + p.bpr * ((hi >> 1) | 1);

			if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
				{
				lpo = p.po + p.obpr * (hi - p.yosdstart);

				if (hi < p.height - 4 && hi >= 4)
//				if (hi < p.height - 4)
					{
					switch (hi & 3)
						{
						case 0:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1I4(lppy - dbpr, lppuv - dbpr, lpy - dbpr, p.bpr, yuvcache, p.width);
								ScaleYUVLine_P8F2WithOSD(yuvcache, ppm, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
								}
							break;
						case 1:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								{
								ConvertLineToYUV_P8D1(lpytb, lpuvtb, yuvcache, p.width);
								ScaleYUVLine_P8F2WithOSD(yuvcache, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
								}
							break;
						case 2:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1I4(lppy - dbpr, lppuv, lpy - dbpr, p.bpr, yuvcache, p.width);
								ScaleYUVLine_P8F2WithOSD(yuvcache, ppm, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
								}
							break;
						case 3:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								{
								ConvertLineToYUV_P8D1(lpytb, lpuvtb, yuvcache, p.width);
								ScaleYUVLine_P8F2WithOSD(yuvcache, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
								}
							break;
						}
					}
				else
					{
					if ((hi & 1) != 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							{
							ConvertLineToYUV_P8D1(lppy, lppuv, yuvcache, p.width);
							ScaleYUVLine_P8F2WithOSD(yuvcache, ppm, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							{
							ConvertLineToYUV_P8D1(lpytb, lpuvtb, yuvcache, p.width);
							ScaleYUVLine_P8F2WithOSD(yuvcache, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						}
					}
				}
			else
				{
				if (hi >= 4)
					{
					switch (hi & 3)
						{
						case 0:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1I4MUV(lppy - dbpr, lppuv - dbpr, lpy - dbpr, p.bpr, yuvcache, p.width);
								ScaleYUVLine_P8F2(yuvcache, ppm, p.mwidth, p.xoffset, PANSCAN_FRACTION);
								}
							break;
						case 1:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								{
								ConvertLineToYUV_P8D1MUV(lpytb, lpuvtb - dbpr, yuvcache, p.width, p.bpr);
								ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION);
								}
							break;
						case 2:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1I4(lppy - dbpr, lppuv, lpy - dbpr, p.bpr, yuvcache, p.width);
								ScaleYUVLine_P8F2(yuvcache, ppm, p.mwidth, p.xoffset, PANSCAN_FRACTION);
								}
							break;
						case 3:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUV_P8F2(lpytb, lpuvtb, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION);
							break;
						}
					}
				else
					{
					if ((hi & 1) == 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							ConvertLineToYUV_P8F2(lppy, lppuv, ppm, p.mwidth, p.xoffset, PANSCAN_FRACTION);
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							ConvertLineToYUV_P8F2(lpytb, lpuvtb, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION);
						}
					}
				}

			pm += p.mbpr;
			ppm += p.mbpr;
			pmb += p.mbpr;
			pmt += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}
// <-new 01/25/2000

// new-> 01/25/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVPSA2_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv, * lppuv;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	if (p.xfraction == 0x10000)
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;

			lpy   = p.py   + p.bpr * hi;
			lppy  = p.ppy  + p.bpr * hi;
			lpuv  = p.puv  + p.bpr * (hi >> 1);
			lppuv = p.ppuv + p.bpr * (hi >> 1);

			ConvertLineToYUV_P8D1M(lpy, lpuv, lppy, lppuv, yuvcache, p.width);
			ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, p.xoffset, PANSCAN_FRACTION);

			pm += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}
// <-new 01/25/2000

// new-> 01/25/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVPSA2ThroughOSD_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv, * lppuv, * lpo;
	int hi, yo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	if (p.xfraction == 0x10000)
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;

			lpy   = p.py   + p.bpr * hi;
			lppy  = p.ppy  + p.bpr * hi;
			lpuv  = p.puv  + p.bpr * (hi >> 1);
			lppuv = p.ppuv + p.bpr * (hi >> 1);

			yo = hi - p.yosdoffset;

			ConvertLineToYUV_P8D1M(lpy, lpuv, lppy, lppuv, yuvcache, p.width);

			if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
				{
				lpo = p.po + p.obpr * (hi - p.yosdstart);

				ScaleYUVLine_P8F2WithOSD(yuvcache, pm, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
				}
			else
				ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, p.xoffset, PANSCAN_FRACTION);

			pm += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}
// <-new 01/25/2000

// new-> 01/25/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVPSSI2_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv;
	int hi;
	int ycount = p.ycount;
	BYTE * pmt = p.pmt;
	BYTE * pmb = p.pmb;
	int dbpr = p.bpr * 2;

	if (p.xfraction == 0x10000)
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;

			lpy  = p.py  + p.bpr * (hi & ~1);
			lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

			if (hi < p.height - 4 && hi >= 4)
				{
				switch (hi & 3)
					{
					case 0:
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							ConvertLineToYUV_P8F2(lpy, lpuv, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION);
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							{
							ConvertLineToYUV_P8D1MYUV(lpy - p.bpr, lpuv - p.bpr, yuvcache, p.width, p.bpr);
							ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION);
							}
						break;
					case 1:
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							{
							ConvertLineToYUV_P8D1MY(lpy, lpuv, yuvcache, p.width, p.bpr);
							ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION);
							}
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							{
							ConvertLineToYUV_P8D1MUV(lpy + p.bpr, lpuv - p.bpr, yuvcache, p.width, p.bpr);
							ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION);
							}
						break;
					case 2:
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							{
							ConvertLineToYUV_P8D1MUV(lpy, lpuv, yuvcache, p.width, p.bpr);
							ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION);
							}
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							{
							ConvertLineToYUV_P8D1MY(lpy - p.bpr, lpuv + p.bpr, yuvcache, p.width, p.bpr);
							ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION);
							}
						break;
					case 3:
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							{
							ConvertLineToYUV_P8D1MYUV(lpy, lpuv, yuvcache, p.width, p.bpr);
							ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION);
							}
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							ConvertLineToYUV_P8F2(lpy + p.bpr, lpuv + p.bpr, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION);
						break;
					}
				}
			else
				{
				if ((hi & 1) != 0)
					{
					if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
						ConvertLineToYUV_P8F2(lpy, lpuv, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION);
					if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
						ConvertLineToYUV_P8F2(lpy + p.bpr, lpuv + p.bpr, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION);
					}
				else
					{
					if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
						ConvertLineToYUV_P8F2(lpy, lpuv, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION);
					if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
						ConvertLineToYUV_P8F2(lpy + p.bpr, lpuv + p.bpr, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION);
					}
				}

			pmb += p.mbpr;
			pmt += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}
// <-new 01/25/2000

// new-> 01/25/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVPSSI2ThroughOSD_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv, * lpo;
	int hi, yo;
	int ycount = p.ycount;
	BYTE * pmt = p.pmt;
	BYTE * pmb = p.pmb;
	int dbpr = p.bpr * 2;

	if	(p.xfraction == 0x10000)
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;

			lpy  = p.py  + p.bpr * (hi & ~1);
			lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

			yo = hi - p.yosdoffset;

			if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
				{
				lpo = p.po + p.obpr * (hi - p.yosdstart);

				if (hi < p.height - 4 && hi >= 4)
					{
					switch (hi & 3)
						{
						case 0:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								{
								ConvertLineToYUV_P8D1(lpy, lpuv, yuvcache, p.width);
								ScaleYUVLine_P8F2WithOSD(yuvcache, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
								}
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1MYUV(lpy - p.bpr, lpuv - p.bpr, yuvcache, p.width, p.bpr);
								ScaleYUVLine_P8F2WithOSD(yuvcache, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
								}
							break;
						case 1:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1MY(lpy, lpuv, yuvcache, p.width, p.bpr);
								ScaleYUVLine_P8F2WithOSD(yuvcache, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
								}
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								{
								ConvertLineToYUV_P8D1MUV(lpy + p.bpr, lpuv - p.bpr, yuvcache, p.bpr, p.width);
								ScaleYUVLine_P8F2WithOSD(yuvcache, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
								}
							break;
						case 2:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								{
								ConvertLineToYUV_P8D1MUV(lpy, lpuv, yuvcache, p.bpr, p.width);
								ScaleYUVLine_P8F2WithOSD(yuvcache, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
								}
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1MY(lpy - p.bpr, lpuv + p.bpr, yuvcache, p.width, p.bpr);
								ScaleYUVLine_P8F2WithOSD(yuvcache, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
								}
							break;
						case 3:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1MYUV(lpy, lpuv, yuvcache, p.width, p.bpr);
								ScaleYUVLine_P8F2WithOSD(yuvcache, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
								}
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								{
								ConvertLineToYUV_P8D1(lpy + p.bpr, lpuv + p.bpr, yuvcache, p.width);
								ScaleYUVLine_P8F2WithOSD(yuvcache, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
								}
							break;
						}
					}
				else
					{
					if ((hi & 1) != 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							{
							ConvertLineToYUV_P8D1(lpy, lpuv, yuvcache, p.width);
							ScaleYUVLine_P8F2WithOSD(yuvcache, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							{
							ConvertLineToYUV_P8D1(lpy + p.bpr, lpuv + p.bpr, yuvcache, p.width);
							ScaleYUVLine_P8F2WithOSD(yuvcache, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							{
							ConvertLineToYUV_P8D1(lpy, lpuv, yuvcache, p.width);
							ScaleYUVLine_P8F2WithOSD(yuvcache, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							{
							ConvertLineToYUV_P8D1(lpy + p.bpr, lpuv + p.bpr, yuvcache, p.width);
							ScaleYUVLine_P8F2WithOSD(yuvcache, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						}
					}
				}
			else
				{
				if (hi < p.height - 4 && hi >= 4)
					{
					switch (hi & 3)
						{
						case 0:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUV_P8F2(lpy, lpuv, pmt, p.mwidth, 0, p.xfraction);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1MYUV(lpy - p.bpr, lpuv - p.bpr, yuvcache, p.width, p.bpr);
								ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION);
								}
							break;
						case 1:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1MY(lpy, lpuv, yuvcache, p.width, p.bpr);
								ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION);
								}
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								{
								ConvertLineToYUV_P8D1MUV(lpy + p.bpr, lpuv - p.bpr, yuvcache, p.width, p.bpr);
								ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION);
								}
							break;
						case 2:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								{
								ConvertLineToYUV_P8D1MUV(lpy, lpuv, yuvcache, p.width, p.bpr);
								ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION);
								}
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1MY(lpy - p.bpr, lpuv + p.bpr, yuvcache, p.width, p.bpr);
								ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION);
								}
							break;
						case 3:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1MYUV(lpy, lpuv, yuvcache, p.width, p.bpr);
								ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION);
								}
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUV_P8F2(lpy + p.bpr, lpuv + p.bpr, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION);
							break;
						}
					}
				else
					{
					if ((hi & 1) != 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							ConvertLineToYUV_P8F2(lpy, lpuv, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION);
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							ConvertLineToYUV_P8F2(lpy + p.bpr, lpuv + p.bpr, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION);
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							ConvertLineToYUV_P8F2(lpy, lpuv, pmt, p.mwidth, p.xoffset, PANSCAN_FRACTION);
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							ConvertLineToYUV_P8F2(lpy + p.bpr, lpuv + p.bpr, pmb, p.mwidth, p.xoffset, PANSCAN_FRACTION);
						}
					}
				}

			pmb += p.mbpr;
			pmt += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}
// <-new 01/25/2000



void XMMXYUVVideoConverter::ConvertStripeToYUVLB_P8DSY2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy0, * lpy1, * lpuv;
	int lhi, llo;
	int sstart = p.lboffset << 16;
	int lycount;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	switch (p.xscale)
		{
		case 0:
			for(y = p.ystart; y < p.ystop; y++)
				{
				lycount = (((ycount - sstart) >> 8) * 5461) >> 4;

				lhi = (lycount >> 16) & p.stripeMask;
				llo = (lycount & 0xffff) >> 8;

				if (lhi >= 0 && lhi < p.height - 1)
					{
					lpy0 = p.py + p.bpr * lhi;
					lpy1 = p.py + p.bpr * ((lhi + 1) & p.stripeMask);

					lpuv = p.puv + p.bpr * (lhi >> 1);

					if (llo)
						ConvertLineToYUV_P8D1Y2(lpy0, lpy1, lpuv, pm, p.width, llo);
					else
						ConvertLineToYUV_P8D1(lpy0, lpuv, pm, p.width);
					}
				else
					{
					BlackOutLine(pm, p.width);
					}

				ycount += p.yfraction;
				pm += p.mbpr;
				}
			break;
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVLBThroughOSD_P8DSY2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpuv, * lpo, * lpy0, * lpy1;
	int hi, lo;
	int lhi, llo;
	int sstart = p.lboffset << 16;
	int lycount;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	switch (p.xscale)
		{
		case 0:
			for(y = p.ystart; y < p.ystop; y++)
				{
				hi = ycount >> 16;
				lo = (ycount & 0xffff) >> 8;

				lycount = (((ycount - sstart) >> 8) * 5461) >> 4;

				lhi = (lycount >> 16) & p.stripeMask;
				llo = (lycount & 0xffff) >> 8;

				if (lhi >= 0 && lhi < p.height - 1)
					{
					lpy0 = p.py + p.bpr * (lhi & p.stripeMask);
					lpy1 = p.py + p.bpr * ((lhi + 1) & p.stripeMask);

					lpuv = p.puv + p.bpr * ((lhi & p.stripeMask) >> 1);


					if (hi >= p.yosdstart && hi < p.yosdstop)
						{
						lpo = p.po + p.obpr * (hi - p.yosdstart);

						if (llo)
							ConvertLineToYUVWithOSD_P8D1Y2(lpy0, lpy1, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd, llo);
						else
							ConvertLineToYUVWithOSD_P8D1(lpy0, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
						}
					else
						{
						if (llo)
							ConvertLineToYUV_P8D1Y2(lpy0, lpy1, lpuv, pm, p.width, llo);
						else
							ConvertLineToYUV_P8D1(lpy0, lpuv, pm, p.width);
						}
					}
				else
					{
					if (hi >= p.yosdstart && hi < p.yosdstop)
						{
						lpo = p.po + p.obpr * (hi - p.yosdstart);

						BlackOutLine(pm, p.xosdstart);
						BlackOutLineThroughOSD(pm + (p.xosdstart << 1), p.xosdstop - p.xosdstart, lpo, p.dd);
						BlackOutLine(pm + (p.xosdstop << 1), p.width - p.xosdstop);
						}
					else
						{
						BlackOutLine(pm, p.width);
						}

					}

				ycount += p.yfraction;
				pm += p.mbpr;
				}
			break;
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVLBAI_P8DSY2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv;
	int lhi, llo;
	int sstart = p.lboffset << 16;
	int lycount;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	short filter[4];

	switch (p.xscale)
		{
		case 0:
			for(y = p.ystart; y < p.ystop; y++)
				{
				lycount = (((ycount - sstart) >> 8) * 5461) >> 4;

				lhi = lycount >> 16;
				llo = lycount & 0xffff;

				if (lhi >= 0 && lhi < p.height - 1)
					{
					lpy  = p.py  + p.bpr * lhi;
					lpuv = p.puv + p.bpr * (lhi >> 1);

					if (lhi >= 2 && lhi < p.height - 2)
						{
						filter[0] = (0x10000 - llo) >> 12;
						filter[1] = (0x10000 + llo) >> 12;
						filter[2] = (0x20000 - llo) >> 12;
						filter[3] = (0x00000 + llo) >> 12;

						ConvertLineToYUV_P8D1Y4MUV(lpy - p.bpr, lpy + p.bpr, lpy, lpy + 2 * p.bpr, lpuv - p.bpr, lpuv, pm, p.width, filter);
						}
					else
						ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
					}
				else
					{
					BlackOutLine(pm, p.width);
					}

				ycount += p.yfraction;
				pm += p.mbpr;
				}
			break;
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVLBAIThroughOSD_P8DSY2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpuv, * lpo, * lpy;
	int hi, lo;
	int lhi, llo;
	int sstart = p.lboffset << 16;
	int lycount;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	short filter[4];

	switch (p.xscale)
		{
		case 0:
			for(y = p.ystart; y < p.ystop; y++)
				{
				hi = ycount >> 16;
				lo = (ycount & 0xffff) >> 8;

				lycount = (((ycount - sstart) >> 8) * 5461) >> 4;

				lhi = lycount >> 16;
				llo = lycount & 0xffff;

				if (lhi >= 0 && lhi < p.height - 1)
					{
					lpy  = p.py  + p.bpr *  lhi;
					lpuv = p.puv + p.bpr * (lhi  >> 1);

					filter[0] = (0x10000 - llo) >> 12;
					filter[1] = (0x10000 + llo) >> 12;
					filter[2] = (0x20000 - llo) >> 12;
					filter[3] = (0x00000 + llo) >> 12;

					if (hi >= p.yosdstart && hi < p.yosdstop)
						{
						lpo = p.po + p.obpr * (hi - p.yosdstart);

						if (lhi >= 2 && lhi < p.height - 2)
							ConvertLineToYUVWithOSD_P8D1Y4MUV(lpy - p.bpr, lpy + p.bpr, lpy, lpy + 2 * p.bpr, lpuv - p.bpr, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd, filter);
						else
							ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
						}
					else
						{
						if (lhi >= 2 && lhi < p.height - 2)
							ConvertLineToYUV_P8D1Y4MUV(lpy - p.bpr, lpy + p.bpr, lpy, lpy + 2 * p.bpr, lpuv - p.bpr, lpuv, pm, p.width, filter);
						else
							ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
						}
					}
				else
					{
					if (hi >= p.yosdstart && hi < p.yosdstop)
						{
						lpo = p.po + p.obpr * (hi - p.yosdstart);

						BlackOutLine(pm, p.xosdstart);
						BlackOutLineThroughOSD(pm + (p.xosdstart << 1), p.xosdstop - p.xosdstart, lpo, p.dd);
						BlackOutLine(pm + (p.xosdstop << 1), p.width - p.xosdstop);
						}
					else
						{
						BlackOutLine(pm, p.width);
						}

					}

				ycount += p.yfraction;
				pm += p.mbpr;
				}
			break;
		}
	}


// new-> 01/25/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVLBDI2_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv, * lppuv, * lpytb, * lpuvtb;
	int lhi;
	int sstart = p.lboffset << 16;
	int lycount;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	BYTE * ppm = p.ppm;
	BYTE * pmt = p.pmt;
	BYTE * pmb = p.pmb;
	int dbpr = p.bpr * 2;

	switch (p.xscale)
		{
		case 0:
			for(y=p.ystart; y<p.ystop; y++)
				{
				lycount = (((ycount - sstart) >> 8) * 5461) >> 4;

				lhi = lycount >> 16;

				if (lhi >= 0 && lhi < p.height - 1)
					{
					lpy  = p.py  + p.bpr * (lhi & ~1);
					lppy = p.ppy + p.bpr * (lhi & ~1);
					lpuv = p.puv + p.bpr * ((lhi >> 1) & ~1);
					lpytb = p.pytb + p.bpr * (lhi & ~1);
					lpuvtb = p.puvtb + p.bpr * ((lhi >> 1) & ~1);

					if (lhi < p.height - 4)
						{
						switch (lhi & 3)
							{
							case 0:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUV_P8D1(lpytb, lpuvtb, pmt, p.width);
								break;
							case 1:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUV_P8D1I4(lpy, lpuv, lppy, p.bpr, pm, p.width);
								break;
							case 2:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUV_P8D1MUV(lpytb, lpuvtb, pmt, p.width, p.bpr);
								break;
							case 3:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUV_P8D1I4MUV(lpy, lpuv, lppy, p.bpr, pm, p.width);
								break;
							}
						}
					else
						{
						if ((lhi & 1) != 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUV_P8D1(lpytb, lpuvtb, pmt, p.width);
							}
						}

					lpy   = p.py   + p.bpr * (lhi | 1);
					lppy  = p.ppy  + p.bpr * (lhi | 1);
					lppuv = p.ppuv + p.bpr * ((lhi >> 1) | 1);
					lpytb = p.pytb + p.bpr * (lhi | 1);
					lpuvtb = p.puvtb + p.bpr * ((lhi >> 1) | 1);

					if (lhi >= 4)
						{
						switch (lhi & 3)
							{
							case 0:
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUV_P8D1I4MUV(lppy - dbpr, lppuv - dbpr, lpy - dbpr, p.bpr, ppm, p.width);
								break;
							case 1:
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUV_P8D1MUV(lpytb, lpuvtb - dbpr, pmb, p.width, p.bpr);
								break;
							case 2:
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUV_P8D1I4(lppy - dbpr, lppuv, lpy - dbpr, p.bpr, ppm, p.width);
								break;
							case 3:
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUV_P8D1(lpytb, lpuvtb, pmb, p.width);
								break;
							}
						}
					else
						{
						if ((lhi & 1) == 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								ConvertLineToYUV_P8D1(lppy, lppuv, ppm, p.width);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUV_P8D1(lpytb, lpuvtb, pmb, p.width);
							}
						}
					}
				else
					{
					if ((lhi & 1) != 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							BlackOutLine(pm, p.width);
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							BlackOutLine(pmb, p.width);
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							BlackOutLine(pmt, p.width);
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							BlackOutLine(ppm, p.width);
						}
					}

				pm += p.mbpr;
				ppm += p.mbpr;
				pmb += p.mbpr;
				pmt += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		}
	}
// <- new 01/25/2000

// new -> 01/25/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVLBDI2ThroughOSD_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv, * lppuv, * lpytb, * lpuvtb, * lpo;
	int hi, yo;
	int ycount = p.ycount;
	int lhi;
	int sstart = p.lboffset << 16;
	int lycount;
	BYTE * pm = p.pm;
	BYTE * ppm = p.ppm;
	BYTE * pmt = p.pmt;
	BYTE * pmb = p.pmb;
	int dbpr = p.bpr * 2;

	switch (p.xscale)
		{
		case 0:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lycount = (((ycount - sstart) >> 8) * 5461) >> 4;

				lhi = lycount >> 16;

				lpy  = p.py  + p.bpr * (lhi & ~1);
				lppy = p.ppy + p.bpr * (lhi & ~1);
				lpuv = p.puv + p.bpr * ((lhi >> 1) & ~1);
				lpytb = p.pytb + p.bpr * (lhi & ~1);
				lpuvtb = p.puvtb + p.bpr * ((lhi >> 1) & ~1);

				yo = hi - p.yosdoffset;

				if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					if (lhi >= 0 && lhi < p.height - 1)
						{
						if (lhi < p.height - 4)
							{
							switch (lhi & 3)
								{
								case 0:
									if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
										ConvertLineToYUVWithOSD_P8D1(lpytb, lpuvtb, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
									break;
								case 1:
									if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
										ConvertLineToYUVWithOSD_P8D1I4(lpy, lpuv, lppy, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
									break;
								case 2:
									if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
										ConvertLineToYUVWithOSD_P8D1(lpytb, lpuvtb, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
									break;
								case 3:
									if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
										ConvertLineToYUVWithOSD_P8D1I4(lpy, lpuv, lppy, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
									break;
								}
							}
						else
							{
							if ((lhi & 1) != 0)
								{
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								}
							else
								{
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUVWithOSD_P8D1(lpytb, lpuvtb, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								}
							}
						}
					else
						{
						if ((lhi & 1) != 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								BlackOutLineWithOSD(pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								BlackOutLineWithOSD(pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						}
					}
				else
					{
					if (lhi >= 0 && lhi < p.height - 1)
						{
						if (lhi < p.height - 4)
							{
							switch (lhi & 3)
								{
								case 0:
									if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
										ConvertLineToYUV_P8D1(lpytb, lpuvtb, pmt, p.width);
									break;
								case 1:
									if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
										ConvertLineToYUV_P8D1I4(lpy, lpuv, lppy, p.bpr, pm, p.width);
									break;
								case 2:
									if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
										ConvertLineToYUV_P8D1MUV(lpytb, lpuvtb, pmt, p.width, p.bpr);
									break;
								case 3:
									if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
										ConvertLineToYUV_P8D1I4MUV(lpy, lpuv, lppy, p.bpr, pm, p.width);
									break;
								}
							}
						else
							{
							if ((lhi & 1) != 0)
								{
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
								}
							else
								{
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUV_P8D1(lpytb, lpuvtb, pmt, p.width);
								}
							}
						}
					else
						{
						if ((lhi & 1) != 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								BlackOutLine(pm, p.width);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								BlackOutLine(pmt, p.width);
							}
						}
					}

				lpy   = p.py   + p.bpr * (lhi | 1);
				lppy  = p.ppy  + p.bpr * (lhi | 1);
				lppuv = p.ppuv + p.bpr * ((lhi >> 1) | 1);
				lpytb = p.pytb + p.bpr * (lhi | 1);
				lpuvtb = p.puvtb + p.bpr * ((lhi >> 1) | 1);

				if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					if (lhi >= 0 && lhi < p.height - 1)
						{
						if (lhi < p.height - 4 && lhi >= 4)
//						if (lhi < p.height - 4)
							{
							switch (lhi & 3)
								{
								case 0:
									if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
										ConvertLineToYUVWithOSD_P8D1I4(lppy - dbpr, lppuv - dbpr, lpy - dbpr, p.bpr, ppm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
									break;
								case 1:
									if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
										ConvertLineToYUVWithOSD_P8D1(lpytb, lpuvtb, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
									break;
								case 2:
									if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
										ConvertLineToYUVWithOSD_P8D1I4(lppy - dbpr, lppuv, lpy - dbpr, p.bpr, ppm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
									break;
								case 3:
									if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
										ConvertLineToYUVWithOSD_P8D1(lpytb, lpuvtb, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
									break;
								}
							}
						else
							{
							if ((lhi & 1) != 0)
								{
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D1(lppy, lppuv, ppm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								}
							else
								{
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUVWithOSD_P8D1(lpytb, lpuvtb, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								}
							}
						}
					else
						{
						if ((lhi & 1) != 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								BlackOutLineWithOSD(ppm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								BlackOutLineWithOSD(pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						}
					}
				else
					{
					if (lhi >= 0 && lhi < p.height - 1)
						{
						if (lhi >= 4)
							{
							switch (lhi & 3)
								{
								case 0:
									if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
										ConvertLineToYUV_P8D1I4MUV(lppy - dbpr, lppuv - dbpr, lpy - dbpr, p.bpr, ppm, p.width);
									break;
								case 1:
									if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
										ConvertLineToYUV_P8D1MUV(lpytb, lpuvtb - dbpr, pmb, p.width, p.bpr);
									break;
								case 2:
									if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
										ConvertLineToYUV_P8D1I4(lppy - dbpr, lppuv, lpy - dbpr, p.bpr, ppm, p.width);
									break;
								case 3:
									if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
										ConvertLineToYUV_P8D1(lpytb, lpuvtb, pmb, p.width);
									break;
								}
							}
						else
							{
							if ((lhi & 1) == 0)
								{
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUV_P8D1(lppy, lppuv, ppm, p.width);
								}
							else
								{
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUV_P8D1(lpytb, lpuvtb, pmb, p.width);
								}
							}
						}
					else
						{
						if ((lhi & 1) == 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								BlackOutLine(ppm, p.width);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								BlackOutLine(pmb, p.width);
							}
						}
					}

				pm += p.mbpr;
				ppm += p.mbpr;
				pmb += p.mbpr;
				pmt += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		}
	}
// <- new 01/25/2000

// new -> 01/25/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVLBA2_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv, * lppuv;
	int lhi, llo;
	int sstart = p.lboffset << 16;
	int lycount;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	short filter[4];

	switch (p.xscale)
		{
		case 0:
			for(y=p.ystart; y<p.ystop; y++)
				{
				lycount = (((ycount - sstart) >> 8) * 5461) >> 4;
				lhi = lycount >> 16;
				llo = lycount & 0xffff;

				if (lhi >= 0 && lhi < p.height - 1)
					{
					lpy   = p.py   + p.bpr * lhi;
					lppy  = p.ppy  + p.bpr * lhi;
					lpuv  = p.puv  + p.bpr * (lhi >> 1);
					lppuv = p.ppuv + p.bpr * (lhi >> 1);

					filter[0] = (0x10000 >> 11) - (llo >> 11);
					filter[1] = (llo) >> 11;
					filter[2] = (0x10000 >> 11) - (llo >> 11);
					filter[3] = (llo) >> 11;

					ConvertLineToYUV_P8D1Y4MUV(lpy, lpy + p.bpr, lppy, lppy + p.bpr, lpuv, lppuv, pm, p.width, filter);
					}
				else
					BlackOutLine(pm, p.width);

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		}
	}
// <- new 01/25/2000

// new -> 01/25/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVLBA2ThroughOSD_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv, * lppuv, * lpo;
	int hi, yo;
	int ycount = p.ycount;
	int lhi, llo;
	int sstart = p.lboffset << 16;
	int lycount;
	BYTE * pm = p.pm;
	short filter[4];

	switch (p.xscale)
		{
		case 0:
			for(y=p.ystart; y<p.ystop; y++)
				{
				lycount = (((ycount - sstart) >> 8) * 5461) >> 4;
				lhi = lycount >> 16;
				llo = lycount & 0xffff;
				hi = ycount >> 16;

				lpy   = p.py   + p.bpr * lhi;
				lppy  = p.ppy  + p.bpr * lhi;
				lpuv  = p.puv  + p.bpr * (lhi >> 1);
				lppuv = p.ppuv + p.bpr * (lhi >> 1);

				filter[0] = (0x10000 >> 11) - (llo >> 11);
				filter[1] = (llo) >> 11;
				filter[2] = (0x10000 >> 11) - (llo >> 11);
				filter[3] = (llo) >> 11;

				yo = hi - p.yosdoffset;

				if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					if (lhi >= 0 && lhi < p.height - 1)
						{
						ConvertLineToYUVWithOSD_P8D1Y4MUV(lpy, lpy + p.bpr, lppy, lppy + p.bpr, lpuv, lppuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd, filter);
//						ConvertLineToYUVWithOSD_P8D1M(lpy, lpuv, lppy, lppuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
						}
					else
						{
						BlackOutLineWithOSD(pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
						}

					}
				else
					{
					if (lhi >= 0 && lhi < p.height - 1)
						{
						ConvertLineToYUV_P8D1Y4MUV(lpy, lpy + p.bpr, lppy, lppy + p.bpr, lpuv, lppuv, pm, p.width, filter);
//						ConvertLineToYUV_P8D1M(lpy, lpuv, lppy, lppuv, pm, p.width);
						}
					else
						{
						BlackOutLine(pm, p.width);
						}
					}

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		}
	}
// <- new 01/25/2000

// new -> 01/25/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVLBSI2_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv;
	int lhi;
	int sstart = p.lboffset << 16;
	int lycount;
	int ycount = p.ycount;
	BYTE * pmt = p.pmt;
	BYTE * pmb = p.pmb;
	int dbpr = p.bpr * 2;

	switch (p.xscale)
		{
		case 0:
			for(y=p.ystart; y<p.ystop; y++)
				{
				lycount = (((ycount - sstart) >> 8) * 5461) >> 4;
				lhi = lycount >> 16;

				lpy  = p.py  + p.bpr * (lhi & ~1);
				lpuv = p.puv + p.bpr * ((lhi >> 1) & ~1);

				if (lhi < p.height - 4 && lhi >= 4)
					{
					switch (lhi & 3)
						{
						case 0:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUV_P8D1(lpy, lpuv, pmt, p.width);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								ConvertLineToYUV_P8D1MYUV(lpy - p.bpr, lpuv - p.bpr, pmb, p.width, p.bpr);
							break;
						case 1:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUV_P8D1MY(lpy, lpuv, pmt, p.width, p.bpr);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUV_P8D1MUV(lpy + p.bpr, lpuv - p.bpr, pmb, p.width, p.bpr);
							break;
						case 2:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUV_P8D1MUV(lpy, lpuv, pmt, p.width, p.bpr);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								ConvertLineToYUV_P8D1MY(lpy - p.bpr, lpuv + p.bpr, pmb, p.width, p.bpr);
							break;
						case 3:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUV_P8D1MYUV(lpy, lpuv, pmt, p.width, p.bpr);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUV_P8D1(lpy + p.bpr, lpuv + p.bpr, pmb, p.width);
							break;
						}
					}
				else if (lhi >= 0 && lhi < p.height)
					{
					if ((lhi & 1) != 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							ConvertLineToYUV_P8D1(lpy, lpuv, pmt, p.width);
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							ConvertLineToYUV_P8D1(lpy + p.bpr, lpuv + p.bpr, pmb, p.width);
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							ConvertLineToYUV_P8D1(lpy, lpuv, pmt, p.width);
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							ConvertLineToYUV_P8D1(lpy + p.bpr, lpuv + p.bpr, pmb, p.width);
						}
					}
				else
					{
					if ((lhi & 1) != 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							BlackOutLine(pmt, p.width);
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							BlackOutLine(pmb, p.width);
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							BlackOutLine(pmt, p.width);
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							BlackOutLine(pmb, p.width);
						}
					}

				pmb += p.mbpr;
				pmt += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		}
	}
// <- new 01/25/2000

// new -> 01/25/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVLBSI2ThroughOSD_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv, * lpo;
	int hi, yo;
	int lhi;
	int sstart = p.lboffset << 16;
	int lycount;
	int ycount = p.ycount;
	BYTE * pmt = p.pmt;
	BYTE * pmb = p.pmb;
	int dbpr = p.bpr * 2;

	switch (p.xscale)
		{
		case 0:
			for(y=p.ystart; y<p.ystop; y++)
				{
				lycount = (((ycount - sstart) >> 8) * 5461) >> 4;
				lhi = lycount >> 16;
				hi = ycount >> 16;

				lpy  = p.py  + p.bpr * (lhi & ~1);
				lpuv = p.puv + p.bpr * ((lhi >> 1) & ~1);

				yo = hi - p.yosdoffset;

				if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					if (lhi < p.height - 4 && lhi >= 4)
						{
						switch (lhi & 3)
							{
							case 0:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D1MYUV(lpy - p.bpr, lpuv - p.bpr, p.bpr, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 1:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D1MY(lpy, lpuv, p.bpr, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUVWithOSD_P8D1MUV(lpy + p.bpr, lpuv - p.bpr, p.bpr, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 2:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUVWithOSD_P8D1MUV(lpy, lpuv, p.bpr, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D1MY(lpy - p.bpr, lpuv + p.bpr, p.bpr, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 3:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D1MYUV(lpy, lpuv, p.bpr, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUVWithOSD_P8D1(lpy + p.bpr, lpuv + p.bpr, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							}
						}
					else if (lhi >= 0 && lhi < p.height)
						{
						if ((lhi & 1) != 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUVWithOSD_P8D1(lpy + p.bpr, lpuv + p.bpr, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								ConvertLineToYUVWithOSD_P8D1(lpy + p.bpr, lpuv + p.bpr, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						}
					else
						{
						if ((lhi & 1) != 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								BlackOutLineWithOSD(pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								BlackOutLineWithOSD(pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								BlackOutLineWithOSD(pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								BlackOutLineWithOSD(pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						}
					}
				else
					{
					if (lhi < p.height - 4 && lhi >= 4)
						{
						switch (lhi & 3)
							{
							case 0:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUV_P8D1(lpy, lpuv, pmt, p.width);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUV_P8D1MYUV(lpy - p.bpr, lpuv - p.bpr, pmb, p.width, p.bpr);
								break;
							case 1:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUV_P8D1MY(lpy, lpuv, pmt, p.width, p.bpr);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUV_P8D1MUV(lpy + p.bpr, lpuv - p.bpr, pmb, p.width, p.bpr);
								break;
							case 2:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUV_P8D1MUV(lpy, lpuv, pmt, p.width, p.bpr);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUV_P8D1MY(lpy - p.bpr, lpuv + p.bpr, pmb, p.width, p.bpr);
								break;
							case 3:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUV_P8D1MYUV(lpy, lpuv, pmt, p.width, p.bpr);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUV_P8D1(lpy + p.bpr, lpuv + p.bpr, pmb, p.width);
								break;
							}
						}
					else if (lhi >= 0 && lhi < p.height)
						{
						if ((lhi & 1) != 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUV_P8D1(lpy, lpuv, pmt, p.width);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUV_P8D1(lpy + p.bpr, lpuv + p.bpr, pmb, p.width);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUV_P8D1(lpy, lpuv, pmt, p.width);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								ConvertLineToYUV_P8D1(lpy + p.bpr, lpuv + p.bpr, pmb, p.width);
							}
						}
					else
						{
						if ((lhi & 1) != 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								BlackOutLine(pmt, p.width);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								BlackOutLine(pmb, p.width);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								BlackOutLine(pmt, p.width);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								BlackOutLine(pmb, p.width);
							}
						}
					}

				pmb += p.mbpr;
				pmt += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		}
	}
// <- new 01/25/2000

// new -> 01/25/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVLB32PDFieldField_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv;
	int lhi;
	int sstart = p.lboffset << 16;
	int lycount;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	switch (p.xscale)
		{
		case 0:
			for(y=p.ystart; y<p.ystop; y++)
				{
				lycount = (((ycount - sstart) >> 8) * 5461) >> 4;
				lhi = lycount >> 16;
				hi = ycount >> 16;

				if (lhi >= 0 && lhi < p.height)
					{
					if ((lhi & 1) == 0)
						{
						lpy  = p.py + p.bpr * lhi;
						lpuv = p.puv + p.bpr * ((lhi >> 1) & ~1);
						}
					else
						{
						lpy  = p.ppy + p.bpr * lhi;
						lpuv = p.ppuv + p.bpr * ((lhi >> 1) | 1);
						}

					ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
					}
				else
					{
					BlackOutLine(pm, p.width);
					}

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		}
	}
// <- new 01/25/2000

// new -> 01/25/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVLB32PDFieldFieldThroughOSD_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv, * lpo;
	int lhi;
	int sstart = p.lboffset << 16;
	int lycount;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	switch (p.xscale)
		{
		case 0:
			for(y=p.ystart; y<p.ystop; y++)
				{
				lycount = (((ycount - sstart) >> 8) * 5461) >> 4;
				lhi = lycount >> 16;
				hi = ycount >> 16;

				if (lhi >= 0 && lhi < p.height)
					{
					if ((lhi & 1) == 0)
						{
						lpy  = p.py + p.bpr * lhi;
						lpuv = p.puv + p.bpr * ((lhi >> 1) & ~1);
						}
					else
						{
						lpy  = p.ppy + p.bpr * lhi;
						lpuv = p.ppuv + p.bpr * ((lhi >> 1) | 1);
						}

					if (hi >= p.yosdstart && hi < p.yosdstop)
						{
						lpo = p.po + p.obpr * (hi - p.yosdstart);

						ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
						}
					else
						{
						ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
						}
					}
				else
					{
					if (hi >= p.yosdstart && hi < p.yosdstop)
						{
						lpo = p.po + p.obpr * (hi - p.yosdstart);

						BlackOutLineWithOSD(pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
						}
					else
						{
						BlackOutLine(pm, p.width);
						}
					}

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		}
	}
// <- new 01/25/2000

// new -> 01/25/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVLB32PDFrameFieldThroughOSD_P8DS(const YUVVideoConverterParameter & p)
	{
	ConvertStripeToYUVLBThroughOSD_P8DSY2(p);
	}
// <- new 01/25/2000

// new-> 01/25/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVLB32PDFrameField_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv, * lppuv;
	int hi;
	int lhi;
	int sstart = p.lboffset << 16;
	int lycount;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	if (p.xscale == 0)
		{
		if (p.topField)
			{
			for(y=p.ystart; y<p.ystop; y++)
				{
				lycount = (((ycount - sstart) >> 8) * 5461) >> 4;
				lhi = lycount >> 16;
				hi = ycount >> 16;

				if (lhi >= 0 && lhi < p.height)
					{
					if ((lhi & 1) == 1)
						{
						lpy  = p.py + p.bpr * lhi;
						lpuv = p.puv + p.bpr * ((lhi >> 1) | 1);

						ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
						}
					else
						{
						lpy   = p.py   + p.bpr * lhi;
						lpuv  = p.puv  + p.bpr * ((lhi >> 1) & ~1);
						lppy  = p.ppy  + p.bpr * lhi;
						lppuv = p.ppuv + p.bpr * ((lhi >> 1) & ~1);

						ConvertLineToYUV_P8D1M(lpy, lpuv, lppy, lppuv, pm, p.width);
						}
					}
				else
					{
					BlackOutLine(pm, p.width);
					}

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			}
		else
			{
			for(y=p.ystart; y<p.ystop; y++)
				{
				lycount = (((ycount - sstart) >> 8) * 5461) >> 4;
				lhi = lycount >> 16;
				hi = ycount >> 16;

				if (lhi >= 0 && lhi < p.height)
					{
					if ((lhi & 1) == 0)
						{
						lpy  = p.py + p.bpr * lhi;
						lpuv = p.puv + p.bpr * ((lhi >> 1) & ~1);

						ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
						}
					else
						{
						lpy   = p.py   + p.bpr * lhi;
						lpuv  = p.puv  + p.bpr * ((lhi >> 1) | 1);
						lppy  = p.ppy  + p.bpr * lhi;
						lppuv = p.ppuv + p.bpr * ((lhi >> 1) | 1);

						ConvertLineToYUV_P8D1M(lpy, lpuv, lppy, lppuv, pm, p.width);
						}
					}
				else
					{
					BlackOutLine(pm, p.width);
					}

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			}
		}
	}
// <-new 01/25/2000

void XMMXYUVVideoConverter::ConvertStripeToYUVDI_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	int dbpr;

	switch (p.xscale)
		{
		case 0:
			if (p.topField)
				{
				for(y=p.ystart; y<p.ystop; y++)
					{
					hi = ycount >> 16;

					lpy  = p.py  + p.bpr * (hi & ~1);
					lppy = p.ppy + p.bpr * (hi & ~1);
					lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

					if (hi >= p.height - 4) hi = 0;
					switch (hi & 3)
						{
						case 0:
							ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
							break;
						case 1:
							ConvertLineToYUV_P8D1I4(lpy, lpuv, lppy, p.bpr, pm, p.width);
							break;
						case 2:
							ConvertLineToYUV_P8D1MUV(lpy, lpuv, pm, p.width, p.bpr);
							break;
						case 3:
							ConvertLineToYUV_P8D1I4MUV(lpy, lpuv, lppy, p.bpr, pm, p.width);
							break;
						}

					pm += p.mbpr;
					ycount += p.yfraction;
					}
				}
			else
				{
				dbpr = p.bpr * 2;

				for(y=p.ystart; y<p.ystop; y++)
					{
					hi = ycount >> 16;

					lpy  = p.py  + p.bpr * (hi | 1);
					lppy = p.ppy + p.bpr * (hi | 1);
					lpuv = p.puv + p.bpr * ((hi >> 1) | 1);

					if (hi < 4) hi = 3;

					switch (hi & 3)
						{
						case 0:
							ConvertLineToYUV_P8D1I4MUV(lpy - dbpr, lpuv - dbpr, lppy - dbpr, p.bpr, pm, p.width);
							break;
						case 1:
							ConvertLineToYUV_P8D1MUV(lpy, lpuv - dbpr, pm, p.width, p.bpr);
							break;
						case 2:
							ConvertLineToYUV_P8D1I4(lpy - dbpr, lpuv, lppy - dbpr, p.bpr, pm, p.width);
							break;
						case 3:
							ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
							break;
						}

					pm += p.mbpr;
					ycount += p.yfraction;
					}
				}
			break;
		case 1:
			if (p.topField)
				{
				for(y=p.ystart; y<p.ystop; y++)
					{
					hi = ycount >> 16;

					lpy  = p.py  + p.bpr * (hi & ~1);
					lppy = p.ppy + p.bpr * (hi & ~1);
					lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

					if (hi >= p.height - 4) hi = 0;

					switch (hi & 3)
						{
						case 0:
							ConvertLineToYUV_P8D2(lpy, lpuv, pm, p.width);
							break;
						case 1:
							ConvertLineToYUV_P8D2I4(lpy, lpuv, lppy, p.bpr, pm, p.width);
							break;
						case 2:
							ConvertLineToYUV_P8D2MUV(lpy, lpuv, pm, p.width, p.bpr);
							break;
						case 3:
							ConvertLineToYUV_P8D2I4MUV(lpy, lpuv, lppy, p.bpr, pm, p.width);
							break;
						}

					pm += p.mbpr;
					ycount += p.yfraction;
					}
				}
			else
				{
				dbpr = p.bpr * 2;

				for(y=p.ystart; y<p.ystop; y++)
					{
					hi = ycount >> 16;

					lpy  = p.py  + p.bpr * (hi | 1);
					lppy = p.ppy + p.bpr * (hi | 1);
					lpuv = p.puv + p.bpr * ((hi >> 1) | 1);

					if (hi < 4) hi = 3;

					switch (hi & 3)
						{
						case 0:
							ConvertLineToYUV_P8D2I4MUV(lpy - dbpr, lpuv - dbpr, lppy - dbpr, p.bpr, pm, p.width);
							break;
						case 1:
							ConvertLineToYUV_P8D2MUV(lpy, lpuv - dbpr, pm, p.width, p.bpr);
							break;
						case 2:
							ConvertLineToYUV_P8D2I4(lpy - dbpr, lpuv, lppy - dbpr, p.bpr, pm, p.width);
							break;
						case 3:
							ConvertLineToYUV_P8D2(lpy, lpuv, pm, p.width);
							break;
						}

					pm += p.mbpr;
					ycount += p.yfraction;
					}
				}
			break;
		default:
			for(y = p.ystart; y < p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy  = p.py  + p.bpr * (hi & ~1);
				lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

				ConvertLineToYUV_P8DS(lpy, lpuv, pm, p.width, p.xscale);

				ycount += p.yfraction;
				pm += p.mbpr;
				}
			break;
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVDIThroughOSD_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv, * lpo;
	int hi, yo, dbpr;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	switch (p.xscale)
		{
		case 0:
			if (p.topField)
				{
				for(y=p.ystart; y<p.ystop; y++)
					{
					hi = ycount >> 16;

					lpy  = p.py  + p.bpr * (hi & ~1);
					lppy = p.ppy + p.bpr * (hi & ~1);
					lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

					yo = hi - p.yosdoffset;

					if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
						{
						lpo = p.po + p.obpr * (hi - p.yosdstart);

						if (hi >= p.height - 4) hi = 0;

						switch (hi & 3)
							{
							case 0:
								ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 1:
								ConvertLineToYUVWithOSD_P8D1I4(lpy, lpuv, lppy, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 2:
								ConvertLineToYUVWithOSD_P8D1MUV(lpy, lpuv, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 3:
								ConvertLineToYUVWithOSD_P8D1I4MUV(lpy, lpuv, lppy, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							}
						}
					else
						{
						if (hi >= p.height - 4) hi = 0;

						switch (hi & 3)
							{
							case 0:
								ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
								break;
							case 1:
								ConvertLineToYUV_P8D1I4(lpy, lpuv, lppy, p.bpr, pm, p.width);
								break;
							case 2:
								ConvertLineToYUV_P8D1MUV(lpy, lpuv, pm, p.width, p.bpr);
								break;
							case 3:
								ConvertLineToYUV_P8D1I4MUV(lpy, lpuv, lppy, p.bpr, pm, p.width);
								break;
							}
						}
					pm += p.mbpr;
					ycount += p.yfraction;
					}
				}
			else
				{
				dbpr = p.bpr * 2;

				for(y=p.ystart; y<p.ystop; y++)
					{
					hi = ycount >> 16;

					lpy  = p.py  + p.bpr * (hi | 1);
					lppy = p.ppy + p.bpr * (hi | 1);
					lpuv = p.puv + p.bpr * ((hi >> 1) | 1);

					yo = hi - p.yosdoffset;

					if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
						{
						lpo = p.po + p.obpr * (hi - p.yosdstart);

						if (hi < 4) hi = 3;

						switch (hi & 3)
							{
							case 0:
								ConvertLineToYUVWithOSD_P8D1I4MUV(lpy - dbpr, lppy - dbpr, lpuv - dbpr, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 1:
								ConvertLineToYUVWithOSD_P8D1MUV(lpy, lpuv - dbpr, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 2:
								ConvertLineToYUVWithOSD_P8D1I4(lpy - dbpr, lpuv, lppy - dbpr, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 3:
								ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							}
						}
					else
						{
						if (hi < 4) hi = 3;

						switch (hi & 3)
							{
							case 0:
								ConvertLineToYUV_P8D1I4MUV(lpy - dbpr, lpuv - dbpr, lppy - dbpr, p.bpr, pm, p.width);
								break;
							case 1:
								ConvertLineToYUV_P8D1MUV(lpy, lpuv - dbpr, pm, p.width, p.bpr);
								break;
							case 2:
								ConvertLineToYUV_P8D1I4(lpy - dbpr, lpuv, lppy - dbpr, p.bpr, pm, p.width);
								break;
							case 3:
								ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
								break;
							}
						}

					pm += p.mbpr;
					ycount += p.yfraction;
					}
				}
			break;
		case 1:
			if (p.topField)
				{
				for(y=p.ystart; y<p.ystop; y++)
					{
					hi = ycount >> 16;

					lpy  = p.py  + p.bpr * (hi & ~1);
					lppy = p.ppy + p.bpr * (hi & ~1);
					lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

					yo = hi - p.yosdoffset;

					if (hi >= p.yosdstart && hi < p.yosdstop && ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0))
						{
						lpo = p.po + p.obpr * (hi - p.yosdstart);

						if (hi >= p.height - 4) hi = 0;

						switch (hi & 3)
							{
							case 0:
								ConvertLineToYUVWithOSD_P8D2(lpy, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 1:
								ConvertLineToYUVWithOSD_P8D2I4(lpy, lpuv, lppy, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 2:
								ConvertLineToYUVWithOSD_P8D2(lpy, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 3:
								ConvertLineToYUVWithOSD_P8D2I4(lpy, lpuv, lppy, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							}
						}
					else
						{
						if (hi >= p.height - 4) hi = 0;

						switch (hi & 3)
							{
							case 0:
								ConvertLineToYUV_P8D2(lpy, lpuv, pm, p.width);
								break;
							case 1:
								ConvertLineToYUV_P8D2I4(lpy, lpuv, lppy, p.bpr, pm, p.width);
								break;
							case 2:
								ConvertLineToYUV_P8D2MUV(lpy, lpuv, pm, p.width, p.bpr);
								break;
							case 3:
								ConvertLineToYUV_P8D2I4MUV(lpy, lpuv, lppy, p.bpr, pm, p.width);
								break;
							}
						}

					pm += p.mbpr;
					ycount += p.yfraction;
					}
				}
			else
				{
				dbpr = p.bpr * 2;

				for(y=p.ystart; y<p.ystop; y++)
					{
					hi = ycount >> 16;

					lpy  = p.py  + p.bpr * (hi | 1);
					lppy = p.ppy + p.bpr * (hi | 1);
					lpuv = p.puv + p.bpr * ((hi >> 1) | 1);

					yo = hi - p.yosdoffset;

					if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
						{
						lpo = p.po + p.obpr * (hi - p.yosdstart);

						if (hi < 4) hi = 3;

						switch (hi & 3)
							{
							case 0:
								ConvertLineToYUVWithOSD_P8D2I4(lpy - dbpr, lppy - dbpr, lpuv - dbpr, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 1:
								ConvertLineToYUVWithOSD_P8D2(lpy, lpuv - dbpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 2:
								ConvertLineToYUVWithOSD_P8D2I4(lpy - dbpr, lpuv, lppy - dbpr, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 3:
								ConvertLineToYUVWithOSD_P8D2(lpy, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							}
						}
					else
						{
						if (hi < 4) hi = 3;

						switch (hi & 3)
							{
							case 0:
								ConvertLineToYUV_P8D2I4MUV(lpy - dbpr, lpuv - dbpr, lppy - dbpr, p.bpr, pm, p.width);
								break;
							case 1:
								ConvertLineToYUV_P8D2MUV(lpy, lpuv - dbpr, pm, p.width, p.bpr);
								break;
							case 2:
								ConvertLineToYUV_P8D2I4(lpy - dbpr, lpuv, lppy - dbpr, p.bpr, pm, p.width);
								break;
							case 3:
								ConvertLineToYUV_P8D2(lpy, lpuv, pm, p.width);
								break;
							}
						}

					pm += p.mbpr;
					ycount += p.yfraction;
					}
				}
			break;
		default:
			for(y = p.ystart; y < p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy  = p.py  + p.bpr * (hi & ~1);
				lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

				ConvertLineToYUV_P8DS(lpy, lpuv, pm, p.width, p.xscale);

				ycount += p.yfraction;
				pm += p.mbpr;
				}
			break;
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVDI_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	int dbpr;

	if (p.xfraction == 0x10000)
		{
		ConvertStripeToYUVDI_P8DS(p);
		}
	else
		{
		if (p.topField)
			{
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy  = p.py  + p.bpr * (hi & ~1);
				lppy = p.ppy + p.bpr * (hi & ~1);
				lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

				if (hi >= p.height - 4) hi = 0;

				switch (hi & 3)
					{
					case 0:
						ConvertLineToYUV_P8F2(lpy, lpuv, pm, p.mwidth, 0, p.xfraction);
						break;
					case 1:
						ConvertLineToYUV_P8D1I4(lpy, lpuv, lppy, p.bpr, yuvcache, p.width);
						ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
						break;
					case 2:
						ConvertLineToYUV_P8F2(lpy, lpuv, pm, p.mwidth, 0, p.xfraction);
//						ConvertLineToYUV_P8D1MUV(lpy, lpuv, yuvcache, p.width, p.bpr);
//						ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
						break;
					case 3:
						ConvertLineToYUV_P8D1I4MUV(lpy, lpuv, lppy, p.bpr, yuvcache, p.width);
						ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
						break;
					}


				pm += p.mbpr;
				ycount += p.yfraction;
				}
			}
		else
			{
			dbpr = p.bpr * 2;

			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy  = p.py  + p.bpr * (hi | 1);
				lppy = p.ppy + p.bpr * (hi | 1);
				lpuv = p.puv + p.bpr * ((hi >> 1) | 1);

				if (hi < 4) hi = 3;

				switch (hi & 3)
					{
					case 0:
						ConvertLineToYUV_P8D1I4MUV(lpy - dbpr, lpuv - dbpr, lppy - dbpr, p.bpr, yuvcache, p.width);
						ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
						break;
					case 1:
						ConvertLineToYUV_P8F2(lpy, lpuv, pm, p.mwidth, 0, p.xfraction);
//						ConvertLineToYUV_P8D1MUV(lpy, lpuv, yuvcache, p.width, p.bpr);
//						ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
						break;
					case 2:
						ConvertLineToYUV_P8D1I4(lpy - dbpr, lpuv, lppy - dbpr, p.bpr, yuvcache, p.width);
						ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
						break;
					case 3:
						ConvertLineToYUV_P8F2(lpy, lpuv, pm, p.mwidth, 0, p.xfraction);
						break;
					}


				pm += p.mbpr;
				ycount += p.yfraction;
				}
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVDIThroughOSD_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv, * lpo;
	int hi, yo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	int dbpr;

	if (p.xfraction == 0x10000)
		{
		ConvertStripeToYUVDIThroughOSD_P8DS(p);
		}
	else
		{
		if (p.topField)
			{
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy  = p.py  + p.bpr * (hi & ~1);
				lppy = p.ppy + p.bpr * (hi & ~1);
				lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

				yo = hi - p.yosdoffset;

				if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					if (hi >= p.height - 4) hi = 0;

					switch (hi & 3)
						{
						case 0:
							ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							break;
						case 1:
							ConvertLineToYUVWithOSD_P8D1I4(lpy, lpuv, lppy, p.bpr, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							break;
						case 2:
							ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							break;
						case 3:
							ConvertLineToYUVWithOSD_P8D1I4(lpy, lpuv, lppy, p.bpr, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							break;
						}

					ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
					}
				else
					{
					if (hi >= p.height - 4) hi = 0;

					switch (hi & 3)
						{
						case 0:
							ConvertLineToYUV_P8F2(lpy, lpuv, pm, p.mwidth, 0, p.xfraction);
							break;
						case 1:
							ConvertLineToYUV_P8D1I4(lpy, lpuv, lppy, p.bpr, yuvcache, p.width);
							ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
							break;
						case 2:
							ConvertLineToYUV_P8D1MUV(lpy, lpuv, yuvcache, p.width, p.bpr);
							ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
							break;
						case 3:
							ConvertLineToYUV_P8D1I4MUV(lpy, lpuv, lppy, p.bpr, yuvcache, p.width);
							ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
							break;
						}
					}


				pm += p.mbpr;
				ycount += p.yfraction;
				}
			}
		else
			{
			dbpr = p.bpr * 2;

			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy  = p.py  + p.bpr * (hi | 1);
				lppy = p.ppy + p.bpr * (hi | 1);
				lpuv = p.puv + p.bpr * ((hi >> 1) | 1);

				yo = hi - p.yosdoffset;

				if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					if (hi < 4) hi = 3;

					switch (hi & 3)
						{
						case 0:
							ConvertLineToYUVWithOSD_P8D1I4(lpy - dbpr, lppy - dbpr, lpuv - dbpr, p.bpr, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							break;
						case 1:
							ConvertLineToYUVWithOSD_P8D1(lpy, lpuv - dbpr, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							break;
						case 2:
							ConvertLineToYUVWithOSD_P8D1I4(lpy - dbpr, lpuv, lppy - dbpr, p.bpr, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							break;
						case 3:
							ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							break;
						}

					ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
					}
				else
					{
					if (hi < 4) hi = 3;

					switch (hi & 3)
						{
						case 0:
							ConvertLineToYUV_P8D1I4MUV(lpy - dbpr, lpuv - dbpr, lppy - dbpr, p.bpr, yuvcache, p.width);
							ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
							break;
						case 1:
							ConvertLineToYUV_P8F2(lpy, lpuv - dbpr, pm, p.mwidth, 0, p.xfraction);
	//						ConvertLineToYUV_P8D1MUV(lpy, lpuv, yuvcache, p.width, p.bpr);
	//						ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
							break;
						case 2:
							ConvertLineToYUV_P8D1I4(lpy - dbpr, lpuv, lppy - dbpr, p.bpr, yuvcache, p.width);
							ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
							break;
						case 3:
							ConvertLineToYUV_P8F2(lpy, lpuv, pm, p.mwidth, 0, p.xfraction);
							break;
						}
					}


				pm += p.mbpr;
				ycount += p.yfraction;
				}
			}

		}
	}

static void ConvertStripeToYUVDI_P8D1TopFieldLine(const YUVVideoConverterParameter & p, BYTE * lpy, BYTE * lppy, BYTE * lpuv, int hi, BYTE * pm)
	{
	if (hi >= p.height - 4) hi = 0;

	switch (hi & 3)
		{
		case 0:
			ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
			break;
		case 1:
			ConvertLineToYUV_P8D1I4(lpy, lpuv, lppy, p.bpr, pm, p.width);
			break;
		case 2:
			ConvertLineToYUV_P8D1MUV(lpy, lpuv, pm, p.width, p.bpr);
			break;
		case 3:
			ConvertLineToYUV_P8D1I4MUV(lpy, lpuv, lppy, p.bpr, pm, p.width);
			break;
		}
	}

static void ConvertStripeToYUVDI_P8D1BottomFieldLine(const YUVVideoConverterParameter & p, BYTE * lpy, BYTE * lppy, BYTE * lpuv, int hi, BYTE * pm)
	{
	int dbpr = p.bpr * 2;

	if (hi < 4) hi = 3;

	switch (hi & 3)
		{
		case 0:
			ConvertLineToYUV_P8D1I4MUV(lpy - dbpr, lpuv - dbpr, lppy - dbpr, p.bpr, pm, p.width);
			break;
		case 1:
			ConvertLineToYUV_P8D1MUV(lpy, lpuv - dbpr, pm, p.width, p.bpr);
			break;
		case 2:
			ConvertLineToYUV_P8D1I4(lpy - dbpr, lpuv, lppy - dbpr, p.bpr, pm, p.width);
			break;
		case 3:
			ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
			break;
		}
	}

static void ConvertStripeToYUVDIThroughOSD_P8D1TopFieldLine(const YUVVideoConverterParameter & p, BYTE * lpy, BYTE * lppy, BYTE * lpuv, int hi, BYTE * pm)
	{
	int yo = hi - p.yosdoffset;
	BYTE * lpo;

	if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
		{
		lpo = p.po + p.obpr * (hi - p.yosdstart);

		if (hi >= p.height - 4) hi = 0;

		switch (hi & 3)
			{
			case 0:
				ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				break;
			case 1:
				ConvertLineToYUVWithOSD_P8D1I4(lpy, lpuv, lppy, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				break;
			case 2:
				ConvertLineToYUVWithOSD_P8D1MUV(lpy, lpuv, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				break;
			case 3:
				ConvertLineToYUVWithOSD_P8D1I4MUV(lpy, lpuv, lppy, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				break;
			}
		}
	else
		{
		if (hi >= p.height - 4) hi = 0;

		switch (hi & 3)
			{
			case 0:
				ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
				break;
			case 1:
				ConvertLineToYUV_P8D1I4(lpy, lpuv, lppy, p.bpr, pm, p.width);
				break;
			case 2:
				ConvertLineToYUV_P8D1MUV(lpy, lpuv, pm, p.width, p.bpr);
				break;
			case 3:
				ConvertLineToYUV_P8D1I4MUV(lpy, lpuv, lppy, p.bpr, pm, p.width);
				break;
			}
		}
	}

static void ConvertStripeToYUVDIThroughOSD_P8D1BottomFieldLine(const YUVVideoConverterParameter & p, BYTE * lpy, BYTE * lppy, BYTE * lpuv, int hi, BYTE * pm)
	{
	int dbpr = p.bpr * 2;
	int yo = hi - p.yosdoffset;
	BYTE * lpo;

	if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
		{
		lpo = p.po + p.obpr * (hi - p.yosdstart);

		if (hi < 4) hi = 3;

		switch (hi & 3)
			{
			case 0:
				ConvertLineToYUVWithOSD_P8D1I4MUV(lpy - dbpr, lppy - dbpr, lpuv - dbpr, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				break;
			case 1:
				ConvertLineToYUVWithOSD_P8D1MUV(lpy, lpuv - dbpr, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				break;
			case 2:
				ConvertLineToYUVWithOSD_P8D1I4(lpy - dbpr, lpuv, lppy - dbpr, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				break;
			case 3:
				ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				break;
			}
		}
	else
		{
		if (hi < 4) hi = 3;

		switch (hi & 3)
			{
			case 0:
				ConvertLineToYUV_P8D1I4MUV(lpy - dbpr, lpuv - dbpr, lppy - dbpr, p.bpr, pm, p.width);
				break;
			case 1:
				ConvertLineToYUV_P8D1MUV(lpy, lpuv - dbpr, pm, p.width, p.bpr);
				break;
			case 2:
				ConvertLineToYUV_P8D1I4(lpy - dbpr, lpuv, lppy - dbpr, p.bpr, pm, p.width);
				break;
			case 3:
				ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
				break;
			}
		}
	}

static void ConvertStripeToYUVDI_P8D2TopFieldLine(const YUVVideoConverterParameter & p, BYTE * lpy, BYTE * lppy, BYTE * lpuv, int hi, BYTE * pm)
	{
	if (hi >= p.height - 4) hi = 0;

	switch (hi & 3)
		{
		case 0:
			ConvertLineToYUV_P8D2(lpy, lpuv, pm, p.width);
			break;
		case 1:
			ConvertLineToYUV_P8D2I4(lpy, lpuv, lppy, p.bpr, pm, p.width);
			break;
		case 2:
			ConvertLineToYUV_P8D2MUV(lpy, lpuv, pm, p.width, p.bpr);
			break;
		case 3:
			ConvertLineToYUV_P8D2I4MUV(lpy, lpuv, lppy, p.bpr, pm, p.width);
			break;
		}
	}

static void ConvertStripeToYUVDI_P8D2BottomFieldLine(const YUVVideoConverterParameter & p, BYTE * lpy, BYTE * lppy, BYTE * lpuv, int hi, BYTE * pm)
	{
	int dbpr = p.bpr * 2;

	if (hi < 4) hi = 3;

	switch (hi & 3)
		{
		case 0:
			ConvertLineToYUV_P8D2I4MUV(lpy - dbpr, lpuv - dbpr, lppy - dbpr, p.bpr, pm, p.width);
			break;
		case 1:
			ConvertLineToYUV_P8D2MUV(lpy, lpuv - dbpr, pm, p.width, p.bpr);
			break;
		case 2:
			ConvertLineToYUV_P8D2I4(lpy - dbpr, lpuv, lppy - dbpr, p.bpr, pm, p.width);
			break;
		case 3:
			ConvertLineToYUV_P8D2(lpy, lpuv, pm, p.width);
			break;
		}
	}

static void ConvertStripeToYUVDIThroughOSD_P8D2TopFieldLine(const YUVVideoConverterParameter & p, BYTE * lpy, BYTE * lppy, BYTE * lpuv, int hi, BYTE * pm)
	{
	int yo = hi - p.yosdoffset;
	BYTE * lpo;

	if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
		{
		lpo = p.po + p.obpr * (hi - p.yosdstart);

		if (hi >= p.height - 4) hi = 0;

		switch (hi & 3)
			{
			case 0:
				ConvertLineToYUVWithOSD_P8D2(lpy, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				break;
			case 1:
				ConvertLineToYUVWithOSD_P8D2I4(lpy, lpuv, lppy, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				break;
			case 2:
				ConvertLineToYUVWithOSD_P8D2MUV(lpy, lpuv, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				break;
			case 3:
				ConvertLineToYUVWithOSD_P8D2I4(lpy, lpuv, lppy, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				break;
			}
		}
	else
		{
		if (hi >= p.height - 4) hi = 0;

		switch (hi & 3)
			{
			case 0:
				ConvertLineToYUV_P8D2(lpy, lpuv, pm, p.width);
				break;
			case 1:
				ConvertLineToYUV_P8D2I4(lpy, lpuv, lppy, p.bpr, pm, p.width);
				break;
			case 2:
				ConvertLineToYUV_P8D2MUV(lpy, lpuv, pm, p.width, p.bpr);
				break;
			case 3:
				ConvertLineToYUV_P8D2I4MUV(lpy, lpuv, lppy, p.bpr, pm, p.width);
				break;
			}
		}
	}

static void ConvertStripeToYUVDIThroughOSD_P8D2BottomFieldLine(const YUVVideoConverterParameter & p, BYTE * lpy, BYTE * lppy, BYTE * lpuv, int hi, BYTE * pm)
	{
	int dbpr = p.bpr * 2;
	int yo = hi - p.yosdoffset;
	BYTE * lpo;

	if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
		{
		lpo = p.po + p.obpr * (hi - p.yosdstart);

		if (hi < 4) hi = 3;

		switch (hi & 3)
			{
			case 0:
				ConvertLineToYUVWithOSD_P8D2I4(lpy - dbpr, lppy - dbpr, lpuv - dbpr, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				break;
			case 1:
				ConvertLineToYUVWithOSD_P8D2MUV(lpy, lpuv - dbpr, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				break;
			case 2:
				ConvertLineToYUVWithOSD_P8D2I4(lpy - dbpr, lpuv, lppy - dbpr, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				break;
			case 3:
				ConvertLineToYUVWithOSD_P8D2(lpy, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				break;
			}
		}
	else
		{
		if (hi < 4) hi = 3;

		switch (hi & 3)
			{
			case 0:
				ConvertLineToYUV_P8D2I4MUV(lpy - dbpr, lpuv - dbpr, lppy - dbpr, p.bpr, pm, p.width);
				break;
			case 1:
				ConvertLineToYUV_P8D2MUV(lpy, lpuv - dbpr, pm, p.width, p.bpr);
				break;
			case 2:
				ConvertLineToYUV_P8D2I4(lpy - dbpr, lpuv, lppy - dbpr, p.bpr, pm, p.width);
				break;
			case 3:
				ConvertLineToYUV_P8D2(lpy, lpuv, pm, p.width);
				break;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVDI_P8DSY2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv;
	int hi, lo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	int predpos, predhi;

	predhi = -1;
	predpos = 0;

	if (p.yfraction == 0x10000)
		{
		ConvertStripeToYUVDI_P8DS(p);
		}
	else
		{
		switch (p.xscale)
			{
			case 0:
				if (p.topField)
					{
					for(y=p.ystart; y<p.ystop; y++)
						{
						hi = ycount >> 16;
						lo = (ycount & 0xffff) >> 8;

						if (hi != predhi)
							{
							lpy  = p.py  + p.bpr * (hi & ~1);
							lppy = p.ppy + p.bpr * (hi & ~1);
							lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

							ConvertStripeToYUVDI_P8D1TopFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);
							}

						predpos = 1440 - predpos;

						hi += 1;

						lpy  = p.py  + p.bpr * (hi & ~1);
						lppy = p.ppy + p.bpr * (hi & ~1);
						lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

						ConvertStripeToYUVDI_P8D1TopFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);

						predhi = hi;

						ScaleYUVLines_P8Y2(yuvcache + 1440 - predpos, yuvcache + predpos, pm, p.width, lo);

						pm += p.mbpr;
						ycount += p.yfraction;
						}
					}
				else
					{
					for(y=p.ystart; y<p.ystop; y++)
						{
						hi = ycount >> 16;
						lo = (ycount & 0xffff) >> 8;

						if (hi != predhi)
							{
							lpy  = p.py  + p.bpr * (hi | 1);
							lppy = p.ppy + p.bpr * (hi | 1);
							lpuv = p.puv + p.bpr * ((hi >> 1) | 1);

							ConvertStripeToYUVDI_P8D1BottomFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);
							}

						predpos = 1440 - predpos;

						hi += 1;

						lpy  = p.py  + p.bpr * (hi | 1);
						lppy = p.ppy + p.bpr * (hi | 1);
						lpuv = p.puv + p.bpr * ((hi >> 1) | 1);

						ConvertStripeToYUVDI_P8D1BottomFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);

						predhi = hi;

						ScaleYUVLines_P8Y2(yuvcache + 1440 - predpos, yuvcache + predpos, pm, p.width, lo);

						pm += p.mbpr;
						ycount += p.yfraction;
						}
					}
				break;
			case 1:
				if (p.topField)
					{
					for(y=p.ystart; y<p.ystop; y++)
						{
						hi = ycount >> 16;
						lo = (ycount & 0xffff) >> 8;

						if (hi != predhi)
							{
							lpy  = p.py  + p.bpr * (hi & ~1);
							lppy = p.ppy + p.bpr * (hi & ~1);
							lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

							ConvertStripeToYUVDI_P8D2TopFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);
							}

						predpos = 1440 - predpos;

						hi += 1;

						lpy  = p.py  + p.bpr * (hi & ~1);
						lppy = p.ppy + p.bpr * (hi & ~1);
						lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

						ConvertStripeToYUVDI_P8D2TopFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);

						predhi = hi;

						ScaleYUVLines_P8Y2(yuvcache + 1440 - predpos, yuvcache + predpos, pm, p.width >> 1, lo);

						pm += p.mbpr;
						ycount += p.yfraction;
						}
					}
				else
					{
					for(y=p.ystart; y<p.ystop; y++)
						{
						hi = ycount >> 16;
						lo = (ycount & 0xffff) >> 8;

						if (hi != predhi)
							{
							lpy  = p.py  + p.bpr * (hi | 1);
							lppy = p.ppy + p.bpr * (hi | 1);
							lpuv = p.puv + p.bpr * ((hi >> 1) | 1);

							ConvertStripeToYUVDI_P8D2BottomFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);
							}

						predpos = 1440 - predpos;

						hi += 1;

						lpy  = p.py  + p.bpr * (hi | 1);
						lppy = p.ppy + p.bpr * (hi | 1);
						lpuv = p.puv + p.bpr * ((hi >> 1) | 1);

						ConvertStripeToYUVDI_P8D2BottomFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);

						predhi = hi;

						ScaleYUVLines_P8Y2(yuvcache + 1440 - predpos, yuvcache + predpos, pm, p.width >> 1, lo);

						pm += p.mbpr;
						ycount += p.yfraction;
						}
					}
				break;
			default:
				ConvertStripeToYUVDI_P8DS(p);
				break;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVDIThroughOSD_P8DSY2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv;
	int hi, lo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	int predpos, predhi;

	predhi = -1;
	predpos = 0;

	if (p.yfraction == 0x10000)
		{
		ConvertStripeToYUVDIThroughOSD_P8DS(p);
		}
	else
		{
		switch (p.xscale)
			{
			case 0:
				if (p.topField)
					{
					for(y=p.ystart; y<p.ystop; y++)
						{
						hi = ycount >> 16;
						lo = (ycount & 0xffff) >> 8;

						if (hi != predhi)
							{
							lpy  = p.py  + p.bpr * (hi & ~1);
							lppy = p.ppy + p.bpr * (hi & ~1);
							lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

							ConvertStripeToYUVDIThroughOSD_P8D1TopFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);
							}

						predpos = 1440 - predpos;

						hi += 1;

						lpy  = p.py  + p.bpr * (hi & ~1);
						lppy = p.ppy + p.bpr * (hi & ~1);
						lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

						ConvertStripeToYUVDIThroughOSD_P8D1TopFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);

						predhi = hi;

						ScaleYUVLines_P8Y2(yuvcache + 1440 - predpos, yuvcache + predpos, pm, p.width, lo);

						pm += p.mbpr;
						ycount += p.yfraction;
						}
					}
				else
					{
					for(y=p.ystart; y<p.ystop; y++)
						{
						hi = ycount >> 16;
						lo = (ycount & 0xffff) >> 8;

						if (hi != predhi)
							{
							lpy  = p.py  + p.bpr * (hi | 1);
							lppy = p.ppy + p.bpr * (hi | 1);
							lpuv = p.puv + p.bpr * ((hi >> 1) | 1);

							ConvertStripeToYUVDIThroughOSD_P8D1BottomFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);
							}

						predpos = 1440 - predpos;

						hi += 1;

						lpy  = p.py  + p.bpr * (hi | 1);
						lppy = p.ppy + p.bpr * (hi | 1);
						lpuv = p.puv + p.bpr * ((hi >> 1) | 1);

						ConvertStripeToYUVDIThroughOSD_P8D1BottomFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);

						predhi = hi;

						ScaleYUVLines_P8Y2(yuvcache + 1440 - predpos, yuvcache + predpos, pm, p.width, lo);

						pm += p.mbpr;
						ycount += p.yfraction;
						}
					}
				break;
			case 1:
				if (p.topField)
					{
					for(y=p.ystart; y<p.ystop; y++)
						{
						hi = ycount >> 16;
						lo = (ycount & 0xffff) >> 8;

						if (hi != predhi)
							{
							lpy  = p.py  + p.bpr * (hi & ~1);
							lppy = p.ppy + p.bpr * (hi & ~1);
							lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

							ConvertStripeToYUVDIThroughOSD_P8D2TopFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);
							}

						predpos = 1440 - predpos;

						hi += 1;

						lpy  = p.py  + p.bpr * (hi & ~1);
						lppy = p.ppy + p.bpr * (hi & ~1);
						lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

						ConvertStripeToYUVDIThroughOSD_P8D2TopFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);

						predhi = hi;

						ScaleYUVLines_P8Y2(yuvcache + 1440 - predpos, yuvcache + predpos, pm, p.width, lo);

						pm += p.mbpr;
						ycount += p.yfraction;
						}
					}
				else
					{
					for(y=p.ystart; y<p.ystop; y++)
						{
						hi = ycount >> 16;
						lo = (ycount & 0xffff) >> 8;

						if (hi != predhi)
							{
							lpy  = p.py  + p.bpr * (hi | 1);
							lppy = p.ppy + p.bpr * (hi | 1);
							lpuv = p.puv + p.bpr * ((hi >> 1) | 1);

							ConvertStripeToYUVDIThroughOSD_P8D2BottomFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);
							}

						predpos = 1440 - predpos;

						hi += 1;

						lpy  = p.py  + p.bpr * (hi | 1);
						lppy = p.ppy + p.bpr * (hi | 1);
						lpuv = p.puv + p.bpr * ((hi >> 1) | 1);

						ConvertStripeToYUVDIThroughOSD_P8D2BottomFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);

						predhi = hi;

						ScaleYUVLines_P8Y2(yuvcache + 1440 - predpos, yuvcache + predpos, pm, p.width, lo);

						pm += p.mbpr;
						ycount += p.yfraction;
						}
					}
				break;
			default:
				ConvertStripeToYUVDIThroughOSD_P8DS(p);
				break;
			}
		}
	}


void XMMXYUVVideoConverter::ConvertStripeToYUVDI_P8F2Y2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv;
	int hi, lo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	int predpos, predhi;

	predhi = -1;
	predpos = 0;

	if (p.yfraction == 0x10000)
		{
		ConvertStripeToYUVDI_P8F2(p);
		}
	else if (p.xfraction == 0x10000)
		{
		ConvertStripeToYUVDI_P8DS(p);
		}
	else
		{
		if (p.topField)
			{
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;
				lo = (ycount & 0xffff) >> 8;

				if (hi != predhi)
					{
					lpy  = p.py  + p.bpr * (hi & ~1);
					lppy = p.ppy + p.bpr * (hi & ~1);
					lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

					ConvertStripeToYUVDI_P8D1TopFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);
					}

				predpos = 1440 - predpos;

				hi += 1;

				lpy  = p.py  + p.bpr * (hi & ~1);
				lppy = p.ppy + p.bpr * (hi & ~1);
				lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

				ConvertStripeToYUVDI_P8D1TopFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);

				predhi = hi;

				ScaleYUVLines_P8Y2(yuvcache + 1440 - predpos, yuvcache + predpos, yuvcache + 1440 - predpos, p.width, lo);
				ScaleYUVLine_P8F2(yuvcache + 1440 - predpos, pm, p.mwidth, 0, p.xfraction);

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			}
		else
			{
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;
				lo = (ycount & 0xffff) >> 8;

				if (hi != predhi)
					{
					lpy  = p.py  + p.bpr * (hi | 1);
					lppy = p.ppy + p.bpr * (hi | 1);
					lpuv = p.puv + p.bpr * ((hi >> 1) | 1);

					ConvertStripeToYUVDI_P8D1BottomFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);
					}

				predpos = 1440 - predpos;

				hi += 1;

				lpy  = p.py  + p.bpr * (hi | 1);
				lppy = p.ppy + p.bpr * (hi | 1);
				lpuv = p.puv + p.bpr * ((hi >> 1) | 1);

				ConvertStripeToYUVDI_P8D1BottomFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);

				predhi = hi;

				ScaleYUVLines_P8Y2(yuvcache + 1440 - predpos, yuvcache + predpos, yuvcache + 1440 - predpos, p.width, lo);
				ScaleYUVLine_P8F2(yuvcache + 1440 - predpos, pm, p.mwidth, 0, p.xfraction);

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVDIThroughOSD_P8F2Y2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv;
	int hi, lo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	int predpos, predhi;

	predhi = -1;
	predpos = 0;

	if (p.yfraction == 0x10000)
		{
		ConvertStripeToYUVDIThroughOSD_P8F2(p);
		}
	else if (p.xfraction == 0x10000)
		{
		ConvertStripeToYUVDIThroughOSD_P8DS(p);
		}
	else
		{
		if (p.topField)
			{
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;
				lo = (ycount & 0xffff) >> 8;

				if (hi != predhi)
					{
					lpy  = p.py  + p.bpr * (hi & ~1);
					lppy = p.ppy + p.bpr * (hi & ~1);
					lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

					ConvertStripeToYUVDIThroughOSD_P8D1TopFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);
					}

				predpos = 1440 - predpos;

				hi += 1;

				lpy  = p.py  + p.bpr * (hi & ~1);
				lppy = p.ppy + p.bpr * (hi & ~1);
				lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

				ConvertStripeToYUVDIThroughOSD_P8D1TopFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);

				predhi = hi;

				ScaleYUVLines_P8Y2(yuvcache + 1440 - predpos, yuvcache + predpos, yuvcache + 1440 - predpos, p.width, lo);
				ScaleYUVLine_P8F2(yuvcache + 1440 - predpos, pm, p.mwidth, 0, p.xfraction);

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			}
		else
			{
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;
				lo = (ycount & 0xffff) >> 8;

				if (hi != predhi)
					{
					lpy  = p.py  + p.bpr * (hi | 1);
					lppy = p.ppy + p.bpr * (hi | 1);
					lpuv = p.puv + p.bpr * ((hi >> 1) | 1);

					ConvertStripeToYUVDIThroughOSD_P8D1BottomFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);
					}

				predpos = 1440 - predpos;

				hi += 1;

				lpy  = p.py  + p.bpr * (hi | 1);
				lppy = p.ppy + p.bpr * (hi | 1);
				lpuv = p.puv + p.bpr * ((hi >> 1) | 1);

				ConvertStripeToYUVDIThroughOSD_P8D1BottomFieldLine(p, lpy, lppy, lpuv, hi, yuvcache + predpos);

				predhi = hi;

				ScaleYUVLines_P8Y2(yuvcache + 1440 - predpos, yuvcache + predpos, yuvcache + 1440 - predpos, p.width, lo);
				ScaleYUVLine_P8F2(yuvcache + 1440 - predpos, pm, p.mwidth, 0, p.xfraction);

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			}
		}
	}

///////////////////////////////

void XMMXYUVVideoConverter::ConvertStripeToYUV32PDFieldField_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	switch (p.xscale)
		{
		case 0:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				if ((y & 1) == 0)
					{
					lpy  = p.py + p.bpr * hi;
					lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);
					}
				else
					{
					lpy  = p.ppy + p.bpr * hi;
					lpuv = p.ppuv + p.bpr * ((hi >> 1) | 1);
					}

				ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		case 1:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				if ((y & 1) == 0)
					{
					lpy  = p.py + p.bpr * hi;
					lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);
					}
				else
					{
					lpy  = p.ppy + p.bpr * hi;
					lpuv = p.ppuv + p.bpr * ((hi >> 1) | 1);
					}

				ConvertLineToYUV_P8D2(lpy, lpuv, pm, p.width);

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUV32PDFieldFieldThroughOSD_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv, * lpo;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	switch (p.xscale)
		{
		case 0:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				if ((y & 1) == 0)
					{
					lpy  = p.py + p.bpr * hi;
					lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);
					}
				else
					{
					lpy  = p.ppy + p.bpr * hi;
					lpuv = p.ppuv + p.bpr * ((hi >> 1) | 1);
					}

				if (hi >= p.yosdstart && hi < p.yosdstop)
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
					}
				else
					{
					ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
					}

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		case 1:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				if ((y & 1) == 0)
					{
					lpy  = p.py + p.bpr * hi;
					lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);
					}
				else
					{
					lpy  = p.ppy + p.bpr * hi;
					lpuv = p.ppuv + p.bpr * ((hi >> 1) | 1);
					}

				if (hi >= p.yosdstart && hi < p.yosdstop)
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					ConvertLineToYUVWithOSD_P8D2(lpy, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
					}
				else
					{
					ConvertLineToYUV_P8D2(lpy, lpuv, pm, p.width);
					}

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUV32PDFrameFieldThroughOSD_P8DS(const YUVVideoConverterParameter & p)
	{
	ConvertStripeToYUVThroughOSD_P8DS(p);
	}

void XMMXYUVVideoConverter::ConvertStripeToYUV32PDFrameField_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv, * lppuv;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	if (p.xscale == 0)
		{
		if (p.topField)
			{
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				if ((y & 1) == 1)
					{
					lpy  = p.py + p.bpr * hi;
					lpuv = p.puv + p.bpr * ((hi >> 1) | 1);

					ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
					}
				else
					{
					lpy   = p.py   + p.bpr * hi;
					lpuv  = p.puv  + p.bpr * ((hi >> 1) & ~1);
					lppy  = p.ppy  + p.bpr * hi;
					lppuv = p.ppuv + p.bpr * ((hi >> 1) & ~1);

					ConvertLineToYUV_P8D1M(lpy, lpuv, lppy, lppuv, pm, p.width);
					}

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			}
		else
			{
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				if ((y & 1) == 0)
					{
					lpy  = p.py + p.bpr * hi;
					lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

					ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
					}
				else
					{
					lpy   = p.py   + p.bpr * hi;
					lpuv  = p.puv  + p.bpr * ((hi >> 1) | 1);
					lppy  = p.ppy  + p.bpr * hi;
					lppuv = p.ppuv + p.bpr * ((hi >> 1) | 1);

					ConvertLineToYUV_P8D1M(lpy, lpuv, lppy, lppuv, pm, p.width);
					}


				pm += p.mbpr;
				ycount += p.yfraction;
				}
			}
		}
	else
		ConvertStripeToYUV_P8DS(p);
	}

///////////////////////////////

void XMMXYUVVideoConverter::ConvertStripeToYUV32PDFieldField_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	if (p.xfraction == 0x10000)
		ConvertStripeToYUV32PDFieldField_P8DS(p);
	else
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;

			if ((y & 1) == 0)
				{
				lpy  = p.py + p.bpr * hi;
				lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);
				}
			else
				{
				lpy  = p.ppy + p.bpr * hi;
				lpuv = p.ppuv + p.bpr * ((hi >> 1) | 1);
				}

			ConvertLineToYUV_P8F2(lpy, lpuv, pm, p.mwidth, 0, p.xfraction);

			pm += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUV32PDFieldFieldThroughOSD_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv, * lpo;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	if (p.xfraction == 0x10000)
		ConvertStripeToYUV32PDFieldFieldThroughOSD_P8DS(p);
	else
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;

			if ((y & 1) == 0)
				{
				lpy  = p.py + p.bpr * hi;
				lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);
				}
			else
				{
				lpy  = p.ppy + p.bpr * hi;
				lpuv = p.ppuv + p.bpr * ((hi >> 1) | 1);
				}

			if (hi >= p.yosdstart && hi < p.yosdstop)
				{
				lpo = p.po + p.obpr * (hi - p.yosdstart);

				ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);

				ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
				}
			else
				{
				ConvertLineToYUV_P8F2(lpy, lpuv, pm, p.mwidth, 0, p.xfraction);
				}

			pm += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUV32PDFrameFieldThroughOSD_P8F2(const YUVVideoConverterParameter & p)
	{
	ConvertStripeToYUVThroughOSD_P8F2(p);
	}

void XMMXYUVVideoConverter::ConvertStripeToYUV32PDFrameField_P8F2(const YUVVideoConverterParameter & p)
	{
	if (p.xfraction == 0x10000)
		ConvertStripeToYUV32PDFrameField_P8DS(p);
	else
		ConvertStripeToYUV_P8F2(p);
	}

// new -> 01/26/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVAI_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy0, * lpy1, * lpy2;
	BYTE * lpuv0, * lpuv1, * lpuv2;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	switch (p.xscale)
		{
		case 0:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy0  = p.py  + p.bpr * (hi - 1 & p.stripeMask);
				lpuv0 = p.puv + p.bpr * ((hi - 2 & p.stripeMask) >> 1);
				lpy1  = p.py  + p.bpr * (hi & p.stripeMask);
				lpuv1 = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);
				lpy2  = p.py  + p.bpr * (hi + 1 & p.stripeMask);
				lpuv2 = p.puv + p.bpr * ((hi + 2 & p.stripeMask) >> 1);

				if (hi >= 2 && hi < p.height - 2)
//				if (hi >= 2 && hi < p.height - 1)
					ConvertLineToYUV_P8D1MV(lpy0, lpuv0, lpy1, lpuv1, lpy2, lpuv2, pm, p.width);
				else
					ConvertLineToYUV_P8D1(lpy1, lpuv1, pm, p.width);

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		case 1:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy0  = p.py  + p.bpr * (hi - 1 & p.stripeMask);
				lpuv0 = p.puv + p.bpr * ((hi - 2 & p.stripeMask) >> 1);
				lpy1  = p.py  + p.bpr * (hi & p.stripeMask);
				lpuv1 = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);
				lpy2  = p.py  + p.bpr * (hi + 1 & p.stripeMask);
				lpuv2 = p.puv + p.bpr * ((hi + 2 & p.stripeMask) >> 1);

				if (hi >= 2 && hi < p.height - 2)
//				if (hi >= 2 && hi < p.height - 1)
					ConvertLineToYUV_P8D2MV(lpy0, lpuv0, lpy1, lpuv1, lpy2, lpuv2, pm, p.width);
				else
					ConvertLineToYUV_P8D2(lpy1, lpuv1, pm, p.width);

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		default:
			for(y = p.ystart; y < p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy0  = p.py  + p.bpr * ((hi & p.stripeMask) & ~1);
				lpuv0 = p.puv + p.bpr * (((hi & p.stripeMask) >> 1) & ~1);

				ConvertLineToYUV_P8DS(lpy0, lpuv0, pm, p.width, p.xscale);

				ycount += p.yfraction;
				pm += p.mbpr;
				}
			break;
		}
	}
// <- new 01/26/2000

// new -> 01/26/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVAIThroughOSD_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy0, * lpy1, * lpy2;
	BYTE * lpuv0, * lpuv1, * lpuv2;
	BYTE * lpo;
	int hi, yo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	switch (p.xscale)
		{
		case 0:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy0  = p.py  + p.bpr * (hi - 1 & p.stripeMask);
				lpuv0 = p.puv + p.bpr * ((hi - 2 & p.stripeMask) >> 1);
				lpy1  = p.py  + p.bpr * (hi & p.stripeMask);
				lpuv1 = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);
				lpy2  = p.py  + p.bpr * (hi + 1 & p.stripeMask);
				lpuv2 = p.puv + p.bpr * ((hi + 2 & p.stripeMask) >> 1);

				yo = hi - p.yosdoffset;

				if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					if (hi >= 2 && hi < p.height - 2)
//					if (hi >= 2 && hi < p.height - 1)
						ConvertLineToYUVWithOSD_P8D1MV(lpy0, lpuv0, lpy1, lpuv1, lpy2, lpuv2, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
					else
						ConvertLineToYUVWithOSD_P8D1(lpy1, lpuv1, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
					}
				else
					{
					if (hi >= 2 && hi < p.height - 2)
//					if (hi >= 2 && hi < p.height - 1)
						ConvertLineToYUV_P8D1MV(lpy0, lpuv0, lpy1, lpuv1, lpy2, lpuv2, pm, p.width);
					else
						ConvertLineToYUV_P8D1(lpy1, lpuv1, pm, p.width);
					}

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		case 1:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy0  = p.py  + p.bpr * (hi - 1 & p.stripeMask);
				lpuv0 = p.puv + p.bpr * ((hi - 2 & p.stripeMask) >> 1);
				lpy1  = p.py  + p.bpr * (hi & p.stripeMask);
				lpuv1 = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);
				lpy2  = p.py  + p.bpr * (hi + 1 & p.stripeMask);
				lpuv2 = p.puv + p.bpr * ((hi + 2 & p.stripeMask) >> 1);

				yo = hi - p.yosdoffset;

				if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					if (hi >= 2 && hi < p.height - 2)
//					if (hi >= 2 && hi < p.height - 1)
						ConvertLineToYUVWithOSD_P8D2MV(lpy0, lpuv0, lpy1, lpuv1, lpy2, lpuv2, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
					else
						ConvertLineToYUVWithOSD_P8D2(lpy1, lpuv1, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
					}
				else
					{
					if (hi >= 2 && hi < p.height - 2)
//					if (hi >= 2 && hi < p.height - 1)
						ConvertLineToYUV_P8D2MV(lpy0, lpuv0, lpy1, lpuv1, lpy2, lpuv2, pm, p.width);
					else
						ConvertLineToYUV_P8D2(lpy1, lpuv1, pm, p.width);
					}

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		default:
			for(y = p.ystart; y < p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy0  = p.py  + p.bpr * ((hi & p.stripeMask) & ~1);
				lpuv0 = p.puv + p.bpr * (((hi & p.stripeMask) >> 1) & ~1);

				ConvertLineToYUV_P8DS(lpy0, lpuv0, pm, p.width, p.xscale);

				ycount += p.yfraction;
				pm += p.mbpr;
				}
			break;
		}
	}
// <- new 01/26/2000

// new -> 01/26/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVAI_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy0, * lpy1, * lpy2;
	BYTE * lpuv0, * lpuv1, * lpuv2;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	if (p.xfraction == 0x10000)
		{
		ConvertStripeToYUVAI_P8DS(p);
		}
	else
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;

			lpy0  = p.py  + p.bpr * (hi - 1 & p.stripeMask);
			lpuv0 = p.puv + p.bpr * ((hi - 2 & p.stripeMask) >> 1);
			lpy1  = p.py  + p.bpr * (hi & p.stripeMask);
			lpuv1 = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);
			lpy2  = p.py  + p.bpr * (hi + 1 & p.stripeMask);
			lpuv2 = p.puv + p.bpr * ((hi + 2 & p.stripeMask) >> 1);

			if (hi >= 2 && hi < p.height - 2)
//			if (hi >= 2 && hi < p.height - 1)
				{
				ConvertLineToYUV_P8D1MV(lpy0, lpuv0, lpy1, lpuv1, lpy2, lpuv2, yuvcache, p.width);
				ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
				}
			else
				ConvertLineToYUV_P8F2(lpy1, lpuv1, pm, p.mwidth, 0, p.xfraction);

			pm += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}
// <- new 01/26/2000

// new -> 01/26/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVAIThroughOSD_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy0, * lpy1, * lpy2;
	BYTE * lpuv0, * lpuv1, * lpuv2;
	BYTE * lpo;
	int hi, yo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	if (p.xfraction == 0x10000)
		{
		ConvertStripeToYUVAIThroughOSD_P8DS(p);
		}
	else
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;

			lpy0  = p.py  + p.bpr * (hi - 1 & p.stripeMask);
			lpuv0 = p.puv + p.bpr * ((hi - 2 & p.stripeMask) >> 1);
			lpy1  = p.py  + p.bpr * (hi & p.stripeMask);
			lpuv1 = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);
			lpy2  = p.py  + p.bpr * (hi + 1 & p.stripeMask);
			lpuv2 = p.puv + p.bpr * ((hi + 2 & p.stripeMask) >> 1);

			yo = hi - p.yosdoffset;

			if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
				{
				lpo = p.po + p.obpr * (hi - p.yosdstart);

				if (hi >= 2 && hi < p.height - 2)
//				if (hi >= 2 && hi < p.height - 1)
					ConvertLineToYUVWithOSD_P8D1MV(lpy0, lpuv0, lpy1, lpuv1, lpy2, lpuv2, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				else
					ConvertLineToYUVWithOSD_P8D1(lpy1, lpuv1, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				}
			else
				{
				if (hi >= 2 && hi < p.height - 2)
//				if (hi >= 2 && hi < p.height - 1)
					ConvertLineToYUV_P8D1MV(lpy0, lpuv0, lpy1, lpuv1, lpy2, lpuv2, yuvcache, p.width);
				else
					ConvertLineToYUV_P8D1(lpy1, lpuv1, yuvcache, p.width);
				}

			ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);

			pm += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}
// <- new 01/26/2000

// new -> 01/26/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVAI_P8DSY2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy0, * lpy1, * lpy2, * lpy3;
	BYTE * lpuv0, * lpuv1, * lpuv2, * lpuv3;
	int hi, lo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	short filter[4];

	if (p.yfraction == 0x10000 || p.xscale != 0)
		{
		ConvertStripeToYUVAI_P8DS(p);
		}
	else
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;
			lo = ycount & 0xffff;

			lpy0  = p.py  + p.bpr * (hi - 1 & p.stripeMask);
			lpuv0 = p.puv + p.bpr * ((hi - 2 & p.stripeMask) >> 1);
			lpy1  = p.py  + p.bpr * (hi & p.stripeMask);
			lpuv1 = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);
			lpy2  = p.py  + p.bpr * (hi + 1 & p.stripeMask);
			lpuv2 = p.puv + p.bpr * ((hi + 2 & p.stripeMask) >> 1);
			lpy3  = p.py  + p.bpr * (hi + 2 & p.stripeMask);
			lpuv3 = p.puv + p.bpr * ((hi + 4 & p.stripeMask) >> 1);

			if (hi >= 2 && hi < p.height - 2)
				{
				filter[0] = (0x10000 - lo) >> 12;
				filter[1] = (0x10000 + lo) >> 12;
				filter[2] = (0x20000 - lo) >> 12;
				filter[3] = (0x00000 + lo) >> 12;

				ConvertLineToYUV_P8D1Y4MUV(lpy0, lpy2, lpy1, lpy3, lpuv0, lpuv1, pm, p.width, filter);
				}
			else
				ConvertLineToYUV_P8D1(lpy1, lpuv1, pm, p.width);

			pm += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}
// <- new 01/26/2000

// new -> 01/26/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVAIThroughOSD_P8DSY2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy0, * lpy1, * lpy2, * lpy3;
	BYTE * lpuv0, * lpuv1, * lpuv2, * lpuv3;
	BYTE * lpo;
	int hi, yo, lo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	short filter[4];

	if (p.yfraction == 0x10000 || p.xscale != 0)
		{
		ConvertStripeToYUVAIThroughOSD_P8DS(p);
		}
	else
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;
			lo = ycount & 0xffff;

			lpy0  = p.py  + p.bpr * (hi - 1 & p.stripeMask);
			lpuv0 = p.puv + p.bpr * ((hi - 2 & p.stripeMask) >> 1);
			lpy1  = p.py  + p.bpr * (hi & p.stripeMask);
			lpuv1 = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);
			lpy2  = p.py  + p.bpr * (hi + 1 & p.stripeMask);
			lpuv2 = p.puv + p.bpr * ((hi + 2 & p.stripeMask) >> 1);
			lpy3  = p.py  + p.bpr * (hi + 2 & p.stripeMask);
			lpuv3 = p.puv + p.bpr * ((hi + 4 & p.stripeMask) >> 1);

			yo = hi - p.yosdoffset;

			filter[0] = (0x10000 - lo) >> 12;
			filter[1] = (0x10000 + lo) >> 12;
			filter[2] = (0x20000 - lo) >> 12;
			filter[3] = (0x00000 + lo) >> 12;

			if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
				{
				lpo = p.po + p.obpr * (hi - p.yosdstart);

				if (hi >= 2 && hi < p.height - 2)
					ConvertLineToYUVWithOSD_P8D1Y4MUV(lpy0, lpy2, lpy1, lpy3, lpuv0, lpuv1, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd, filter);
				else
					ConvertLineToYUVWithOSD_P8D1(lpy1, lpuv1, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				}
			else
				{
				if (hi >= 2 && hi < p.height - 2)
					ConvertLineToYUV_P8D1Y4MUV(lpy0, lpy2, lpy1, lpy3, lpuv0, lpuv1, pm, p.width, filter);
				else
					ConvertLineToYUV_P8D1(lpy1, lpuv1, pm, p.width);
				}

			pm += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}
// <- new 01/26/2000

// new -> 01/26/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVAI_P8F2Y2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy0, * lpy1, * lpy2, * lpy3;
	BYTE * lpuv0, * lpuv1, * lpuv2, * lpuv3;
	int hi, lo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	short filter[4];

	if (p.xfraction == 0x10000)
		{
		ConvertStripeToYUVAI_P8DSY2(p);
		}
	else if (p.yfraction == 0x10000)
		{
		ConvertStripeToYUVAI_P8F2(p);
		}
	else
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;
			lo = ycount & 0xffff;

			lpy0  = p.py  + p.bpr * (hi - 1 & p.stripeMask);
			lpuv0 = p.puv + p.bpr * ((hi - 2 & p.stripeMask) >> 1);
			lpy1  = p.py  + p.bpr * (hi & p.stripeMask);
			lpuv1 = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);
			lpy2  = p.py  + p.bpr * (hi + 1 & p.stripeMask);
			lpuv2 = p.puv + p.bpr * ((hi + 2 & p.stripeMask) >> 1);
			lpy3  = p.py  + p.bpr * (hi + 2 & p.stripeMask);
			lpuv3 = p.puv + p.bpr * ((hi + 4 & p.stripeMask) >> 1);

			if (hi >= 2 && hi < p.height - 2)
				{
				filter[0] = (0x10000 - lo) >> 12;
				filter[1] = (0x10000 + lo) >> 12;
				filter[2] = (0x20000 - lo) >> 12;
				filter[3] = (0x00000 + lo) >> 12;

				ConvertLineToYUV_P8D1Y4MUV(lpy0, lpy2, lpy1, lpy3, lpuv0, lpuv1, yuvcache, p.width, filter);
				ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
				}
			else
				ConvertLineToYUV_P8F2(lpy1, lpuv1, pm, p.mwidth, 0, p.xfraction);

			pm += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}
// <- new 01/26/2000

// new -> 01/26/2000
void XMMXYUVVideoConverter::ConvertStripeToYUVAIThroughOSD_P8F2Y2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy0, * lpy1, * lpy2, * lpy3;
	BYTE * lpuv0, * lpuv1, * lpuv2, * lpuv3;
	BYTE * lpo;
	int hi, yo, lo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	short filter[4];

	if (p.xfraction == 0x10000)
		{
		ConvertStripeToYUVAIThroughOSD_P8DSY2(p);
		}
	else if (p.yfraction == 0x10000)
		{
		ConvertStripeToYUVAIThroughOSD_P8F2(p);
		}
	else
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;
			lo = ycount & 0xffff;

			lpy0  = p.py  + p.bpr * (hi - 1 & p.stripeMask);
			lpuv0 = p.puv + p.bpr * ((hi - 2 & p.stripeMask) >> 1);
			lpy1  = p.py  + p.bpr * (hi & p.stripeMask);
			lpuv1 = p.puv + p.bpr * ((hi & p.stripeMask) >> 1);
			lpy2  = p.py  + p.bpr * (hi + 1 & p.stripeMask);
			lpuv2 = p.puv + p.bpr * ((hi + 2 & p.stripeMask) >> 1);
			lpy3  = p.py  + p.bpr * (hi + 2 & p.stripeMask);
			lpuv3 = p.puv + p.bpr * ((hi + 4 & p.stripeMask) >> 1);

			filter[0] = (0x10000 - lo) >> 12;
			filter[1] = (0x10000 + lo) >> 12;
			filter[2] = (0x20000 - lo) >> 12;
			filter[3] = (0x00000 + lo) >> 12;

			yo = hi - p.yosdoffset;

			if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
				{
				lpo = p.po + p.obpr * (hi - p.yosdstart);

				if (hi >= 2 && hi < p.height - 2)
					ConvertLineToYUVWithOSD_P8D1Y4MUV(lpy0, lpy2, lpy1, lpy3, lpuv0, lpuv1, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd, filter);
				else
					ConvertLineToYUVWithOSD_P8D1(lpy1, lpuv1, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				}
			else
				{
				if (hi >= 2 && hi < p.height - 2)
					ConvertLineToYUV_P8D1Y4MUV(lpy0, lpy2, lpy1, lpy3, lpuv0, lpuv1, yuvcache, p.width, filter);
				else
					ConvertLineToYUV_P8D1(lpy1, lpuv1, yuvcache, p.width);
				}

			ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);

			pm += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}
// <- new 01/26/2000

void XMMXYUVVideoConverter::ConvertStripeToYUVDI2_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv, * lppuv, * lpytb, * lpuvtb;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	BYTE * ppm = p.ppm;
	BYTE * pmt = p.pmt;
	BYTE * pmb = p.pmb;
	int dbpr = p.bpr * 2;

	switch (p.xscale)
		{
		case 0:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy  = p.py  + p.bpr * (hi & ~1);
				lppy = p.ppy + p.bpr * (hi & ~1);
				lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);
				lpytb = p.pytb + p.bpr * (hi & ~1);
				lpuvtb = p.puvtb + p.bpr * ((hi >> 1) & ~1);

				if (hi < p.height - 4)
					{
					switch (hi & 3)
						{
						case 0:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUV_P8D1(lpytb, lpuvtb, pmt, p.width);
							break;
						case 1:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUV_P8D1I4(lpy, lpuv, lppy, p.bpr, pm, p.width);
							break;
						case 2:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUV_P8D1MUV(lpytb, lpuvtb, pmt, p.width, p.bpr);
							break;
						case 3:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUV_P8D1I4MUV(lpy, lpuv, lppy, p.bpr, pm, p.width);
							break;
						}
					}
				else
					{
					if ((hi & 1) != 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							ConvertLineToYUV_P8D1(lpytb, lpuvtb, pmt, p.width);
						}
					}

				hi = ycount >> 16;

				lpy   = p.py   + p.bpr * (hi | 1);
				lppy  = p.ppy  + p.bpr * (hi | 1);
				lppuv = p.ppuv + p.bpr * ((hi >> 1) | 1);
				lpytb = p.pytb + p.bpr * (hi | 1);
				lpuvtb = p.puvtb + p.bpr * ((hi >> 1) | 1);

				if (hi >= 4)
					{
					switch (hi & 3)
						{
						case 0:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								ConvertLineToYUV_P8D1I4MUV(lppy - dbpr, lppuv - dbpr, lpy - dbpr, p.bpr, ppm, p.width);
							break;
						case 1:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUV_P8D1MUV(lpytb, lpuvtb - dbpr, pmb, p.width, p.bpr);
							break;
						case 2:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								ConvertLineToYUV_P8D1I4(lppy - dbpr, lppuv, lpy - dbpr, p.bpr, ppm, p.width);
							break;
						case 3:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUV_P8D1(lpytb, lpuvtb, pmb, p.width);
							break;
						}
					}
				else
					{
					if ((hi & 1) == 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							ConvertLineToYUV_P8D1(lppy, lppuv, ppm, p.width);
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							ConvertLineToYUV_P8D1(lpytb, lpuvtb, pmb, p.width);
						}
					}

				pm += p.mbpr;
				ppm += p.mbpr;
				pmb += p.mbpr;
				pmt += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		case 1:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy  = p.py  + p.bpr * (hi & ~1);
				lppy = p.ppy + p.bpr * (hi & ~1);
				lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);
				lpytb = p.pytb + p.bpr * (hi & ~1);
				lpuvtb = p.puvtb + p.bpr * ((hi >> 1) & ~1);

				if (hi < p.height - 4)
					{
					switch (hi & 3)
						{
						case 0:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUV_P8D2(lpytb, lpuvtb, pmt, p.width);
							break;
						case 1:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUV_P8D2I4(lpy, lpuv, lppy, p.bpr, pm, p.width);
							break;
						case 2:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUV_P8D2MUV(lpytb, lpuvtb, pmt, p.width, p.bpr);
							break;
						case 3:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUV_P8D2I4MUV(lpy, lpuv, lppy, p.bpr, pm, p.width);
							break;
						}
					}
				else
					{
					if ((hi & 1) != 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							ConvertLineToYUV_P8D2(lpy, lpuv, pm, p.width);
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							ConvertLineToYUV_P8D2(lpytb, lpuvtb, pmt, p.width);
						}
					}

				hi = ycount >> 16;

				lpy   = p.py   + p.bpr * (hi | 1);
				lppy  = p.ppy  + p.bpr * (hi | 1);
				lppuv = p.ppuv + p.bpr * ((hi >> 1) | 1);
				lpytb = p.pytb + p.bpr * (hi | 1);
				lpuvtb = p.puvtb + p.bpr * ((hi >> 1) | 1);

				if (hi >= 4)
					{
					switch (hi & 3)
						{
						case 0:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								ConvertLineToYUV_P8D2I4MUV(lppy - dbpr, lppuv - dbpr, lpy - dbpr, p.bpr, ppm, p.width);
							break;
						case 1:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUV_P8D2MUV(lpytb, lpuvtb - dbpr, pmb, p.width, p.bpr);
							break;
						case 2:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								ConvertLineToYUV_P8D2I4(lppy - dbpr, lppuv, lpy - dbpr, p.bpr, ppm, p.width);
							break;
						case 3:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUV_P8D2(lpytb, lpuvtb, pmb, p.width);
							break;
						}
					}
				else
					{
					if ((hi & 1) == 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							ConvertLineToYUV_P8D2(lppy, lppuv, ppm, p.width);
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							ConvertLineToYUV_P8D2(lpytb, lpuvtb, pmb, p.width);
						}
					}

				pm += p.mbpr;
				ppm += p.mbpr;
				pmb += p.mbpr;
				pmt += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		default:
			for(y = p.ystart; y < p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy  = p.py  + p.bpr * (hi & ~1);
				lppy  = p.ppy  + p.bpr * (hi | 1);
				lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);
				lppuv = p.puv + p.bpr * ((hi >> 1) | 1);

				ConvertLineToYUV_P8DS(lpy, lpuv, pm, p.width, p.xscale);
				ConvertLineToYUV_P8DS(lppy, lppuv, ppm, p.width, p.xscale);

				ycount += p.yfraction;
				pm += p.mbpr;
				ppm += p.mbpr;
				}
			break;
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVDI2ThroughOSD_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv, * lppuv, * lpytb, * lpuvtb, * lpo;
	int hi, yo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	BYTE * ppm = p.ppm;
	BYTE * pmt = p.pmt;
	BYTE * pmb = p.pmb;
	int dbpr = p.bpr * 2;

	switch (p.xscale)
		{
		case 0:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy  = p.py  + p.bpr * (hi & ~1);
				lppy = p.ppy + p.bpr * (hi & ~1);
				lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);
				lpytb = p.pytb + p.bpr * (hi & ~1);
				lpuvtb = p.puvtb + p.bpr * ((hi >> 1) & ~1);

				yo = hi - p.yosdoffset;

				if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					if (hi < p.height - 4)
						{
						switch (hi & 3)
							{
							case 0:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUVWithOSD_P8D1(lpytb, lpuvtb, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 1:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D1I4(lpy, lpuv, lppy, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 2:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUVWithOSD_P8D1(lpytb, lpuvtb, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 3:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D1I4(lpy, lpuv, lppy, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							}
						}
					else
						{
						if ((hi & 1) != 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUVWithOSD_P8D1(lpytb, lpuvtb, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						}
					}
				else
					{
					if (hi < p.height - 4)
						{
						switch (hi & 3)
							{
							case 0:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUV_P8D1(lpytb, lpuvtb, pmt, p.width);
								break;
							case 1:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUV_P8D1I4(lpy, lpuv, lppy, p.bpr, pm, p.width);
								break;
							case 2:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUV_P8D1MUV(lpytb, lpuvtb, pmt, p.width, p.bpr);
								break;
							case 3:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUV_P8D1I4MUV(lpy, lpuv, lppy, p.bpr, pm, p.width);
								break;
							}
						}
					else
						{
						if ((hi & 1) != 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUV_P8D1(lpy, lpuv, pm, p.width);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUV_P8D1(lpytb, lpuvtb, pmt, p.width);
							}
						}
					}

				hi = ycount >> 16;

				lpy   = p.py   + p.bpr * (hi | 1);
				lppy  = p.ppy  + p.bpr * (hi | 1);
				lppuv = p.ppuv + p.bpr * ((hi >> 1) | 1);
				lpytb = p.pytb + p.bpr * (hi | 1);
				lpuvtb = p.puvtb + p.bpr * ((hi >> 1) | 1);

				if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					if (hi < p.height - 4 && hi >= 4)
//					if (hi < p.height - 4)
						{
						switch (hi & 3)
							{
							case 0:
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D1I4(lppy - dbpr, lppuv - dbpr, lpy - dbpr, p.bpr, ppm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 1:
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUVWithOSD_P8D1(lpytb, lpuvtb, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 2:
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D1I4(lppy - dbpr, lppuv, lpy - dbpr, p.bpr, ppm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 3:
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUVWithOSD_P8D1(lpytb, lpuvtb, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							}
						}
					else
						{
						if ((hi & 1) != 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D1(lppy, lppuv, ppm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUVWithOSD_P8D1(lpytb, lpuvtb, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						}
					}
				else
					{
					if (hi >= 4)
						{
						switch (hi & 3)
							{
							case 0:
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUV_P8D1I4MUV(lppy - dbpr, lppuv - dbpr, lpy - dbpr, p.bpr, ppm, p.width);
								break;
							case 1:
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUV_P8D1MUV(lpytb, lpuvtb - dbpr, pmb, p.width, p.bpr);
								break;
							case 2:
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUV_P8D1I4(lppy - dbpr, lppuv, lpy - dbpr, p.bpr, ppm, p.width);
								break;
							case 3:
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUV_P8D1(lpytb, lpuvtb, pmb, p.width);
								break;
							}
						}
					else
						{
						if ((hi & 1) == 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								ConvertLineToYUV_P8D1(lppy, lppuv, ppm, p.width);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUV_P8D1(lpytb, lpuvtb, pmb, p.width);
							}
						}
					}

				pm += p.mbpr;
				ppm += p.mbpr;
				pmb += p.mbpr;
				pmt += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		case 1:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy  = p.py  + p.bpr * (hi & ~1);
				lppy = p.ppy + p.bpr * (hi & ~1);
				lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);
				lpytb = p.pytb + p.bpr * (hi & ~1);
				lpuvtb = p.puvtb + p.bpr * ((hi >> 1) & ~1);

				yo = hi - p.yosdoffset;

				if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					if (hi < p.height - 4)
						{
						switch (hi & 3)
							{
							case 0:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUVWithOSD_P8D2(lpytb, lpuvtb, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 1:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D2I4(lpy, lpuv, lppy, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 2:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUVWithOSD_P8D2(lpytb, lpuvtb, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 3:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D2I4(lpy, lpuv, lppy, p.bpr, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							}
						}
					else
						{
						if ((hi & 1) != 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUVWithOSD_P8D2(lpy, lpuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUVWithOSD_P8D2(lpytb, lpuvtb, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						}
					}
				else
					{
					if (hi < p.height - 4)
						{
						switch (hi & 3)
							{
							case 0:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUV_P8D2(lpytb, lpuvtb, pmt, p.width);
								break;
							case 1:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUV_P8D2I4(lpy, lpuv, lppy, p.bpr, pm, p.width);
								break;
							case 2:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUV_P8D2MUV(lpytb, lpuvtb, pmt, p.width, p.bpr);
								break;
							case 3:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUV_P8D2I4MUV(lpy, lpuv, lppy, p.bpr, pm, p.width);
								break;
							}
						}
					else
						{
						if ((hi & 1) != 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUV_P8D2(lpy, lpuv, pm, p.width);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUV_P8D2(lpytb, lpuvtb, pmt, p.width);
							}
						}
					}

				hi = ycount >> 16;

				lpy   = p.py   + p.bpr * (hi | 1);
				lppy  = p.ppy  + p.bpr * (hi | 1);
				lppuv = p.ppuv + p.bpr * ((hi >> 1) | 1);
				lpytb = p.pytb + p.bpr * (hi | 1);
				lpuvtb = p.puvtb + p.bpr * ((hi >> 1) | 1);

				if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					if (hi < p.height - 4 && hi >= 4)
					//if (hi < p.height - 4)
						{
						switch (hi & 3)
							{
							case 0:
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D2I4(lppy - dbpr, lppuv - dbpr, lpy - dbpr, p.bpr, ppm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 1:
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUVWithOSD_P8D2(lpytb, lpuvtb, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 2:
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D2I4(lppy - dbpr, lppuv, lpy - dbpr, p.bpr, ppm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 3:
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUVWithOSD_P8D2(lpytb, lpuvtb, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							}
						}
					else
						{
						if ((hi & 1) != 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D2(lppy, lppuv, ppm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUVWithOSD_P8D2(lpytb, lpuvtb, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						}
					}
				else
					{
					if (hi >= 4)
						{
						switch (hi & 3)
							{
							case 0:
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUV_P8D2I4MUV(lppy - dbpr, lppuv - dbpr, lpy - dbpr, p.bpr, ppm, p.width);
								break;
							case 1:
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUV_P8D2MUV(lpytb, lpuvtb - dbpr, pmb, p.width, p.bpr);
								break;
							case 2:
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUV_P8D2I4(lppy - dbpr, lppuv, lpy - dbpr, p.bpr, ppm, p.width);
								break;
							case 3:
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUV_P8D2(lpytb, lpuvtb, pmb, p.width);
								break;
							}
						}
					else
						{
						if ((hi & 1) == 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								ConvertLineToYUV_P8D2(lppy, lppuv, ppm, p.width);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUV_P8D2(lpytb, lpuvtb, pmb, p.width);
							}
						}
					}

				pm += p.mbpr;
				ppm += p.mbpr;
				pmb += p.mbpr;
				pmt += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		default:
			for(y = p.ystart; y < p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy  = p.py  + p.bpr * (hi & ~1);
				lppy  = p.ppy  + p.bpr * (hi | 1);
				lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);
				lppuv = p.puv + p.bpr * ((hi >> 1) | 1);

				ConvertLineToYUV_P8DS(lpy, lpuv, pm, p.width, p.xscale);
				ConvertLineToYUV_P8DS(lppy, lppuv, ppm, p.width, p.xscale);

				ycount += p.yfraction;
				pm += p.mbpr;
				ppm += p.mbpr;
				}
			break;
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVDI2_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv, * lppuv, * lpytb, * lpuvtb;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	BYTE * ppm = p.ppm;
	BYTE * pmt = p.pmt;
	BYTE * pmb = p.pmb;
	int dbpr = p.bpr * 2;

	if (p.xfraction == 0x10000)
		ConvertStripeToYUVDI2_P8DS(p);
	else
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;

			lpy  = p.py  + p.bpr * (hi & ~1);
			lppy = p.ppy + p.bpr * (hi & ~1);
			lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);
			lpytb = p.pytb + p.bpr * (hi & ~1);
			lpuvtb = p.puvtb + p.bpr * ((hi >> 1) & ~1);

			if (hi < p.height - 4)
				{
				switch (hi & 3)
					{
					case 0:
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							ConvertLineToYUV_P8F2(lpytb, lpuvtb, pmt, p.mwidth, 0, p.xfraction);
						break;
					case 1:
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							{
							ConvertLineToYUV_P8D1I4(lpy, lpuv, lppy, p.bpr, yuvcache, p.width);
							ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
							}
						break;
					case 2:
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							{
							ConvertLineToYUV_P8D1MUV(lpytb, lpuvtb, yuvcache, p.width, p.bpr);
							ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, 0, p.xfraction);
							}
						break;
					case 3:
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							{
							ConvertLineToYUV_P8D1I4MUV(lpy, lpuv, lppy, p.bpr, yuvcache, p.width);
							ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
							}
						break;
					}
				}
			else
				{
				if ((hi & 1) != 0)
					{
					if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
						ConvertLineToYUV_P8F2(lpy, lpuv, pm, p.mwidth, 0, p.xfraction);
					}
				else
					{
					if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
						ConvertLineToYUV_P8F2(lpytb, lpuvtb, pmt, p.mwidth, 0, p.xfraction);
					}
				}

			hi = ycount >> 16;

			lpy   = p.py   + p.bpr * (hi | 1);
			lppy  = p.ppy  + p.bpr * (hi | 1);
			lppuv = p.ppuv + p.bpr * ((hi >> 1) | 1);
			lpytb = p.pytb + p.bpr * (hi | 1);
			lpuvtb = p.puvtb + p.bpr * ((hi >> 1) | 1);

			if (hi >= 4)
				{
				switch (hi & 3)
					{
					case 0:
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							{
							ConvertLineToYUV_P8D1I4MUV(lppy - dbpr, lppuv - dbpr, lpy - dbpr, p.bpr, yuvcache, p.width);
							ScaleYUVLine_P8F2(yuvcache, ppm, p.mwidth, 0, p.xfraction);
							}
						break;
					case 1:
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							{
							ConvertLineToYUV_P8D1MUV(lpytb, lpuvtb - dbpr, yuvcache, p.width, p.bpr);
							ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, 0, p.xfraction);
							}
						break;
					case 2:
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							{
							ConvertLineToYUV_P8D1I4(lppy - dbpr, lppuv, lpy - dbpr, p.bpr, yuvcache, p.width);
							ScaleYUVLine_P8F2(yuvcache, ppm, p.mwidth, 0, p.xfraction);
							}
						break;
					case 3:
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							ConvertLineToYUV_P8F2(lpytb, lpuvtb, pmb, p.mwidth, 0, p.xfraction);
						break;
					}
				}
			else
				{
				if ((hi & 1) == 0)
					{
					if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
						ConvertLineToYUV_P8F2(lppy, lppuv, ppm, p.mwidth, 0, p.xfraction);
					}
				else
					{
					if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
						ConvertLineToYUV_P8F2(lpytb, lpuvtb, pmb, p.mwidth,0, p.xfraction);
					}
				}

			pm += p.mbpr;
			ppm += p.mbpr;
			pmb += p.mbpr;
			pmt += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVDI2ThroughOSD_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv, * lppuv, * lpytb, * lpuvtb, * lpo;
	int hi, yo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;
	BYTE * ppm = p.ppm;
	BYTE * pmt = p.pmt;
	BYTE * pmb = p.pmb;
	int dbpr = p.bpr * 2;

	if (p.xfraction == 0x10000)
		ConvertStripeToYUVDI2ThroughOSD_P8DS(p);
	else
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;

			lpy  = p.py  + p.bpr * (hi & ~1);
			lppy = p.ppy + p.bpr * (hi & ~1);
			lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);
			lpytb = p.pytb + p.bpr * (hi & ~1);
			lpuvtb = p.puvtb + p.bpr * ((hi >> 1) & ~1);

			yo = hi - p.yosdoffset;

			if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
				{
				lpo = p.po + p.obpr * (hi - p.yosdstart);

				if (hi < p.height - 4)
					{
					switch (hi & 3)
						{
						case 0:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								{
								ConvertLineToYUVWithOSD_P8D1(lpytb, lpuvtb, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, 0, p.xfraction);
								}
							break;
						case 1:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								{
								ConvertLineToYUVWithOSD_P8D1I4(lpy, lpuv, lppy, p.bpr, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
								}
							break;
						case 2:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								{
								ConvertLineToYUVWithOSD_P8D1(lpytb, lpuvtb, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, 0, p.xfraction);
								}
							break;
						case 3:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								{
								ConvertLineToYUVWithOSD_P8D1I4(lpy, lpuv, lppy, p.bpr, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
								}
							break;
						}
					}
				else
					{
					if ((hi & 1) != 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							{
							ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
							}
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							{
							ConvertLineToYUVWithOSD_P8D1(lpytb, lpuvtb, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, 0, p.xfraction);
							}
						}
					}
				}
			else
				{
				if (hi < p.height - 4)
					{
					switch (hi & 3)
						{
						case 0:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUV_P8F2(lpytb, lpuvtb, pmt, p.mwidth, 0, p.xfraction);
							break;
						case 1:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1I4(lpy, lpuv, lppy, p.bpr, yuvcache, p.width);
								ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
								}
							break;
						case 2:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								{
								ConvertLineToYUV_P8D1MUV(lpytb, lpuvtb, yuvcache, p.width, p.bpr);
								ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, 0, p.xfraction);
								}
							break;
						case 3:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1I4MUV(lpy, lpuv, lppy, p.bpr, yuvcache, p.width);
								ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);
								}
							break;
						}
					}
				else
					{
					if ((hi & 1) != 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							ConvertLineToYUV_P8F2(lpy, lpuv, pm, p.mwidth, 0, p.xfraction);
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							ConvertLineToYUV_P8F2(lpytb, lpuvtb, pmt, p.mwidth, 0, p.xfraction);
						}
					}
				}

			hi = ycount >> 16;

			lpy   = p.py   + p.bpr * (hi | 1);
			lppy  = p.ppy  + p.bpr * (hi | 1);
			lppuv = p.ppuv + p.bpr * ((hi >> 1) | 1);
			lpytb = p.pytb + p.bpr * (hi | 1);
			lpuvtb = p.puvtb + p.bpr * ((hi >> 1) | 1);

			if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
				{
				lpo = p.po + p.obpr * (hi - p.yosdstart);

				if (hi < p.height - 4 && hi >= 4)
//				if (hi < p.height - 4)
					{
					switch (hi & 3)
						{
						case 0:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								{
								ConvertLineToYUVWithOSD_P8D1I4(lppy - dbpr, lppuv - dbpr, lpy - dbpr, p.bpr, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								ScaleYUVLine_P8F2(yuvcache, ppm, p.mwidth, 0, p.xfraction);
								}
							break;
						case 1:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								{
								ConvertLineToYUVWithOSD_P8D1(lpytb, lpuvtb, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, 0, p.xfraction);
								}
							break;
						case 2:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								{
								ConvertLineToYUVWithOSD_P8D1I4(lppy - dbpr, lppuv, lpy - dbpr, p.bpr, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								ScaleYUVLine_P8F2(yuvcache, ppm, p.mwidth, 0, p.xfraction);
								}
							break;
						case 3:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								{
								ConvertLineToYUVWithOSD_P8D1(lpytb, lpuvtb, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, 0, p.xfraction);
								}
							break;
						}
					}
				else
					{
					if ((hi & 1) != 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							{
							ConvertLineToYUVWithOSD_P8D1(lppy, lppuv, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							ScaleYUVLine_P8F2(yuvcache, ppm, p.mwidth, 0, p.xfraction);
							}
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							{
							ConvertLineToYUVWithOSD_P8D1(lpytb, lpuvtb, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, 0, p.xfraction);
							}
						}
					}
				}
			else
				{
				if (hi >= 4)
					{
					switch (hi & 3)
						{
						case 0:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1I4MUV(lppy - dbpr, lppuv - dbpr, lpy - dbpr, p.bpr, yuvcache, p.width);
								ScaleYUVLine_P8F2(yuvcache, ppm, p.mwidth, 0, p.xfraction);
								}
							break;
						case 1:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								{
								ConvertLineToYUV_P8D1MUV(lpytb, lpuvtb - dbpr, yuvcache, p.width, p.bpr);
								ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, 0, p.xfraction);
								}
							break;
						case 2:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1I4(lppy - dbpr, lppuv, lpy - dbpr, p.bpr, yuvcache, p.width);
								ScaleYUVLine_P8F2(yuvcache, ppm, p.mwidth, 0, p.xfraction);
								}
							break;
						case 3:
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUV_P8F2(lpytb, lpuvtb, pmb, p.mwidth, 0, p.xfraction);
							break;
						}
					}
				else
					{
					if ((hi & 1) == 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							ConvertLineToYUV_P8F2(lppy, lppuv, ppm, p.mwidth, 0, p.xfraction);
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							ConvertLineToYUV_P8F2(lpytb, lpuvtb, pmb, p.mwidth, 0, p.xfraction);
						}
					}
				}

			pm += p.mbpr;
			ppm += p.mbpr;
			pmb += p.mbpr;
			pmt += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVSI2_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv;
	int hi;
	int ycount = p.ycount;
	BYTE * pmt = p.pmt;
	BYTE * pmb = p.pmb;
	int dbpr = p.bpr * 2;

	switch (p.xscale)
		{
		case 0:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy  = p.py  + p.bpr * (hi & ~1);
				lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

				if (hi < p.height - 4 && hi >= 4)
					{
					switch (hi & 3)
						{
						case 0:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUV_P8D1(lpy, lpuv, pmt, p.width);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								ConvertLineToYUV_P8D1MYUV(lpy - p.bpr, lpuv - p.bpr, pmb, p.width, p.bpr);
							break;
						case 1:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUV_P8D1MY(lpy, lpuv, pmt, p.width, p.bpr);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUV_P8D1MUV(lpy + p.bpr, lpuv - p.bpr, pmb, p.width, p.bpr);
							break;
						case 2:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUV_P8D1MUV(lpy, lpuv, pmt, p.width, p.bpr);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								ConvertLineToYUV_P8D1MY(lpy - p.bpr, lpuv + p.bpr, pmb, p.width, p.bpr);
							break;
						case 3:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUV_P8D1MYUV(lpy, lpuv, pmt, p.width, p.bpr);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUV_P8D1(lpy + p.bpr, lpuv + p.bpr, pmb, p.width);
							break;
						}
					}
				else
					{
					if ((hi & 1) != 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							ConvertLineToYUV_P8D1(lpy, lpuv, pmt, p.width);
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							ConvertLineToYUV_P8D1(lpy + p.bpr, lpuv + p.bpr, pmb, p.width);
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							ConvertLineToYUV_P8D1(lpy, lpuv, pmt, p.width);
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							ConvertLineToYUV_P8D1(lpy + p.bpr, lpuv + p.bpr, pmb, p.width);
						}
					}

				pmb += p.mbpr;
				pmt += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		case 1:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy  = p.py  + p.bpr * (hi & ~1);
				lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

				if (hi < p.height - 4 && hi >= 4)
					{
					switch (hi & 3)
						{
						case 0:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUV_P8D2(lpy, lpuv, pmt, p.width);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								ConvertLineToYUV_P8D2MYUV(lpy - p.bpr, lpuv - p.bpr, pmb, p.width, p.bpr);
							break;
						case 1:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUV_P8D2MY(lpy, lpuv, pmt, p.width, p.bpr);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUV_P8D2MUV(lpy + p.bpr, lpuv - p.bpr, pmb, p.width, p.bpr);
							break;
						case 2:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUV_P8D2MUV(lpy, lpuv, pmt, p.width, p.bpr);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								ConvertLineToYUV_P8D2MY(lpy - p.bpr, lpuv + p.bpr, pmb, p.width, p.bpr);
							break;
						case 3:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUV_P8D2MYUV(lpy, lpuv, pmt, p.width, p.bpr);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUV_P8D2(lpy + p.bpr, lpuv + p.bpr, pmb, p.width);
							break;
						}
					}
				else
					{
					if ((hi & 1) != 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							ConvertLineToYUV_P8D2(lpy, lpuv, pmt, p.width);
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							ConvertLineToYUV_P8D2(lpy + p.bpr, lpuv + p.bpr, pmb, p.width);
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							ConvertLineToYUV_P8D2(lpy, lpuv, pmt, p.width);
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							ConvertLineToYUV_P8D2(lpy + p.bpr, lpuv + p.bpr, pmb, p.width);
						}
					}

				pmb += p.mbpr;
				pmt += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVSI2ThroughOSD_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv, * lpo;
	int hi, yo;
	int ycount = p.ycount;
	BYTE * pmt = p.pmt;
	BYTE * pmb = p.pmb;
	int dbpr = p.bpr * 2;

	switch (p.xscale)
		{
		case 0:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy  = p.py  + p.bpr * (hi & ~1);
				lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

				yo = hi - p.yosdoffset;

				if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					if (hi < p.height - 4 && hi >= 4)
						{
						switch (hi & 3)
							{
							case 0:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D1MYUV(lpy - p.bpr, lpuv - p.bpr, p.bpr, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 1:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D1MY(lpy, lpuv, p.bpr, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUVWithOSD_P8D1MUV(lpy + p.bpr, lpuv - p.bpr, p.bpr, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 2:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUVWithOSD_P8D1MUV(lpy, lpuv, p.bpr, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D1MY(lpy - p.bpr, lpuv + p.bpr, p.bpr, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 3:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D1MYUV(lpy, lpuv, p.bpr, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUVWithOSD_P8D1(lpy + p.bpr, lpuv + p.bpr, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							}
						}
					else
						{
						if ((hi & 1) != 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUVWithOSD_P8D1(lpy + p.bpr, lpuv + p.bpr, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								ConvertLineToYUVWithOSD_P8D1(lpy + p.bpr, lpuv + p.bpr, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						}
					}
				else
					{
					if (hi < p.height - 4 && hi >= 4)
						{
						switch (hi & 3)
							{
							case 0:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUV_P8D1(lpy, lpuv, pmt, p.width);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUV_P8D1MYUV(lpy - p.bpr, lpuv - p.bpr, pmb, p.width, p.bpr);
								break;
							case 1:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUV_P8D1MY(lpy, lpuv, pmt, p.width, p.bpr);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUV_P8D1MUV(lpy + p.bpr, lpuv - p.bpr, pmb, p.width, p.bpr);
								break;
							case 2:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUV_P8D1MUV(lpy, lpuv, pmt, p.width, p.bpr);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUV_P8D1MY(lpy - p.bpr, lpuv + p.bpr, pmb, p.width, p.bpr);
								break;
							case 3:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUV_P8D1MYUV(lpy, lpuv, pmt, p.width, p.bpr);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUV_P8D1(lpy + p.bpr, lpuv + p.bpr, pmb, p.width);
								break;
							}
						}
					else
						{
						if ((hi & 1) != 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUV_P8D1(lpy, lpuv, pmt, p.width);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUV_P8D1(lpy + p.bpr, lpuv + p.bpr, pmb, p.width);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUV_P8D1(lpy, lpuv, pmt, p.width);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								ConvertLineToYUV_P8D1(lpy + p.bpr, lpuv + p.bpr, pmb, p.width);
							}
						}
					}

				pmb += p.mbpr;
				pmt += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		case 1:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy  = p.py  + p.bpr * (hi & ~1);
				lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

				yo = hi - p.yosdoffset;

				if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					if (hi < p.height - 4 && hi >= 4)
						{
						switch (hi & 3)
							{
							case 0:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUVWithOSD_P8D2(lpy, lpuv, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D2MYUV(lpy - p.bpr, lpuv - p.bpr, p.bpr, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 1:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D2MY(lpy, lpuv, p.bpr, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUVWithOSD_P8D2MUV(lpy + p.bpr, lpuv - p.bpr, p.bpr, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 2:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUVWithOSD_P8D2MUV(lpy, lpuv, p.bpr, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D2MY(lpy - p.bpr, lpuv + p.bpr, p.bpr, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							case 3:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUVWithOSD_P8D2MYUV(lpy, lpuv, p.bpr, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUVWithOSD_P8D2(lpy + p.bpr, lpuv + p.bpr, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								break;
							}
						}
					else
						{
						if ((hi & 1) != 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUVWithOSD_P8D2(lpy, lpuv, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUVWithOSD_P8D2(lpy + p.bpr, lpuv + p.bpr, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUVWithOSD_P8D2(lpy, lpuv, pmt, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								ConvertLineToYUVWithOSD_P8D2(lpy + p.bpr, lpuv + p.bpr, pmb, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							}
						}
					}
				else
					{
					if (hi < p.height - 4 && hi >= 4)
						{
						switch (hi & 3)
							{
							case 0:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUV_P8D2(lpy, lpuv, pmt, p.width);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUV_P8D2MYUV(lpy - p.bpr, lpuv - p.bpr, pmb, p.width, p.bpr);
								break;
							case 1:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUV_P8D2MY(lpy, lpuv, pmt, p.width, p.bpr);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUV_P8D2MUV(lpy + p.bpr, lpuv - p.bpr, pmb, p.width, p.bpr);
								break;
							case 2:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
									ConvertLineToYUV_P8D2MUV(lpy, lpuv, pmt, p.width, p.bpr);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
									ConvertLineToYUV_P8D2MY(lpy - p.bpr, lpuv + p.bpr, pmb, p.width, p.bpr);
								break;
							case 3:
								if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
									ConvertLineToYUV_P8D2MYUV(lpy, lpuv, pmt, p.width, p.bpr);
								if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
									ConvertLineToYUV_P8D2(lpy + p.bpr, lpuv + p.bpr, pmb, p.width);
								break;
							}
						}
					else
						{
						if ((hi & 1) != 0)
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								ConvertLineToYUV_P8D2(lpy, lpuv, pmt, p.width);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUV_P8D2(lpy + p.bpr, lpuv + p.bpr, pmb, p.width);
							}
						else
							{
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUV_P8D2(lpy, lpuv, pmt, p.width);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								ConvertLineToYUV_P8D2(lpy + p.bpr, lpuv + p.bpr, pmb, p.width);
							}
						}
					}

				pmb += p.mbpr;
				pmt += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVSI2_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv;
	int hi;
	int ycount = p.ycount;
	BYTE * pmt = p.pmt;
	BYTE * pmb = p.pmb;
	int dbpr = p.bpr * 2;

	if (p.xfraction == 0x10000)
		ConvertStripeToYUVSI2_P8DS(p);
	else
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;

			lpy  = p.py  + p.bpr * (hi & ~1);
			lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

			if (hi < p.height - 4 && hi >= 4)
				{
				switch (hi & 3)
					{
					case 0:
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							ConvertLineToYUV_P8F2(lpy, lpuv, pmt, p.mwidth, 0, p.xfraction);
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							{
							ConvertLineToYUV_P8D1MYUV(lpy - p.bpr, lpuv - p.bpr, yuvcache, p.width, p.bpr);
							ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, 0, p.xfraction);
							}
						break;
					case 1:
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							{
							ConvertLineToYUV_P8D1MY(lpy, lpuv, yuvcache, p.width, p.bpr);
							ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, 0, p.xfraction);
							}
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							{
							ConvertLineToYUV_P8D1MUV(lpy + p.bpr, lpuv - p.bpr, yuvcache, p.width, p.bpr);
							ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, 0, p.xfraction);
							}
						break;
					case 2:
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							{
							ConvertLineToYUV_P8D1MUV(lpy, lpuv, yuvcache, p.width, p.bpr);
							ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, 0, p.xfraction);
							}
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							{
							ConvertLineToYUV_P8D1MY(lpy - p.bpr, lpuv + p.bpr, yuvcache, p.width, p.bpr);
							ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, 0, p.xfraction);
							}
						break;
					case 3:
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							{
							ConvertLineToYUV_P8D1MYUV(lpy, lpuv, yuvcache, p.width, p.bpr);
							ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, 0, p.xfraction);
							}
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							ConvertLineToYUV_P8F2(lpy + p.bpr, lpuv + p.bpr, pmb, p.mwidth, 0, p.xfraction);
						break;
					}
				}
			else
				{
				if ((hi & 1) != 0)
					{
					if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
						ConvertLineToYUV_P8F2(lpy, lpuv, pmt, p.mwidth, 0, p.xfraction);
					if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
						ConvertLineToYUV_P8F2(lpy + p.bpr, lpuv + p.bpr, pmb, p.mwidth, 0, p.xfraction);
					}
				else
					{
					if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
						ConvertLineToYUV_P8F2(lpy, lpuv, pmt, p.mwidth, 0, p.xfraction);
					if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
						ConvertLineToYUV_P8F2(lpy + p.bpr, lpuv + p.bpr, pmb, p.mwidth, 0, p.xfraction);
					}
				}

			pmb += p.mbpr;
			pmt += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVSI2ThroughOSD_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lpuv, * lpo;
	int hi, yo;
	int ycount = p.ycount;
	BYTE * pmt = p.pmt;
	BYTE * pmb = p.pmb;
	int dbpr = p.bpr * 2;

	if	(p.xfraction == 0x10000)
		ConvertStripeToYUVSI2ThroughOSD_P8DS(p);
	else
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;

			lpy  = p.py  + p.bpr * (hi & ~1);
			lpuv = p.puv + p.bpr * ((hi >> 1) & ~1);

			yo = hi - p.yosdoffset;

			if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
				{
				lpo = p.po + p.obpr * (hi - p.yosdstart);

				if (hi < p.height - 4 && hi >= 4)
					{
					switch (hi & 3)
						{
						case 0:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								{
								ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, 0, p.xfraction);
								}
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								{
								ConvertLineToYUVWithOSD_P8D1MYUV(lpy - p.bpr, lpuv - p.bpr, p.bpr, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, 0, p.xfraction);
								}
							break;
						case 1:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								{
								ConvertLineToYUVWithOSD_P8D1MY(lpy, lpuv, p.bpr, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, 0, p.xfraction);
								}
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								{
								ConvertLineToYUVWithOSD_P8D1MUV(lpy + p.bpr, lpuv - p.bpr, p.bpr, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, 0, p.xfraction);
								}
							break;
						case 2:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								{
								ConvertLineToYUVWithOSD_P8D1MUV(lpy, lpuv, p.bpr, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, 0, p.xfraction);
								}
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								{
								ConvertLineToYUVWithOSD_P8D1MY(lpy - p.bpr, lpuv + p.bpr, p.bpr, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, 0, p.xfraction);
								}
							break;
						case 3:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								{
								ConvertLineToYUVWithOSD_P8D1MYUV(lpy, lpuv, p.bpr, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, 0, p.xfraction);
								}
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								{
								ConvertLineToYUVWithOSD_P8D1(lpy + p.bpr, lpuv + p.bpr, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
								ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, 0, p.xfraction);
								}
							break;
						}
					}
				else
					{
					if ((hi & 1) != 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							{
							ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, 0, p.xfraction);
							}
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							{
							ConvertLineToYUVWithOSD_P8D1(lpy + p.bpr, lpuv + p.bpr, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, 0, p.xfraction);
							}
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							{
							ConvertLineToYUVWithOSD_P8D1(lpy, lpuv, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, 0, p.xfraction);
							}
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							{
							ConvertLineToYUVWithOSD_P8D1(lpy + p.bpr, lpuv + p.bpr, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
							ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, 0, p.xfraction);
							}
						}
					}
				}
			else
				{
				if (hi < p.height - 4 && hi >= 4)
					{
					switch (hi & 3)
						{
						case 0:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								ConvertLineToYUV_P8F2(lpy, lpuv, pmt, p.mwidth, 0, p.xfraction);
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1MYUV(lpy - p.bpr, lpuv - p.bpr, yuvcache, p.width, p.bpr);
								ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, 0, p.xfraction);
								}
							break;
						case 1:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1MY(lpy, lpuv, yuvcache, p.width, p.bpr);
								ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, 0, p.xfraction);
								}
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								{
								ConvertLineToYUV_P8D1MUV(lpy + p.bpr, lpuv - p.bpr, yuvcache, p.width, p.bpr);
								ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, 0, p.xfraction);
								}
							break;
						case 2:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
								{
								ConvertLineToYUV_P8D1MUV(lpy, lpuv, yuvcache, p.width, p.bpr);
								ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, 0, p.xfraction);
								}
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1MY(lpy - p.bpr, lpuv + p.bpr, yuvcache, p.width, p.bpr);
								ScaleYUVLine_P8F2(yuvcache, pmb, p.mwidth, 0, p.xfraction);
								}
							break;
						case 3:
							if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
								{
								ConvertLineToYUV_P8D1MYUV(lpy, lpuv, yuvcache, p.width, p.bpr);
								ScaleYUVLine_P8F2(yuvcache, pmt, p.mwidth, 0, p.xfraction);
								}
							if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
								ConvertLineToYUV_P8F2(lpy + p.bpr, lpuv + p.bpr, pmb, p.mwidth, 0, p.xfraction);
							break;
						}
					}
				else
					{
					if ((hi & 1) != 0)
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_DEINTERLACE)
							ConvertLineToYUV_P8F2(lpy, lpuv, pmt, p.mwidth, 0, p.xfraction);
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_COPY)
							ConvertLineToYUV_P8F2(lpy + p.bpr, lpuv + p.bpr, pmb, p.mwidth, 0, p.xfraction);
						}
					else
						{
						if (p.deinterlaceFlags & DIFEF_ENABLE_TOP_COPY)
							ConvertLineToYUV_P8F2(lpy, lpuv, pmt, p.mwidth, 0, p.xfraction);
						if (p.deinterlaceFlags & DIFEF_ENABLE_BOTTOM_DEINTERLACE)
							ConvertLineToYUV_P8F2(lpy + p.bpr, lpuv + p.bpr, pmb, p.mwidth, 0, p.xfraction);
						}
					}
				}

			pmb += p.mbpr;
			pmt += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVA2_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv, * lppuv;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	switch (p.xscale)
		{
		case 0:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy   = p.py   + p.bpr * hi;
				lppy  = p.ppy  + p.bpr * hi;
				lpuv  = p.puv  + p.bpr * (hi >> 1);
				lppuv = p.ppuv + p.bpr * (hi >> 1);

				ConvertLineToYUV_P8D1M(lpy, lpuv, lppy, lppuv, pm, p.width);

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		case 1:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy   = p.py   + p.bpr * hi;
				lppy  = p.ppy  + p.bpr * hi;
				lpuv  = p.puv  + p.bpr * (hi >> 1);
				lppuv = p.ppuv + p.bpr * (hi >> 1);

				ConvertLineToYUV_P8D2M(lpy, lpuv, lppy, lppuv, pm, p.width);

				pm += p.mbpr;
				ycount += p.yfraction;
				}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVA2ThroughOSD_P8DS(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv, * lppuv, * lpo;
	int hi, yo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	switch (p.xscale)
		{
		case 0:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy   = p.py   + p.bpr * hi;
				lppy  = p.ppy  + p.bpr * hi;
				lpuv  = p.puv  + p.bpr * (hi >> 1);
				lppuv = p.ppuv + p.bpr * (hi >> 1);

				yo = hi - p.yosdoffset;

				if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					ConvertLineToYUVWithOSD_P8D1M(lpy, lpuv, lppy, lppuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
					}
				else
					ConvertLineToYUV_P8D1M(lpy, lpuv, lppy, lppuv, pm, p.width);

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		case 1:
			for(y=p.ystart; y<p.ystop; y++)
				{
				hi = ycount >> 16;

				lpy   = p.py   + p.bpr * hi;
				lppy  = p.ppy  + p.bpr * hi;
				lpuv  = p.puv  + p.bpr * (hi >> 1);
				lppuv = p.ppuv + p.bpr * (hi >> 1);

				yo = hi - p.yosdoffset;

				if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
					{
					lpo = p.po + p.obpr * (hi - p.yosdstart);

					ConvertLineToYUVWithOSD_P8D2M(lpy, lpuv, lppy, lppuv, pm, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
					}
				else
					ConvertLineToYUV_P8D2M(lpy, lpuv, lppy, lppuv, pm, p.width);

				pm += p.mbpr;
				ycount += p.yfraction;
				}
			break;
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVA2_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv, * lppuv;
	int hi;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	if (p.xfraction == 0x10000)
		ConvertStripeToYUVA2_P8DS(p);
	else
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;

			lpy   = p.py   + p.bpr * hi;
			lppy  = p.ppy  + p.bpr * hi;
			lpuv  = p.puv  + p.bpr * (hi >> 1);
			lppuv = p.ppuv + p.bpr * (hi >> 1);

			ConvertLineToYUV_P8D1M(lpy, lpuv, lppy, lppuv, yuvcache, p.width);
			ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);

			pm += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}

void XMMXYUVVideoConverter::ConvertStripeToYUVA2ThroughOSD_P8F2(const YUVVideoConverterParameter & p)
	{
	int y;
	BYTE * lpy, * lppy, * lpuv, * lppuv, * lpo;
	int hi, yo;
	int ycount = p.ycount;
	BYTE * pm = p.pm;

	if (p.xfraction == 0x10000)
		ConvertStripeToYUVA2ThroughOSD_P8DS(p);
	else
		{
		for(y=p.ystart; y<p.ystop; y++)
			{
			hi = ycount >> 16;

			lpy   = p.py   + p.bpr * hi;
			lppy  = p.ppy  + p.bpr * hi;
			lpuv  = p.puv  + p.bpr * (hi >> 1);
			lppuv = p.ppuv + p.bpr * (hi >> 1);

			yo = hi - p.yosdoffset;

			if (hi >= p.yosdstart && hi < p.yosdstop && (!p.osdNonZeroMap || ((p.osdNonZeroMap[yo >> 5] & (1 << (yo & 0x1f))) != 0)))
				{
				lpo = p.po + p.obpr * (hi - p.yosdstart);

				ConvertLineToYUVWithOSD_P8D1M(lpy, lpuv, lppy, lppuv, yuvcache, p.width, p.xosdstart, p.xosdstop, lpo, p.dd);
				}
			else
				ConvertLineToYUV_P8D1M(lpy, lpuv, lppy, lppuv, yuvcache, p.width);

			ScaleYUVLine_P8F2(yuvcache, pm, p.mwidth, 0, p.xfraction);

			pm += p.mbpr;
			ycount += p.yfraction;
			}
		}
	}





#pragma warning (default : 4799)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\XMMXYUVConverter.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#ifndef XMMXYUVCONVERTER_H
#define XMMXYUVCONVERTER_H


#include "GenericMMXYUVConverter.h"

	class XMMXYUVVideoConverter : public GenericMMXYUVVideoConverter
	{
	public:
		XMMXYUVVideoConverter(void) : GenericMMXYUVVideoConverter() {}

		//////
		//
		// horizontal binary ratio scaler, vertical line drop
		//
		void ConvertStripeToYUV_P7DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVThroughOSD_P7DS(const YUVVideoConverterParameter & p);


		void ConvertStripeToYUV_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVThroughOSD_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUV_P8DSY2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVThroughOSD_P8DSY2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUV_P8DSY4(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVThroughOSD_P8DSY4(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUV_P8F2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVThroughOSD_P8F2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUV_P8F2Y2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVThroughOSD_P8F2Y2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUV_P8F2Y4(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVThroughOSD_P8F2Y4(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUV_P8F4(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVThroughOSD_P8F4(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUV_P8F4Y2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVThroughOSD_P8F4Y2(const YUVVideoConverterParameter & p);

		void ConvertStripeToYUV_P8F4Y4(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVThroughOSD_P8F4Y4(const YUVVideoConverterParameter & p);

		//////
		//
		// horizontal linear interpolation, vertical line drop and pan scan stretching
		//
		void ConvertStripeToYUVPS_P8F2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVPSThroughOSD_P8F2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVPSAI_P8F2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVPSAIThroughOSD_P8F2(const YUVVideoConverterParameter & p);
		// new->	  Jan. 25.2000
		void ConvertStripeToYUVPSDI2_P8F2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVPSDI2ThroughOSD_P8F2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVPSA2_P8F2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVPSA2ThroughOSD_P8F2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVPSSI2_P8F2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVPSSI2ThroughOSD_P8F2(const YUVVideoConverterParameter & p);
		// <-new

		//////
		//
		// horizontal binary ratio scaler, vertical linear interpolation
		//
		void ConvertStripeToYUVLB_P8DSY2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVLBThroughOSD_P8DSY2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVLBAI_P8DSY2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVLBAIThroughOSD_P8DSY2(const YUVVideoConverterParameter & p);
		// new->	  Jan. 25.2000
		void ConvertStripeToYUVLBDI2_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVLBDI2ThroughOSD_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVLBA2_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVLBA2ThroughOSD_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVLBSI2_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVLBSI2ThroughOSD_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVLB32PDFieldField_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVLB32PDFieldFieldThroughOSD_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVLB32PDFrameField_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVLB32PDFrameFieldThroughOSD_P8DS(const YUVVideoConverterParameter & p);
		// <-new

		//////
		//
		// horizontal binary ratio scaler, vertical linear interpolation
		//
		void ConvertStripeToYUVDI_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVDIThroughOSD_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVDI_P8F2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVDIThroughOSD_P8F2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVDI_P8DSY2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVDIThroughOSD_P8DSY2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVDI_P8F2Y2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVDIThroughOSD_P8F2Y2(const YUVVideoConverterParameter & p);

		//////
		//
		// horizontal binary ratio scaler, vertical linear interpolation
		//
		void ConvertStripeToYUVAI_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVAIThroughOSD_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVAI_P8DSY2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVAIThroughOSD_P8DSY2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVAI_P8F2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVAIThroughOSD_P8F2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVAI_P8F2Y2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVAIThroughOSD_P8F2Y2(const YUVVideoConverterParameter & p);

		//////
		//
		// horizontal binary ratio scaler, vertical linear interpolation
		//
		void ConvertStripeToYUV32PDFieldField_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUV32PDFieldFieldThroughOSD_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUV32PDFrameField_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUV32PDFrameFieldThroughOSD_P8DS(const YUVVideoConverterParameter & p);

		//////
		//
		// horizontal binary ratio scaler, vertical linear interpolation
		//
		void ConvertStripeToYUV32PDFieldField_P8F2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUV32PDFieldFieldThroughOSD_P8F2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUV32PDFrameField_P8F2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUV32PDFrameFieldThroughOSD_P8F2(const YUVVideoConverterParameter & p);

		//////
		//
		// horizontal binary ratio scaler, vertical linear interpolation
		//
		void ConvertStripeToYUVDI2_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVDI2ThroughOSD_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVDI2_P8F2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVDI2ThroughOSD_P8F2(const YUVVideoConverterParameter & p);


		//////
		//
		// horizontal binary ratio scaler, vertical linear interpolation
		//
		void ConvertStripeToYUVSI2_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVSI2ThroughOSD_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVSI2_P8F2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVSI2ThroughOSD_P8F2(const YUVVideoConverterParameter & p);

		//////
		//
		// horizontal binary ratio scaler, vertical linear interpolation
		//
		void ConvertStripeToYUVA2_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVA2ThroughOSD_P8DS(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVA2_P8F2(const YUVVideoConverterParameter & p);
		void ConvertStripeToYUVA2ThroughOSD_P8F2(const YUVVideoConverterParameter & p);


	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\common\Hooks.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\hooks.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   15.05.95
//
// PURPOSE:   Generalized callback
//
// HISTORY:
//
//

#ifndef HOOKS_H
#define HOOKS_H

#include "prelude.h"
#include "gnerrors.h"

//
// A hook is a generalized callback.  The receiver of the callback
// gets two parameters, first the hook itself (this may be used for
// caller specific data), and a hook specific data element.
//
// The callback function is _NOT_ a virtual function, but a function
// pointer.  This has been done, to avoid incompatibilities with
// traditional 'C'.
//
// A typical use for a hook would be a refill request for a buffer
// in a buffer based stream:
//
// typedef struct RefillMsgStruct
//    {void __far * data, long num, long actual} RefillMsg;
//
// MKHOOK(Refill, RefillMsg);
//
// The implementor of the hook may then add some additional data,
// to customize the hook:
//
// class FileRefillHook : public RefillHook {
//		private:
//			Error Refill(void __far * data, long num, long &actual);
//			friend Error Refill(RefillHook * me, RefillMsg data);
//			FILE 	*	file;
//    public:
//       FileRefillHook(FILE * file) : RefillHook(Refill);
//		};
//
//	Error Refill(RefillHook * me, RefillMsg data)
//		{
//		return (FileRefillHook *)me->Refill(data.data, data.num, data.actual);
//		};
//
//
// Note that you have to do a MakeProcInstance if your callback function is not
// inside a DLL.
//


class KWorkerQueue;

class GenericHook
	{
	protected:
		KWorkerQueue	*	queue;
	public:
		void Register(KWorkerQueue * queue) {this->queue = queue;}
	};


#if NT_KERNEL

//#ifndef ONLY_EXTERNAL_VISIBLE

#include "krnlsync.h"

#define WORKER_QUEUE_SIZE	4096

#if WDM_VERSION
#define WORKER_HEADER_SIZE ((sizeof(void *) + sizeof(DWORD)) / sizeof(DWORD))
#endif

class KWorkerQueue
	{
	private:
		DWORD		buffer[WORKER_QUEUE_SIZE];
		int		bstart, bend, used;
		KEVENT	event, done;
		HANDLE	workerThread;
		IRQMutex	mutex;

		void PutDW(DWORD val);
		DWORD GetDW(void);

#if WDM_VERSION
		void PutDWP(DWORD_PTR);
		DWORD_PTR GetDWP(void);
#endif

	public:
		KWorkerQueue(void);
		~KWorkerQueue(void);
		void EnterWork(GenericHook * me, void * mem, int size);
		void GetWork(GenericHook * & me, void * mem, int & size);
		void RemoveHook(GenericHook * hook);
	};

#define MKHOOK(name, type) \
	class name##Hook : public GenericHook { \
		friend class name##HookHandle;	\
		public: \
			typedef Error (__far * CallType)(name##Hook * me, type & data); \
		private: \
			CallType	call; \
		public:	\
			name##Hook(CallType call) {this->call = call; queue = NULL;} \
	};	\
	class name##HookHandle {	\
		private:	\
			KWorkerQueue	*	queue;	\
			name##Hook	*	hook;		\
		public: \
			name##HookHandle(name##Hook * hook) {this->queue = hook->queue; this->hook = hook;}	\
			name##HookHandle(void) {hook = NULL; queue = NULL;}	\
			Error Call(type data) {if (!queue && hook) hook->call(hook, data); else queue->EnterWork(hook, &data, sizeof(type));GNRAISE_OK;} \
			operator name##Hook * (void) {return hook;}	\
			BOOL operator!= (name##Hook * hook) {return this->hook != hook;} \
			name##HookHandle & operator= (name##Hook * hook) \
				{	\
				if (hook)	\
					this->queue = hook->queue;	\
				else	\
					this->queue = NULL;	\
				this->hook = hook; return *this;	\
				} \
			name##HookHandle & operator= (int i) {this->queue = NULL; this->hook = NULL; return *this;}	\
	};


//#endif // of ONLY_EXTERNAL_VISIBLE

#elif VXD_VERSION

#ifndef ONLY_EXTERNAL_VISIBLE

#define KEVENT HANDLE

#define WORKER_QUEUE_SIZE	4096

class KWorkerQueue
	{
	private:
		DWORD		eventVxdHandle, doneVxdHandle;
		DWORD		buffer[WORKER_QUEUE_SIZE];
		volatile int bstart, bend, used;
//		KEVENT	event, done;
		HANDLE	workerThread;
		void PutDW(DWORD val);
		DWORD GetDW(void);
	public:
		KWorkerQueue(DWORD eventVxdHandle, DWORD doneVxdHandle);
		~KWorkerQueue(void);
		void EnterWork(GenericHook * me, void * mem, int size);
		void GetWork(GenericHook * & me, void * mem, int & size);
	};

#define MKHOOK(name, type) \
	class name##Hook : public GenericHook { \
		friend class name##HookHandle;	\
		public: \
			typedef Error (__far * CallType)(name##Hook * me, type & data); \
		private: \
			CallType	call; \
	};	\
	class name##HookHandle {	\
		private:	\
			KWorkerQueue	*	queue;	\
			name##Hook	*	hook;		\
		public: \
			name##HookHandle(name##Hook * hook) {this->queue = hook->queue; this->hook = hook;}	\
			name##HookHandle(void) {hook = NULL; queue = NULL;}	\
			Error Call(type data) {queue->EnterWork(hook, &data, sizeof(type));GNRAISE_OK;} \
			operator name##Hook * (void) {return hook;}	\
			name##HookHandle & operator= (name##Hook * hook) \
				{	\
				if (hook)	\
					this->queue = hook->queue;	\
				else	\
					this->queue = NULL;	\
				this->hook = hook; return *this;	\
				} \
			name##HookHandle & operator= (int i) {this->queue = NULL; this->hook = NULL; return *this;}	\
	};

#endif	// of ONLY_EXTERNAL_VISIBLE

#elif DRVDLL

#define MKHOOK(name, type) \
	class __far name##Hook : public GenericHook { \
		public: \
			typedef Error (WINAPI * CallType)(name##Hook __far * me, type & data); \
		private: \
			CallType	call; \
			class KWorkerQueue	*	queue;	\
		public: \
			name##Hook(CallType call) {this->call = call;} \
			Error Call(type &data) {return call(this, data);} \
	};

typedef DWORD DWBLK[8];

MKHOOK(Dummy, DWBLK);

#else

extern "C" {
DLLCALL void  WINAPI VDR_RegisterCallback(GenericHook * hook);
}

#define MKHOOK(name, type) \
	class __far name##Hook : public GenericHook { \
		public: \
			typedef Error (WINAPI * CallType)(name##Hook __far * me, type & data); \
		private: \
			CallType	call; \
			class KWorkerQueue	*	queue;	\
		public: \
			name##Hook(CallType call) {this->call = call;VDR_RegisterCallback(this);} \
	};

#endif // NTKERNEL




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\XBoxDisplay.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define INITGUID 1

#include "XBoxDisplay.h"
#include "library\common\vddebug.h"
#include "..\common\PerformanceMonitor.h"
#include "YUVFrameDebug.h"
#include "library\hardware\video\generic\videnc.h"
#include "av.h"

#define DUMP_BITMAP_DATA    0

#define MEASURE_FLIP_TIME               0
#define MEASURE_LOCK_TIME               0
#define MEASURE_UNLOCK_TIME				0
#define MEASURE_DEINTERLACE_TIME        0
#define FRAME_ANNOTATION                0
#define DUMP_FLIP_TIMES							0

#define SUPPORT_PANSCAN_LETTERBOX		1

#pragma warning(disable : 4799)

#define PUSHER_WORKAROUND	1


#ifdef FRAME_ANNOTATION
int		displayedEvenFrames;
int		displayedOddFrames;
#endif


//
// We've turned off inverse 3:2 pulldown interpolation
// 
// Uncomment the line below to turn it back on
//

// #define INVERSE_3_2_PULLDOWN__INTERPOLATION		1


extern "C"
	{
	extern volatile DWORD *D3D__GpuReg;
	}


#ifdef USE_TEXTURE_SURFACES
static LPDIRECT3DVERTEXBUFFER8 g_pVB  = NULL;
DWORD								pixelShader;

DWORD psFunctionTokens[] = {  0x18111812,
										0x5d511c30,
										0x18111010,
										0x5d511c30,
										0x1c141010,
										0,	0,	0,	0,
										0,	0, 2,	3,
										4,	0,	0,	0,
										0, 1,	0,	0,
										0, 0, 0, 0,
										0, 0xcd, 0xc00,
										0xd0, 0xc00, 0xc0, 0,
										0, 0,
										0x08010802,
										0x4d410c20,
										0x08010000,
										0x4d410c20,
										0x0c040000,
										0, 0, 0, 0,
										0, 0, 0x30cd, 0xc00,
										0x20d0, 0xc00, 0xc0, 0,
										0, 0,
										0x011105, 1,
										0, 0,
										0xffff4320,
										0xfffffff1,
										0xff };

#endif

inline DWORD CalcPitch(DWORD width)
{
    return (width * 2 + D3DTEXTURE_PITCH_ALIGNMENT - 1) &
            ~(D3DTEXTURE_PITCH_ALIGNMENT - 1);
}

//
//  Set Macrovision Level
//

void XBoxDisplay::SetMacrovisionLevel(int level)
    {
    bool newHide;

    if (macrovisionEncoder)
        {
        if (!macrovisionEncoder->SetMacrovisionLevel(level))
            {
            lock.Enter();

            newHide = level != 0;
            if (newHide != macrovisionHideDisplay)
                {
                if (newHide && errorMessenger) errorMessenger->PostErrorMessage(GNR_MACROVISION_NOT_SUPPORTED);

                macrovisionHideDisplay = newHide;
                }

            lock.Leave();
            }
        else
            {
            if (macrovisionHideDisplay)
                {
                lock.Enter();

                macrovisionHideDisplay = FALSE;

                lock.Leave();
                }
            }
        }
    }

void XBoxDisplay::SetCGMSMode(VideoCopyMode eCGMSMode)
    {    

    if(this->eCGMSMode != eCGMSMode)
        {
        this->eCGMSMode = eCGMSMode;
        
        ULONG ulOption = AV_CGMS_UNRESTRICTED;
        switch(eCGMSMode)
            {
	        case VCPMD_ONE_COPY_PERMITTED:
	            ulOption = AV_CGMS_ONECOPY;
	            break;
	            
	        case VCPMD_NO_COPYING_PERMITTED:
	            ulOption = AV_CGMS_NOCOPIES;
	            break;

        	case VCPMD_COPYING_PERMITTED:
        	default:
        	    ulOption = AV_CGMS_UNRESTRICTED;
        	    break;
            }

        ULONG Result;
    	AvSendTVEncoderOption((void *)D3D__GpuReg, AV_OPTION_CGMS, ulOption, &Result);

        }
    }


//
//  Constructor
//

XBoxDisplay::XBoxDisplay(HINSTANCE hinst, GenericProfile * profile, GenericProfile * globalProfile)
    {
    lpDDSOverlay = NULL;
    decodeWidth = 0;
    decodeHeight = 0;
	sourceLeft = sourceTop = sourceWidth = sourceHeight = 0;
	destWidth = destHeight = destLeft = destTop = 0;
	outputWidth = outputHeight = outputLeft = outputTop = 0;
	sourceAdapt = TRUE;
	destAdapt = TRUE;

    currentDisplayMode = PS_FRAME_PICTURE;

    macrovisionHideDisplay = FALSE;

	enforceFlipSync = FALSE;

	downscaleFilter.fullX = (VideoDownscaleFilterLevel)4;
	downscaleFilter.fullY = (VideoDownscaleFilterLevel)4;
	downscaleFilter.halfX = (VideoDownscaleFilterLevel)4;
	downscaleFilter.halfY = (VideoDownscaleFilterLevel)4;

    currentDisplayBuffer = NULL;
	 previousDisplayBuffer = NULL;
    displayFreezeMode = false;
	overlayOpen = false;

#if FRAME_ANNOTATION
	displayedEvenFrames = 0;
	displayedOddFrames = 0;
#endif

	overlayAvailable = FALSE;

    ULONG Result;

	// ffh - turn off the flicker
	AvSendTVEncoderOption((void *)D3D__GpuReg, AV_OPTION_FLICKER_FILTER, 0, &Result);

    }

//
//  Destructor
//

XBoxDisplay::~XBoxDisplay(void)
    {
    FreeDisplayBuffers();
    }

//
//  Set Color Key
//

void XBoxDisplay::SetColorKeyColor(DWORD color)
    {
	colorKeyColor = color;
    }


//
//  Enable Display
//

void XBoxDisplay::EnableDisplay(bool enable)
    {
    }

//
//  Update Display
//

void XBoxDisplay::UpdateDisplay(void)
    {
    }



#ifdef USE_TEXTURE_SURFACES

struct CUSTOMVERTEX
{
    D3DXVECTOR4 p; // The transformed position for the vertex
    FLOAT       tu, tv;   // The texture coordinates
};

// Our custom FVF, which describes our custom vertex structure
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_TEX1)

#endif



Error XBoxDisplay::OpenOverlay(void)
    {
    lock.Enter();

#ifdef USE_TEXTURE_SURFACES

    // First time around, create a vertex buffer
    if( g_pVB == NULL )
    {
		DWORD dwWidth, dwHeight;
		DWORD dwSourceWidth, dwSourceHeight;

		dwWidth = 640;
		dwHeight = 480;

		dwSourceWidth = decodeWidth;
		dwSourceHeight = decodeHeight;


	    D3DDevice_CreateVertexBuffer( 4*sizeof(CUSTOMVERTEX), 0,
                                      D3DFVF_CUSTOMVERTEX, D3DPOOL_DEFAULT, &g_pVB);

		CUSTOMVERTEX* pVertices;
		g_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );

		pVertices[0].p = D3DXVECTOR4( 0.0f, 0.0f, 0.5f, 1.0f );
		pVertices[0].tu = 0.0f;
		pVertices[0].tv = 0.0f;

		pVertices[1].p = D3DXVECTOR4( (float) dwWidth, 0.0f, 0.5f, 1.0f );
		pVertices[1].tu = (float) dwSourceWidth;
		pVertices[1].tv = 0.0f;

		pVertices[2].p = D3DXVECTOR4( 0.0f, (float) dwHeight, 0.5f, 1.0f );
		pVertices[2].tu = 0.0f;
		pVertices[2].tv = (float) dwSourceHeight;

		pVertices[3].p = D3DXVECTOR4( (float) dwWidth, (float) dwHeight, 0.5f, 1.0f );
		pVertices[3].tu = (float) dwSourceWidth;
		pVertices[3].tv = (float) dwSourceHeight;

		g_pVB->Unlock();

    }


    D3DDevice_CreatePixelShader( (D3DPIXELSHADERDEF *)&psFunctionTokens, &pixelShader ) ;

#else

	 DP("Enable overlay");

	 //ffh - workaround for enable overlay bug - cannot be enabled more than once
	 if (!overlayOpen)
		 {
		 D3DDevice_EnableOverlay(TRUE);
		 overlayOpen = true;
		 }
#endif

    lock.Leave();

    GNRAISE_OK;
    }


//
//  Close Overlay
//

void XBoxDisplay::CloseOverlay(void)
    {
    lock.Enter();

	 //D3DDevice_EnableOverlay(FALSE);

	overlayAvailable = FALSE;

    lock.Leave();
    }


void DumpFlipCnt(void);

//
//  Init Display
//

void XBoxDisplay::InitDisplay(int width, int height, int minStretch)
    {
    lock.Enter();

#if DUMP_FLIP_TIMES
	DumpFlipCnt();
#endif

	if (decodeWidth != width || decodeHeight != height)
		{
		FreeDisplayBuffers();
		}


#if FRAME_ANNOTATION
	displayedEvenFrames = 0;
	displayedOddFrames = 0;
#endif

    decodeWidth = width;
    decodeHeight = height;


	if ((sourceWidth == 0) || (sourceHeight == 0))
		{
		sourceLeft = sourceTop = 0;
		sourceWidth = decodeWidth;
		sourceHeight = decodeHeight;
		}


    AllocateDisplayBuffers();
    ClearDisplayBuffers();

	OpenOverlay();

    GenericPictureDisplay::InitDisplay(width, height, minStretch);

	FlipOverlay(currentDisplayBuffer->lpDDSurface, 0);

	overlayAvailable = TRUE;

    lock.Leave();
    }

//
//  Free Display Buffers
//

void XBoxDisplay::FreeDisplayBuffers(void)
    {
    int i;

    lock.Enter();

    PMMSG("FreeDisplayBuffers\n");

    display = NULL;
    nextAvail = NULL;
    currentDisplayBuffer = NULL;
	 previousDisplayBuffer = NULL;
	 sourceWidth = 0;
	 sourceHeight = 0;

    PMMSGX("NumDisplayBuffers %d\n", numDisplayBuffers);

    for(i=0; i<numDisplayBuffers; i++)
        {
			if (displayBuffers[i])
				{
			   ((XBoxDisplayBuffer *)(displayBuffers[i]))->lpSurface1->Release();
			   ((XBoxDisplayBuffer *)(displayBuffers[i]))->lpSurface2->Release();

				delete displayBuffers[i];
				displayBuffers[i] = NULL;
				}
        }

    numDisplayBuffers = 0;
    currentDisplayMode = PS_FRAME_PICTURE;

	CloseOverlay();
    lock.Leave();
    }





void XBoxDisplay::ClearSurface(LPDIRECTDRAWSURFACE surface)
    {
	D3DLOCKED_RECT xLock;
    HRESULT ddrval;
	D3DSURFACE_DESC desc;

    if (surface)
        {

#ifndef PUSHER_WORKAROUND

#ifdef USE_TEXTURE_SURFACES
		surface->GetLevelDesc(0, &desc);
        ddrval = surface->LockRect(0, &xLock, NULL, NULL);
#else
		surface->GetDesc(&desc);
        ddrval = surface->LockRect(&xLock, NULL, NULL);
#endif

#else
		surface->GetDesc(&desc);

		if (surface->Common & D3DCOMMON_VIDEOMEMORY)
			xLock.pBits = (void *)(surface->Data | 0xF0000000);
		else
			xLock.pBits = (void *)(surface->Data | 0x80000000);

		xLock.Pitch = CalcPitch(decodeWidth);
		ddrval = DD_OK;

#endif

        if (ddrval == DD_OK)
            {
            DWORD p = (DWORD)xLock.pBits;
            DWORD n, c;

            c = 0x80008000;
            n = desc.Height * xLock.Pitch / 4;

            __asm
                {
                mov edi, [p]
                mov ecx, [n]
                mov eax, [c]
                rep stosd
                }

#ifndef PUSHER_WORKAROUND

#ifdef USE_TEXTURE_SURFACES
            surface->UnlockRect(0);
#else
            surface->UnlockRect();
#endif

#endif
            }
        }
    }



void XBoxDisplay::AllocateDisplayBuffers(void)
    {

	LPDIRECTDRAWSURFACE surfaces[12];
//	LPDIRECTDRAWSURFACE surfaces[10];

	if (!numDisplayBuffers)
		{
		int i;

		for(i=0; i<12; i++)
//		for(i=0; i<10; i++)
			{
#ifdef USE_TEXTURE_SURFACES
			D3DDevice_CreateTexture((decodeWidth + 15) & ~15, decodeHeight+1, 1, 0, D3DFMT_UYVY, 0, &surface[i]);
#else
			D3DDevice_CreateImageSurface((decodeWidth + 15) & ~15, decodeHeight+1, D3DFMT_YUY2, &(surfaces[i]));
#endif
			ClearSurface(surfaces[i]);
			}

		for(i=0; i<6; i++)
//		for(i=0; i<5; i++)
			{
			displayBuffers[numDisplayBuffers] = new XBoxDisplayBuffer(this, surfaces[2*i], surfaces[2*i+1], decodeWidth, decodeHeight);
			numDisplayBuffers++;
			}


		lpDDSecondary = NULL;
		lpDDSOverlay = surfaces[0];

		currentDisplayBuffer = (XBoxDisplayBuffer *)displayBuffers[0];
		previousDisplayBuffer = NULL;
		currentDisplayMode = PS_TOP_FIELD;

		}

    }




DWORD XBoxDisplay::GetDeinterlaceFlags(void)
    {
    return DEIF_DEINTERLACE_WEAVE |
            DEIF_DEINTERLACE_BOB |
            DEIF_CAN_CHANGE_DEINTERLACE_DECODE;
    }

bool XBoxDisplay::FlipOverlay(LPDIRECTDRAWSURFACE to, DWORD flags)
    {
    DWORD ddres;






	 RECT rcSrc, rcDest;

	 rcSrc.top = sourceTop;
	 rcSrc.left = sourceLeft;
	 rcSrc.bottom = sourceTop + sourceHeight;
	 rcSrc.right = sourceLeft + sourceWidth;

	 rcDest.top = destTop;
	 rcDest.left = destLeft;
	 rcDest.bottom = destTop + destHeight;
	 rcDest.right = destLeft + destWidth;


#ifdef USE_TEXTURE_SURFACES
	 RenderFrame(to);

#else

    D3DDevice_UpdateOverlay(to, &rcSrc, &rcDest, true, colorKeyColor);
	ddres = DD_OK;

#endif

	lpDDSOverlay = to;

	return ddres == DD_OK;

    }



#ifdef USE_TEXTURE_SURFACES

//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the gamepad help image, and it's labelled callouts.
//-----------------------------------------------------------------------------
HRESULT XBoxDisplay::RenderFrame(LPDIRECTDRAWSURFACE surf)
{

	LPDIRECT3DDEVICE8 m_d3dDevice;

	D3DDevice_BeginScene();

	D3DDevice_SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
	D3DDevice_SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_ONE );
	D3DDevice_SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_ZERO );
	D3DDevice_SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
	D3DDevice_SetRenderState( D3DRS_ALPHAREF,         0x08 );
	D3DDevice_SetRenderState( D3DRS_ALPHAFUNC,        D3DCMP_GREATEREQUAL );
	D3DDevice_SetRenderState( D3DRS_FILLMODE,         D3DFILL_SOLID );

	//D3DDevice_SetRenderState( D3DRS_CULLMODE,         D3DCULL_CW );

	D3DDevice_SetRenderState( D3DRS_ZENABLE,          D3DZB_TRUE );
	D3DDevice_SetRenderState( D3DRS_FOGENABLE,        FALSE );
	D3DDevice_SetRenderState( D3DRS_STENCILENABLE,    FALSE );

//	D3DDevice_SetRenderState( D3DRS_CLIPPING,         TRUE );

	D3DDevice_SetRenderState( D3DRS_EDGEANTIALIAS,    FALSE );
//	D3DDevice_SetRenderState( D3DRS_CLIPPLANEENABLE,  FALSE );

	D3DDevice_SetRenderState( D3DRS_LIGHTING, FALSE );
	D3DDevice_SetRenderState( D3DRS_ZENABLE, TRUE );

	D3DDevice_Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,D3DCOLOR_XRGB(0,0,255), 1.0f, 0 );

	D3DDevice_SetTexture( 0, NULL );
	D3DDevice_SetRenderState( D3DRS_ZENABLE,          TRUE );
	D3DDevice_SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
	D3DDevice_SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );

	D3DDevice_SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_DISABLE );
	D3DDevice_SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
	D3DDevice_SetTextureStageState( 2, D3DTSS_COLOROP,   D3DTOP_DISABLE );
	D3DDevice_SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
	D3DDevice_SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
	D3DDevice_SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
	D3DDevice_SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );

	// Note: The hardware requires CLAMP for linear textures
	D3DDevice_SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
	D3DDevice_SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );


	D3DDevice_SetPixelShader( pixelShader );
	const float fixedRedToY[] =
		{
		1.00,  0.00,  0.00,  0.00,
			0.00,  1.00,  0.00,  0.00,
			0.50, -86. / 1024 + 0.5, 443. / 1024 + 0.5, 0.00,
			0.00,  0.00,  1.00,  0.00,
			351. / 1024 + 0.5, -179. / 1024 + 0.5, 0.50, 0.00
		};
	D3DDevice_SetPixelShaderConstant(0, fixedRedToY, 5);

	D3DDevice_SetTexture( 0, surf );

	surf->GetDevice(&m_d3dDevice);

	D3DDevice_SetStreamSource( 0, g_pVB, sizeof(CUSTOMVERTEX) );
	D3DDevice_SetVertexShader( D3DFVF_CUSTOMVERTEX );
	m_d3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 4-2 );

	D3DDevice_EndScene();

	m_d3dDevice->Present( NULL, NULL, NULL, NULL );


    return S_OK;
}



#endif

#if DUMP_FLIP_TIMES
#include <stdio.h>

extern struct
	{
	int	time, streamTime;
	int	numTimes;
	int	times[16];
	int	avail;
	} dispinfo[40000];
extern int dispcnt;
static struct
	{
	int					time, streamTime;
	D3DFIELD_STATUS	fs1;
	D3DRASTER_STATUS	rs1;
	D3DFIELD_STATUS	fs2;
	D3DRASTER_STATUS	rs2;
	D3DFIELD_STATUS	fs3;
	} flipinfo[40000];
static int flipcnt;
static int filecnt;

void DumpFlipCnt(void)
	{
	FILE * file;
	int i, j, k;
	char buffer[100];

	wsprintf(buffer, "d:\\mpstat%2d.txt", filecnt);
	filecnt++;


	OutputDebugString("############################### DUMP FLIP COUNT ###############################\n");
	file = fopen(buffer, "w");
	if (file)
		{
		i = 0;
		j = 0;
		while (i < flipcnt || j < dispcnt)
			{
			if (j != dispcnt && (i == flipcnt || flipinfo[i].time >= dispinfo[j].time))
				{
				fprintf(file, "%8d, %8d (%8d) A : %2d",
					dispinfo[j].time,
					dispinfo[j].streamTime,
					dispinfo[j].time - dispinfo[j].streamTime,
					dispinfo[j].avail);
				for(k=0; k<dispinfo[j].numTimes; k++)
					fprintf(file, "%8d ", dispinfo[j].times[k]);
				fprintf(file, "\n");
				j++;
				}
			if (i != flipcnt && (j == dispcnt || flipinfo[i].time <= dispinfo[j].time))
				{
				fprintf(file, "%8d, %8d (%8d) (L %3d V %d) (F %6d B %d) (L %3d V %d) (F %6d B %d) (F %6d B %d) %s\n",
					flipinfo[i].time,
					flipinfo[i].streamTime,
					flipinfo[i].time - flipinfo[i].streamTime,
					flipinfo[i].rs1.ScanLine, flipinfo[i].rs1.InVBlank,
					flipinfo[i].fs1.VBlankCount, flipinfo[i].fs1.Field,
					flipinfo[i].rs2.ScanLine, flipinfo[i].rs2.InVBlank,
					flipinfo[i].fs2.VBlankCount, flipinfo[i].fs2.Field,
					flipinfo[i].fs3.VBlankCount, flipinfo[i].fs3.Field,
					i >= 1 && flipinfo[i].fs3.VBlankCount - flipinfo[i-1].fs3.VBlankCount == 1 ? "OK" : "FAIL" );
				i++;
				}
			}

		fclose(file);
		}
	flipcnt = 0;
	dispcnt = 0;
	}
#endif

void XBoxDisplay::CalculateFlipDoneTime(void)
    {
    flipDoneTime = currentDisplayBuffer->flipDoneTime = GetInternalTime() + 16;
    }

void XBoxDisplay::DisplayFrame(XBoxDisplayBuffer * frame, PictureStructure mode)
	{
	D3DFIELD_STATUS fs;

	lock.Enter(false);

#if MEASURE_FLIP_TIME
	static __int64 flipSumTime;
	static int flipCount;
	__int64 t1, t2;

	ReadPerformanceCounter(t1);
#endif

	if (displayFreezeMode) mode = PS_FRAME_PICTURE;

	if ((currentDisplayBuffer != frame) || (currentDisplayMode != mode))
		{
		if (PlaybackSpeed() == 0x10000)
			{
			D3DRASTER_STATUS rs;
			D3DDevice_GetRasterStatus(&rs);

#if DUMP_FLIP_TIMES
			flipinfo[flipcnt].time = GetInternalTime();
			flipinfo[flipcnt].streamTime = CurrentTime();
			flipinfo[flipcnt].rs1 = rs;
#endif

			if (rs.InVBlank)
				YieldTimedFiber(4, TRUE);

			D3DDevice_GetDisplayFieldStatus(&fs);
#if DUMP_FLIP_TIMES
			flipinfo[flipcnt].fs1 = fs;
#endif
			if (fs.VBlankCount == previousVBlankCount)
				YieldTimedFiber((outputHeight-rs.ScanLine)*10/horizScan+4, TRUE);

			D3DDevice_GetRasterStatus(&rs);
#if DUMP_FLIP_TIMES
			flipinfo[flipcnt].rs2 = rs;
#endif
			if (rs.InVBlank)
				YieldTimedFiber(4, TRUE);

			if (frame->fmode != PS_FRAME_PICTURE)
				{
				D3DDevice_GetDisplayFieldStatus(&fs);
#if DUMP_FLIP_TIMES
				flipinfo[flipcnt].fs2 = fs;
#endif

				if (mode == PS_TOP_FIELD    && fs.Field == D3DFIELD_EVEN ||
					 mode == PS_BOTTOM_FIELD && fs.Field == D3DFIELD_ODD)
					{
					YieldTimedFiber((outputHeight-rs.ScanLine)*10/horizScan+4, TRUE);
					}
				}
			}

		D3DDevice_GetDisplayFieldStatus(&fs);
#if DUMP_FLIP_TIMES
		flipinfo[flipcnt].fs3 = fs;
		flipcnt++;
		if (flipcnt == 40000) DumpFlipCnt();
#endif

		previousVBlankCount = fs.VBlankCount;
		PictureStructure orig_mode;
		orig_mode = mode;
		switch (mode)
			{
			case PS_FRAME_PICTURE:
				mode = PS_TOP_FIELD;
			case PS_TOP_FIELD:
				FlipOverlay(frame->lpDDSurface, 0);
#if FRAME_ANNOTATION
				displayedEvenFrames++;
#endif
				break;
			case PS_BOTTOM_FIELD:
				FlipOverlay(frame->lpDDSecondary, 0);
#if FRAME_ANNOTATION
				displayedOddFrames++;
#endif
				break;
			}

#if FRAME_ANNOTATION
		frame->DebugPrint(16,  11, "DisE# %3d", displayedEvenFrames);
		frame->DebugPrint(16,  12, "DisO# %3d", displayedOddFrames);
#endif

		CalculateFlipDoneTime();

		if (previousDisplayBuffer && previousDisplayBuffer != currentDisplayBuffer && previousVBlankCount >= previousDisplayBuffer->flipDoneField)
			previousDisplayBuffer->flipped = FALSE;
		// if this is a new frame, then the old one has been flipped
		if (currentDisplayBuffer != frame)
			{
	      currentDisplayBuffer->flipped = TRUE;
			currentDisplayBuffer->flipDoneField = previousVBlankCount + 1;
			}

		previousDisplayBuffer = currentDisplayBuffer;
		currentDisplayBuffer = frame;
		currentDisplayMode = mode;
		}

#if MEASURE_FLIP_TIME
	ReadPerformanceCounter(t2);

	flipSumTime += t2 - t1;
	flipCount++;

	if (!(flipCount & 255))
		{
		char buffer[100];
		wsprintf(buffer, "Flip %d.%02d\n", (int)(flipSumTime / flipCount), (int)(100 * flipSumTime / flipCount % 100));
		OutputDebugString(buffer);
		flipCount = 0;
		flipSumTime = 0;
		}
#endif
	lock.Leave();

	}

void XBoxDisplay::BeginFreezeDisplay(void)
    {
//    if (currentDisplayBuffer && currentDisplayMode != PS_FRAME_PICTURE && frameFreezeForFieldContent)
    if (currentDisplayBuffer && currentDisplayMode != PS_FRAME_PICTURE )
        {
        DisplayFrame(currentDisplayBuffer, PS_FRAME_PICTURE);
        displayFreezeMode = true;
        }
    }

void XBoxDisplay::EndFreezeDisplay(void)
    {
    displayFreezeMode = false;
    }

bool XBoxDisplay::SupportsStripeAccess(void)
    {
    return FALSE;
    }

bool XBoxDisplay::NeedsPreviousFrame(void)
    {
    return TRUE;
    }

void XBoxDisplay::SetSourceRectangle(bool autoAdapt, WORD left, WORD top, WORD width, WORD height)
	{
	if (!autoAdapt)
		{
		sourceAdapt = FALSE;
		sourceLeft =  left;
		sourceTop = top;
		sourceWidth = width;
		sourceHeight = height;
		}
	else
		{
		sourceAdapt = TRUE;
		sourceLeft = sourceTop = 0;
		sourceWidth = decodeWidth;
		sourceHeight = decodeHeight;
		}

	if (currentDisplayBuffer)
		FlipOverlay(currentDisplayBuffer->lpDDSurface, 0);

	}

void XBoxDisplay::SetDestRectangle(bool autoAdapt, WORD left, WORD top, WORD width, WORD height)
	{
	if (!autoAdapt)
		{
		destAdapt = FALSE;
		destLeft = left;
		destTop = top;
		destWidth = width;
		destHeight = height;
		}
	else
		{
		destAdapt = TRUE;
		destLeft = outputLeft;
		destTop = outputTop;
		destWidth = outputWidth;
		destHeight = outputHeight;
		}

	if (currentDisplayBuffer)
		FlipOverlay(currentDisplayBuffer->lpDDSurface, 0);

	}


void XBoxDisplay::SetOutputRectangle(WORD left, WORD top, WORD width, WORD height)
	{

	outputLeft = left;
	outputTop = top;
	outputWidth = width;
	outputHeight = height;

	if (outputHeight == 480)
		horizScan = 315;
	else if (outputHeight == 576)
		horizScan = 313;
	else if (outputHeight == 720)
		horizScan = 450;
	else if (outputHeight ==  1080)
		horizScan = 675;

	}




void XBoxDisplay::SetClientRectangle(bool autoAdapt, WORD left, WORD top, WORD width, WORD height) {}


//************************
//
// XBoxDisplayBuffer
//
//************************


XBoxDisplayBuffer::XBoxDisplayBuffer(XBoxDisplay           *   display,
                            LPDIRECTDRAWSURFACE     lpDDSurface,
                            LPDIRECTDRAWSURFACE     lpDDSecondary,
                            int                         width,
                            int                         height)
    : PictureDisplayBuffer(display)
    {
    this->display = display;
    this->lpSurface1 = this->lpDDSurface = lpDDSurface;
    this->lpSurface2 = this->lpDDSecondary = lpDDSecondary;
    this->voffset = 0;
    this->decodeWidth = this->width = width;
    this->decodeHeight = this->height = height;
    lpSurface = NULL;
    flipped = FALSE;
    flipDoneTime = 0;
    this->frame = NULL;
    previousFrame = NULL;
    lpDDPrevious = NULL;
    }



XBoxDisplayBuffer::~XBoxDisplayBuffer(void)
    {
    int timeout;

    timeout = 20;

    while (timeout && !DisplayCompleted())
        {
        Sleep(10);
        timeout--;
        }
    }


void XBoxDisplayBuffer::DisplayFrame(PictureStructure mode)
    {
    display->DisplayFrame(this, mode);
    }


bool XBoxDisplayBuffer::DisplayCompleted(void)
	{
	if (!flipped || !lpDDSurface)
		return TRUE;
	else if (display->enforceFlipSync && GetInternalTime() < flipDoneTime)
		return FALSE;
	else
		{
		D3DFIELD_STATUS fs;

		D3DDevice_GetDisplayFieldStatus(&fs);
		return fs.VBlankCount >= flipDoneField;
		}
		/*
		previousVBlankCount = fs.VBlankCount;
		//    else if (IsFlipStatusCompleted(lpDDSurface) && IsFlipStatusCompleted(lpDDSecondary))

		  // if the frame has been flipped, then as soon as the update is complete we can free it up
		  else if (D3DDevice_GetOverlayUpdateStatus())
		  {
        flipped = FALSE;
        return TRUE;
        }
		  else
		  {
        return FALSE;
		  }
		*/
	}

int XBoxDisplayBuffer::DisplayCompletionDelay(void)
    {
    int delay;

    if (!DisplayCompleted())
        {

		delay = flipDoneTime - GetInternalTime();
		if (delay < 2) delay = 2;

        return delay;
        }
    else
        return 0;
    }

bool XBoxDisplayBuffer::Lock1Surface(LPDIRECTDRAWSURFACE & lpDDSurface1)
    {
    HRESULT ddrval;


	while (lpDDSurface1->IsBusy());

#ifndef PUSHER_WORKAROUND

#ifdef USE_TEXTURE_SURFACES

    ddrval = lpDDSurface1->LockRect(0, &xLock, NULL, NULL);

#else

    ddrval = lpDDSurface1->LockRect(&xLock, NULL, D3DLOCK_DISCARD);

#endif

#else
	if (lpDDSurface1->Common & D3DCOMMON_VIDEOMEMORY)
		xLock.pBits = (void *)(lpDDSurface1->Data | 0xF0000000);
	else
		xLock.pBits = (void *)(lpDDSurface1->Data | 0x80000000);

	xLock.Pitch = CalcPitch(decodeWidth);
	ddrval = DD_OK;
#endif

/*
    while (ddrval == DDERR_WASSTILLDRAWING || ddrval == DDERR_SURFACEBUSY)
        {
        YieldTimedFiber(DisplayCompletionDelay(), TRUE);
        ddrval = lpDDSurface1->Lock(NULL, &desc, display->lockFlags|DDLOCK_SURFACEMEMORYPTR|DDLOCK_WRITEONLY, NULL);
        }
*/

    return ddrval == DD_OK;
    }

bool XBoxDisplayBuffer::Lock2Surfaces(LPDIRECTDRAWSURFACE & lpDDSurface1, LPDIRECTDRAWSURFACE & lpDDSurface2)
    {
    HRESULT ddrval;

	while (lpDDSurface1->IsBusy());

#ifndef PUSHER_WORKAROUND

#ifdef USE_TEXTURE_SURFACES
    ddrval = lpDDSurface1->LockRect(0, &xLock, NULL, NULL);
#else
    ddrval = lpDDSurface1->LockRect(&xLock, NULL, D3DLOCK_DISCARD);
#endif

#else
	if (lpDDSurface1->Common & D3DCOMMON_VIDEOMEMORY)
		xLock.pBits = (void *)(lpDDSurface1->Data | 0xF0000000);
	else
		xLock.pBits = (void *)(lpDDSurface1->Data | 0x80000000);
	xLock.Pitch = CalcPitch(decodeWidth);

	ddrval = DD_OK;
#endif

    if (ddrval == DD_OK)
        {

		while (lpDDSurface2->IsBusy());

#ifndef PUSHER_WORKAROUND

#ifdef USE_TEXTURE_SURFACES
	    ddrval = lpDDSurface2->LockRect(0, &xLock2, NULL, NULL);
#else
	    ddrval = lpDDSurface2->LockRect(&xLock2, NULL, D3DLOCK_DISCARD);
#endif

#else
	if (lpDDSurface2->Common & D3DCOMMON_VIDEOMEMORY)
		xLock2.pBits = (void *)(lpDDSurface2->Data | 0xF0000000);
	else
		xLock2.pBits = (void *)(lpDDSurface2->Data | 0x80000000);
		xLock2.Pitch = CalcPitch(decodeWidth);

	ddrval = DD_OK;
#endif

        if (ddrval != DD_OK)
            {
#ifndef PUSHER_WORKAROUND
#ifdef USE_TEXTURE_SURFACES
            lpDDSurface1->UnlockRect(0);
#else
            lpDDSurface1->UnlockRect();
#endif
#endif
            }
        }
/*
    while (ddrval == DDERR_WASSTILLDRAWING || ddrval == DDERR_SURFACEBUSY)
        {
        YieldTimedFiber(DisplayCompletionDelay(), TRUE);
        ddrval = lpDDSurface1->Lock(NULL, &desc, display->lockFlags|DDLOCK_SURFACEMEMORYPTR|DDLOCK_WRITEONLY, NULL);
        if (ddrval == DD_OK)
            {
            ddrval = lpDDSurface2->Lock(NULL, &desc2, display->lockFlags|DDLOCK_SURFACEMEMORYPTR|DDLOCK_WRITEONLY, NULL);
            if (ddrval != DD_OK)
                {
                lpDDSurface1->Unlock(&desc);
                }
            }
        }
*/
    return ddrval == DD_OK;
    }

bool XBoxDisplayBuffer::Lock3Surfaces(LPDIRECTDRAWSURFACE & lpDDSurface1, LPDIRECTDRAWSURFACE & lpDDSurface2, LPDIRECTDRAWSURFACE & lpDDSurface3)
    {
    HRESULT ddrval;

	while (lpDDSurface1->IsBusy());

#ifndef PUSHER_WORKAROUND

#ifdef USE_TEXTURE_SURFACES
    ddrval = lpDDSurface1->LockRect(0, &xLock, NULL, NULL);
#else
    ddrval = lpDDSurface1->LockRect(&xLock, NULL, D3DLOCK_DISCARD);
#endif

#else
	if (lpDDSurface1->Common & D3DCOMMON_VIDEOMEMORY)
		xLock.pBits = (void *)(lpDDSurface1->Data | 0xF0000000);
	else
		xLock.pBits = (void *)(lpDDSurface1->Data | 0x80000000);
	xLock.Pitch = CalcPitch(decodeWidth);

	ddrval = DD_OK;
#endif

    if (ddrval == DD_OK)
        {

		while (lpDDSurface2->IsBusy());

#ifndef PUSHER_WORKAROUND

#ifdef USE_TEXTURE_SURFACES
	    ddrval = lpDDSurface2->LockRect(0, &xLock2, NULL, NULL);
#else
	    ddrval = lpDDSurface2->LockRect(&xLock2, NULL, D3DLOCK_DISCARD);
#endif

#else
		if (lpDDSurface2->Common & D3DCOMMON_VIDEOMEMORY)
			xLock2.pBits = (void *)(lpDDSurface2->Data | 0xF0000000);
		else
			xLock2.pBits = (void *)(lpDDSurface2->Data | 0x80000000);
		xLock2.Pitch = CalcPitch(decodeWidth);

		ddrval = DD_OK;
#endif

        if (ddrval == DD_OK)
            {

			while (lpDDSurface3->IsBusy());

#ifndef PUSHER_WORKAROUND

#ifdef USE_TEXTURE_SURFACES
		    ddrval = lpDDSurface3->LockRect(0, &xLock3, NULL, NULL);
#else
		    ddrval = lpDDSurface3->LockRect(&xLock3, NULL, D3DLOCK_DISCARD);
#endif

#else
			if (lpDDSurface3->Common & D3DCOMMON_VIDEOMEMORY)
				xLock3.pBits = (void *)(lpDDSurface3->Data | 0xF0000000);
			else
				xLock3.pBits = (void *)(lpDDSurface3->Data | 0x80000000);
			xLock3.Pitch = CalcPitch(decodeWidth);

			ddrval = DD_OK;
#endif

	        if (ddrval != DD_OK)
	            {
#ifndef PUSHER_WORKAROUND
#ifdef USE_TEXTURE_SURFACES
		        lpDDSurface2->UnlockRect(0);
			    lpDDSurface1->UnlockRect(0);
#else
		        lpDDSurface2->UnlockRect();
			    lpDDSurface1->UnlockRect();
#endif
#endif
				}
			}
        else
            {
#ifndef PUSHER_WORKAROUND
#ifdef USE_TEXTURE_SURFACES
            lpDDSurface1->UnlockRect(0);
#else
            lpDDSurface1->UnlockRect();
#endif
#endif
            }
        }

/*
    while (ddrval == DDERR_WASSTILLDRAWING || ddrval == DDERR_SURFACEBUSY)
        {
        YieldTimedFiber(DisplayCompletionDelay(), TRUE);
        ddrval = lpDDSurface->Lock(NULL, &desc, display->lockFlags|DDLOCK_SURFACEMEMORYPTR|DDLOCK_WRITEONLY, NULL);
        if (ddrval == DD_OK)
            {
            ddrval = lpDDSurface2->Lock(NULL, &desc2, display->lockFlags|DDLOCK_SURFACEMEMORYPTR|DDLOCK_WRITEONLY, NULL);
            if (ddrval == DD_OK)
                {
                ddrval = lpDDSurface3->Lock(NULL, &desc3, display->lockFlags|DDLOCK_SURFACEMEMORYPTR|DDLOCK_WRITEONLY, NULL);


                if (ddrval != DD_OK)
                    {
                    lpDDSurface2->Unlock(&desc);
                    lpDDSurface1->Unlock(&desc);
                    }
                }
            else
                {
                lpDDSurface1->Unlock(&desc);
                }
            }
        }
*/

    return ddrval == DD_OK;
    }

bool XBoxDisplayBuffer::BeginStripeAccess(FrameStore * frame, int sheight, PictureStructure fmode)
    {
    int i;
    bool result;

    display->lock.Enter(false);

    for(i=0; i<display->numDisplayBuffers; i++)
        {
        if (display->displayBuffers[i]->frame == frame)
            display->displayBuffers[i]->frame = NULL;
        }

    display->lock.Leave();

    lock.Enter();

    this->frame = frame;
    this->sheight = sheight;

    if (frame) frame->EnableStripeMode(TRUE);


#if MEASURE_LOCK_TIME
    static int lockSumTime;
    static int lockCount;
    __int64 t1, t2;

    ReadPerformanceCounter(t1);
#endif

    if (lpDDPrevious)
        {
        result = Lock3Surfaces(lpDDSurface, lpDDSecondary, lpDDPrevious);

        if (result)
            {
            lpSurface = (BYTE *)(xLock.pBits);
            lpSecondary = (BYTE *)(xLock2.pBits);
            lpPrevious = (BYTE *)(xLock3.pBits);
            lPitch = xLock.Pitch;
            lpSurface += lPitch * voffset;
            }
        }
    else
        {
        result = Lock2Surfaces(lpDDSurface, lpDDSecondary);

        if (result)
            {
            lpSurface = (BYTE *)(xLock.pBits);
            lpSecondary = (BYTE *)(xLock2.pBits);
            lPitch = xLock.Pitch;
            lpSurface += lPitch * voffset;
            }
        }

#if MEASURE_LOCK_TIME
    ReadPerformanceCounter(t2);

    lockSumTime += t2 - t1;
    lockCount++;

    if (!(lockCount & 255))
        {
        char buffer[100];
        wsprintf(buffer, "Lock %d : %d.%02d\n", lockCount, lockSumTime / lockCount, 100 * lockSumTime / lockCount % 100);
        OutputDebugString(buffer);
        }
#endif

    firstFieldDeinterlaced = FALSE;

    if (!result)
        lock.Leave();

    return result;


    }

void XBoxDisplayBuffer::DoneStripeAccess(void)
    {
    if (lpSurface)
        {
#if MEASURE_UNLOCK_TIME
    static int lockSumTime;
    static int lockCount;
    __int64 t1, t2;

    ReadPerformanceCounter(t1);
#endif

#if FRAME_ANNOTATION
	    YUVD_WriteString(lpSecondary,   lPitch, 40, 3, "Secondary");
#endif

#ifndef PUSHER_WORKAROUND
#ifdef USE_TEXTURE_SURFACES
		lpDDSecondary->UnlockRect(0);
#else
		lpDDSecondary->UnlockRect();
#endif
#endif

        if (lpDDPrevious)
            {
#ifndef PUSHER_WORKAROUND
#ifdef USE_TEXTURE_SURFACES
			lpDDPrevious->UnlockRect(0);
#else
			lpDDPrevious->UnlockRect();
#endif
#endif
            }

#if FRAME_ANNOTATION
       YUVD_WriteString(lpSurface,   lPitch, 40, 4, "Surface");
#endif

#ifndef PUSHER_WORKAROUND
#ifdef USE_TEXTURE_SURFACES
        lpDDSurface->UnlockRect(0);
#else
        lpDDSurface->UnlockRect();
#endif
#endif

        lpSurface = NULL;

#if MEASURE_UNLOCK_TIME
        ReadPerformanceCounter(t2);

        lockSumTime += t2 - t1;
        lockCount++;

        if (!(lockCount & 255))
            {
            char buffer[100];
            wsprintf(buffer, "Unlock %d : %d.%02d\n", lockCount, lockSumTime / lockCount, 100 * lockSumTime / lockCount % 100);
            OutputDebugString(buffer);
            }
#endif

        lock.Leave();
        }

    }

void XBoxDisplayBuffer::CopyStripe(int ss, PictureStructure fmode)
    {
    int width = decodeWidth;
    int height = decodeHeight;
    bool laced = mode != PS_FRAME_PICTURE;

    FullWidthMMXSPUDisplayBuffer * osd = (FullWidthMMXSPUDisplayBuffer *)(this->osd);

    if (lpSurface && decodeHeight > 0 && decodeWidth > 0)
        {

#if SUPPORT_PANSCAN_LETTERBOX
		 switch (EffectivePresentationMode())
			 {
			 case PDPM_FULLSIZE:
				 if (lpDDPrevious)
					 {
					 switch (fmode)
						 {
						 case PS_TOP_FIELD:
							 if (mode == PS_BOTTOM_FIELD)
								 frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSecondary, lpSurface, previousFrame->frame, width, height, lPitch, 2 * ss, 2 * sheight, false, DIFEF_ENABLE_BOTH_ALL, MinimumVideoDownscaleFilterLevelSet, osd);
							 break;
						 case PS_BOTTOM_FIELD:
							 if (mode == PS_TOP_FIELD)
								 frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSurface, lpSecondary, previousFrame->frame, width, height, lPitch, 2 * ss, 2 * sheight, true, DIFEF_ENABLE_BOTH_ALL, MinimumVideoDownscaleFilterLevelSet, osd);
							 break;
						 case PS_FRAME_PICTURE:
							 switch (mode)
								 {
								 case PS_TOP_FIELD:
									 if (this->osd == previousFrame->osd)
										frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSurface, lpSecondary, previousFrame->frame, width, height, lPitch, ss, sheight, true, DIFEF_ENABLE_BOTH_ALL, MinimumVideoDownscaleFilterLevelSet, osd);
									 else
										 {
										frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSurface, lpSecondary, previousFrame->frame, width, height, lPitch, ss, sheight, true, DIFEF_ENABLE_BOTTOM_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, (FullWidthMMXSPUDisplayBuffer *)(previousFrame->osd));
										frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSurface, lpSecondary, previousFrame->frame, width, height, lPitch, ss, sheight, true, DIFEF_ENABLE_BOTH_ALL & ~DIFEF_ENABLE_BOTTOM_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, osd);
										 }
									 break;
								 case PS_BOTTOM_FIELD:
									 if (this->osd == previousFrame->osd)
										 frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSecondary, lpSurface, previousFrame->frame, width, height, lPitch, ss, sheight, false, DIFEF_ENABLE_BOTH_ALL, MinimumVideoDownscaleFilterLevelSet, osd);
									 else
										 {
										 frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSecondary, lpSurface, previousFrame->frame, width, height, lPitch, ss, sheight, false, DIFEF_ENABLE_TOP_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, (FullWidthMMXSPUDisplayBuffer *)(previousFrame->osd));
										 frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSecondary, lpSurface, previousFrame->frame, width, height, lPitch, ss, sheight, false, DIFEF_ENABLE_BOTH_ALL & ~DIFEF_ENABLE_TOP_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, osd);
										 }
									 break;
								 case PS_FRAME_PICTURE:
									 frame->ConvertToYUVStripe(lpSurface, NULL, width, height, lPitch, ss, sheight, false, false, fmode, MinimumVideoDownscaleFilterLevelSet, osd);
									 frame->ConvertToYUVStripeInterpolate(lpPrevious, previousFrame->frame, width, height, lPitch, ss, sheight, MinimumVideoDownscaleFilterLevelSet, osd);
									 break;
								 }
							 break;
						 }
					 }
				 else
					 {
					 switch (fmode)
						 {
						 case PS_TOP_FIELD:
							 if (mode == PS_BOTTOM_FIELD)
								 frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSecondary, lpSurface, frame, width, height, lPitch, 2 * ss, 2 * sheight, false, DIFEF_ENABLE_BOTH_COPY, MinimumVideoDownscaleFilterLevelSet, osd);
							 break;
						 case PS_BOTTOM_FIELD:
							 if (mode == PS_TOP_FIELD)
								 frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSurface, lpSecondary, frame, width, height, lPitch, 2 * ss, 2 * sheight, true, DIFEF_ENABLE_BOTH_COPY, MinimumVideoDownscaleFilterLevelSet, osd);
							 break;
						 case PS_FRAME_PICTURE:
							 switch (mode)
								 {
								 case PS_TOP_FIELD:
									 frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSurface, lpSecondary, frame, width, height, lPitch, ss, sheight, true, DIFEF_ENABLE_BOTH_COPY, MinimumVideoDownscaleFilterLevelSet, osd);
									 break;
								 case PS_BOTTOM_FIELD:
									 frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSecondary, lpSurface, frame, width, height, lPitch, ss, sheight, false, DIFEF_ENABLE_BOTH_COPY, MinimumVideoDownscaleFilterLevelSet, osd);
									 break;
								 case PS_FRAME_PICTURE:
									 frame->ConvertToYUVStripe(lpSurface, NULL, width, height, lPitch, ss, sheight, false, false, fmode, MinimumVideoDownscaleFilterLevelSet, osd);
									 break;
								 }
							 break;
						 }
					 }
				 break;
			 case PDPM_LETTERBOXED:
				 if (lpDDPrevious)
					 {
					 switch (fmode)
						 {
						 case PS_TOP_FIELD:
							 if (mode == PS_BOTTOM_FIELD)
								 frame->ConvertToYUVStripeLetterboxDeinterlace(lpPrevious, lpSecondary, lpSurface, previousFrame->frame, width, height, lPitch, 2 * ss, 2 * sheight, false, DIFEF_ENABLE_BOTH_ALL, MinimumVideoDownscaleFilterLevelSet, osd);
							 break;
						 case PS_BOTTOM_FIELD:
							 if (mode == PS_TOP_FIELD)
								 frame->ConvertToYUVStripeLetterboxDeinterlace(lpPrevious, lpSurface, lpSecondary, previousFrame->frame, width, height, lPitch, 2 * ss, 2 * sheight, true, DIFEF_ENABLE_BOTH_ALL, MinimumVideoDownscaleFilterLevelSet, osd);
							 break;
						 case PS_FRAME_PICTURE:
							 switch (mode)
								 {
								 case PS_TOP_FIELD:
									 if (this->osd == previousFrame->osd)
										 frame->ConvertToYUVStripeLetterboxDeinterlace(lpPrevious, lpSurface, lpSecondary, previousFrame->frame, width, height, lPitch, ss, sheight, true, DIFEF_ENABLE_BOTH_ALL, MinimumVideoDownscaleFilterLevelSet, osd);
									 else
										 {
										 frame->ConvertToYUVStripeLetterboxDeinterlace(lpPrevious, lpSurface, lpSecondary, previousFrame->frame, width, height, lPitch, ss, sheight, true, DIFEF_ENABLE_BOTTOM_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, (FullWidthMMXSPUDisplayBuffer *)(previousFrame->osd));
										 frame->ConvertToYUVStripeLetterboxDeinterlace(lpPrevious, lpSurface, lpSecondary, previousFrame->frame, width, height, lPitch, ss, sheight, true, DIFEF_ENABLE_BOTH_ALL & ~DIFEF_ENABLE_BOTTOM_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, osd);
										 }
									 break;
								 case PS_BOTTOM_FIELD:
									 if (this->osd == previousFrame->osd)
										 frame->ConvertToYUVStripeLetterboxDeinterlace(lpPrevious, lpSecondary, lpSurface, previousFrame->frame, width, height, lPitch, ss, sheight, false, DIFEF_ENABLE_BOTH_ALL, MinimumVideoDownscaleFilterLevelSet, osd);
									 else
										 {
										 frame->ConvertToYUVStripeLetterboxDeinterlace(lpPrevious, lpSecondary, lpSurface, previousFrame->frame, width, height, lPitch, ss, sheight, false, DIFEF_ENABLE_TOP_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, (FullWidthMMXSPUDisplayBuffer *)(previousFrame->osd));
										 frame->ConvertToYUVStripeLetterboxDeinterlace(lpPrevious, lpSecondary, lpSurface, previousFrame->frame, width, height, lPitch, ss, sheight, false, DIFEF_ENABLE_BOTH_ALL & ~DIFEF_ENABLE_TOP_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, osd);
										 }
									 break;
								 case PS_FRAME_PICTURE:
									 frame->ConvertToYUVStripeLetterbox(lpSurface, NULL, width, height, lPitch, ss, sheight, false, false, fmode, MinimumVideoDownscaleFilterLevelSet, osd);
									 frame->ConvertToYUVStripeLetterboxInterpolate(lpPrevious, previousFrame->frame, width, height, lPitch, ss, sheight, MinimumVideoDownscaleFilterLevelSet, osd);
									 break;
								 }
							 break;
						 }
					 }
				 else
					 {
					 switch (fmode)
						 {
						 case PS_TOP_FIELD:
							 if (mode == PS_BOTTOM_FIELD)
								 frame->ConvertToYUVStripeLetterboxDeinterlace(lpPrevious, lpSecondary, lpSurface, frame, width, height, lPitch, 2 * ss, 2 * sheight, false, DIFEF_ENABLE_BOTH_COPY, MinimumVideoDownscaleFilterLevelSet, osd);
							 break;
						 case PS_BOTTOM_FIELD:
							 if (mode == PS_TOP_FIELD)
								 frame->ConvertToYUVStripeLetterboxDeinterlace(lpPrevious, lpSurface, lpSecondary, frame, width, height, lPitch, 2 * ss, 2 * sheight, true, DIFEF_ENABLE_BOTH_COPY, MinimumVideoDownscaleFilterLevelSet, osd);
							 break;
						 case PS_FRAME_PICTURE:
							 switch (mode)
								 {
								 case PS_TOP_FIELD:
									 frame->ConvertToYUVStripeLetterboxDeinterlace(lpPrevious, lpSurface, lpSecondary, frame, width, height, lPitch, ss, sheight, true, DIFEF_ENABLE_BOTH_COPY, MinimumVideoDownscaleFilterLevelSet, osd);
									 break;
								 case PS_BOTTOM_FIELD:
									 frame->ConvertToYUVStripeLetterboxDeinterlace(lpPrevious, lpSecondary, lpSurface, frame, width, height, lPitch, ss, sheight, false, DIFEF_ENABLE_BOTH_COPY, MinimumVideoDownscaleFilterLevelSet, osd);
									 break;
								 case PS_FRAME_PICTURE:
									 frame->ConvertToYUVStripeLetterbox(lpSurface, NULL, width, height, lPitch, ss, sheight, false, false, fmode, MinimumVideoDownscaleFilterLevelSet, osd);
									 break;
								 }
							 break;
						 }
					 }
				 break;
			 case PDPM_PANSCAN:
				 if (lpDDPrevious)
					 {
					 switch (fmode)
						 {
						 case PS_TOP_FIELD:
							 if (mode == PS_BOTTOM_FIELD)
								 frame->ConvertToYUVStripePanScanDeinterlace(lpPrevious, lpSecondary, lpSurface, previousFrame->frame, width, height, lPitch, panScanOffset, 2 * ss, 2 * sheight, false, DIFEF_ENABLE_BOTH_ALL, MinimumVideoDownscaleFilterLevelSet, osd);
							 break;
						 case PS_BOTTOM_FIELD:
							 if (mode == PS_TOP_FIELD)
								 frame->ConvertToYUVStripePanScanDeinterlace(lpPrevious, lpSurface, lpSecondary, previousFrame->frame, width, height, lPitch, panScanOffset, 2 * ss, 2 * sheight, true, DIFEF_ENABLE_BOTH_ALL, MinimumVideoDownscaleFilterLevelSet, osd);
							 break;
						 case PS_FRAME_PICTURE:
							 switch (mode)
								 {
								 case PS_TOP_FIELD:
									 if (this->osd == previousFrame->osd)
										 frame->ConvertToYUVStripePanScanDeinterlace(lpPrevious, lpSurface, lpSecondary, previousFrame->frame, width, height, lPitch, panScanOffset, ss, sheight, true, DIFEF_ENABLE_BOTH_ALL, MinimumVideoDownscaleFilterLevelSet, osd);
									 else
										 {
										 frame->ConvertToYUVStripePanScanDeinterlace(lpPrevious, lpSurface, lpSecondary, previousFrame->frame, width, height, lPitch, panScanOffset, ss, sheight, true, DIFEF_ENABLE_BOTTOM_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, (FullWidthMMXSPUDisplayBuffer *)(previousFrame->osd));
										 frame->ConvertToYUVStripePanScanDeinterlace(lpPrevious, lpSurface, lpSecondary, previousFrame->frame, width, height, lPitch, panScanOffset, ss, sheight, true, DIFEF_ENABLE_BOTH_ALL & ~DIFEF_ENABLE_BOTTOM_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, osd);
										 }
									 break;
								 case PS_BOTTOM_FIELD:
									 if (this->osd == previousFrame->osd)
										 frame->ConvertToYUVStripePanScanDeinterlace(lpPrevious, lpSecondary, lpSurface, previousFrame->frame, width, height, lPitch, panScanOffset, ss, sheight, false, DIFEF_ENABLE_BOTH_ALL, MinimumVideoDownscaleFilterLevelSet, osd);
									 else
										 {
										 frame->ConvertToYUVStripePanScanDeinterlace(lpPrevious, lpSecondary, lpSurface, previousFrame->frame, width, height, lPitch, panScanOffset, ss, sheight, false, DIFEF_ENABLE_TOP_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, (FullWidthMMXSPUDisplayBuffer *)(previousFrame->osd));
										 frame->ConvertToYUVStripePanScanDeinterlace(lpPrevious, lpSecondary, lpSurface, previousFrame->frame, width, height, lPitch, panScanOffset, ss, sheight, false, DIFEF_ENABLE_BOTH_ALL & ~DIFEF_ENABLE_TOP_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, osd);
										 }
									 break;
								 case PS_FRAME_PICTURE:
									 frame->ConvertToYUVStripePanScan(lpSurface, NULL, width, height, lPitch, panScanOffset, ss, sheight, false, false, fmode, MinimumVideoDownscaleFilterLevelSet, osd);
									 frame->ConvertToYUVStripePanScanInterpolate(lpPrevious, previousFrame->frame, width, height, lPitch, panScanOffset, ss, sheight, MinimumVideoDownscaleFilterLevelSet, osd);
									 break;
								 }
							 break;
						 }
					 }
				 else
					 {
					 switch (fmode)
						 {
						 case PS_TOP_FIELD:
							 if (mode == PS_BOTTOM_FIELD)
								 frame->ConvertToYUVStripePanScanDeinterlace(lpPrevious, lpSecondary, lpSurface, frame, width, height, lPitch, panScanOffset, 2 * ss, 2 * sheight, false, DIFEF_ENABLE_BOTH_COPY, MinimumVideoDownscaleFilterLevelSet, osd);
							 break;
						 case PS_BOTTOM_FIELD:
							 if (mode == PS_TOP_FIELD)
								 frame->ConvertToYUVStripePanScanDeinterlace(lpPrevious, lpSurface, lpSecondary, frame, width, height, lPitch, panScanOffset, 2 * ss, 2 * sheight, true, DIFEF_ENABLE_BOTH_COPY, MinimumVideoDownscaleFilterLevelSet, osd);
							 break;
						 case PS_FRAME_PICTURE:
							 switch (mode)
								 {
								 case PS_TOP_FIELD:
									 frame->ConvertToYUVStripePanScanDeinterlace(lpPrevious, lpSurface, lpSecondary, frame, width, height, lPitch, panScanOffset, ss, sheight, true, DIFEF_ENABLE_BOTH_COPY, MinimumVideoDownscaleFilterLevelSet, osd);
									 break;
								 case PS_BOTTOM_FIELD:
									 frame->ConvertToYUVStripePanScanDeinterlace(lpPrevious, lpSecondary, lpSurface, frame, width, height, lPitch, panScanOffset, ss, sheight, false, DIFEF_ENABLE_BOTH_COPY, MinimumVideoDownscaleFilterLevelSet, osd);
									 break;
								 case PS_FRAME_PICTURE:
									 frame->ConvertToYUVStripePanScan(lpSurface, NULL, width, height, lPitch, panScanOffset, ss, sheight, false, false, fmode, MinimumVideoDownscaleFilterLevelSet, osd);
									 break;
								 }
							 break;
						 }
					 }
				 break;
			  }
#else

        if (lpDDPrevious)
            {
            switch (fmode)
                {
                case PS_TOP_FIELD:
                    if (mode == PS_BOTTOM_FIELD)
                        frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSecondary, lpSurface, previousFrame->frame, width, height, lPitch, 2 * ss, 2 * sheight, false, DIFEF_ENABLE_BOTH_ALL, display->downscaleFilter, osd);
                    break;
                case PS_BOTTOM_FIELD:
                    if (mode == PS_TOP_FIELD)
                        frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSurface, lpSecondary, previousFrame->frame, width, height, lPitch, 2 * ss, 2 * sheight, true, DIFEF_ENABLE_BOTH_ALL, display->downscaleFilter, osd);
                    break;
                case PS_FRAME_PICTURE:
                    switch (mode)
                        {
                        case PS_TOP_FIELD:
                            frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSurface, lpSecondary, previousFrame->frame, width, height, lPitch, ss, sheight, true, DIFEF_ENABLE_BOTH_ALL, display->downscaleFilter, osd);
                            break;
                        case PS_BOTTOM_FIELD:
                            frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSecondary, lpSurface, previousFrame->frame, width, height, lPitch, ss, sheight, false, DIFEF_ENABLE_BOTH_ALL, display->downscaleFilter, osd);
                            break;
                        case PS_FRAME_PICTURE:
                            frame->ConvertToYUVStripe(lpSurface, NULL, width, height, lPitch, ss, sheight, false, false, fmode, display->downscaleFilter, osd);
                            frame->ConvertToYUVStripeInterpolate(lpPrevious, previousFrame->frame, width, height, lPitch, ss, sheight, display->downscaleFilter, osd);
                            break;
                        }
                    break;
                }
            }
        else
            {
            switch (fmode)
                {
                case PS_TOP_FIELD:
                    if (mode == PS_BOTTOM_FIELD)
                        frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSecondary, lpSurface, frame, width, height, lPitch, 2 * ss, 2 * sheight, false, DIFEF_ENABLE_BOTH_COPY, display->downscaleFilter, osd);
                    break;
                case PS_BOTTOM_FIELD:
                    if (mode == PS_TOP_FIELD)
                        frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSurface, lpSecondary, frame, width, height, lPitch, 2 * ss, 2 * sheight, true, DIFEF_ENABLE_BOTH_COPY, display->downscaleFilter, osd);
                    break;
                case PS_FRAME_PICTURE:
                    switch (mode)
                        {
                        case PS_TOP_FIELD:
                            frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSurface, lpSecondary, frame, width, height, lPitch, ss, sheight, true, DIFEF_ENABLE_BOTH_COPY, display->downscaleFilter, osd);
                            break;
                        case PS_BOTTOM_FIELD:
                            frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSecondary, lpSurface, frame, width, height, lPitch, ss, sheight, false, DIFEF_ENABLE_BOTH_COPY, display->downscaleFilter, osd);
                            break;
                        case PS_FRAME_PICTURE:
                            frame->ConvertToYUVStripe(lpSurface, NULL, width, height, lPitch, ss, sheight, false, false, fmode, display->downscaleFilter, osd);
                            break;
                        }
                    break;
                }
            }
#endif
        }

    }

bool XBoxDisplayBuffer::AttemptDirectStripeYUVAccess(int width, int height, int ss, BPTR & p, BPTR & ip, int & stride)
    {
    if (lpSurface && EffectivePresentationMode() == PDPM_FULLSIZE &&
         width  == decodeWidth &&
         height == decodeHeight &&
			(!osd || (height >= 480 && ss + 16 <= osd->nonTransparentTop)))
        {
            stride = lPitch;
            sstart = ss;

            if (mode == PS_FRAME_PICTURE)
                {
                p = lpSurface + stride * ss;
                ip = NULL;
                }
            else
                {
                p = lpSurface + stride * ss;
                ip = lpSecondary + stride * (ss + 1);
                stride *= 2;
                }
            return TRUE;
        }

    return FALSE;
    }

bool XBoxDisplayBuffer::NeedsFrameDataWithDirectYUVAccess(void)
    {
    return TRUE;
    }

void XBoxDisplayBuffer::DoneDirectStripeAccess(PictureStructure fmode)
	{
	if (lpDDPrevious && decodeHeight > 0 && decodeWidth > 0 && previousFrame->frame)
		{
		switch (fmode)
			{
			case PS_TOP_FIELD:
				if (mode == PS_BOTTOM_FIELD)
					frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSecondary, lpSurface, previousFrame->frame, decodeWidth, decodeHeight, lPitch, sstart, 2 * sheight, false, DIFEF_ENABLE_BOTH_DEINTERLACE, display->downscaleFilter, (FullWidthMMXSPUDisplayBuffer *)osd);
				break;
			case PS_BOTTOM_FIELD:
				if (mode == PS_TOP_FIELD)
					frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSurface, lpSecondary, previousFrame->frame, decodeWidth, decodeHeight, lPitch, sstart, 2 * sheight, true, DIFEF_ENABLE_BOTH_DEINTERLACE, display->downscaleFilter, (FullWidthMMXSPUDisplayBuffer *)osd);
				break;
			case PS_FRAME_PICTURE:
				if (osd == previousFrame->osd)
					{
					switch (mode)
						{
						case PS_TOP_FIELD:
							frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSurface, lpSecondary, previousFrame->frame, decodeWidth, decodeHeight, lPitch, sstart, sheight, true, DIFEF_ENABLE_BOTH_DEINTERLACE, display->downscaleFilter, (FullWidthMMXSPUDisplayBuffer *)osd);
							break;
						case PS_BOTTOM_FIELD:
							frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSecondary, lpSurface, previousFrame->frame, decodeWidth, decodeHeight, lPitch, sstart, sheight, false, DIFEF_ENABLE_BOTH_DEINTERLACE, display->downscaleFilter, (FullWidthMMXSPUDisplayBuffer *)osd);
							break;
						case PS_FRAME_PICTURE:
							frame->ConvertToYUVStripeInterpolate(lpPrevious, previousFrame->frame, decodeWidth, decodeHeight, lPitch, sstart, sheight, display->downscaleFilter, (FullWidthMMXSPUDisplayBuffer *)osd);
							break;
						}
					}
				else
					{
					switch (mode)
						{
						case PS_TOP_FIELD:
							frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSurface, lpSecondary, previousFrame->frame, decodeWidth, decodeHeight, lPitch, sstart, sheight, true, DIFEF_ENABLE_BOTTOM_DEINTERLACE, display->downscaleFilter, (FullWidthMMXSPUDisplayBuffer *)(previousFrame->osd));
							frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSurface, lpSecondary, previousFrame->frame, decodeWidth, decodeHeight, lPitch, sstart, sheight, true, DIFEF_ENABLE_TOP_DEINTERLACE, display->downscaleFilter, (FullWidthMMXSPUDisplayBuffer *)osd);
							break;
						case PS_BOTTOM_FIELD:
							frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSecondary, lpSurface, previousFrame->frame, decodeWidth, decodeHeight, lPitch, sstart, sheight, false, DIFEF_ENABLE_TOP_DEINTERLACE, display->downscaleFilter, (FullWidthMMXSPUDisplayBuffer *)(previousFrame->osd));
							frame->ConvertToYUVStripeDeinterlace(lpPrevious, lpSecondary, lpSurface, previousFrame->frame, decodeWidth, decodeHeight, lPitch, sstart, sheight, false, DIFEF_ENABLE_BOTTOM_DEINTERLACE, display->downscaleFilter, (FullWidthMMXSPUDisplayBuffer *)osd);
							break;
						case PS_FRAME_PICTURE:
							frame->ConvertToYUVStripeInterpolate(lpPrevious, previousFrame->frame, decodeWidth, decodeHeight, lPitch, sstart, sheight, display->downscaleFilter, (FullWidthMMXSPUDisplayBuffer *)osd);
							break;
						}
					}
				break;
			}
		}
	}


bool XBoxDisplayBuffer::HasInterlaceArtifacts(void)
    {
    return FALSE;
    }

void XBoxDisplayBuffer::DeinterlaceSurfaces(LPDIRECTDRAWSURFACE lpDDTop, LPDIRECTDRAWSURFACE lpDDBottom, PictureStructure mode, FrameStore * frame, FrameStore * previous, FullWidthMMXSPUDisplayBuffer * cosd, FullWidthMMXSPUDisplayBuffer * posd, bool hurryUp)
	{
	int ppos, psize;

	if (decodeHeight > 0 && decodeWidth > 0)
		{
		ppos = 0;
		psize = 16;

		if (Lock2Surfaces(lpDDTop, lpDDBottom))
			{
			lpSurface = (BYTE *)(xLock.pBits);
			lpSecondary = (BYTE *)(xLock2.pBits);
			lPitch = xLock.Pitch;

			while (ppos < decodeHeight)
				{
				if (cosd == posd)
					{
#if SUPPORT_PANSCAN_LETTERBOX
					switch (EffectivePresentationMode())
						{
						case PDPM_FULLSIZE:
							frame->ConvertToYUVStripeDeinterlace(lpSurface, lpSecondary, NULL, previous, width, height, lPitch, ppos, psize, true, DIFEF_ENABLE_BOTH_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, cosd);
							break;
						case PDPM_LETTERBOXED:
							frame->ConvertToYUVStripeLetterboxDeinterlace(lpSurface, lpSecondary, NULL, previous, width, height, lPitch, ppos, psize, true, DIFEF_ENABLE_BOTH_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, cosd);
							break;
						case PDPM_PANSCAN:
							frame->ConvertToYUVStripePanScanDeinterlace(lpSurface, lpSecondary, NULL, previous, width, height, lPitch, panScanOffset, ppos, psize, true, DIFEF_ENABLE_BOTH_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, cosd);
							break;
						}
#else
	            frame->ConvertToYUVStripeDeinterlace(lpSurface, lpSecondary, NULL, previous, decodeWidth, decodeHeight, lPitch, ppos, psize, true, DIFEF_ENABLE_BOTH_DEINTERLACE, display->downscaleFilter, cosd);
#endif
					}
				else
					{
#if SUPPORT_PANSCAN_LETTERBOX
					switch (EffectivePresentationMode())
						{
						case PDPM_FULLSIZE:
							frame->ConvertToYUVStripeDeinterlace(lpSurface, lpSecondary, NULL, previous, width, height, lPitch, ppos, psize, true, DIFEF_ENABLE_BOTTOM_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, posd);
							frame->ConvertToYUVStripeDeinterlace(lpSurface, lpSecondary, NULL, previous, width, height, lPitch, ppos, psize, true, DIFEF_ENABLE_TOP_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, cosd);
							break;
						case PDPM_LETTERBOXED:
							frame->ConvertToYUVStripeLetterboxDeinterlace(lpSurface, lpSecondary, NULL, previous, width, height, lPitch, ppos, psize, true, DIFEF_ENABLE_BOTTOM_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, posd);
							frame->ConvertToYUVStripeLetterboxDeinterlace(lpSurface, lpSecondary, NULL, previous, width, height, lPitch, ppos, psize, true, DIFEF_ENABLE_TOP_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, cosd);
							break;
						case PDPM_PANSCAN:
							frame->ConvertToYUVStripePanScanDeinterlace(lpSurface, lpSecondary, NULL, previous, width, height, lPitch, panScanOffset, ppos, psize, true, DIFEF_ENABLE_BOTTOM_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, posd);
							frame->ConvertToYUVStripePanScanDeinterlace(lpSurface, lpSecondary, NULL, previous, width, height, lPitch, panScanOffset, ppos, psize, true, DIFEF_ENABLE_TOP_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, cosd);
							break;
						}
#else
	            frame->ConvertToYUVStripeDeinterlace(lpSurface, lpSecondary, NULL, previous, decodeWidth, decodeHeight, lPitch, ppos, psize, true, DIFEF_ENABLE_BOTTOM_DEINTERLACE, display->downscaleFilter, posd);
	            frame->ConvertToYUVStripeDeinterlace(lpSurface, lpSecondary, NULL, previous, decodeWidth, decodeHeight, lPitch, ppos, psize, true, DIFEF_ENABLE_TOP_DEINTERLACE, display->downscaleFilter, cosd);
#endif
					}

				ppos += psize;

            if (IsHigherPriorityTimedFiberReady(6))
					{
#ifdef USE_TEXTURE_SURFACES
#ifndef PUSHER_WORKAROUND
					lpDDBottom->UnlockRect(0);
					lpDDTop->UnlockRect(0);
#endif
					YieldTimedFiber(0);
#ifndef PUSHER_WORKAROUND
					lpDDTop->LockRect(0, &xLock, NULL, 0);
					lpDDBottom->LockRect(0, &xLock2, NULL, 0);
#endif
#else
#ifndef PUSHER_WORKAROUND
					lpDDBottom->UnlockRect();
					lpDDTop->UnlockRect();
#endif
					YieldTimedFiber(0);
#ifndef PUSHER_WORKAROUND
					lpDDTop->LockRect(&xLock, NULL, 0);
					lpDDBottom->LockRect(&xLock2, NULL, 0);
#endif
#endif
					lpSurface = (BYTE *)(xLock.pBits);
					lpSecondary = (BYTE *)(xLock2.pBits);
					}
				}

#if FRAME_ANNOTATION
			YUVD_WriteString(lpSurface,   lPitch, 40, 0, "Top");
			YUVD_WriteString(lpSecondary, lPitch, 40, 0, "Bottom");
#endif


#ifndef PUSHER_WORKAROUND
#ifdef USE_TEXTURE_SURFACES
			lpDDBottom->UnlockRect(0);
			lpDDTop->UnlockRect(0);
#else
			lpDDBottom->UnlockRect();
			lpDDTop->UnlockRect();
#endif
#endif
			lpSurface = NULL;
			}
		}

	}

bool XBoxDisplayBuffer::PrepareDeinterlaceDuringDecode(PictureDisplayBuffer * previous)
    {
    if (previous && previous->frame && previous->frame->IsFullFrame())
        {
        previousFrame = (XBoxDisplayBuffer *)previous;

        switch (mode)
            {
            case PS_FRAME_PICTURE:
                if (previous->fmode == PS_FRAME_PICTURE)
                    lpDDPrevious = previousFrame->lpDDSecondary;
                else
                    {
                    previousFrame = NULL;
                    lpDDPrevious = NULL;
                    }
                break;
            case PS_TOP_FIELD:
                lpDDPrevious = previousFrame->lpDDSecondary;
                break;
            case PS_BOTTOM_FIELD:
                lpDDPrevious = previousFrame->lpDDSurface;
                break;
            }

        deinterlaceY = 0;

        return lpDDPrevious != NULL;
        }
    else
        {
        previousFrame = NULL;
        lpDDPrevious = NULL;
        return FALSE;
        }
    }

bool XBoxDisplayBuffer::DeinterlaceFrame(PictureDisplayBuffer * previousT, Inverse32PulldownHint & phint, bool hurryUp)
    {
    LPDIRECTDRAWSURFACE lpDDTemorary;
    XBoxDisplayBuffer * previous = (XBoxDisplayBuffer *)previousT;


    if (frame && frame->IsFullFrame() &&
         previous->frame && previous->frame->IsFullFrame())
        {
        lock.Enter();

#if MEASURE_DEINTERLACE_TIME
    static __int64 lockSumTime;
    static int lockCount;
    __int64 t1, t2;

    ReadPerformanceCounter(t1);
#endif

        if (fmode == PS_FRAME_PICTURE)
            {
            if (previous->fmode == PS_FRAME_PICTURE)
                {
                if (!lpDDPrevious && decodeHeight > 0 && decodeWidth > 0)
                    {
                    if (Lock1Surface(previous->lpDDSecondary))
                        {
                        lpSurface = (BYTE *)(xLock.pBits);

#if SUPPORT_PANSCAN_LETTERBOX
						 switch (EffectivePresentationMode())
							 {
							 case PDPM_FULLSIZE:
								 frame->ConvertToYUVStripeInterpolate(lpSurface, previous->frame, width, height, lPitch, 0, frame->Height(), MinimumVideoDownscaleFilterLevelSet, (FullWidthMMXSPUDisplayBuffer *)osd);
								 break;
							 case PDPM_LETTERBOXED:
								 frame->ConvertToYUVStripeLetterboxInterpolate(lpSurface, previous->frame, width, height, lPitch, 0, frame->Height(), MinimumVideoDownscaleFilterLevelSet, (FullWidthMMXSPUDisplayBuffer *)osd);
								 break;
							 case PDPM_PANSCAN:
								 frame->ConvertToYUVStripePanScanInterpolate(lpSurface, previous->frame, width, height, lPitch, panScanOffset, 0, frame->Height(), MinimumVideoDownscaleFilterLevelSet, (FullWidthMMXSPUDisplayBuffer *)osd);
								 break;
							 }
#else

                        frame->ConvertToYUVStripeInterpolate(lpSurface, previous->frame, decodeWidth, decodeHeight, lPitch, 0, frame->Height(), display->downscaleFilter, (FullWidthMMXSPUDisplayBuffer *)osd);
#endif

#ifndef PUSHER_WORKAROUND

#ifdef USE_TEXTURE_SURFACES
                        previous->lpDDSecondary->UnlockRect(0);
#else
                        previous->lpDDSecondary->UnlockRect();
#endif
#endif
                        lpSurface = NULL;
                        }
                    }

#ifdef INVERSE_3_2_PULLDOWN__INTERPOLATION
                previous->mode = PS_TOP_FIELD;
#endif
                }
            else if (previous->mode != PS_FRAME_PICTURE)
                {
                if (previous->mode == PS_TOP_FIELD)
                    DeinterlaceSurfaces(previous->lpDDSecondary, lpDDSecondary, previous->mode, frame, previous->frame, (FullWidthMMXSPUDisplayBuffer *)osd, (FullWidthMMXSPUDisplayBuffer *)(previous->osd), hurryUp);
                else
                    DeinterlaceSurfaces(lpDDSecondary, previous->lpDDSurface, previous->mode, previous->frame, frame, (FullWidthMMXSPUDisplayBuffer *)(previous->osd), (FullWidthMMXSPUDisplayBuffer *)osd, hurryUp);
                }
            }
		else
            {
            if (previous->mode == PS_FRAME_PICTURE && phint != IPDH_UNKNOWN && frame->Is32PulldownFrame(previous->frame, phint))
                {
                if (decodeHeight > 0 && decodeWidth > 0 && Lock1Surface(lpDDSurface))
                    {
                    lpSurface = (BYTE *)(xLock.pBits);
                    lPitch = xLock.Pitch;

#if SUPPORT_PANSCAN_LETTERBOX
					 switch (EffectivePresentationMode())
						 {
						 case PDPM_FULLSIZE:
							 frame->ConvertToYUVStripeSingleInverse32Pulldown(lpSurface, previous->frame, width, height, lPitch, 0, frame->Height(), phint, MinimumVideoDownscaleFilterLevelSet, (FullWidthMMXSPUDisplayBuffer *)osd);
							 break;
						 case PDPM_LETTERBOXED:
							 frame->ConvertToYUVStripeLetterboxSingleInverse32Pulldown(lpSurface, previous->frame, width, height, lPitch, 0, frame->Height(), phint, MinimumVideoDownscaleFilterLevelSet, (FullWidthMMXSPUDisplayBuffer *)osd);
							 break;
						 case PDPM_PANSCAN:
//							 frame->ConvertToYUVStripeSingleInverse32Pulldown(lpSurface, previous->frame, width, height, lPitch, 0, frame->Height(), phint, MinimumVideoDownscaleFilterLevelSet, (FullWidthMMXSPUDisplayBuffer *)osd);
							 break;
						 }
#else

                    frame->ConvertToYUVStripeSingleInverse32Pulldown(lpSurface, previous->frame, decodeWidth, decodeHeight, lPitch, 0, frame->Height(), phint, display->downscaleFilter, (FullWidthMMXSPUDisplayBuffer *)osd);
#endif

#ifndef PUSHER_WORKAROUND

#ifdef USE_TEXTURE_SURFACES
                    lpDDSurface->UnlockRect(0);
#else
                    lpDDSurface->UnlockRect();
#endif
#endif
                    lpSurface = NULL;
                    }

                mode = PS_FRAME_PICTURE;
                }
            else
                {
                phint = IPDH_UNKNOWN;

                if (!lpDDPrevious)
                    {
                    if (mode == PS_TOP_FIELD)
                        DeinterlaceSurfaces(previous->lpDDSecondary, lpDDSurface, mode, frame, previous->frame, (FullWidthMMXSPUDisplayBuffer *)osd, (FullWidthMMXSPUDisplayBuffer *)(previous->osd), hurryUp);
                    else
                        DeinterlaceSurfaces(lpDDSecondary, previous->lpDDSurface, mode, previous->frame, frame, (FullWidthMMXSPUDisplayBuffer *)(previous->osd), (FullWidthMMXSPUDisplayBuffer *)osd, hurryUp);
                    }
                }
            }

        if (!previous->firstFieldDeinterlaced && previous->fmode != PS_FRAME_PICTURE)
            {
            if (previous->fmode == PS_TOP_FIELD)
                {
                lpDDTemorary = previous->lpDDSurface; previous->lpDDSurface = previous->lpDDSecondary; previous->lpDDSecondary = lpDDTemorary;
                }

            previous->firstFieldDeinterlaced = TRUE;
            previous->mode = PS_FRAME_PICTURE;
            }

#if MEASURE_DEINTERLACE_TIME
        ReadPerformanceCounter(t2);

        lockSumTime += t2 - t1;
        lockCount++;

        if (!(lockCount & 255))
            {
            char buffer[100];
            wsprintf(buffer, "Deinterlace %d : %d.%02d\n", lockCount, (int)(lockSumTime / lockCount), (int)(100 * lockSumTime / lockCount % 100));
            OutputDebugString(buffer);
            }
#endif

        firstFieldDeinterlaced = TRUE;
        previousFrame = NULL;
        lpDDPrevious = NULL;

        lock.Leave();

        return TRUE;
        }
	else
		return FALSE;

    }

bool XBoxDisplayBuffer::CompleteDeinterlaceFrame(void)
    {
    LPDIRECTDRAWSURFACE lpDDTemorary;

    if (frame && frame->IsFullFrame())
        {
        lock.Enter();

        if (!firstFieldDeinterlaced)
            {
            switch (fmode)
                {
                case PS_TOP_FIELD:

                    if (decodeHeight > 0 && decodeWidth > 0 && Lock1Surface(lpDDSurface))
                        {
                        lpSurface = (BYTE *)(xLock.pBits);
#if SUPPORT_PANSCAN_LETTERBOX
						 switch (EffectivePresentationMode())
							 {
							 case PDPM_FULLSIZE:
								 frame->ConvertToYUVStripeDeinterlaceStretch(lpSurface, NULL, width, height, lPitch, 0, frame->Height(),
									 DIFEF_ENABLE_TOP_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, (FullWidthMMXSPUDisplayBuffer *)osd);
								 break;
							 case PDPM_LETTERBOXED:
								 frame->ConvertToYUVStripeLetterboxDeinterlaceStretch(lpSurface, NULL, width, height, lPitch, 0, frame->Height(),
									 DIFEF_ENABLE_TOP_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, (FullWidthMMXSPUDisplayBuffer *)osd);
								 break;
							 case PDPM_PANSCAN:
								 frame->ConvertToYUVStripePanScanDeinterlaceStretch(lpSurface, NULL, width, height, lPitch, panScanOffset, 0, frame->Height(),
									 DIFEF_ENABLE_TOP_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, (FullWidthMMXSPUDisplayBuffer *)osd);
								 break;
							 }
#else


                        frame->ConvertToYUVStripeDeinterlaceStretch(lpSurface, NULL, decodeWidth, decodeHeight, lPitch, 0, frame->Height(),
                            DIFEF_ENABLE_TOP_DEINTERLACE, display->downscaleFilter, (FullWidthMMXSPUDisplayBuffer *)osd);
#endif

#ifndef PUSHER_WORKAROUND

#ifdef USE_TEXTURE_SURFACES
                        lpDDSurface->UnlockRect(0);
#else
                        lpDDSurface->UnlockRect();
#endif
#endif
                        lpSurface = NULL;
                        }

                    break;
                case PS_BOTTOM_FIELD:

                    if (decodeHeight > 0 && decodeWidth > 0 && Lock1Surface(lpDDSecondary))
                        {
                        lpSurface = (BYTE *)(xLock.pBits);

#if SUPPORT_PANSCAN_LETTERBOX
						 switch (EffectivePresentationMode())
							 {
							 case PDPM_FULLSIZE:
								 frame->ConvertToYUVStripeDeinterlaceStretch(NULL, lpSurface, width, height, lPitch, 0, frame->Height(),
									 DIFEF_ENABLE_BOTTOM_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, (FullWidthMMXSPUDisplayBuffer *)osd);
								 break;
							 case PDPM_LETTERBOXED:
								 frame->ConvertToYUVStripeLetterboxDeinterlaceStretch(NULL, lpSurface, width, height, lPitch, 0, frame->Height(),
									 DIFEF_ENABLE_BOTTOM_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, (FullWidthMMXSPUDisplayBuffer *)osd);
								 break;
							 case PDPM_PANSCAN:
								 frame->ConvertToYUVStripePanScanDeinterlaceStretch(NULL, lpSurface, width, height, lPitch, panScanOffset, 0, frame->Height(),
									 DIFEF_ENABLE_BOTTOM_DEINTERLACE, MinimumVideoDownscaleFilterLevelSet, (FullWidthMMXSPUDisplayBuffer *)osd);
								 break;
							 }
#else

                        frame->ConvertToYUVStripeDeinterlaceStretch(NULL, lpSurface, decodeWidth, decodeHeight, lPitch, 0, frame->Height(),
                            DIFEF_ENABLE_BOTTOM_DEINTERLACE, display->downscaleFilter, (FullWidthMMXSPUDisplayBuffer *)osd);
#endif

#ifndef PUSHER_WORKAROUND
#ifdef USE_TEXTURE_SURFACES
                        lpDDSecondary->UnlockRect(0);
#else
                        lpDDSecondary->UnlockRect();
#endif
#endif
                        lpSurface = NULL;
                        }
                    break;
                }
            }

        if (fmode == PS_BOTTOM_FIELD)
            {
            lpDDTemorary = lpDDSurface; lpDDSurface = lpDDSecondary; lpDDSecondary = lpDDTemorary;
            }

        mode = PS_FRAME_PICTURE;
        lock.Leave();

        return TRUE;
        }
    else
        return FALSE;
    }

bool XBoxDisplayBuffer::DeinterlaceInitialFrame(void)
    {
    return FALSE;
    }

void XBoxDisplayBuffer::CopyFrame(FrameStore * frame)
    {
    if (frame && frame->IsFullFrame())
        {
		  if (display->completed)
			  fmode = PS_FRAME_PICTURE;

        if (fmode == PS_FRAME_PICTURE)
            {
            if (BeginStripeAccess(frame, frame->Height(), PS_FRAME_PICTURE))
                {
                CopyStripe(0, PS_FRAME_PICTURE);
                DoneStripeAccess();
                }

            mode = fmode;
            }
        else
            {
            if (BeginStripeAccess(frame, frame->Height(), PS_FRAME_PICTURE))
                {
                CopyStripe(0, PS_FRAME_PICTURE);
                DoneStripeAccess();
                }

				CompleteDeinterlaceFrame();

            mode = fmode;
            }
        }
    }

void XBoxDisplayBuffer::UpdateOSDBitmap(SPUDisplayBuffer * map)
    {
    display->lock.Enter();

    lock.Enter();

    if (frame && map && frame->IsFullFrame())
        {
        osd = map;

        CopyFrame(frame);
        }

    lock.Leave();

    display->lock.Leave();
    }



void XBoxDisplayBuffer::ClearFrame(void)
    {
    lock.Enter();

    if (BeginStripeAccess(NULL, height, PS_FRAME_PICTURE))
        {
        DoneStripeAccess();
        }

    lock.Leave();
    }


void __cdecl XBoxDisplayBuffer::DebugPrint(int x, int y, char * format, ...)
    {
    HRESULT ddrval;

    char buffer[256];
    wvsprintf(buffer, format, (LPSTR)(&format+1));

    lock.Enter();

	/*
    while ((ddrval = lpDDSurface->Lock(NULL, &desc, display->lockFlags|DDLOCK_SURFACEMEMORYPTR|DDLOCK_WRITEONLY, NULL)) == DDERR_WASSTILLDRAWING)
        {
        YieldTimedFiber(DisplayCompletionDelay(), TRUE);
        }
	*/



#ifndef PUSHER_WORKAROUND

#ifdef USE_TEXTURE_SURFACES
	ddrval = lpDDSurface->LockRect(0, &xLock, NULL, NULL);

    if (ddrval == DD_OK)
        {
        lpSurface = (BYTE *)(xLock.pBits);
        lPitch = xLock.Pitch;

		ddrval = lpDDSecondary->LockRect(0, &xLock2, NULL, NULL);
        if (ddrval == DD_OK)
            {
            lpSecondary = (BYTE *)(xLock2.pBits);

            YUVD_WriteString(lpSurface, lPitch, x, y, buffer);
            YUVD_WriteString(lpSecondary, lPitch, x, y, buffer);

            lpDDSecondary->UnlockRect(0);
            }
        lpDDSurface->UnlockRect(0);
        lpSurface = NULL;
        }
#else
	ddrval = lpDDSurface->LockRect(&xLock, NULL, NULL);

    if (ddrval == DD_OK)
        {
        lpSurface = (BYTE *)(xLock.pBits);
        lPitch = xLock.Pitch;

		ddrval = lpDDSecondary->LockRect(&xLock2, NULL, NULL);
        if (ddrval == DD_OK)
            {
            lpSecondary = (BYTE *)(xLock2.pBits);

            YUVD_WriteString(lpSurface, lPitch, x, y, buffer);
            YUVD_WriteString(lpSecondary, lPitch, x, y, buffer);

            lpDDSecondary->UnlockRect();
            }
        lpDDSurface->UnlockRect();
        lpSurface = NULL;
        }
#endif

#else

	if (lpDDSurface->Common & D3DCOMMON_VIDEOMEMORY)
		xLock.pBits = (void *)(lpDDSurface->Data | 0xF0000000);
	else
		xLock.pBits = (void *)(lpDDSurface->Data | 0x80000000);

	xLock.Pitch = CalcPitch(decodeWidth);
	ddrval = DD_OK;

    if (ddrval == DD_OK)
        {
        lpSurface = (BYTE *)(xLock.pBits);
        lPitch = xLock.Pitch;

		if (lpDDSecondary->Common & D3DCOMMON_VIDEOMEMORY)
			xLock2.pBits = (void *)(lpDDSecondary->Data | 0xF0000000);
		else
			xLock2.pBits = (void *)(lpDDSecondary->Data | 0x80000000);

		xLock2.Pitch = CalcPitch(decodeWidth);
		ddrval = DD_OK;

        if (ddrval == DD_OK)
            {
            lpSecondary = (BYTE *)(xLock2.pBits);

            YUVD_WriteString(lpSurface, lPitch, x, y, buffer);
            YUVD_WriteString(lpSecondary, lPitch, x, y, buffer);

            }
        lpSurface = NULL;
        }


#endif



    lock.Leave();
    }

#pragma warning(default : 4799)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\common\KrnlInt.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\krnlint.cpp
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:
//
#include "KrnlInt.h"



KernelInt64 operator* (const KernelInt64 u, const KernelInt64 v)
	{
	BOOL sign;
	DWORD ll0, ll1, lh, hl, dummy;
	KernelInt64 u1, v1;

	if (u < 0)
		{
		u1 = -u;
		sign = TRUE;
		}
	else
		{
		u1 = u;
		sign = FALSE;
		}

	if (v < 0)
		{
		v1 = -v;
		sign = !sign;
		}
	else
		{
		v1 = v;
		}

	MUL32x32(v1.lower, u1.lower, ll1, ll0);
	MUL32x32(v1.lower, u1.upper, dummy, lh);
	MUL32x32(v1.upper, u1.lower, dummy, hl);

	if (sign)
		return -KernelInt64(ll0, lh+hl+ll1);
	else
		return KernelInt64(ll0, lh+hl+ll1);
	}

KernelInt64 operator/ (const KernelInt64 u, const KernelInt64 v)
	{
	BOOL sign;
	KernelInt64 u1, v1, acc;
	DWORD a0, a1, a2;

	if (u < 0)
		{
		u1 = -u;
		sign = TRUE;
		}
	else
		{
		u1 = u;
		sign = FALSE;
		}

	if (v < 0)
		{
		v1 = -v;
		sign = !sign;
		}
	else
		{
		v1 = v;
		}

	if (v1 != 0)
		{
		if (v1.upper)
			{
			if (u1.upper <= v1.upper)
				{
				a0 = u1.upper / v1.upper;
				MUL32x32(a0, v1.lower, a1, a2);
				a2 += a0 * v1.upper;
				acc = KernelInt64(a1, a2);
				if (acc > u1) a0--;

				acc = KernelInt64(a0, 0L);
				}
			else
				acc = 0;
			}
		else
			{
			if ((unsigned long)u1.upper < v1.lower)
				{
				a0 = DIV64x32(u1.upper, u1.lower, v1.lower);
				acc = KernelInt64(a0, 0L);
				}
			else
				{
				a0 = u1.upper / v1.lower;
				a1 = DIV64x32(u1.upper % v1.lower, u1.lower, v1.lower);
				acc = KernelInt64(a1, a0);
				}
			}
		if (sign)
			return -acc;
		else
			return acc;
		}
	else
		{
		if (sign)
			return KernelInt64(0x00000000, 0x80000000);
		else
			return KernelInt64(0xffffffff, 0x7fffffff);
		}
	}

KernelInt64::KernelInt64(KernelString str, int base)
	{
	int i = 0;
	BOOL sign = FALSE;
	TCHAR c;

	*this = 0;

	if (str[0] == '-')
		{
		sign = TRUE;
		i++;
		}

	while (c = str[i++])
		{
		*this *= base;

		if (c >= __TEXT('a') && c <= __TEXT('f'))
			*this += c - __TEXT('a') + 10;
		else if (c >= __TEXT('A') && c <= __TEXT('F'))
			*this += c - __TEXT('A') + 10;
		else if (c >= __TEXT('0') && c <= __TEXT('9'))
			*this += c - __TEXT('0');
		}

	if (sign)
		*this = -*this;
	}

KernelString KernelInt64::ToString(int digits, int base, TCHAR fill)
	{
	KernelString s;
	KernelInt64 a;
	BOOL sign;

	if (*this < 0)
		{
		a = -*this;
		sign = TRUE;
		}
	else
		{
		a = *this;
		sign = FALSE;
		}

	if (a == 0)
		{
		s = __TEXT("0");
		}
	else
		{
		while (a > 0)
			{
			int val = (a % base).ToLong();

			if (val < 10)
				s = KernelString((TCHAR)(__TEXT('0') + val)) + s;
			else
				s = KernelString((TCHAR)(__TEXT('A') + val - 10)) + s;

			a = a / base;
			}
		}

	if (sign)
		s = KernelString(__TEXT('-')) + s;

	if (digits)
		{
		while (s.Length() < digits) s = KernelString(fill) + s;
		}

	return s;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\Video\VideoDisplay.h ===
//depot/xbox-aug01-final/private/ui/dvd/driver/softwarecinemaster/Video/VideoDisplay.h#3 - edit change 19203 (text)
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef VIDEODISPLAY_H
#define VIDEODISPLAY_H

#include "driver\SoftwareCinemaster\Common\Prelude.h"
#include "..\common\streamtiming.h"
#include "..\common\ASyncErrorMessages.h"
#include "FrameStore.h"
#include "..\common\TimedFibers.h"
#include "..\SPUDecoder\SPUDisplayBuffer.h"
#include "MacrovisionEncoder.h"
#undef ONLY_EXTERNAL_VISIBLE //get rid of pesky warnings
#define ONLY_EXTERNAL_VISIBLE
#include "library\hardware\videodma\generic\pip.h"

	//
	// State of a PictureDisplayBuffer.  Maintained for client, not
	// used by GenericPictureDisplay.
	//
enum PictureDisplayBufferState
	{
	PDBS_IDLE,						// The display buffer is currently not used
	PDBS_REFERENCED,				// The display buffer is referenced, and can not be reused
	PDBS_DECODING,					// Decoding is currently done into ths display buffer
	PDBS_PENDING,					// The display buffer waits in the display queue
	PDBS_DISPLAYING,				// The display buffer is currently displayed
	PDBS_DISPLAYCOMPLETING		// The display buffer waits for display to complete
	};

enum PictureDisplayPresentationMode
	{
	PDPM_FULLSIZE,
	PDPM_LETTERBOXED,
	PDPM_PANSCAN,
	PDPM_FULLSIZE16by9
	};

enum PictureDisplayAspectRatio
	{
	PDAR_4by3,
	PDAR_16by9
	};

class GenericPictureDisplay;

	//
	// Generic picture display buffer.  Every picture that is in the
	// display queue is associated by a PictureDisplayBuffer
	//
class PictureDisplayBuffer
	{
	protected:
		GenericPictureDisplay			*	display;			// handle to the display handler
	public:
		SPUDisplayBuffer					*	osd;				// associated sub picture buffer, or NULL if none
		FrameStore							*	frame;			// associated frame store, or NULL if none
		int										sheight;			// height of a stripe during StripeAccess
		PictureStructure						mode;				// requested display mode
		PictureStructure						fmode;			// picture structure of the frame buffer
		int										fieldTime;		// duration of a single field
		bool										complete;		// TRUE, if the buffer contains a complete picture
		int										referenceCount;// number of references to this buffer
		PictureDisplayBufferState			state;			// current state of the buffer.
		PictureDisplayAspectRatio			aspectRatio;	// the aspect ratio of this picture
		int										panScanOffset;	// horizontal pan & scan vector

		PictureDisplayBuffer(GenericPictureDisplay * display) {this->display = display; osd = NULL; frame = NULL;}

		virtual ~PictureDisplayBuffer(void) {}

			//
			// Braces the decoding into a display buffer.  A sub picture buffer
			// is given to the buffer, if one is to overlay it.
			//
			// IN  : osd       : Sub picture buffer to overlay.
			//
		virtual void BeginDecoding(SPUDisplayBuffer * osd) {this->osd = osd;}
		virtual void DoneDecoding(void) {}

			//
			// Braces stripe level access to the buffer during decode.  This mode
			// is used during decode to acces vertical subsections of the display
			// buffer.
			//
			// IN  : frame     : Frame buffer that is used as a reference during
			//                   the decode of this frame.
			// IN  : sheight   : Height of a stripe
			// RETURN          : TRUE on success
			//
		virtual bool BeginStripeAccess(FrameStore * frame, int sheight, PictureStructure fmode)
			{
			this->frame = frame;
			this->sheight = sheight;
			return TRUE;
			}
		virtual void DoneStripeAccess(void) {}

			//
			// Braces direct access to a stripe of data during decode.  The data
			// has to be in YUY2 mode for this access to succeed.  The display
			// buffer does also have to have to the correct size.  This function
			// will also fail, if subpicture data is to be overlayed inside the
			// display buffer at this stripe location.
			//
			// IN  : width     : requested decoding width of the picture
			// IN  : height    : requested decoding height of the picture
			// IN  : ss        : vertical stripe start
			//	OUT : p         : pointer to first line of even data to access.
			// OUT : ip        : pointer to first line of odd data to access, or NULL if
			//                   odd and even lines are interleaved.
			// OUT : stride    : distance between to lines of the same field, or two lines
			//                   of the frame if the display is interleaved.
			// RETURN          : TRUE on success
			//
		virtual bool AttemptDirectStripeYUVAccess(int width, int height, int ss, BPTR & p, BPTR & ip, int & stride) {return FALSE;}
		virtual void DoneDirectStripeAccess(PictureStructure fmode) {}

			//
			// Copy a single stripe from the frame buffer to the display buffer.
			// This function is typically used, of the direct access fails.  It
			// has to perform all necessary conversion operations, and subpicture
			// overlay functions.
			//
			// IN  : ss        : vertical stripe start
			// IN  : fmode     : picture structure
			//
		virtual void CopyStripe(int ss, PictureStructure fmode) = 0;

			//
			// Queries whether the display buffer needs the frame buffer data, even
			// if direct access did happen.  This can be the case if deinterlacing
			// is performed.
			//
		virtual bool NeedsFrameDataWithDirectYUVAccess(void) {return FALSE;}

			//
			// Copy a complete frame from the frame buffer into the display buffer
			//
		virtual void CopyFrame(FrameStore * frame)
			{
			if (frame && frame->IsFullFrame() && BeginStripeAccess(frame, frame->Height(), PS_FRAME_PICTURE))
				{
				CopyStripe(0, PS_FRAME_PICTURE);
				DoneStripeAccess();
				}
			}

		virtual void ClearFrame(void) {}

			//
			// Perform deinterlacing after the decoding of a frame.
			//
			// IN  : previous  : Previous display buffer, needed as reference
			// IO  : phint     : Inverse 3/2 pulldown hint, can be utilized by the deinterlace
			//                   algorithm to perform inverse 3/2 pulldown, instead of normal
			//                   deinterlacing, when 3/2 pulldown is likely
			// IN  : hurryUp   : The decoder is low on decoding time, may be used as a hint
			//                   to choose a simpler deinterlacing algorithm.
			//
		virtual bool DeinterlaceFrame(PictureDisplayBuffer * previous, Inverse32PulldownHint & phint, bool hurryUp)
			{
			return FALSE;
			}

			//
			// Prepare a display buffer for deinterlacing during decoding.
			//
			// IN  : previous  : Previous display buffer, needed as reference
			//
		virtual bool PrepareDeinterlaceDuringDecode(PictureDisplayBuffer * previous)
			{
			return FALSE;
			}

			//
			// Inform a display buffer, that it is likely the last display buffer in the
			// sequence, and has to perform deinterlacing with its data.
			//
		virtual bool CompleteDeinterlaceFrame(void)
			{
			return FALSE;
			}

		virtual bool DeinterlaceInitialFrame(void)
			{
			return FALSE;
			}


			//
			// Start the display of this frame, or a single field of the full frame.
			//
			// IN  : mode      : Frame or field to be displayed
			//
		virtual void DisplayFrame(PictureStructure mode) = 0;

			//
			// Check whether display is completed (this display buffer is no longer
			// visible on the screen).
			//
		virtual bool DisplayCompleted(void) = 0;

			//
			// Return the number of milliseconds, that this display buffer will be
			// visible on the screen, before the display is completed.
			//
		virtual int DisplayCompletionDelay(void)
			{
			return 1;
			}

			//
			// The sub picture display has changed during the display of this display
			// buffer.  If this buffer contains enough information to change the sub
			// picture overlay, it should do so.  This function is typically not called
			// during streaming, but for a still frame.
			//
		virtual void UpdateOSDBitmap(SPUDisplayBuffer * map) = 0;

			//
			// Sets the field versus frame display mode of this display buffer
			//
			// IN  : mode      : Either frame mode, or top/bottom first field display
			//                   mode.  This function is called, before the actual
			//                   frame decoding is started.
			// IN  : fieldTime : duration of a single field
			//
		virtual void SetFieldDisplayMode(PictureStructure mode, int fieldTime)
			{
			this->fmode = this->mode = mode;
			this->fieldTime = fieldTime;
			}

		PictureDisplayPresentationMode EffectivePresentationMode(void);

		virtual void SetAspectRatio(PictureDisplayAspectRatio aspectRatio, int panScanOffset = 0)
			{
			this->aspectRatio = aspectRatio;
			this->panScanOffset = panScanOffset;
			}

			//
			// Frame completion routine.  A frame is considered complete, if all
			// data could be decoded correctly, or the error conceilment likely
			// resulted in a usefull picture.  If a frame is not complete, it should
			// not be used for display in a sequence.
			//
		void MarkFrameIncomplete(void) {complete = FALSE;}
		void MarkFrameComplete(void) {complete = TRUE;}
		bool IsFrameComplete(void) {return complete;}

			//
			// Check whether this display buffer (also considered a frame) is
			// likely to be two interlaced fields.
			//
		virtual bool HasInterlaceArtifacts(void) {return FALSE;}

			//
			// Mark the frame buffer associated with this display buffer invalid.
			//
		virtual void InvalidateBuffer(void) {frame = NULL;}

			//
			// Increase or decrease the reference counter for this frame.  Reference
			// counters are used for HW assisted decoders, that use independend direct
			// draw surfaces.
			//
		void ObtainReference(void);
		void ReleaseReference(void);

			//
			// Check whether the rendering of this frame is complete.
			//
		virtual bool IsRenderingComplete(void) {return !frame || frame->IsRenderingComplete();}

		virtual void __cdecl DebugPrint(int x, int y, char * format, ...) {};
	};

#define NUMOSDPREVIEW	8

	//
	// Deinterlacing capabilities
	//
#define DEIF_DEINTERLACE_WEAVE					1
#define DEIF_DEINTERLACE_BOB						2
#define DEIF_CAN_CHANGE_DEINTERLACE_DECODE	4
#define DEIF_CAN_CHANGE_DEINTERLACE_DISPLAY	8

	//
	// Generic display device.  Handles all display timing, and display buffer
	// queueing.  It does also control the subpicture overlay timing.
	//
class GenericPictureDisplay : public TimingSlave,
                              protected TimedFiber
	{
	friend class PictureDisplayBuffer;
	protected:
		TimedFiberMutex			lock;									// mutex for protection of shared variables
		TimedFiberEvent			event;								// event to signal for new frame available
		TimedFiberEvent			queueEvent;							// event to signal for idle frame available
		volatile bool				terminate;							// request for streaming termination
		volatile bool				pause;								// request for pause
		volatile bool				isPaused;							// acknowledge for pause
		volatile bool				completed;							// acknowledge for completion
		volatile bool				step;									// request for single step
		bool							scanning;							// scanning mode indiaction
		bool							streaming;							// streaming mdoe indication
		bool							secondField;						// displaying second field of an interlaced frame
		PictureStructure			displayMode;						// current picture display mode

		PictureDisplayBuffer *	displayBuffers[16];				// all allocated display buffers
		int							numDisplayBuffers;				// number of allocated display buffers

		PictureDisplayBuffer	*	availQueue[16];						// idle display buffers
		PictureDisplayBuffer	*	pendingQueue[8];					// ready to be displayed buffers
		int							timeQueue[8];						// times for the ready to be displayed buffers

		PictureDisplayBuffer	*	display;								// currently displayed buffer
		PictureDisplayBuffer	*	nextAvail;							// previous displayed buffer, while it is still visible

		SPUDisplayBuffer		*	osdMap[NUMOSDPREVIEW];			// pending sub picture buffers
		int							osdStartTime[NUMOSDPREVIEW];	// start times for sub picture buffers
		int							osdStopTime[NUMOSDPREVIEW];	// end times for sub picture buffers

		int							initialDisplayTime;				// display time of first frame in a streaming sequence
		int							noOfDisplayFrames;				// number of frames displayed in current sequence

		volatile	int				firstAvail, lastAvail;			// queue control for idle queue

		MacrovisionEncoder	*	macrovisionEncoder;				// handle to macrovision encoder if available
		DWORD							preferedDeinterlaceMode;		// prefered deinterlace mode

		TimingClient				timingClient;						// timing client, used to wait for display time

		PictureDisplayPresentationMode	presentationMode;		// selects between Pan&Scan, Letterbox and Wide

		struct SPUDeferData												// data for defered sub picture display
			{
			SPUDisplayBuffer		*	map;								// sub picture bitmap
			int							mid;								// index into sub picture display queue
			int							startTime;						// start time of this subpicture
			int							stopTime;						// stop time of this subpicture
			} spuDeferData;

		ASyncErrorMessenger	*	errorMessenger;

			//
			// Check if the final frame is currently displayed
			//
		bool FinalFrameIsDisplayed(void);

			//
			// Execution routine for the display thread
			//
		virtual void FiberRoutine(void);

			//
			// Allocate the display buffers into the displayBuffers array.  If this
			// function fails, it should set numDisplayBuffers to zero.
			//
		virtual void AllocateDisplayBuffers(void) = 0;

			//
			// Free all allocated display buffers
			//
		virtual void FreeDisplayBuffers(void) = 0;

			//
			// Clear all allocated display buffers (fill them with black).
			//
		virtual void ClearDisplayBuffers(void) = 0;

			//
			// Attempt to defer the update of a sub picture bitmap, to prevent flickering
			// caused by frame reordering.
			//
			// IN  : map       : Sub picture display buffer
			// IN  : mid       : Entry in sub picture display queue
			// IN  : startTime : Start time for sub picture display
			// IN  : stopTime  : Stop time for sub picture display
			//
		virtual bool DeferUpdateOSDBitmap(SPUDisplayBuffer * map, int mid, int startTime, int stopTime);

		virtual void BeginFreezeDisplay(void) {}
		virtual void EndFreezeDisplay(void) {}
	public:
		GenericPictureDisplay(void);
		virtual ~GenericPictureDisplay(void);

			//
			// Initialize the display system, after the sequence header has been decoded.
			// This function may also be called inside a sequence, if the picture size
			// changes.
			//
			// IN  : width     : width of decoded frame
			// IN  : height    : height of decoded frame
			// IN  : minStretch: minimum stretch factor from the frame buffer to
			//                   the actual display.  1000 is a 1:1 mapping
			//
		virtual void InitDisplay(int width, int height, int minStretch);

			//
			// Hide the display.
			//
		virtual void HideDisplay(void);

			//
			// Mark all decoding buffers as invalid in the display buffers.
			//
		virtual void InvalidateDecodingBuffer(void);

			//
			// Bracing a playback sequence.  No buffer operation is performed
			// outside of a Begin/EndStreaming pair.
			//
			// IN  : scanning	 : TRUE, if the playback is in scanning mode, which
			//                   means that every buffer is to be displayed as
			//                   soon as it arrives.
			// IN  : fullReset : TRUE, all display buffers should be deleted,
			//                   and the display area hidden.
			//
		virtual void BeginStreaming(bool scanning);
		virtual void EndStreaming(bool fullReset);

			//
			// Start/Stop of a playback sequence.  Several Start/Stop pairs
			// maybe called inside a single pair of Begin/EndStreaming.  These
			// functions should execute immediately, without any delay.
			//
			// IN : playbackSpeed : 0x10000 is normal speed
			//
		virtual void StartStreaming(int playbackSpeed);
		virtual void StopStreaming(void);

			//
			// Inform the display that there is no more buffer to be expected.
			//
		virtual void DoneStreaming(void);

			//
			// Advance a single frame in Stop mode.
			//
		virtual void AdvanceFrame(void);

			//
			// Check whether the display buffers are lost to a different application,
			// and the display should be reinitialized.
			//
//		virtual bool CheckDisplayBuffersLost(void) {return FALSE;}

			//
			// Get an empty IP frame display buffer.  This function will wait
			// until an idle disply buffer is available.  If no display buffer
			// will be available (e.g. display buffers lost), it will return
			// NULL.
			//
			// IN  : approxDisplayTime : approximate display time of this IP frame
			//                           buffer.  The actual time may not be known
			//                           to the decoder at this stage of decoding.
			//									  This time is used to select a sub picture
			//                           display buffer.
			//
		virtual PictureDisplayBuffer * GetIPFrameBuffer(int approxDisplayTime);

			//
			// Put a decoded IP frame display buffer into the queue of pending
			// display buffers.
			//
			// IN  : frame      	 : display buffer to be displayed
			// IN  : displayTime  : actual display time for this picture
			//
		virtual void PostIPFrameBuffer(PictureDisplayBuffer * frame, int displayTime);

			//
			// Display/Frame buffer reference management
			//
		virtual void ObtainIPFrameBufferReference(PictureDisplayBuffer * frame);
		virtual void ReleaseIPFrameBufferReference(PictureDisplayBuffer * frame);
		virtual bool IsIPFrameBufferReferences(PictureDisplayBuffer * frame) {return frame->referenceCount > 0;}

			//
			// Get an empty B frame display buffer.  This function will wait
			// until an idle display buffer is available.  If no display buffer
			// will be available (e.g. display buffers lost), it will return
			// NULL.
			//
			// IN  : displayTime  : actual display time for this picture
			//
		virtual PictureDisplayBuffer * GetBFrameBuffer(int displayTime);

			//
			// Put a decoded B frame display buffer into the queue of pending
			//
			// IN  : frame      	 : display buffer to be displayed
			// IN  : displayTime  : actual display time for this picture
			//
		virtual void PostBFrameBuffer(PictureDisplayBuffer * frame, int displayTime);

			//
			// Return the number of entries in the sub picture display queue.
			//
		virtual int NumOSDBitmapPreview(void) {return NUMOSDPREVIEW;}

			//
			// Find an sub picture display buffer for the given time
			//
		virtual SPUDisplayBuffer * FindOSDBitmap(int time);

			//
			// Update the current sub picture display with this buffer
			//
		virtual void UpdateOSDBitmap(SPUDisplayBuffer * map);

			//
			// Prepare the display of the given sub picture display buffer.
			//
		virtual void PrepareOSDBitmap(SPUDisplayBuffer * map) {}

			//
			// Send a sub picture display buffer from the sub picture display
			// manager.
			//
		virtual void PostOSDBitmap(SPUDisplayBuffer * map, int startTime, int stopTime);

			//
			// Invalidate all sub picture display buffers.
			//
		virtual void InvalidateOSDBitmaps(void);

			//
			// Get dimensions of actual display rectangle in the display window
			//
		virtual void GetDisplayLeft(short & x) {x = 0;}
		virtual void GetDisplayTop(short & y) {y = 0;}
		virtual void GetDisplayWidth(short & w) = 0;
		virtual void GetDisplayHeight(short & h) = 0;

			//
			// Check whether this display is also a decoder
			//
		virtual bool IsDecoder(void) {return FALSE;}

			//
			// Change the macrovision level.  If a macrovisionEncoder is available,
			// this call is simply forwarded.
			//
		virtual void SetMacrovisionLevel(int level) {if (macrovisionEncoder) macrovisionEncoder->SetMacrovisionLevel(level);}

           //
           // Change the CGMS mode
           //

        virtual void SetCGMSMode(VideoCopyMode eCGMSMode) {}


			//
			// Set a MacrovisionEncoder for this display
			//
		virtual void SetMacrovisionEncoder(MacrovisionEncoder * encoder) {macrovisionEncoder = encoder;}

			//
			// Set the cropping rectangle
			//
		virtual void SetCropRectangle(WORD left, WORD top, WORD right, WORD bottom) = 0;

		virtual void SetDisplayPresentationMode(PictureDisplayPresentationMode presentationMode);

			//
			// Force a different video start time, for clips that do not start
			// with a PTS of zero.
			//
		virtual void SetVideoStartTiming(int startTime);

			//
			// Check whether this display device is available and functioning.
			//
		virtual Error CheckHardwareResources(void) {GNRAISE_OK;}

			//
			// Get the available deinterlace features of this display device.
			//
		virtual DWORD GetDeinterlaceFlags(void)
			{
			return DEIF_DEINTERLACE_WEAVE |
				    DEIF_DEINTERLACE_BOB |
				    DEIF_CAN_CHANGE_DEINTERLACE_DECODE |
				    DEIF_CAN_CHANGE_DEINTERLACE_DISPLAY;
			}

			//
			// Set the prefered deinterlace mode
			//
		virtual void SetPreferedDeinterlaceMode(DWORD mode)
			{preferedDeinterlaceMode = mode;}

			//
			// Check whether this display device supports direct stripe access
			//
		virtual bool SupportsStripeAccess(void) {return TRUE;}

			//
			// Check whether this display needs the previous frame for decoding,
			// typically used in deinterlacing.
			//
		virtual bool NeedsPreviousFrame(void) {return FALSE;}

		void SetErrorMessenger(ASyncErrorMessenger * errorMessenger) {this->errorMessenger = errorMessenger;}
	};

inline void PictureDisplayBuffer::ObtainReference(void) {display->ObtainIPFrameBufferReference(this);}
inline void PictureDisplayBuffer::ReleaseReference(void) {display->ReleaseIPFrameBufferReference(this);}
inline PictureDisplayPresentationMode PictureDisplayBuffer::EffectivePresentationMode(void)
	{
	if (/*aspectRatio == PDAR_4by3 ||*/ display->presentationMode == PDPM_FULLSIZE16by9)
		return PDPM_FULLSIZE;
	else
		return display->presentationMode;
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\common\Krnlsync.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\krnlsync.cpp
// AUTHOR:    Viona
// COPYRIGHT: (c) 1996 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:

#include "krnlsync.h"

#include "vddebug.h"





#if NT_KERNEL


IRQMutex::IRQMutex(void)
	{
	KeInitializeSpinLock(&lock);
	KeInitializeEvent(&event, SynchronizationEvent, TRUE);
	block = TRUE;
	}


void IRQMutex::Enter(void)
	{
	LARGE_INTEGER	li;

	if (KeGetCurrentIrql() < DISPATCH_LEVEL)
		{
		li.QuadPart = 0x7fffffffffffffff;

		for(;;)
			{
			KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, &li);

			KeAcquireSpinLock(&lock, &irql);

			if (block) break;

			KeReleaseSpinLock(&lock, irql);
			}

		atIRQLevel = FALSE;
		}
	else
		{
		KeAcquireSpinLockAtDpcLevel(&lock);
		atIRQLevel = TRUE;
		}
	}


void IRQMutex::Leave(void)
	{
	if (!atIRQLevel)
		{
		KeReleaseSpinLock(&lock, irql);
		KeSetEvent(&event, 0, FALSE);
		}
	else
		KeReleaseSpinLockFromDpcLevel(&lock);
	}


void IRQMutex::EnterAtIRQLevel(void)
	{
	KeAcquireSpinLockAtDpcLevel(&lock);
	KeResetEvent(&event);
	block = FALSE;
	KeReleaseSpinLockFromDpcLevel(&lock);
	}


void IRQMutex::LeaveAtIRQLevel(void)
	{
	KeAcquireSpinLockAtDpcLevel(&lock);
	block = TRUE;
	KeSetEvent(&event, 0, FALSE);
	KeReleaseSpinLockFromDpcLevel(&lock);
	}


#else


VDMutex::VDMutex(LPCTSTR name)
	{
//	DP(__TEXT("*** Create: %lx, %lx"), ::GetCurrentProcessId(), ::GetCurrentThreadId());
	mutex = ::CreateMutex(NULL, FALSE, name);
//	DP(__TEXT("*** C-    : %lx, %lx"), ::GetCurrentProcessId(), ::GetCurrentThreadId());
	}

VDMutex::VDMutex(void)
	{
	VDMutex(NULL);
	}

VDMutex::~VDMutex(void)
	{
//	DP(__TEXT("*** Destroy: %lx, %lx"), ::GetCurrentProcessId(), ::GetCurrentThreadId());
	if (mutex)
		CloseHandle(mutex);
//	DP(__TEXT("*** D-     : %lx, %lx"), ::GetCurrentProcessId(), ::GetCurrentThreadId());
	}

void VDMutex::Enter(void)
	{
//	DP(__TEXT("*** Enter : %lx, %lx"), ::GetCurrentProcessId(), ::GetCurrentThreadId());
	::WaitForSingleObject(mutex, INFINITE);
//	DP(__TEXT("*** E-,   : %lx, %lx"), ::GetCurrentProcessId(), ::GetCurrentThreadId());
	}

void VDMutex::Leave(void)
	{
//	DP(__TEXT("*** Leave : %lx, %lx"), ::GetCurrentProcessId(), ::GetCurrentThreadId());
	::ReleaseMutex(mutex);
//	DP(__TEXT("*** L-    : %lx, %lx"), ::GetCurrentProcessId(), ::GetCurrentThreadId());
	}

VDSemaphore::VDSemaphore (void)
	{
	sema = ::CreateSemaphore(NULL, NULL, 1000000, NULL);
	}

VDSemaphore::~VDSemaphore (void)
	{
	if (sema)
		CloseHandle(sema);
	}

void VDSemaphore::Reset (void)
	{
	do {} while (::WaitForSingleObject(sema, 0) != WAIT_TIMEOUT);
	}

void VDSemaphore::Signal (void)
	{
	::ReleaseSemaphore(sema, 1, NULL);
	}

void VDSemaphore::Wait (void)
	{
	::WaitForSingleObject(sema, INFINITE);
	}

VDTimedSemaphore::VDTimedSemaphore(void)
	: VDSemaphore()
	{
	}

VDTimedSemaphore::~VDTimedSemaphore(void)
	{
	}

void VDTimedSemaphore::Reset (void)
	{
	do {} while (::WaitForSingleObject(sema, 0) != WAIT_TIMEOUT);
	}

void VDTimedSemaphore::Wait (void)
	{
	::WaitForSingleObject(sema, INFINITE);
	}

void VDTimedSemaphore::WaitTimeout (DWORD time, BOOL & timeout)
	{
	timeout = ::WaitForSingleObject(sema, time / 1000) == WAIT_TIMEOUT;
	}

#endif	// of NT_KERNEL





VDCriticalSection::VDCriticalSection(void)
	{
	scheduled = FALSE;
	cnt = 0;
#if NT_KERNEL
	KeInitializeMutex (&mutex, 0);
#endif
	}


void VDCriticalSection::EnterSection(void)
	{
#if NT_KERNEL
	KeWaitForSingleObject (&mutex, Executive, KernelMode, FALSE, NULL);
	cnt++;
//	DP("ES %x %d", KeGetCurrentThread(), cnt);
#else
	cnt++;
#endif
	}

void VDCriticalSection::LeaveSection(void)
	{
#if NT_KERNEL
	cnt--;
	if (!cnt)
		{
//		DP("LS1 %x %d", KeGetCurrentThread(), cnt);
		KeReleaseMutex (&mutex, FALSE);
		while (scheduled)
			{
//			DP("SCHED1");
			KeWaitForSingleObject (&mutex, Executive, KernelMode, FALSE, NULL);
			cnt++;
			if (scheduled)
				{
				scheduled = FALSE;
				CriticalSection ();
				}
			cnt--;
			KeReleaseMutex (&mutex, FALSE);
			}
		}
	else
		{
//		DP("LS2 %x %d", KeGetCurrentThread(), cnt);
		KeReleaseMutex (&mutex, FALSE);
		}
#else
	cnt--;
	if (!cnt)
		{
		while (scheduled)
			{
			cnt++;
			if (scheduled)
				{
				scheduled = FALSE;
				CriticalSection();
				}
			cnt--;
			}
		}
#endif
	}

void VDCriticalSection::ScheduleSection(void)
	{
#if NT_KERNEL
	LARGE_INTEGER timeout;
	timeout.QuadPart = 0;
	BOOL success;
	success = (STATUS_SUCCESS == KeWaitForSingleObject (&mutex, Executive, KernelMode, FALSE, &timeout));
	if (! success)
		{
//		DP("SS1 %x %d", KeGetCurrentThread(), cnt);
		scheduled = TRUE;
		}
	else
		{
//		DP("SS2 %x %d", KeGetCurrentThread(), cnt);
		if (!cnt)
			{
			scheduled = FALSE;
			CriticalSection ();
			}
		else
			scheduled = TRUE;

		KeReleaseMutex (&mutex, FALSE);
		}
#else
	if (cnt)
		scheduled = TRUE;
	else
		{
		scheduled = FALSE;
		CriticalSection();
		}
#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\common\KrnlStr.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\krnlstr.h
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:
//

#ifndef KRNLSTR
#define KRNLSTR

#include "library/common/prelude.h"
#include "library/common/gnerrors.h"

class KernelStringBuffer;

class __far KernelString
	{
	private:
		KernelStringBuffer	*	buffer;
	public:
		KernelString(void);
		KernelString(const TCHAR __far * str);
		KernelString(const TCHAR ch);
#if NT_KERNEL
		KernelString(const UNICODE_STRING & org);
#endif
		KernelString(const KernelString & str);
		KernelString(DWORD value, int digits = 0, int base = 10, TCHAR fill = __TEXT('0'));
		KernelString(int value, int digits = 0, int base = 10, TCHAR fill = __TEXT('0'));
		~KernelString();

		// returns the length of the string EXCLUDING the succeeding zero...
		int Length() const;

		long ToInt(int base = 10);
		DWORD ToUnsigned(int base = 10);


		BOOL Get(TCHAR __far * str, int len);
#if NT_KERNEL
		BOOL Get(UNICODE_STRING & us);
#endif

		KernelString & operator = (const TCHAR __far * str);
#if NT_KERNEL
		KernelString & operator = (const UNICODE_STRING & str);
#endif
		KernelString & operator = (const KernelString str);

		friend KernelString operator+ (const KernelString u, const KernelString v);
		KernelString & operator+= (const KernelString u);
		friend KernelString operator* (const KernelString u, const int num);
		KernelString & operator*= (const int num);

		int Compare(const KernelString str);

		friend BOOL operator==(const KernelString u, const KernelString v);
		friend BOOL operator!=(const KernelString u, const KernelString v);
		friend BOOL operator<(const KernelString u, const KernelString v);
		friend BOOL operator>(const KernelString u, const KernelString v);
		friend BOOL operator<=(const KernelString u, const KernelString v);
		friend BOOL operator>=(const KernelString u, const KernelString v);

		friend KernelString operator << (const KernelString u, int index);
		friend KernelString operator >> (const KernelString u, int index);
		KernelString & operator <<= (int index);
		KernelString & operator >>= (int index);

		KernelString Seg(int start, int num) const;	// Extract seqment of string
		KernelString Caps(void);
		KernelString Head(int num) const;				// Return the first num characters
		KernelString Tail(int num) const;				// Return the last num characters

		int First(KernelString str) const;				// Find first occurrence of str
		int Next(KernelString str, int pos) const;	// Find next occurrence of str
		int Last(KernelString str) const;				// Find last occurrence of str
		int Prev(KernelString str, int pos) const;	// Find previous occurrence of str

		int First(TCHAR c) const;							// Find first occurrence of c (-1 if not found)
		int Next(TCHAR c, int pos) const;				// Find next occurrence of c (-1 if not found)
		int Last(TCHAR c) const;							// Find last occurrence of c (-1 if not found)
		int Prev(TCHAR c, int pos) const;				// Find prevoius occurrence of c (-1 if not found)
		BOOL Contains(TCHAR c) const;						// Test if character occurs in string

		// deletes spaces (and tabs) at beginning or end of string...
		KernelString Trim();

		TCHAR& operator[] (const int index);
		const TCHAR& operator[] (const int index) const;

//
// Unsafe functions
//
#if NT_KERNEL
		operator UNICODE_STRING * (void);
		operator UNICODE_STRING & (void);
#else
		operator TCHAR * (void);
#endif
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\common\krnlsync.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\krnlsync.h
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:
//
#ifndef KRNLSYNC_H
#define KRNLSYNC_H

#include "prelude.h"





class IRQMutex
	{
	private:
#if NT_KERNEL
		KSPIN_LOCK	lock;
		KEVENT		event;
		BOOL			block;
		KIRQL			irql;
		BOOL			atIRQLevel;
#else
		volatile	BOOL	lock;
		BOOL				irq;
#endif
	public:
		IRQMutex(void);

		void Enter(void);
		void Leave(void);

		void EnterAtIRQLevel(void);
		void LeaveAtIRQLevel(void);
	};



class VDMutex
	{
	private:
#if   !NT_KERNEL && !VXD_VERSION
		int		count;
		int		requested;
		HANDLE	mutex;
#endif
	public:
		VDMutex(void);
		VDMutex(LPCTSTR name);
		~VDMutex(void);

		void Enter(void);
		void Leave(void);
	};

#if !NT_KERNEL && !VXD_VERSION
class VDLocalMutex
	{
	private:
		CRITICAL_SECTION	lock;
	public:
		VDLocalMutex(void) {InitializeCriticalSection(&lock);}
		~VDLocalMutex(void) {DeleteCriticalSection(&lock);}

		void Enter(void) {EnterCriticalSection(&lock);}
		void Leave(void) {LeaveCriticalSection(&lock);}
	};
#else
typedef VDMutex	VDLocalMutex;
#endif

class VDAutoMutex
	{
	protected:
		VDLocalMutex	*	mutex;
	public:
		VDAutoMutex(VDLocalMutex	*	mutex)
			{
			this->mutex = mutex;
			mutex->Enter();
			}

		~VDAutoMutex(void)
			{
			mutex->Leave();
			}
	};



class VDSemaphore
	{
	protected:
#if !NT_KERNEL && !VXD_VERSION
		HANDLE	sema;
#endif
	public:
		VDSemaphore (void);
		virtual ~VDSemaphore (void);

		virtual void Reset (void);
		virtual void Signal (void);
		virtual void Wait (void);
	};

class VDTimedSemaphore : public VDSemaphore
	{
	public:
		VDTimedSemaphore (void);
		virtual ~VDTimedSemaphore (void);

		virtual void Reset (void);
		virtual void Wait (void);

		void WaitTimeout (DWORD time, BOOL & timeout); // time in microsecs
	};



class VDCriticalSection
	{
	private:
		BOOL		scheduled;
		WORD		cnt;
#if NT_KERNEL
		KMUTEX	mutex;
#endif
	protected:
		virtual void CriticalSection(void) = 0;
	public:
		VDCriticalSection(void);

		void EnterSection(void);
		void LeaveSection(void);

		void ScheduleSection(void);
	};



#if !NT_KERNEL && !VXD_VERSION

extern VDMutex	VDWin16Mutex;

#endif



// This class provides multitasking- and multiprocessing-safe variables.

class InterlockedLong
	{
	private:
		LONG value;


	public:
		InterlockedLong (void)
			{
			value = 0;
			}

		InterlockedLong (LONG value)
			{
			this->value = value;
			}

		~InterlockedLong (void)
			{
			}

		void Increment (void)
			{
#if NT_KERNEL
			InterlockedIncrement (&value);
#else
			InterlockedIncrement (&value);
#endif
			}

		void Decrement (void)
			{
#if NT_KERNEL
			InterlockedDecrement (&value);
#else
			InterlockedDecrement (&value);
#endif
			}

		void SetValue (LONG newValue) {value = newValue;}

		LONG GetValue (void)
			{
			return value;
			}
	};



class VDIRQSafeSpinLock
	{
	private:
#if NT_KERNEL
		KIRQL			oldIRQLevel;
		LONG			lockVar;
#elif !VXD_VERSION
		int			count;
		BOOL			irqDisabled;
#endif
		BOOL			inIRQ;
	protected:
#if !NT_KERNEL && !VXD_VERSION
		void EnableLock(void);
		BOOL DisableLock(void);
#endif
	public:
		VDIRQSafeSpinLock(void);

		void EnterLock(void);
		void LeaveLock(void);

		void SetInIRQ(BOOL inIRQ) {this->inIRQ = inIRQ;}
		BOOL InIRQ(void) {return inIRQ;}
	};



inline VDIRQSafeSpinLock::VDIRQSafeSpinLock(void)
	{
#if NT_KERNEL
	lockVar = 0;
#elif !VXD_VERSION
	count = 0;
#endif
	}

inline void VDIRQSafeSpinLock::EnterLock()
	{
#if NT_KERNEL
	KIRQL oldIRQLLocal;

	// Multi-processor safe lock that can be executed at > DISPATCH_LEVEL

	KeRaiseIrql(HIGH_LEVEL, &oldIRQLLocal);				// prevents us from being interrupted by any IRQ
	do {;} while (InterlockedExchange(&lockVar, 1));

	oldIRQLevel = oldIRQLLocal;

#elif !VXD_VERSION
	if (!inIRQ)
		{
		count++;

		if (count == 1)
			irqDisabled = DisableLock();
		}
#endif
	}

inline void VDIRQSafeSpinLock::LeaveLock()
	{
#if NT_KERNEL
	KIRQL	oldIRQLLocal;

	oldIRQLLocal = oldIRQLevel;
	InterlockedExchange(&lockVar, 0);
	KeLowerIrql(oldIRQLLocal);
#elif !VXD_VERSION
	if (!inIRQ)
		{
		count--;

		if (count == 0)
			{
			if (irqDisabled)
				EnableLock();
			}
		}
#endif
	}




#if NT_KERNEL || VXD_VERSION || DRVDLL

class VDSpinLock
	{
	private:
#if NT_KERNEL
		KSPIN_LOCK	spinLock;
		KIRQL			oldIRQLevel;
#elif !VXD_VERSION
		int			count;
		BOOL			irqDisabled;
#endif
		BOOL			inIRQ;
	protected:
#if !NT_KERNEL && !VXD_VERSION
		void EnableLock(void);
		BOOL DisableLock(void);
#endif
	public:
		VDSpinLock(void);

		void EnterLock(void);
		void LeaveLock(void);

		void SetInIRQ(BOOL inIRQ) {this->inIRQ = inIRQ;}
		BOOL InIRQ(void) {return inIRQ;}
	};


inline VDSpinLock::VDSpinLock(void)
	{
#if NT_KERNEL
	KeInitializeSpinLock(&spinLock);
#elif !VXD_VERSION
	count = 0;
#endif
	}

inline void VDSpinLock::EnterLock()
	{
#if NT_KERNEL
	KeAcquireSpinLock(&spinLock, &oldIRQLevel);
#elif !VXD_VERSION
	if (!inIRQ)
		{
		count++;

		if (count == 1)
			irqDisabled = DisableLock();
		}
#endif
	}

inline void VDSpinLock::LeaveLock()
	{
#if NT_KERNEL
	KeReleaseSpinLock(&spinLock, oldIRQLevel);
#elif !VXD_VERSION
	if (!inIRQ)
		{
		count--;

		if (count == 0)
			{
			if (irqDisabled)
				EnableLock();
			}
		}
#endif
	}

#if !NT_KERNEL && !VXD_VERSION

inline BOOL VDSpinLock::DisableLock(void)
	{
	if (inIRQ)
		return FALSE;
	else
		{
		BOOL	result;
		_asm {pushf
			   pop   ax
			   and   ax, 0x0200
			   jz   	notSet
				mov	ax, TRUE
				cli
		notSet:
				mov	[result], ax
				}
		return result;
		}
	}

inline void VDSpinLock::EnableLock(void)
	{
	_asm sti;
	}

#endif

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\common\prelude.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\prelude.cpp
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   21.03.95
//
// PURPOSE:
//
// HISTORY:
//
//



#if   LINUX
////////////////////////////////////////////////////////////////////
//
//	LINUX
//
////////////////////////////////////////////////////////////////////


#define MUNGWALL	0

#include <stdlib.h>
#include <malloc.h>
#include "prelude.h"

#if MUNGWALL
#include "vddebug.h"
#include <debug.h>
DWORD	memAllocated = 0;
DWORD maxAllocated = 0;
DWORD numAllocated[1024];
DWORD newAllocated[1024];
#endif

void PrintFreeMemory (void);


void MUL32x32(DWORD op1, DWORD op2, DWORD & upper, DWORD & lower)
	{
	DWORD u, l;

	__asm__ (
		".intel_syntax \n"
		"movl		%%eax, %0 \n"
		"movl		%%edx, %1 \n"
		"mul		%%edx \n"
		".att_syntax \n"
		:"=r"(l), "=r"(u)
		:"0"(l), "1"(u)
// 	:"eax", "edx"
		);

	upper = u;
	lower = l;
	}

DWORD DIV64x32(DWORD upper, DWORD lower, DWORD op)
	{
	DWORD res;

	if(op)
		{
		__asm__ (
			".intel_syntax \n"
			"movl		%%edx, %0 \n"
			"movl		%%eax, %1 \n"
			"movl		%%ecx, %2 \n"
			"divl		%%ecx \n"
			".att_syntax \n"
			:"=r"(res)
			:"r"(lower), "r"(upper)
			);
		return res;
		}
	else
		return 0;
	}

#elif MACINTOSH
////////////////////////////////////////////////////////////////////
//
//	Apple Macintosh
//
////////////////////////////////////////////////////////////////////

#include "prelude.h"


#include <stdlib.h>


void *  operator new(size_t nSize)
	{
	return malloc(nSize);
	}

void *  operator new(size_t nSize, POOL_TYPE iType)
	{
	return malloc(nSize);
	}

void	operator delete(void* p)
	{
	free(p);
	}


void *  operator new[](size_t nSize)
	{
	return malloc(nSize);
	}

void *  operator new[](size_t nSize, POOL_TYPE iType)
	{
	return malloc(nSize);
	}

void	operator delete[](void* p)
	{
	free(p);
	}


#else
////////////////////////////////////////////////////////////////////
//
//	WIN32 || NT_KERNEL || VXD_VERSION
//
////////////////////////////////////////////////////////////////////

#include "prelude.h"

#if NT_KERNEL


#ifndef POOL_ALLOCATION_TAG
// Default tag: "VddV"
#define POOL_ALLOCATION_TAG 0x56646456
#endif

void * __cdecl operator new(size_t nSize, POOL_TYPE iType)
	{
	return ExAllocatePoolWithTag(iType, nSize, (DWORD) POOL_ALLOCATION_TAG);
	}

void * __cdecl operator new(size_t nSize)
	{
	return ExAllocatePoolWithTag(NonPagedPool, nSize, (DWORD) POOL_ALLOCATION_TAG);
	}

void __cdecl operator delete(void* p)
	{
	if (p) ExFreePool(p);
	}

#endif



#if VXD_VERSION

void * __cdecl operator new(unsigned int nSize, POOL_TYPE iType)
	{
	return _HeapAllocate(nSize, iType);
	}

void * __cdecl operator new(unsigned int nSize)
	{
	return _HeapAllocate(nSize, NonPagedPool);
	}

void __cdecl operator delete(void* p)
	{
	if (p) _HeapFree(p, 0);
	}


#endif

#if VXD_VERSION || WDM_VERSION

//
// This is normally in the run time libraries, so we define it here.
// It is there to detect calls of pure virtual functions.
//

int __cdecl _purecall(void)
	{
	// Insert your own error reporting code here
	return 0;
	}

#endif // VXD_VERSION



#if WDM_VERSION

void MUL32x32(DWORD op1, DWORD op2, DWORD __far & upper, DWORD __far & lower)
	{
	unsigned __int64 ui;

	ui = (unsigned __int64) op1 * (unsigned __int64) op2;

	lower = (DWORD) ui;
	upper = (DWORD) (ui >> 32);
	}

DWORD DIV64x32(DWORD upper, DWORD lower, DWORD op)
	{
	unsigned __int64 ui;

	ui = ((unsigned __int64) upper << 32) | lower;

	return (DWORD) (ui / op);
	}

DWORD ScaleDWord(DWORD op, DWORD from, DWORD to)
	{
	unsigned __int64 ui;

	if (to && op)
		{
		ui = (unsigned __int64) op * (unsigned __int64) to;

		return (DWORD) (ui / (unsigned __int64) from);
		}
	else
		return 0;
	}

long ScaleLong(long op, long from, long to)
	{
	__int64 i;

	if (to && op)
		{
		i = (__int64) op * (__int64) to;

		return (long) (i / (__int64) from);
		}
	else
		return 0;
	}

#else

void MUL32x32(DWORD op1, DWORD op2, DWORD __far & upper, DWORD __far & lower)
	{
	DWORD u, l;

	__asm {
			mov	eax, op1
			mov	edx, op2
			mul	edx
			mov	u, edx
			mov	l, eax
			}

	upper = u;
	lower = l;
	}

DWORD DIV64x32(DWORD upper, DWORD lower, DWORD op)
	{
	DWORD res;

	if (op)
		{
		__asm {
				mov	edx, upper
				mov	eax, lower
				mov	ecx, op
				div	ecx
				mov	res, eax
				};
		return res;
		}
	else
		return 0;
	}

DWORD ScaleDWord(DWORD op, DWORD from, DWORD to)
	{
	DWORD	res;

	if (to && op)
		{
		__asm {
				mov	eax, op
				mov	edx, to
				mul	edx
				mov	ecx, from
				cmp	edx, ecx
				jge	done
				div	ecx
				mov	res, eax
			done:
				};

		return res;
		}
	else
		return 0;
	}

long ScaleLong(long op, long from, long to)
	{
	long	res;

	if (to && op)
		{
		__asm {
				mov	eax, op
				mov	edx, to
				imul	edx
				mov	ecx, from
				cmp	edx, ecx
				jge	done
				idiv	ecx
				mov	res, eax
			done:
				};

		return res;
		}
	else
		return 0;
	}

#endif	// WDM_VERSION

#endif	// of !WIN32 && !NT_KERNEL && !VXD_VERSION
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\driver\softwarecinemaster\winsockperfmon\WinSockPerfMon.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef _WINSOCKPERFMON_H_
#define _WINSOCKPERFMON_H_

extern void WINAPI OpenWinSockServerPerformanceMonitor(void);
extern void WINAPI CloseWinSockServerPerformanceMonitor(void);

#endif _WINSOCKPERFMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\common\TagUnits.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\common\tagunits.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   24.03.95
//
// PURPOSE: The tag units.
//
// HISTORY:

#ifndef TAGUNITS_H
#define TAGUNITS_H

#include "Tags.h"

MKTAGUNIT(PIP_UNIT,            0)
MKTAGUNIT(VIDEO_ENCODER_UNIT,  1)
MKTAGUNIT(VIDEO_DECODER_UNIT,  2)
MKTAGUNIT(MPEG_DECODER_UNIT,   3)
MKTAGUNIT(TV_TUNER_UNIT,       4)
MKTAGUNIT(AUDIO_MIXER_UNIT,    5)
MKTAGUNIT(AUDIO_DECODER_UNIT,  6)
MKTAGUNIT(AUDIO_ENCODER_UNIT,  7)
MKTAGUNIT(JPEG_CODEC_UNIT,     8)
MKTAGUNIT(OSD_UNIT,				 9)
MKTAGUNIT(PANEL_UNIT,         10)
MKTAGUNIT(COMMUNICATION_UNIT, 11)
// DO NOT USE 12 or 13 due to contention with tag type
MKTAGUNIT(MPEG_ENCODER_UNIT,  14)

#define VIDEO_CHIP_UNIT			(VIDEO_ENCODER_UNIT | VIDEO_DECODER_UNIT)
#define AUDIO_STREAMDEV_UNIT	(AUDIO_ENCODER_UNIT | AUDIO_DECODER_UNIT)

#define NUM_UNITS		12

#ifndef ONLY_EXTERNAL_VISIBLE

// Only internally used tag units
MKITAGUNIT(AUDIO_DAC_UNIT,			1)
MKITAGUNIT(STEREO_DECODER_UNIT,	2)
MKITAGUNIT(VIDEO_DEVICE_UNIT,		3)
MKITAGUNIT(PLL_UNIT,				   4)


#endif // external visible

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\common\vddebug.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\vddebug.cpp
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:
//
#include <xtl.h>

#include "vddebug.h"

#if LINUX
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#endif



#if   LINUX

void DebugPrint(const TCHAR * szFormat, ...)
	{
	TCHAR buff[256];
	int fd;

  	sprintf(buff,szFormat,(&szFormat)[1], (&szFormat)[2], (&szFormat)[3], (&szFormat)[4]);
  	strcat(buff, "\n");
	/* FN: my hack to get debug output to something sort-of fast - the ttys */
	/* are rather low-overhead, me thinks.. */
	fd = open("/tmp/CINELOG", O_CREAT | O_RDWR | O_APPEND, S_IRWXU);
	write(fd, buff, strlen(buff));
	close(fd);
	}



#elif !VXD_VERSION

// Print debug string to DebugWin. Formatted output is possible.
void __cdecl DebugPrint(const TCHAR __far * szFormat, ...)
	{
	TCHAR buff[256];

  	wvsprintf(buff,szFormat,(char __far *)(&szFormat+1));
  	_fstrcat(buff, __TEXT("\r\n"));
  	::OutputDebugString(buff);
	}

void __cdecl MDebugPrint(const TCHAR * szFormat, ...)
	{
	TCHAR buff[256];

  	::wvsprintf(buff,szFormat,(char __far *)(&szFormat+1));
  	_fstrcat(buff, __TEXT("\r\n"));
  	::OutputDebugString(buff);
	}



#else

void _cdecl DebugPrint(char * szFormat, ...)
	{
	static char buff[256];

	_Sprintf(buff, szFormat, (&szFormat)[1], (&szFormat)[2], (&szFormat)[3], (&szFormat)[4] );
	Out_Debug_String(buff);
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\common\gnerrors.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\gnerrors.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   21.03.95
//
// PURPOSE:   Centralized error handling
//
// HISTORY:
//
//

#ifndef GNERRORS_H
#define GNERRORS_H

#if !VIDEO_MINIPORT_DRIVER
#include	"prelude.h"
#endif

typedef unsigned long Error;

//
// The last error, that was raised, is not only returned, but preserved in
// this variable.
//
//extern Error LastError;

//
// Error numbers are composed of four parts, an severity level, that
// tells how hard the error hit; a unit id, describing the unit that
// failed; an error type giving some general reasons and an unique
// id (unique for the module, not all error messages).
//
//                  SS-UUUUUUUU-TTTTTTTT-IIIIIIIIIIIIII
//


#define GNR_SEVERITY_BITS	(2)
#define GNR_SEVERITY_SHIFT	(30)
#define GNR_SEVERITY_MASK	(0xC0000000)

#define GNR_UNIT_BITS		(8)
#define GNR_UNIT_SHIFT		(22)
#define GNR_UNIT_MASK		(0x3FC00000)

#define GNR_TYPE_BITS		(8)
#define GNR_TYPE_SHIFT		(14)
#define GNR_TYPE_MASK	   (0x003FC000)

#define GNR_UNIQUE_BITS		(14)
#define GNR_UNIQUE_SHIFT	(0)
#define GNR_UNIQUE_MASK		(0x00003FFF)


//
// The severity level describes how hard this error affected the operation.
//
// As the severity level is the most significant part of an error message,
// it can be tested with a simple compare (not the Error is defined as
// unsigned, so no special sign effects can occur).
//
#define GNR_OK					(0x0L << GNR_SEVERITY_SHIFT)
	// everything did well; The neat side effect of defining the OK level as
	// 0, is that the check for an error can be done with a simple not
	// 0 compare like "if (error) { ... }".

#define GNR_WARNING			(0x1L << GNR_SEVERITY_SHIFT)
	// something not quite perfect happened, but the action was performed

#define GNR_ERROR				(0x2L << GNR_SEVERITY_SHIFT)
	// an error accured, that kept the routine from doing its job

#define GNR_DEADLY			(0x3L << GNR_SEVERITY_SHIFT)
	// something happened, that will keep the program from working correct,
	// it would be better to exit gracefully

//
// The error unit specifies the module where this error was defined
//
#define GNR_UNIT_COMMON		(0x0L << GNR_UNIT_SHIFT)
	// defined in gnerrors.H

#define GNR_UNIT_GENERAL	(0x1L << GNR_UNIT_SHIFT)
	// define in ..\general\*.h

#define GNR_UNIT_MEMMPDIO	(0x2L << GNR_UNIT_SHIFT)
	// define in memmpdio.h

#define GNR_UNIT_I2C			(0x3L << GNR_UNIT_SHIFT)
	// defined in viperi2c.h

#define GNR_UNIT_INTERRUPT	(0x4L << GNR_UNIT_SHIFT)
   // defined in intrctrl.h

#define GNR_UNIT_PARSER		(0x5L << GNR_UNIT_SHIFT)
	// defined in mpgparse.h

#define GNR_UNIT_PCI					(0x6L << GNR_UNIT_SHIFT)
	// define in pci.h

#define GNR_UNIT_DMA					(0x7L << GNR_UNIT_SHIFT)
	// define in dma*.h

#define GNR_UNIT_VDECODER			(0x8L << GNR_UNIT_SHIFT)
	// defined in viddec.h

#define GNR_UNIT_VENCODER			(0x9L << GNR_UNIT_SHIFT)
	// defined in videnc.h

#define GNR_UNIT_JPEG				(0xCL << GNR_UNIT_SHIFT)
	// defined in core.h

#define GNR_UNIT_MPEG				(0xDL << GNR_UNIT_SHIFT)
	// defined in library\hardware\mpeg2dec\mp2eldec.h

#define GNR_UNIT_TVTUNER			(0xEL << GNR_UNIT_SHIFT)
	// defined in tvtuner.h

#define GNR_UNIT_VESA20				(0xFL << GNR_UNIT_SHIFT)
	// defined in vesa20.h

#define GNR_UNIT_GFC					(0x10L << GNR_UNIT_SHIFT)
	// defined in gfxconfig.h

#define GNR_UNIT_PIP					(0x11L << GNR_UNIT_SHIFT)
	// defined in *pip*.h

#define GNR_UNIT_DMAMEM				(0x12L << GNR_UNIT_SHIFT)
	//	defined in ctdmamem.h

#define GNR_UNIT_CD					(0x13L << GNR_UNIT_SHIFT)
	// defined in cdifs.h

#define GNR_UNIT_PROFILES			(0x14L << GNR_UNIT_SHIFT)
	// defined in profiles.h

#define GNR_UNIT_AUDIO				(0x15L << GNR_UNIT_SHIFT)
	// defined in audio

#define GNR_UNIT_PCICONTROLLER	(0x16L << GNR_UNIT_SHIFT)

#define GNR_UNIT_AC3					(0x17L << GNR_UNIT_SHIFT)

#define GNR_UNIT_VTX					(0x18L << GNR_UNIT_SHIFT)
	// defined in vtxdll.h

#define GNR_UNIT_MPEG2				(0x19L << GNR_UNIT_SHIFT)

#define GNR_UNIT_MP2PARSER			(0x1AL << GNR_UNIT_SHIFT)

#define GNR_UNIT_VXD					(0x1BL << GNR_UNIT_SHIFT)
	// Error messages from PnP VxD interfaces

#define GNR_UNIT_DISK				(0x1CL << GNR_UNIT_SHIFT)
	// General disk errors (library\hardware\drives\generic\diskerrors.h)

#define GNR_UNIT_NAVIGATION		(0x1DL << GNR_UNIT_SHIFT)
	// Navigation errors (driver\dvdpldrv\win32\naverrors.h)

#define GNR_UNIT_DVD					(0x1EL << GNR_UNIT_SHIFT)
	// DVD specific errors (driver\dvdpldrv\win32\naverrors.h)

#define GNR_UNIT_VCD					(0x1FL << GNR_UNIT_SHIFT)
	// VCD specific errors (driver\dvdpldrv\win32\naverrors.h)

#define GNR_UNIT_CDA					(0x20L << GNR_UNIT_SHIFT)
	// CDA specific errors (driver\dvdpldrv\win32\naverrors.h)

#define GNR_UNIT_DECRYPTION		(0x21L << GNR_UNIT_SHIFT)
	// Decryption errors (library\hardware\mpeg2dec\generic\mp2dcryp.h)

#define GNR_UNIT_FILE				(0x22L << GNR_UNIT_SHIFT)
	// File errors (library\files\fileerrors.h)

#define GNR_UNIT_UNITS				(0x21L << GNR_UNIT_SHIFT)
	// in virtunit.h

#define GNR_UNIT_SUBPICTURE		(0x22L << GNR_UNIT_SHIFT)

#define GNR_UNIT_FRONTPANEL             (0x23L << GNR_UNIT_SHIFT)

//
// The error type gives a general hint, what caused the malfunction
//
#define GNR_TYPE_GENERAL			(0x00L << GNR_TYPE_SHIFT)
	// no special info

#define GNR_TYPE_FILEIO				(0x01L << GNR_TYPE_SHIFT)
	// some file specific error occured

#define GNR_TYPE_HARDWARE			(0x02L << GNR_TYPE_SHIFT)
	// it was a general hardware problem

#define GNR_TYPE_PARAMS				(0x03L << GNR_TYPE_SHIFT)
	// illegal parameters were used

#define GNR_TYPE_TIMEOUT			(0x04L << GNR_TYPE_SHIFT)
	// a timeout happened

#define GNR_TYPE_BUSY				(0x05L << GNR_TYPE_SHIFT)
	// the requested unit is currently busy

#define GNR_TYPE_NOACK				(0x06L << GNR_TYPE_SHIFT)
	// the requested unit did not respond

#define GNR_TYPE_INACTIVE			(0x07L << GNR_TYPE_SHIFT)
	// the requested unit is currently not active, or in an illegal
	// state for the type of the requested operation

#define GNR_TYPE_MEMORY				(0x08L << GNR_TYPE_SHIFT)
	// there was no sufficient free store left

#define GNR_TYPE_UNIMPLEMENTED 	(0x09L << GNR_TYPE_SHIFT)
	// the called function is not yet completely implemented

#define GNR_TYPE_FORMAT				(0x0aL << GNR_TYPE_SHIFT)
	// the examined object was in the wrong format

#define GNR_TYPE_OBJECT				(0x0bL << GNR_TYPE_SHIFT)

#define GNR_TYPE_BOUNDS				(0x0cL << GNR_TYPE_SHIFT)

#define GNR_TYPE_ILLEGALACCESS	(0x0dL << GNR_TYPE_SHIFT)

#define GNR_TYPE_REGION				(0x0eL << GNR_TYPE_SHIFT)

#define GNR_TYPE_PARENTAL			(0x0fL << GNR_TYPE_SHIFT)

#define GNR_TYPE_UOP					(0x10L << GNR_TYPE_SHIFT)

#define GNR_TYPE_OPERATION			(0x11L << GNR_TYPE_SHIFT)

#define GNR_TYPE_INTERNALSTATE	(0x12L << GNR_TYPE_SHIFT)

#define GNR_TYPE_COPYPROTECTION	(0x13L << GNR_TYPE_SHIFT)

//
// Macros to build and decompose error numbers
//
#define MKERR(level, unit, type, unique) ((Error)(GNR_##level | GNR_UNIT_##unit | GNR_TYPE_##type | unique))
	// build an error number from its parts

#define GNR_SEVERITY(err) (err & GNR_SEVERITY_MASK)
	// extracts the severity of the error number

#define GNR_UNIT(err) (err & GNR_UNIT_MASK)
	// extracts the unit of the error number

#define GNR_TYPE(err) (err & GNR_TYPE_MASK)
	// extracts the type of the error number

#define GNR_UNIQUE(err) (err & GNR_UNIQUE_MASK)
	// extracts the unique id of the error number

#ifndef IS_ERROR
	//
	// sidenote, the original definition of IS_ERROR in <winerror.h> is
	// #define IS_ERROR(Status) ((unsigned long)(Status) >> 31 == SEVERITY_ERROR)
	// this is functional identical to our definition, so no need to redefine it
	// here.  In any case a new define is added, which is to be used in all future
	// tests.
	//
#define IS_ERROR(err) ((err) >= GNR_ERROR)
#endif
#define IS_GNERROR(err) ((err) >= GNR_ERROR)

#define IS_WARNING(err) (GNR_SEVERITY(err) == GNR_WARNING)

//
// Some default error messages
//
#define GNR_FILE_NOT_FOUND			MKERR(ERROR, COMMON, FILEIO, 0x00)
	// general file not found error

#define GNR_FILE_IN_USE 			MKERR(ERROR, COMMON, FILEIO, 0x01)
	// the file is currently in use

#define GNR_FILE_WRONG_FORMAT 	MKERR(ERROR, COMMON, FILEIO, 0x02)
	// the file is in the wrong file format

#define GNR_END_OF_FILE 			MKERR(ERROR, COMMON, FILEIO, 0x03)
	// attempt to read behind the end of a file

#define GNR_NOT_ENOUGH_MEMORY 	MKERR(ERROR, COMMON, MEMORY, 0x04)
	// general not enough memory left

#define GNR_MEM_NOT_ALLOCATED 	MKERR(WARNING, COMMON, MEMORY, 0x05)
	// the memory that was requested to be freed was not allocated
	// before.

#define GNR_MEM_ALLOCATED_BEFORE MKERR(WARNING, COMMON, MEMORY, 0x06)
	// the memory was allocated before


#define GNR_UNIMPLEMENTED 			MKERR(ERROR, COMMON, UNIMPLEMENTED, 0x07)
	// the function is not yet implemented, and will never be


#define GNR_OBJECT_NOT_FOUND		MKERR(ERROR, COMMON, OBJECT, 0x08)
	// the requested object could not be found

#define GNR_OBJECT_EXISTS			MKERR(ERROR, COMMON, OBJECT, 0x09)
	// the object requested to be created does already exist

#define GNR_OBJECT_IN_USE			MKERR(ERROR, COMMON, OBJECT, 0x0a)
	// an operation that needs exclusive access to an object, found the object
	// already in use

#define GNR_OBJECT_FOUND			MKERR(ERROR, COMMON, OBJECT, 0x0b)
	// an object that was to be inserted in a data structure with unique objects
	// was already in there

#define GNR_RANGE_VIOLATION		MKERR(ERROR, COMMON, BOUNDS, 0x0c)
	// a given parameter was out of bounds


#define GNR_INVALID_CONFIGURE_STATE		MKERR(ERROR, COMMON, INACTIVE, 0x0d)
	// the unit was in an invalid state for configuration

#define GNR_OBJECT_FULL				MKERR(ERROR, COMMON, BOUNDS, 0x0e)

#define GNR_OBJECT_EMPTY			MKERR(ERROR, COMMON, BOUNDS, 0x0f)

#define GNR_OBJECT_NOT_ALLOCATED	MKERR(ERROR, COMMON, INACTIVE, 0x10)

#define GNR_OBJECT_READ_ONLY		MKERR(ERROR, COMMON, OBJECT, 0x11)

#define GNR_OBJECT_WRITE_ONLY		MKERR(ERROR, COMMON, OBJECT, 0x12)

#define GNR_OPERATION_PROHIBITED	MKERR(ERROR, COMMON, ILLEGALACCESS, 0x13)

#define GNR_OBJECT_INVALID			MKERR(ERROR, COMMON, OBJECT, 0x14)

#define GNR_INSUFFICIENT_RIGHTS	MKERR(ERROR, COMMON, ILLEGALACCESS, 0x15)

#define GNR_TIMEOUT					MKERR(ERROR, COMMON, NOACK, 0x16)

#define GNR_FILE_READ_ERROR		MKERR(ERROR, COMMON, FILEIO, 0x17)

#define GNR_FILE_WRITE_ERROR		MKERR(ERROR, COMMON, FILEIO, 0x18)

#define GNR_INVALID_PARAMETERS	MKERR(ERROR, COMMON, PARAMS, 0x19)

#define GNR_CONNECTION_LOST		MKERR(ERROR, COMMON, INACTIVE, 0x1a)

#define GNR_OPERATION_ABORTED		MKERR(ERROR, COMMON, TIMEOUT, 0x1b)

#define GNR_OPERATION_FAILED		MKERR(ERROR, COMMON, OPERATION, 0x1c )

//
// Error invocation macros, to be used to standardize erroneous returns
//
#define GNRAISE(e) return (e)
	// raise an error, store it into the global error variable, and
	// return with the error number.

#define GNRAISE_OK return GNR_OK
	// raise the OK error, all did well

//#define GNRAISE_AGAIN return LastError
	// raise the last error again

#define GNASSERT(cond, except) if (cond) GNRAISE(except); else	0
	// if the condition evaluates to true, the exception is raised

#define GNREASSERT(cond) if (1) {Error e; if (e = (cond)) GNRAISE(e);} else 0
	// if the condition evaluates to not OK, the error is raised again

#define GNREASSERTMAP(cond, ne) if (1) {Error e; if (e = (cond)) GNRAISE(ne);} else 0
	// if the condition evaluates to not OK, the error ne is returned

#ifndef ONLY_EXTERNAL_VISIBLE


#ifdef _WINDOWS

class NamedError {
	private:
		Error				error;
		NamedError	*	link;
		WORD				id;
		static	NamedError	*	root;
	friend void GetErrorText(HINSTANCE hinst, Error error, TCHAR __far * buffer, int bufferSize);
	public:
		NamedError(Error error, WORD id) {this->error = error; this->id = id; this->link = root; root = this;}
	};

#define NAME_ERROR(err, text)	static const NamedError GNRI_##err(GNR_##err, IDS_GNR_##err)

void GetErrorText(HINSTANCE hinst, Error error, TCHAR __far * buffer, int bufferSize);

#elif LINUX

class NamedError {
	private:
		Error				error;
		NamedError	*	link;
		const char 	*	name;
		static	NamedError	*	root;
	friend void GetErrorText(Error error, TCHAR __far * buffer, int bufferSize);
	public:
		NamedError(Error error, const char * name) {this->error = error; this->name = name; this->link = root; root = this;}
	};

#define NAME_ERROR(err, text)	static const NamedError GNRI_##err(GNR_##err, text)

void GetErrorText(Error error, TCHAR __far * buffer, int bufferSize);

#else

#if VXD_VERSION || WDM_VERSION

#define NAME_ERROR(err, text)
const char * GetErrorText(Error error);

#else
class NamedError {
	private:
		Error				error;
		NamedError	*	link;
		const char 	*	name;
		static	NamedError	*	root;
	friend const char * GetErrorText(Error error);
	public:
		NamedError(Error error, const char * name) {this->error = error; this->name = name; this->link = root; root = this;}
	};

#define NAME_ERROR(err, text)	static const NamedError GNRI_##err(GNR_##err, text)

const char * GetErrorText(Error error);
#endif	// of VXD_VERSION

#endif	// of _WINDOWS

#endif	// of ONLY_EXTERNAL_VISIBLE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\common\KrnlInt.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\krnlint.h
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:
//
#ifndef KRNLINT_H
#define KRNLINT_H

#include "prelude.h"
#include "KrnlStr.h"


//
// REMARK:
// This class is passed through DLLs.
// So please:
//        - insert member variables only at the end of the class declaration
//			 - do not append virutal methods
//
// occures in krnlint.h


// this defines a new data type as a class, the KernelInt64 type,
// a 64-Bit-Integer data type for all integer arithmetics
class __far KernelInt64
	{
	private:
      // upper 32 bit
		unsigned long lower;
      // lower 32 bit
		signed long upper;
	public:

      // empty constructor sets value to ZERO
		KernelInt64(void) {lower = 0; upper = 0;}

      // DWORD constructor, generates a 64-bit value from an 32 DWORD
      KernelInt64(DWORD val) {lower = val; upper = 0;}

      // long constructor (32 bit with sign)
		// upper 32 bit part carries sign
      KernelInt64(long val) {lower = val; upper = val < 0 ? -1 : 0;}

      // int constructor, same effect as for long value
      // i.e. upper 32 bit carry also sign
		KernelInt64(int val) {lower = val; upper = val < 0 ? -1 : 0;}
      // same for positive values, upper 32 bit are ZERO
		KernelInt64(unsigned int val) {lower = val; upper =  0;}
      // copy constructor
      // dublicates value
      KernelInt64(const KernelInt64 & val) {lower = val.lower; upper = val.upper;}

      // assignment operator
      KernelInt64 & operator= (const KernelInt64 val) {lower = val.lower; upper = val.upper; return *this;}

      // constructor:  a 64 bit value out of 2 32 bit int parts
		KernelInt64(unsigned long lower, int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(unsigned int lower, int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(int lower, unsigned int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(int lower, int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(int lower, long upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(unsigned int lower, unsigned int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(unsigned long lower, unsigned int upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(unsigned long lower, unsigned long upper) {this->lower = lower; this->upper = upper;}
		KernelInt64(unsigned long lower, signed long upper) {this->lower = lower; this->upper = upper;}

		KernelInt64(KernelString str, int base = 10);
		KernelString ToString(int digits = 0, int base = 10, TCHAR fill = __TEXT('0'));

      // convert 64bit value to 32 bit long/DWORD/Int value with saturation
      // i.e in case of an overflow a predefined value is retruned

		long ToLong(void)
			{
			if      (upper == 0x00000000 && !(lower & 0x80000000)) return lower;
			else if (upper == 0xffffffff &&  (lower & 0x80000000)) return lower;
			else if (upper < 0) return 0x8000000;
			else return 0x7fffffff;
			}

		DWORD ToDWORD(void)
			{
			if (upper < 0) return 0;
			else if (upper > 0) return 0xffffffff;
			else return lower;
			}

		int ToInt(void)
			{
			if (*this < -32768) return -32768;
			else if (*this > 32767) return 32767;
			else return (int)lower;
			}

#if NT_KERNEL
		LONGLONG ToLongLong(void)
			{
			LARGE_INTEGER li;

			li.LowPart = lower;
			li.HighPart = upper;

			return li.QuadPart;
			}
#endif

      // return upper or lower part of 64 bit values
		DWORD Lower(void) {return lower;}
		long Upper(void) {return upper;}

      // The logical-negation (logical-NOT) operator produces the value 0 if its operand
      // is true (nonzero) and the value 1 if its operand is false (0). The result has int type.
      // The operand must be an integral, floating, or pointer value.
		inline int operator! (void) const {return !lower && !upper;}

      // minus operator
		inline KernelInt64 operator- (void) const;

      // The one's complement operator, sometimes called the "bitwise complement" or "bitwise NOT"
      // operator, produces the bitwise one's complement of its operand. The operand must be of
      // integral type. This operator performs usual arithmetic conversions; the result has the
      // type of the operand after conversion.
		inline KernelInt64 operator~ (void) const {return KernelInt64(~lower, ~upper);}

      // FRIEND
      // The friend keyword allows a function or class to gain access to the private
      // and protected members of a class. In some circumstances, it is more convenient to grant
      // member-level access to functions that are not members of a class or to all functions in
      // a separate class. With the friend keyword, programmers can designate either the specific
      // functions or the classes whose functions can access not only public members but also protected
      // and private members


      // integer arithmetic operators for different input types/vaiations
		inline friend KernelInt64 operator+ (const KernelInt64 u, const KernelInt64 v);
		inline friend KernelInt64 operator- (const KernelInt64 u, const KernelInt64 v);
		inline friend KernelInt64 operator+ (const long u, const KernelInt64 v);
		inline friend KernelInt64 operator- (const long u, const KernelInt64 v);
		inline friend KernelInt64 operator+ (const KernelInt64 u, const long v);
		inline friend KernelInt64 operator- (const KernelInt64 u, const long v);
		friend KernelInt64 operator* (const KernelInt64 u, const KernelInt64 v);
		friend KernelInt64 operator/ (const KernelInt64 u, const KernelInt64 v);
		inline friend KernelInt64 operator% (const KernelInt64 u, const KernelInt64 v);

		inline KernelInt64 & operator+= (const KernelInt64 u);
		inline KernelInt64 & operator-= (const KernelInt64 u);
		inline KernelInt64 & operator+= (const long u);
		inline KernelInt64 & operator-= (const long u);
		inline KernelInt64 & operator*= (const KernelInt64 u);
		inline KernelInt64 & operator/= (const KernelInt64 u);
		inline KernelInt64 & operator%= (const KernelInt64 u);

		inline KernelInt64 & operator++ (void);
		inline KernelInt64 & operator-- (void);

      // shift operators
		inline friend KernelInt64 operator << (const KernelInt64 u, const int shl);
		inline friend KernelInt64 operator >> (const KernelInt64 u, const int shl);

		inline KernelInt64 & operator <<= (const int shl);
		inline KernelInt64 & operator >>= (const int shl);

		inline int Compare(const KernelInt64 u) const;

		friend BOOL operator==(const KernelInt64 u, const KernelInt64 v) {return u.Compare(v) == 0;}
		friend BOOL operator!=(const KernelInt64 u, const KernelInt64 v) {return u.Compare(v) != 0;}
		friend BOOL operator<(const KernelInt64 u, const KernelInt64 v)  {return u.Compare(v) < 0;}
		friend BOOL operator>(const KernelInt64 u, const KernelInt64 v)  {return u.Compare(v) > 0;}
		friend BOOL operator<=(const KernelInt64 u, const KernelInt64 v) {return u.Compare(v) <= 0;}
		friend BOOL operator>=(const KernelInt64 u, const KernelInt64 v) {return u.Compare(v) >= 0;}

		friend KernelInt64 operator& (const KernelInt64 u, const KernelInt64 v) {return KernelInt64(u.lower & v.lower, u.upper & v.upper);}
		friend KernelInt64 operator| (const KernelInt64 u, const KernelInt64 v) {return KernelInt64(u.lower | v.lower, u.upper | v.upper);}

		KernelInt64 & operator&= (const KernelInt64 u) {lower &= u.lower; upper &= u.upper; return *this;}
		KernelInt64 & operator|= (const KernelInt64 u) {lower |= u.lower; upper |= u.upper; return *this;}
	};

inline KernelInt64 & KernelInt64::operator+= (const KernelInt64 u)
	{
	lower += u.lower;
   // check and propagare overflow from lower part up to upper part
	if (lower < u.lower)
      // overflow
		upper += u.upper+1;
	else
      // no overflow
		upper += u.upper;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator-= (const KernelInt64 u)
	{
	unsigned long sum = lower - u.lower;

   // check and propagare overflow from lower part up to upper part
	if (sum > lower)
      // overflow...
		upper -= u.upper+1;
	else
      // none...
		upper -= u.upper;
	lower = sum;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator+= (const long u)
	{
   // check sign of u
	if (u < 0)
      // already use new defined -= operator (see above) and negation operator
      // to invert and subtract u from this (type KernelInt64)
		*this -= -u;
	else
		{
		lower += u;
      // check overflow and eventually propagate it to upper part
		if (lower < (DWORD)u)
         // yes, overflow
			upper += 1;
		}
	return *this;
	}

inline KernelInt64 & KernelInt64::operator++ (void)
	{
	lower ++;
	if (!lower)
      // pass on overflow upwards...
		upper ++;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator-- (void)
	{
   // check overflow
	if (!lower)
      // .. and paas on
		upper --;
	lower --;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator-= (const long u)
	{
	if (u < 0)
		*this += -u;
	else
		{
      // check and handle overflow
		unsigned long sum = lower - u;
		if (sum > lower)
         // propagate overflow
			upper -= 1;
		lower = sum;
		}
	return *this;
	}


// the following additions and subtractions is rearranged from the add/sub of two KernelInto64 objects
// with each having an upper and lower part to a separate addition of the lower part
// then passing the result to another add/sub  of the two added/subtracted lower parts with the
// added/subtracted upper parts


// add two KernelInt64 objects
inline KernelInt64 operator+ (const KernelInt64 u, const KernelInt64 v)
	{
   // add into temporary var
	unsigned long sum = u.lower + v.lower;
   // check overflow from lower to upper
	if (sum < u.lower)
      // overflow, so add one to pass this on
		return KernelInt64(sum, u.upper + v.upper + 1);
	else
      // no overflow
		return KernelInt64(sum, u.upper + v.upper);
	}

inline KernelInt64 operator- (const KernelInt64 u, const KernelInt64 v)
	{
	unsigned long sum = u.lower - v.lower;
	if (sum > u.lower)
      // overflow
		return KernelInt64(sum, u.upper - v.upper - 1);
	else
      // no overflow
		return KernelInt64(sum, u.upper - v.upper);
	}

inline KernelInt64 operator+ (const KernelInt64 u, const long v)
	{
	if (v < 0)
		return u - -v;
	else
		{
		unsigned long sum = u.lower + v;
		if (sum < u.lower)
			return KernelInt64(sum, u.upper + 1);
		else
			return KernelInt64(sum, u.upper);
		}
	}

inline KernelInt64 operator- (const KernelInt64 u, const long v)
	{
	if (v < 0)
		return u + -v;
	else
		{
		unsigned long sum = u.lower - v;
		if (sum > u.lower)
			return KernelInt64(sum, u.upper - 1);
		else
			return KernelInt64(sum, u.upper);
		}
	}


inline KernelInt64 operator+ (const long u, const KernelInt64 v)
	{
	if (u < 0)
		return v - -u;
	else
		{
		unsigned long sum = u + v.lower;
		if (sum < v.lower)
			return KernelInt64(sum, v.upper + 1);
		else
			return KernelInt64(sum, v.upper);
		}
	}

inline KernelInt64 operator- (const long u, const KernelInt64 v)
	{
   // use negation operation and addition opeartor to define minus operator
	return u + -v;
	}

inline KernelInt64 KernelInt64::operator- (void) const
	{
	if (lower == 0)
		return KernelInt64(0, -upper);
	else
		return KernelInt64((DWORD)-(long)lower, ~upper);
	}

inline int KernelInt64::Compare(const KernelInt64 u) const
	{
	if (upper < u.upper) return -1;
	else if (upper > u.upper) return 1;
	else if (lower < u.lower) return -1;
	else if (lower > u.lower) return 1;
	else return 0;
	}


// define shift operators

// left shift of KernelInt64 object for shl bits
inline KernelInt64 operator<< (const KernelInt64 u, const int shl)
	{
   // use definition of <<= operator to do this

   // first make a copy of u to do the shift with
	KernelInt64 v = u;
	v <<= shl;
	return v;
	}

// right shift of KernelInt64 object for shr bits
inline KernelInt64 operator>> (const KernelInt64 u, const int shr)
	{
   // use definition of >>= operator to do this

   // do shift with copy
	KernelInt64 v = u;
	v >>= shr;
	return v;
	}

inline KernelInt64 & KernelInt64::operator*= (const KernelInt64 u)
	{
   // use "normal" mult to do *=
	*this = *this * u;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator/= (const KernelInt64 u)
	{
   // use normal division to do /=
	*this = *this / u;
	return *this;
	}

inline KernelInt64 & KernelInt64::operator%= (const KernelInt64 u)
	{
   // use normal modulo op to do %=
	*this = *this % u;
	return *this;
	}

inline KernelInt64 operator % (const KernelInt64 u, const KernelInt64 v)
	{
   // normal modulo op is done with / and *
	return u - (u / v) * v;
	}

inline KernelInt64 & KernelInt64::operator<<= (const int shl)
	{
	int s = shl;

   // shift data shl times left by 1
	while (s > 0)
		{
      // upper part left 1 bit, lowest bit becomes always 0
		upper <<= 1;
      // check lower part before shift: if highest bit is set, carry this to upper part
      // i.e. set lowest bit of upper part
		if (lower & 0x80000000) upper |= 1;
		lower <<= 1;
		s--;
		}

	return *this;
	}

inline KernelInt64 & KernelInt64::operator>>= (const int shl)
	{
	int s = shl;

   // lower part right by 1, highest bit becomes always 0
	while (s > 0)
		{
		lower >>= 1;
      // check lowest bit of upper part, and take carry to highest bit of lower part
		if (upper & 0x00000001) lower |= 0x80000000;
		upper >>= 1;
		s--;
		}

	return *this;
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\common\prelude.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\prelude.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   21.03.95
//
// PURPOSE:   Central prelude for all modules, defining types and
//				  often used macros.
//
// HISTORY:
//
//


// ATTENTION: THE INCLUDE OF "RESOURCE.H" EXPERIMENTALY REMOVED : Uli (II)

#ifndef PRELUDE_H
#define PRELUDE_H



#if   LINUX
////////////////////////////////////////////////////////////////////
//
//	LINUX
//
////////////////////////////////////////////////////////////////////

// #define NULL	0

#define __far
#define __huge
#define __cdecl
#define __pascal
#define __export
#define __loadds
#define FAR
#define cdecl
#define WINAPI
#define DLLCALL

typedef unsigned int HANDLE;
typedef signed long LONG;

typedef unsigned long DWORD;
typedef unsigned short WORD;
typedef unsigned char BYTE;


#include <stdlib.h>
#include <malloc.h>
#include <string.h>

enum POOL_TYPE
	{
	NonPagedPool, PagedPool
	};

void * operator new (unsigned int nSize, POOL_TYPE iType);
void * operator new (unsigned int nSize);
void operator delete (void *p);

#define _fstrcpy	strcpy
#define _fstrcat	strcat
#define _fstrlen	strlen
#define _fstrcmp	strcmp
#define _fmemcpy  memcpy
#define _fmalloc	malloc
#define _ffree		free

/* just like below in the #ifdef MMXMEMORY section */
inline void * __cdecl operator new(unsigned int nSize)
	{
	int * p = (int *)malloc(nSize + 16);
	int t = (int)p & 15;
	p += (16 - t) >> 2;
	p[-1] = t;
	return (void *)p;
	}

inline void * __cdecl operator new(unsigned int nSize, POOL_TYPE iType)
	{
	int * p = (int *)malloc(nSize + 16);
	int t = (int)p & 15;
	p += (16 - t) >> 2;
	p[-1] = t;
	return (void *)p;
	}

inline void __cdecl operator delete(void* p, POOL_TYPE iType)
	{
	int * q;

	if (p)
		{
		q = (int *)p;
		int t;
		t = q[-1];
		q -= (16 - t) >> 2;
		free(q);
		}
	}

inline void __cdecl operator delete(void* p)
	{
	int * q;

	if (p)
		{
		q = (int *)p;
		int t;
		t = q[-1];
		q -= (16 - t) >> 2;
		free(q);
		}
	}

inline void __cdecl operator delete[](void* p)
	{
	int * q;

	if (p)
		{
		q = (int *)p;
		int t;
		t = q[-1];
		q -= (16 - t) >> 2;
		free(q);
		}
	}


#elif MACINTOSH
////////////////////////////////////////////////////////////////////
//
//	Apple Macintosh
//
////////////////////////////////////////////////////////////////////

//	You should manually define MACINTOSH and also one of:
//	TARGET_API_MAC_OS8 ||TARGET_API_MAC_OSX ||TARGET_API_MAC_CARBON
//	TARGET_CPU_PPC is default


//	undefine Windows-isms
#define __far
#define __huge
#define __cdecl
#define __pascal
#define __export
#define __loadds
#define WINAPI
#define DLLCALL


//	Memory management

typedef unsigned long	size_t;

enum POOL_TYPE
	{
	NonPagedPool, PagedPool
	};

void *  operator new(size_t nSize);
void *  operator new(size_t nSize, POOL_TYPE iType);
void	operator delete(void* p);

void *  operator new[](size_t nSize);
void *  operator new[](size_t nSize, POOL_TYPE iType);
void	operator delete[](void* p);

//	core MacOS includes
#include <ConditionalMacros.h>


#else
////////////////////////////////////////////////////////////////////
//
//	 Windows and XBox
//
////////////////////////////////////////////////////////////////////

//
// Disable warnings for "inline assembler", "lost debugging information"
// and "inline functions".
//
#pragma warning(disable : 4505)
#pragma warning(disable : 4704)
#pragma warning(disable : 4791)

#define DLLCALL

#if VXD_VERSION

// Take these as C includes as we are a .cpp file!
#define WANTVXDWRAPS
#define IS_32

#define NULL	0

extern "C"
	{
	#include <basedef.h>
	#include <vmm.h>
	#include <vmmreg.h>
	#include <vxdwraps.h>
	#include <debug.h>
	#include <vwin32.h>
	#include "library/support/w95vxds/vwinwrap.h"
	#include <winerror.h>
	}

extern int __cdecl _purecall(void);

#ifdef _DEBUG
#define HARDBREAK __asm int 1;
#else
#define HARDBREAK
#endif

#pragma VxD_LOCKED_CODE_SEG
#pragma VxD_LOCKED_DATA_SEG

#endif // VXD_VERSION



#if NT_KERNEL


#if WDM_VERSION

extern "C"
{
#include <wdm.h>
#include <windef.h>
}


#else


#ifndef CALLBACK
#define CALLBACK    __stdcall
#endif


extern "C"
{
#include <ntddk.h>
}

#endif // not WDM_VERSION branch

void * __cdecl operator new(size_t nSize, POOL_TYPE iType);
void * __cdecl operator new(size_t nSize);
void __cdecl operator delete(void *p);


#elif VXD_VERSION

enum POOL_TYPE
	{
	NonPagedPool = 0,
	PagedPool = HEAPSWAP
	};

void * __cdecl operator new(unsigned int nSize, POOL_TYPE iType);
void * __cdecl operator new(unsigned int nSize);
void __cdecl operator delete(void *p);


#else


#include <stdlib.h>
#include <malloc.h>

enum POOL_TYPE
	{
	PagedPool = 0,
	NonPagedPool = 1
	};


//void * __cdecl operator new(unsigned int nSize);
//void __cdecl operator delete(void *p);

#include <stdlib.h>
#include <malloc.h>

static inline void * __cdecl operator new(unsigned int nSize)
	{
	int * p = (int *)malloc(nSize + 16);
	int t = (int)p & 15;
	p += (16 - t) >> 2;
	p[-1] = t;
	return (void *)p;
	}

static inline void * __cdecl operator new[](unsigned int nSize)
	{
	int * p = (int *)malloc(nSize + 16);
	int t = (int)p & 15;
	p += (16 - t) >> 2;
	p[-1] = t;
	return (void *)p;
	}

static inline void * __cdecl operator new(unsigned int nSize, POOL_TYPE iType)
	{
	int * p = (int *)malloc(nSize + 16);
	int t = (int)p & 15;
	p += (16 - t) >> 2;
	p[-1] = t;
	return (void *)p;
	}

static inline void * __cdecl operator new[](unsigned int nSize, POOL_TYPE iType)
	{
	int * p = (int *)malloc(nSize + 16);
	int t = (int)p & 15;
	p += (16 - t) >> 2;
	p[-1] = t;
	return (void *)p;
	}

static inline void __cdecl operator delete(void* p, POOL_TYPE iType)
	{
	int * q;

	if (p)
		{
		q = (int *)p;
		int t;
		t = q[-1];
		q -= (16 - t) >> 2;
		free(q);
		}
	}

static inline void __cdecl operator delete(void* p)
	{
	int * q;

	if (p)
		{
		q = (int *)p;
		int t;
		t = q[-1];
		q -= (16 - t) >> 2;
		free(q);
		}
	}

static inline void __cdecl operator delete[](void* p)
	{
	int * q;

	if (p)
		{
		q = (int *)p;
		int t;
		t = q[-1];
		q -= (16 - t) >> 2;
		free(q);
		}
	}


#endif // not NT_KERNEL and not VXD_VERSION branch



#endif // not ST20LITE branch


////////////////////////////////////////////////////////////////////
//
//	SECOND PART: Common definitions
//
////////////////////////////////////////////////////////////////////



#include <xtl.h>
#include <winnt.h>
#define ASSERT(x)

#define __far
#define __huge
#define __loadds

#define _fmemcpy	memcpy
#if UNICODE
#define _fstrcpy	wcscpy
#define _fstrcat	wcscat
#define _fstrlen  wcslen
#define _fstrcmp	wcscmp
#else
#define _fstrcpy	strcpy
#define _fstrcat	strcat
#define _fstrlen	strlen
#define _fstrcmp	strcmp
#endif
#define _fmalloc	malloc
#define _ffree		free
#define _halloc(x,y)	new BYTE[x*y]
#define _hfree(x) delete[] x

typedef int			BOOL;
typedef char	 * LPSTR;

typedef unsigned char		BYTE;
typedef unsigned short		WORD;
typedef unsigned long		DWORD;

#ifndef VXD_VERSION
typedef unsigned __int64	QWORD;
#endif

typedef unsigned int		UINT;
typedef signed long		LONG;


#ifndef LOBYTE
#define LOBYTE(w)	    	((BYTE)(w))
#endif

#ifndef HIBYTE
#define HIBYTE(w)     	((BYTE)(((UINT)(w) >> 8) & 0xFF))
#endif

#ifndef LOWORD
#define LOWORD(l)     	((WORD)(DWORD)(l))
#endif

#ifndef HIWORD
#define HIWORD(l)     	((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))
#endif

#ifndef MAKELONG
#define MAKELONG(low, high) ((DWORD)(WORD)(low) | ((DWORD)(WORD)(high) << 16))
#endif

#ifndef max
#define max(a,b)        (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)        (((a) < (b)) ? (a) : (b))
#endif

#if (NT_KERNEL || VXD_VERSION) && !WDM_VERSION
struct RECT
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
};
#endif





#if VXD_VERSION

#define TCHAR	char
#define __TEXT(x)	x

#endif



//
// Some extended definitions for word/dword arithmetic
//
#ifndef MAKEWORD
#define MAKEWORD(low, high) ((WORD)(BYTE)(low) | ((WORD)(BYTE)(high) << 8))
#endif

#define MAKELONG4(low, lmid, hmid, high) ((DWORD)(BYTE)(low) | ((DWORD)(BYTE)(lmid) << 8) | ((DWORD)(BYTE)(hmid) << 16) | ((DWORD)(BYTE)(high) << 24))
#define LBYTE0(w) ((BYTE)((w) & 0xff))
#define LBYTE1(w) ((BYTE)(((DWORD)(w) >> 8) & 0xff))
#define LBYTE2(w) ((BYTE)(((DWORD)(w) >> 16) & 0xff))
#define LBYTE3(w) ((BYTE)(((DWORD)(w) >> 24) & 0xff))

inline DWORD FLIPENDIAN(DWORD x)
	{
	return MAKELONG4(LBYTE3(x), LBYTE2(x), LBYTE1(x), LBYTE0(x));
	}

//
// Some standard pointer types
//

typedef void 		 	*	APTR;			// local pointer
typedef void __far	*	FPTR;			// far pointer
typedef void __huge	*	HPTR;			//	huge pointer
typedef BYTE __huge 	*	HBPTR;		// huge byte pointer



//
// We need a memory copy for huge memory; will use the windows version
// when available.
//

#if NT_KERNEL

#define _hmemcpy RtlMoveMemory

#else

#if _WINDOWS

#define _hmemcpy memcpy

#else


inline void _hmemcpy(HPTR dst, HPTR src, DWORD size)
	{
	DWORD i, quad, rest;
	quad = size / 4;
	rest = size % 4;

	for(i=0;i<quad;i++) *((DWORD __huge * &)dst)++ = *((DWORD __huge * &)src)++;
	for(i=0;i<rest;i++) *((BYTE __huge * &)dst)++ = *((BYTE __huge * &)src)++;
	}


#endif // not _WINDOWS branch

#endif // not NT_KERNEL branch



//
// Some more stuff
//
typedef BOOL				BIT;

#define HIGH				TRUE
#define LOW					FALSE

#if !NT_KERNEL && !VXD_VERSION
#ifndef FP_OFF
#define FP_OFF(x)			LOWORD(x)
#define FP_SEG(x)			HIWORD(x)
#endif
#endif



//
// Flag construction macro
//
#define MKFLAG(x)		(1UL << (x))

//
// DWORD Bitfield construction and extraction functions
//
inline DWORD MKBF(int bit, int num, DWORD val) {return (((DWORD)val & ((1UL << num) -1)) << bit);}
inline DWORD MKBF(int bit, BOOL val) {return (val ? (1UL << bit) : 0);}
inline DWORD XTBF(int bit, int num, DWORD bf) {return ((bf >> bit) & ((1UL << num) -1));}
inline BOOL XTBF(int bit, DWORD bf) {return ((bf & (1UL << bit)) != 0);}
inline DWORD WRBF(DWORD bf, int bit, int num, DWORD val)
	{
	DWORD mask = ((1UL << num)-1) << bit;
	return (bf & ~mask) | ((val << bit) & mask);
	}
inline DWORD WRBF(DWORD bf, int bit, BOOL val) {return (val ? (bf | (1UL << bit)) : (bf & ~(1UL << bit)));}

//
// WORD Bitfield construction and extraction functions
//
inline WORD MKBFW(int bit, int num, WORD val) {return (((WORD)val & ((1 << num) -1)) << bit);}
inline WORD MKBFW(int bit, BOOL val) {return (val ? (1 << bit) : 0);}
inline WORD XTBFW(int bit, int num, WORD bf) {return ((bf >> bit) & ((1 << num) -1));}
inline BOOL XTBFW(int bit, WORD bf) {return ((bf & (1 << bit)) != 0);}
inline WORD WRBFW(WORD bf, int bit, int num, WORD val)
	{
	WORD mask = ((1 << num)-1) << bit;
	return (bf & ~mask) | ((val << bit) & mask);
	}
inline WORD WRBFW(WORD bf, int bit, BOOL val) {return (val ? (bf | (1 << bit)) : (bf & ~(1 << bit)));}

//
// BYTE Bitfield construction and extraction functions
//
inline BYTE MKBFB(int bit, int num, BYTE val) {return (((BYTE)val & ((1 << num) -1)) << bit);}
inline BYTE MKBFB(int bit, BOOL val) {return (val ? (1 << bit) : 0);}
inline BYTE XTBFB(int bit, int num, BYTE bf) {return ((bf >> bit) & ((1 << num) -1));}
inline BOOL XTBFB(int bit, BYTE bf) {return ((bf & (1 << bit)) != 0);}
inline BYTE WRBFB(BYTE bf, int bit, int num, BYTE val)
	{
	BYTE mask = ((1 << num)-1) << bit;
	return (bf & ~mask) | ((val << bit) & mask);
	}
inline BYTE WRBFB(BYTE bf, int bit, BOOL val) {return (val ? (bf | (1 << bit)) : (bf & ~(1 << bit)));}

//
// Find the most significate one bit or the least significant one bit in a double word
//
inline int FindMSB(DWORD bf) {int i; for(i=31; i>=0; i--) {if (XTBF(31, bf)) return i; bf <<= 1;} return -1;}
inline int FindLSB(DWORD bf) {int i; for(i=0; i<=31; i++) {if (XTBF( 0, bf)) return i; bf >>= 1;} return 32;}



//
// Scaling of values of WORD range to values of WORD range
//
inline WORD ScaleWord(WORD op, WORD from, WORD to) {return (WORD)((DWORD)op * (DWORD) to / (DWORD) from);}
	DWORD ScaleDWord(DWORD op, DWORD from, DWORD to);
	long ScaleLong(long op, long from, long to);
	void MUL32x32(DWORD op1, DWORD op2, DWORD __far & upper, DWORD __far & lower);
	DWORD DIV64x32(DWORD upper, DWORD lower, DWORD op);
//
// Most values in drivers etc. are scaled in a range from 0 to 10000, this functions transfer from and
// to this range
//
inline WORD ScaleFrom10k(WORD op, WORD to) {return ScaleWord(op, 10000, to);}
inline BYTE ScaleByteFrom10k(WORD op, BYTE to) {return (BYTE)ScaleWord(op, 10000, to);}
inline WORD ScaleTo10k(WORD op, WORD from) {return ScaleWord(op, from, 10000);}



#ifndef ONLY_EXTERNAL_VISIBLE

#define FAND(x, y) ScaleWord(x, 10000, y)
#define FAND3(x, y, z) FAND(FAND(x, y), z)

//
// Fix a value inside a boundary
//
inline DWORD BoundTo(DWORD op, DWORD lower, DWORD upper) {if (op<lower) return lower; else if (op>upper) return upper; else return op;}

#if !NT_KERNEL && !VXD_VERSION
//
// Alloc Dos (real) and Windows (protected) memory
//
void AllocDouble(FPTR __far &rmode, FPTR __far &pmode, DWORD size);

//
// Free this memory
//
void FreeDouble(FPTR rmode, FPTR pmode);
#endif

#endif // ONLY_EXTERNAL_VISIBLE



#endif // PRELUDE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\common\vddebug.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\vddebug.h
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:
//
#ifndef _VDDEBUG_
#define _VDDEBUG_

#include "library/common/gnerrors.h"


#if LINUX
#include <stdio.h>
#include "library/common/prelude.h"
#define _export    /* FN: should be corrected in prelude.h.. */
#endif

void __cdecl MDebugPrint(const TCHAR * szFormat, ...);
#define RDP MDebugPrint

#if _DEBUG
	#ifdef _PROPTEST
		extern Error Print(const TCHAR __far * szFormat, ...);
		#define DP Print
	#elif NT_KERNEL
		#define DP DbgPrint("\n"), DbgPrint
	#elif VXD_VERSION
		void _cdecl DebugPrint(char * szFormat, ...);
		#define DP DebugPrint
	#elif LINUX
		void DebugPrint (const TCHAR * szFormat, ...);	// standard prototype for debug output
		#define DP DebugPrint
		#define DPF printf
		void DebugPrintRecord (const TCHAR * szFormat, ...);	// standard prototype for debug output
		#define DPR DebugPrintRecord
		void InitializeDebugRecording (void);
		void GetDebugRecordingParameters (BYTE * & array, int & size);
	#elif _DOS
		#define DP printf   // note: output should really go to stderr instead of stdout
#else
		void FAR __cdecl DebugPrint(const TCHAR __far * szFormat, ...);	// standard prototype for debug output
		#define DP DebugPrint
		#define DPF DebugPrint
	#endif
#else
	#ifdef _PROPTEST
		extern Error Print(const TCHAR __far * szFormat, ...);
		#define DP Print
	#elif NT_KERNEL
		inline void __cdecl DebugPrintEmpty(const char __far * szFormat, ...) {}		// empty function (optimized to nothing)
		#define DP while(0) DebugPrintEmpty
	#elif LINUX
		inline void DebugPrintEmpty(const TCHAR * szFormat, ...) {}		// empty function (optimized to nothing)
		#define DP while(0) DebugPrintEmpty
		#define DPF while(0) DebugPrintEmpty
		#define DPR while(0) DebugPrintEmpty
		inline void InitializeDebugRecording (void) {}
		inline void GetDebugRecordingParameters (BYTE * & array, int & size) {array=NULL; size=0;}
#else
		inline void __cdecl DebugPrintEmpty(const TCHAR __far * szFormat, ...) {}		// empty function (optimized to nothing)
		#define DP while(0) DebugPrintEmpty
		#define DPF DP
	#endif
#endif

//
//  Define breakpoint
//

#ifdef _DEBUG

#if NT_KERNEL
#define BREAKPOINT		DbgBreakPoint();
#else
#define BREAKPOINT		__asm int 3
#endif

#else

#define BREAKPOINT		while (0)

#endif // _DEBUG


#if !UPDATE_UTILITY_BUILD
#define DEBUG__(x)		x
#else
#define DEBUG__(x)
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\common\Profiles.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\profiles.cpp
// AUTHOR:    S. Herr
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   28.11.95
//
// PURPOSE:   Classes for configuration (INI) files.
//
// HISTORY:
//
// Date			Author	Comment
// --------		------	-------

#include "library/common/profiles.h"
#include "library/lowlevel/timer.h"
#include "library/common/vddebug.h"

///////////////////////////////////////////////////////////////////////////////
// Generic Profile Implementation
///////////////////////////////////////////////////////////////////////////////

Error GenericProfile::Write(KernelString section, KernelString entry, int value)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->WriteDirect(entry, value);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}

Error GenericProfile::Read(KernelString section, KernelString entry, int __far & value, int deflt)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->ReadDirect(entry, value, deflt);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}

Error GenericProfile::Write(KernelString section, KernelString entry, bool value)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->WriteDirect(entry, value);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}

Error GenericProfile::Read(KernelString section, KernelString entry, bool __far & value, bool deflt)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->ReadDirect(entry, value, deflt);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}


Error GenericProfile::Read(KernelString section, KernelString entry, long __far & value, long deflt)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->ReadDirect(entry, value, deflt);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}

Error GenericProfile::Write(KernelString section, KernelString entry, DWORD value, int base)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->WriteDirect(entry, value, base);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}


Error GenericProfile::Read(KernelString section, KernelString entry, DWORD __far & value, int base, DWORD deflt)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->ReadDirect(entry, value, base, deflt);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}

Error GenericProfile::Write(KernelString section, KernelString entry, WORD value, int base)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->WriteDirect(entry, value, base);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}


Error GenericProfile::Read(KernelString section, KernelString entry, WORD __far & value, int base, WORD deflt)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->ReadDirect(entry, value, base, deflt);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}

Error GenericProfile::Write(KernelString section, KernelString entry, KernelString value)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->WriteDirect(entry, value);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}


Error GenericProfile::Read(KernelString section, KernelString entry, KernelString & value, KernelString deflt)
	{
	Error err;

	GenericProfile * child = CreateSection(section);
	if (child)
		{
		err = child->ReadDirect(entry, value, deflt);
		delete child;
		}
	else
		err = GNR_PROFILE_NO_LEVEL;

	GNRAISE(err);
	}



///////////////////////////////////////////////////////////////////////////////
// Static Profile Implementation
///////////////////////////////////////////////////////////////////////////////


static DWORD CalculateID(BOOL section, KernelString name, int start, int range)
	{
	DWORD temp = 0;

	if (name.Length() > 0)
		{
		for (int i = start; i < start + range; i++)
			{
			temp ^= name[i];
			temp = (temp << 3) | (temp >> 29);	// The first 10 characters count
			}

		return (section ? (temp |= 1) : (temp &= ~1));
		}
	else
		return 0;
	}

static ProfileEntry * WalkSetupInfo(ProfileEntry * entries, int start, DWORD id)
	{
	DWORD i = start + 1;
	DWORD range = entries->value;

	while (i < range)
		{
		if (entries[i].id == id)
			return entries + i;
		else if (entries[i].id & 1)
			i += entries[i].value;
		else
			i++;
		}

	return NULL;
	}

Error StaticProfile::FindValue(KernelString entryName, ProfileEntry * __far & entry)
	{
	DWORD id;

	if (entries && (id = CalculateID(FALSE, entryName, 0, entryName.Length())))
		{
		entry = WalkSetupInfo(entries, 0, id);

		if (entry)
			GNRAISE_OK;
		}

	entry = NULL;
	GNRAISE(GNR_OBJECT_NOT_FOUND);
	}

Error StaticProfile::FindSection(KernelString section, ProfileEntry * __far & entry)
	{
	int start, range;
	DWORD	id;

	ProfileEntry * entryPtr = this->entries;	// Initialize with root

	start = 0;

	while (entryPtr && start < section.Length())
		{
		range = section.Next(__TEXT("\\"), start - 1) - start;	// Next increments its argument!

		id = CalculateID(TRUE, section, start, range);
		entryPtr = WalkSetupInfo(entryPtr, 0, id);	// entryPtr->value - 1: section header is counted for

		start = start + range + 1;	// Skip "\"
		}

	if (entryPtr)
		{
		entry = entryPtr;
		GNRAISE_OK;
		}
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);

	GNRAISE_OK;
	}

StaticProfile::StaticProfile(ProfileEntry * entries)
	{
	this->protect = FALSE;
	this->entries = entries;
	}

StaticProfile::StaticProfile(const ProfileEntry * entries)
	{
	this->protect = TRUE;
	this->entries = (ProfileEntry *) entries;
	}


StaticProfile::StaticProfile(ProfileEntry * entries, KernelString section)
	{
	ProfileEntry * sectionEntry;

	this->protect = TRUE;

	this->entries = entries;

	// Find section
	if (!IS_ERROR(FindSection(section, sectionEntry)))
		{
		// Now the search will become faster by adapting the offset into the array
		this->entries = sectionEntry;
		}
	}

StaticProfile::StaticProfile(StaticProfile * parent, KernelString section)
	{
	ProfileEntry * sectionEntry;

	this->protect = TRUE;

	if (!IS_ERROR(parent->FindSection(section, sectionEntry)))
		this->entries = sectionEntry;
	else
		this->entries = NULL;
	}

GenericProfile * StaticProfile::CreateSection(KernelString section)
	{
	StaticProfile *profile = new StaticProfile(this, section);
	profile->protect = this->protect;   // clone protection setting
	return profile;
	}

BOOL StaticProfile::IsValid(void)
	{
	return TRUE;
	}

Error StaticProfile::CalculateByteSize (int & size)
	{
	// The top section has the number of ProfileEntry entries.
	size = entries->value * sizeof(ProfileEntry);
	GNRAISE_OK;
	}

Error StaticProfile::WriteDW(KernelString entry, DWORD value)
	{
	ProfileEntry * valEntry;

	if (protect)
		GNRAISE(GNR_OBJECT_READ_ONLY);
	else
		{
		if (!IS_ERROR(FindValue(entry, valEntry)))
			valEntry->value = value;
		else
			GNRAISE(GNR_OBJECT_NOT_FOUND);
		}

	GNRAISE_OK;
	}

Error StaticProfile::ReadDW(KernelString entry, DWORD __far & value)
	{
	ProfileEntry * valEntry;

	if (!IS_ERROR(FindValue(entry, valEntry)))
		value = valEntry->value;
	else
		GNRAISE(GNR_OBJECT_NOT_FOUND);

	GNRAISE_OK;
	}

Error StaticProfile::WriteDirect(KernelString entry, int value)
	{
	GNRAISE(WriteDW(entry, (DWORD) value));	// Type size platform specific...
	}

Error StaticProfile::WriteDirect(KernelString entry, long value)
	{
	GNRAISE(WriteDW(entry, (DWORD) value));
	}

Error StaticProfile::WriteDirect(KernelString entry, WORD value, int base)
	{
	GNRAISE(WriteDW(entry, ((DWORD) value) & 0xffff0000));
	}

Error StaticProfile::WriteDirect(KernelString entry, DWORD value, int base)
	{
	GNRAISE(WriteDW(entry, value));
	}

Error StaticProfile::ReadDirect(KernelString entry, int __far & value, int deflt)
	{
	DWORD dw;
	Error error;

	if (!IS_ERROR(error = ReadDW(entry, dw)))
		value = (int) dw;
	else
		value = deflt;

	GNRAISE(error);
	}

Error StaticProfile::ReadDirect(KernelString entry, long __far & value, long deflt)
	{
	DWORD dw;
	Error error;

	if (!IS_ERROR(error = ReadDW(entry, dw)))
		value = (long) dw;
	else
		value = deflt;

	GNRAISE(error);
	}

Error StaticProfile::ReadDirect(KernelString entry, WORD __far & value, int base, WORD deflt)
	{
	DWORD dw;
	Error error;

	if (!IS_ERROR(error = ReadDW(entry, dw)))
		value = (WORD) dw;
	else
		value = deflt;

	GNRAISE(error);
	}

Error StaticProfile::ReadDirect(KernelString entry, DWORD __far & value, int base, DWORD deflt)
	{
	DWORD dw;
	Error error;

	if (!IS_ERROR(error = ReadDW(entry, dw)))
		value = (int) dw;
	else
		value = deflt;

	GNRAISE(error);
	}

Error StaticProfile::WriteDirect(KernelString entry, KernelString value)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

Error StaticProfile::ReadDirect(KernelString entry, KernelString & value, KernelString deflt)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}


Error StaticProfile::WriteDirect(KernelString entry, bool value)
	{
	GNRAISE(WriteDW(entry, value ? 1 : 0));
	}

Error StaticProfile::ReadDirect(KernelString entry, bool __far & value, bool deflt)
	{
	DWORD dw;
	Error error;

	if (!IS_ERROR(error = ReadDW(entry, dw)))
		value = (bool) (dw != 0);
	else
		value = deflt;

	GNRAISE(error);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\common\WinPorts.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\winports.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   22.03.95
//
// PURPOSE:   Class for windows as ports.
//
// HISTORY:
//

#ifndef WINPORTS_H
#define WINPORTS_H

#include "library\common\prelude.h"

////////////////////////////////////////////////////////////////////
//
//  Some defines
//
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
//
//  Generic Message Port Class
//
////////////////////////////////////////////////////////////////////

class GenericMsgPort
	{
	public:
		// Send a message to the port and return immediately. The result is TRUE for success.
		virtual BOOL SendMessage (WPARAM wParam, LPARAM lParam) = 0;
		virtual BOOL SendMessageIfQueueEmpty (WPARAM wParam, LPARAM lParam) = 0;

		// Send a message to the port and wait until it has been processed.
		virtual void DoMessage (WPARAM wParam, LPARAM dParam) = 0;

		// Schedule a message to be posted after some delay. The call returns immediately.
		// Note that you cannot call this during interrupt.
		virtual void ScheduleTimer (WPARAM wParam, DWORD millisecondDelay) = 0;

		// Cancel any delayed message.
		virtual void CancelTimer (void) = 0;

		// Remove all messages from the queue.
		virtual void FlushMessages (void) = 0;
	};

#ifndef ONLY_EXTERNAL_VISIBLE

#include "library\common\krnlsync.h"

////////////////////////////////////////////////////////////////////
//
//  ST20 WinPort Classes
//
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
//
//  Windows WinPorts
//
////////////////////////////////////////////////////////////////////



//
//  WinPortServer
//

class EventPortMessage;
class EventPort;

class WinPortServer
	{
	friend class EventPort;
	friend class EventPortWorkerThread;
	protected:
		EventPortMessage	*	messages;
		EventPortMessage	*	timeMessages;
		HANDLE					event;
		VDLocalMutex			lock;
		bool						terminate;

		void EnterQueueHead(EventPortMessage * & queue, EventPortMessage * message);
		void EnterQueueTime(EventPortMessage * & queue, EventPortMessage * message);
		EventPortMessage * GetQueuePort(EventPortMessage * & queue, EventPort * port);
		EventPortMessage * PeekQueueHead(EventPortMessage * queue);
		EventPortMessage * GetQueueHead(EventPortMessage * & queue);

	public:
		WinPortServer(void);
		~WinPortServer(void);

		BOOL ProcessMessages(void);

		BOOL SendMessage(EventPort * port, WPARAM wParam, LPARAM lParam, HANDLE event = NULL);
		void ScheduleTimer(EventPort * port, WPARAM wParam, DWORD delay);
		void CancelTimer(EventPort * port);

		void FlushMessages(EventPort * port);
	};




//
//  WinPortWorkerThread
//

class EventPort : public GenericMsgPort
	{
	protected:
		WinPortServer *	server;
		VDLocalMutex		lock;
		HANDLE				event;
		void InternalMessage(WPARAM wParam, LPARAM lParam);
	public:
		EventPort(WinPortServer * server);
		virtual ~EventPort(void);

		//
		// Send a message to the port.
		//
		BOOL SendMessage(WPARAM wParam, LPARAM lParam);
		BOOL SendMessageIfQueueEmpty (WPARAM wParam, LPARAM lParam);
		void DoMessage(WPARAM wParam, LPARAM dParam);

		void ScheduleTimer(WPARAM wParam, DWORD delay);
		void CancelTimer(void);

		//
		// Method, that receives incoming messages asynchronously.
		//
		virtual void Message(WPARAM wParam, LPARAM lParam) = 0;

		void FlushMessages(void);

		void ClosePort(void);

		HWND GetHWND(void) {return NULL;}
	};

class EventPortWorkerThread : protected WinPortServer
	{
	friend class WorkerThreadEventPort;
	friend DWORD WINAPI EventWorkerThreadEntry(void * param);
	protected:
		EventPort	*	port;
		HANDLE			workerThread;

		void ThreadEntry(void);
	public:
		EventPortWorkerThread(WinPortServer * server, int priority);
		virtual ~EventPortWorkerThread(void);

		BOOL SendWorkMessage(WPARAM wParam, LPARAM lParam) {return port->SendMessage(wParam, lParam);}
		void DoWorkMessage(WPARAM wParam, LPARAM lParam) {port->DoMessage(wParam, lParam);}

		virtual void WorkMessage(WPARAM wParam, LPARAM lParam) = 0;

		void FlushWorkMessages(void) {port->FlushMessages();}

		void TerminateWorker(void);

		HWND GetHWND(void) {return NULL;}

		GenericMsgPort * GetPort(void) {return port;}
	};



typedef EventPort						WinPort;
typedef EventPortWorkerThread		WinPortWorkerThread;


#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\common\xbwarning.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#pragma warning(3:4092)   // sizeof returns 'unsigned long'
#pragma warning(4:4121)   // structure is sensitive to alignment
#pragma warning(3:4125)   // decimal digit in octal sequence
#pragma warning(3:4130)   // logical operation on address of string constant
#pragma warning(3:4132)   // const object should be initialized
#pragma warning(4:4206)   // Source File is empty
#pragma warning(4:4101)   // Unreferenced local variable
#pragma warning(4:4208)   // delete[exp] - exp evaluated but ignored
#pragma warning(3:4212)   // function declaration used ellipsis
#pragma warning(3:4242)   // convertion possible loss of data
#pragma warning(4:4267)   // convertion from size_t to smaller type
#pragma warning(4:4312)   // conversion to type of greater size
#pragma warning(error:4700)    // Local used w/o being initialized
//#pragma warning(3:4700)    // Local used w/o being initialized
#pragma warning(error:4259)    // pure virtual function was not defined
#pragma warning(error:4071)    // no function prototype given
#pragma warning(error:4072)    // no function prototype given (fastcall)
#pragma warning(error:4171)    // no function prototype given (old style)
#pragma warning(error:4013)    // 'function' undefined - assuming extern returning int
#pragma warning(error:4551)    // Function call missing argument list
#pragma warning(error:4806)    // unsafe operation involving type 'bool'
#pragma warning(4:4509)   // use of SEH with destructor
#pragma warning(4:4177)   // pragma data_seg s/b at global scope
#pragma warning(disable:4274)  // #ident ignored
#pragma warning(disable:4786)  // identifier was truncated to 255 chararcers in debug information.
#pragma warning(disable:4503)  // decorated name length exceeded, name was truncated.
#pragma warning(disable:4263)  // Derived override doesn't match base - who cares...
#pragma warning(disable:4264)  // base function is hidden - again who cares.
#pragma warning(disable:4710)  // Function marked as inline - wasn't
#pragma warning(disable:4917)  // A GUID can only be associated with a class, interface or namespace
#pragma warning(error:4552)    // <<, >> ops used to no effect (probably missing an = sign)
#pragma warning(error:4553)    // == op used w/o effect (probably s/b an = sign)


#if _MSC_VER>=1300
// Fix these new warnings post NT5 RTM.
#pragma warning(4:4532)   // jump out of __finally block
#pragma warning(4:4288)   // nonstandard extension used (loop counter)
#endif

#ifndef __cplusplus
#undef try
#undef except
#undef finally
#undef leave
#define try                         __try
#define except                      __except
#define finally                     __finally
#define leave                       __leave
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\common\Tags.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


// FILE:      library\common\tags.h
// AUTHOR:    Dietmar Heidrich
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   24.03.95
//
// PURPOSE: The tag processing module.
//
// HISTORY:

#ifndef TAGS_H
#define TAGS_H

#include "library/common/prelude.h"
#include "library/common/gnerrors.h"



// In order to be flexible, we use tags for setting and getting data and query
// module capabilities. Tag pairs consist of the tag itself and a data item.
// The tag tells which variable shall be set or retrieved. The data item is
// the value written to the variable or a pointer to the location where the
// retrieved value is to be stored.
// Tags have 32 bits and are built the following way:
//
// iccc uuuu uuuu uuuu rsss ssss ssss ssss
//
// "cc" is the tag command get, set or query. The tagging unit follows. The
// tag specifier itself is contained in the lowest 15 bits.
// Internal tags are marked with an i=1, external tags marked with an i=0.
// The difference between internal and external tagunits is, that external
// units have a type bit each, internal units only have numbers.
// Tags are type checked. Tags are constructed by the MKTAG_* macros and
// terminated by TAGDONE. The inline functions below do the type checking and
// are optimized to NOPs.  The r bit is used for reference tags.  These tags
// do not carry a value, but a reference to a more extendet structure;
//

#define TAG_VAL  0x00000000
#define TAG_GET  0x10000000
#define TAG_SET  0x20000000
#define TAG_QRY  0x30000000

#define TAG_REF  0x00008000

#define TAG_TYPE(x)	(x & 0x30000000)

#define ANYUNIT	0x4fff0000
#define MAIN_UNIT	0x00000000

#define MKTAGUNIT(unit, id)	\
	static const WORD unit##_ID	=	id;	\
	static const DWORD unit =  MKFLAG(16 + id);

#define GETTAGUNITS(tag)   XTBF(16, 12, tag)
#define USESTAGUNIT(tag, id) XTBF(16+id, tag)

#define MKITAGUNIT(unit, id)	\
	static const DWORD unit = 0x80000000L | (id << 16);

#if WDM_VERSION
struct __far TAG {
	DWORD	id;
	DWORD_PTR	data;
	TAG (DWORD _id, DWORD_PTR _data) { data = _data; id = _id; };
	TAG() {};
	~TAG() {}
	};
#else
struct __far TAG {
	DWORD	id;
	DWORD	data;
	TAG (DWORD _id, DWORD _data) { data = _data; id = _id; };
	TAG() {};
#if !__EDG__ || __EDG_VERSION__<240
	~TAG() {}	// This is mainly used as a workaround for a certain C++ frontend compiler bug.
#endif
	};
#endif

inline BOOL __far & QRY_TAG(TAG __far * tag) {return *((BOOL __far *)(tag->data));}

	//
	// TAG terminator
	//
#define TAGDONE TAG(0,0)

#if WDM_VERSION
DWORD_PTR FilterTags(TAG __far * tags, DWORD id, DWORD_PTR def);
#else
DWORD FilterTags(TAG __far * tags, DWORD id, DWORD def);
#endif

#if WDM_VERSION

#define MKTAG(name, unit, val, type)	\
	inline TAG SET_##name(type x) {return TAG(val | unit | TAG_SET, (DWORD_PTR)(x));}	\
	inline TAG GET_##name(type __far &x) {return TAG(val | unit | TAG_GET, (DWORD_PTR)(&x));}	\
	inline TAG QRY_##name(BOOL __far &x) {return TAG(val | unit | TAG_QRY, (DWORD_PTR)(&x));}	\
	inline type VAL_##name(TAG __far * tag) {return (type)(tag->data);}	\
	inline type FVAL_##name(TAG __far * tags, type def) {return (type)(FilterTags(tags, val | unit | TAG_GET, (DWORD_PTR)def));}	\
	inline type __far & REF_##name(TAG __far * tag) {return *(type __far *)(tag->data);}	\
	typedef type TTYPE_##name;	\
	static const DWORD CSET_##name = val | unit | TAG_SET;	\
	static const DWORD CGET_##name = val | unit | TAG_GET;	\
	static const DWORD CQRY_##name = val | unit | TAG_QRY;

#define MKRTG(name, unit, val, type)	\
	inline TAG SET_##name(type __far &x) {return TAG(val | unit | TAG_SET | TAG_REF, (DWORD_PTR)(FPTR)(&x));}	\
	inline TAG GET_##name(type __far &x) {return TAG(val | unit | TAG_GET | TAG_REF, (DWORD_PTR)(FPTR)(&x));}	\
	inline TAG QRY_##name(BOOL __far &x) {return TAG(val | unit | TAG_QRY | TAG_REF, (DWORD_PTR)(&x));}	\
	inline type VAL_##name(TAG __far * tag) {return *(type __far *)(tag->data);}	\
	inline type __far & REF_##name(TAG __far * tag) {return *(type __far *)(tag->data);}	\
	typedef type TTYPE_##name;	\
	static const DWORD CSET_##name = val | unit | TAG_SET | TAG_REF;	\
	static const DWORD CGET_##name = val | unit | TAG_GET | TAG_REF;	\
	static const DWORD CQRY_##name = val | unit | TAG_QRY | TAG_REF;

#else

#define MKTAG(name, unit, val, type)	\
	inline TAG SET_##name(type x) {return TAG(val | unit | TAG_SET, (DWORD)(x));}	\
	inline TAG GET_##name(type __far &x) {return TAG(val | unit | TAG_GET, (DWORD)(&x));}	\
	inline TAG QRY_##name(BOOL __far &x) {return TAG(val | unit | TAG_QRY, (DWORD)(&x));}	\
	inline type VAL_##name(TAG __far * tag) {return (type)(tag->data);}	\
	inline type FVAL_##name(TAG __far * tags, type def) {return (type)(FilterTags(tags, val | unit | TAG_GET, (DWORD)def));}	\
	inline type __far & REF_##name(TAG __far * tag) {return *(type __far *)(tag->data);}	\
	typedef type TTYPE_##name;	\
	static const DWORD CSET_##name = val | unit | TAG_SET;	\
	static const DWORD CGET_##name = val | unit | TAG_GET;	\
	static const DWORD CQRY_##name = val | unit | TAG_QRY;

#define MKRTG(name, unit, val, type)	\
	inline TAG SET_##name(type __far &x) {return TAG(val | unit | TAG_SET | TAG_REF, (DWORD)(FPTR)(&x));}	\
	inline TAG GET_##name(type __far &x) {return TAG(val | unit | TAG_GET | TAG_REF, (DWORD)(FPTR)(&x));}	\
	inline TAG QRY_##name(BOOL __far &x) {return TAG(val | unit | TAG_QRY | TAG_REF, (DWORD)(&x));}	\
	inline type VAL_##name(TAG __far * tag) {return *(type __far *)(tag->data);}	\
	inline type __far & REF_##name(TAG __far * tag) {return *(type __far *)(tag->data);}	\
	typedef type TTYPE_##name;	\
	static const DWORD CSET_##name = val | unit | TAG_SET | TAG_REF;	\
	static const DWORD CGET_##name = val | unit | TAG_GET | TAG_REF;	\
	static const DWORD CQRY_##name = val | unit | TAG_QRY | TAG_REF;

#endif

#if UNICODE

struct BoardVersionInfo
	{
	char	boardName[100];
	DWORD	boardVersion;
	};

struct UnicodeBoardVersionInfo
	{
	TCHAR boardName[100];
	DWORD boardVersion;
	};

MKRTG(BOARD_VERSION_UNICODE, MAIN_UNIT, 2, UnicodeBoardVersionInfo)

#else

struct BoardVersionInfo
	{
	char	boardName[100];
	DWORD	boardVersion;
	};

#endif

MKRTG(BOARD_VERSION,						MAIN_UNIT, 1,		BoardVersionInfo)
// 2 is used above!

MKRTG(BOARD_REGION_CODE,				MAIN_UNIT,	0x10,	BYTE)
MKRTG(BOARD_REGION_COUNT,				MAIN_UNIT,	0x11,	WORD)

MKRTG(BOARD_SPLIT_STREAM_SUPPORT,	MAIN_UNIT,	0x20, BOOL)

#if BOARD_HAS_AUTOMOTIVE_DRIVE
MKRTG(DRIVE_HAS_HIGH_TEMPERATURE,	MAIN_UNIT,	0x21, BOOL)
#endif

struct SoftwareVersionInfo
	{
	DWORD softwareVersion, softwareRevision;
	DWORD buildNumber;
	};

MKRTG(SOFTWARE_VERSION,		MAIN_UNIT,	0x30, SoftwareVersionInfo)

//
// Macros for easy access to TAG lists during parsing
//
// GETSET     : Simple get and set of a variable
// GETSETV    : Calls a function when the variable is changed
// GETSETVC   : Like GETSETV, but only calls on real changes
// GETSETC    : Sets a variable "changed" to TRUE when a variable is changed
// GETSETP    : Allows changing only when the virtual unit is passivated
// GETSETCF   : Ors a variable "changed" with a flag when the variable is changed
// GETONLY    : Allows only reading of a value
// GETINQUIRE : Calls an inquire function, the result is to be placed
//              in the pseudo variable "data".
//
// A typical TAG parsing routine will look like this
//
//	Error VirtualMPEGDecoder::Configure(TAG *tags)
//		{
//		PARSE_TAGS_START(tags)
//			GETSETP(MPEG_AUDIO_BITRATE,  params.audioBitRate);
//			GETSETP(MPEG_AUDIO_STREAMID, params.audioStreamID);
//			GETSETP(MPEG_VIDEO_STREAMID, params.videoStreamID);
//			GETSETP(MPEG_VIDEO_WIDTH,    params.videoWidth);
//			GETSETP(MPEG_VIDEO_HEIGHT,   params.videoHeight);
//			GETSETP(MPEG_VIDEO_FPS,      params.videoFPS);
//			GETSETP(MPEG_STREAM_TYPE,    params.streamType);
//
//			GETSET(MPEG_STREAM_HOOK, streamHook);
//
//			GETSETV(MPEG_LEFT_VOLUME,  leftVolume,  GNREASSERT(decoder->SetLeftVolume(leftVolume)));
//			GETSETV(MPEG_RIGHT_VOLUME, rightVolume, GNREASSERT(decoder->SetRightVolume(rightVolume)));
//			GETSETV(MPEG_AUDIO_MUTE,   audioMute,   GNREASSERT(decoder->MuteAudio(audioMute)));
//		PARSE_TAGS_END
//
//		GNRAISE_OK;
//		}
//

#ifndef ONLY_EXTERNAL_VISIBLE

#define PARSE_TAGS_START(tags) \
	TAG __far * tp = tags; \
	while (tp->id) { \
		switch (tp->id) {

#define PARSE_TAGS_END } tp++; }


#define GETSET(tagid, variable)	\
	case CSET_##tagid:	\
		variable = VAL_##tagid(tp);	\
		break;	\
	case CGET_##tagid:	\
		REF_##tagid(tp) = variable; \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETSETV(tagid, variable, call) \
	case CSET_##tagid:	\
		variable = VAL_##tagid(tp);	\
		if (GetState() == current) {call;} \
		break;	\
	case CGET_##tagid:	\
		REF_##tagid(tp) = variable; \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETSETVD(tagid, variable1, variable2, call) \
	case CSET_##tagid:	\
		variable1 = VAL_##tagid(tp);	\
		variable2 = VAL_##tagid(tp);	\
		if (GetState() == current) {call;} \
		break;	\
	case CGET_##tagid:	\
		GNRAISE(GNR_OBJECT_WRITE_ONLY); \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define SETD(tagid, call) \
	case CSET_##tagid:	\
		GNREASSERT(call(VAL_##tagid(tp))); \
		break;	\
	case CGET_##tagid:	\
		GNRAISE(GNR_OBJECT_WRITE_ONLY); \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETD(tagid, call) \
	case CSET_##tagid:	\
		GNRAISE(GNR_OBJECT_READ_ONLY); \
		break;	\
	case CGET_##tagid:	\
		GNREASSERT(call(REF_##tagid(tp))); \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETDSETD(tagid, getcall, setcall) \
	case CSET_##tagid:	\
		setcall(VAL_##tagid(tp)); \
		break;	\
	case CGET_##tagid:	\
		getcall(REF_##tagid(tp)); \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break


#define GETSETDV(tagid, variable, call) \
	case CSET_##tagid:	\
		variable = VAL_##tagid(tp);	\
		call; \
		break;	\
	case CGET_##tagid:	\
		REF_##tagid(tp) = variable; \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define SETDVGETDP(tagid, variable, call, puVar) \
	case CSET_##tagid:	\
		variable = VAL_##tagid(tp);	\
		GNREASSERT(call); \
		break;	\
	case CGET_##tagid:	\
		REF_##tagid(tp) = puVar; \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define SETDV(tagid, variable, call) \
	case CSET_##tagid:	\
		variable = VAL_##tagid(tp);    \
		call; \
		break;	\
	case CGET_##tagid:	\
		GNRAISE(GNR_OBJECT_WRITE_ONLY); \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define SETDDV(tagid, variable1, variable2, call) \
	case CSET_##tagid:	\
		variable1 = VAL_##tagid(tp);    \
		variable2 = VAL_##tagid(tp);    \
		call; \
		break;	\
	case CGET_##tagid:	\
		GNRAISE(GNR_OBJECT_WRITE_ONLY); \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETSETVC(tagid, variable, call) \
	case CSET_##tagid:	\
		if (variable != VAL_##tagid(tp)) {	\
			variable = VAL_##tagid(tp);	\
			if (GetState() == current) {call;} }	\
		break;	\
	case CGET_##tagid:	\
		REF_##tagid(tp) = variable; \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETSETC(tagid, variable) \
	case CSET_##tagid:	\
		if (VAL_##tagid(tp) != variable) { \
			variable = VAL_##tagid(tp);	\
			changed = TRUE; } \
		break;	\
	case CGET_##tagid:	\
		REF_##tagid(tp) = variable; \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETSETCF(tagid, variable, flag) \
	case CSET_##tagid:	\
		if (VAL_##tagid(tp) != variable) { \
			variable = VAL_##tagid(tp);	\
			changed |= flag; } \
		break;	\
	case CGET_##tagid:	\
		REF_##tagid(tp) = variable; \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETSETP(tagid, variable)	\
	case CSET_##tagid:	\
		if (GetState() != passive) GNRAISE(GNR_INVALID_CONFIGURE_STATE); \
		variable = VAL_##tagid(tp);	\
		break;	\
	case CGET_##tagid:	\
		REF_##tagid(tp) = variable; \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETONLY(tagid, variable) \
	case CSET_##tagid:	\
		GNRAISE(GNR_OBJECT_READ_ONLY);	\
		break;	\
	case CGET_##tagid:	\
		REF_##tagid(tp) = variable;	\
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETC(tagid, call) \
	case CSET_##tagid:	\
		GNRAISE(GNR_OBJECT_READ_ONLY);	\
		break;	\
	case CGET_##tagid:	\
		if (GetState() == current) \
			GNREASSERT(call(REF_##tagid(tp))); \
		else	\
			GNRAISE(GNR_INVALID_CONFIGURE_STATE); \
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define GETINQUIRE(tagid, inquire)	\
	case CSET_##tagid:	\
		GNRAISE(GNR_OBJECT_READ_ONLY);	\
	case CGET_##tagid:	\
		{	\
		TTYPE_##tagid __far &data = REF_##tagid(tp);	\
		inquire	\
		}	\
		break;	\
	case CQRY_##tagid:	\
		QRY_TAG(tp) = TRUE;	\
		break

#define BUILD_TAGS_START(num)	\
	{TAG list[num]; TAG __far * ntp = list;

#define BUILD_TAGS_ADD(tag)	\
	*ntp++ = tag;

#define BUILD_TAGS_END(callee)	\
	*ntp++ = TAGDONE;	\
	GNREASSERT(callee->Configure(list));}

#define FILTER_TAGS_ADD(tagid)	\
	case CSET_##tagid:	\
	case CGET_##tagid:	\
	case CQRY_##tagid:	\
		*ntp++ = *tp;	\
		break;

#define FILTER_TAGS_IF(condition, tagid)	\
	case CSET_##tagid:	\
	case CGET_##tagid:	\
	case CQRY_##tagid:	\
		if (condition)	\
			*ntp++ = *tp;	\
		break;

// This macro short-cuts the typical case of setting and getting a simple
// variable via tags in the implementation of Configure() functions. Note
// that it sets a BOOL variable "changed" when a parameter is set.

#define TAG_CASE(name, var)  \
	case CSET_##name:  var = VAL_##name(tp);  changed = TRUE;  break;  \
	case CGET_##name:  REF_##name(tp) = var;  break;  \
	case CQRY_##name:  QRY_TAG(tp) = TRUE;    break;

#endif

#ifndef ONLY_EXTERNAL_VISIBLE

class TagClass {
	public:
		virtual Error Configure(TAG __far * tags) {GNRAISE_OK;}
		Error __cdecl ConfigureTags (TAG tag, ...);
	};

class TagFilter {
	protected:
		TAG	*	list;
		TAG	*  ntp;

		int 		size;
		int		num;

		virtual Error InternalStart(int size)
			{
			if (!list)
				{
				this->size = size;
				list = new TAG[size];
				}
			else if (this->size < size)
				{
				delete[] list;
				this->size = size;
				list = new TAG[size];
				}

			this->num = 0;
			ntp = list;

			GNRAISE_OK;
			}

		virtual Error InternalAdd(TAG tag) {*ntp++ = tag; GNRAISE_OK;}
		virtual Error InternalDone(void) {return InternalAdd(TAGDONE);}
	public:
		virtual Error Start(int size = 100) {return InternalStart(size);}
		virtual Error Add(TAG tag) {return InternalAdd(tag);}
		virtual Error Done(void) {return InternalDone();}

		operator TAG * (void) {return list;}
	};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\common\KrnlStr.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\krnlstr.cpp
// AUTHOR:    Viona
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   04.12.96
//
// PURPOSE:
//
// HISTORY:
//
#include "KrnlStr.h"

////////////////////////////////////////////////////////////////////
//
//  Kernel String Buffer Class
//
////////////////////////////////////////////////////////////////////

class KernelStringBuffer
	{
	public:
		int		useCnt;
		int		length;
		TCHAR	*	buffer;
#if NT_KERNEL
		UNICODE_STRING	us;
#endif

		KernelStringBuffer(const TCHAR __far * str);
		KernelStringBuffer(const TCHAR ch);
		KernelStringBuffer(KernelStringBuffer * u, KernelStringBuffer * v);
		KernelStringBuffer(KernelStringBuffer * u, int start, int num);
		KernelStringBuffer(KernelStringBuffer * u, int num);
		KernelStringBuffer(BOOL sign, DWORD value, int digits, int base, TCHAR fill);

		~KernelStringBuffer(void);

		int Compare(KernelStringBuffer * u);

		void Obtain(void) {useCnt++;}
		void Release(void) {if (!--useCnt) delete this;}
	};

#define WS	sizeof(TCHAR)

KernelStringBuffer::KernelStringBuffer(const TCHAR __far * str)
	{
	useCnt = 1;

	const TCHAR __far * p;
	TCHAR * q;

	length = 0;
	p = str;
	while (*p++) length++;

#if   LINUX
	buffer = new TCHAR[length+2];
#else
	buffer = new (PagedPool) TCHAR[length+2];
#endif

	p = str;
	q = buffer;

	while (*q++ = *p++) ;

#if NT_KERNEL
	RtlInitUnicodeString(&us, buffer);
#endif
	}

KernelStringBuffer::KernelStringBuffer(const TCHAR ch)
	{
	useCnt = 1;

   length = 1;

#if   LINUX
	buffer = new TCHAR[2];
#else
	buffer = new (PagedPool) TCHAR[2];
#endif

	buffer[0] = ch;
	buffer[1] = 0;

#if NT_KERNEL
	RtlInitUnicodeString(&us, buffer);
#endif
	}

KernelStringBuffer::~KernelStringBuffer(void)
	{
	if (buffer) delete[] buffer;
	}

KernelStringBuffer::KernelStringBuffer(KernelStringBuffer * u, KernelStringBuffer * v)
	{
	useCnt = 1;

	length = u->length + v->length;
	TCHAR * p, * q;

#if   LINUX
	buffer = new TCHAR[length + 1];
#else
	buffer = new (PagedPool) TCHAR[length + 1];
#endif

	p = buffer;
	q = u->buffer;
	while (*p++ = *q++);
	p--;
	q = v->buffer;
	while (*p++ = *q++);

#if NT_KERNEL
	RtlInitUnicodeString(&us, buffer);
#endif
	}

KernelStringBuffer::KernelStringBuffer(KernelStringBuffer * u, int start, int num)
	{
	int i;

	useCnt = 1;

	length = u->length - start;
	if (length > num) length = num;
	TCHAR * p, * q;

#if   LINUX
	buffer = new TCHAR[length + 1];
#else
	buffer = new (PagedPool) TCHAR[length + 1];
#endif

	p = buffer;
	q = u->buffer + start;

	for(i=0; i<length; i++) *p++ = *q++;

	*p = 0;

#if NT_KERNEL
	RtlInitUnicodeString(&us, buffer);
#endif
	}

KernelStringBuffer::KernelStringBuffer(KernelStringBuffer * u, int num)
	{
	int i;

	useCnt = 1;

	length = u->length * num;
	TCHAR * p, * q;

#if   LINUX
	buffer = new TCHAR[length + 1];
#else
	buffer = new (PagedPool) TCHAR[length + 1];
#endif

	p = buffer;
	for(i=0; i<num; i++)
		{
		q = u->buffer;
		while (*p++ = *q++);
		p--;
		}
	p++;

#if NT_KERNEL
	RtlInitUnicodeString(&us, buffer);
#endif
	}

KernelStringBuffer::KernelStringBuffer(BOOL sign, DWORD value, int digits, int base, TCHAR fill)
	{
	TCHAR lbuffer[12];
	int pos = digits;
	int i;

	useCnt = 1;

	if (!pos) pos = 10;

	do {
		i = (int)(value % base);

		if (i < 10)
			lbuffer[--pos] = __TEXT('0') + i;
		else
			lbuffer[--pos] = __TEXT('A') + i - 10;

		value /= base;
		} while (value && pos);

	if (digits)
		{
#if   LINUX
		buffer = new TCHAR[digits + 1];
#else
		buffer = new (PagedPool) TCHAR[digits + 1];
#endif

		for(i=0; i<pos; i++) buffer[i] = fill;
		if (sign) buffer[0] = __TEXT('-');
		for(i=pos; i<digits; i++) buffer[i] = lbuffer[i];
		buffer[digits] = 0;
		length = digits;
		}
	else
		{
		if (sign)
			{
#if   LINUX
			buffer = new TCHAR[10 - pos + 2];
#else
			buffer = new (PagedPool) TCHAR[10 - pos + 2];
#endif
			buffer[0] = __TEXT('-');
			i = 1;
			length = 10 - pos + 1;
			}
		else
			{
#if   LINUX
			buffer = new TCHAR[10 - pos + 1];
#else
			buffer = new (PagedPool) TCHAR[10 - pos + 1];
#endif
			i = 0;
			length = 10 - pos;
			}

		while (pos < 10)
			{
			buffer[i++] = lbuffer[pos++];
			}
		buffer[i] = 0;
		}
	}


int KernelStringBuffer::Compare(KernelStringBuffer * u)
	{
#if NT_KERNEL
	return RtlCompareUnicodeString(&us, &(u->us), FALSE);
#else
	TCHAR * p, * q;
	TCHAR cp, cq;

	p = buffer;
	q = u->buffer;

	do {
		cp = *p++;
		cq = *q++;
		if (cp < cq)
			return -1;
		else if (cp > cq)
			return 1;
		} while (cp);

	return 0;
#endif
	}

////////////////////////////////////////////////////////////////////
//
//  Kernel String Class
//
////////////////////////////////////////////////////////////////////

KernelString::KernelString(void)
	{
	buffer = NULL;
	}

KernelString::KernelString(const TCHAR __far * str)
	{
	buffer = new (PagedPool) KernelStringBuffer(str);
	}

KernelString::KernelString(const TCHAR ch)
	{
	buffer = new (PagedPool) KernelStringBuffer(ch);
	}

#if NT_KERNEL

KernelString::KernelString(const UNICODE_STRING & str)
	{
	buffer = new (PagedPool) KernelStringBuffer(str.Buffer);
	}

#endif

KernelString::KernelString(int value, int digits, int base, TCHAR fill)
	{
	if (value < 0)
		buffer = new (PagedPool) KernelStringBuffer(TRUE, (DWORD)(-value), digits, base, fill);
	else
		buffer = new (PagedPool) KernelStringBuffer(FALSE, (DWORD)(value), digits, base, fill);
	}



KernelString::KernelString(DWORD value, int digits, int base, TCHAR fill)
	{
	buffer = new (PagedPool) KernelStringBuffer(FALSE, value, digits, base, fill);
	}

KernelString::KernelString(const KernelString & str)
	{
	buffer = str.buffer;
	if (buffer) buffer->Obtain();
	}

KernelString::~KernelString(void)
	{
	if (buffer) buffer->Release();
	}


int KernelString::Length(void) const
	{
	if (buffer)
		return buffer->length;
	else
		return 0;
	}


long KernelString::ToInt(int base)
	{
	long val = 0;
	BOOL sign;
	TCHAR c, * p;

	if (buffer && buffer->length)
		{
		p = buffer->buffer;
		if (*p == __TEXT('-'))
			{
			sign = TRUE;
			p++;
			}
		else
			sign = FALSE;

		while (c = *p++)
			{
			if      (c >= __TEXT('0') && c <= __TEXT('9')) val = val * base + c - __TEXT('0');
			else if (c >= __TEXT('a') && c <= __TEXT('f')) val = val * base + c - __TEXT('a') + 10;
			else if (c >= __TEXT('A') && c <= __TEXT('F')) val = val * base + c - __TEXT('A') + 10;
			else return 0;
			}

		if (sign)
			return -val;
		else
			return val;
		}
	else
		return 0;
	}

DWORD KernelString::ToUnsigned(int base)
	{
	DWORD val = 0;
	TCHAR c, * p;

	if (buffer && buffer->length)
		{
		p = buffer->buffer;

		while (c = *p++)
			{
			if (c>=__TEXT('0') && c<= __TEXT('9')) val = val * base + c - __TEXT('0');
			else if (c>=__TEXT('a') && c<=__TEXT('f')) val = val * base + c - __TEXT('a') + 10;
			else if (c>=__TEXT('A') && c<=__TEXT('F')) val = val * base + c - __TEXT('A') + 10;
			else return 0;
			}

		return val;
		}
	else
		return 0;
	}

BOOL KernelString::Get(TCHAR __far * str, int len)
	{
	TCHAR __far * p, * q;
	if (buffer)
		{
		if (len > buffer->length)
			{
			p = str;
			q = buffer->buffer;

			while (*p++ = * q++);

			return TRUE;
			}
		else
			return FALSE;
		}
	else if (len > 0)
		{
		str[0] = 0;

		return TRUE;
		}
	else
		return FALSE;
	}

#if NT_KERNEL

BOOL KernelString::Get(UNICODE_STRING & us)
	{
	RtlCopyUnicodeString(&us, &(buffer->us));

	return TRUE;
	}

#endif

KernelString & KernelString::operator= (const TCHAR __far * str)
	{
	if (buffer) buffer->Release();
	buffer = new (PagedPool) KernelStringBuffer(str);
	return * this;
	}

#if NT_KERNEL

KernelString & KernelString::operator= (const UNICODE_STRING & str)
	{
	if (buffer) buffer->Release();
	buffer = new (PagedPool) KernelStringBuffer(str.Buffer);
	return * this;
	}

#endif

KernelString & KernelString::operator= (const KernelString str)
	{
	if (buffer) buffer->Release();
	buffer = str.buffer;
	if (buffer) buffer->Obtain();

	return * this;
	}

KernelString operator+ (const KernelString u, const KernelString v)
	{
	KernelString str = u;
	str += v;
	return str;
	}

KernelString & KernelString::operator += (const KernelString u)
	{
	KernelStringBuffer * bp;

	if (buffer)
		{
		if (u.buffer)
			{
			bp = new (PagedPool) KernelStringBuffer(buffer, u.buffer);
			buffer->Release();
			buffer = bp;
			}
		}
	else
		{
		buffer = u.buffer;
		if (buffer) buffer->Obtain();
		}
	return *this;
	}

KernelString operator* (const KernelString u, const int num)
	{
	KernelString str = u;
	str *= num;
	return str;
	}

KernelString & KernelString::operator *= (const int num)
	{
	KernelStringBuffer * bp;

	if (buffer)
		{
		if (num)
			{
			bp = new (PagedPool) KernelStringBuffer(buffer, num);
			buffer->Release();
			buffer = bp;
			}
		else
			{
			buffer->Release();
			buffer = NULL;
			}
		}

	return *this;
	}

int KernelString::Compare(const KernelString str)
	{
	if (buffer == str.buffer)
		return 0;
	else if (!buffer)
		return -1;
	else if (!str.buffer)
		return 1;
	else
		return buffer->Compare(str.buffer);
	}

BOOL operator==(const KernelString u, const KernelString v)
	{
	return ((KernelString)u).Compare(v) == 0;
	}

BOOL operator!=(const KernelString u, const KernelString v)
	{
	return ((KernelString)u).Compare(v) != 0;
	}

BOOL operator<=(const KernelString u, const KernelString v)
	{
	return ((KernelString)u).Compare(v) <= 0;
	}

BOOL operator>=(const KernelString u, const KernelString v)
	{
	return ((KernelString)u).Compare(v) >= 0;
	}

BOOL operator<(const KernelString u, const KernelString v)
	{
	return ((KernelString)u).Compare(v) < 0;
	}

BOOL operator>(const KernelString u, const KernelString v)
	{
	return ((KernelString)u).Compare(v) > 0;
	}

TCHAR & KernelString::operator[] (const int index)
	{
	static TCHAR dummy;

	if (buffer)
		return buffer->buffer[index];
	else
		return dummy;
	}

const TCHAR & KernelString::operator[] (const int index) const
	{
	static TCHAR dummy;

	if (buffer)
		return buffer->buffer[index];
	else
		return dummy;
	}

KernelString operator >> (const KernelString u, int num)
	{
	KernelString str = u;
	str >>= num;

	return str;
	}

KernelString operator << (const KernelString u, int num)
	{
	KernelString str = u;
	str <<= num;

	return str;
	}

KernelString & KernelString::operator <<= (int index)
	{
	KernelStringBuffer * pb;

	if (buffer)
		{
		if (index < buffer->length)
			pb = new (PagedPool) KernelStringBuffer(buffer, index, buffer->length-index);
		else
			pb = NULL;

		buffer->Release();
		buffer = pb;
		}

	return * this;
	}

KernelString & KernelString::operator >>= (int index)
	{
	KernelStringBuffer * pb;

	if (buffer)
		{
		if (index < buffer->length)
			pb = new (PagedPool) KernelStringBuffer(buffer, 0, buffer->length-index);
		else
			pb = NULL;

		buffer->Release();
		buffer = pb;
		}

	return * this;
	}

KernelString KernelString::Seg(int start, int num) const
	{
	KernelString str;

	if (buffer)
		{
		if (start+num > buffer->length) num = buffer->length-start;
		if (num > 0)
			str.buffer = new (PagedPool) KernelStringBuffer(buffer, start, num);
		}

	return str;
	}

//
//  Return first num characters
//

KernelString KernelString::Head(int num) const
	{
	KernelString str;

	if (buffer && num > 0)
		{
		if (num > buffer->length)
			num = buffer->length;

		str.buffer = new (PagedPool) KernelStringBuffer(buffer, 0, num);
		}

	return str;
	}

//
//  Return last num characters
//

KernelString KernelString::Tail(int num) const
	{
	KernelString str;

	if (buffer && num > 0)
		{
		if (num <= buffer->length)
			str.buffer = new (PagedPool) KernelStringBuffer(buffer, buffer->length - num, num);
		else
			str.buffer = new (PagedPool) KernelStringBuffer(buffer, 0, num);
		}

	return str;
	}

//
//  Delete whitespaces at beginning or end of string
//

KernelString KernelString::Trim()
	{
	int i = 0;
	KernelString str = *this;

	// delete leading tabs and spaces...
	i = 0;
	while ((str[i] == ' ') || (str[i] == '\t'))
		i++;
	str <<= i;


	// delete preceding tabs and spaces ...
	i = str.Length()-1;
	while ((str[i] == ' ') || (str[i] == '\t'))
		i--;
	str = str.Seg(0, i+1);

	return str;
	}

//
//  Return upper case version of string
//

KernelString KernelString::Caps(void)
	{
	KernelString str;
	int i;
	TCHAR c;

	str = *this;

	for(i=0; i<str.Length(); i++)
		{
		c = str[i];
		if (c >= __TEXT('a') && c <= __TEXT('z'))
			str[i] = c + __TEXT('A') - __TEXT('a');
		}

	return str;
	}

//
//  Find first occurrence of str
//

int KernelString::First(KernelString str) const
	{
	int i;
	i = 0;

	while (i<= Length()-str.Length() && Seg(i, str.Length()) != str)
		i++;

	return i;
	}

//
//  Find next occurrence of str
//

int KernelString::Next(KernelString str, int pos) const
	{
	int i;
	i = pos+1;

	while (i<= Length()-str.Length() && Seg(i, str.Length()) != str)
		i++;

	return i;
	}

//
//  Find last occurrence of str
//

int KernelString::Last(KernelString str) const
	{
	int i;
	i = Length()-str.Length();

	while (i>=0 && Seg(i, str.Length()) != str)
		i--;

	return i;
	}

//
//  Find previous occurrence of str
//

int KernelString::Prev(KernelString str, int pos) const
	{
	int i;
	i = pos-1;

	while (i>=0 && Seg(i, str.Length()) != str)
		i--;

	return i;
	}

//
//  Find first occurrence of c (-1 if not found)
//

int KernelString::First(TCHAR c) const
	{
	int i = 0;

	if (buffer)
		{
		while (i < Length())
			{
			if (buffer->buffer[i] == c)
				return i;

			i++;
			}
		}

	return -1;
	}

//
//  Find next occurrence of c (length if not found)
//

int KernelString::Next(TCHAR c, int pos) const
	{
	int i = 0;

	if (buffer)
		{
		i = pos + 1;
		while (i < Length())
			{
			if (buffer->buffer[i] == c)
				return i;

			i++;
			}
		}

	return i;
	}

//
//  Find last occurrence of c (length if not found)
//

int KernelString::Last(TCHAR c) const
	{
	int i = 0;

	if (buffer)
		{
		i = Length() - 1;
		while (i >= 0)
			{
			if (buffer->buffer[i] == c)
				return i;

			i--;
			}
		}

	return i;
	}

//
//  Find previous occurrence of c (-1 if not found)
//

int KernelString::Prev(TCHAR c, int pos) const
	{
	int i = 0;

	if (buffer)
		{
		i = pos - 1;
		while (i >= 0)
			{
			if (buffer->buffer[i] == c)
				return i;

			i--;
			}
		}

	return -1;
	}

//
//  Test if string contains c
//

BOOL KernelString::Contains(TCHAR c) const
	{
	int i;

	if (buffer)
		{
		for (i=0; i<Length(); i++)
			{
			if (buffer->buffer[i] == c)
				return TRUE;
			}
		}

	return FALSE;
	}

#if NT_KERNEL

KernelString::operator UNICODE_STRING * (void)
	{
	return &(buffer->us);
	}

KernelString::operator UNICODE_STRING & (void)
	{
	return buffer->us;
	}

#else

KernelString::operator TCHAR * (void)
	{
	if (buffer)
		return buffer->buffer;
	else
		return NULL;
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\common\Profiles.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\profiles.h
// AUTHOR:    S. Herr
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   28.11.95
//
// PURPOSE:   Classes for configuration (INI) files.
//
// HISTORY:
//
// Date			Author	Comment
// --------		------	-------
// 16.11.1999  Franky   Added some documentation
// 20.04.2000	Martin	Added some more documentation after searching several hours for a bug
//								(I didn't know to call InitProfiles() first before creating a new profile object in NT kernel)


// The Profile classes are used to store configuration data in a tree-like
// structure. The location where profile information is stored depends on
// the operating system; for Win16, it's in .ini files, for W95/W98/NT it's
// in the registry.
// Where the data is stored is hidden from the programmer; he just uses
// the public methods to store or retrieve key/value pairs.
//
// There are 3 types of profile classes:
// GenericProfile - this is the base class
// StaticProfile - it stores its data in a linear array instead of a tree
//                 and is mostly used for storage in ROM areas
// Profile - derived from GenericProfile, mostly used class
//
// All classes are able to create new entries (actual key/value pairs)
// or sections (folders) through their constructors.
//
// The entries that can be read or written are:
// int, long, DWORD, WORD, string, (bool - only under Win32)
// For ReadXXX functions, if the desired key cannot be opened
// you can pass a default value that will be returned instead.
//
// When creating a new profile object, the corresponding
// object is either opened for read/write access (if it exists)
// or is created newly if it didn't yet exist.
//
// All methods of the ReadDirect() and WriteDirect() format
// (only found in the derived classes) are directly reading
// from / writing to the specified location, using absolute
// path names.
// Methods without "Direct" in their name allow a parent entry
// to be named first under which the child entry will be located
// (which means the path is a relative path, starting at the
// location of the current Profile object).
//
// The constructors can be called in one of the following ways:
//
// bla = new Profile(KernelString name)
//   creates a Profile object with <name> as its complete
//   "path", as seen from the root of the profile tree.
//
// bla = new Profile(Profile * parent, KernelString name)
//   creates a Profile object under the given "parent"
//   object in the tree.
//
// bla = new Profile(KernelString main, KernelString section)
//   creates a Profile object under the location
//   "software\viona\<main>\<section>" in the tree.
//   (e.g. "software\viona\Ravisent\2.0")
//
// bla = new Profile(KernelString vendor, KernelString product, KernelString version)
//   creates a Profile object under the location
//   "software\<vendor>\<product>\<version>" in the tree
//   (e.g. "software\SomeoneProducts, Unlimited\Kickstart\40.72")
//
// IMPORTANT when using the Profiles class in kernel mode drivers:
// Before creating a new Profile object (see above) you have to call the static function
//	Profiles::InitProfiles(). And after deleting the Profile object you have to call
// the static function Profiles::CleanupProfiles()!!!

// Parameter: Was bei Aufruf ohne Default?

#ifndef _PROFILES_H_
#define _PROFILES_H_

#include "gnerrors.h"
#include "krnlstr.h"

#define MAX_PROFILE_NAME_LENGTH 40

// error: unable to write to the specified profile
#define GNR_PROFILE_WRITE			MKERR(ERROR, PROFILES, GENERAL, 0x01)

// error: unable to read from the specified profile
#define GNR_PROFILE_READ			MKERR(ERROR, PROFILES, GENERAL, 0x02)

// error: No child profile could be created
#define GNR_PROFILE_NO_LEVEL		MKERR(ERROR, PROFILES, GENERAL, 0x03)

// Entry for the generic profile
class GenericProfile
	{
	public:
		virtual ~GenericProfile(void) {}
		virtual GenericProfile * CreateSection(KernelString section) = 0;

		virtual BOOL IsValid(void) = 0;

		// XXXDirect methods write directly to the absolute location given in "entry"
		// entry is the absolute path name, value is the value to be written.
		// "deflt", where used, is the value to return from a ReadXXX function when
		// the desired entry does not exist. If in such a case no parameter for
		// "deflt" is passed, the value of "value" is not changed.

		virtual Error WriteDirect(KernelString entry, int value) = 0;
		virtual Error ReadDirect(KernelString entry, int __far & value, int deflt) = 0;
		Error ReadDirect(KernelString entry, int __far & value) {return ReadDirect(entry, value, value);}

		virtual Error WriteDirect(KernelString entry, bool value) = 0;
		virtual Error ReadDirect(KernelString entry, bool __far & value, bool deflt) = 0;
		Error ReadDirect(KernelString entry, bool __far & value) {return ReadDirect(entry, value, value);}

		virtual Error ReadDirect(KernelString entry, long __far & value, long deflt) = 0;
		Error ReadDirect(KernelString entry, long __far & value) {return ReadDirect(entry, value, value);}

		// the base parameter determines the base (2, 8, 10, 16..) of the argument that
		// is about to be read or written.
		// This is required because e.g. when writing binary data to text-based profiles
		// (like under Win16), the data has to be encoded in a textual format (ASCII).
		virtual Error WriteDirect(KernelString entry, WORD value, int base) = 0;
		virtual Error ReadDirect(KernelString entry, WORD __far & value, int base, WORD deflt) = 0;
		Error ReadDirect(KernelString entry, WORD __far & value, int base) {return ReadDirect(entry, value, base, value);}

		virtual Error WriteDirect(KernelString entry, DWORD value, int base) = 0;
		virtual Error ReadDirect(KernelString entry, DWORD __far & value, int base, DWORD deflt) = 0;
		Error ReadDirect(KernelString entry, DWORD __far & value, int base) {return ReadDirect(entry, value, base, value);}

		virtual Error WriteDirect(KernelString entry, KernelString value) = 0;
		virtual Error ReadDirect(KernelString entry, KernelString & value, KernelString deflt) = 0;
		Error ReadDirect(KernelString entry, KernelString & value) {return ReadDirect(entry, value, value);}

		// These Write/Read functions use "section" as relative path, starting at
		// the location of "this" object.
		virtual Error Write(KernelString section, KernelString entry, int value);
		virtual Error Read(KernelString section, KernelString entry, int __far & value, int deflt);
		Error Read(KernelString section, KernelString entry, int __far & value) {return Read(section, entry, value, value);}

		virtual Error Write(KernelString section, KernelString entry, bool value);
		virtual Error Read(KernelString section, KernelString entry, bool __far & value, bool deflt);
		Error Read(KernelString section, KernelString entry, bool __far & value) {return Read(section, entry, value, value);}

		virtual Error Read(KernelString section, KernelString entry, long __far & value, long deflt);
		Error Read(KernelString section, KernelString entry, long __far & value) {return Read(section, entry, value, value);}

		virtual Error Write(KernelString section, KernelString entry, DWORD value, int base = 10);
		virtual Error Read(KernelString section, KernelString entry, DWORD __far & value, int base, DWORD deflt);
		Error Read(KernelString section, KernelString entry, DWORD __far & value, int base) {return Read(section, entry, value, base, value);}

		virtual Error Write(KernelString section, KernelString entry, WORD value, int base);
		virtual Error Read(KernelString section, KernelString entry, WORD __far & value, int base, WORD deflt);
		Error Read(KernelString section, KernelString entry, WORD __far & value, int base) {return Read(section, entry, value, base, value);}

		virtual Error Write(KernelString section, KernelString entry, KernelString value);
		virtual Error Read(KernelString section, KernelString entry, KernelString & value, KernelString deflt);
		Error Read(KernelString section, KernelString entry, KernelString & value) {return Read(section, entry, value, value);}
	};


//
// Entry for the static profile
// The location of keys in a static profile is found by
// calculating a hash value from their name.
//

struct ProfileEntry
	{
	DWORD id;
	DWORD	value;
	};

class StaticProfile : public GenericProfile
	{
	private:
		ProfileEntry	*	entries;

	protected:
		BOOL	protect;

		virtual Error WriteDW(KernelString entry, DWORD value);
		virtual Error ReadDW(KernelString entry, DWORD __far & value);

		virtual Error FindValue(KernelString entryName, ProfileEntry * __far & entry);
		virtual Error FindSection(KernelString section, ProfileEntry * __far & entry);

	public:
		// ProfileEntry array must be initialized (formatted).
		StaticProfile(ProfileEntry * entries);
		StaticProfile(const ProfileEntry * entries);	// Read only profile
		// Start with a subsection.
		StaticProfile(ProfileEntry * entries, KernelString section);
		StaticProfile(StaticProfile * parent, KernelString section);

		virtual void SetWriteProtection(BOOL protect) {this->protect = protect;}	// Default is ON!

		GenericProfile * CreateSection(KernelString section); // creates a new subsection (folder)

		BOOL IsValid(void);

		Error CalculateByteSize (int & size);   // of the valid ProfileEntry array

		// XXXDirect methods write directly to the absolute location given in "entry".
		Error WriteDirect(KernelString entry, int value);
		Error ReadDirect(KernelString entry, int __far & value, int deflt);

		Error WriteDirect(KernelString entry, long value);
		Error ReadDirect(KernelString entry, long __far & value, long deflt);

		Error WriteDirect(KernelString entry, WORD value, int base);
		Error ReadDirect(KernelString entry, WORD __far & value, int base, WORD deflt);

		Error WriteDirect(KernelString entry, DWORD value, int base);
		Error ReadDirect(KernelString entry, DWORD __far & value, int base, DWORD deflt);

		Error WriteDirect(KernelString entry, KernelString value);
		Error ReadDirect(KernelString entry, KernelString & value, KernelString deflt);

		Error WriteDirect(KernelString entry, bool value);
		Error ReadDirect(KernelString entry, bool __far & value, bool deflt);
	};

//
// Entry for the most-used standard profile
// When compiling for Win16, profiles get written to .ini files
// When compiling a standard Win32 app, a VxD or for NT, profiles
// get written into the registry.
//

class NullProfile : public GenericProfile
	{
	public:
		GenericProfile * CreateSection(KernelString section) {return this;}

		BOOL IsValid(void) {return true;}

		Error WriteDirect(KernelString entry, int value) {GNRAISE_OK;}
		Error ReadDirect(KernelString entry, int __far & value, int deflt) {value = deflt; GNRAISE_OK;}

		Error WriteDirect(KernelString entry, bool value)  {GNRAISE_OK;}
		Error ReadDirect(KernelString entry, bool __far & value, bool deflt)  {value = deflt; GNRAISE_OK;}

		Error ReadDirect(KernelString entry, long __far & value, long deflt)  {value = deflt; GNRAISE_OK;}

		Error WriteDirect(KernelString entry, WORD value, int base)  {GNRAISE_OK;}
		Error ReadDirect(KernelString entry, WORD __far & value, int base, WORD deflt)  {value = deflt; GNRAISE_OK;}

		Error WriteDirect(KernelString entry, DWORD value, int base)  {GNRAISE_OK;}
		Error ReadDirect(KernelString entry, DWORD __far & value, int base, DWORD deflt)  {value = deflt; GNRAISE_OK;}

		Error WriteDirect(KernelString entry, KernelString value)  {GNRAISE_OK;}
		Error ReadDirect(KernelString entry, KernelString & value, KernelString deflt)  {value = deflt; GNRAISE_OK;}
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\common\WinPorts.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\winports.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   22.03.95
//
// PURPOSE:   Class for windows as ports
//
// HISTORY:
//
//

#include "winports.h"
#include "library/common/prelude.h"
#include "library/common/vddebug.h"
#include "library/lowlevel/timer.h"

////////////////////////////////////////////////////////////////////
//
//  ST20LITE WinPort Classes
//
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
//
//  Windows WinPort Classes
//
////////////////////////////////////////////////////////////////////



//
// Class name
//

static TCHAR PWClassName[] = __TEXT("VDWinPort");

//
// Static class variables, represent the window class
//

////////////////////////////////////////////////////////////////////
//
//  WorkerThreadWinPort Class
//
////////////////////////////////////////////////////////////////////


class EventPortMessage
	{
	public:
		EventPortMessage	*	succ;
		EventPort			*	port;
		WPARAM					wParam;
		LPARAM					lParam;
		DWORD						time;
		HANDLE					event;

		EventPortMessage(EventPort * port, WPARAM wParam, LPARAM lParam, DWORD time, HANDLE event)
			{
			this->port = port;
			this->wParam = wParam;
			this->lParam = lParam;
			this->time = time;
			this->event = event;
			this->succ = NULL;
			}
	};

WinPortServer::WinPortServer(void)
	{
	messages = NULL;
	timeMessages = NULL;
	event = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	terminate = false;
	}

WinPortServer::~WinPortServer(void)
	{
	::CloseHandle(event);
	}

void WinPortServer::EnterQueueHead(EventPortMessage * & queue, EventPortMessage * message)
	{
	if (queue)
		{
		message->succ = queue->succ;
		queue->succ = message;
		queue = message;
		}
	else
		{
		message->succ = message;
		queue = message;
		}
	}

EventPortMessage * WinPortServer::GetQueuePort(EventPortMessage * & queue, EventPort * port)
	{
	EventPortMessage * msg, * rmsg;

	if (queue)
		{
		msg = queue;
		while (msg->succ != queue && msg->succ->port != port)
			{
			msg = msg->succ;
			}
		if (msg->succ->port == port)
			{
			rmsg = msg->succ;
			if (msg->succ == queue)
				{
				if (queue == queue->succ)
					queue = NULL;
				else
					{
					queue = msg;
					msg->succ = msg->succ->succ;
					}
				}
			else
				msg->succ = msg->succ->succ;

			return rmsg;
			}
		else
			return NULL;
		}
	else
		return NULL;
	}

void WinPortServer::EnterQueueTime(EventPortMessage * & queue, EventPortMessage * message)
	{
	EventPortMessage * mq;

	if (queue)
		{
		mq = queue;
		while (mq->succ != queue && mq->succ->time < message->time)
			mq = mq->succ;

		if (mq->succ->time < message->time)
			{
			message->succ = mq->succ;
			mq->succ = message;
			}
		else
			{
			message->succ = queue->succ;
			queue->succ = message;
			queue = queue->succ;
			}
		}
	else
		{
		message->succ = message;
		queue = message;
		}
	}

EventPortMessage * WinPortServer::PeekQueueHead(EventPortMessage * queue)
	{
	if (queue)
		{
		return queue->succ;
		}
	else
		return NULL;
	}

EventPortMessage * WinPortServer::GetQueueHead(EventPortMessage * & queue)
	{
	EventPortMessage * message;

	if (queue)
		{
		message = queue->succ;

		if (queue->succ != queue)
			{
			queue->succ = queue->succ->succ;
			}
		else
			{
			queue = NULL;
			}

		return message;
		}
	else
		return NULL;
	}

BOOL WinPortServer::ProcessMessages(void)
	{
	HANDLE	events[1];
	DWORD		result;
	DWORD		time;
	EventPortMessage *	message;

	events[0] = event;
	while (!terminate)
		{
		lock.Enter();
		time = Timer.GetMilliTicks();
		message = PeekQueueHead(timeMessages);
		while (message && time >= message->time)
			{
			GetQueueHead(timeMessages);
			lock.Leave();
			message->port->Message(message->wParam, message->lParam);
			delete message;
			lock.Enter();
			time = Timer.GetMilliTicks();
			message = PeekQueueHead(timeMessages);
			}

		if (message)
			time = message->time - time;
		else
			time = INFINITE;

		message = PeekQueueHead(messages);
		while (message)
			{
			GetQueueHead(messages);
			lock.Leave();
			message->port->Message(message->wParam, message->lParam);
			if (message->event) ::SetEvent(message->event);
			delete message;
			lock.Enter();
			message = PeekQueueHead(messages);
			}
		lock.Leave();
		result = WaitForMultipleObjects(1, events, FALSE, time);
		}

	return TRUE;
	}

BOOL WinPortServer::SendMessage(EventPort * port, WPARAM wParam, LPARAM lParam, HANDLE event)
	{
	lock.Enter();
	EnterQueueHead(messages, new EventPortMessage(port, wParam, lParam, 0, event));
	::SetEvent(this->event);
	lock.Leave();

	return TRUE;
	}

void WinPortServer::ScheduleTimer(EventPort * port, WPARAM wParam, DWORD delay)
	{
	lock.Enter();
	CancelTimer(port);
	EnterQueueTime(timeMessages, new EventPortMessage(port, wParam, 0, Timer.GetMilliTicks() + delay, NULL));
	::SetEvent(this->event);
	lock.Leave();
	}

void WinPortServer::CancelTimer(EventPort * port)
	{
	EventPortMessage * message;

	lock.Enter();
	while (message = GetQueuePort(timeMessages, port))
		delete message;
	lock.Leave();
	}


void WinPortServer::FlushMessages(EventPort * port)
	{
	EventPortMessage * message;

	lock.Enter();
	while (message = GetQueuePort(timeMessages, port))
		delete message;
	while (message = GetQueuePort(messages, port))
		delete message;
	lock.Leave();
	}

void EventPort::InternalMessage(WPARAM wParam, LPARAM lParam)
	{
	Message(wParam, lParam);
	}

EventPort::EventPort(WinPortServer * server)
	{
	this->server = server;
	event = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	}

EventPort::~EventPort(void)
	{
	FlushMessages();
	CloseHandle(event);
	}

BOOL EventPort::SendMessage(WPARAM wParam, LPARAM lParam)
	{
	return server->SendMessage(this, wParam, lParam);
	}

BOOL EventPort::SendMessageIfQueueEmpty (WPARAM wParam, LPARAM lParam)
	{
	return server->SendMessage(this, wParam, lParam);
	}

void EventPort::DoMessage(WPARAM wParam, LPARAM lParam)
	{
	lock.Enter();
	if (server->SendMessage(this, wParam, lParam, event))
		::WaitForSingleObject(event, INFINITE);
	lock.Leave();
	}

void EventPort::ScheduleTimer(WPARAM wParam, DWORD delay)
	{
	server->ScheduleTimer(this, wParam, delay);
	}

void EventPort::CancelTimer(void)
	{
	server->CancelTimer(this);
	}

void EventPort::FlushMessages(void)
	{
	server->FlushMessages(this);
	}

void EventPort::ClosePort(void)
	{
	FlushMessages();
	}

//////////////////////////////////////////////////////////////

class WorkerThreadEventPort : public EventPort
	{
	protected:
		EventPortWorkerThread	*	thread;
	public:
		WorkerThreadEventPort(EventPortWorkerThread * thread)
			: EventPort(thread)
			{
			this->thread = thread;
			}

		void Message(WPARAM wParam, LPARAM lParam)
			{
			thread->WorkMessage(wParam, lParam);
			}
	};

static DWORD WINAPI EventWorkerThreadEntry(void * param)
	{
	((EventPortWorkerThread *)param)->ThreadEntry();

	return 0;
	}


void EventPortWorkerThread::ThreadEntry(void)
	{
	ProcessMessages();
	}

EventPortWorkerThread::EventPortWorkerThread(WinPortServer * server, int priority)
	{
	DWORD id;

	port = new WorkerThreadEventPort(this);

	workerThread = CreateThread(NULL, 100000, EventWorkerThreadEntry, this, 0, &id);
	SetThreadPriority(workerThread, priority);
	}

EventPortWorkerThread::~EventPortWorkerThread(void)
	{
	TerminateWorker();
	}

void EventPortWorkerThread::TerminateWorker(void)
	{
	if (port)
		{
		terminate = true;
		::SetEvent(event);
		WaitForSingleObject(workerThread, INFINITE);
		CloseHandle(workerThread);
		workerThread = NULL;
		delete port;
		port = NULL;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\CDFile.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  CD File System Classes
//
////////////////////////////////////////////////////////////////////

#include "CDFile.h"
#include <stdio.h>

////////////////////////////////////////////////////////////////////
//
//  CD Track Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

CDTrack::CDTrack(CDFileSystem * cdfs) : GenericFile(cdfs)
	{
	this->cdfs = cdfs;
	cdi = NULL;
	}

//
//  Destructor
//

CDTrack::~CDTrack(void)
	{
	Close();
	}

//
//  Open track
//

Error CDTrack::Open(GenericFileSystemIterator * gfsi, DWORD accessType)
	{
	if (accessType != FAT_READ)
		GNRAISE(GNR_FILE_READ_ONLY);

	GNREASSERT(GenericFile::Open(gfsi, accessType));
	GNREASSERT(((CDIterator*)gfsi)->Clone(cdi));
	startBlock = cdfs->GetStartBlock(cdi);
	trackType = cdfs->GetTrackType(cdi);

	GNRAISE_OK;
	}

//
//  Close track
//

Error CDTrack::Close(void)
	{
	delete cdi;
	cdi = NULL;

	GNRAISE_OK;
	}

//
//  Get name of track
//

Error CDTrack::GetName(DiskItemName & name)
	{
	return cdfs->GetItemName(cdi, name);
	}

//
//  Get path to track
//

Error CDTrack::GetPathName(DiskItemName & name)
	{
	return cdfs->GetPathName(cdi, name);
	}

//
//  Get track size
//

Error CDTrack::GetSize(KernelInt64 & size)
	{
	return cdfs->GetItemSize(cdi, size);
	}

//
//  Get iterator
//

Error CDTrack::GetIterator(GenericFileSystemIterator * & gfsi)
	{
	return cdi->Clone(gfsi);
	}

//
//  Build unique key
//

Error CDTrack::BuildUniqueKey(void)
	{
	GNRAISE(GNR_UNIMPLEMENTED);
	}

//
//  Get copy management mode
//

Error CDTrack::GetCopyManagementInfo(GenericCopyManagementInfo & gcmi)
	{
	gcmi = GCMI_COPY_FORBIDDEN;	// ???
	GNRAISE_OK;
	}

//
//  Seek block
//

Error CDTrack::SeekBlock(DWORD block, DWORD flags, RequestHandle * rh)
	{
	GNRAISE(cdfs->SeekBlock(startBlock + block, flags, rh));
	}

//
//  Lock blocks
//

Error CDTrack::LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	if (trackType == CTT_AUDIO)
		flags = (flags & ~GD_SECTOR_TYPE_MASK) | DST_CDDA;
	else if (headerFile)
		flags = (flags & ~GD_SECTOR_TYPE_MASK) | cdfs->GetHeaderSectorType();
	else
		flags = (flags & ~GD_SECTOR_TYPE_MASK) | cdfs->GetDataSectorType();

	GNRAISE(cdfs->LockBlocks(startBlock + block, num, blocks, flags, rh));
	}

//
//  Unlock blocks
//

Error CDTrack::UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	if (trackType == CTT_AUDIO)
		flags = (flags & ~GD_SECTOR_TYPE_MASK) | DST_CDDA;
	else if (headerFile)
		flags = (flags & ~GD_SECTOR_TYPE_MASK) | cdfs->GetHeaderSectorType();
	else
		flags = (flags & ~GD_SECTOR_TYPE_MASK) | cdfs->GetDataSectorType();

	GNRAISE(cdfs->UnlockBlocks(startBlock + block, num, blocks, flags, rh));
	}

////////////////////////////////////////////////////////////////////
//
//  CD Session Class
//
////////////////////////////////////////////////////////////////////

#if GFS_ENABLE_DIRECTORIES

//
//  Constructor
//

CDSession::CDSession(CDFileSystem * cdfs) : GenericDirectory(cdfs)
	{
	this->cdfs = cdfs;
	cdi = NULL;
	}

//
//  Copy constructor
//

CDSession::CDSession(const CDSession & cds) : GenericDirectory(cds)
	{
	cdi = new CDIterator(*(cds.cdi));
	}

//
//  Destructor
//

CDSession::~CDSession(void)
	{
	Close();
	}

//
//  Open directory
//

Error CDSession::Open(GenericFileSystemIterator * gfsi, DWORD accessType)
	{
	GNREASSERT(gfsi->Clone((GenericFileSystemIterator*&)cdi));
	GNRAISE_OK;
	}

//
//  Close directory
//

Error CDSession::Close(void)
	{
	delete cdi;
	cdi = NULL;

	GNRAISE_OK;
	}

//
//  Get name
//

Error CDSession::GetName(DiskItemName & name)
	{
	return cdfs->GetItemName(cdi, name);
	}

//
//  Get path name
//

Error CDSession::GetPathName(DiskItemName & name)
	{
	return cdfs->GetPathName(cdi, name);
	}

//
//  Get iterator pointing to this dir
//

Error CDSession::GetIterator(GenericFileSystemIterator * & gfsi)
	{
	return cdi->Clone(gfsi);
	}

//
//  Create item
//

Error CDSession::CreateItem(DWORD diskItemType, const DiskItemName & name, GenericDiskItem * & gdi)
	{
	GNRAISE(GNR_DISK_READ_ONLY);
	}

//
//  Delete item
//

Error CDSession::DeleteItem(GenericFileSystemIterator * gfsi)
	{
	GNRAISE(GNR_DISK_READ_ONLY);
	}

//
//  Get number of items in dir
//

Error CDSession::GetNumberOfItems(DWORD & num)
	{
	return cdfs->GetNumberOfItems(cdi, num);
	}

//
//  Find item
//

Error CDSession::FindItem(const DiskItemName & name, DiskItemType type, DWORD flags, GenericFileSystemIterator * & gfsi)
	{
	GenericFileSystemIterator * where;
	Error err;

	GNREASSERT(GetIterator(where));
	err = cdfs->FindItem(name, type, flags, where, gfsi);
	delete where;
	GNRAISE(err);
	}

#endif

////////////////////////////////////////////////////////////////////
//
//  CD Iterator Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

CDIterator::CDIterator(CDFileSystem * cdfs) : GenericFileSystemIterator(cdfs)
	{
	this->cdfs = cdfs;
	session = 0;	// Let's point to root dir
	track = 0;
	}

//
//  Copy constructor
//

CDIterator::CDIterator(const CDIterator & cdi) : GenericFileSystemIterator(cdi)
	{
	cdfs = cdi.cdfs;
	session = cdi.session;
	track = cdi.track;
	}

//
//  Clone function
//

Error CDIterator::Clone(CDIterator * & cdi) const
	{
	cdi = new CDIterator(cdfs);
	if (cdi)
		{
		cdi->session = session;
		cdi->track = track;
		GNRAISE_OK;
		}
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}

//
//  Clone function
//

Error CDIterator::Clone(GenericFileSystemIterator * & gfsi) const
	{
	CDIterator * cdi;

	GNREASSERT(Clone(cdi));
	gfsi = cdi;
	GNRAISE_OK;
	}

//
//  Destructor
//

CDIterator::~CDIterator(void)
	{
	}

//
//  Comparison function
//

BOOL CDIterator::Equals(GenericFileSystemIterator * gfsi)
	{
	return (session == ((CDIterator*)gfsi)->session) &&
			 (track   == ((CDIterator*)gfsi)->track);
	}

//
//  Go to first item in directory
//

Error	CDIterator::GoToFirstItem(void)
	{
	return cdfs->GoToFirstItem(this);
	}

//
//  Go to next item in directory
//

Error	CDIterator::GoToNextItem(void)
	{
	return cdfs->GoToNextItem(this);
	}

//
//  Enter subdirectory
//

Error	CDIterator::GoToSubDir(GenericFileSystemIterator * & gfsi)
	{
	return cdfs->GoToSubDir(this, gfsi);
	}

//
//  Go to parent directory
//

Error	CDIterator::GoToParentDir(GenericFileSystemIterator * & gfsi)
	{
	return cdfs->GoToParentDir(this, gfsi);
	}

//
//  Get current directory
//

Error	CDIterator::GetCurrentDir(GenericDirectory * & gd)
	{
	return cdfs->GetDir(this, gd);
	}

//
//  Get path name of current directory
//

Error CDIterator::GetPathName(DiskItemName & name)
	{
	return cdfs->GetPathName(this, name);
	}

//
//  Get type of item pointed to
//

Error CDIterator::GetItemType(DiskItemType & type)
	{
	return cdfs->GetItemType(this, type);
	}

//
//  Get name of item pointed to
//

Error CDIterator::GetItemName(DiskItemName & name)
	{
	return cdfs->GetItemName(this, name);
	}

//
//  Get size of item pointed to
//

Error CDIterator::GetItemSize(KernelInt64 & size)
	{
	return cdfs->GetItemSize(this, size);
	}

//
//  Get the number of items in the directory the iterator is in
//

Error CDIterator::GetNumberOfItems(DWORD & num)
	{
	return cdfs->GetNumberOfItems(this, num);
	}

//
//  Open item pointed to
//

Error	CDIterator::OpenItem(DWORD fileAccessType, GenericDiskItem * & gdi)
	{
	return cdfs->OpenItem(this, fileAccessType, gdi);
	}

////////////////////////////////////////////////////////////////////
//
//  CD File System Class
//
////////////////////////////////////////////////////////////////////

//
//  Constructor
//

CDFileSystem::CDFileSystem(void) : GenericFileSystem()
	{
	numSessions = 0;
	sessions = NULL;
	cdvdVolume = NULL;
	fileSystemType = FS_CD;
	}

//
//  Destructor
//

CDFileSystem::~CDFileSystem(void)
	{
	int i;

	//
	//  Delete TOC data
	//

	for (i=0; i<numSessions; i++)
		delete[] sessions[i].toc;

	delete[] sessions;
	}

//
//  Initialize
//

Error CDFileSystem::Init(GenericFileSystemIterator * mountPoint, GenericVolume * volume, GenericProfile * profile)
	{
	RequestHandle rh;
	CDSessionType sessionType = CST_NONE;
	PhysicalDiskType type;
	Error err = GNR_OK, herr;
	int i;

	//
	//  Check if we can use this volume
	//

	GNREASSERT(volume->GetDiskType(type));

	switch (type)
		{
		case PHDT_CDDA:
			volumeName = "Audio CD";
			break;
		case PHDT_CDROM:
			volumeName = "CDROM";
			break;
		case PHDT_CDI:
			volumeName = "CDI";
			break;
		case PHDT_CDROM_XA:
			volumeName = "CDROM XA";
			break;
		default:
			GNRAISE(GNR_VOLUME_INVALID);
		}

	GNREASSERT(GenericFileSystem::Init(mountPoint, volume, profile));
	cdvdVolume = (CDVDVolume*)volume;

	//
	//  Initialize TOCs
	//

	GNREASSERT((cdvdVolume)->GetNumberOfSessions(numSessions));
	if (!numSessions)
		GNRAISE(GNR_VOLUME_INVALID);

	sessions = new CDSessionInfo[numSessions];
	for (i=0; i<numSessions; i++)
		{
		if (IS_ERROR(herr = cdvdVolume->ReadCDTOC(i+1, sessionType, sessions[i].toc, sessions[i].numTracks, &rh)))
			{
			err = herr;
			sessions[i].toc = NULL;
			sessions[i].numTracks = 0;
			}
		}

	//
	//  Initialize misc
	//

	volumeSetName = volumeName;
	volumeSetIndex = 1;
	volumeSetSize = 1;

	GNRAISE(err);
	}

//
// Initialize header- and data-related variables.
// Base class doesn't do good enough job because it bases decision about sector
// type relying on phisical disk type, which in case of audio may not be a good
// criteria (audio could be found mixed with data on CDROM and other disk types)
//
Error	CDFileSystem::InitHeaderAndData(GenericVolume * volume)
	{
	DWORD dummy;

	headerSectorType = DST_CDDA;
	dataSectorType = DST_CDDA;
	GNREASSERT(volume->GetBlockInfo(headerSectorType, dummy, headerHeaderSize, headerDataSize));
	GNREASSERT(volume->GetBlockInfo(dataSectorType, dummy, dataHeaderSize, dataDataSize));

	GNRAISE_OK;
	}


#define CDDB_UNIQUE_CD_ID 1

//
//  Build unique volume key
//

Error CDFileSystem::BuildUniqueKey(void)
	{
	int i;
	int j;
	DWORD val;

#if CDDB_UNIQUE_CD_ID

	// Unique CD key compatible with www.freedb.org.
	// To confirm the algorithma is up-to-date, check out www.freedb.org and/or www.cddb.com
	//TODO: How to handle multiple sessions? To base key on all the sessions may have more chances
	//to be unique, but it may not be very useful for CDDB.

	char szTemp[9];
	int cddbTrackSum, cddbTotalSum, totalTracks, totalCDLengthSec;
	DWORD dwDiscId;

	cddbTotalSum = 0; totalTracks = 0; totalCDLengthSec = 0;
	for (i=0; i<numSessions; i++)
		{
		int endOfCDSec;

		for (j=0; j<sessions[i].numTracks; j++)
			{
			cddbTrackSum = 0;
			val = sessions[i].toc[j].GetStartBlock()/75; //track positon time in seconds
			while (val > 0)
				{
				cddbTrackSum += (val%10);
				val /= 10;
				}
			cddbTotalSum += cddbTrackSum;
			val = sessions[i].toc[j].GetNumberOfBlocks();
			}

		totalTracks += sessions[i].numTracks;
		endOfCDSec = (sessions[i].toc[j-1].GetStartBlock() + sessions[i].toc[j-1].GetNumberOfBlocks())/75;
		totalCDLengthSec += endOfCDSec - sessions[i].toc[0].GetStartBlock()/75;
		}

	//Set unique disc ID value
	dwDiscId = ((cddbTotalSum % 0xff) << 24 | (totalCDLengthSec & 0xffff) << 8 | (totalTracks & 0xff));
	sprintf(szTemp, "%08x", dwDiscId);
	memcpy(uniqueKey.key, szTemp, 8);

#else

	// Our internal CD key
	int pos = 0;

	for (i=0; i<8; i++)
		uniqueKey.key[i] = 0x00;

	for (i=0; i<numSessions; i++)
		{
		for (j=0; j<sessions[i].numTracks; j++)
			{
			val = sessions[i].toc[j].GetStartBlock();
			uniqueKey.key[pos++] += (BYTE)XTBF( 0, 8, val);
			pos &= 0x7;
			uniqueKey.key[pos++] += (BYTE)XTBF( 8, 8, val);
			pos &= 0x7;
			uniqueKey.key[pos++] += (BYTE)XTBF(16, 8, val);
			pos &= 0x7;

			val = sessions[i].toc[j].GetNumberOfBlocks();
			uniqueKey.key[pos++] += (BYTE)XTBF( 0, 8, val);
			pos &= 0x7;
			uniqueKey.key[pos++] += (BYTE)XTBF( 8, 8, val);
			pos &= 0x7;
			uniqueKey.key[pos++] += (BYTE)XTBF(16, 8, val);
			pos &= 0x7;
			}
		}

#endif

	uniqueKey.valid = TRUE;
	GNRAISE_OK;
	}

//
//  Create iterator
//

Error CDFileSystem::CreateIterator(CDIterator * & cdi)
	{
	cdi = new CDIterator(this);
	if (cdi)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}

//
//  Create iterator
//

Error CDFileSystem::CreateIterator(GenericFileSystemIterator * & gfsi)
	{
	gfsi = new CDIterator(this);
	if (gfsi)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}

//
//  Create file
//

Error CDFileSystem::CreateFile(DWORD flags, GenericFile * & gf)
	{
	gf = new CDTrack(this);
	if (gf)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
	}

//
//  Create directory
//

Error CDFileSystem::CreateDirectory(DWORD flags, GenericDirectory * & gd)
	{
#if GFS_ENABLE_DIRECTORIES
	gd = new CDSession(this);
	if (gd)
		GNRAISE_OK;
	else
		GNRAISE(GNR_NOT_ENOUGH_MEMORY);
#else
	GNRAISE(GNR_UNIMPLEMENTED);
#endif
	}

//
//  Return start address of track
//

DWORD CDFileSystem::GetStartBlock(CDIterator * cdi)
	{
	if (cdi->session)
		return sessions[cdi->session - 1].toc[cdi->track].GetStartBlock();
	else
		return 0;
	}

//
//  Return the number of items in a dir
//

Error CDFileSystem::GetNumberOfItems(CDIterator * cdi, DWORD & num)
	{
	if (cdi->session)
		num = sessions[cdi->session].numTracks;
	else
		num = numSessions;
	GNRAISE_OK;
	}

//
// GetTrackType
//

CDTrackType	CDFileSystem::GetTrackType(CDIterator * cdi)
	{
	if (cdi->session)
		return sessions[cdi->session - 1].toc[cdi->track].GetTrackType();
	else
		return CTT_NONE;
	}

//
//  Go to first item in dir
//

Error CDFileSystem::GoToFirstItem(CDIterator * cdi)
	{
	cdi->track = 0;
	GNRAISE_OK;
	}

//
//  Go to next item in dir
//

Error	CDFileSystem::GoToNextItem(CDIterator * cdi)
	{
	if ((cdi->session && cdi->track == (sessions[cdi->session - 1].numTracks - 1)) ||		//  We are inside a session
		 (!cdi->session && cdi->track == numSessions - 1))												//  We are in root directory
		GNRAISE(GNR_ITEM_NOT_FOUND);

	cdi->track++;
	GNRAISE_OK;
	}

//
//  Enter directory
//

Error CDFileSystem::GoToSubDir(CDIterator * cdi, GenericFileSystemIterator * & gfsi)
	{
	if (cdi->session)
		{
		GNRAISE(GNR_ITEM_NOT_FOUND);
		}
	else
		{
		GNREASSERT(CreateIterator(gfsi));
		((CDIterator*)gfsi)->session = cdi->track + 1;
		((CDIterator*)gfsi)->track = 0;
		GNRAISE_OK;
		}
	}

//
//  Go to parent directory
//

Error	CDFileSystem::GoToParentDir(CDIterator * cdi, GenericFileSystemIterator * & gfsi)
	{
	if (cdi->session)
		return CreateIterator(gfsi);				// If we are inside session we go to root dir of file system
	else
		return mountPoint->Clone(gfsi);			// If we are in root dir we take iterator of parent
	}

//
//  Get current directory as object
//

Error	CDFileSystem::GetDir(CDIterator * cdi, GenericDirectory * & gd)
	{
	Error err;

	GNREASSERT(CreateDirectory(FAT_NONE, gd));
	if (IS_ERROR(err = gd->Open(cdi, DAT_NONE)))
		delete gd;

	GNRAISE(err);
	}

//
//  Get path name
//

Error CDFileSystem::GetPathName(CDIterator * cdi, DiskItemName & name)
	{
	if (cdi->session)
		name = DiskItemName(KernelString("/Session" + KernelString(cdi->session)));
	else
		name = DiskItemName("/");

	// go through mount point...
	if (this->mountPoint)
		{
		DiskItemName mpName;
		DiskItemName mpPath;
		this->mountPoint->GetPathName(mpPath);
		this->mountPoint->GetItemName(mpName);
		name = mpPath + (DiskItemName)"/" + mpName + name;
		}
	else
		{
		// no mount point? Should not be, but do not panic. Claim to be root...
		name = name;
		}


	GNRAISE_OK;
	}

//
//  Get type item pointed to
//

Error CDFileSystem::GetItemType(CDIterator * cdi, DiskItemType & type)
	{
	if (cdi->session)
		type = DIT_FILE;
	else
		type = DIT_DIR;

	GNRAISE_OK;
	}

//
//  Get name of item pointed to
//

Error CDFileSystem::GetItemName(CDIterator * cdi, DiskItemName & name)
	{
	if (cdi->session)
		name = (KernelString)"Track" + KernelString(cdi->track + 1);
	else
		name = (KernelString)("Session" + KernelString(cdi->track + 1) + (KernelString)name.GetDefaultSeparator());

	GNRAISE_OK;
	}

//
//  Get size of item pointed to
//

Error CDFileSystem::GetItemSize(CDIterator * cdi, KernelInt64 & size)
	{
	if (cdi->session)
		size = sessions[cdi->session - 1].toc[cdi->track].GetNumberOfBlocks() * blockSize;
	else
		size = 0;	// Directories (sessions in this case) don't have a size, as well as errors

	GNRAISE_OK;
	}

//
//  Get extended item information
//

Error CDFileSystem::GetExtItemInfo(GenericFileSystemIterator * gfsi, ExtItemInfo & info)
	{
	CDIterator * cdi = (CDIterator*)gfsi;

	if (cdi->session)
		{
		if (sessions[cdi->session - 1].toc[cdi->track].GetTrackType() == CTT_AUDIO)
			info.exType = EDIT_AUDIO_TRACK;
		else
			info.exType = EDIT_DATA_TRACK;
		}
	else
		info.exType = EDIT_NONE;

	GNRAISE_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\CDFile.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  CD Access Classes
//
////////////////////////////////////////////////////////////////////

#ifndef CDFILE_H
#define CDFILE_H

#include "library/Files/CDVDVolume.h"
#include "library/Files/ISOFile.h"

//
//  Forward declarations
//

class CDTrack;
class CDSession;
class CDIterator;
class CDFileSystem;

////////////////////////////////////////////////////////////////////
//
//  CDTrack Class
//
////////////////////////////////////////////////////////////////////

class CDTrack : public GenericFile
	{
	friend class CDFileSystem;

	protected:
		CDFileSystem * cdfs;
		CDIterator * cdi;

		DWORD startBlock;
		CDTrackType trackType;

		CDTrack(CDFileSystem * cdfs);

		virtual Error BuildUniqueKey(void);

	public:
		CDTrack(const CDTrack & track);
		virtual ~CDTrack(void);

		virtual Error Open(GenericFileSystemIterator * gfsi, DWORD accessType);
		virtual Error Close(void);

		//
		//  Misc. inquiry
		//

		virtual Error GetName(DiskItemName & name);
		virtual Error GetPathName(DiskItemName & name);
		virtual Error GetSize(KernelInt64 & size);
		virtual Error GetIterator(GenericFileSystemIterator * & gfsi);
		virtual Error GetCopyManagementInfo(GenericCopyManagementInfo & gcmi);

		//
		//  Access functions
		//

		virtual Error SeekBlock(DWORD block, DWORD flags, RequestHandle * rh);
		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
		virtual Error UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
	};

////////////////////////////////////////////////////////////////////
//
//  CD Session Class
//
////////////////////////////////////////////////////////////////////

#if GFS_ENABLE_DIRECTORIES

class CDSession : public GenericDirectory
	{
	friend class CDFileSystem;

	protected:
		CDFileSystem * cdfs;
		CDIterator * cdi;

		CDSession(CDFileSystem * cdfs);

	public:
		CDSession(const CDSession & cds);
		virtual ~CDSession(void);

		virtual Error Open(GenericFileSystemIterator * gfsi, DWORD accessType);
		virtual Error Close(void);

		//
		//  Inquiry
		//

		virtual Error GetName(DiskItemName & name);
		virtual Error GetPathName(DiskItemName & name);
		virtual Error GetIterator(GenericFileSystemIterator * & gfsi);

		//
		//  Item handling
		//

		virtual Error CreateItem(DWORD diskItemType, const DiskItemName & name, GenericDiskItem * & gdi);
		virtual Error DeleteItem(GenericFileSystemIterator * gfsi);

		virtual Error GetNumberOfItems(DWORD & num);
		virtual Error FindItem(const DiskItemName & name, DiskItemType type, DWORD flags, GenericFileSystemIterator * & gfsi);
	};

#endif

////////////////////////////////////////////////////////////////////
//
//  CD Iterator Class
//
////////////////////////////////////////////////////////////////////

class CDIterator : public GenericFileSystemIterator
	{
	friend class CDFileSystem;

	protected:
		CDFileSystem * cdfs;
		WORD session;		// The session we are currently in (0 is the root dir above all sessions)
		WORD track;			// The track (item) we point to (starting with 0)

		CDIterator(CDFileSystem * cdfs);

		virtual BOOL Equals(GenericFileSystemIterator * gfsi);

	public:
		CDIterator(const CDIterator & cdi);
		virtual ~CDIterator(void);

		virtual Error Clone(GenericFileSystemIterator * & gfsi) const;
		virtual Error Clone(CDIterator * & cdi) const;

		//
		//  Directory Handling
		//

		virtual Error	GoToFirstItem(void);
		virtual Error	GoToNextItem(void);
		virtual Error	GoToSubDir(GenericFileSystemIterator * & gfsi);
		virtual Error	GoToParentDir(GenericFileSystemIterator * & gfsi);

		//
		//  Inquiry
		//

		virtual Error GetPathName(DiskItemName & name);
		virtual Error GetItemType(DiskItemType & type);
		virtual Error GetItemName(DiskItemName & name);
		virtual Error GetItemSize(KernelInt64 & size);
		virtual Error GetNumberOfItems(DWORD & num);
		virtual Error GetCurrentDir(GenericDirectory * & gd);

		//
		//  File Access
		//

		virtual Error OpenItem(DWORD accessType, GenericDiskItem * & gdi);
	};

////////////////////////////////////////////////////////////////////
//
//  CD File System Class
//
////////////////////////////////////////////////////////////////////

class CDFileSystem : public GenericFileSystem
	{
	friend class CDTrack;
	friend class CDSession;
	friend class CDIterator;

	protected:
		CDVDVolume * cdvdVolume;

		//
		//  Information about a session
		//

		class CDSessionInfo
			{
			public:
				CDTocEntry			*	toc;				// TOC entries of session
				WORD						numTracks;		// Number of TOC entries in session
			};

		//
		//  Volume information
		//

		WORD					numSessions;			// Number of sessions of disk
		CDSessionInfo	*	sessions;				// Session information array

		//
		//  Factory Methods
		//

		virtual Error CreateIterator(CDIterator * & cdi);
		virtual Error CreateIterator(GenericFileSystemIterator * & gfsi);
		virtual Error CreateFile(DWORD flags, GenericFile * & gf);
		virtual Error CreateDirectory(DWORD flags, GenericDirectory * & gd);

		//
		//  Internal functions
		//

		DWORD GetStartBlock(CDIterator * cdi);
		Error BuildUniqueKey(void);
		virtual Error InitHeaderAndData(GenericVolume * volume);

		//
		//  Item Handling
		//

		Error GoToFirstItem(CDIterator * cdi);
		Error GoToNextItem(CDIterator * cdi);
		Error GoToSubDir(CDIterator * cdi, GenericFileSystemIterator * & gfsi);
		Error GoToParentDir(CDIterator * cdi, GenericFileSystemIterator * & gfsi);

		Error GetItemType(CDIterator * cdi, DiskItemType & type);
		Error GetItemName(CDIterator * cdi, DiskItemName & name);
		Error GetPathName(CDIterator * cdi, DiskItemName & name);
		Error GetItemSize(CDIterator * cdi, KernelInt64  & size);

		Error GetDir(CDIterator * cdi, GenericDirectory * & gd);
		Error GetNumberOfItems(CDIterator * cdi, DWORD & num);
		CDTrackType	GetTrackType(CDIterator * cdi);

	public:
		CDFileSystem(void);
		virtual ~CDFileSystem(void);

		virtual Error Init(GenericFileSystemIterator * mountPoint, GenericVolume * volume, GenericProfile * profile);

		virtual Error GetExtItemInfo(GenericFileSystemIterator * gfsi, ExtItemInfo & info);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\CDVDVolume.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  CDVD Volume Classes
//
////////////////////////////////////////////////////////////////////

#ifndef CDVDVOLUME_H
#define CDVDVOLUME_H

#include "library/Files/GenericVolume.h"

////////////////////////////////////////////////////////////////////
//
//  CDVD Volume Declaration
//
////////////////////////////////////////////////////////////////////

class CDVDVolume : public GenericVolume
	{
	protected:
		CDVDDrive * cdvdDrive;
		VolumeCache cache;
		BOOL isEncrypted;
		BOOL isEncryptedValid;

	public:
		CDVDVolume(void);
		virtual ~CDVDVolume(void);

		//
		//  Init
		//

		virtual Error Init(GenericDrive * drive, GenericProfile * profile);

		//
		//  Drive handling
		//

		virtual Error GetVolumeInfo(VolumeInfo & volumeInfo);

		//
		//  Data Access Methods
		//

		virtual Error LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);
		virtual Error UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh);

		//
		//  DVD Access Methods
		//

		virtual Error DVDIsEncrypted(BOOL & enc);
		virtual Error DoAuthenticationCommand(DVDAuthenticationCommand com, DWORD sector, BYTE * key);
		virtual Error GetRPCData(BOOL & isRPC2, BYTE & regionCode, BYTE & availSets);
		virtual Error SetRegionCode(BYTE region);

		//
		//  CD Access Methods
		//

		virtual Error GetNumberOfSessions(WORD & sessions);
		virtual Error ReadCDTOC(WORD session, CDSessionType & sessionType, CDTocEntry * & toc, WORD & tocEntryNum, RequestHandle * rh);
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\common\VirtUnit.h ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

//
// FILE:      library\common\virtunit.h
// AUTHOR:    U. Sigmund
// COPYRIGHT: (c) 1995 Viona Development.  All Rights Reserved.
// CREATED:   30.03.95
//
// PURPOSE:   Virtual and physical units
//
// A physical unit represents a shared physical hardware or software
// resource.  Several virtual units try to use the same resource at a time,
// but only one gets access.
//
// When a virtual unit requests access, but the physical unit is currently
// busy by an other virtual unit, the previous unit gets preempted.  The
// virtual units are responsible for storing the current state of the
// physical unit, so it can be reactivated, when the virtual unit gets in
// charge again.
//
// A virtual unit may prevent preemption by two means, first by locking
// the physical unit or second by returning FALSE to inquisitive calls.
//
// A virtual unit may be in any of (3/2) states:
//
//    Generalstate: passive  P the virtual unit does not compete
//                  active   A the virtual unit is currently preempted
//                  current  C the virtual unit owns the physical unit
//
//    Lockstate:    unlocked U the physical unit is not locked by this
//                             virtual unit
//                  locked   L the physical unit is currently locked
//                             by this virtual unit
//
//
// State transition:
// none or (s) : success, (f) : failed
//
// Initial Transition    Final   Actions performed
// State                 state
// ---------------------------------------------------------------------------
// PU      Lock(s)       PL      current->PreparePreempt() -> OK
//         Lock(f)       PU      current->PreparePreempt() -> FAIL
//         Activate(s)   CU      current->MayPreempt() -> OK
//                               current->IsPreempted()
//                               IsActivated()
//                               IsScheduled()
//                               Preempt(current)
//         Activate(f)   AU      current->MayPreempt() -> FAIL
//                               IsActivated()
//
// PL      Lock          PL
//         Unlock        PU      current->UnpreparePreempt()
//         Activate      CL      current->IsPreempted()
//                               IsActivated()
//                               IsScheduled()
//                               Preempt(current)
//
// AU      Lock(s)       AL      current->PreparePreempt() -> OK
//         Lock(f)       AU      current->PreparePreempt() -> FAIL
//         Activate(s)   CU      current->MayPreempt() -> OK
//                               current->IsPreempted()
//                               IsScheduled()
//                               Preempt(current)
//         Activate(f)   AU      current->MayPreempt() -> FAIL
//         Passivate     PU      IsPassivated()
//
// AL      Lock          AL
//         Unlock        AU      current->UnpreparePreempt()
//         Activate      CL      current->IsPreempted()
//                               IsScheduled()
//                               Preempt(current)
//         Passivate     PL      IsPassivated()
//
// CU      Lock(s)       CL
//         Lock(f)       CU
//         Passivate     PU      IsPreempted()
//                               IsPassivated()
//                               new->IsScheduled()
//                               new->Preempt(this)
//
// CL      Unlock        CU
//         Passivate     PL      IsPreempted()
//                               IsPassivated()
//                               new->IsScheduled()
//                               new->Preempt(this)
//
//
// Activation/Passivation sequence for preemptable use:
//
//   Activate()
//   ....
//   Passivate()
//
// Activation/Passivation sequence for nonpreemptable use:
//
//   Lock()
//   Activate()
//   ....
//   Unlock()
//   Passivate()
//
// To nonpreemptably lock a sequence of units, you need a two phase protocol:
//
//   if (!IS_ERROR(unit1->Lock()))
//     if (!IS_ERROR(unit2->Lock()))
//        if (!IS_ERROR(unit3->Lock()))
//          {
//          unit1->Activate(); // must succeed
//          unit2->Activate();
//          unit3->Activate();
//          ...
//          unit1->Unlock();
//          unit2->Unlock();
//          unit3->Unlock();
//          unit1->Passivate();
//          unit2->Passivate();
//          unit3->Passivate();
//          }
//        else
//          {
//          unit2->Unlock();
//          unit1->Unlock();
//          }
//      else
//        unit1->Unlock;
//
//
// HISTORY:
//
//

#ifndef VIRTUNIT_H
#define VIRTUNIT_H

#include "prelude.h"
#include "gnerrors.h"
#include "Tags.h"
#ifndef ONLY_EXTERNAL_VISIBLE
#include "library/general/Lists.h"
#endif

#define GNR_CAN_NOT_PASSIVATE_IDLE_UNIT			MKERR(ERROR,	UNITS,	OBJECT,	0x01)

#define GNR_OBJECT_NOT_CURRENT						MKERR(ERROR,	UNITS,	OBJECT,	0x02)

#define GNR_OBJECT_ALREADY_JOINED					MKERR(ERROR,	UNITS,	OBJECT,	0x03)

#define GNR_UNITS_BUSY									MKERR(ERROR,	UNITS,	BUSY,		0x04)

#define GNR_INVALID_UNITS								MKERR(ERROR,	UNITS,	PARAMS,	0x05)

#ifndef ONLY_EXTERNAL_VISIBLE

class VirtualUnit;

class PhysicalUnit : public TagClass
	{
	friend class VirtualUnit;
	private:
		VirtualUnit *	current;
		VirtualUnit	*	lockedBy;
		VirtualUnit *	old, * rep;

		enum {preemptNone, preemptInitial, preemptStopped, preemptChanged, preemptComplete} preemptState;

		List				preempted;
		int				lockCnt;

		Error InternalActivate(VirtualUnit * unit);
		BOOL InternalMayPreempt(VirtualUnit * unit);

		Error InternalPreemptBegin(VirtualUnit * unit);

		Error InternalPreemptStopPrevious(void);
		Error InternalPreemptChange(void);
		Error InternalPreemptStartNew(void);

		Error InternalPreemptComplete(void);

		void InternalPreemptFail(void);

		Error InternalPassivate(VirtualUnit * unit);
	public:
		PhysicalUnit(void);
		virtual ~PhysicalUnit(void);

		//
		// A successful lock implies no problem with the
		// current unit during a later activation.
		//
		virtual Error Lock(VirtualUnit * unit);
		virtual Error Unlock(VirtualUnit * unit);

		virtual Error Activate(VirtualUnit * unit);
		virtual Error Passivate(VirtualUnit * unit);

		virtual VirtualUnit * CreateVirtual(void) = 0;

		virtual Error Initialize(void) {GNRAISE_OK;}
		virtual Error ReInitialize(void) {GNRAISE_OK;}

		VirtualUnit * GetCurrent(void) {return current;}
	};

class VirtualUnit : public TagClass, Node
	{
	friend class PhysicalUnit;
	public:
		enum State {passive, active, current};
	private:
		PhysicalUnit *	physical;
		State			 	state;

		BOOL				preemptVisited;

		VirtualUnit	 * predLink, * succLink;

		int				useCount;
	protected:
		//
		// the one for parameter only devices
		//
		virtual Error Preempt(VirtualUnit * previous);

      virtual Error PreemptStopPrevious(VirtualUnit * previous) {GNRAISE_OK;}
      virtual Error PreemptChange(VirtualUnit * previous) {return Preempt(previous);}
      virtual Error PreemptStartNew(VirtualUnit * previous) {GNRAISE_OK;}

		//
		// Positive response to PreparePreempt implies
		// positive response on may preempt at any time
		// until Preempt or UnpreparePreempt.
		//
		virtual BOOL PreparePreempt(void) {return TRUE;}
		virtual void UnpreparePreempt(void) {;}

      virtual BOOL MayPreempt(void) {return TRUE;}
		virtual Error IsPreempted(void) {GNRAISE_OK;}
		virtual Error IsScheduled(void) {GNRAISE_OK;}
		virtual Error IsActivated(void) {GNRAISE_OK;}
		virtual Error IsPassivated(void) {GNRAISE_OK;}

	public:
		VirtualUnit(PhysicalUnit *	physical);
		virtual ~VirtualUnit(void);

		PhysicalUnit *	GetPhysical (void) {return physical;}

		Error Activate(void);
		Error Passivate(void);

		Error Lock(void);
		Error Unlock(void);

		Error Join(VirtualUnit * unit);
		Error Split(VirtualUnit * unit);

		State GetState(void) {return state;}

		void Obtain() {useCount++;}
		void Release() {useCount--;if (!useCount) {Passivate(); delete this;}}
	};


#define PREEMPT_START(type)	\
	{ type *	p = (type *)previous;	\

#define PREEMPT_END	}

#define PREEMPT_UPDATE(param, update)	\
	if (!p || p->param != param) update;

#endif // External visible

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\dvd\library\files\CDVDVolume.cpp ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Copyright 2000-2001 STMicroelectronics, Inc.  All Rights Reserved.         //
// HIGHLY CONFIDENTIAL INFORMATION:  This source code contains                //
// confidential and proprietary information of STMicroelectronics, Inc.       //
// This source code is provided to Microsoft Corporation under a written      //
// confidentiality agreement between STMicroelectronics and Microsoft.  This  //
// software may not be reproduced, distributed, modified, disclosed, used,    //
// displayed, stored in a retrieval system or transmitted in whole or in part,//
// in any form or by any means, electronic, mechanical, photocopying or       //
// otherwise, except as expressly authorized by STMicroelectronics. THE ONLY  //
// PERSONS WHO MAY HAVE ACCESS TO THIS SOFTWARE ARE THOSE PERSONS             //
// AUTHORIZED BY RAVISENT, WHO HAVE EXECUTED AND DELIVERED A                  //
// WRITTEN CONFIDENTIALITY AGREEMENT TO STMicroelectronics, IN THE FORM       //
// PRESCRIBED BY STMicroelectronics.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
//  CDVD Volume Class
//  Note that accesses to the drive are checked against genericDrive
//  since this might have been detached in GenericDrive
//
////////////////////////////////////////////////////////////////////

#include "CDVDVolume.h"

//
//  Constructor
//

CDVDVolume::CDVDVolume(void) : GenericVolume()
	{
	cdvdDrive = NULL;
	isEncryptedValid = FALSE;
	}

//
//  Destructor
//

CDVDVolume::~CDVDVolume(void)
	{
	if (genericDrive)
		{
		cache.Cleanup();
		}
	}

//
//  Init
//

Error CDVDVolume::Init(GenericDrive * drive, GenericProfile * profile)
	{
	VDAutoMutex mutex(&monitor);

	if (cdvdDrive)
		GNRAISE(GNR_OBJECT_IN_USE);

	GNREASSERT(GenericVolume::Init(drive, profile));
	GNREASSERT(cache.Init(drive, 64, maxBlockSize));
	this->cdvdDrive = (CDVDDrive*)drive;
	GNRAISE_OK;
	}

//
//  Get volume info
//

Error CDVDVolume::GetVolumeInfo(VolumeInfo & volumeInfo)
	{
	RequestHandle rh;
	WORD numSessions;
	WORD session;
	CDSessionType sessionType;
	CDTocEntry * toc;
	WORD tocEntryNum;
	WORD tocEntry;

	GNREASSERT(GenericVolume::GetVolumeInfo(volumeInfo));

	//
	//  Let's find out if there are audio tracks
	//

	GNREASSERT(cdvdDrive->GetNumberOfSessions(numSessions));

	for (session=1; session<=numSessions; session++)
		{
		GNREASSERT(ReadCDTOC(session, sessionType, toc, tocEntryNum, &rh));

		for (tocEntry=0; tocEntry<tocEntryNum; tocEntry++)
			{
			if (toc[tocEntry].GetTrackType() == CTT_AUDIO)
				{
				volumeInfo.attributes |= VIA_CONTAINS_AUDIO_TRACKS;
				session = numSessions;	// Terminate loop
				break;
				}
			}

		delete[] toc;
		}

	GNRAISE_OK;
	}

//
//  Lock blocks
//

Error CDVDVolume::LockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	VDAutoMutex mutex(&monitor);

	if (GD_COMMAND(flags) != DAT_LOCK_AND_READ)
		GNRAISE(GNR_UNIMPLEMENTED);

	if (GD_FLAGS(flags) & DAF_CACHED)
		return cache.LockBlocks(block, num, blocks, flags, rh);
	else
		{
		if (genericDrive)
			GNRAISE(cdvdDrive->LockBlocks(block, num, blocks, flags, rh));
		else
			GNRAISE(GNR_NO_DRIVE);
		}
	}

//
//  Unlock blocks
//

Error CDVDVolume::UnlockBlocks(DWORD block, DWORD num, DriveBlock * blocks, DWORD flags, RequestHandle * rh)
	{
	VDAutoMutex mutex(&monitor);

	if (GD_COMMAND(flags) != DAT_UNLOCK_CLEAN)
		GNRAISE(GNR_UNIMPLEMENTED);

	if (GD_FLAGS(flags) & DAF_CACHED)
		return cache.UnlockBlocks(block, num, blocks, flags, rh);
	else
		{
		if (genericDrive)
			GNRAISE(cdvdDrive->UnlockBlocks(block, num, blocks, flags, rh));
		else
			GNRAISE(GNR_NO_DRIVE);
		}
	}

//
//  Test if DVD is encrypted
//

Error CDVDVolume::DVDIsEncrypted(BOOL & enc)
	{
	VDAutoMutex mutex(&monitor);
	PhysicalDiskType type;

	if (!isEncryptedValid)
		{
		if (genericDrive)
			{
			//
			//  Check of we really have DVD. If not, then just pretend it's not encrypted.
			//

			GNREASSERT(cdvdDri