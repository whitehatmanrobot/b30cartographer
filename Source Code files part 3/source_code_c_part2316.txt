mov     esi,pGNCrtcCXOffset

        lfs     bx,ds:[esi].GNCRTCCX.lpCrtcModeInfo
        cmp     fs:[bx].MODEINFO.dwBpp,8
        jne     IsGamma

IsPal:
        lea     eax,[esi].GNCRTCCX.dwPaletteTable
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        push    eax
        pushd   0
        pushd   100H
        call    HW_SetPalette
        jmp     DoneIt

IsGamma:
        lea     eax,[esi].GNCRTCCX.dwGammaTable
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        push    eax
        pushd   0
        pushd   100H
        call    HW_SetGamma
DoneIt:
        mov     eax,1
        POPR    esi
CLOSEPROC

CLOSESEG  _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNDISABL.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gndisabl.asm
;
; Purpose:      This file holds the Disable display driver entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc
include minivdd.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GENERIC_Disable
;
; Purpose:      This function is the Disable display driver entry point.
;               It handles proper device disabling in a multi-monitor
;               environment.
;
; Arguments:    lpDstDev  - The device to disable.
;
; Returns:      eax     should always be set to -1
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_Disable, PASCAL, FRAME, FAR16
PARMD   lpDstDev
LOCALD  dwRet
LOCALD  dwVddDeviceHandle
OPENPROC
        PUSHR   ds,esi,edi
        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]

        ; Split into primary and secondary cases
        cmp     cs:[dwThisLogicalDeviceHandle_In_NVTEXT16],1
        je      AsIfPrimary

        ; Enable access to the secondary device
        mov     dwRet,0
        pushd   ENABLE_ALL
        call    GN_VddEnableDevice
        cmp     eax,ENABLE_ERROR
        je      done

AsIfPrimary:
        ; This is either the primary device or it is a secondary device
        ; with full access turned on. We can disable the device now.
        push    esi
        call    GN_DisableDevice
        mov     dwRet,eax

        ; If we are a secondary, we have a few things to clean up.
        cmp     cs:[dwThisLogicalDeviceHandle_In_NVTEXT16],1
        je      done

        ; Turn off all access to our device.
        pushd   ENABLE_NONE
        call    GN_VddEnableDevice

        ; We are done with the secondary device -- close it
        call    GN_VddCloseDevice
done:
        mov     eax,dwRet
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_DisableDevice
;
; Purpose:      This function does the disabling once a specific device has
;               been selected.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX
;
; Returns:      eax     should always be set to -1
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_DisableDevice, PASCAL, FRAME, NEAR
PARMD   pGNLogdevCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pGNLogdevCXOffset

        ; If we are not "attached to the desktop", then
        ; don't blank the screen.
        call    GN_VddIsDriverAttachedToDesktop
        or      ax,ax
        je      SkipBlankScreen

        ; Don't access to the FB if we're in powerdown
        cmp     ds:[esi].GNLOGDEVCX.dwInt2FScreenSwitchOut,0
        jne     SkipBlankScreen
        
        push    pGNLogdevCXOffset
        call    GN_BlankScreen

SkipBlankScreen:
        ; Let the DIBENG do its thing
        push    cs:[CSlp16LogDevice_In_NVTEXT16]
        call    DIB_Disable

        ; Send a message down to disable the device
        push    esi
        pushd   MSG_DISABLE
        push    esi
        push    cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        call    GN_LogdevMessage

        ; Free the primary surface memory.
        cmp     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        je      @F
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_FreeLogicalSurface
        
        ; Don't access to the FB if we're in powerdown
        cmp     ds:[esi].GNLOGDEVCX.dwInt2FScreenSwitchOut,0
        jne     SkipBlankScreen1
        
        ; Blank the screen. If we just rely on the earlier GN_BlankScreen,
        ; then when we free the logical surface, tiling may be disabled which
        ; can cause garbage on the screen. However, if we don't do the earlier
        ; GN_BlankScreen, we get a flash of garbage when the surface is
        ; untiled.
        push    pGNLogdevCXOffset
        call    GN_BlankScreen

SkipBlankScreen1:
        mov     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
@@:

        ; Enable IO trapping if we are not a secondary device.
        ; The GN_VddEnableIOTrapping checks the device ID.
        pushd   1
        call    GN_VddEnableIOTrapping
        POPR    esi

        ; Return Success
        mov     eax,-1
CLOSEPROC


;==============================================================================
;
; Function:     GN_BlankScreen
;
; Purpose:      This function blts black to the screen.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX
;
; Returns:
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_BlankScreen, PASCAL, FRAME, NEAR
PARMD   pGNLogdevCXOffset
OPENPROC
        PUSHR   ds,es,esi,edi

        ; Clear the screen to black so there won't be wierd artifacts
        ; if we switch back to a lower resolution mode.
        mov     esi,pGNLogdevCXOffset

        ; Make sure we have the primary surface
        cmp     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        je      GN_BlankScreen_Exit

        ; Check DOS FS or power state.
        cmp     ds:[esi].GNLOGDEVCX.dwInt2FScreenSwitchOut,0
        jne     GN_BlankScreen_Exit

        ; We can't use DIBENG at this point because
        ; CSpGNLogicalDevice_In_NVTEXT16 not initialize yet.
        mov     ecx,ds:[esi].DIBENGINE.deDeltaScan
        movzx   ebx,word ptr ds:[esi].DIBENGINE.deHeight
        imul    ecx,ebx
        shr     ecx,2
        mov     es,ds:[esi].DIBENGINEHDR.deBitsSelector
        mov     edi,ds:[esi].DIBENGINEHDR.deBitsOffset
        sub     eax,eax
        rep     stos dword ptr es:[edi]

GN_BlankScreen_Exit:
        POPR    ds,es,esi,edi
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNENABLE.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnenable.asm
;
; Purpose:      This file holds the Enable and ReEnable display driver
;               entry points.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc
include escape.inc
include minivdd.inc
include modeext.inc

; Keep the caps we are supporting here for ease of modification
CAPS_C1         TEXTEQU <C1_DIBENGINE + C1_REINIT_ABLE + C1_COLORCURSOR + C1_GLYPH_INDEX + C1_GAMMA_RAMP>
CAPS_CLIP       TEXTEQU <CP_RECTANGLE>
CAPS_CURVE      TEXTEQU <0>
CAPS_LINE       TEXTEQU <LC_POLYLINE + LC_STYLED + LC_POLYSCANLINE>
CAPS_POLYGONAL  TEXTEQU <PC_SCANLINE + PC_ALTPOLYGON + PC_RECTANGLE + PC_WINDPOLYGON + PC_INTERIORS>
CAPS_RASTER     TEXTEQU <RC_BITBLT + RC_BITMAP64 + RC_GDI20_OUTPUT + RC_DI_BITMAP + RC_DIBTODEV + RC_BIGFONT + RC_STRETCHBLT + RC_STRETCHDIB + RC_OP_DX_OUTPUT + RC_SAVEBITMAP + RC_DEVBITS>
CAPS_TEXT       TEXTEQU <TC_CP_STROKE + TC_RA_ABLE>

; For different resolutions, we need to give GDI different Window/Viewport
; scaling combinations. There is an array of data in the following format
; located in this file -- each element in the array is for a different
; screen resolution.
METRICDATA      STRUCT
        wMetLowX        DW      0
        wMetLowY        DW      0
        wEngLowX        DW      0
        wEngLowY        DW      0
        wEngHighX       DW      0
        wEngHighY       DW      0
        wTwipX          DW      0
        wTwipY          DW      0
METRICDATA      ENDS


OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA


OPENSEG  _NVTEXT16, USE16, CODE

ALIGN 2
PUBLIC  sMetricData
sMetricData  LABEL   METRICDATA
;       nXres,  nYres,  nEngLoX nEngLoY,nEngHiX,nEngHiY,nTwipX, nTwipY
DW      320,    200,    127,    127,    64,     64,     64,     64
DW      640,    480,    254,    254,    127,    127,    127,    127
DW      800,    600,    318,    318,    159,    159,    159,    159
DW      1024,   768,    407,    407,    203,    203,    203,    203
DW      1280,   1024,   509,    509,    254,    254,    254,    254
DW      1152,   864,    457,    457,    230,    230,    230,    230
DW      1600,   1200,   635,    635,    320,    320,    320,    320
DW      2048,   1536,   635,    635,    320,    320,    320,    320
DW      0

IFDEF DEBUG
szReEnable      DB      'DISPLAY:GENERIC_ReEnable',0DH,0AH,0
szEnable        DB      'DISPLAY:GENERIC_Enable',0DH,0AH,0
ENDIF

;==============================================================================
;
; Function:     GENERIC_ReEnable
;
; Purpose:      This function is the ReEnable display driver entry point.
;               Mostly it just sequences the two Enable calls to do the
;               ReEnable plus a few extra things unique to ReEnable.
;
; Arguments:    ReEnable Display Driver Stack Frame
;
; Returns:      ax      0       then failure
;                       non-0   then success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_ReEnable, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMD   lpGdiInfoA
LOCALS  dwTempPalette,400H
OPENPROC
        PUSHR   ds,esi,edi

IFDEF DEBUG
        mov     ax,cs
        shl     eax,10H
        lea     ax,szReEnable
        push    eax
        call    GENERIC_OutputDebugString
ENDIF

        ; Load up the GNLOGDEVCX
        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]

        cmp     ds:[esi].GNLOGDEVCX.bSetModeBypass,0
        je      @F
        mov     ds:[esi].GNLOGDEVCX.bSetModeBypass,0
        jmp     Bypass_ReEnable

@@:
        ; Save the ptr to the GDIINFO table in case it has changed
        mov     eax,lpGdiInfoA
        mov     ds:[esi].GNLOGDEVCX.lpGdiInfo,eax

        ; Save off the palette in case we need to restore it later
        mov     ax,ss
        mov     es,ax
        lea     edi,dwTempPalette
        lea     esi,[esi].GNLOGDEVCX.dwPalette
        mov     ecx,100H
        rep     movs dword ptr es:[edi], ds:[esi]

        ; The DIBENG is clobbering the spotsize which should only be
        ; touched by GDI so we save and restore it around the call.
        lds     di,lpGdiInfoA
        push    ds:[edi].GDIINFO.dpSpotSizeX
        push    ds:[edi].GDIINFO.dpSpotSizeY

        ; Do the GDIINFO flavor of the enable call.
        sub     eax,eax
        mov     ecx,1
        push    lpGdiInfoA
        push    cx
        push    eax
        push    eax
        inc     eax
        push    eax
        call    GENERIC_Enable

        ; Here is where the Restore happens.
        pop     ds:[edi].GDIINFO.dpSpotSizeY
        pop     ds:[edi].GDIINFO.dpSpotSizeX

        ; Do the Enable Device flavor of the enable call.
        sub     eax,eax
        push    lpDstDev
        push    ax
        push    eax
        push    eax
        inc     eax
        push    eax
        call    GENERIC_Enable

        ; Restore and set the palette if we are palettized.
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]
        mov     es,cs:[wFlatDataSel_In_NVTEXT16]
        test    es:[esi].GNLOGDEVCX.Dibeng.deFlags,PALETTIZED
        jz      @F

        ; Restore the palette we saved off
        ; This palette is not the one that actually gets set
        ; into the hardware. That palette in in the CRTC objects
        ; and their palette does not get trashed. Hence, there is
        ; no need to resend the palette to the CRTC objects.
        lea     edi,[esi].GNLOGDEVCX.dwPalette
        mov     ax,ss
        mov     ds,ax
        lea     esi,dwTempPalette
        mov     ecx,100H
        rep     movs dword ptr es:[edi], ds:[esi]
@@:

Bypass_ReEnable:
        mov     eax,1
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GENERIC_Enable
;
; Purpose:      This function is the Enable display driver entry point.
;               It deals with multi-monitor stuff and then hands off to
;               the real enable routine which implements the enable
;               for the selected device.
;
; Arguments:    Enable Display Driver Stack Frame
;
; Returns:      ax      0       then failure
;                       non-0   then success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_Enable, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wAction
PARMD   lpDstDevType
PARMD   lpOutputFile
PARMD   lpData
OPENPROC
        PUSHR   ds,esi,edi

IFDEF DEBUG
        mov     ax,cs
        shl     eax,10H
        lea     ax,szEnable
        push    eax
        call    GENERIC_OutputDebugString
ENDIF

        ; This is one of the two functions in the driver that can be
        ; called first. If we haven't initted yet, we must do it now.
        cmp     cs:[wNVTEXT32_Alias_In_NVTEXT16],0
        jne     @F
        push    lpDstDevType
        push    lpDstDev                ; GDIINFO PTR the first time.
        call    GN_DllEntryPoint
        or      eax,eax
        je      DoneIt
@@:
        ; Load up the GNLOGDEV
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]
        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]

        ; Which case is it? Primary or secondary
        mov     eax,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        cmp     eax,1
        je      AsIfPrimary

        ; We are a secondary card. Hence, we must first enable access
        ; to the board. If we are truly multi-monitor compliant, we
        ; can just enable Memory access and leave it on all the time.
        ; If we use I/O (in or out) instructions anywhere, this won't
        ; work because I will not Enable I/O access to the board.
        pushd   ENABLE_MEM
        call    GN_VddEnableDevice
        cmp     eax,ENABLE_ERROR
        je      Exit_Fail

AsIfPrimary:
        ; At this point, we are either primary, or we are secondary and
        ; Memory accesses to our board have been enabled. Hence, we can
        ; now dispatch to the correct subfunction.
        ; Split based on action.
        push    esi
        push    lpDstDev
        push    wAction
        push    lpDstDevType
        push    lpOutputFile
        push    lpData

        push    OFFSET DoneIt
        movzx   eax,wAction
        test    al,1
        jz      GN_EnableDevice
        jmp     GN_EnableGdiInfo

Exit_Fail:
        sub     eax,eax
DoneIt:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_EnableGdiInfo
;
; Purpose:      This function is jumped to from the Enable display driver
;               entry point once it is known that the flavor of the call
;               is to get the GDIINFO table.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX offset
;
; Returns:      ax      0       then failure
;                       non-0   then success
;
; Preserve:     esi,edi
;==============================================================================
DECPROC GN_EnableGdiInfo, PASCAL, FRAME, NEAR
PARMD   pGNLogdevCXOffset
PARMD   lpThisGdiInfo
PARMW   wAction
PARMD   lpDstDevType
PARMD   lpOutputFile
PARMD   lpData
OPENPROC
        PUSHR   esi,edi

        ; Let the DIBENG do its own thing
        push    lpThisGdiInfo
        push    wAction
        push    lpDstDevType
        push    lpOutputFile
        push    lpData
        call    DIB_Enable

        PUSHR   ds

        sub     esi,esi
        lds     si,lpThisGdiInfo
        mov     ds:[esi].GDIINFO.dpVersion,400H
        mov     ds:[esi].GDIINFO.dpTechnology,DT_RASDISPLAY
        mov     ds:[esi].GDIINFO.dpHorzSize,208
        mov     ds:[esi].GDIINFO.dpVertSize,156
;        mov     ds:[esi].GDIINFO.dpHorzRes
;        mov     ds:[esi].GDIINFO.dpVertRes
;        mov     ds:[esi].GDIINFO.dpBitsPixel
        mov     ds:[esi].GDIINFO.dpPlanes,1
        mov     ds:[esi].GDIINFO.dpNumBrushes,-1
        mov     ds:[esi].GDIINFO.dpNumPens,20*5
        mov     ds:[esi].GDIINFO.dpCapsFE,0
        mov     ds:[esi].GDIINFO.dpNumFonts,0
        mov     ds:[esi].GDIINFO.dpNumColors,-1
        mov     ds:[esi].GDIINFO.dpDEVICEsize,SIZE GNLOGDEVCX
        mov     ds:[esi].GDIINFO.dpCurves,CAPS_CURVE
        mov     ds:[esi].GDIINFO.dpLines,CAPS_LINE
        mov     ds:[esi].GDIINFO.dpPolygonals,CAPS_POLYGONAL
        mov     ds:[esi].GDIINFO.dpText,CAPS_TEXT
        mov     ds:[esi].GDIINFO.dpClip,CAPS_CLIP
        mov     ds:[esi].GDIINFO.dpRaster,CAPS_RASTER
        mov     ds:[esi].GDIINFO.dpAspectX,10
        mov     ds:[esi].GDIINFO.dpAspectY,10
        mov     ds:[esi].GDIINFO.dpAspectXY,14
        mov     ds:[esi].GDIINFO.dpStyleLen,28

        ; Based upon the screen resolution, we need to find
        ; the best set of Window/Viewport scalings.
        mov     ebx,OFFSET sMetricData
@@:     mov     ax,cs:[ebx].METRICDATA.wMetLowX
        cmp     ax,ds:[esi].GDIINFO.dpHorzRes
        je      Match
        add     ebx,SIZE METRICDATA
        cmp     cs:[ebx].METRICDATA.wMetLowX,0
        jne     @B
        mov     ebx,OFFSET sMetricData
Match:
        mov     ds:[esi+0].GDIINFO.dpMLoWin,2080
        mov     ds:[esi+2].GDIINFO.dpMLoWin,1560
        mov     ax,cs:[ebx].METRICDATA.wMetLowY
        mov     dx,cs:[ebx].METRICDATA.wMetLowX
        neg     ax
        mov     ds:[esi+0].GDIINFO.dpMLoVpt,dx
        mov     ds:[esi+2].GDIINFO.dpMLoVpt,ax

        mov     ds:[esi+0].GDIINFO.dpMHiWin,20800
        mov     ds:[esi+2].GDIINFO.dpMHiWin,15600
        mov     ds:[esi+0].GDIINFO.dpMHiVpt,dx
        mov     ds:[esi+2].GDIINFO.dpMHiVpt,ax

        mov     ds:[esi+0].GDIINFO.dpELoWin,325
        mov     ds:[esi+2].GDIINFO.dpELoWin,325
        mov     ax,cs:[ebx].METRICDATA.wEngLowY
        neg     ax
        mov     ds:[esi+2].GDIINFO.dpELoVpt,ax
        mov     ax,cs:[ebx].METRICDATA.wEngLowX
        mov     ds:[esi+0].GDIINFO.dpELoVpt,ax

        mov     ds:[esi+0].GDIINFO.dpEHiWin,1625
        mov     ds:[esi+2].GDIINFO.dpEHiWin,1625
        mov     ax,cs:[ebx].METRICDATA.wEngHighY
        neg     ax
        mov     ds:[esi+2].GDIINFO.dpEHiVpt,ax
        mov     ax,cs:[ebx].METRICDATA.wEngHighX
        mov     ds:[esi+0].GDIINFO.dpEHiVpt,ax

        mov     ax,cs:[ebx].METRICDATA.wTwipY
        neg     ax
        mov     ds:[esi+2].GDIINFO.dpTwpVpt,ax
        mov     ax,cs:[ebx].METRICDATA.wTwipX
        mov     ds:[esi+0].GDIINFO.dpTwpVpt,ax
        mov     ds:[esi+0].GDIINFO.dpTwpWin,2340
        mov     ds:[esi+2].GDIINFO.dpTwpWin,2340

        ; Always set to 96 right now. GDI overrides this as needed.
        mov     ax,96
        mov     ds:[esi].GDIINFO.dpLogPixelsX,ax
        mov     ds:[esi].GDIINFO.dpLogPixelsY,ax

        ; The display driver doesn't use File Name Pair matching
        mov     ds:[esi].GDIINFO.dpDCManage,DC_IgnoreDFNP

        ; The CAPS_C1 are at the top of the file.
        mov     ds:[esi].GDIINFO.dpCaps1,CAPS_C1

        mov     es,cs:[wFlatDataSel_In_NVTEXT16]
        mov     edi,pGNLogdevCXOffset
        mov     eax,es:[edi].GNLOGDEVCX.dwFontFormat
        or      ds:[esi].GDIINFO.dpCaps1,ax

        ; The dpSpotSize are set by GDI, not the driver -- do not touch!
        ; mov    ds:[esi].GDIINFO.dpSpotSizeX
        ; mov    ds:[esi].GDIINFO.dpSpotSizeY

        ; The color resolution. We will always be 8 bits per gun.
        mov     ds:[esi].GDIINFO.dpColorRes,24

        mov     ecx,pGNLogdevCXOffset
        mov     eax,lpThisGdiInfo
        mov     es:[ecx].GNLOGDEVCX.lpGdiInfo,eax

        ; Set the desktop mode first.
        PUSHR   es
        POPR    ds
        push    ecx
        call    GN_GetLogicalAndPhysicalModes

        ; Reload stuff after the call
        sub     esi,esi
        lds     si,lpThisGdiInfo
        mov     es,cs:[wFlatDataSel_In_NVTEXT16]

        ; If we are not PALETTE_MANAGED, then clear out palette fields
        cmp     ds:[esi].GDIINFO.dpBitsPixel,8
        je      IsPal
        sub     eax,eax
        mov     ds:[esi].GDIINFO.dpNumPalReg,ax
        mov     ds:[esi].GDIINFO.dpPalReserved,ax
        mov     ds:[esi].GDIINFO.dpColorRes,ax
        jmp     @F
IsPal:  mov     ds:[esi].GDIINFO.dpNumPalReg,256
        or      ds:[esi].GDIINFO.dpRaster,RC_PALETTE
        mov     ds:[esi].GDIINFO.dpPalReserved,20
        mov     ds:[esi].GDIINFO.dpNumColors,20
        mov     ebx,es:[edi].GNLOGDEVCX.pGNCrtcCX
        mov     eax,es:[ebx].GNCRTCCX.dwBitsPerColorChannel
        imul    eax,3
        mov     ds:[esi].GDIINFO.dpColorRes,ax
@@:
        POPR    ds

        ; Give the correct return value
        mov     eax,SIZE GDIINFO

        POPR    esi,edi
CLOSEPROC

;==============================================================================
;
; Function:     GN_EnableDevice
;
; Purpose:      This function is jumped to from the Enable display driver
;               entry point once it is known that the flavor of the call
;               is to Enable the Physical Device.  (Actually this flavor
;               of call breaks out into two itself -- Enable the device
;               or just return the device context.)
;
; Arguments:    Enable Display Driver Stack Frame
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX offset
;
; Returns:      ax      0       then failure
;                       non-0   then success
;
; Preserve:     ss,ebp,esp
;==============================================================================
DECPROC GN_EnableDevice, PASCAL, FRAME, NEAR
PARMD   pGNLogdevCXOffset
PARMD   lpDstDevice
PARMW   wAction
PARMD   lpDstDevType
PARMD   lpOutputFile
PARMD   lpData
LOCALD  dwCRTCCount
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset

        call    GN_CheckInterlacedStereoConnection
        mov     ds:[esi].GNLOGDEVCX.bInterlacedStereo, al
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ecx].GNBOARDCX.pHWBoardCX
        push    eax
        call    NV_SetInterlacedStereoMode

        ; The high bit of the Action argument tells whether or not to
        ; enable the hardware or simply return the device context.
        movzx   eax,wAction
        test    ah,80H
        jz      EnableDev

GetDeviceContext:
        mov     esi,pGNLogdevCXOffset
        sub     edi,edi
        les     di,lpDstDevice
        mov     ecx,SIZE GNLOGDEVCX
        rep     movs byte ptr es:[edi], ds:[esi]
        jmp     DoneIt

EnableDev:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Everything in the driver is based upon the GNLOGDEVCX as the
        ; sole piece of context data. Before the very first time this
        ; function is called, however, we technically do not yet have
        ; a GNLOGDEVCCX. A temporary one was initalized at driver load
        ; time and has been used up to this point. We copy over the
        ; template to the one passed in here and reassign the ptr to
        ; the real GNLOGDEVCX.
        mov     eax,lpDstDevice
        shr     eax,10H
        push    eax
        call    GN_GetSelectorBase
        cmp     eax,pGNLogdevCXOffset
        je      DoneFirst

        ; Copy the GNLOGDEVCX over to the new ptr
        mov     esi,pGNLogdevCXOffset
        sub     edi,edi
        les     di,lpDstDevice
        mov     ecx,SIZE GNLOGDEVCX
        rep     movs byte ptr es:[edi], ds:[esi]

        ; Free the old ptr
        mov     esi,eax
        push    pGNLogdevCXOffset
        call    HW_FreeFlatMemory

        ; Load these up
        mov     es,cs:[wNVTEXT16_Alias_In_NVTEXT16]
        mov     fs,cs:[wNVTEXT32_Alias_In_NVTEXT16]

        ; Set the new ptr
        mov     es:[CSpGNLogicalDevice_In_NVTEXT16],esi
        mov     fs:[CSpGNLogicalDevice],esi

        ; Also fill these in
        mov     eax,lpDstDevice
        mov     es:[CSlp16LogDevice_In_NVTEXT16],eax
        mov     fs:[CSlp16LogDevice],eax
        mov     ds:[esi].GNLOGDEVCX.Dibeng.delpPDevice,eax

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Let everyone know that Logical device has moved.
        push    esi
        pushd   MSG_LOGDEVMOVED
        push    esi                             ; push new prt
        push    pGNLogdevCXOffset               ; push old ptr
        call    GN_LogdevMessage
        mov     pGNLogdevCXOffset,esi
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DoneFirst:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Ugh! If we are not "attached to the desktop", then
        ; don't set the mode! We might not have any CRTCCXs
        ; if we are not attached to the desktop.
        call    GN_VddIsDriverAttachedToDesktop
        or      ax,ax
        je      DoneIt
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ; Do not get any modes from the registry, etc. All the GDIINFO
        ; stuff and mode fetching should have been snapshotted at
        ; GetGdiInfo time. In this call, just set whatever is in the
        ; CRTCCXs. Some weird apps and WHQL stuff just call Enable and
        ; not ReEnable after going out to a DOS box. They expect that
        ; to just reset the mode that existed before the DOS box.

        push    esi
        call    GN_SetLogicalAndPhysicalModes

        ; Make sure we turn off busy so we can paint to the screen.
        and     ds:[esi].GNLOGDEVCX.Dibeng.deFlags,NOT BUSY
        mov     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0

        ; Register the driver with the VDD
        call    GN_VddDriverRegister

        ; Tell the VDD to save the driver state
        call    GN_VddSaveDriverState

        ; Disable IO trapping if we are not a secondary device.
        ; The GN_VddEnableIOTrapping checks the device ID.
        sub     eax,eax
        push    eax
        call    GN_VddEnableIOTrapping

        ; We need to force all logical devices to redraw themselves
        ; since all the desktops may have been repositioned in
        ; video memory.
        push    esi
        call    GN_UserRepaint

        ; We let the driver load if it is disabled, but we don't
        ; give it a GNCRTCCX. Protect against NULL ptr.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        or      ebx,ebx
        je      DoneIt

IF DIB_FAST_EXIT
        ; Init the Fast Exit Stiff for DIBS
        push    ds:[ebx].GNCRTCCX.lpNvmodeDispData
        call    GN_InitDibFastExit
ENDIF

DoneIt:
        ; Return Success
        mov     eax,-1
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetLogicalAndPhysicalModes
;
; Purpose:      This function gets the logical (GDIINFO or desktop) mode
;               as well as the physical modes for all the CRTCs attached
;               to the logical device.
;
; Arguments:
;               ds                      CXSel
;               pGNLogdevCXOffset       GNLOGDEVCX offset
;               lpThisGdiInfo
;
; Returns:
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetLogicalAndPhysicalModes, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
LOCALW  wForcedModePresent
LOCALV  sDispInfo,DISPLAYINFO
LOCALD  lpDispInfo
LOCALV  sDesktopModeInfo,MODEINFO
LOCALD  lpDesktopModeInfo
LOCALD  dwSettableModeFreeBlockSize
LOCALD  dwMemoryNeededFor640x480x8
LOCALS  LocalDevData,(MAX_ATTACHED_CRTCS*4)
LOCALD  lpLocalDevData
LOCALS  aHWCrtcCX,(MAX_ATTACHED_CRTCS*4)
LOCALD  lpHWCrtcCX
LOCALS  aGNCrtcCX,(MAX_ATTACHED_CRTCS*4)
LOCALD  lpGNCrtcCX
LOCALD  dwOriginalXRes
LOCALD  dwOriginalYRes
LOCALD  dwCloneRefreshRate
LOCALW  wClone
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Build some things we will need
        mov     ax,ss
        shl     eax,10H
        lea     ax,sDispInfo
        mov     lpDispInfo,eax
        lea     ax,sDesktopModeInfo
        mov     lpDesktopModeInfo,eax
        lea     ax,LocalDevData
        mov     lpLocalDevData,eax
        lea     ax,aHWCrtcCX
        mov     lpHWCrtcCX,eax
        lea     ax,aGNCrtcCX
        mov     lpGNCrtcCX,eax

        ; We will be needing this
        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[eax].GNBOARDCX.pHWBoardCX
        pushd   640
        pushd   480
        pushd   8
        call    HW_GetModeDimensions
        mov     dwMemoryNeededFor640x480x8,ebx
        
        ; Get the registry key for clone behavior
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetCloneDesktopSelection,es,ax
        mov     wClone,ax

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Get the Desktop mode that the system wants to set
        ; This is the LOGICAL DEVICE mode.
        push    lpDispInfo
        pushd   VDD_GET_DISPLAY_CONFIG
        call    GN_VddGetDisplayInfo

        ; Microsoft uses a 0 return for the refresh rate to indicate
        ; that we should make the CONFIG2 call for display res info.
        cmp     sDispInfo.diRefreshRateMax,0
        jne     @F
        push    lpDispInfo
        pushd   VDD_GET_DISPLAY_CONFIG2
        call    GN_VddGetDisplayInfo
@@:
        ; Save the xres,yres that Windows wants us to set
        sub     ecx,ecx
        lfs     cx,lpDispInfo
        mov     eax,dword ptr fs:[ecx].DISPLAYINFO.diXRes
        mov     dword ptr ds:[esi].GNLOGDEVCX.wWindowsXRes,eax

        ; Make sure that the mode Windows is asking us for
        ; hasn't been wierdly modified by Windows. If it has,
        ; then correct it to our real mode.
        mov     ebx,lpDispInfo
        lea     eax,[ebx].DISPLAYINFO.diXRes
        push    eax
        lea     eax,[ebx].DISPLAYINFO.diYRes
        push    eax
        call    GN_CheckForMultipleOf8Mode

        ; Peg the pixel depth to something we can handle
        sub     ecx,ecx
        lfs     cx,lpDispInfo
        mov     al,fs:[ecx].DISPLAYINFO.diBpp
        cmp     al,08H
        je      @F
        cmp     al,10H
        je      @F
        cmp     al,20H
        je      @F
        mov     al,08H
@@:     mov     fs:[ecx].DISPLAYINFO.diBpp,al

        ; Get this into a MODEINFO format which we need later
        sub     ebx,ebx
        les     bx,lpDesktopModeInfo
        movzx   eax,fs:[ecx].DISPLAYINFO.diXRes
        mov     es:[ebx].MODEINFO.dwXRes,eax
        mov     dwOriginalXRes,eax
        movzx   eax,fs:[ecx].DISPLAYINFO.diYRes
        mov     es:[ebx].MODEINFO.dwYRes,eax
        mov     dwOriginalYRes,eax
        movzx   eax,fs:[ecx].DISPLAYINFO.diBpp
        mov     es:[ebx].MODEINFO.dwBpp,eax

        ; Ugh! If we are not "attached to the desktop", then
        ; don't set the mode! We might not have any CRTCCXs
        ; if we are not attached to the desktop.
        call    GN_VddIsDriverAttachedToDesktop
        or      ax,ax
        je      JustRes
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Is this a first boot (are we initting still?)
        cmp     ds:[esi].GNLOGDEVCX.dwInitting,0
        je      NotInit0

        ; OK, this is a pain. There is one circumstance under
        ; which we do not want to set the desktop mode that
        ; Windows is asking us to. If the user changed the color
        ; depth, but said, reboot to make it happen, then we might
        ; not set what Windows asks. Why? Because, suppose the user
        ; changed the color depth on the CRT and asked for a reboot.
        ; Then the user unplugs the CRT and goes with a DFP and
        ; boots up.  The color depth switch does not apply to the
        ; DFP, but rather the "Shutdown device" which was the CRT.
        ; No biggie, this scenario will only happen on boot. All
        ; we need to do is write out the mode Windows is asking us
        ; to boot in to the Shutdown device. If the shutdown device
        ; is the current device, that is OK.

        ; OK, what device did we shut down on last time?
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    ds:[esi].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard
        pushd   0
        push    lpLocalDevData
        CALLFAR16IND lpfnGetDisplayDevice,es,ax

        ; If there was no physical device 0 on this logical device,
        ; then don't worry about it.
        or      ax,ax
        je      NotInit0
        
        ; Get the TV Format for this device from the ResMan. Please note
        ; if this device is not a TV, this function will return 0.
        mov     eax,dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    ds:[eax].GNCRTCCX.pHWCrtcCX
        push    dword ptr LocalDevData
        call    HW_GetResManTvFormat
        shl     eax,10h
        and     dword ptr LocalDevData,0ff00ffffh
        or      dword ptr LocalDevData,eax

        ; Write out the desired desktop mode for that device
        mov     eax,dword ptr LocalDevData
        mov     sDesktopModeInfo.MIDevData,eax
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    lpDesktopModeInfo
        mov     eax,0
        cmp     wClone,1
        jne     @F
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,2
        jl      @F
        mov     eax,1
@@:     push    eax     
        CALLFAR16IND lpfnSetDeviceDesktopMode,es,ax

        ; Now what device are we booting on this time?
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX
        call    GN_GetDevData
        cmp     sDesktopModeInfo.MIDevData.cType,al
        je      MergeInit
        mov     sDesktopModeInfo.MIDevData,eax

        ; Get Last Desktop mode set on this new device
        push    sDesktopModeInfo.dwBpp
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    lpDesktopModeInfo
        mov     eax,0
        cmp     wClone,1
        jne     @F
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,2
        jl      @F
        mov     eax,1
@@:     push    eax     
        CALLFAR16IND lpfnGetDeviceDesktopMode,es,ax
        pop     sDesktopModeInfo.dwBpp
        jmp     MergeInit

NotInit0:
        ; Since we are not initting, we can just use the DevData
        ; for PhysicalDevice0
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX
        call    GN_GetDevData
        mov     sDesktopModeInfo.MIDevData,eax
MergeInit:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Now we may modify the desktop mode the system requested.

        ; Get any forced desktop mode
        push    sDesktopModeInfo.dwBpp
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    lpDesktopModeInfo
        CALLFAR16IND lpfnGetForcedDesktopMode,es,ax
        mov     wForcedModePresent,ax
        mov     eax,sDesktopModeInfo.dwBpp
        pop     sDesktopModeInfo.dwBpp

        ; If Windows is booting, then we can change the color depth.
        ; Otherwise, we cannot.
        cmp     dwThisLogicalDeviceHandle_In_NVTEXT16,1
        jne     @F
        cmp     ds:[esi].GNLOGDEVCX.dwInitting,0
        je      @F
        mov     sDesktopModeInfo.dwBpp,eax
@@:

        ; It is possible that the forced desktop mode has XRes = 0
        ; This is a signal to use the largest EDID mode.
        cmp     sDesktopModeInfo.dwXRes,0
        jne     GetRefreshRateForDesktop

        ; Ask the CRTC for its largest EDID mode.
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    lpDesktopModeInfo
        call    GN_GetLargestEdidMode
        or      ax,ax
        jne     GotDesktopAndRefreshRate

        ; Restore the original desktop size for non DDC display
        mov     eax,dwOriginalXRes
        mov     sDesktopModeInfo.dwXRes,eax
        mov     eax,dwOriginalYRes
        mov     sDesktopModeInfo.dwYRes,eax

GetRefreshRateForDesktop:
        ; We don't have a refresh rate yet. Get one.
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    lpDesktopModeInfo
        call    GN_GetRefreshRateForDesktop
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

GotDesktopAndRefreshRate:
        ; Get the largest block size that we could put this mode in
        ; If this is smaller than a 640x480x8 mode, scream loudly!
        push    esi
        call    GN_GetFreeBlockSizeForMode
        cmp     eax,dwMemoryNeededFor640x480x8
        jae     DoneRecoverFromNoPrimary

RecoverFromNoPrimary:
        push    esi
        call    GN_NoPrimarySurfaceRecovery

DoneRecoverFromNoPrimary:
        mov     dwSettableModeFreeBlockSize,eax

        test    dwSettableModeFreeBlockSize,80000000H
        jnz     EnoughSpace
        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[eax].GNBOARDCX.pHWBoardCX
        pushd   sDesktopModeInfo.dwXRes
        pushd   sDesktopModeInfo.dwYRes
        pushd   sDesktopModeInfo.dwBpp
        call    HW_GetModeDimensions
        cmp     ebx,dwSettableModeFreeBlockSize
        jg      RecoverFromNoPrimary

EnoughSpace:
        and     dwSettableModeFreeBlockSize,NOT 80000000H

        ; Restrict the desktop mode based upon the memory requirements
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    ds:[ebx].GNCRTCCX.lpNvmodeDispData
        push    lpDesktopModeInfo
        push    lpDesktopModeInfo
        push    dwSettableModeFreeBlockSize
        CALLFAR16IND lpfnFindVirtualModeEntry,es,ax

        ; Write any forced desktop mode out to the registry.
        ; Technically Windows will do this, but if we have modified
        ; the desktop mode in any way from what Windows requested,
        ; and if we reboot right away, then Windows will not have
        ; updated its registry section to what we wanted the desktop
        ; to be. Hence, the reboot will not come up in the desktop
        ; that we 'modified' to this time.
        cmp     wForcedModePresent,0
        je      @F
        push    sDesktopModeInfo.dwBpp
        push    sDesktopModeInfo.dwXRes
        push    sDesktopModeInfo.dwYRes
        CALLFAR16IND lpfnSetResolutionAndColorDepth,es,ax
@@:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; There are two possibilities here. We may get called by
        ; 1) Windows Control Panel
        ; 2) NVidiaControlPanel or hotkey handler

        ; If we are called by the Windows Control Panel, then skip
        ; this section and go on to the next section -- normal
        ; processing.
        cmp     ds:[esi].GNLOGDEVCX.dwDisplayConfigPending,0
        je      SkipNVSet

        ; OK, if we get here, it means that we received a
        ; NVTWINVIEW_ACTION_SETGET_DISPLAY_CONFIG escape
        ; call with a delayed state change. The NV Control
        ; Panel or HotKey handler is making this modeset
        ; call to snap the new state into the hardware.

        ; First, clear out the pending display config flag
        mov     ds:[esi].GNLOGDEVCX.dwDisplayConfigPending,0
        lea     edi,[esi].GNLOGDEVCX.sDispConfig

        ; Issue the Begin
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        mov     eax,ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwDeviceMask
        or      eax,80000000H
        push    eax
        call    HW_BeginDisplayChange
        mov     ds:[esi].GNLOGDEVCX.dwBeginDisplayChangeIssued,1

        push    esi
        push    lpDesktopModeInfo
        call    GN_DoFullStateChange
        
        ; Set the refresh rate for the desktop to the refresh rate we
        ; got for the primary CRTCCX from GN_DoFullStateChange.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        sub     edx,edx
        lfs     dx,ds:[ebx].GNCRTCCX.lpCrtcModeInfo
        mov     eax,fs:[edx].MODEINFO.dwRefreshRate
        mov     sDesktopModeInfo.dwRefreshRate,eax

SkipNVSet:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; OK, what we need to do now is to have the hardware take
        ; all the devices and map each device to some head. We
        ; know this can be done or we wouldn't even be here.
        push    esi
        call    GN_CrtcRemapArray
        mov     ds:[esi].GNLOGDEVCX.dwDeviceHasBeenRemapped,eax
        
        ; Now that everything's been remapped, make sure the local copy
        ; of sDesktopModeInfo has the MIDevData for the primary GNCrtcCX.
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX
        call    GN_GetDevData
        mov     sDesktopModeInfo.MIDevData,eax
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ; We may need to override the desktop resolution here if
        ; we are responding to an Enable call after the NV Control Panel
        ; or the hotkey handler issued ChangeDisplaySettings. If this
        ; Enable call is in response to the Windows Control Panel then
        ; use the desktop resolution already provided.
        cmp     ds:[esi].GNLOGDEVCX.dwNvDisplayChangePending,1
        jne     SkipDesktopOverride
        
        mov     ds:[esi].GNLOGDEVCX.dwNvDisplayChangePending,0

        ; We only want to override the desktop resolution if we are writing
        ; separate registry keys for the desktop mode in clone and standard
        ; mode.
        cmp     wClone,1
        jne     SkipDesktopOverride

        ; In order to know which registry key to read, LastCloneDesktopMode or
        ; LastDesktopMode, we need to know if we are in clone mode or not.
        ; Unfortunately, if this Enable is as a result of the hotkey handler,
        ; GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice is not yet set to
        ; the correct value. However, if called by the hotkey handler,
        ; GNLOGDEVCX.dwDisplayConfigPending = 1 and
        ; NVTWINVIEW_DISPLAY_CONFIG.dwActiveDevices is valid.
        cmp     ds:[esi].GNLOGDEVCX.dwDisplayConfigPending,1
        jne     NvControlPanelSet
        
        lea     edi,[esi].GNLOGDEVCX.sDispConfig
        mov     edx,0
        cmp     ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwActiveDevices,1
        je      GetDesktopFromRegistry
        mov     edx,1
        jmp     GetDesktopFromRegistry

NvControlPanelSet:
        mov     edx,0
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,1
        je      GetDesktopFromRegistry
        mov     edx,1

GetDesktopFromRegistry:
        ; Get Last Desktop mode set on this new device
        push    sDesktopModeInfo.dwBpp
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    lpDesktopModeInfo
        push    edx
        CALLFAR16IND lpfnGetDeviceDesktopMode,es,ax
        pop     sDesktopModeInfo.dwBpp

        ; Write any forced desktop mode out to the registry.
        push    sDesktopModeInfo.dwBpp
        push    sDesktopModeInfo.dwXRes
        push    sDesktopModeInfo.dwYRes
        CALLFAR16IND lpfnSetResolutionAndColorDepth,es,ax

SkipDesktopOverride:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Now for the physical modes.
        ; At this point, I am going to assume that a Windows
        ; Control Panel modeset and an NVidia Control Panel
        ; modeset are essentially the same thing.

        ; Run through all devices.
        sub     edi,edi

GetLoop0:
        ; The first PhysicalDevice attached to this logical device
        ; will set, as it's physical mode, the mode and refresh rate of
        ; the desktop. If it is unable to, then back off the phys mode.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        sub     edx,edx
        lfs     dx,ds:[ebx].GNCRTCCX.lpCrtcModeInfo
        mov     eax,fs:[edx].MODEINFO.dwRefreshRate
        mov     dwCloneRefreshRate,eax
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    lpDesktopModeInfo
        call    GN_AssignCrtcModeOnlyBackOffSpatial
        or      edi,edi
        je      SkipRestoreRefreshRate
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        sub     edx,edx
        lfs     dx,ds:[ebx].GNCRTCCX.lpCrtcModeInfo
        mov     eax,dwCloneRefreshRate
        cmp     eax,0
        je      SkipRestoreRefreshRate
        mov     fs:[edx].MODEINFO.dwRefreshRate,eax
        
SkipRestoreRefreshRate:
        jmp     PickupGetLoop

GetLoop1:
        ; For any clone monitors attached to this logical
        ; device, read the CRTC mode from the registry.
        cmp     dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4],0
        je      PickupGetLoop

        ; Read the panning flag for appropriate clone device.
        ; If this flag is 0 than set the desktop resolution,
        ; Otherwise set mode from the registry
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    ds:[ebx].GNCRTCCX.lpBoardRegistryData
        push    ds:[ebx].GNCRTCCX.lpCrtcModeInfo
        CALLFAR16IND lpfnGetClonePanningFlag,es,ax
        or      ax,ax
        jz      GetLoop0

        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    lpDesktopModeInfo
        call    GN_GetCrtcMode

PickupGetLoop:
        inc     edi
        cmp     edi,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jb      GetLoop1
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Now start restricting things ...

        ; If we aren't allowing all modes, then make sure the
        ; desktop mode does not exceed the mode of the primary
        ; CRTC. We always allow virtualization on secondaries.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetAllowMightyModesFlag,es,ax
        or      ax,ax
        jne     @F
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    lpDesktopModeInfo
        call    GN_RestrictOtherModeSpatial
@@:
        sub     edi,edi

RestrictLoop:
        ; We can never set a physical mode larger than the desktop mode
        cmp     dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4],0
        je      @F
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    lpDesktopModeInfo
        call    GN_RestrictCrtcModeSpatial
@@:
        inc     edi
        cmp     edi,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      RestrictLoop
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; We've got all the info we need. We know the desktop and
        ; the physical modes on each attached CRTC.

        ; For the first physical device attached, write out the
        ; last desktop mode for that device.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    lpDesktopModeInfo
        mov     eax,0
        cmp     wClone,1
        jne     @F
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,2
        jl      @F
        mov     eax,1
@@:     push    eax     
        CALLFAR16IND lpfnSetDeviceDesktopMode,es,ax

        ; Also, for the first physical device ONLY, write out its
        ; physical mode. Only the NVidia Control Panel can change
        ; the physical mode of a Clone device. We may have had to
        ; back off what the CRTC modes in the registry for the
        ; Clone devices, but we still don't change them here. This
        ; solves the problem of D3D changing to a fullscreen 6x4
        ; mode, and when it restores the original desktop mode
        ; all cloned device physical modes were left at 6x4. No!
        ; OK, We can write out secondary devices modes as well,
        ; but ONLY if there is not currently any mode for the
        ; secnodary device in the registry.
        sub     edi,edi
@@:
        cmp     dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4],0
        je      ELoop
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    edi
        call    GN_CrtcWriteModeToReg
ELoop:
        inc     edi
        cmp     edi,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      @B
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

JustRes:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Finally! Update the GDIInfo table with our desktop
        sub     edi,edi
        les     di,ds:[esi].GNLOGDEVCX.lpGdiInfo
        mov     eax,sDesktopModeInfo.dwXRes
        mov     ebx,sDesktopModeInfo.dwYRes
        mov     ecx,sDesktopModeInfo.dwBpp
        mov     es:[edi].GDIINFO.dpHorzRes,ax
        mov     es:[edi].GDIINFO.dpVertRes,bx
        mov     es:[edi].GDIINFO.dpBitsPixel,cx
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_SetLogicalAndPhysicalModes
;
; Purpose:      This function sets the desktop mode and and the physical
;               modes in each attached CRTC.
;
; Arguments:
;               ds                      CXSel
;               pGNLogdevCXOffset       GNLOGDEVCX offset
;               lpThisGdiInfo
;
; Returns:
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_SetLogicalAndPhysicalModes, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
LOCALD  dwJustOnePrimaryCanMove
LOCALD  pOtherGNLogdevCXOffset
LOCALD  dwMemoryNeededFor640x480x8
LOCALD  dwMemoryNeededForPrimarySurface
LOCALD  dwMemoryNeededForOtherPrimarySurface
LOCALD  pFirstNonNullCRTCForLogdev2
LOCALD  dwClearAndPanSecondSurface
LOCALD  dwDevDataMask
LOCALD  dwSetModeOnPrimary
LOCALD  dwSetModeOnSecondary
LOCALD  dwForceBothDevices
OPENPROC
        PUSHR   esi,edi

        mov     dwForceBothDevices,0

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; We will be needing this
        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[eax].GNBOARDCX.pHWBoardCX
        pushd   640
        pushd   480
        pushd   8
        call    HW_GetModeDimensions
        mov     dwMemoryNeededFor640x480x8,ebx
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TryItAgain:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Figure out whether one, or more than one (which means 2
        ; right now) primary surfaces will be moving.
        push    esi
        push    dwForceBothDevices
        call    GN_GetOtherLogdev
        mov     dwJustOnePrimaryCanMove,ecx
        or      ecx,ecx
        jne     ClearJustOnePrimary

        mov     dwMemoryNeededForOtherPrimarySurface,ebx
        mov     pOtherGNLogdevCXOffset,edi
        mov     eax,ds:[edi].GNLOGDEVCX.pGNCrtcCX
        mov     pFirstNonNullCRTCForLogdev2,eax

ClearBothPrimaries:
        cmp     ds:[edi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        je      ClearJustOnePrimary
        push    edi
        call    GN_BlankScreen

ClearJustOnePrimary:
        cmp     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        je      @F
        push    esi
        call    GN_BlankScreen
@@:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Isolate ourselves so that the modeswitch is atomic

        cmp     ds:[esi].GNLOGDEVCX.dwInitting,0
        je      @F

        ; We are initting. Are we the second display driver
        cmp     ds:[esi].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard,0
        je      @F

        ; We are the second display driver and we are initting.
        ; We must call the hardware side to allow them to do some
        ; stuff.
        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     ecx,dword ptr ds:[eax].GNBOARDCX.pGNLogdevCX[0]
        mov     edx,dword ptr ds:[eax].GNBOARDCX.pGNLogdevCX[4]
        push    ds:[ecx].GNLOGDEVCX.pHWLogdevCX
        push    ds:[edx].GNLOGDEVCX.pHWLogdevCX
        call    HW_DriverTwinviewStateChanging
@@:

        ; The first thing we do is send the PRE_MODESET message.
        ; All other components should stop all interactions with
        ; the board and video memory from this point until they
        ; see the POST_MODESET message. This way all our code
        ; and calculations herein appear atomic. For the most
        ; part just being inside the Win16 mutex does this.
        push    esi
        pushd   MSG_PREMODESET
        push    esi
        push    ds:[esi].GNLOGDEVCX.Dibeng.delpPDevice
        call    GN_LogdevMessage
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; NOTE: The general fitting algorithm is too difficult to do in
        ; its full generality. Hence, we just implement the two specific
        ; cases that we know are the only ones that can happen right now.
        cmp     dwJustOnePrimaryCanMove,0
        jne     FillInPDevice

FreeBothPrimaries:
        ; Do we even have the secondary?
        mov     eax,ds:[edi].GNLOGDEVCX.dwMemorySizeForPrimarySurface
        or      eax,eax
        je      FillInPDevice

        ; Can we use the same surface?
        or      eax,dwForceBothDevices
        cmp     eax,dwMemoryNeededForOtherPrimarySurface
        je      FillInPDevice

        push    ds:[edi].GNLOGDEVCX.pHWLogdevCX
        call    HW_FreeLogicalSurface
        mov     ds:[edi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FillInPDevice:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Fill in the resolution to the GDIINFO table
        sub     edi,edi
        sub     eax,eax
        sub     ebx,ebx
        les     di,ds:[esi].GNLOGDEVCX.lpGdiInfo
        mov     ax,es:[edi].GDIINFO.dpHorzRes
        mov     bx,es:[edi].GDIINFO.dpVertRes
        mov     cx,es:[edi].GDIINFO.dpBitsPixel
        mov     ds:[esi].DIBENGINEHDR.deWidth,ax
        mov     ds:[esi].DIBENGINEHDR.deHeight,bx
        mov     ds:[esi].DIBENGINEHDR.deBitsPixel,cl

        ; Flesh out the Dibeng structure
        and     ds:[esi].DIBENGINEHDR.deFlags,NOT FIVE6FIVE
        mov     edx,ds:[esi].GNLOGDEVCX.dw16BppFormat
        cmp     cl,16
        jne     @f
        or      ds:[esi].DIBENGINEHDR.deFlags,dx
        cmp     edx,FIVE6FIVE
        je      @F
        mov     cl,15
@@:
        mov     ds:[esi].DIBENGINEHDR.bRealBpp,cl
        les     di,ds:[esi].DIBENGINEHDR.deBitmapInfo
        mov     es:[edi].BitmapInfoHeader.biWidth,eax
        mov     es:[edi].BitmapInfoHeader.biHeight,ebx
        mov     es:[edi].BitmapInfoHeader.biBitCount,cx

        mov     edx,ecx
        imul    ecx,eax
        shr     ecx,3
        inc     ecx
        and     cl,NOT 1
        mov     ds:[esi].DIBENGINEHDR.deWidthBytes,cx

        ; Set the palettized flag if needed
        and     ds:[esi].DIBENGINEHDR.deFlags,NOT PALETTIZED
        cmp     ds:[esi].DIBENGINEHDR.deBitsPixel,8
        jne     @F
        or      ds:[esi].DIBENGINEHDR.deFlags,PALETTIZED
@@:
        ; Get the size of the primary we are going to set.
        ; We NEVER get less than 640x480x8 amount of memory
        ; or we might not be able to set the mode back to a
        ; reasonable desktop (if we are going to 320x200, say)
        ; since we might not be able to get the memory later.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        movzx   eax,ds:[esi].DIBENGINEHDR.deWidth
        push    eax
        movzx   eax,ds:[esi].DIBENGINEHDR.deHeight
        push    eax
        movzx   eax,ds:[esi].DIBENGINEHDR.deBitsPixel
        push    eax
        call    HW_GetModeDimensions
        mov     ds:[esi].DIBENGINEHDR.deDeltaScan,eax
        mov     ecx,ebx
        cmp     ecx,dwMemoryNeededFor640x480x8
        ja      @F
        mov     ecx,dwMemoryNeededFor640x480x8
@@:     mov     dwMemoryNeededForPrimarySurface,ecx
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ; Do we even have the primary?
        mov     eax,ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface
        or      eax,eax
        je      @F

        ; Can we use the same surface?
        or      eax,dwForceBothDevices
        cmp     eax,ebx
        je      @F

        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_FreeLogicalSurface
        mov     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
@@:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        mov     dwClearAndPanSecondSurface,0
        cmp     dwJustOnePrimaryCanMove,0
        jne     AllocJustOnePrimary

AllocBothPrimary:
        ; We need to re-allocate these in order from larger to smaller
        ; or we might not get both. As long as we allocate in the
        ; correct order, code earlier in this routine should have
        ; guaranteed that we will get the surfaces.
        mov     dwClearAndPanSecondSurface,1
        mov     edi,pOtherGNLogdevCXOffset
        mov     eax,dwMemoryNeededForOtherPrimarySurface
        cmp     eax,dwMemoryNeededForPrimarySurface
        ja      SecondSurfaceAlloc

FirstSurfaceAlloc:
        mov     dwSetModeOnPrimary,1;!!!
        cmp     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        jne     HavePrimary

        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    esi
        call    HW_AllocLogicalSurface
        cmp     eax,-1
        jne     FirstAllocOk

        push    esi
        call    GN_NoPrimarySurfaceRecovery
        test    eax,80000000H
        jz      FirstSurfaceAlloc

CheckForceBothDevicesFlag:
        cmp     dwForceBothDevices,0
        mov     dwForceBothDevices,1
        je      TryItAgain

        ;VMEM deadlock. Never should be here.
IFDEF DEBUG
        int     3
ENDIF
@@:
        mov     eax,0DEADBEEFH
        jmp     @B

FirstAllocOk:
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deBitsOffset,eax
        mov     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,ebx
        mov     dwSetModeOnPrimary,ebx

HavePrimary:
        mov     eax,dwMemoryNeededForOtherPrimarySurface
        cmp     eax,dwMemoryNeededForPrimarySurface
        ja      FinishUp

SecondSurfaceAlloc:
        ; Now alloc the other guy
        mov     dwSetModeOnSecondary,1;!!!
        cmp     ds:[edi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        jne     HaveSecondary

        push    ds:[edi].GNLOGDEVCX.pHWLogdevCX
        push    edi
        call    HW_AllocLogicalSurface
        cmp     eax,-1
        jne     @F
        push    esi
        call    GN_NoPrimarySurfaceRecovery
        test    eax,80000000H
        jz      SecondSurfaceAlloc
        jmp     CheckForceBothDevicesFlag

@@:
        mov     ds:[edi].GNLOGDEVCX.Dibeng.deBitsOffset,eax
        mov     ds:[edi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,ebx
        mov     dwSetModeOnSecondary,ebx

HaveSecondary:
        mov     eax,dwMemoryNeededForOtherPrimarySurface
        cmp     eax,dwMemoryNeededForPrimarySurface
        ja      FirstSurfaceAlloc
        jmp     FinishUp
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

AllocJustOnePrimary:
        mov     dwSetModeOnPrimary,1;!!!
        mov     dwSetModeOnSecondary,0
        cmp     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        jne     FinishUp

        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    esi
        call    HW_AllocLogicalSurface
        cmp     eax,-1
        jne     @F
        push    esi
        call    GN_NoPrimarySurfaceRecovery
        test    eax,80000000H
        jz      AllocJustOnePrimary
        jmp     CheckForceBothDevicesFlag

@@:
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deBitsOffset,eax
        mov     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,ebx
        mov     dwSetModeOnPrimary,ebx
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FinishUp:
        ; Tell all other componenets that the modeset is complete.
        push    esi
        pushd   MSG_POSTMODESET
        push    esi
        push    ds:[esi].GNLOGDEVCX.Dibeng.delpPDevice
        call    GN_LogdevMessage

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ; Get the Device Data Mask for all display devices.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ebx
        pushd   0
        call    GN_GetDevDataMask
        or      eax,80000000H
        mov     dwDevDataMask,eax

        ; Did we already issue a BeginDisplayChange in
        ; GetLogicalAndPhysicalModes?
        cmp     ds:[esi].GNLOGDEVCX.dwBeginDisplayChangeIssued,0
        jne     @F
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwDevDataMask
        call    HW_BeginDisplayChange
@@:
        cmp     dwSetModeOnSecondary,0
        je      DoneSecondary

        ; Don't forget to clear the OTHER surface if needed
        cmp     dwClearAndPanSecondSurface,0
        je      @F
        push    edi
        call    GN_BlankScreen
@@:

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; We need to call and reset the mode on the OTHER guy now.
        ; The problem is that the other guys CRTC timings may have
        ; gotten messed up when we set the mode here because we may
        ; have had to do a head reassignment in order to get all the
        ; heads to display to their appropriate output devices. If
        ; we did, then the other logical device's HW CRTC state is
        ; uninitted.
        cmp     dwClearAndPanSecondSurface,0
        je      DoneSecondary

        push    dword ptr ds:[edi].GNLOGDEVCX.pGNCrtcCX
        push    edi
        call    GN_RestoreCrtcState

DoneSecondary:
        ; Now we can actually set the modes in the CRTCCXs
        ; which are attached to THIS logical device.
        ; Let's make the screen look pretty by clearing it to black.
        push    esi
        call    GN_BlankScreen

        sub     edi,edi
        cmp     dwSetModeOnPrimary,0
        je      NextCrtc7

Loopit7:
        ; Is this CRTCCX valid?
        cmp     dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4],0
        je      NextCrtc7

        ; Set the mode on this CRTC.
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    esi
        call    GN_RestoreCrtcState

NextCrtc7:
        inc     edi
        cmp     edi,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      Loopit7

        ; Signal the end of a display state change
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwDevDataMask
        call    HW_EndDisplayChange

        ; We just issued the matching end.
        mov     ds:[esi].GNLOGDEVCX.dwBeginDisplayChangeIssued,0

        ; See if we need to modify some results back to the
        ; Windows requested mode (which is one of our modes
        ; ANDed with 8 -- this only happens in multimon).
        mov     ax,ds:[esi].GNLOGDEVCX.wWindowsXRes
        mov     cx,ds:[esi].GNLOGDEVCX.wWindowsYRes
        mov     bx,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
        cmp     ax,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
        jne     Skip10
        and     bx,NOT 7
        and     cx,NOT 7
        cmp     bx,cx
        jne     Skip10

        mov     cx,ds:[esi].GNLOGDEVCX.wWindowsYRes
        mov     dword ptr ds:[esi].GNLOGDEVCX.wWindowsXRes,0
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deHeight,cx
        sub     edi,edi
        les     di,ds:[esi].GNLOGDEVCX.lpGdiInfo
        mov     es:[edi].GDIINFO.dpVertRes,cx
Skip10:

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetOtherLogdev
;
; Purpose:      This routine is called to get whether or not there
;               is more than one logical device on this board, and,
;               if there is, to get information on the other logical
;               device.
;
; Arguments:
;               ds                      CXSel
;               pGNLogdevCXOffset       GNLOGDEVCX offset
;
; Returns:      ecx     0 if parm pGNLogdevCXOffset is the only device on
;                               the board
;                       non-0 if there is another logdev on this board
;               edi     if ecx is non-0, then edi is the other pGNLogdevCX
;               ebx     if ecx is non-0, then ebx is the memory needed
;                               for the primary surface of the other
;                               pGNLogdevCX
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetOtherLogdev, PASCAL, FRAME, NEAR
PARMD   pGNLogdevCXOffset
PARMD   dwForceBothDevices
OPENPROC
        PUSHR   esi
        mov     esi,pGNLogdevCXOffset

        mov     ecx,1
        sub     edi,edi
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX

        ; Is there another primary surface on this board?
        cmp     ds:[ebx].GNBOARDCX.dwLogicalDeviceInstancesOnThisBoard,1
        je      GotPrimaryData

        ; OK, there is more than 1 primary (that means 2 right now),
        ; but can the other primary be moved? First figure out
        ; which is the OTHER logical device
        mov     edi,ds:[ebx].GNBOARDCX.pGNLogdevCX[0]
        cmp     edi,esi
        jne     @F
        mov     edi,ds:[ebx].GNBOARDCX.pGNLogdevCX[4]
@@:
        ; HACK -- if the OTHER logical device is disabled,
        ; then just say there is only 1 logical device. Do NOT
        ; call IsDriverAttachedToDesktop!! We are in the wrong
        ; display driver for this to get called. Just see if
        ; there is a primary CRTC attached to the other logdev
        cmp     dword ptr ds:[edi].GNLOGDEVCX.pGNCrtcCX,0
        je      GotPrimaryData

        ; The OTHER logical device is enabled. If dwForceBothDevices is true
        ; then it can be moved. Otherwise it shouldn't.
        mov     ebx,ds:[edi].GNLOGDEVCX.dwMemorySizeForPrimarySurface
        cmp     dwForceBothDevices,0
        jne     ForceBothDevices

        ; Check for remapped devices
        mov     eax,ds:[esi].GNLOGDEVCX.dwDeviceHasBeenRemapped
        or      eax,eax
        jz      GotPrimaryData

        ; Determine how many devices has been remapped
@@:
        test    eax,1
        jnz     @F
        shr     eax,1
        jmp     @B

@@:
        ; Don't set mode on the primary if the only one device has been remapped
        shr     eax,1
        je      GotPrimaryData

ForceBothDevices:
        ; Set mode on both devices
        sub     ecx,ecx

GotPrimaryData:
        POPR    esi
CLOSEPROC

;==============================================================================
;
; Function:     GN_NoPrimarySurfaceRecovery
;
; Purpose:      This routine is only called in dire emergencies when
;               we are unable to get the memory for even a 640x480x8
;               primary surface. The display driver should be able to
;               guarantee that this will never happen. As long as its
;               code is correct and the heap doesn't get corrupted,
;               etc. then everything is fine. However, we need to be
;               able to recover somehow if we can't alloc the screen.
;
;               In here, we do a purge of all of video memory and ask
;               the hareware code to reset its offscreen heap manager.
;               This will probably result in some temporary drawing
;               problems, because some offscreen surfaces that are
;               allocated to various clients will be written over as
;               the memory freed behind their backs gets reallocated
;               to other clients. However, these drawing issues will
;               probably be short lived and this strategy does allow
;               us to recover fully.
;
;       JKTODO -- purge all offscreen video memory through special
;       RM call which does not yet exist. OGL wants us to increment the
;       mode counter so that they will reallocate appropriately.
;       We would also need to flush, etc...
;
; Arguments:
;               ds                      CXSel
;               pGNLogdevCXOffset       GNLOGDEVCX offset
;
; Returns:      eax                     New size of free offscreen memory
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_NoPrimarySurfaceRecovery, PASCAL, FRAME, NEAR
PARMD   pGNLogdevCXOffset
LOCALD  dwOldOffscreenFreeSpace
OPENPROC
        PUSHR   esi
        mov     esi,pGNLogdevCXOffset

        ; Send a broadcast message around that video memory
        ; is about to be reset. Since the heap is probably
        ; already trashed, object cleanup may not be that
        ; effective, but it iw worth a shot.

        ; Get the largest block size before purge
        ; If this is the same as before purge, scream loudly!
        push    esi
        call    GN_GetFreeBlockSizeForMode
        mov     dwOldOffscreenFreeSpace,eax

        ; Purge DX video memory
        ; Specifically call the HWBOARD routine so that it
        ; can do stuff that is global and crucial to the
        ; board.
        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[eax].GNBOARDCX.pHWBoardCX
        call    HW_DxHeapPurge

        ; Send a broadcast message around that video memory
        ; has been reset. Everyone can realloc stuff.

        ; Get the largest block size again
        ; If this is the same as before purge, scream loudly!
        push    esi
        call    GN_GetFreeBlockSizeForMode
        cmp     eax,dwOldOffscreenFreeSpace
        jg      DoneIt

        ; There is not enough memory to set the requested mode, and purging
        ; DX video memory didn't help. Now, purge everything except the
        ; primary surface which was purged earlier. After we purge everything,
        ; we will need to purge the cursor cache.
        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[eax].GNBOARDCX.pHWBoardCX
        call    HW_HeapPurgeAllExceptPrimarySurface
        
        ; Clear all cursor cahces.
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        call    GN_ClearAllCursorCaches
        
        ; Get the largest block size again
        ; If this is the same as before purge, scream loudly!
        push    esi
        call    GN_GetFreeBlockSizeForMode
        cmp     eax,dwOldOffscreenFreeSpace
        jg      DoneIt

        ; At this point we might not realloc the secondary surface.
        ; Return E31 to force it.
        or      eax,80000000H

DoneIt:
        POPR    esi
CLOSEPROC



;==============================================================================
;
; Function:     GN_DoFullStateChange
;
; Purpose:      This routine is called when the information in the
;               NVTWINVIEW_DISPAY_CONFIG buffer in the GNLOGDEVCX
;               is to be processed. This may happen at escape time
;               or it may be deferred until the next modeset.
;
; Arguments:
;               ds                      CXSel
;               pGNLogdevCXOffset       GNLOGDEVCX offset
;
; Returns:      eax                     New size of free offscreen memory
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_DoFullStateChange, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
PARMD   lpPassedInModeInfo
LOCALD  dwMaxMonitors
LOCALD  dwMonitorNum
LOCALD  dwLocalDeviceMask
LOCALD  dwDeviceCount
LOCALV  sModeInfo,MODEINFO
LOCALD  lpModeInfo
LOCALV  sDesktopModeInfo,MODEINFO
LOCALD  lpDesktopModeInfo
LOCALS  LocalDevData,MAX_ATTACHED_CRTCS*4
LOCALD  lpLocalDevData
OPENPROC
        PUSHR   esi,edi

        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        mov     lpModeInfo,eax
        lea     ax,sDesktopModeInfo
        mov     lpDesktopModeInfo,eax
        lea     ax,LocalDevData
        mov     lpLocalDevData,eax

        mov     esi,pGNLogdevCXOffset
        lea     edi,[esi].GNLOGDEVCX.sDispConfig

        ; If we are going to standard mode then destroy any CLONE CRTCCX
        ; if one exists
        cmp     ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwActiveDevices,1
        jne     @F
        mov     dwMaxMonitors,1
        push    esi
        pushd   1
        call    GN_LogdevDetachCrtc
        jmp     DoneDevice
@@:
        ; If we are going to clone mode and we are currently in
        ; standard mode then add a clone
        cmp     ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwActiveDevices,3
        jne     DoneDevice
        cmp     ds:[esi].GNLOGDEVCX.pGNCrtcCX[4],0
        jne     DoneDevice
        mov     dwMaxMonitors,2
        push    esi
        call    GN_LogdevAddAClone

DoneDevice:

        ; Loop on all the modes.
        mov     dwMonitorNum,0

        ; We have to do the primary device first. But then we will want
        ; to skip whiever one it was later, so remove it from the mask.
        mov     eax,ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwDeviceMask
        mov     dwLocalDeviceMask,eax
        mov     eax,ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwPrimaryDeviceMask
        xor     dwLocalDeviceMask,eax
        mov     edx,eax

        sub     ecx,ecx
        mov     dwDeviceCount,ecx
@@:     shr     edx,1
        je      Merge1
        inc     ecx
        mov     dwDeviceCount,ecx
        jmp     @B


LoopNow1:
        ; Does this guy have a mode to set?
        mov     ecx,dwDeviceCount
        mov     eax,1
        shl     eax,cl

        test    eax,dwLocalDeviceMask
        jz      SkipInitNoDev

Merge1:
        PUSHR   eax

        mov     ebx,ecx
        shr     cl,3
        and     ebx,07H
        mov     ch,bl
        mov     dword ptr sModeInfo.MIDevData,ecx

        ; Get the TV Format from the ResMan.
        mov     ebx,dwMonitorNum
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4]
        push    ds:[ebx].GNCRTCCX.pHWCrtcCX
        push    ecx
        call    HW_GetResManTvFormat
        
        mov     sModeInfo.MIDevData.cFormat,al

        ; Now change the device type in the CRTCCX
        mov     ecx,dwMonitorNum
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX[ecx * 4]
        push    dword ptr sModeInfo.MIDevData
        call    GN_SetDevData

        POPR    eax
        test    eax,ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwPhysicalModeFlags
        jz      SkipInit

        mov     ecx,dwDeviceCount
        imul    ecx,SIZE PHYSICAL_MODE
        lea     eax,[edi].NVTWINVIEW_DISPLAY_CONFIG.PhysModes
        add     eax,ecx
        push    eax
        
        ; Figure out the EDID thing
        mov     ebx,dwMonitorNum
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4]
        mov     ds:[ebx].GNCRTCCX.dwEdidSize,0
        cmp     sModeInfo.MIDevData.cType,DEVTYPE_TV
        je      DoneEdidRead

        ; Read the EDID for this device
        mov     ds:[ebx].GNCRTCCX.dwEdidSize,MAX_EDID_BUFFER_SIZE
        push    ds:[ebx].GNCRTCCX.pHWCrtcCX
        push    dword ptr sModeInfo.MIDevData
        mov     ax,ds
        push    eax
        call    GN_GetSelectorBase
        lea     ecx,ds:[ebx].GNCRTCCX.sEdidBuffer
        add     ecx,eax
        push    ecx
        lea     ecx,ds:[ebx].GNCRTCCX.dwEdidSize
        add     ecx,eax
        push    ecx
        call    HW_ReadEdid

DoneEdidRead:
        ; Assume that this is a normal mode
        pop     eax
        mov     ebx,ds:[eax].MODEINFO.dwXRes
        mov     ecx,ds:[eax].MODEINFO.dwYRes
        mov     edx,ds:[eax].MODEINFO.dwRefreshRate
        or      ebx,ebx
        jne     UseTwinViewMode

        ; Special max device mode when dwXRes, dwYRes, and dwRefreshRate = 0.
        ; First, check to see if this is a Toshiba mobile system. If so, use
        ; the refresh rate out of the registry unless the monitor is
        ; non-DDC (no EDID) in which case use 60Hz. If this is not a
        ; Toshiba mobile system, use the largest dwXRes, dwYRes, and
        ; dwRefreshRate allowable for the current desktop.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetBootDeviceSelection,es,ax
        mov     edx,1000
        cmp     ax,2
        jne     UseRefreshRate
        
        ; Check to see if there is an EDID, and if not, use 60Hz.
        mov     ebx,dwMonitorNum
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4]
        cmp     ds:[ebx].GNCRTCCX.dwEdidSize,0
        mov     edx,60
        je      UseRefreshRate

        ; Get the refresh rate from the registry.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    lpModeInfo
        CALLFAR16IND lpfnGetDeviceDisplayMode,es,ax
        sub     ebx,ebx
        lea     bx,sModeInfo
        mov     edx,ss:[ebx].MODEINFO.dwRefreshRate
        or      ax,ax
        jne     UseRefreshRate

        ; No mode in the registry, use 60Hz as default.
        mov     edx,60

UseRefreshRate:
        mov     ebx,7FFFH
        mov     ecx,ebx
        
UseTwinViewMode:
        sub     eax,eax
        lfs     ax,lpPassedInModeInfo
        cmp     ebx,fs:[eax].MODEINFO.dwXRes
        jl      @F
        mov     ebx,fs:[eax].MODEINFO.dwXRes
@@:     
        mov     sModeInfo.dwXRes,ebx
        
        cmp     ecx,fs:[eax].MODEINFO.dwYRes
        jl      @F
        mov     ecx,fs:[eax].MODEINFO.dwYRes
@@:     
        mov     sModeInfo.dwYRes,ecx
        mov     sModeInfo.dwRefreshRate,edx
        mov     eax,fs:[eax].MODEINFO.dwBpp
        mov     sModeInfo.dwBpp,eax

        ; NOTE: At this point, the DISPDATA.dwMaxDacSpeedInHertzXXbpp
        ; structure members are stale, but since we don't have a head
        ; mapping yet, we can not get the real values for the DAC.
        ; Set this to a large number so we won't restrict now according
        ; to the DAC speed. The DAC speed will be filled in after we
        ; have a head mapping, and the mode will be revalidated using
        ; the correct DAC speed. This only needs to be done for the
        ; primary as GN_LogdevAddAClone already does this for the secondary.
        mov     edx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        lea     edx,[edx].GNCRTCCX.sNvmodeDispData
        mov     ds:[edx].DISPDATA.dwMaxDacSpeedInHertz8bpp,40000000H
        mov     ds:[edx].DISPDATA.dwMaxDacSpeedInHertz16bpp,40000000H
        mov     ds:[edx].DISPDATA.dwMaxDacSpeedInHertz32bpp,40000000H

        mov     ecx,dwMonitorNum
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX[ecx * 4]
        push    lpModeInfo
        call    GN_AssignCrtcModeOnlyBackOffSpatial

        ; We should now have a mode that is settable on this device.
        ; Let's write this out to the registry
        mov     ecx,dwMonitorNum
        sub     eax,eax
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[ecx * 4]
        push    eax
        call    GN_CrtcWriteModeToReg

SkipInit:
        ; Go to the next monitor
        inc     dwMonitorNum
        mov     ecx,dwMonitorNum
        cmp     ecx,dwMaxMonitors
        jnc     DoneInit

        cmp     ecx,1
        jne     SkipInitNoDev
        ; We just did MonitorNum = 0 which is the primary.
        ; Start over with the beginning of the deviceMask.
        ; The primary won't be repeated -- we reomved it from
        ; the deviceMask at the beginning.
        mov     dwDeviceCount,-1

SkipInitNoDev:
        inc     dwDeviceCount
        cmp     dwDeviceCount,18H
        jc      LoopNow1

DoneInit:
        POPR    esi,edi
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNINT2F.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnint2f.asm
;
; Purpose:      This file holds the routines dealing with int2f.
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

SCREEN_SWITCH_OUT       EQU     4001H
SCREEN_SWITCH_IN        EQU     4002H

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE
PUBLIC  lpfnOldInt2FHandler
lpfnOldInt2FHandler     DD      0
dwInt2FInstalled        DD      0

PUBLIC	lpUserFullscreenDOSBoxFlag
lpUserFullscreenDOSBoxFlag	DD	0

IFDEF DEBUG
szToWindows     DB      'DISPLAY:GN_Int2FSwitchingToWindows',0DH,0AH,0
szToDos         DB      'DISPLAY:Int2FSwitchingToDos',0DH,0AH,0
ENDIF

;==============================================================================
;
; Function:     GN_HookInt2F
;
; Purpose:      This function hooks into the int2f chain if this is
;               the primary device and we have not already hooked
;               the chain. It is a NOP if we are a secondary
;               device or we are already in the chain.
;
; Arguments:
;               ds              Context Selector
;               pLogdevCXOffset GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_HookInt2F, PASCAL, FRAME, FAR16
PARMD   pLogdevCXOffset
OPENPROC
        PUSHR   ds
        sub     eax,eax

        ; Have we already hooked it?
        cmp     eax,cs:[dwInt2FInstalled]
        jne     done

        ; Are we the primary device?
        cmp     cs:[dwThisLogicalDeviceHandle_In_NVTEXT16],1
        jne     done

        ; Use the DOS int 21H interface to get and set the 2F vector
        cli
        mov     ax,3500H+2FH
        int     21H
        mov     ds,cs:[wNVTEXT16_Alias_In_NVTEXT16]
        mov     word ptr ds:[lpfnOldInt2FHandler + 0],bx
        mov     word ptr ds:[lpfnOldInt2FHandler + 2],es
        mov     ds:[dwInt2FInstalled],1

        ; Now set it to our interrupt handler
        mov     ax,SEG Int2FHandler
        mov     edx,OFFSET Int2FHandler
        mov     ds,ax
        mov     ax,2500H + 2FH
        int     21H
        sti

	push    pLogdevCXOffset
	call	GN_GetUserDosBoxFlagAddress

        ; We must tell the main VDD that we;d like to recieve int2fs.
        mov     eax,4000H
        int     2FH
done:
        POPR    ds
CLOSEPROC


;==============================================================================
;
; Function:     GN_UnhookInt2F
;
; Purpose:      This function unhooks us from the int2f chain if
;               we are currently hooked. Otherwise it just returns.
;
; Arguments:
;               ds              Context Selector
;               pLogdevCXOffset GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_UnhookInt2F, PASCAL, FRAME, FAR16
PARMD   pLogdevCXOffset
OPENPROC
        PUSHR   ds

        sub     eax,eax
        cmp     eax,cs:[dwInt2FInstalled]
        je      done

        ; Use the DOS int 21H interface to reset the old vector
        cli
        sub     ecx,ecx
        mov     eax,cs:[lpfnOldInt2FHandler]
        mov     ds,cs:[wNVTEXT16_Alias_In_NVTEXT16]
        mov     ds:[dwInt2FInstalled],ecx
        mov     dx,ax
        shr     eax,10H
        mov     ds,ax
        mov     ax,2500H + 2FH
        int     21H
        sti
done:
       POPR     ds
CLOSEPROC


;==============================================================================
;
; Function:     Int2FHandler
;
; Purpose:      This function is the int2F handler. Lots of things come
;               through here, but we only care about ScreenSwitchIn and
;               ScrenSwitchOut.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     All registers must be preserved
;==============================================================================
DECPROC Int2FHandler, PASCAL, NOFRAME, FAR16
OPENPROC
        cmp     ax,SCREEN_SWITCH_IN
        je      Int2FSwitchingToWindows
        cmp     ax,SCREEN_SWITCH_OUT
        je      Int2FSwitchingToDos
        jmp     FFP16 PTR lpfnOldInt2FHandler

Int2FHandler    ENDP


;==============================================================================
;
; Function:     Int2FSwitchingToWindows
;
; Purpose:      This function is the int2F handler once it is known
;               that we are doing a screen switch in (going to Windows).
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     All registers must be preserved
;==============================================================================
DECPROC Int2FSwitchingToWindows, PASCAL, NOFRAME, FAR16
OPENPROC
        push    bp
        mov     bp,sp
        PUSHR   alld,ds,es,fs,gs
        call    GN_Int2FSwitchingToWindows
        POPR    alld,ds,es,fs,gs
        and     word ptr [bp + 6],NOT 1
        pop     bp
        iret

Int2FSwitchingToWindows ENDP


;==============================================================================
;
; Function:     GN_Int2FSwitchingToWindows
;
; Purpose:      This function is the same as GN_Int2FSwitchingToWindows
;               and is called from it.  The only difference is, this
;               routine can be called from anywhere because it does a
;               ret instead of an iret.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     ds, esi, edi
;==============================================================================
DECPROC GN_Int2FSwitchingToWindows, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi

IFDEF DEBUG
        mov     ax,cs
        shl     eax,10H
        lea     ax,szToWindows
        push    eax
        call    GENERIC_OutputDebugString
ENDIF
        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]
        mov     ds:[esi].GNLOGDEVCX.bSetModeBypass,0

        ; Bypass routine if we are already in windows mode.
        cmp     ds:[esi].GNLOGDEVCX.dwInt2FScreenSwitchOut,0
        je      @F

        ; Send a message down the chain
        push    esi
        pushd   MSG_DOSOFF
        push    esi                             ; CX ptr to DIBENGINEHDR
        push	CSlp16LogDevice_In_NVTEXT16	; 16:16 ptr to DIBENGINEHDR
        call    GN_LogdevMessage

        ; Tell the VDD we are going to HiRes
        call    GN_VddDriverRegister

        ; UserRepaint sometimes takes a few seconds to take effect.
        ; Clear the screen to black or else we see garbage on the
        ; screen for those few seconds.
        sub     eax,eax
        push    CSlp16LogDevice_In_NVTEXT16
        push    eax
        push    eax
        push    eax
        push    ds:[esi].DIBENGINE.deWidth
        push    ds:[esi].DIBENGINE.deHeight
        push    eax
        push    eax
        push    eax
        call    GENERIC_BitBlt

        ; Now ask User to repaint the screen
        push	esi
        call    GN_UserRepaint

	cmp	cs:[lpUserFullscreenDOSBoxFlag],0
	je	@F
	; This corrects for the fact that occassionally USER does
	; not RESET its own internal flag that indicates that it is
	; no longer in a fullscreen DOS box.
	lds	si,cs:[lpUserFullscreenDOSBoxFlag]
	and	byte ptr ds:[si],NOT 8
@@:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     Int2FSwitchingToDos
;
; Purpose:      This function is the int2F handler once it is known
;               that we are doing a screen switch out (going to Dos).
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     All registers must be preserved
;==============================================================================
DECPROC Int2FSwitchingToDos, PASCAL, NOFRAME, FAR16
OPENPROC
        push    bp
        mov     bp,sp
        PUSHR   alld,ds,es,fs,gs

IFDEF DEBUG
        mov     ax,cs
        shl     eax,10H
        lea     ax,szToDos
        push    eax
        call    GENERIC_OutputDebugString
ENDIF

        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]

        ; Clear the screen before issuing the unregister. Otherwise
        ; we sometimes see a flash of garbage.
        sub     eax,eax
        push    CSlp16LogDevice_In_NVTEXT16
        push    eax
        push    eax
        push    eax
        push    ds:[esi].DIBENGINE.deWidth
        push    ds:[esi].DIBENGINE.deHeight
        push    eax
        push    eax
        push    eax
        call    GENERIC_BitBlt

        ; If the BUSY bit is already set, it is beacuse the VDD is
        ; orchestrating the switch to DOS (e.g. user pressed Alt-Tab)
        ; If it is not set, then inform the VDD we are going to DOS.
        test    ds:[esi].GNLOGDEVCX.Dibeng.deFlags,BUSY
        jnz     @F

        call    GN_VddDriverUnregister
@@:
        ; Send a message down the chain
        push    esi
        pushd   MSG_DOSON
        push    esi                             ; CX ptr to DIBENGINEHDR
        push	CSlp16LogDevice_In_NVTEXT16	; 16:16 ptr to DIBENGINEHDR
        call    GN_LogdevMessage

        POPR    alld,ds,es,fs,gs
        and     word ptr [bp + 6],NOT 1
        pop     bp
        iret

Int2FSwitchingToDos     ENDP


;==============================================================================
;
; Function:     GENERIC_ResetHiresMode
;
; Purpose:      This function is called from the main VDD when switching
;               from a full screen DOS back to Windows. We need to get
;               back into a HiRes mode here. (The resource manager
;               may be catching the SET_FOCUS call in VDD land and
;               doing the mode set itself, so we may not need to do
;               anything here. Just in case.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     All registers must be preserved
;==============================================================================
DECPROC GENERIC_ResetHiresMode, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi

        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]

        mov     ds:[esi].GNLOGDEVCX.dwInt2FScreenSwitchOut,1
        call    GN_Int2FSwitchingToWindows

        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:	GN_GetUserDosBoxFlagAddress
;
; Purpose:
;		This fixes a bug in USER that is DOS-box switching timing
;		related. The probem is that USER maintains a bit, which
;		when set, indicates we are in a full-screen DOS box; when
;		clear, we are in the Windows desktop. Sometimes, when
;		coming back from a fullscreen DOS box, particularly on
; 		the character mode tests in WHQL, for some reason, the
;		bit does not get cleared and USER ends up thinking that
;		we are in a full-screen DOS BOX when we are really on
;		the Windows desktop. This causes ChangeDisplaySettingsEx
;		to fail without even getting to the display driver.
;
;		The solution is to flip this bit ourselves whenever we
;		receive a SET_DEVICE_FOCUS message in the minivdd to
;		switch from FullScreenDos to FullScreen Windows.
;
; Arguments:	pLogdevCXOffset		GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetUserDosBoxFlagAddress, PASCAL, FRAME, FAR16
PARMD   pLogdevCXOffset
LOCALW	wUserHandle
LOCALV	sVersionInfo,OSVERSIONINFOW
OPENPROC
	PUSHR	esi,edi

	; Assume for a second Let's get USER
        mov     ax,_DATA
        shl     eax,10H
        mov     ax,OFFSET szUserModuleName
        push    eax
        call    GetModuleHandle
        mov	wUserHandle,ax

	; Now check the version of the OS
	mov	sVersionInfo.dwOSVersionInfoSize,SIZE OSVERSIONINFOA
	mov	ax,ss
	shl	eax,10H
	lea	ax,sVersionInfo
	push	eax
	call	GetVersionEx
	or	ax,ax
	je	DoneIt

	; Dispatch to correct OS handler
	mov	eax,sVersionInfo.dwMajorVersion
	mov	ecx,sVersionInfo.dwMinorVersion
	mov	edx,sVersionInfo.dwBuildNumber

	; Make sure it is Windows 9X
	cmp	eax,4
	jne	DoneIt

	; We don't care about Windows 95
	cmp	ecx,0			; Windows 95
	je	DoneIt

	; Check for the three versions of 9X we care about
	cmp	ecx,90			; Windows ME
	jne	NotWinME
	cmp	edx,45A0BB8H
	je	IsOK
	jmp	DoneIt

NotWinME:
	; Windows 98 and Windows 98SE have the same Major
	; and Minor version numbers and build number.
	cmp	ecx,10			; Windows 98,98SE
	jne	DoneIt
	cmp	edx,040A08AEH		; Windows 98,98SE
	jne	DoneIt

IsOK:
	; The technique to get the address of the flag is the same
	; in Win98, Win98SE and WinME so we just use one code path.
	push	wUserHandle
	pushd	602
	call	GetProcAddress
	mov	cx,dx
	or	cx,ax
	je	DoneIt

	; Lets' make sure we won't fault if we read it
	PUSHR	ax,dx
	push	dx
	push	ax
	pushw	30H
	call	IsBadReadPtr
	POPR	di,si
	or	ax,ax
	jne	DoneIt

	; Now we can load the ptr to the code.
	; Let's do a few checks to see if everything is cool.
	mov	fs,si
	cmp	byte ptr fs:[di + 5],0B8H
	jne	DoneIt
	cmp	word ptr fs:[di + 25H],6F6H
	jne	DoneIt

	; There should be a ptr to USER's data selector at offset 6
	mov	si,fs:[di + 6]
	mov	di,fs:[di + 27H]

	; Suppsedly si is the data selector we want. The bit that
	; says "I am in fullscreen DOS" is at si:76A bit 3. Let's
	; make sure that we can read and write that byte.
	push	si
	push	di
	pushw	1
	call	IsBadWritePtr
	or	ax,ax
	jne	DoneIt

	; Everything looks OK. Let's save the address
	mov     es,cs:[wNVTEXT16_Alias_In_NVTEXT16]
	shl	esi,10H
	mov	si,di
	mov	es:[lpUserFullscreenDOSBoxFlag],esi

DoneIt:
	POPR	esi,edi
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNINIT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gninit.asm
;
; Purpose:      This file holds the DllEntryPoint code.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include minivdd.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include escape.inc

OPENSEG  _DATA, USE16, DATA
szModeSetDll            DB      "nvmode.dll",0
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
PUBLIC  CSlp16LogDevice
CSlp16LogDevice                 DD      0

PUBLIC  CSpGNLogicalDevice
CSpGNLogicalDevice              DD      0

PUBLIC  wNVTEXT32_Alias_In_NVTEXT32
wNVTEXT32_Alias_In_NVTEXT32     DW      0

PUBLIC  wNVTEXT16_Alias_In_NVTEXT32
wNVTEXT16_Alias_In_NVTEXT32     DW      0

PUBLIC  wFlatDataSel
wFlatDataSel                    DW      0
CLOSESEG _NVTEXT32


OPENSEG  _NVTEXT16, USE16, CODE
PUBLIC  CSlp16LogDevice_In_NVTEXT16
CSlp16LogDevice_In_NVTEXT16     DD      0

PUBLIC  CSpGNLogicalDevice_In_NVTEXT16
CSpGNLogicalDevice_In_NVTEXT16  DD      0

PUBLIC  wNVTEXT32_Alias_In_NVTEXT16
wNVTEXT32_Alias_In_NVTEXT16     DW      0

PUBLIC  wNVTEXT16_Alias_In_NVTEXT16
wNVTEXT16_Alias_In_NVTEXT16     DW      0

PUBLIC  wFlatDataSel_In_NVTEXT16
wFlatDataSel_In_NVTEXT16        DW      0

PUBLIC  ModesetTable
ModesetTable  LABEL   WORD
DW      OFFSET szModeSetDll, SEG szModeSetDll
hModesetDll                     DW              0
lpfnFindModeEntry                       MODULELINK      <0, 1>
lpfnFindVirtualModeEntry                MODULELINK      <0, 2>
lpfnGetModeList                         MODULELINK      <0, 3>
lpfnGetDesktopModeList                  MODULELINK      <0, 4>
lpfnSetVirtualDesktop                   MODULELINK      <0, 5>
lpfnGetVirtualDesktop                   MODULELINK      <0, 6>
lpfnSetDesktopState                     MODULELINK      <0, 7>
lpfnGetDesktopState                     MODULELINK      <0, 8>
lpfnGetBootDevice                       MODULELINK      <0, 9>
lpfnGetDisplayDevice                    MODULELINK      <0, 10>
lpfnSetDisplayDevice                    MODULELINK      <0, 11>
lpfnGetRefreshRateForDesktop            MODULELINK      <0, 12>
lpfnGetForcedDesktopMode                MODULELINK      <0, 13>
lpfnGetLargestEdidMode                  MODULELINK      <0, 14>
lpfnGetDeviceDesktopMode                MODULELINK      <0, 15>
lpfnSetDeviceDesktopMode                MODULELINK      <0, 16>
lpfnGetForcedDisplayMode                MODULELINK      <0, 17>
lpfnGetDeviceDisplayMode                MODULELINK      <0, 18>
lpfnSetDeviceDisplayMode                MODULELINK      <0, 19>
lpfnGetEdidRegistryKey                  MODULELINK      <0, 20>
lpfnGetLocalNvidiaDisplayRegValue       MODULELINK      <0, 21>
lpfnGetLocalNvidiaDisplayRegString      MODULELINK      <0, 22>
lpfnDeleteLocalRegEntry                 MODULELINK      <0, 23>
lpfnResetRefreshRates                   MODULELINK      <0, 24>
lpfnGetSafeTiming                       MODULELINK      <0, 25>
lpfnSetResolutionAndColorDepth          MODULELINK      <0, 26>
lpfnSetAutoPanMode                      MODULELINK      <0, 27>
lpfnGetAutoPanMode                      MODULELINK      <0, 28>
lpfnSetTimingOverride                   MODULELINK      <0, 29>
lpfnGetTimingOverride                   MODULELINK      <0, 30>
lpfnGetControlVisionFlag                MODULELINK      <0, 31>
lpfnGetBootDeviceSelection              MODULELINK      <0, 32>
lpfnIsDriverAttachedToDesktop           MODULELINK      <0, 33>
lpfnGetAllowAllModesFlag                MODULELINK      <0, 34>
lpfnGetAllowMightyModesFlag             MODULELINK      <0, 35>
lpfnGetCheckSXGAPanelFlag               MODULELINK      <0, 36>
lpfnGetClonePanningFlag                 MODULELINK      <0, 37>
lpfnSetClonePanningFlag                 MODULELINK      <0, 38>
lpfnDisplayDriverControl                MODULELINK      <0, 39>
lpfnFreeMasterLists                     MODULELINK      <0, 40>
lpfnGetCloneDesktopSelection            MODULELINK      <0, 41>
lpfnGetRestrictLargestMode              MODULELINK      <0, 42>
lpfnGet1400x1050Override                MODULELINK      <0, 43>
lpfnGetMaxDfpMode                       MODULELINK      <0, 44>
lpfnGetModesetStopImage                 MODULELINK      <0, 45>
                                        MODULELINK      <0, 0>

;==============================================================================
;
; Function:     DllEntryPoint
;
; Purpose:      The OS calls this function immediaetly after the DLL
;               loads. We don't do anything here.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DllEntryPoint, PASCAL, NOFRAME, FAR16
OPENPROC
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_DllEntryPoint
;
; Purpose:      This routine does all the global init for the driver.
;               It should be called by Enable the very first time the
;               driver loads.
;
; Arguments:
;               lpDstDevType            We can use this to get the
;                                       logical devic handle from the
;                                       minivdd
;               lpThisGdiInfo           GDIINFO ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_DllEntryPoint, PASCAL, FRAME, FAR16
PARMD   lpDstDevType
PARMD   lpThisGdiInfo
LOCALV  sDispInfo,DISPLAYINFO
LOCALD  dwDesktopState
LOCALD  pGNLogdevCXOffset
LOCALD  pGNBoardCXOffset
LOCALD  dwFirstBoardContext
OPENPROC
        PUSHR   ds,esi,edi

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Constants Creation
        push    lpDstDevType
        call    GN_CreateConstants
        or      eax,eax
        je      FailIt_00

IFDEF DEBUG
        ; Catch driver loading for the debugger
        mov     eax,1
        CALLFAR16IND lpfnDisplayDriverControl,es,bx
ENDIF

        call    HW_CreateConstants
        or      eax,eax
        je      FailIt_0

        ; This will keep throughout the routine
        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]

        ; See if we already have an attachment to the board
        ; We need to get the board dev node handle. One way
        ; is through the GetDisplayInfo call.
        mov     ax,ss
        shl     eax,10H
        lea     ax,sDispInfo
        push    eax
        pushd   VDD_GET_DISPLAY_CONFIG
        call    GN_VddGetDisplayInfo

        ; See if a GNBOARDCX already exists for this board
        push    sDispInfo.diDevNodeHandle
        call    GN_FindBoardContext
        mov     dwFirstBoardContext,0
        or      eax,eax
        jne     DoneBoard

First:
        mov     dwFirstBoardContext,1

        ; Create the GNBOARDCX
        push    cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        call    GN_CreateBoardContext
        or      eax,eax
        je      FailIt_1

DoneBoard:
        mov     pGNBoardCXOffset,eax

        ; Now create our logical device context
        push    pGNBoardCXOffset
        call    GN_CreateLogdevContext
        or      eax,eax
        je      FailIt_2
        mov     pGNLogdevCXOffset,eax

        ; We usually only need to attach children to their parents,
        ; but in this one special case we need to attach a parent
        ; to the child. Attach this logical device to the board.
        push    pGNBoardCXOffset
        push    pGNLogdevCXOffset
        call    GN_AttachLogicalDeviceToBoard
        or      eax,eax
        je      FailIt_3
        mov     esi,pGNLogdevCXOffset
        mov     ds:[esi].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard,ecx

        ; Se the GDIINFO ptr
        push    pGNLogdevCXOffset
        push    lpThisGdiInfo
        call    GN_SetGdiInfoPtr

        ; Save off the ptr
        mov     esi,pGNLogdevCXOffset
        mov     es,cs:[wNVTEXT16_Alias_In_NVTEXT16]
        mov     es:[CSpGNLogicalDevice_In_NVTEXT16],esi
        mov     es,cs:[wNVTEXT32_Alias_In_NVTEXT16]
        mov     es:[CSpGNLogicalDevice],esi

        ; The init can handle having more logical devices on the
        ; board than the board has CRTCs. This may seem weird,
        ; but abstractly it works. We limit it here as an external
        ; condition.
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]
        mov     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        cmp     eax,ds:[esi].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard
        jbe     FailIt_4

        ; If the secondry driver is not enabled ("AttachedToDesktop"),
        ; then don't create any CRTCCXs since we will be unloaded immed.
        call    GN_VddIsDriverAttachedToDesktop
        or      ax,ax
        je      DoneClone

        ; Before we get any farther, figure out if we need to make
        ; modifications to the device connections. This is largely
        ; for mobile support.
        push    esi
        call    GN_ResolveDeviceConnectionsOnLoad

        ; Attach a CRTC to this logical device
        push    pGNLogdevCXOffset
        call    GN_LogdevAttachCrtc
        or      eax,eax
        je      FailIt_5

        ; Determine this driver's desktop state -- clone or standard.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10h
        lea     ax,dwDesktopState
        push    eax
        call    FFP16 PTR cs:[lpfnGetDesktopState]
        cmp     dwDesktopState,NVTWINVIEW_STATE_CLONE
        jne     DoneClone

        ; Attach a second CRTC to this logical device
        push    pGNLogdevCXOffset
        call    GN_LogdevAttachCrtc
        or      ax,ax
        jne     DoneClone

        ; Don't fail if there wasn't a device to use as a
        ; clone device. Just revert to standard mode.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        pushd   NVTWINVIEW_STATE_NORMAL
        CALLFAR16IND lpfnSetDesktopState,es,ax

DoneClone:
        ; Setup control offscreen allocations callbacks
        ; for the primary device
        cmp     dwThisLogicalDeviceHandle_In_NVTEXT16,1
        jne     Secondary
        call    GN_VddSetLockAndUnlockOffscreen
        call    GN_VddSetPowerManagementCallbacks

Secondary:
        mov     eax,1
        jmp     DoneIt

FailIt_6:
FailIt_5:
FailIt_4:
        push    pGNBoardCXOffset
        push    pGNLogdevCXOffset
        call    GN_DetachLogicalDeviceFromBoard

FailIt_3:
        push    pGNLogdevCXOffset
        call    GN_DestroyLogdevContext

FailIt_2:
        cmp     dwFirstBoardContext,0
        je      FailIt_1
        push    pGNBoardCXOffset
        call    GN_DestroyBoardContext

FailIt_1:
        push    dwThisLogicalDeviceHandle_In_NVTEXT16
        call    HW_DestroyConstants

FailIt_0:
        call    GN_DestroyConstants
        sub     eax,eax

FailIt_00:
DoneIt:
        POPR    ds,esi,edi
CLOSEPROC



;==============================================================================
;
; Function:     GENERIC_WEP
;
; Purpose:      This function is the WEP entry point.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve      ds,esi,edi
;==============================================================================
PUBLIC  WEP
WEP     PROC    FAR16
        ; Windows requires that WEP be exported by name. I have the
        ; real routine GENERIC_WEP equated to the same address.
        .errnz  $ - OFFSET GENERIC_WEP
WEP     ENDP

DECPROC GENERIC_WEP, PASCAL, FRAME, FAR16
LOCALD  dwCRTCCount
LOCALD  dwLogdevAttachedToBoard
LOCALD  pGNBoardContext
LOCALD  pGNBoardCXOffset
LOCALD  dwDriverEnabled
OPENPROC
        PUSHR   ds,esi,edi

IFDEF DEBUG
        ; Catch driver unloading for the debugger
        mov     eax,0
        CALLFAR16IND lpfnDisplayDriverControl,es,bx
ENDIF

        ; Check to see how far in the creation process we got.
        ; We are guaranteed from the way GN_DllEntryPoint is
        ; written that if wNVTEXT16_Alias_In_NVTEXT16 is non-0,
        ; then we have a GNLOGDEVCX created.
        cmp     cs:[wNVTEXT16_Alias_In_NVTEXT16],0
        je      DoneIt

        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     esi,CSpGNLogicalDevice_In_NVTEXT16

        ; Sometimes disable doesn't get called, but WEP does
        ; and we see a flash of garbage when shutting down.
        ; This may prevent that. Windows clears the AttachToDesktop
        ; flag before calling WEP!! So, check to see if we
        ; created a primary CRTCCX to know if this driver was
        ; really enabled or not -- unh!
        mov     eax,dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     dwDriverEnabled,eax

        cmp     dwDriverEnabled,0
        je      @F
        push    esi
        call    GN_BlankScreen
@@:
        ; Tell everyone that we are unloading.
        sub     eax,eax
        push    esi
        pushd   MSG_DISPLAY_DRIVER_UNLOADING
        push    eax
        push    eax
        call    GN_LogdevMessage

        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     pGNBoardCXOffset,eax

        ; One less logical device on this board
        push    pGNBoardCXOffset
        push    esi
        call    GN_DetachLogicalDeviceFromBoard
        mov     dwLogdevAttachedToBoard,eax

        cmp     dwDriverEnabled,0
        je      @F
        cmp     dwLogdevAttachedToBoard,0
        je      @F
        ; The secondary driver is being unloaded. Tell ResMan we are
        ; leaving spanning mode.
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        pushd   0
        call    HW_TellResManSpanningState
@@:
        ; Destroy the logical device context
        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     pGNBoardContext,eax
        push    esi
        call    GN_DestroyLogdevContext

        cmp     dwDriverEnabled,0
        je      @F
        cmp     dwLogdevAttachedToBoard,0
        je      @F
        ; We might want to change display device configurations now
        mov     eax,pGNBoardCXOffset
        push    dword ptr ds:[eax].GNBOARDCX.pGNLogdevCX
        call    GN_ResolveDeviceConnectionsOnUnload
@@:
        cmp     dwLogdevAttachedToBoard,0
        jne     @F
        push    pGNBoardContext
        call    GN_DestroyBoardContext
@@:
        push    dwThisLogicalDeviceHandle_In_NVTEXT16
        call    HW_DestroyConstants

        call    GN_DestroyConstants

DoneIt:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_CreateConstants
;
; Purpose:      This functions should init any things that are
;               effectively constants in the driver. Usually these
;               are items that go in the code segment. This routine
;               is called only once at boot and no context has yet
;               been created.
;
; Arguments:    None
;
; Returns:      eax     0       Failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_CreateConstants, PASCAL, FRAME, FAR16
PARMD   lpDstDevType
OPENPROC
        PUSHR   ds

        ; Allocate a writable alias for the 16bit code segment.
        mov     ax,SEG wNVTEXT16_Alias_In_NVTEXT16
        push    ax
        call    AllocCSToDSAlias
        or      ax,ax
        je      Done
        mov     ds,ax
        mov     ds:[wNVTEXT16_Alias_In_NVTEXT16],ax

        ; Allocate a writable alias for the 32bit code segment
        mov     ax,SEG wNVTEXT16_Alias_In_NVTEXT32
        push    ax
        call    AllocCSToDSAlias
        or      ax,ax
        je      Done
        mov     es,ax
        mov     es:[wNVTEXT32_Alias_In_NVTEXT32],ax

        ; Now put each in the other
        mov     ax,es:[wNVTEXT32_Alias_In_NVTEXT32]
        mov     ds:[wNVTEXT32_Alias_In_NVTEXT16],ax
        mov     ax,ds:[wNVTEXT16_Alias_In_NVTEXT16]
        mov     es:[wNVTEXT16_Alias_In_NVTEXT32],ax

        ; The VDDEntryPoint is just an address that is constant
        call    GN_VddGetEntryPoint

        ; Let's get the device handle so we can get a unique
        ; board identifier.
        push    lpDstDevType
        call    GN_VddGetDeviceHandle
        or      eax,eax
        je      Done

        lea     esi,ModesetTable
        call    GN_LoadDllAndGetExports
Done:
        POPR    ds
CLOSEPROC


;==============================================================================
;
; Function:     GN_DestroyConstants
;
; Purpose:      This functions should destroy any "constants"
;               created by the CreateConstants routine. This
;               routine is called once when the driver is about
;               to be unloaded.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_DestroyConstants, PASCAL, NOFRAME, FAR16
OPENPROC

        ; Make sure that none of the selectors
        ; has any selectors we are about to free in them.
        sub     ax,ax
        mov     ds,ax
        mov     es,ax
        mov     fs,ax
        mov     gs,ax

        ; Did we even create an NVTEXT32 Code Alias?
        mov     ax,cs:[wNVTEXT32_Alias_In_NVTEXT16]
        or      ax,ax
        je      Done32

        ; Zero out the variables in this code segment.
        mov     ds,ax
        mov     ds:[CSpGNLogicalDevice],0
        mov     ds:[wNVTEXT16_Alias_In_NVTEXT32],0

        sub     eax,eax
        mov     ds:[wNVTEXT32_Alias_In_NVTEXT32],ax
        mov     cx,ds
        mov     ds,ax

        ; Free our writable NVTEXT32 code segment alias
        push    cx
        call    FreeSelector
Done32:

        ; Did we even create a NVTEXT16 Code Alias?
        mov     ax,cs:[wNVTEXT16_Alias_In_NVTEXT16]
        or      ax,ax
        je      Done16
        mov     ds,ax

        ; Zero out the variables in this code segment.
        mov     ds:[CSpGNLogicalDevice_In_NVTEXT16],0
        mov     ds:[wNVTEXT32_Alias_In_NVTEXT16],0

        sub     eax,eax
        mov     ds:[wNVTEXT16_Alias_In_NVTEXT16],ax
        mov     cx,ds
        mov     ds,ax

        ; Free our writable NVTEXT16 code segment alias
        push    cx
        call    FreeSelector
Done16:
CLOSEPROC


;==============================================================================
;
; Function:     GN_LoadDllAndGetExports
;
; Purpose:      This function loads the NvSys 16-bit RM interface dll
;               and gets addresses to the exports.
;
; Arguments:
;               ds:esi  offset of a MODULELINK array
;
; Returns:      eax     0       then load or export grab failed
;                       non-0   then everything was a success
;
; Preserve:     ds,esi
;==============================================================================
DECPROC GN_LoadDllAndGetExports, PASCAL, FRAME, FAR16
LOCALW  hDll
OPENPROC
        PUSHR   ds,esi,edi      ; LoadLibrary trashes DI and SI

        ; Load the library.  If it fails to load, we are totally hosed
        ; and there is no way to recover so blow off error code check.
        PUSHR   esi
        push    dword ptr ds:[esi]
        call    LoadLibrary
        POPR    esi
        mov     hDll,ax
        mov     ds:[esi + 4],ax
        add     esi,6

        ; Get some proc address
@@:     push    hDll
        pushw   0
        push    ds:[esi].MODULELINK.wOrdinal
        call    GetProcAddress
        shl     edx,10H
        mov     dx,ax
        mov     ds:[esi].MODULELINK.lpfnFunc,edx
        add     esi,SIZE MODULELINK
        add     edi,2
        cmp     word ptr ds:[esi].MODULELINK.wOrdinal,0
        jne     @B

        mov     eax,1
        POPR    ds,esi,edi
CLOSEPROC

CLOSESEG _NVTEXT16

END     DllEntryPoint
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNLOGDEV.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnlogdev.asm
;
; Purpose:      This file holds the init and deinit of the
;               GNLOGDEVCX.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include minivdd.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc
include modeext.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GN_CreateLogdevContext
;
; Purpose:      This routine initializes a GNLOGDEV structure.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;
; Returns:      eax     0       failure
;                       else    Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_CreateLogdevContext, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
LOCALD  dwVirtualDesktopState
LOCALD  dwCRTCIndex
LOCALV  sDispInfo,DISPLAYINFO
OPENPROC
        PUSHR   esi,edi
        sub     esi,esi

        ; Allocate memory for the GNLOGDEVCX
        pushd   SIZE GNLOGDEVCX
        call    HW_AllocFlatMemory
        or      eax,eax
        je      DoneIt
        mov     esi,eax

        ; Crate the HW logical device next
        mov     eax,pGNBoardCXOffset
        push    ds:[eax].GNBOARDCX.pHWBoardCX
        call    HW_CreateLogdevContext
        or      eax,eax
        je      DoneIt
        mov     ds:[esi].GNLOGDEVCX.pHWLogdevCX,eax

        ; We are initting. This will be cleared after the first modeset.
        mov     ds:[esi].GNLOGDEVCX.dwInitting,1

        ; Fill in the logical board ptr
        mov     eax,pGNBoardCXOffset
        mov     ds:[esi].GNLOGDEVCX.pGNBoardCX,eax

        ; Save off the code segment values -- Ugh!
        mov     ds:[esi].GNLOGDEVCX.dw16BitCodeSegment,_NVTEXT16
        mov     ds:[esi].GNLOGDEVCX.dw32BitCodeSegment,_NVTEXT32

	; This gets initted to -1
        mov     ds:[esi].GNLOGDEVCX.dwCplData,-1

        ; We need a 16:16 ptr in the GNLOGDEVCX.Dibeng.deBitmapInfo
        ; field to the GNCRTCCX.bmi field.
        mov     eax,1
        lea     ebx,[esi].GNLOGDEVCX.bmi
        mov     ecx,SIZE DIBHEADER + 410H       ; 400H for palette table +
                                                ; some slack just in case
        ; Fill in the DIBENG header, Default to 640x480x8
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
        shl     eax,10H
        sub     edx,edx
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deBitmapInfo,eax
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deType,'RP'
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deWidth,640
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deHeight,480
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deWidthBytes,640
        mov     ds:[esi].GNLOGDEVCX.Dibeng.dePlanes,1
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deBitsPixel,8
        mov     dword ptr ds:[esi].GNLOGDEVCX.Dibeng.bRealBpp,8
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deDeltaScan,640
        mov     ds:[esi].GNLOGDEVCX.Dibeng.delpPDevice,edx
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deBitsOffset,edx

        ; Get the frame buffer selector from the GNBOARDCX
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        call    GN_GetFrameBufferSelector
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deBitsSelector,ax
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deFlags,MINIDRIVER + VRAM
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deVersion,400H
        mov     eax,OFFSET GENERIC_BeginAccess
        mov     ecx,OFFSET GENERIC_EndAccess
        mov     dx,SEG GENERIC_BeginAccess
        shl     edx,10H
        mov     dx,ax
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deBeginAccess,edx
        mov     dx,cx
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deEndAccess,edx

        ; Fill in the bmi Header
        sub     edx,edx
        mov     ds:[esi].GNLOGDEVCX.bmi.biSize,SIZE DIBHEADER
        mov     ds:[esi].GNLOGDEVCX.bmi.biWidth,edx
        mov     ds:[esi].GNLOGDEVCX.bmi.biHeight,edx
        mov     ds:[esi].GNLOGDEVCX.bmi.biPlanes,1
        mov     ds:[esi].GNLOGDEVCX.bmi.biBitCount,dx
        mov     ds:[esi].GNLOGDEVCX.bmi.biCompression,edx
        mov     ds:[esi].GNLOGDEVCX.bmi.biSizeImage,edx
        mov     ds:[esi].GNLOGDEVCX.bmi.biXPelsPerMeter,edx
        mov     ds:[esi].GNLOGDEVCX.bmi.biYPelsPerMeter,edx
        mov     ds:[esi].GNLOGDEVCX.bmi.biClrUsed,edx
        mov     ds:[esi].GNLOGDEVCX.bmi.biClrImportant,edx

        ; Assume 0 for these right now
        mov     ds:[esi].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard,0
        mov     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,0

        ; Get the number of CRTCS
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        call    GN_GetNumCRTCs
        mov     ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard,eax

        ; Do we have virtual desktops? The registry knows.
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        call    GN_GetBoardRegistryPath
        mov     ds:[esi].GNLOGDEVCX.lpBoardRegistryData,eax

        mov     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0

        ; Are they using 1-5-5-5 or 5-6-5 mode for this logical device
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_Get16BppPixelFormat
        mov     ds:[esi].GNLOGDEVCX.dw16BppFormat,eax

        ; Are they bitpacked or byte packed fonts
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_GetTextFormat
        mov     ds:[esi].GNLOGDEVCX.dwFontFormat,eax

        ; Init the save screen bitmap stuff
        push    esi
        call    GN_ClearSaveScreenBitmapCache

        ; Init the macrovision stuff
        mov     ds:[esi].GNLOGDEVCX.dwCurrentMacrovisionKey,-1
        mov     ds:[esi].GNLOGDEVCX.dwNextMacrovisionKey,99999999H
        mov     ds:[esi].GNLOGDEVCX.dwMacrovisionMode,0
        mov     ds:[esi].GNLOGDEVCX.dwMacrovisionNavigatorID,0

        ; Hook int2F. This protects itself from hooking more than once
        ; and also will not hook unless we are the primary device.
        push    pGNLogdevCXOffset
        call    GN_HookInt2F

        mov     eax,esi
DoneIt:
        ; If eax is 0, then we failed, BUT if esi is non-0, then
        ; some of the GNLOGDEVCX. was filled in. We must handle
        ; this case and free any portion that got initted.
        or      eax,eax
        jne     ExitIt
        or      esi,esi
        je      ExitIt

        ; GN_DestroyLogdevContext can clean up partial inits
        push    esi
        call    GN_DestroyLogdevContext
        sub     eax,eax

ExitIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_DestroyLogdevContext
;
; Purpose:      This routine destroys a GNLOGDEVCX structure.
;               You do not need to free its memory. Just free any
;               resources inside the structure.
;
; Arguments:
;               ds              Context Selector
;               pGNLogdevCXOffset       Offset to the pdev context data
;
; Returns:      eax     0       failure
;                       else    Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_DestroyLogdevContext, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
LOCALD  pGNBoardCXOffset
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset
        or      esi,esi
        je      DoneIt

        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     pGNBoardCXOffset,eax

        ; UnHook int2F. This routine will not unhook if we are not
        ; already hooked.
        push    pGNLogdevCXOffset
        call    GN_UnhookInt2F

        sub     edi,edi
@@:
        cmp     dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4],0
        je      NextCrtc

        call    GN_VddIsDriverAttachedToDesktop
        or      eax,eax
        jnz     DoNotInitResolutionForClone

        ; Clear panning flag to prevent the next clone limitation
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    ds:[ebx].GNCRTCCX.lpBoardRegistryData
        push    ds:[ebx].GNCRTCCX.lpCrtcModeInfo
        pushd   0
        CALLFAR16IND lpfnSetClonePanningFlag,es,ax

DoNotInitResolutionForClone:
        push    esi
        push    edi
        call    GN_LogdevDetachCrtc
NextCrtc:
        inc     edi
        cmp     edi,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      @B

        ; Free the primary surface memory.
        cmp     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        je      @F
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    ds:[esi].GNLOGDEVCX.Dibeng.deBitsOffset
        call    HW_FreePrimarySurface
        mov     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
@@:
        ; Free the selector we were using for the BitmapInfo
        mov     eax,ds:[esi].GNLOGDEVCX.Dibeng.deBitmapInfo
        or      eax,eax
        je      Skip0
        shr     eax,10H
        call    GN_UnmapAndFreeSelector
        mov     ds:[esi].GNLOGDEVCX.Dibeng.deBitmapInfo,0
Skip0:
        cmp     ds:[esi].GNLOGDEVCX.pHWLogdevCX,0
        je      @F
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_DestroyLogdevContext
        mov     ds:[esi].GNLOGDEVCX.pHWLogdevCX,0
@@:
        ; Clear out a few fields
        push    esi
        call    HW_FreeFlatMemory

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_SetGdiInfoPtr
;
; Purpose:      This routine sets the GDIINFO ptr in the GNLOGDEVCX.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX
;               lpThisGdiInfo           16:16 ptr to GdiInfo table
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_SetGdiInfoPtr, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
PARMD   lpThisGdiInfo
LOCALD  dwState
OPENPROC
        mov     eax,lpThisGdiInfo
        mov     edx,pGNLogdevCXOffset
        mov     ds:[edx].GNLOGDEVCX.lpGdiInfo,eax

        ; OK, it is kind of weird to put this code in this routine,
        ; but there is an order problem. We can do this at create
        ; time because we don't know the value of
        ; dwLogicalDeviceInstanceOnThisBoard at that time. But by
        ; the time we get called here, we do know it. So....
        push    ds:[edx].GNLOGDEVCX.lpBoardRegistryData
        push    ds:[edx].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard
        mov     ax,ss
        shl     eax,10H
        lea     ax,dwState
        push    eax
        CALLFAR16IND lpfnGetVirtualDesktop,es,ax
        mov     edx,pGNLogdevCXOffset
        mov     eax,dwState
        mov     ds:[edx].GNLOGDEVCX.dwVirtualDesktopEnabled,eax
CLOSEPROC


;==============================================================================
;
; Function:     GN_LogdevAttachCrtc
;
; Purpose:      This routine attaches a CRTC to a logical device
;               giving a viewable display to a logical desktop.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;
; Returns:      eax     0       failure
;                       else    Success
;                               In this case, ebx is the physical device num
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_LogdevAttachCrtc, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
LOCALD  pGNCrtcCXOffset
LOCALD  dwPhysicalDeviceNum
LOCALD  dwDeviceCount
LOCALD  dwIsBootCrtc
LOCALS  LocalDevData,(MAX_ATTACHED_CRTCS*4)
LOCALD  lpLocalDevData
LOCALS  aGNCrtcCX,(MAX_ATTACHED_CRTCS*4)
LOCALS  aHWCrtcCX,(MAX_ATTACHED_CRTCS*4)
LOCALD  lpGNCrtcCX
LOCALD  lpHWCrtcCX
LOCALD  dwUnusedIndex
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset

        mov     ax,ss
        shl     eax,10H
        lea     ax,LocalDevData
        mov     lpLocalDevData,eax
        lea     ax,aGNCrtcCX
        mov     lpGNCrtcCX,eax
        lea     ax,aHWCrtcCX
        mov     lpHWCrtcCX,eax

        ; Find a free attachment point
        sub     eax,eax
        sub     ebx,ebx
@@:
        cmp     ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4],0
        je      FoundIt
        inc     ebx
        cmp     ebx,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      @B
        jmp     DoneIt

FoundIt:
        mov     dwPhysicalDeviceNum,ebx

        ; If this is PhysicalDevice0 on the primary driver, then this
        ; is the boot crtc.
        sub     edx,edx
        or      ebx,ebx
        jne     @F
        mov     dx,SEG dwThisLogicalDeviceHandle
        mov     es,dx
        mov     edx,es:[dwThisLogicalDeviceHandle]
        cmp     edx,1
        sete    dl
        movzx   edx,dl
@@:     mov     dwIsBootCrtc,edx

        ; OK, this is a bit tricky. If this is dwPhysicalDeviceNum = 0,
        ; then we are here because a driver is loading. In that case,
        ; it is because we are booting, OR because we are running multimon
        ; and someone enabled another device on the Windows Settings page.
        ; We want to allow this driver to come up if at all possible.
        ; The one thing that might hinder us is if there are no more
        ; physical CRTCS available to assign to this driver as the primary.
        ; Let's see if this is the case currently.

        ; How many CRTCS are currently in use?
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    lpLocalDevData
        push    lpGNCrtcCX
        push    lpHWCrtcCX
        pushd   MAX_ATTACHED_CRTCS
        call    GN_GetAllDeviceData
        cmp     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jb      AnAvailCrtc

        ; All CRTCs are currently in use. However, if any of them
        ; is currently being used as a clone device, we will steal
        ; it away so that we can use it as the primary for this
        ; driver.
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        call    GN_FindFirstCloneDevice
        or      ebx,ebx
        je      DoneIt

        ; HA! We found a GNLOGDEVCX with a clone device
        ; Bump the number of clones awaited by 1 in the logical device
        ; that we are stealing the CRTCCX from. When we destroy the Logdev
        ; which stole the clone away, we will give it back to a logdev
        ; which is awaiting clones (in GN_DestroyLogdevContext).
        inc     ds:[ebx].GNLOGDEVCX.dwNumClonesAwaited

        ; Remove the clone
        push    ebx
        push    eax
        call    GN_LogdevDetachCrtc

        ; Now there should be an available CRTCCX

AnAvailCrtc:
        ; Create a GNCRTCCX
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[esi].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard
        push    dwPhysicalDeviceNum
        push    dwIsBootCrtc
        call    GN_CreateCrtcContext
        or      eax,eax
        je      DoneIt
        mov     pGNCrtcCXOffset,eax

        ; This is UGLY and a bit of a hack right now. In multiomon
        ; this routine can be called with the context of the other
        ; driver. That is fine, but CreateCrtcContext stores the
        ; address of the function GN_Far16GetModeSize in the GNCRTCCX.
        ; The problem is that the code segment is incorrect because
        ; the code seg it stores is for this driver! Ugh! One driver
        ; is what we really want with all data just context. But for now..
        mov     ecx,ds:[esi].GNLOGDEVCX.dw16BitCodeSegment
        lea     edx,[eax].GNCRTCCX.sNvmodeDispData
        mov     word ptr ds:[edx].DISPDATA.lpfnGetModeSize+2,cx
        mov     word ptr ds:[edx].DISPDATA.lpfnIsModeAcceptedByDriver+2,cx

        ; This is tentative! We haven't yet determined if it is OK
        ; to attach the CRTC, so we have to clear it out if it fails.
        ; We need to do it though for some of the other tests to work.
        mov     ebx,dwPhysicalDeviceNum
        mov     ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4],eax

        ; Get the Device Data specifying the device the CRTC desires
        push    pGNCrtcCXOffset
        call    GN_GetDevData
        mov     dword ptr LocalDevData,eax

        ; Make sure that the device desired by this CRTC is not
        ; in use by any other active CRTCCX on the board.
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    pGNCrtcCXOffset
        call    GN_IsDevDataUniqueOnBoard
        or      eax,eax
        mov     dwUnusedIndex,0
        jne     IsUnique

TryOther:
        ; Nope! The device is in use!
        ; Set the device used by the CRTCCX to nothing
        push    pGNCrtcCXOffset
        pushd   0FFFFFFFFH
        call    GN_SetDevData

        ; Find an unused device
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    dwUnusedIndex
        call    GN_FindUnusedDevice

        ; If there isn't an unused device, then abort the attach
        cmp     eax,-1
        je      FailIt
        mov     dword ptr LocalDevData,eax

        ; Find unused device can find a device type and a device
        ; number. However, in order to get a device format (like
        ; NTSCM, or PALA), we need to ask the ResMan what the
        ; last format was on that device. Right now, this only
        ; applies if the device type is a tv, but for consistency
        ; I always get the last display format. For non-tv's,
        ; this will simply set the format to 0.
        cmp     byte ptr LocalDevData,DEVTYPE_TV
        jne     GotDevData
        mov     eax,pGNCrtcCXOffset
        push    ds:[eax].GNCRTCCX.pHWCrtcCX
        push    dword ptr LocalDevData
        call    HW_GetResManTvFormat
        shl     eax,10h
        and     dword ptr LocalDevData,0ff00ffffh
        or      dword ptr LocalDevData,eax
        jmp     GotDevData

IsUnique:
        ; OK, sure it's unique, but is the device connectable to some
        ; head? (any head - it doesn't matter right now which one.)
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ecx].GNBOARDCX.pHWBoardCX
        push    dword ptr LocalDevData
        call    HW_IsDeviceAttached
        or      eax,eax
        je      TryOther

        ; If this device doesn't work, then dwUnusedIndex will
        ; be incremented and we will start scanning at the zeroth
        ; unused device for others that might.
        mov     dwUnusedIndex,-1

GotDevData:
        ; OK, tentatively, we will allow this CRTCCX to be
        ; the device type / number found.
        push    pGNCrtcCXOffset
        push    dword ptr LocalDevData
        call    GN_SetDevData

        ; OK, we have a unique device (from the others in use)
        ; that is connected to the system. Now can we find an
        ; arrangment whereby this device can be used?
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    lpLocalDevData
        push    lpGNCrtcCX
        push    lpHWCrtcCX
        pushd   MAX_ATTACHED_CRTCS
        call    GN_GetAllDeviceData
        mov     dwDeviceCount,eax

        ; Ask the hardware if it is possible to have all the
        ; devices specified enabled simultaneously by assigning
        ; each to a different head.
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ecx].GNBOARDCX.pHWBoardCX
        push    lpLocalDevData
        push    dwDeviceCount
        call    HW_CanDevicesBeMapped
        or      eax,eax
        jne     GoodToGo

        ; If we only have one device, failing the mapping is fatal.
        cmp     dwDeviceCount,1
        je      FailIt

        ; Failing the mapping when there is more than one device
        ; may simply mean that the set of devices requested cannot
        ; all be used simultaneously. But there might be a different
        ; device which is available which could be used for the new
        ; CRTC we are trying to attach.
        inc     dwUnusedIndex
        jmp     TryOther

GoodToGo:
        ; OK, NOW we can read the EDID
        mov     edi,pGNCrtcCXOffset
        lea     ebx,[edi].GNCRTCCX.sCrtcModeInfo
        cmp     ds:[ebx].MODEINFO.MIDevData.cType,DEVTYPE_TV
        je      SkipEdidRead
        
        mov     ds:[edi].GNCRTCCX.dwEdidSize,MAX_EDID_BUFFER_SIZE
        push    ds:[edi].GNCRTCCX.pHWCrtcCX
        push    ds:[ebx].MODEINFO.MIDevData
        lea     eax,[edi].GNCRTCCX.sEdidBuffer
        push    eax
        lea     eax,[edi].GNCRTCCX.dwEdidSize
        push    eax
        call    HW_ReadEdid
        
SkipEdidRead:
        ; Write out the display device for the CRTCCX
        push    pGNCrtcCXOffset
        call    GN_GetDevData
        mov     dword ptr LocalDevData,eax
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    ds:[esi].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard
        push    dwPhysicalDeviceNum
        push    lpLocalDevData
        CALLFAR16IND lpfnSetDisplayDevice,es,ax

        ; If this device is a TV, set the TV Format in the ResMan.
        cmp     byte ptr LocalDevData,DEVTYPE_TV
        jne     SkipTVFormat
        mov     eax,pGNCrtcCXOffset
        push    ds:[eax].GNCRTCCX.pHWCrtcCX
        push    dword ptr LocalDevData
        call    HW_SetResManTvFormat
        
SkipTVFormat:
        ; Tell the HWLOGDEVCX about its new CRTCCX
        mov     eax,pGNCrtcCXOffset
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    dwPhysicalDeviceNum
        push    ds:[eax].GNCRTCCX.pHWCrtcCX
        call    HW_LogdevAttachCrtc

        ; One more CRTC attached to this logical device
        inc     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        mov     ebx,dwPhysicalDeviceNum
        mov     eax,1

        ; If this was a clone device that was added, then we can
        ; decrement WaitingOnAClone if it is > 0.
        or      ebx,ebx
        je      DoneIt
        sub     ds:[esi].GNLOGDEVCX.dwNumClonesAwaited,1
        jge     DoneIt
        mov     ds:[esi].GNLOGDEVCX.dwNumClonesAwaited,0
        jmp     DoneIt

FailIt:
        ; remove the CRTCCX from our array since it isn't
        ; going to work.
        sub     eax,eax
        mov     ecx,dwPhysicalDeviceNum
        mov     ds:[esi].GNLOGDEVCX.pGNCrtcCX[ecx * 4],eax

        push    pGNCrtcCXOffset
        call    GN_DestroyCrtcContext
        sub     eax,eax

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_LogdevDetachCrtc
;
; Purpose:      This routine detaches a CRTC from a logical device
;               removing a viewable display from a logical desktop.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;               dwPhysDevNum            0 based CRTCCX to detach
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_LogdevDetachCrtc, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
PARMD   dwPhysDevNum
LOCALS  LocalDevData,(MAX_ATTACHED_CRTCS*4)
LOCALD  lpLocalDevData
LOCALS  aHWCrtcCX,MAX_ATTACHED_CRTCS*4
LOCALD  lpHWCrtcCX
LOCALD  dwDeviceCount
LOCALD  dwDevicesChanged
LOCALD  dwDeviceMask
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset

        ; Is there a valid GNCRTCCX in that logical slot?
        mov     edi,dwPhysDevNum
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        or      ecx,ecx
        je      DoneIt

        ; Some prep for other code
        mov     ax,ss
        shl     eax,10H
        lea     ax,LocalDevData
        mov     lpLocalDevData,eax
        lea     ax,aHWCrtcCX
        mov     lpHWCrtcCX,eax

        ; Tell the HWLOGDEVCX to detach its CRTCCX
        ; We MUST be careful here. If DDRAW has locked
        ; our HWCRTCCX, we must use the cached copy to free
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        mov         eax,ds:[ecx].GNCRTCCX.pHWCrtcCX
        or          eax,eax
        jne         @F
        mov         eax,ds:[ecx].GNCRTCCX.pHWCrtcCXWhenLocked
        mov         ds:[ecx].GNCRTCCX.pHWCrtcCX,eax
        mov         ds:[ecx].GNCRTCCX.pHWCrtcCXWhenLocked,0
@@:
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    dwPhysDevNum
        push    eax
        call    HW_LogdevDetachCrtc

        ; What display devices will be in use AFTER we detach this
        ; CRTC. Well, GetDevDataMask will tell give us a mask of
        ; all the display devices EXCEPT the one is use by the
        ; CRTCCX passed in.
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        call    GN_GetDevDataMask
        mov     dwDeviceMask,eax

        ; Signal the beginning of a display state change
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    eax
        call    HW_BeginDisplayChange

        ; Destroy the CRTCCX
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        mov     dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4],0
        call    GN_DestroyCrtcContext

        ; Signal the end of a display state change
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwDeviceMask
        call    HW_EndDisplayChange

        ; One less CRTC attached to this logical device
        dec     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        mov     eax,1

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_LogdevAddAClone
;
; Purpose:      This routine tries to adda clone display to the logical
;               device.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;               dwPhysDevNum            0 based CRTCCX to detach
;
; Returns:
;               eax                     0       Failed
;                                       non-0   Success
;                                               In this case ebx holds
;                                               the physical device index
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_LogdevAddAClone, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
LOCALV  sDesktopModeInfo,MODEINFO
LOCALD  lpDesktopModeInfo
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset

        ; OK, normal->clone means we attach a crtc
        push    esi
        call    GN_LogdevAttachCrtc

        ; If we couldn't attach, then stay in normal mode
        or      eax,eax
        je      DoneIt
        mov     edi,ebx

        ; Build up the desktop MODEINFO
        mov     ax,ss
        shl     eax,10H
        lea     ax,sDesktopModeInfo
        mov     lpDesktopModeInfo,eax

        ; Set the MIDevData into sDesktopModeInfo.
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        call    GN_GetDevData
        mov     sDesktopModeInfo.MIDevData,eax
        
        ; Get the refresh rate from the registry.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    lpDesktopModeInfo
        CALLFAR16IND lpfnGetDeviceDisplayMode,es,ax
        or      ax,ax
        jne     UseRefreshRate

        ; No mode in the registry, use 60Hz as default.
        mov     sDesktopModeInfo.dwRefreshRate,60

UseRefreshRate:
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
        mov     sDesktopModeInfo.dwXRes,eax
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
        mov     sDesktopModeInfo.dwYRes,eax
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deBitsPixel
        mov     sDesktopModeInfo.dwBpp,eax

        ; Only set the desktop mode into the registry of the primary
        ; display device.
        cmp     edi,0
        jne     SkipSetDesktop
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10H
        lea     ax,sDesktopModeInfo
        push    eax
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetCloneDesktopSelection,es,ax
        cmp     ax,1
        mov     eax,0
        jne     @F
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,2
        jl      @F
        mov     eax,1
@@:     push    eax     
        CALLFAR16IND lpfnSetDeviceDesktopMode,es,ax

SkipSetDesktop:
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10H
        lea     ax,sDesktopModeInfo
        push    eax
        CALLFAR16IND lpfnSetDeviceDisplayMode,es,ax
        mov     sDesktopModeInfo.dwRefreshRate,60

        ; I know these are wrong. We haven't yet mapped devices.
        ; There is a partial chicken or egg problem here. It is
        ; not too big a deal because by the time we actually go
        ; to set the physical mode, these will be valid and we
        ; will back off if need be.
        mov     edx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        lea     edx,[edx].GNCRTCCX.sNvmodeDispData
        mov     ds:[edx].DISPDATA.dwMaxDacSpeedInHertz8bpp,40000000H
        mov     ds:[edx].DISPDATA.dwMaxDacSpeedInHertz16bpp,40000000H
        mov     ds:[edx].DISPDATA.dwMaxDacSpeedInHertz32bpp,40000000H

        ; Get the CRTC mode (the desktop mode is just a suggestion)
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    lpDesktopModeInfo
        call    GN_GetCrtcMode

        ; There are a few things whose state we would like to grab
        ; from the primary CRTCCX and copy into this new clone device's
        ; CRTCCX.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[0 * 4]
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]

        ; First, The pan base and pitch
        mov     eax,ds:[ebx].GNCRTCCX.dwBytesPerPixelInCurrentMode
        mov     ds:[ecx].GNCRTCCX.dwBytesPerPixelInCurrentMode,eax
        mov     eax,ds:[ebx].GNCRTCCX.dwBytesPerLineInCurrentMode
        mov     ds:[ecx].GNCRTCCX.dwBytesPerLineInCurrentMode,eax

        ; One last thing. Right now the default palette / gamma table
        ; is in the new clone CRTCCX. This is probably not right. We
        ; should copy the palette and gamma table from the primary
        ; CRTCCX just as a starting point.
        PUSHR   esi,edi
        mov     ebx,esi
        mov     edx,edi
        mov     edi,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        lea     edi,[edi].GNCRTCCX.dwPaletteTable
        mov     esi,[esi].GNLOGDEVCX.pGNCrtcCX
        lea     esi,[esi].GNCRTCCX.dwPaletteTable
        mov     ax,ds
        mov     es,ax
        mov     ecx,100H
        rep     movs dword ptr es:[edi], ds:[esi]

        sub     esi,400H
        lea     esi,[esi].GNCRTCCX.dwGammaTable
        sub     edi,400H
        lea     edi,[edi].GNCRTCCX.dwGammaTable
        mov     ecx,100H
        rep     movs dword ptr es:[edi], ds:[esi]
        POPR    esi,edi

        ; Copy the Cursor cache from the primary CRTCCX into the
        ; Clone CRTCCX
        PUSHR   esi,edi
        mov     edi,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        mov     edi,ds:[edi].GNCRTCCX.pCursorCache
        mov     esi,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     esi,ds:[esi].GNCRTCCX.pCursorCache
        mov     ecx,SIZE CURSORCACHE + (SIZE CURSORDESCEX * MAX_CACHEABLE_CURSORS)
        rep     movs byte ptr es:[edi], ds:[esi]
        POPR    esi,edi

        ; Success
        mov     eax,1
        mov     ebx,edi

DoneIt:
        POPR    esi,edi
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNLOGDEV2.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnlogdev.asm
;
; Purpose:      This file holds runtime routines dealing with the
;               GNLOGDEVCX.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include minivdd.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc
include escape.inc
include modeext.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GN_LogdevMessage
;
; Purpose:      This routine gets called whenver there is an
;               message to send to all objects. There are
;               a few different messages.  See gngdi.inc
;               for details.
;
;               The dwData1 and dwData2 parameters may get
;               overridden by this routine.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;               dwMessage               which message
;               dwData1                 extra data
;               dwData2                 extra data
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_LogdevMessage, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
PARMD   dwMessage
PARMD   dwData1
PARMD   dwData2
LOCALD  pGNCrtcCXOffset
LOCALD  dwCRTCCount
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset

        mov     eax,dwMessage
        cmp     eax,MSG_PREMODESET
        je      PreMS
        cmp     eax,MSG_POSTMODESET
        je      PostMS
        cmp     eax,MSG_DIRECTX_ENUM
        je      DXEnum
        cmp     eax,MSG_DIRECTXON
        je      DXOn
        cmp     eax,MSG_DIRECTXOFF
        je      DXOff
        cmp     eax,MSG_DOSON
        je      DosOn
        cmp     eax,MSG_DOSOFF
        je      DosOff
        cmp     eax,MSG_POWERON
        je      PowerOn
        cmp     eax,MSG_POWEROFF
        je      PowerOff
        cmp     eax,MSG_DISABLE
        je      DrvDis
        cmp     eax,MSG_LOGDEVMOVED
        je      LogdevMove
        jmp     ChainIt

PreMS:
        ; Flag that we are busy
        or      ds:[esi].GNLOGDEVCX.Dibeng.deFlags,BUSY
        mov     ds:[esi].GNLOGDEVCX.dwHardwareBusy,1

        ; Clear the SaveScrenBitmapCache
        push    pGNLogdevCXOffset
        call    GN_ClearSaveScreenBitmapCache
        jmp     ChainIt

PostMS:
        cmp     ds:[esi].GNLOGDEVCX.dwInitting,0
        je      @F

        ; Only if we are initting AND only if this is the first
        ; logical device on this board (i.e. we are booting windows.)
        cmp     ds:[esi].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard,0
        jne     @F
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX
        call    GN_DoOddballStuffAtBoot
@@:
        ; Flag that we are no longer busy
        and     ds:[esi].GNLOGDEVCX.Dibeng.deFlags,NOT BUSY
        mov     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0

        ; If this is a secondary driver, tell the ResMan we are in
        ; spanning mode.
        cmp     ds:[esi].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard,0
        je      SkipCallToRM

        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        pushd   1
        call    HW_TellResManSpanningState

SkipCallToRM:

        ; We are no longer initting after the first modeset
        mov     ds:[esi].GNLOGDEVCX.dwInitting,0
        jmp     ChainIt

DXEnum:
DXOn:
DXOff:
        jmp     ChainIt

DosOff:
PowerOn:
        ; Enable SW access to device
        and     ds:[esi].GNLOGDEVCX.Dibeng.deFlags,NOT BUSY

        ; Indicate a screen switch in has occurred.
        mov     ds:[esi].GNLOGDEVCX.dwInt2FScreenSwitchOut,0
        jmp     ChainIt

DosOn:
PowerOff:
        ; Disable SW access to device
        or      ds:[esi].GNLOGDEVCX.Dibeng.deFlags,BUSY

        ; Wait until all hardware contexts are idle
        push    esi
        mov     esi,ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_BeginAccess_Far32
        pop     esi

        ; Indicate a screen switch out has occurred.
        mov     ds:[esi].GNLOGDEVCX.dwInt2FScreenSwitchOut,1
        jmp     ChainIt

DrvDis:
        ; Disable HW & SW access to device
        or      ds:[esi].GNLOGDEVCX.Dibeng.deFlags,BUSY
        mov     ds:[esi].GNLOGDEVCX.dwHardwareBusy,1
        jmp     ChainIt

LogdevMove:
        ; Reset the ptr to the BitmapInfo structure
        ; alloc pointer to new location.
        mov     eax,[esi].GNLOGDEVCX.Dibeng.deBitmapInfo
        shr     eax,10h
        lea     ebx,[esi].GNLOGDEVCX.bmi
        push    ax
        push    ebx
        call    SetSelectorBase

        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    dwData2
        push    dwData1
        call    GN_ReattachLogicalDeviceToBoard
        jmp     ChainIt

ChainIt:
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    dwMessage
        push    dwData1
        push    dwData2
        call    GN_BoardMessage

        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    dwMessage
        push    dwData1
        push    dwData2
        call    HW_LogdevMessage

        ; Create the GNCRTCCXs
        lea     edi,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     dwCRTCCount,0
@@:
        ; Make sure this CRTC ptr is not NULL
        cmp     dword ptr ds:[edi],0
        je      SkipIt3

        push    dword ptr ds:[edi]
        push    dwMessage
        push    dwData1
        push    dwData2
        call    GN_CrtcMessage

SkipIt3:
        ; Next CRTCCX
        add     edi,4
        inc     dwCRTCCount
        mov     eax,dwCRTCCount
        cmp     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      @B

DoneIt:
        POPR    esi,edi
CLOSEPROC



;==============================================================================
;
; Function:     GN_OffscreenHeapDisappearing
;
; Purpose:      This routine gets called whenever the offscreen
;               heap is disappearing.
;
;               Right now, we simply flush our save screen bitmap cache.
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_OffscreenHeapDisappearing, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
OPENPROC
        push    pGNLogdevCXOffset
        call    GN_ClearSaveScreenBitmapCache
CLOSEPROC


;==============================================================================
;
; Function:     GN_ResolveDeviceConnectionsOnLoad
;
; Purpose:      This routine gets called just before we attach the
;               first CRTC in a display driver. It gives us a chance
;               to modify what we think the display devices should be.
;
;               UseHwSelectedDevice registry key is interpreted as:
;               0 - use NVidia behavior for establishing device types
;                   when a driver loads (whatever means NVidia wants)
;               1 - Ask the RM for the device types
;               2 - Use a specific behavior described later
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_ResolveDeviceConnectionsOnLoad, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
LOCALD  LocalDevData
LOCALD  LocalDevData2
LOCALD  BootDevData
LOCALW  wMobile
LOCALV  tvd,NVTWINVIEWDATA
LOCALD  lpTVD
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset
        mov     ax,ss
        shl     eax,10H
        lea     ax,tvd
        mov     lpTVD,eax

        ; This routine returns TRUE if we want mobile device behavior
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetBootDeviceSelection,es,ax
        mov     wMobile,ax

        cmp     dwThisLogicalDeviceHandle_In_NVTEXT16,1
        jne     SecondaryDriver

PrimaryDriver:
        ; See if we want mobile device bahavior
        cmp     wMobile,0
        je      DoneIt

        ; Ask the HW for the boot device
        ; (the HW probably asks the BIOS or RM).
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        pushd   0                       ; get the primary device instance
        call    HW_GetBootDevice
        mov     dword ptr LocalDevData,eax

        ; We only get called for the primary once when it first
        ; loads. Hence, at this point, we may even want to override
        ; what the HW told us is the boot device with a forced boot
        ; device from the registry.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10h
        lea     ax,BootDevData
        push    eax
        CALLFAR16IND lpfnGetBootDevice,es,ax
        or      ax,ax
        je      @F
        mov     eax,BootDevData
        mov     LocalDevData,eax
@@:
        ; If for some reason, the HW didn't return any display
        ; devices, we'll just leave things as is.newu
        cmp     LocalDevData,-1
        je      DoneIt

        ; OK, we know the primary boot display. Write it out
        sub     ecx,ecx
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    ecx                             ; Logical device 0
        push    ecx                             ; Physical Device 0
        mov     bx,ss
        shl     ebx,10H
        lea     bx,LocalDevData
        push    ebx
        CALLFAR16IND lpfnSetDisplayDevice,es,ax
        
        ; If this device is a TV, set the TV Format in the ResMan.
        cmp     byte ptr LocalDevData,DEVTYPE_TV
        jne     SkipTVFormat
        mov     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    ds:[eax].GNCRTCCX.pHWCrtcCX
        push    LocalDevData
        call    HW_SetResManTvFormat
        
SkipTVFormat:
        ; Now, ask the HW if we booted with more than one display
        ; active and, if so, what was the second display device type.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        pushd   1                       ; get the next instance
        call    HW_GetBootDevice
        mov     dword ptr LocalDevData2,eax
        cmp     eax,-1
        je      PrimaryIsStandard

PrimaryIsCloned:
        ; Write the desktop state to clone
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        pushd   NVTWINVIEW_STATE_CLONE
        CALLFAR16IND lpfnSetDesktopState,es,ax

        ; Write out the clone display device type
        sub     ecx,ecx
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    ecx                             ; Logical device 0
        inc     ecx
        push    ecx                             ; Physical Device 1
        mov     bx,ss
        shl     ebx,10H
        lea     bx,LocalDevData2
        push    ebx
        CALLFAR16IND lpfnSetDisplayDevice,es,ax
        jmp     DoneIt

        ; If this device is a TV, set the TV Format in the ResMan.
        cmp     byte ptr LocalDevData,DEVTYPE_TV
        jne     PrimaryIsStandard
        mov     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    ds:[eax].GNCRTCCX.pHWCrtcCX
        push    LocalDevData2
        call    HW_SetResManTvFormat
        
PrimaryIsStandard:
        ; Write the desktop state to clone
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        pushd   NVTWINVIEW_STATE_NORMAL
        CALLFAR16IND lpfnSetDesktopState,es,ax
        jmp     DoneIt


SecondaryDriver:
        ; Write out desktop state to standard. If we have a secondary
        ; display driver loaded, we definitely aren't in clone.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        pushd   NVTWINVIEW_STATE_NORMAL
        CALLFAR16IND lpfnSetDesktopState,es,ax

        ; This routine returns TRUE if we want mobile device behavior
        cmp     wMobile,1
        jc      DoneIt
        cmp     wMobile,2
        je      SpecialBehavior2

SecondDriverAskRm:
        ; Now, ask the HW if we booted with more than one display
        ; active and, if so, what was the second display device type.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        pushd   1                               ; get the next instance
        call    HW_GetBootDevice
        mov     dword ptr LocalDevData2,eax

        ; If we only booted on a single display device, then
        ; we just leave the registry as is and we will end up
        ; using whatever the registry said was the last display
        ; device used by the secondary driver.
        cmp     eax,-1
        je      DoneIt

        ; If we booted on two display devices, then use the second
        ; one as the secondary device.
        sub     ecx,ecx
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    ecx                             ; Logical device 1
        push    ecx                             ; Physical Device 0
        mov     bx,ss
        shl     ebx,10H
        lea     bx,LocalDevData2
        push    ebx
        CALLFAR16IND lpfnSetDisplayDevice,es,ax
        
        ; If this device is a TV, set the TV Format in the ResMan.
        cmp     byte ptr LocalDevData,DEVTYPE_TV
        jne     DoneIt
        mov     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    ds:[eax].GNCRTCCX.pHWCrtcCX
        push    LocalDevData2
        call    HW_SetResManTvFormat
        
        jmp     DoneIt
        
SpecialBehavior2:

        ; NOTE:
        ;       (N) means Normal (standard mode)
        ;       (C) means clone,                (M) Multi-mon
        ;       In clone mode
        ;       (1) means primary device        (2) means clone device
        ;       In multi-mon
        ;       (P) means primary device        (S) means secondary device
        ;
        ; At this point we are definitely going to multi-mon
        ; (if there are at least two display devices connected).
        ; It is just a question of which display devices we will
        ; be using for the primary and the secondary.
        ;
        ; If currently in this config,  then go to this config
        ; (N) LCD                       (M) LCD (P), CRT (S)
        ; (C) LCD (1), CRT (2)          (M) LCD (P), CRT (S)
        ; (N) CRT                       (M) LCD (P), CRT (S)
        ; (C) LCD (1), TV (2)           (M) LCD (P), TV  (S)
        ; (N) TV                        (M) LCD (P), TV  (S)

        ; Is the primary driver currently in clone mode?
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     edi,dword ptr ds:[ebx].GNBOARDCX.pGNLogdevCX

CheckCurrentPrimary:
        ; Is the current primary the DFP?
        push    dword ptr ds:[edi].GNLOGDEVCX.pGNCrtcCX
        call    GN_GetDevData
        mov     LocalDevData,eax

        ; Remember this ... and assume normal mode
        mov     ebx,ds:[edi].GNLOGDEVCX.pGNBoardCX
        mov     ds:[ebx].GNBOARDCX.dwOldPrimaryDevData,eax
        mov     ds:[ebx].GNBOARDCX.dwOldTwinviewState,NVTWINVIEW_STATE_NORMAL
        mov     ds:[ebx].GNBOARDCX.dwCheckCursorTicksSinceSecondDriverLoaded,0

        cmp     al,DEVTYPE_DFP
        jne     @F

        ; OK, the primary is the DFP. If there is a clone device,
        ; it will determine the device type to set on the second driver.
        ; If there isn't a clone device, the second driver gets a CRT.
        mov     LocalDevData,DEVTYPE_CRT
        mov     eax,dword ptr ds:[edi].GNLOGDEVCX.pGNCrtcCX+4
        or      eax,eax
        je      @F
        push    eax
        call    GN_GetDevData
        mov     LocalDevData,eax

        ; Remember the clone device type and that we were in clone mode
        mov     ebx,ds:[edi].GNLOGDEVCX.pGNBoardCX
        mov     ds:[ebx].GNBOARDCX.dwOldCloneDevData,eax
        mov     ds:[ebx].GNBOARDCX.dwOldTwinviewState,NVTWINVIEW_STATE_CLONE

@@:
        ; First, go to normal mode (if we are already, there, that's fine.)
        mov     tvd.dwFlag,NVTWINVIEW_FLAG_SET
        mov     tvd.dwAction,NVTWINVIEW_ACTION_SETGET_STATE
        mov     tvd.dwState,NVTWINVIEW_STATE_NORMAL

        push    ds:[edi].GNLOGDEVCX.Dibeng.delpPDevice
        pushw   NV_ESC_SETGET_TWINVIEW_DATA
        push    lpTVD
        push    lpTVD
        call    Control

        ; Make the DFP primary (just in case it isn't)
        mov     tvd.dwFlag,NVTWINVIEW_FLAG_SET
        mov     tvd.dwAction,NVTWINVIEW_ACTION_SETGET_DEVICE_TYPE
        mov     tvd.dwCrtc,0
        mov     ecx,DEVTYPE_DFP
        call    HW_MapGNDeviceTypeToHWDeviceType
        mov     tvd.NVTWINVIEWUNION.nvtwdevdata.dwDeviceType,ecx
        mov     tvd.NVTWINVIEWUNION.nvtwdevdata.dwTVFormat,0

        push    ds:[edi].GNLOGDEVCX.Dibeng.delpPDevice
        pushw   NV_ESC_SETGET_TWINVIEW_DATA
        push    lpTVD
        push    lpTVD
        call    Control

        ; Set the physical mode in the GNCRTCCX to the desktop mode
        ; so the physical mode set will be as close as possible to the
        ; desktop mode.
        sub     ebx,ebx
        mov     eax,ds:[edi].GNLOGDEVCX.pGNCrtcCX
        les     bx,ds:[eax].GNCRTCCX.lpCrtcModeInfo
        sub     eax,eax
        mov     ax,ds:[edi].DIBENGINEHDR.deWidth
        mov     es:[ebx].MODEINFO.dwXRes,eax
        mov     ax,ds:[edi].DIBENGINEHDR.deHeight
        mov     es:[ebx].MODEINFO.dwYRes,eax
        sub     ax,ax
        mov     al,ds:[edi].DIBENGINEHDR.deBitsPixel
        mov     es:[ebx].MODEINFO.dwBpp,eax
        
WriteOutType:
        ; If device type is TV, get the TV format from the ResMan.
        cmp     byte ptr LocalDevData,DEVTYPE_TV
        je      @F
        mov     eax,dword ptr ds:[edi].GNLOGDEVCX.pGNCrtcCX[4]
        push    ds:[eax].GNCRTCCX.pHWCrtcCX
        push    dword ptr LocalDevData
        call    HW_GetResManTvFormat
        shl     eax,10h
        and     dword ptr LocalDevData,0ff00ffffh
        or      dword ptr LocalDevData,eax
@@:
        ; Now we can set the display device type. Please note the ResMan
        ; already has the correct TV Format which we just got above.
        mov     ebx,dword ptr ds:[edi].GNLOGDEVCX.pGNCrtcCX
        mov     eax,1
        push    ds:[ebx].GNCRTCCX.lpBoardRegistryData
        push    eax
        dec     eax
        push    eax
        mov     ax,ss
        shl     eax,10h
        lea     ax,LocalDevData
        push    eax
        CALLFAR16IND lpfnSetDisplayDevice,es,ax

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_ResolveDeviceConnectionsOnUnload
;
; Purpose:      This routine gets called just before we attach the
;               first CRTC in a display driver. It gives us a chance
;               to modify what we think the display devices should be.
;
;               UseHwSelectedDevice registry key is interpreted as:
;               0 - use NVidia behavior for establishing device types
;                   when a driver loads (whatever means NVidia wants)
;               1 - Ask the RM for the device types
;               2 - Use a specific behavior described later
;
; Arguments:
;               ds                      Context Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_ResolveDeviceConnectionsOnUnload, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
LOCALV  LocalDevData,DEVDATA
LOCALW  wMobile
LOCALV  sModeInfo,MODEINFO
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset

        ; This routine returns the type of mobile behavior we want
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetBootDeviceSelection,es,ax
        mov     wMobile,ax

        ; Nothing to do if we are unloading the primary driver!
        cmp     dwThisLogicalDeviceHandle_In_NVTEXT16,1
        je      DoneIt

SecondaryDriver:
        cmp     wMobile,2
        je      SpecialBehavior2

        ; Standard mobile behavior is NVidia default behavior
        ; which is to restore the last Clone or standard state
        ; they had before enabling multi-mon.

        ; So, we probably detached a CRTCCX when the logical device
        ; was destroyed. There may be another logical device on this
        ; board that would like to have the CRTCCX. Let's find out.
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        call    GN_FindLogdevWaitingToClone
        or      eax,eax
        je      DoneIt

        ; There was a logical device that wanted a clone! Try to
        ; add a clone to it.
        push    eax
        call    GN_LogdevAddAClone
        or      eax,eax
        je      DoneIt

        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     ecx,dword ptr ds:[eax].GNBOARDCX.pGNLogdevCX[0]
        push    ds:[ecx].GNLOGDEVCX.pHWLogdevCX
        push    ds:[ecx].GNLOGDEVCX.pHWLogdevCX
        call    HW_DriverTwinviewStateChanging

        ; We aren't going to receive a ReEnable call to reset all the
        ; CRTC modes. We must force a refresh here.
        push    esi
        call    GN_CrtcRemapArray
        push    esi
        call    GN_RestoreAllCrtcStates
        jmp     DoneIt

SpecialBehavior2:
        ; Special behavior #2 says that from any multi-mon config,
        ; we should always go back to Clone with LCD on the primary
        ; and CRT as the clone device.

        ; HOWEVER!!!! If we are unloaded very soon (within a second
        ; or two of when we are loaded), then this is probably just
        ; a "FAKE" unload. i.e. When enabling multi-mon, Windows
        ; loads and unloads the display driver a couple times. If
        ; we go back to LCD/CRT clone mode now, and then we instantly
        ; get reloaded, then we will go into LCD/CRT multimon. If
        ; this whole sequence started with LCD/TV clone, then we
        ; end up in the wrong state. Hence, on "FAKE" unloads, we
        ; restore the display device state that existed when we were
        ; loaded.
        mov  edi,ds:[esi].GNLOGDEVCX.pGNBoardCX
        cmp  ds:[edi].GNBOARDCX.dwCheckCursorTicksSinceSecondDriverLoaded,20H
        ja   DriverUnloadIsReal

DriverUnloadIsFake:
        ; Reset the old state.

        ; Reset the primary device type to be what it was
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    ds:[edi].GNBOARDCX.dwOldPrimaryDevData
        call    GN_SetDevData

        ; Were we in clone mode?????
        cmp     ds:[edi].GNBOARDCX.dwOldTwinviewState,NVTWINVIEW_STATE_NORMAL
        je      FinishUp

        ; Add a clone device.
        push    esi
        call    GN_LogdevAddAClone
        or      eax,eax
        je      FinishUp

        ; Make sure the clone device type is whatever it was previously
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX+4
        push    ds:[edi].GNBOARDCX.dwOldCloneDevData
        call    GN_SetDevData

DriverUnloadIsReal:
        ; First, make the primary device the DFP
        mov     LocalDevData.cType,DEVTYPE_DFP
        mov     LocalDevData.cNumber,0
        mov     LocalDevData.cFormat,0

        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    dword ptr LocalDevData
        call    GN_SetDevData

        ; Add a clone device.
        push    esi
        call    GN_LogdevAddAClone
        or      eax,eax
        je      FinishUp

        ; Make sure the clone is the CRT
        mov     LocalDevData.cType,DEVTYPE_CRT
        mov     LocalDevData.cNumber,0
        mov     LocalDevData.cFormat,0
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX+4
        push    dword ptr LocalDevData
        call    GN_SetDevData

        ; Now that we have the correct display device for the clone, we
        ; need to make sure we write the desktop mode to the MODEINFO
        ; structure so we will set the clone as close as possible to
        ; the desktop mode.
        
        ; Build up the desktop MODEINFO
        mov     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX+4
        sub     ebx,ebx
        lfs     bx,ds:[eax].GNCRTCCX.lpCrtcModeInfo
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
        mov     fs:[ebx].MODEINFO.dwXRes,eax
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
        mov     fs:[ebx].MODEINFO.dwYRes,eax
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deBitsPixel
        mov     fs:[ebx].MODEINFO.dwBpp,eax
        
        ; Get the refresh rate from the registry for the CRT as the clone.
        mov     ah,LocalDevData.cFormat
        mov     al,LocalDevData.cNumber
        shl     eax,8
        mov     al,LocalDevData.cType
        mov     sModeInfo.MIDevData,eax
        
        mov     eax,ds:[esi].GNLOGDEVCX.pGNCrtcCX+4
        push    ds:[eax].GNCRTCCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        push    eax
        CALLFAR16IND lpfnGetDeviceDisplayMode,es,ax
        sub     ebx,ebx
        lea     bx,sModeInfo
        mov     ebx,ss:[ebx].MODEINFO.dwRefreshRate
        or      ax,ax
        jne     UseRefreshRate

        ; No mode in the registry, use 60Hz as default.
        mov     ebx,60  

UseRefreshRate:
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX+4
        sub     eax,eax
        lfs     ax,ds:[ecx].GNCRTCCX.lpCrtcModeInfo
        mov     fs:[eax].MODEINFO.dwRefreshRate,ebx
        
FinishUp:
        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     ecx,dword ptr ds:[eax].GNBOARDCX.pGNLogdevCX[0]
        push    ds:[ecx].GNLOGDEVCX.pHWLogdevCX
        push    ds:[ecx].GNLOGDEVCX.pHWLogdevCX
        call    HW_DriverTwinviewStateChanging

        ; We aren't going to receive a ReEnable call to reset all the
        ; CRTC modes. We must force a refresh here.
        push    esi
        call    GN_CrtcRemapArray
        push    esi
        call    GN_RestoreAllCrtcStates

DoneIt:
        POPR    esi,edi
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNMEM.ASM ===
;===================================================================
;
; Copyright (C) 1998, NVidia Coporation
;
; File:         gnmem.asm
;
; Purpose:      This file holds routines for the linear memory heap
;               manager. You can create and destroy heaps, allocate
;               memory from the heap and free memory back to heap.
;
; The basic strategy is to maintain three doubly linked lists for every
; heap. The elements in every list are always MEMINFO structures. There
; are a fixed number of total elements which places a limit on how many
; allocations that can be oustanding at any one time. This fixed number
; can be run-time decided, however, and shouldn't affect performance as
; long as it is made large enough to accomodate sufficient simultaneous
; allocations. The three lists are:
;
; The ALLOC list contains elements describing linear chunks of the heap
; which are currently allocated.
;
; The FREE list contains elements describing linear chunks of the heap
; which are NOT currently allocated.
;
; The MANAGEMENT list (or MAN list) contains elements which can be used
; as either an element in the ALLOC list or the FREE list.
;
; Whenever a new chunk of memory is allocated, a MEMINFO element is
; pulled out of the MAN list and placed into the ALLOC list after being
; filled in appropriately to describe the new allocation. Also, a MEMINFO
; element in the FREE list is modified to reflect that it no longer
; describes as large a chunk of memory as it used to. Alternatively, if
; the newly alloced chunk was less than but close to the size of the
; chunk in the FREE list, then the MEMINFO element from the FREE list
; is just placed in the ALLOC list and removed from the FREE list.
;
; When memory is freed a similar process takes place. The MEMINFO element
; in the ALLOC list that is being freed is checked to see if it can be
; merged into a larger contiguous block with other elements in the FREE
; list. If it can, then a block already in the FREE list is modified to
; reflect the larger free chunk and the MEMINFO element from the ALLOC
; list is removed and placed into the MAN list. If the belock being
; freed cannot be merged, then the MEMINFO element is removed from the
; ALLOC list and placed into the FREE list.
;
; There is one block in each list that is the head block. That is an
; anchor from which I can start walking the list.
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

PREPEND_BLOCK_TO_LIST   MACRO   listhead,block
        LOCAL   Eol

        mov     edi,listhead
        mov     eax,ds:[edi].MEMINFO.dwNext
        mov     ds:[edi].MEMINFO.dwNext,block
        mov     ds:[block].MEMINFO.dwPrev,listhead
        mov     ds:[block].MEMINFO.dwNext,eax
        cmp     eax,SENTINEL
        je      Eol
        mov     edi,eax
        mov     ds:[edi].MEMINFO.dwPrev,block
Eol:
ENDM

INSERT_BLOCK1_AFTER_BLOCK2      MACRO  blocka,blockb
        LOCAL   Eol

        mov     edi,ds:[blockb].MEMINFO.dwNext
        mov     ds:[blockb].MEMINFO.dwNext,blocka
        mov     ds:[blocka].MEMINFO.dwPrev,blockb
        mov     ds:[blocka].MEMINFO.dwNext,edi
        cmp     edi,SENTINEL
        je      Eol
        mov     ds:[edi].MEMINFO.dwPrev,blocka
Eol:
ENDM

EXTRACT_BLOCK_FROM_LIST MACRO   block
        LOCAL   Eol

        mov     edi,ds:[block].MEMINFO.dwPrev
        mov     eax,ds:[block].MEMINFO.dwNext
        mov     ds:[edi].MEMINFO.dwNext,eax
        cmp     eax,SENTINEL
        je      Eol
        mov     ds:[eax].MEMINFO.dwPrev,edi
Eol:
ENDM

; Every allocation will be rounded up to next MINALLOCUNIT multiple
MINALLOCUNIT    EQU     64

; This marks the beginning and ending of lists
SENTINEL        TEXTEQU <-1>

; This is the list element for all three lists. It holds doubly linked
; pointers and the base and length of an allocation.
MEMINFO STRUC
        dwBase          DD      0
        dwLength        DD      0
        dwPrev          DD      0
        dwNext          DD      0
MEMINFO ENDS

; I want to keep stats on the allocations and it makes the most sense
; to store these in a few fields of the MEMINFO structures that are
; unused since I have to allocate memory for these anyway. Here are
; the stats I will be keeping and where they are being placed.

; MANHEAD.dwBase        Number of MEMINFO elements in MAN list
; MANHEAD.dwLength      Number of MEMINFO elements (Total)
; ALLOCHEAD.dwBase      Number of Allocations currently outstanding
; ALLOCHEAD.dwLength    Number of Bytes in all Outstanding Allocations
; FREEHEAD.dwLength     Number of Free Bytes left in the Heap

NUMMEMINFOS     TEXTEQU <(MEMINFO PTR ds:[MANHEAD]).dwLength>
NUMMANS         TEXTEQU <word ptr (MEMINFO PTR ds:[MANHEAD]).dwBase>
NUMALLOCS       TEXTEQU <(MEMINFO PTR ds:[ALLOCHEAD]).dwBase>
ALLOCEDBYTES    TEXTEQU <(MEMINFO PTR ds:[ALLOCHEAD]).dwLength>
TOTALBYTES      TEXTEQU <(MEMINFO PTR ds:[FREEHEAD]).dwBase>
FREEBYTES       TEXTEQU <(MEMINFO PTR ds:[FREEHEAD]).dwLength>

; The first five blocks of a heap are fixed function. These equates
; make sure I am consistent about the usage of the blocks.
MANHEAD         EQU     ((SIZE MEMINFO) * 0)
FREEHEAD        EQU     ((SIZE MEMINFO) * 1)
ALLOCHEAD       EQU     ((SIZE MEMINFO) * 2)
FIRSTFREEBLOCK  EQU     ((SIZE MEMINFO) * 3)
FIRSTMANBLOCK   EQU     ((SIZE MEMINFO) * 4)



OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GN_HeapCreate
;
; Purpose:      This routine creates a linear memory heap. The base
;               minimum number of simultaneous
;               allocations (MSA) are determined by the caller. For
;               example, the caller might request that the MSA be 100H.
;               Then any attempt to allocate from the
;               heap when there are alredy 100H other allocations
;               might fail even if there is enough memory. I say might
;               because it depends upon how fragmented the heap is.
;               The less fragmented the more requests can be handled
;               at the same time. However, you never get less than
;               the number requested herein and you will never get
;               more than about 2 x the number you request.
;
;               NOTE: This routine does not actually allocate allocate
;               memory for a heap. It just sets up data structures to
;               manage a linear heap. The caller must allocate memory
;               if it wants something to actually match these number to.
;
; Arguments:
;               eax     The minimum number of simultaneous allocations
;                       allowed before allocs fail
;
; Returns:      eax     Heap token if successful
;                       NULL if unsuccessful
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_HeapCreate, PASCAL, FRAME, FAR32
LOCALD  dwTotalMemInfos
OPENPROC
        PUSHR   ds,esi,edi

        ; There is an alloc list, a free list and a manage list.
        ; All three lists must have a header block. Plus, the worst
        ; fragmented heap will have alternating FREE and ALLOC
        ; blocks with a FREE block at the beginning and the end.
        ; Also I have a few blocks that I keep statistics in.
        ; Hence, to guarantee ecx allocations, we need at
        ; least 2 * eax + 6 MEMINFO structs.
        lea     eax,[eax * 2 + 6]
        mov     dwTotalMemInfos,eax

        ; Now allocate enough bytes for eax MEMINFO structs
        mov     ecx,SIZE MEMINFO
        imul    eax,ecx
        call    GN_MemoryAlloc
        or	eax,eax
        je	DoneIt

        mov	ds,ax
        mov	ecx,dwTotalMemInfos
	mov	NUMMEMINFOS,ecx
DoneIt:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_HeapInit
;
; Purpose:      This routine inits a linear memory heap.
;
; Arguments:
;		eax	Heap Token returned from GN_HeapCreate
;		ebx     The desired base address
;               ecx     The number of bytes in the heap
;
; Returns:      Nothing
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_HeapInit, PASCAL, FRAME, FAR32
OPENPROC
        PUSHR   ds,esi,edi
        mov     ds,ax

        ; Save the base address and heap size. Round heap size down to
        ; the closest multiple of the MINALLOCUNIT.
        mov     esi,ebx
        mov     edi,ecx
        and     edi,NOT (MINALLOCUNIT - 1)
        mov     eax,SENTINEL

        ; First setup the FREE list
        mov     ebx,FREEHEAD
        mov     ds:[ebx].MEMINFO.dwPrev,eax
        mov     ds:[ebx].MEMINFO.dwNext,FIRSTFREEBLOCK
        mov     FREEBYTES,edi
        mov	TOTALBYTES,edi
        mov     ebx,FIRSTFREEBLOCK
        mov     ds:[ebx].MEMINFO.dwPrev,FREEHEAD
        mov     ds:[ebx].MEMINFO.dwNext,eax
        mov     ds:[ebx].MEMINFO.dwBase,esi
        mov     ds:[ebx].MEMINFO.dwLength,edi

        ; Next, setup the ALLOC list
        mov     ebx,ALLOCHEAD
        mov     ds:[ebx].MEMINFO.dwPrev,eax
        mov     ds:[ebx].MEMINFO.dwNext,eax
        sub     ecx,ecx
        mov     NUMALLOCS,ecx
        mov     ALLOCEDBYTES,ecx

        ; Lastly, setup the MAN list
        mov     ebx,MANHEAD
        mov     ds:[ebx].MEMINFO.dwPrev,eax
        mov     ds:[ebx].MEMINFO.dwNext,FIRSTMANBLOCK
        mov     ecx,NUMMEMINFOS
        mov     NUMMANS,cx

        ; All the remaining blocks belong in the MAN list -- doubly linked
        mov     ebx,FIRSTMANBLOCK
        mov     ds:[ebx].MEMINFO.dwPrev,MANHEAD
        mov     ds:[ebx].MEMINFO.dwNext,eax
        sub     ecx,5
        jle     Done
@@:     lea     esi,[ebx + SIZE MEMINFO]
        mov     ds:[ebx].MEMINFO.dwNext,esi
        mov     edx,ebx
        add     ebx,SIZE MEMINFO
        mov     ds:[ebx].MEMINFO.dwPrev,edx
        mov     ds:[ebx].MEMINFO.dwNext,eax
        dec     ecx
        jg      @B

Done:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_HeapDestroy
;
; Purpose:      This routine destroys a linear memory heap.
;
; Arguments:    eax     Heap Token returned by GN_HeapCreate
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_HeapDestroy, PASCAL, NOFRAME, FAR32
OPENPROC
        call    GN_MemoryFree
CLOSEPROC


;==============================================================================
;
; Function:     GN_HeapAlloc
;
; Purpose:      This routine allocates memory from a heap.
;
; Arguments:    eax     Heap Token returned by GN_HeapCreate
;               ecx     bytes needed from heap.
;                       NOTE: This number will be rounded up to
;                       the next multiple of MINALLOCUNIT.
;
; Returns:      eax     Offset of the allocation if successful
;                               In this case ecx = actual size allocated
;                       -1 if it could not allocate
;
; Preserve:     ds,esi,edi,es
;==============================================================================
DECPROC GN_HeapAlloc, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,esi,edi

        ; Get the heap token (which is the selector of a memory block
        ; that has the heap info in it) into ds.
        mov     ds,ax

        ; Round the requested allocation amount up to next multiple
        ; of MINALLOCUNIT.
        add     ecx,MINALLOCUNIT - 1
        sub     eax,eax
        and     ecx,NOT (MINALLOCUNIT - 1)

        ; See if we have at least this many bytes free in the heap.
        ; If not, don't bother walking the FREE list.
        cmp     ecx,FREEBYTES
        ja      Done

        ; Is there a MEMINFO block that can hold this allocation or
        ; will we exceed the simultaneous allocation limit?
        mov     edi,MANHEAD
        cmp     ds:[edi].MEMINFO.dwNext,SENTINEL
        je      Done

        ; Walk the FREE list looking for a free block at least as big
        ; as the rounded up request size. If we reach the end of the
        ; free list without finding one, that is an error.
        mov     esi,FREEHEAD
@@:     mov     esi,ds:[esi].MEMINFO.dwNext
        cmp     esi,SENTINEL
        je      Done
        cmp     ecx,ds:[esi].MEMINFO.dwLength
        ja      @B

        ; We found a block in the FREE list that is big enough. If the
        ; block is exactly the requested size, then just remove the free
        ; block from the free list and put it in the alloced list.
        je      MoveFreeBlockToAllocList

        ; The free block is bigger than we need. Use the first portion of
        ; the free block as our allocated area and adjust the free block
        ; to describe only the free memory after the newly allocated area.

        ; Remember the base of the free block. It will become the
        ; base of our allocation.
        mov     eax,ds:[esi].MEMINFO.dwBase

        ; Update the block in the FREE list to show it is a smaller region
        add     ds:[esi].MEMINFO.dwBase,ecx     ; The base is further
        sub     ds:[esi].MEMINFO.dwLength,ecx   ; The length is less

        ; Get a new MEMINFO struct to use to describe the allocation.
        ; One exists or we would never have gotten this far.
        mov     esi,ds:[edi].MEMINFO.dwNext     ; edi = MANHEAD remember
        dec     NUMMANS                         ; We used a MAN list block

        ; Set the base and length of this new alloced block
        mov     ds:[esi].MEMINFO.dwBase,eax     ; Base of allocation
        mov     ds:[esi].MEMINFO.dwLength,ecx   ; And the is the length

MoveFreeBlockToAllocList:
        ; Pull the MEMINFO block pointed to by esi out of the list
        ; it is in. This may be the FREE list or the MAN list, but
        ; it doesn't matter. The same code is used for both.
        EXTRACT_BLOCK_FROM_LIST esi

        ; The MEMINFO block pointed to by esi describes an allocation
        ; so place it at the head of the ALLOC list.
        PREPEND_BLOCK_TO_LIST  ALLOCHEAD,esi

        ; Now return the base address of the length of the allocation
        mov     eax,ds:[esi].MEMINFO.dwBase
        mov     ecx,ds:[esi].MEMINFO.dwLength

        ; Keep track of these -- simple and takes little time.
        inc     NUMALLOCS
        add     ALLOCEDBYTES,ecx
        sub     FREEBYTES,ecx

Done:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_HeapFree
;
; Purpose:      This routine frees memory from a heap.
;
; Arguments:    eax     Heap Token returned by GN_HeapCreate
;               ecx     Allocation offset returned by GN_HeapAlloc
;
; Returns:      eax     non-0   Valid allocation was found and freed
;                               In this case ecx = number of bytes in
;                               the allocation.
;                       0       Could not find this allocation
;                               Nothing bad happens here, but as long
;                               as you match the allocs and frees this
;                               case shouldn't really ever happen.
;
; Preserve:     ds,esi,edi,es
;==============================================================================
DECPROC GN_HeapFree, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,esi,edi

        ; Get the heap token (which is the selector of a memory block
        ; that has the heap info in it) into ds.
        mov     ds,ax
        sub     eax,eax

        ; Search the ALLOC list for the allocation offset
        mov     esi,ALLOCHEAD
@@:     mov     esi,ds:[esi].MEMINFO.dwNext
        cmp     esi,SENTINEL
        je      Fail
        cmp     ecx,ds:[esi].MEMINFO.dwBase
        jne     @B

        ; Found It! Remove the allocation from the ALLOC list
        EXTRACT_BLOCK_FROM_LIST esi

        ; save the amount we are freeing
        push    ds:[esi].MEMINFO.dwLength

        ; The FREE list is kept sorted so that we can merge newly
        ; freed blocks back in with existing free blocks to make
        ; the largest free blocks available. Keeping the list
        ; sorted makes this much easier.
        mov     ebx,FREEHEAD
        cmp     ds:[ebx].MEMINFO.dwNext,SENTINEL
        je      InsertEsiBlockAfterEbxBlock
@@:     mov     ebx,ds:[ebx].MEMINFO.dwNext
        cmp     ecx,ds:[ebx].MEMINFO.dwBase
        jc      TryMergeWithNextAndPrev
        cmp     ds:[ebx].MEMINFO.dwNext,SENTINEL
        jne     @B

TryMergeAtEnd:
        ; If we get here, then the esi block we are freeing might merge
        ; on the end of the last block currently in the FREE list, or it
        ; might be the new last block on the FREE list.
        mov     eax,ds:[ebx].MEMINFO.dwBase
        add     eax,ds:[ebx].MEMINFO.dwLength
        cmp     eax,ecx
        jne     InsertEsiBlockAfterEbxBlock

        ; The newly freed block pointed to by esi does merge with the
        ; current last free block pointed to by ebx.
        mov     eax,ds:[esi].MEMINFO.dwLength
        add     ds:[ebx].MEMINFO.dwLength,eax

        ; We no longer need the MEMINFO struct pointed to by esi which
        ; described the block just freed so give it back to the MAN list.
        ; Also, update the number of blocks in the MAN list.
        PREPEND_BLOCK_TO_LIST  MANHEAD,esi
        inc     NUMMANS
        jmp     Success

InsertEsiBlockAfterEdiBlock:
        mov     ebx,edi

InsertEsiBlockAfterEbxBlock:
        ; [esi] block belongs after [ebx] block
        INSERT_BLOCK1_AFTER_BLOCK2 esi,ebx
        jmp     Success

TryMergeWithNextAndPrev:
        ; We now know that the block pointed to by esi goes in the FREE
        ; list in between the block pointed to by ebx and the block
        ; before ebx in the FREE list. Let's see if the esi block merges
        ; with the ebx block, first.
        mov     edx,ds:[esi].MEMINFO.dwBase
        mov     eax,ds:[ebx].MEMINFO.dwBase
        add     edx,ds:[esi].MEMINFO.dwLength
        cmp     eax,edx
        jne     TryMergeWithPrev

        ; It does! Back up the base of the ebx block to include the
        ; esi block and increase the ebx block length.
        mov     edx,ds:[esi].MEMINFO.dwLength
        sub     ds:[ebx].MEMINFO.dwBase,edx
        add     ds:[ebx].MEMINFO.dwLength,edx

        ; Now we can get rid of the esi block since we don't need it.
        ; Indicate that we have given back a block to the MAN list.
        PREPEND_BLOCK_TO_LIST  MANHEAD,esi
        inc     NUMMANS

        ; Now see if we can merge this new free block with the previous
        ; block in the FREE list. Careful because we may already be at
        ; the start of the free list.
        mov     edi,ds:[ebx].MEMINFO.dwPrev
        cmp     edi,FREEHEAD
        je      Success
        mov     eax,ds:[edi].MEMINFO.dwBase
        add     eax,ds:[edi].MEMINFO.dwLength
        cmp     eax,ds:[ebx].MEMINFO.dwBase
        jne     Success

        ; It does merge! So combine these two blocks.
        mov     ecx,ds:[ebx].MEMINFO.dwLength
        add     ds:[edi].MEMINFO.dwLength,ecx
        jmp     RemoveEbxFromFreeListAndInsertItInManList

TryMergeWithPrev:
        ; The esi block did not merge with the block after it in the
        ; FREE list, so now let's see if it merges with the one before
        ; it in the FREE list. The one before it may be the FREEHEAD,
        ; so we need to check for that as well. DOn't forget that ecx
        ; holds the base addr of the allocation we are freeing.
        mov     edi,ds:[ebx].MEMINFO.dwPrev
        cmp     edi,FREEHEAD
        je      InsertEsiBlockAfterEdiBlock
        mov     eax,ds:[edi].MEMINFO.dwBase
        add     eax,ds:[edi].MEMINFO.dwLength
        cmp     eax,ecx
        jne     InsertEsiBlockAfterEdiBlock

        ; Yep! The esi block merges with the edi block -- so do it.
        mov     edx,ds:[esi].MEMINFO.dwLength
        add     ds:[edi].MEMINFO.dwLength,edx

        ; Now we can stick the esi block back into the MAN list
        ; and update the count of available MEMINFO blocks.
        PREPEND_BLOCK_TO_LIST  MANHEAD,esi
        inc     NUMMANS
        jmp     Success

RemoveEbxFromFreeListAndInsertItInManList:
        ; We no longer need the ebx block -- it was merged with another
        ; block. Remove it from the list it is currently in...
        EXTRACT_BLOCK_FROM_LIST ebx

        ; ... and stick the ebx block back in the MAN list.
        ; Update the count of available MEMINFO blocks.
        PREPEND_BLOCK_TO_LIST  MANHEAD,ebx
        inc     NUMMANS
        jmp     Success

Fail:   sub     eax,eax
        jmp     Done

Success:
        ; This is the number of bytes freed. We need to return this.
        pop     ecx

        ; Keep track of these -- simple and takes little time.
        dec     NUMALLOCS
        sub     ALLOCEDBYTES,ecx
        add     FREEBYTES,ecx
        mov     eax,1

Done:
        POPR    ds,esi,edi
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNGAMMA.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gngamma.asm
;
; Purpose:      This file holds the GammaRamp display driver entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_GammaRamp
;
; Purpose:      This function is the GammaRamp display driver entry point.
;
; Arguments:    GammaRamp Display Driver Stack Frame
;
; Returns:      Always return 1.
;
;==============================================================================
DECPROC GENERIC_GammaRamp, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   fGetSet
PARMD   lpGammaRamp
LOCALD  dwCRTCCount
LOCALD  pGammaRamp
OPENPROC
        PUSHR   ds,esi,edi

        ; Load up the GNLOGDEVCX
        mov     ds,cs:[wFlatDataSel]
        mov     esi,cs:[CSpGNLogicalDevice]

        ; Get a flat ptr to the gamma ramp
        movzx   eax,word ptr lpGammaRamp+2
        push    eax
        call    GN_GetSelectorBase
        movzx   edx,word ptr lpGammaRamp+0
        add     eax,edx
        mov     pGammaRamp,eax

        ; Run through all the CRTCs attached to this logical device
        ; and program them all, or get the gamma ramp from the first.
        ; The first is sufficient on a Get since if there is more
        ; than 1 CRTC attached, then we are in CLONE mode.
        mov     dwCRTCCount,0
        lea     edi,ds:[esi].GNLOGDEVCX.pGNCrtcCX

Loopit3:
        ; Now call to set this mode
        cmp     dword ptr ds:[edi],0
        je      SkipIt3
        cmp     fGetSet,0
        jne     SetGamma
GetGamma:
        push    dword ptr ds:[edi]
        push    pGammaRamp
        call    GN_GetCrtcGamma
        jmp     DoneIt

SetGamma:
        push    dword ptr ds:[edi]
        push    pGammaRamp
        call    GN_SetCrtcGamma
SkipIt3:
        add     edi,4
        inc     dwCRTCCount
        mov     eax,dwCRTCCount
	cmp	eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      Loopit3

DoneIt:
        mov     eax,1
        POPR    ds,esi,edi
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNLINE.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnline.asm
;
; Purpose:      This file holds the Output(OS_POLYLINE) display driver
;               implementation. The Output display driver entry point
;               jumps to here without creating a FRAME when it is
;               discovered that this is and OS_POLYLINE style.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_Polyline
;
; Purpose:      This function is the Output(OS_POLYLINE) display driver
;               implementation. The Output display driver entry point
;               jumps to here without creating a FRAME when it is
;               discovered that this is the OS_POLYLINE style.
;
; Arguments:    Output Display Driver Stack Frame
;
; Returns:      ax      0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_Polyline, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wStyle
PARMW   wCount
PARMD   lpPoints
PARMD   lpPen
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   lpClipRect
OPENPROC
        PUSHR   ds,esi,edi

        ; Load HW Logical Device Context
        mov     ds,cs:[wFlatDataSel]
        mov     ebx,cs:[CSpGNLogicalDevice]

        ; Get a ptr to the dst bitmap
        mov     gs,word ptr lpDstDev+2
        movzx   esi,word ptr lpDstDev+0

        ; Load dst flags and prep some registers
        sub     edx,edx
        sub     edi,edi
        movzx   eax,gs:[esi].DIBENGINE.deFlags

        ; Filter out Null Pens
        cmp     edx,lpPen
        je      GN_PolylinePunt

        ; Filter out old style destinations
        cmp     dx,gs:[esi].DIBENGINE.deType
        je      GN_PolylinePunt

        ; Filter out based upon deFlags
        test    ah,VRAM / 256
        jz      GN_PolylinePunt

        cmp     ds:[ebx].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_PolylinePunt

        ; Load up the pen color
        les     di,lpPen
        mov     ecx,es:[edi].DIB_Pen.dpPenColor
        movzx   edx,byte ptr es:[edi].DIB_Pen.dpPenStyle
        cmp     edx,LS_NOLINE
        je      GN_PolylineSuccess
        
        test    ah,PALETTE_XLAT / 256
        jz      @F

        ; Get color from bPaletteXlatTable
        and     ecx,0FFh
        lea     eax,ds:[ebx].GNLOGDEVCX.bPaletteXlatTable
        mov     cl,byte ptr ds:[eax+ecx]

@@:
        ; Push arguments for Hardware specific polyline routine
        push    ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        push    lpPoints
        movzx   eax,wCount
        push    eax
        push    ecx

        ; We need the background color in case this is a styled line
        les     di,lpDrawMode
        mov     eax,es:[edi].DRAWMODE.bkColor
        push    eax

        ; Get the Rop2 from the DRAWMODE struct
        movzx   eax,byte ptr es:[edi].DRAWMODE.Rop2
        dec     eax
        push    eax
        push    edx

        ; Get the clip rect if there is one
        mov     eax,-1
        cmp     lpClipRect,0
        je      NoClipRect
        les     di,lpClipRect
        mov     eax,dword ptr es:[edi].RECT.left
        mov     ebx,dword ptr es:[edi].RECT.right

        ; Right may exceed bitmap Width
        cmp     bx,gs:[esi].DIBENGINE.deWidth
        jle     @F
        mov     bx,gs:[esi].DIBENGINE.deWidth
@@:

NoClipRect:
        push    ebx
        push    eax

        ; Check for degenerate clip rectangles before calling.
        ; This almost never happens, but should be checked for.
        cmp     ax,bx
        jge     GN_PolylinePuntPop
        shr     eax,10H
        shr     ebx,10H
        cmp     ax,bx
        jge     GN_PolylinePuntPop

        cmp     edx,LS_SOLID
        jne     GN_PolylineNonSolid

        ; Call the hardware specific routine to draw the lines
        call    HW_Polyline
        test    eax,eax
        jz      GN_PolylinePunt
        jmp     GN_PolylineSuccess
GENERIC_Polyline        ENDP


PUBLIC  GN_PolylineNonSolid
GN_PolylineNonSolid PROC    NEAR
        call    HW_PolyStyledLine
        test    eax,eax
        jz      GN_PolylinePunt
        jmp     GN_PolylineSuccess
GN_PolylineNonSolid ENDP

;==============================================================================
;
; Function:     Polyline ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of Polyline. You can either return a success code,
;               punt to the DIBENG, etc.
;
; Arguments:    Output Display Driver Stack Frame
;
;==============================================================================
PUBLIC  GN_PolylinePuntPop
GN_PolylinePuntPop       PROC    NEAR
        ; Clean off parameters for HW_Polyline
        add     sp,9 * 4
GN_PolylinePuntPop       ENDP

PUBLIC  GN_PolylinePunt
GN_PolylinePunt  PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
PLABEL  Punt_Polyline
        jmp     DIB_Output
GN_PolylinePunt  ENDP

PUBLIC  GN_PolylineSuccess
GN_PolylineSuccess       PROC    NEAR
        mov     eax,1
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 1CH
GN_PolylineSuccess       ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNMONBLT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, NVidia Coporation
;
; File:         gnmonblt.asm
;
; Purpose:      This file holds the routines to do Bitblt's involving
;               a mono source located in system memory. There may
;               also be a pattern involved but maybe not. The code is
;               generic in terms of not touching hardware, but it does
;               make assumptions about hardware capability and to some
;               extent programming order. These should all be fine for
;               Nvidia products.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include	gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GN_BitBltSrcMonoDstVram
;
; Purpose:      This function implements BitBlts where the rop involves
;               a src, the src is a mono system memory bitmap and the
;               dst is in VRAM. There may be a pattern involved as well
;               but there may not be. The general strategy implemented
;               in this routine is
;
;               1) Compute all the neccessary data
;
;               2) Call the HW_BeginSrcMonoDstVram routine to set up
;                  the chip to expect to receive dwExtX * dwExtY pixels
;                  in the Destination Pixel Depth and place them
;                  in the rectangle whose upper left corner is at
;                  dwDstLeft,dwDstTop. HW_BeginSrcMonoDstVram will
;                  also set the rop, base address, set up the pattern, etc.
;
;               3) GN_BitBltSrcMonoDstVram calls the routine
;                  HW_BlockSrcMonoDstVram to wait for enough space
;                  in the hardware buffer.
;
;               4) GN_BitBltSrcMonoDstVram calls an inner loop routine
;                  which reads src pixels, translates them to dst space
;                  and stores them in the hardware. The inner loop routine
;                  can do partial scanlines or an integral number of scans.
;
;               5) Steps 3 and 4 are repeated until the entire bitmap has
;                  been transferred.
;
;               6) HW_EndSrcMonoDstVram is called to allow the hardware
;                  specific code to clean up anything it needs to.
;
; Arguments:
;		ds		Context Selector
;		pGNLogdevCXOffset  GNLOGDEVCX ptr
;               dwDstBitsSel    Selector for the dst bits
;               dwDstBitsOffset Offset to the dst bits
;               dwDstBpp        bits per pixel of the dst bitmap
;               dwDstPitch      address of first pixel on line n+1 minus
;                               address of first pixel on line n.
;                               This number might be negative if the
;                               DIB is upside down.
;               dwDstLeft       left edge of the dst rectangle
;               dwDstTop        top  edge of the dst rectangle
;               dwSrcBitsSel    selector to the src bits
;               dwSrcBitsOffset offset to the start of the source bits
;               dwSrcPitch      address of first pixel on line n+1 minus
;                               address of first pixel on line n.
;                               This number might be negative if the
;                               DIB is upside down.
;               dwSrcLeft       left edge of the src rectangle
;               dwSrcTop        top  edge of the src rectangle
;               dwExtX          extent of the src (and dst) rectangle.
;               dwExtY          extent of the src (and dst) rectangle.
;               dwBgColor       expand 0 bits in the src to this color
;               dwFgColor       expand 1 bits in the src to this color
;               dwRop3          3-operand rop
;               lpBrush         ptr to a DIB_Brush struct
;               lpDrawMode      This is only needed for the case where
;                               the rop involves a brush and the brush
;                               is a mono pattern. In this case,
;                               DRAWMODE.TextColor specifies the color
;                               to which to translate pattern 0 bits, and
;                               DRAWMODE.bkColor specifies the color to
;                               which to translate pattern 1 bits. Note
;                               that these are not the same colors used
;                               translate 0 and 1 bits from the src
;                               bitmap.
;               dwScansLeftInSeg number of scanlines to process starting
;                               from the dwSrcTop coord passed in before
;                               the segment break and byte padding.
;               dwScansPerSeg   number of scans between segment breaks
;               dwFillBytes     number of bytes to add to src ptr to
;                               skip padding between bitmap segment breaks.
;
; Returns:      eax     0       The routine will be punted to software
;                       non-0   the return code to GDI
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_BitBltSrcMonoDstVram, PASCAL, FRAME, NEAR
PARMD   pGNLogdevCXOffset
PARMD   dwDstBitsSel
PARMD   dwDstBitsOffset
PARMD   dwDstBpp
PARMD   dwDstPitch
PARMD   dwDstLeft
PARMD   dwDstTop
PARMD   dwSrcBitsSel
PARMD   dwSrcBitsOffset
PARMD   dwSrcPitch
PARMD   dwSrcLeft
PARMD   dwSrcTop
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwBgColor
PARMD   dwFgColor
PARMD   dwRop3
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   dwScansLeftInSeg
PARMD   dwScansPerSeg
PARMD   dwFillBytes

LOCALD  dwExtraWord
LOCALD  dwPixelsIgnoredOnLeft
LOCALD  dwAlignedDstLeft
LOCALD  dwAlignedSrcLeft
LOCALD  dwAlignedExtXInPixels
LOCALD  dwAlignedSrcExtXInBytes
LOCALD  dwAlignedSrcExtXInDwords
LOCALD  dwMaxTransferSizeInBytes
LOCALD  dwSrcStart
LOCALD  dwDstWrapWidth
LOCALD  dwSrcWrapWidth
LOCALD  dwDwordsPerBlock
LOCALD  dwScansPerBlock
LOCALD  dwBytesPerBlock
LOCALD	pHWBoardCXOffset
OPENPROC
        PUSHR   ds,esi,edi

        ; We assume a hardware clip rect; hence, drop the starting
        ; src coord back to the start of a dword. The dst will need
        ; to be dropped back the same amount and the width will need
        ; to be increased by the same amount. Then to make things
        ; even simpler, increase the width from this new value until
        ; it is a multiple of 32, thus making the amount of src data
        ; to transfer per scan a multiple of a dword.
        mov     eax,dwSrcLeft
        mov     ebx,eax
        and     eax,NOT 1FH
        mov     dwAlignedSrcLeft,eax
        sub     ebx,eax
        mov     ecx,dwDstLeft
        mov     edx,dwExtX
        mov     dwPixelsIgnoredOnLeft,ebx
        sub     ecx,ebx
        lea     eax,[edx][ebx + 0FH]
        lea     edx,[edx][ebx + 1FH]
        and     eax,NOT 0FH
        and     edx,NOT 1FH
        mov     dwAlignedExtXInPixels,edx
        sub     eax,edx
        mov     dwExtraWord,eax
        mov     dwAlignedDstLeft,ecx
        shr     edx,3
        mov     dwAlignedSrcExtXInBytes,edx
        shr     edx,2
        mov     dwAlignedSrcExtXInDwords,edx

        ; Now we compute the src starting address and wrap width
        mov     eax,dwSrcTop
        sub     edx,edx
        div     dwScansPerSeg
        shl     eax,10H
        imul    edx,dwSrcPitch
        mov     ebx,dwAlignedSrcLeft
        add     eax,edx
        shr     ebx,3
        add     eax,dwSrcBitsOffset
        add     eax,ebx
        mov     dwSrcStart,eax
        mov     eax,dwSrcPitch
        sub     eax,dwAlignedSrcExtXInBytes
        mov     dwSrcWrapWidth,eax

        ; Call the hardware specific routine to setup for the transfer
        mov	ebx,pGNLogdevCXOffset
        mov    	ecx,ds:[ebx].GNLOGDEVCX.pGNBoardCX
	mov	eax,ds:[ecx].GNBOARDCX.pHWBoardCX
	mov	pHWBoardCXOffset,eax

        push    ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        push    dwDstBitsOffset
        push    dwDstPitch
        push    dwDstBpp
        push    dwDstLeft
        push    dwDstTop
        push    dwAlignedDstLeft
        push    dwExtX
        push    dwExtY
        push    dwAlignedSrcExtXInBytes
        push    dwAlignedExtXInPixels
        push    dwPixelsIgnoredOnLeft
        push    dwBgColor
        push    dwFgColor
        push    lpBrush
        push    lpDrawMode
        push    dwRop3
        call    HW_BeginSrcMonoDstVram
        or      eax,eax
        je      DoneIt
        mov     dwDstWrapWidth,ebx
        mov     dwMaxTransferSizeInBytes,ecx

        ; At this point, the generic and hardware code are linked
        ; until the HW_EndSrcMonoDstVram routine is called.
        ; The generic code has agreed not to touch es -- it is the
        ; hardware's selector for whatever purposes it may need.

        ; Now we can begin the inner loop. Ther are two major cases
        ; that can occur and we will handle them separately.
        ; 1) The number of bytes that are to be transferred for a single
        ;    scanline is larger than the most the hardware can accept
        ;    in one shot. Each scanline must be broken into multiple
        ;    pieces. This is most typically the FIFO based model.
        ; 2) At least one scanline, possibly many, can be sent as a
        ;    single transfer. This is the typical DMA scenario.
        ;
        ; For each of these cases, there are two subcases. Mono bitmaps
        ; are only guaranteed to have a word width and if we transfer a
        ; multiple of 4 bytes per scan, on the last scan we could walk
        ; off the end of the bitmap casuing a GPF unless we handle the
        ; scan properly. We don't have to worry about this unless the
        ; dwSrcPitch is NOT a multiple of 4 AND in extending the width
        ; of the transfer out to be dword aligned on the left edge, we
        ; have included a word in which all pixels are clipped.
        push    OFFSET CRet
        mov     eax,dwSrcPitch
        mov     ebx,dwExtraWord
        and     eax,3
        je      IsAlgn
        or      ebx,ebx
        je      IsAlgn
IsUnAl: cmp     ecx,dwAlignedSrcExtXInBytes
        jle     GN_XferPartialUnalignedMonoScans
        jmp     GN_XferWholeUnalignedMonoScans
IsAlgn: cmp     ecx,dwAlignedSrcExtXInBytes
        jle     GN_XferPartialAlignedMonoScans
Whole:  jmp     GN_XferWholeAlignedMonoScans
CRet:
        ; Let the hardware know we are done
        mov	esi,pHWBoardCXOffset
        call    HW_EndSrcMonoDstVram

        mov     eax,1
DoneIt:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_XferWholeAlignedMonoScans
;
; Purpose:      This function is called from GN_BitBltSrcMonoDstVram
;               when at least one whole scan will fit in the transfer
;               area of the chip AND the pitch of the src bitmap is a
;               multiple of a dword. It handles calling the hardware for
;               space and then calling the inner loop to transfer data.
;
; Arguments:    Shares stack FRAME with GN_BitBltSrcMonoDstVram
;               es      hardware specific code has set this
;                       Do not change it!
;               edi     Can be incremented appropriately as each scan
;                       is put in the buffer and the wrapWidth can be
;                       added appropriately. These are the only changes
;                       allowed.
;
; Returns:      None
;
; Preserve:     None
;==============================================================================
PUBLIC  GN_XferWholeAlignedMonoScans
GN_XferWholeAlignedMonoScans    PROC    NEAR

        ; Figure out how many scanlines can be done in a single shot
        mov     eax,dwMaxTransferSizeInBytes
        sub     edx,edx
        div     dwAlignedSrcExtXInBytes
        mov     dwScansPerBlock,eax
        imul    eax,dwAlignedSrcExtXInBytes
        mov     dwBytesPerBlock,eax
        mov     esi,dwSrcStart
        mov     ds,word ptr dwSrcBitsSel
LoopY:
        ; Compute the number of scans in the next chunk
        mov     eax,dwBytesPerBlock
        mov     ebx,dwScansPerBlock
        sub     dwExtY,ebx
        jge     @F
        add     ebx,dwExtY
        mov     dwExtY,0
        mov     eax,dwAlignedSrcExtXInBytes
        imul    eax,ebx
@@:
        ; Have the hardware wait for enough space to hold one chunk's
        ; worth of bytes. The hardware returns in es:edi a ptr to where
        ; to place the dst pixels.
        PUSHR	esi
        mov	esi,pHWBoardCXOffset
        call    HW_BlockSrcMonoDstVram
        POPR	esi
@@:
        ; Now we transfer the data
        mov     ecx,dwAlignedSrcExtXInDwords
        rep     movs dword ptr es:[edi], ds:[esi]
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwScansLeftInSeg
        je      Wrap
WrapD:
        dec     ebx
        jne     @B
        cmp     ebx,dwExtY
        jne     LoopY
        ret
Wrap:
        mov     eax,dwScansPerSeg
        mov     dwScansLeftInSeg,eax
        add     esi,dwFillBytes
        jmp     WrapD

GN_XferWholeAlignedMonoScans    ENDP


;==============================================================================
;
; Function:     GN_XferWholeUnalignedMonoScans
;
; Purpose:      This function is called from GN_BitBltSrcMonoDstVram
;               when at least one whole scan will fit in the transfer
;               area of the chip AND the pitch of the src bitmap is NOT a
;               multiple of a dword. It handles calling the hardware for
;               space and then calling the inner loop to transfer data.
;
; Arguments:    Shares stack FRAME with GN_BitBltSrcMonoDstVram
;               es      hardware specific code has set this
;                       Do not change it!
;               edi     Can be incremented appropriately as each scan
;                       is put in the buffer and the wrapWidth can be
;                       added appropriately. These are the only changes
;                       allowed.
;
; Returns:      None
;
; Preserve:     None
;==============================================================================
PUBLIC  GN_XferWholeUnalignedMonoScans
GN_XferWholeUnalignedMonoScans  PROC    NEAR

        ; Figure out how many scanlines can be done in a single shot
        mov     eax,dwMaxTransferSizeInBytes
        sub     edx,edx
        div     dwAlignedSrcExtXInBytes
        mov     dwScansPerBlock,eax
        imul    eax,dwAlignedSrcExtXInBytes
        mov     dwBytesPerBlock,eax
        mov     esi,dwSrcStart
        mov     ds,word ptr dwSrcBitsSel

        ; We must transfer one less dword and then one extra word
        ; so adjust some things to make up for this change.
        mov     eax,4
        dec     dwAlignedSrcExtXInDwords
        add     dwSrcWrapWidth,eax
        add     dwDstWrapWidth,eax
LoopY:
        ; Compute the number of scans in the next chunk
        mov     eax,dwBytesPerBlock
        mov     ebx,dwScansPerBlock
        sub     dwExtY,ebx
        jge     @F
        add     ebx,dwExtY
        mov     dwExtY,0
        mov     eax,dwAlignedSrcExtXInBytes
        imul    eax,ebx
@@:
        ; Have the hardware wait for enough space to hold one chunk's
        ; worth of bytes. The hardware returns in es:edi a ptr to where
        ; to place the dst pixels.
        PUSHR	esi
        mov	esi,pHWBoardCXOffset
        call    HW_BlockSrcMonoDstVram
        POPR	esi
@@:
        ; Now we transfer the data
        mov     ecx,dwAlignedSrcExtXInDwords
        rep     movs dword ptr es:[edi], ds:[esi]
        mov     ax,ds:[esi]
        mov     es:[edi],ax
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwScansLeftInSeg
        je      Wrap
WrapD:
        dec     ebx
        jne     @B
        cmp     ebx,dwExtY
        jne     LoopY
        ret
Wrap:
        mov     eax,dwScansPerSeg
        mov     dwScansLeftInSeg,eax
        add     esi,dwFillBytes
        jmp     WrapD

GN_XferWholeUnalignedMonoScans  ENDP


;==============================================================================
;
; Function:     GN_XferPartialAlignedMonoScans
;
; Purpose:      This function is called from GN_BitBltSrcMonoDstVram
;               when one whole scan will not fit in the transfer
;               area of the chip AND the pitch of the src bitmap is a
;               multiple of a dword. It handles calling the hardware for
;               space and then calling the inner loop to transfer data.
;
; Arguments:    Shares stack FRAME with GN_BitBltSrcMonoDstVram
;               es      hardware specific code has set this
;                       Do not change it!
;               edi     Can be incremented appropriately as each scan
;                       is put in the buffer and the wrapWidth can be
;                       added appropriately. These are the only changes
;                       allowed.
;
; Returns:      None
;
; Preserve:     None
;==============================================================================
PUBLIC  GN_XferPartialAlignedMonoScans
GN_XferPartialAlignedMonoScans  PROC    NEAR

        ; We can't send a whole scanline in a single transfer so compute
        ; how many dwords (chunks of 32 pixels) we can send in one shot.
        mov     eax,dwMaxTransferSizeInBytes
        mov     dwBytesPerBlock,eax
        shr     eax,2
        mov     dwDwordsPerBlock,eax
        mov     esi,dwSrcStart
        mov     ds,word ptr dwSrcBitsSel

LoopY:
        push    dwAlignedSrcExtXInDwords
LoopX:
        ; Compute the number of pixels in the next chunk
        mov     eax,dwBytesPerBlock
        mov     ebx,dwDwordsPerBlock
        sub     dwAlignedSrcExtXInDwords,ebx
        jge     @F
        add     ebx,dwAlignedSrcExtXInDwords
        mov     dwAlignedSrcExtXInDwords,0
        lea     eax,[ebx * 4]
@@:
        ; Have the hardware wait for enough space to hold one chunk's
        ; worth of bytes. The hardware returns in es:edi a ptr to where
        ; to place the dst pixels.
        PUSHR	esi
        mov	esi,pHWBoardCXOffset
        call    HW_BlockSrcMonoDstVram
        POPR	esi

        ; Now we transfer the data
        mov     ecx,ebx
        rep     movs dword ptr es:[edi], ds:[esi]

        ; Are there more pixels left on this scanline?
        cmp     ecx,dwAlignedSrcExtXInDwords
        jne     LoopX
        pop     dwAlignedSrcExtXInDwords

        ; Go to the next scanline
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwScansLeftInSeg
        je      Wrap
WrapD:
        dec     dwExtY
        jg      LoopY
        ret
Wrap:
        mov     eax,dwScansPerSeg
        mov     dwScansLeftInSeg,eax
        add     esi,dwFillBytes
        jmp     WrapD

GN_XferPartialAlignedMonoScans  ENDP


;==============================================================================
;
; Function:     GN_XferPartialUnalignedMonoScans
;
; Purpose:      This function is called from GN_BitBltSrcMonoDstVram
;               when one whole scan will not fit in the transfer
;               area of the chip AND the pitch of the src bitmap is NOT a
;               multiple of a dword. It handles calling the hardware for
;               space and then calling the inner loop to transfer data.
;
; Arguments:    Shares stack FRAME with GN_BitBltSrcMonoDstVram
;               es      hardware specific code has set this
;                       Do not change it!
;               edi     Can be incremented appropriately as each scan
;                       is put in the buffer and the wrapWidth can be
;                       added appropriately. These are the only changes
;                       allowed.
;
; Returns:      None
;
; Preserve:     None
;==============================================================================
PUBLIC  GN_XferPartialUnalignedMonoScans
GN_XferPartialUnalignedMonoScans        PROC    NEAR

        ; We can't send a whole scanline in a single transfer so compute
        ; how many dwords (chunks of 32 pixels) we can send in one shot.
        mov     eax,dwMaxTransferSizeInBytes
        mov     dwBytesPerBlock,eax
        shr     eax,2
        mov     dwDwordsPerBlock,eax
        mov     esi,dwSrcStart
        mov     ds,word ptr dwSrcBitsSel

        ; We must transfer one less dword and then one extra word
        ; so adjust some things to make up for this change.
        mov     eax,4
        add     dwSrcWrapWidth,eax
        add     dwDstWrapWidth,eax

LoopY:
        push    dwAlignedSrcExtXInDwords
LoopX:
        ; Compute the number of pixels in the next chunk
        mov     eax,dwBytesPerBlock
        mov     ebx,dwDwordsPerBlock
        sub     dwAlignedSrcExtXInDwords,ebx
        jge     @F
        add     ebx,dwAlignedSrcExtXInDwords
        mov     dwAlignedSrcExtXInDwords,0
        lea     eax,[ebx * 4]
        dec     ebx             ; allocate, but don't fill last dword
@@:
        ; Have the hardware wait for enough space to hold one chunk's
        ; worth of bytes. The hardware returns in es:edi a ptr to where
        ; to place the dst pixels.
        PUSHR	esi
        mov	esi,pHWBoardCXOffset
        call    HW_BlockSrcMonoDstVram
        POPR	esi

        ; Now we transfer the data
        mov     ecx,ebx
        rep     movs dword ptr es:[edi], ds:[esi]

        ; Are there more pixels left on this scanline?
        cmp     ecx,dwAlignedSrcExtXInDwords
        jne     LoopX
        mov     ax,ds:[esi]
        mov     es:[edi],ax
        pop     dwAlignedSrcExtXInDwords

        ; Go to the next scanline
        add     esi,dwSrcWrapWidth 
        add     edi,dwDstWrapWidth 
        dec     dwScansLeftInSeg
        je      Wrap
WrapD:
        dec     dwExtY
        jg      LoopY
        ret
Wrap:
        mov     eax,dwScansPerSeg
        mov     dwScansLeftInSeg,eax
        add     esi,dwFillBytes
        jmp     WrapD

GN_XferPartialUnalignedMonoScans        ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNOFFMGR.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation
;
; File:         gnoffmgr.asm
;
; Purpose:      This file holds the routines that manage offscreen
;               memory.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GN_ControlOffscreenAllocations
;
; Purpose:      This routine gets called to either allocate memory
;               for offscreen allocations or free it up.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;               dwFlag                  TRUE then enable, FALSE then disable
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_ControlOffscreenAllocations, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   dwFlag
LOCALD	dwLogdevCount
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNBoardCXOffset

        cmp     dwFlag,0
        jne     DoEnable

DoDisable:
        test   	ds:[esi].GNBOARDCX.dwOffscreenFlags,OFFS_HEAP_UNAVAILABLE
        jnz	DoneIt

        ; Flush all offscreen bitmaps
        push    pGNBoardCXOffset
        call    GN_ClearOffscreenBitmapCache

	; OK, this is funky. We have to run through all the logical
	; devices that are attached to this board and tell them that
	; the offscreen heap is disappearing.
	lea	edi,[esi].GNBOARDCX.pGNLogdevCX
	mov	dwLogdevCount,0
Loop1:
	mov	eax,ds:[edi]
	or	eax,eax
	je	@F
	push	eax
	call	GN_OffscreenHeapDisappearing
@@:
	add	edi,4
	inc	dwLogdevCount
	mov	ecx,dwLogdevCount
	cmp	ecx,MAX_ATTACHED_CRTCS
	jc	Loop1

        ; Mark the offscreen heap as unavailable
        or     	ds:[esi].GNBOARDCX.dwOffscreenFlags,OFFS_HEAP_UNAVAILABLE

        ; Call the hardware to have it free the offscreen block
        push    ds:[esi].GNBOARDCX.pHWBoardCX
        push    ds:[esi].GNBOARDCX.dwOffscreenBaseAddress
        call    HW_FreeOffscreenBlock
        mov     ds:[esi].GNBOARDCX.dwOffscreenBaseAddress,0
        mov     ds:[esi].GNBOARDCX.dwOffscreenLength,0
        jmp     DoneIt

DoEnable:
        ; If we are already enabled, then ignore the call
        test   	ds:[esi].GNBOARDCX.dwOffscreenFlags,OFFS_HEAP_UNAVAILABLE
        jz	DoneIt

        ; Call the hardware to get the largest offscreen block.
        push    ds:[esi].GNBOARDCX.pHWBoardCX
        call    HW_GetLargestOffscreenBlock

        ; Allocate it
        push    ds:[esi].GNBOARDCX.pHWBoardCX
        push    eax
        call    HW_AllocOffscreenBlock

        ; Set up an offscreen heap if there was any memory
        cmp	eax,-1
        je      DoneIt

        mov     ds:[esi].GNBOARDCX.dwOffscreenBaseAddress,eax
        mov     ds:[esi].GNBOARDCX.dwOffscreenLength,ebx

	mov	ecx,ebx
	mov	ebx,eax
        mov    	eax,ds:[esi].GNBOARDCX.dwOffscreenHeap
        call    GN_HeapInit

        and    	ds:[esi].GNBOARDCX.dwOffscreenFlags,NOT OFFS_HEAP_UNAVAILABLE

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_OffscreenAllocationsLock
;
; Purpose:      This function increments a lock count which begins at 0.
;               When the lock count goes from 0 to 1, all offscreen
;               allocations are flushed and offscreen usage by the display
;               driver is inhibited until the lock count goes to 0 via
;               matching calls to GN_OffscreenAllocationsUnlock.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     All registers
;==============================================================================
DECPROC GN_OffscreenAllocationsLock, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   alld,ds,es,fs,gs
        mov     ds,wFlatDataSel_In_NVTEXT16
        mov     esi,CSpGNLogicalDevice_In_NVTEXT16
        mov     edi,ds:[esi].GNLOGDEVCX.pGNBoardCX
        cmp     ds:[edi].GNBOARDCX.dwOffscreenLockCount,0
        jne     @F

        ; Flush the offscreen list
        push    edi
        call    GN_ClearOffscreenBitmapCache
@@:
        or      ds:[edi].GNBOARDCX.dwOffscreenFlags,OFFS_ALLOCS_BLOCKED
        inc     ds:[edi].GNBOARDCX.dwOffscreenLockCount
        POPR    alld,ds,es,fs,gs
CLOSEPROC


;==============================================================================
;
; Function:     GN_OffscreenAllocationsUnlock
;
; Purpose:      See GN_OffscreenAllocationsLock for details.
;
; Arguments:    None
;
; Returns:      eax     Current Lock count
;
; Preserve:     All registers except eax
;==============================================================================
DECPROC GN_OffscreenAllocationsUnlock, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi
        mov     ds,wFlatDataSel_In_NVTEXT16
        mov     esi,CSpGNLogicalDevice_In_NVTEXT16
        mov     edi,ds:[esi].GNLOGDEVCX.pGNBoardCX
        dec     ds:[edi].GNBOARDCX.dwOffscreenLockCount
        jne     @F
        and     ds:[edi].GNBOARDCX.dwOffscreenFlags,NOT OFFS_ALLOCS_BLOCKED
@@:
        POPR    ds,esi,edi
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNOUTPUT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnoutput.asm
;
; Purpose:      This file holds the Output display driver entry point.
;
;==============================================================================
.586
incOutput = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

; These all have to be marked as NEAR or else the conditional jumps to them
; below will cause an assembler error. They are really FAR16 functions.
EXTERNDEF       GENERIC_Rectangle:NEAR
EXTERNDEF       GENERIC_Polyline:NEAR
EXTERNDEF       GENERIC_PolyScanOrScanLine:NEAR
EXTERNDEF       GENERIC_BeginScan:NEAR
EXTERNDEF       GENERIC_EndScan:NEAR

;==============================================================================
;
; Function:     GENERIC_Output
;
; Purpose:      This function is the Output display driver entry point.
;
; Arguments:    Output Display Driver Stack Frame
;
;
; Returns:      ax      1       success
;                       0       failure
;                       -1      have GDI simulate
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_Output, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMW   wStyle
;PARMW   wCount
;PARMD   lpPoints
;PARMD   lpPen
;PARMD   lpBrush
;PARMD   lpDrawMode
;PARMD   lpClipRect
OPENPROC
        movzx   ebx,sp
        movzx   eax,word ptr ss:[ebx + 1AH]
        cmp     eax,OS_RECTANGLE
        je      GENERIC_Rectangle
        cmp     eax,OS_POLYLINE
        je      GENERIC_Polyline
        cmp     eax,OS_POLYSCANLINE
        je      GENERIC_PolyScanOrScanLine
        cmp     eax,OS_BEGINNSCAN
        je      GENERIC_BeginScan
        cmp     eax,OS_ENDNSCAN
        je      GENERIC_EndScan
        cmp     eax,OS_SCANLINES
        je      GENERIC_PolyScanOrScanLine
        cmp     eax,OS_ALTPOLYGON
        je      O_Ret
        cmp     eax,OS_WINDPOLYGON
        jne	Punt_Output     
O_Ret:	mov     eax,-1
        RETFAR16 1CH
PLABEL	Punt_Output
        jmp     DIB_Output
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNOFFBMP.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnoffbmp.asm
;
; Purpose:      This file holds routines for flushing, initting,
;               de-initting, allocating and freeing offscreen bitmaps.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc


; I want to keep stats on the allocations and it makes the most sense
; to store these in a few fields of the first OFFBMPINFO structure.
; Here are the stats I will be keeping and where they are being placed.
;
; dwBitmapLength - total number of offscreen bitmaps ever allocated
; dwBitmapVRAMOffset - bytes of offscreen memory currently allocated to
;                         offscreen bitmaps
; wHeaderSel     - number of offscreen bitmaps currently allocated
; wUnused        - Byte Offset in array of next OFFBMPINFO struct
;                         to use for the next offscreen bitmap,

NEXT_FREE_ENTRY                         MACRO   sreg,reg
        EXITM   <@CatStr(sreg, <:[>, reg, <].OFFBMPINFO.wUnused>)>
ENDM

NUM_ALLOCED_OFFSCREEN_BITMAPS           MACRO   sreg,reg
        EXITM   <@CatStr(sreg, <:[>, reg, <].OFFBMPINFO.wBitmapSel>)>
ENDM

BYTES_USED_FOR_OFFSCREEN_BITMAPS        MACRO   sreg,reg
        EXITM   <@CatStr(sreg, <:[>, reg, <].OFFBMPINFO.dwBitmapVRAMOffset>)>
ENDM

TOTAL_ALLOCED_OFFSCREEN_BITMAPS         MACRO   sreg,reg
        EXITM   <@CatStr(sreg, <:[>, reg, <].OFFBMPINFO.dwBitmapLength>)>
ENDM


OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
;==============================================================================
;
; Function:     GN_ClearOffscreenBitmapCache
;
; Purpose:      This function clears the offscreen bitmap cache.
;
; Arguments:
;               ds              Selector for the board Context data
;               pBoardCXOffset  Offset to the board context data
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_ClearOffscreenBitmapCache, PASCAL, FRAME, FAR32
PARMD   pBoardCXOffset
OPENPROC
        PUSHR   es,esi,edi
        mov     esi,pBoardCXOffset
        mov     edi,ds:[esi].GNBOARDCX.pNextOffbmpinfo

LoopY:
        ; Are there more headers?
        lea     ebx,[esi].GNBOARDCX.OffscreenBitmapCache
        sub     edi,SIZE OFFBMPINFO
        cmp     edi,ebx
        jc      ClearStats

        ; Is the bitmap still valid?
        mov     eax,ds:[edi].OFFBMPINFO.dwBitmapSel
        call    GN_OffscreenBitmapValidCheck
        or      eax,eax
	jnz	FlushIt

	; Bitmap lost. Free offscreen memory.
	push	esi
	push	edi
	call	GN_OffscreenBitmapDelete
	jmp	LoopY

FlushIt:
        ; Yes it is, so flush it out to system memory and clear
        ; out the ptr to the bitmap header.
        mov     eax,ds:[edi].OFFBMPINFO.dwBitmapSel
	mov	es,ax
	push	esi
        mov     esi,ds:[edi].OFFBMPINFO.dwBitmapOffset
        call	GN_FlushOffscreenBitmap
	pop	esi
        mov     dword ptr ds:[edi],0
        jmp     LoopY

ClearStats:
        ; Reset the statistics
        sub     eax,eax
        mov     ds:[esi].GNBOARDCX.dwOffscreenBitmapsAllocatedSinceLastFlush,eax
        mov     ds:[esi].GNBOARDCX.dwOffscreenBitmapsCurrentlyAllocated,eax
        mov     ds:[esi].GNBOARDCX.dwBytesOfOffscreenMemoryCurrentlyAllocatedForBitmaps,eax
        lea     eax,[esi].GNBOARDCX.OffscreenBitmapCache
        mov     ds:[esi].GNBOARDCX.pNextOffbmpinfo,eax

        POPR    es,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_OffscreenBitmapCreate
;
; Purpose:      This routine will create an offscreen bitmap by allocating
;               memory and modifying an existing DIBENGINE header.
;
; Arguments:
;               ds                      CXSel
;               pGNBoardCXOffset
;               es:edi                  ptr to DEVBMP.
;                                       The fields below are valid:
;                                       deWidth
;                                       deHeight
;                                       deWidthBytes
;                                       dePlanes
;                                       deBitsPixel
;                                       delpPDevice
;
; Returns:
;               eax     0       If the routine did not create the bitmap
;                       non-0   If the routine did create the bitmap
;                               In this case, the routine must have
;                               filled in the fields below:
;                               ds:[esi].DIBENGINE.deDeltaScan - bitmap pitch
;                               ds:[esi].DIBENGINE.deBits - ptr to bits
;
; Preserve:     ds,esi,edi,es
;==============================================================================
DECPROC GN_OffscreenBitmapCreate, PASCAL, FRAME, NEAR
PARMD   pGNBoardCXOffset
LOCALD  dwBmpOffset
LOCALD  dwBmpSize
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNBoardCXOffset
        mov     dwBmpOffset,edi

        ; Can our list of offscreen bitmaps hold another one?
        sub     eax,eax
        lea     ecx,ds:[esi].GNBOARDCX.OffscreenBitmapCache
        add     ecx,(MAX_OFFSCREEN_BITMAPS + 1) * SIZE OFFBMPINFO
        cmp     ecx,ds:[esi].GNBOARDCX.pNextOffbmpinfo
        jbe     Done

        ; Is there an offscreen heap?
        test	ds:[esi].GNBOARDCX.dwOffscreenFlags,NO_OFFS_BMPS
        jnz     Done

        ; Call the hardware specific routine to make sure it is OK
        ; to place this bitmap in offscreen memory.
        mov     ebx,ds:[esi].GNBOARDCX.pHWBoardCX
        call    HW_CreateOffscreenBitmap
        or      eax,eax
        je      Done

	; Check for the same selector at first
        sub     ebx,ebx
        mov     bx,es
        or      ebx,3
        lea     edx,ds:[esi].GNBOARDCX.OffscreenBitmapCache
        mov     edi,ds:[esi].GNBOARDCX.pNextOffbmpinfo
@@:
        sub     edi,SIZE OFFBMPINFO
        cmp     edi,edx
        jb      AllocSpace
        cmp     ebx,ds:[edi].OFFBMPINFO.dwBitmapSel
        jne     @B
	mov	eax,ds:[edi].OFFBMPINFO.dwBitmapOffset
        cmp	eax,dwBmpOffset
        jne     @B

	; We've found the same selector in cache.
	; We have to free offscreen memory and update cache table.
        push    esi
        push    edi
	call	GN_OffscreenBitmapDelete

AllocSpace:
        ; Hardware specific code approved the bitmap. Now, see
        ; if we can allocate the offscreen memory for it.
        mov     edi,dwBmpOffset
        movzx   edx,es:[edi].DEVBMP.Dibeng.deHeight
        mov     ecx,es:[edi].DEVBMP.Dibeng.deDeltaScan
        imul    ecx,edx
        mov     dwBmpSize,ecx
        or      es:[edi].DEVBMP.Dibeng.deFlags,VRAM OR OFFSCREEN
        mov     eax,ds:[esi].GNBOARDCX.dwOffscreenHeap
        call    GN_HeapAlloc
        sub     ebx,ebx
        or      eax,eax
        jne     Success

        ; The bitmap could not fit into the free offscreen memory.
        ; Look for a bitmap that we can flush out to system memory
        ; that is bigger than the new one we want to put in vidmem.
        lea     edx,ds:[esi].GNBOARDCX.OffscreenBitmapCache
        mov     edi,ds:[esi].GNBOARDCX.pNextOffbmpinfo
@@:
        sub     edi,SIZE OFFBMPINFO
        cmp     edi,edx
        jb      Done
        cmp     ds:[edi].OFFBMPINFO.dwBitmapLength,ecx
        jl      @B

Found:
        ; Is the bitmap still valid?
        mov     eax,ds:[edi].OFFBMPINFO.dwBitmapSel
        call    GN_OffscreenBitmapValidCheck
        or      eax,eax
        jne	SelectorValid

	; Here we have to remove invalid element from the chain.
        push    esi
        push    edi
	call	GN_OffscreenBitmapDelete

	; Try to allocate again
	jmp	AllocSpace

SelectorValid:
        ; Yes it is, so flush it out to system memory and clear
        ; out the ptr to the bitmap header.
        mov     eax,ds:[edi].OFFBMPINFO.dwBitmapSel
	push	es
	mov	es,ax
	push	esi
        mov     esi,ds:[edi].OFFBMPINFO.dwBitmapOffset
        call    GN_FlushOffscreenBitmap
	pop	esi
	pop	es
        mov     ecx,dwBmpSize

RedoAlloc:
        xor     ebx,ebx
        mov     eax,ds:[esi].GNBOARDCX.dwOffscreenHeap
        call    GN_HeapAlloc
        sub     ebx,ebx
        or      eax,eax
        je      Done

Success:
        ; We got the memory for an offscreen bitmap. The selector
        ; for the bits ptr is the same as the screen. The offset
        ; is what we got back from the HeapAlloc.
        mov     ebx,dwBmpOffset
        mov     es:[ebx].DEVBMP.Dibeng.deBitsOffset,eax

        ; Keep track of the new offscreen bitmap in our header list.
        mov     edi,ds:[esi].GNBOARDCX.pNextOffbmpinfo
        mov     ds:[edi].OFFBMPINFO.dwBitmapLength,ecx
        mov     ds:[edi].OFFBMPINFO.dwBitmapVRAMOffset,eax
	sub	edx,edx
        mov     dx,es
        or      edx,3
        mov     ds:[edi].OFFBMPINFO.dwBitmapSel,edx
        mov     ds:[edi].OFFBMPINFO.dwBitmapOffset,ebx
        add     edi,SIZE OFFBMPINFO
        mov     ds:[esi].GNBOARDCX.pNextOffbmpinfo,edi

        ; Minimal time taken to keep some statistics as well.
        inc     ds:[esi].GNBOARDCX.dwOffscreenBitmapsAllocatedSinceLastFlush
        inc     ds:[esi].GNBOARDCX.dwOffscreenBitmapsCurrentlyAllocated
        add     ds:[esi].GNBOARDCX.dwBytesOfOffscreenMemoryCurrentlyAllocatedForBitmaps,ecx
        mov     eax,1
Done:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_OffscreenBitmapDelete
;
; Purpose:      This routine deletes an offscreen bitmap and frees
;               up memory associated with it.
;
; Arguments:
;               ds                      CXSel
;               pGNBoardCXOffset
;               es:edi                  ptr to DEVBMP.
;                                       es:[esi].DIBENGINE.deBitsOffset
;                                       has base address of the bitmap.
;               dwCacheOffset		offset OffscreenBitmapCache if selector invalid
;
; Returns:      None
;
; Preserve:     ds,esi,edi,es
;==============================================================================
DECPROC GN_OffscreenBitmapDelete, PASCAL, FRAME, NEAR
PARMD   pGNBoardCXOffset
PARMD   dwCacheOffset
LOCALD	dwBitsOffset
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNBoardCXOffset

	cmp	dwCacheOffset,0
	je	GetOffsetFromBmp
	mov	edi,dwCacheOffset
	mov	ecx,ds:[edi].OFFBMPINFO.dwBitmapVRAMOffset
	jmp	@F

GetOffsetFromBmp:
        mov     ecx,es:[edi].DEVBMP.Dibeng.deBitsOffset
@@:
	mov	dwBitsOffset,ecx

        ; Call the hardware specific routine to do their thing
        mov     ebx,ds:[esi].GNBOARDCX.pHWBoardCX
	mov	eax,ecx
        call    HW_DeleteOffscreenBitmap

        ; Make sure we have an offscreen heap
        test	ds:[esi].GNBOARDCX.dwOffscreenFlags,NO_OFFS_BMPS
        jnz     Done

        ; Attempt to free the offscreen memory used by the bitmap.
        mov     eax,ds:[esi].GNBOARDCX.dwOffscreenHeap
	mov	ecx,dwBitsOffset
        call    GN_HeapFree

        ; If the memory manager found the allocation, we can update
        ; our statistics on offscreen bitmap memory usage.
        or      eax,eax
        je      @F
        sub     ds:[esi].GNBOARDCX.dwBytesOfOffscreenMemoryCurrentlyAllocatedForBitmaps,ecx
@@:
	cmp	dwCacheOffset,0
	jnz	Found

        ; Search for the offscreen bitmap in the list.
	sub	ebx,ebx
	mov	ecx,edi
        mov     bx,es
        or      ebx,3
        lea     edx,ds:[esi].GNBOARDCX.OffscreenBitmapCache
        mov     edi,ds:[esi].GNBOARDCX.pNextOffbmpinfo
@@:
        sub     edi,SIZE OFFBMPINFO
        cmp     edi,edx
        jb      Done
        cmp     ebx,ds:[edi].OFFBMPINFO.dwBitmapSel
        jne     @B
	mov	eax,ds:[edi].OFFBMPINFO.dwBitmapOffset
        cmp	eax,ecx
        jne     @B

Found:
        ; The bitmap was in our list. Adjust statistics again.
        dec     ds:[esi].GNBOARDCX.dwOffscreenBitmapsCurrentlyAllocated

        ; Now, to remove the bitmap from our list, take the last entry
        ; in the list and move it into the spot that has this current
        ; bitmap info. Then, drop the list count by 1 entry.
        ; and drop the free entry pointer by one array entry.
        mov     ebx,ds:[esi].GNBOARDCX.pNextOffbmpinfo
        sub     ebx,SIZE OFFBMPINFO
        mov     ds:[esi].GNBOARDCX.pNextOffbmpinfo,ebx

	; We don't need to copy if we are the last element.
	cmp	edi,ebx
	je	Done

        .errnz  (SIZE OFFBMPINFO - 10H)
        mov     eax,ds:[ebx + 00H]
        mov     ecx,ds:[ebx + 04H]
        mov     edx,ds:[ebx + 08H]
        mov     ebx,ds:[ebx + 0CH]
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        mov     ds:[edi + 08H],edx
        mov     ds:[edi + 0CH],ebx

Done:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_OffscreenBitmapValidCheck
;
; Purpose:      This routine checks a bitmap header to make sure it is
;               still valid and that the memory doesn't appear to have
;               been allocated to someone else. Unfortunately, the
;               display driver does not always get informed of when
;               memory belonging to bitmaps is deleted, discarded, etc
;               so this routine is necessary.
;
; Arguments:    eax     selector for bitmap header (header at ax:0)
;
; Returns:      eax     0       invalid bitmap header
;                       non-0   valid bitmap header
;
; Preserve:     ds,esi,edi,es
;==============================================================================
DECPROC GN_OffscreenBitmapValidCheck, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   es

        ; Is this even a valid selector?
        lar     edx,eax
        jnz     Fail

        ; The selector must be PRESENT, RING3, DATA
        and     dh,NOT 7
        cmp     dh,0F0H
        jne     Fail

	; The selector base must exceed 7fffffffH
	push	eax
        push    ax
        call    GetSelectorBase
	test	edx,8000H
	pop	eax
	jz	Fail

        ; The selector limit must be large enough to hold
        ; at least a DEVBMP header.
        lsl     ebx,eax
        inc     ebx
        cmp     ebx,SIZE DEVBMP
        jc      Fail

        ; Now we can load the selector without a GPF.
        ; Make sure the first word in the memory block looks like
        ; the start of a DIBENGINE header.
        mov     es,ax
        sub     edx,edx
        cmp     es:[edx].DIBENGINE.deType,5250H
        jne     Fail

        ; Check the selector limit against the total size the bitmap
        ; would take up -- header and the bits.
        movzx   eax,es:[edx].DEVBMP.Dibeng.deWidthBytes
        movzx   edx,es:[edx].DEVBMP.Dibeng.deHeight
        add     eax,3
        and     eax,NOT 3
        imul    eax,edx
        add     eax,SIZE DEVBMP
        cmp     ebx,eax
        jae     @F

Fail:
        sub     eax,eax
@@:
        POPR    es
CLOSEPROC


;==============================================================================
;
; Function:     GN_FlushOffscreenBitmap
;
; Purpose:      This routine will copy an offscreen bitmap into
;               its system memory backup region and adjust the
;               bitmap header appropriately to point to the new
;               location of the bitmap data. The offscreen
;               memory used by the bitmap is freed.
;
; Arguments:    es:esi  ptr to DEVBMP.
;               The bitmap header MUST be valid. No
;               validity checking is performed in here.
;
; Returns:      None
;
; Preserve:     ds,es,gs,esi,edi
;==============================================================================
DECPROC GN_FlushOffscreenBitmap, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,esi,edi,gs

        ; The deDeltaScan of the new system memory copy is always
        ; (deWidthBytes + 3) AND NOT 3 -- the DIBENG assumes this.
        movzx   eax,es:[esi].DEVBMP.Dibeng.deWidthBytes
        mov     edx,es:[esi].DEVBMP.Dibeng.deDeltaScan
        add     eax,3
        and     eax,NOT 3

        ; Compute the dst wrap width and load up src and dst ptrs
        sub     edx,eax
        shr     eax,2
        mov     edi,SIZE DEVBMP
        movzx   ebx,es:[esi].DEVBMP.Dibeng.deHeight
	;--->
	push	esi
        lds     esi,fword ptr es:[esi].DEVBMP.Dibeng.deBitsOffset

        ; Copy the bitmap from offscreen to system memory area
@@:     mov     ecx,eax
        rep     movs dword ptr es:[edi], ds:[esi]
        add     esi,edx
        dec     ebx
        jne     @B

	pop	edi
	;<---

        ; Now we need to delete the offscreen bitmap which will
        ; cause the offscreen memory allocated for it to be released.
        mov     ds,cs:[wFlatDataSel]
        mov     esi,cs:[CSpGNLogicalDevice]
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
	pushd	0
        call    GN_OffscreenBitmapDelete

        ; The DeltaScan and bits ptrs in the bitmap should now be
        ; updated to reflect the new location and bitmap pitch.
        movzx   eax,es:[edi].DEVBMP.Dibeng.deWidthBytes
        add     eax,3
        and     eax,NOT 3
        mov     es:[edi].DIBENGINE.deDeltaScan,eax
        mov     eax,SIZE DEVBMP
        mov     es:[edi].DIBENGINEHDR.deBitsOffset,eax
        mov     es:[edi].DIBENGINEHDR.deBitsSelector,es

        ; Since the bitmap is now in system memory, clear
        ; the offscreen flags and the access routines.
        sub     eax,eax
        and     es:[edi].DIBENGINEHDR.deFlags,NOT (VRAM OR OFFSCREEN)
        mov     es:[edi].DIBENGINEHDR.deBeginAccess,eax
        mov     es:[edi].DIBENGINEHDR.deEndAccess,eax
        POPR    ds,esi,edi,gs
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\gnpower.asm ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnpower.asm
;
; Purpose:      This file holds the routines dealing with power management support.
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

IFDEF DEBUG
szPowerOn       DB      'DISPLAY:GN_PowerOn',0DH,0AH,0
szPowerOff      DB      'DISPLAY:GN_PowerOff',0DH,0AH,0
ENDIF

;==============================================================================
;
; Function:     GN_PowerOn
;
; Purpose:      This function gets called from minivdd when
;               we are going to resume from powerdown.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     All registers must be preserved
;==============================================================================
DECPROC GN_PowerOn, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi

IFDEF DEBUG
        mov     ax,cs
        shl     eax,10H
        lea     ax,szPowerOn
        push    eax
        call    GENERIC_OutputDebugString
ENDIF

        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]

        ; Send a message down the chain
        push    esi
        pushd   MSG_POWERON
        push    esi                             ; CX ptr to DIBENGINEHDR
        push	CSlp16LogDevice_In_NVTEXT16	; 16:16 ptr to DIBENGINEHDR
        call    GN_LogdevMessage

        mov     ds:[esi].GNLOGDEVCX.bSetModeBypass,0

        ; Do the Enable Device.
        sub     eax,eax
        push    CSlp16LogDevice_In_NVTEXT16
        push    ax
        push    eax
        push    eax
        inc     eax
        push    eax
        call    GENERIC_Enable

        mov     ds:[esi].GNLOGDEVCX.bSetModeBypass,1

        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_PowerOff
;
; Purpose:      This function gets called from minivdd when
;               we are going to resume from powerdown.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     All registers must be preserved
;==============================================================================
DECPROC GN_PowerOff, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi

IFDEF DEBUG
        mov     ax,cs
        shl     eax,10H
        lea     ax,szPowerOff
        push    eax
        call    GENERIC_OutputDebugString
ENDIF

        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]

        ;Check for power call after INT2F
        inc     ds:[esi].GNLOGDEVCX.dwInt2FScreenSwitchOut
        cmp     ds:[esi].GNLOGDEVCX.dwInt2FScreenSwitchOut,2
        jge     @F

        ; Send a message down the chain
        push    esi
        pushd   MSG_POWEROFF
        push    esi                             ; CX ptr to DIBENGINEHDR
        push	CSlp16LogDevice_In_NVTEXT16	; 16:16 ptr to DIBENGINEHDR
        call    GN_LogdevMessage

        push    esi
        call    GN_BlankScreen

@@:
        POPR    ds,esi,edi
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNPALET.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnsetpal.asm
;
; Purpose:      This file holds the SetPalette, SetPaletteTranslate, and
;               the UpdateColors display driver entry points.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_SetPalette
;
; Purpose:      This function is the SetPalette display driver entry point.
;
; Arguments:    SetPalette Display Driver Stack Frame
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_SetPalette, PASCAL, FRAME, FAR16
PARMW   wStartIndex
PARMW   wNumEntries
PARMD   lpPalette
LOCALD  dwCRTCCount
LOCALD  pPalette
OPENPROC
        PUSHR   ds,esi,edi
		jmp		GN_SetPalette
GENERIC_SetPalette	ENDP

;==============================================================================
PUBLIC	GN_SetPaletteExit
GN_SetPaletteExit PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 08H
GN_SetPaletteExit ENDP

;==============================================================================
PUBLIC	GN_SetPalette
GN_SetPalette	PROC	NEAR

        ; Load up the GNLOGDEVCX
        mov     ds,cs:[wFlatDataSel]
        mov     esi,cs:[CSpGNLogicalDevice]

        ; See if screen is busy
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
		jne		GN_SetPalettePunt

        ; Get a flat ptr to the gamma ramp
        movzx   eax,word ptr lpPalette+2
        push    eax
        call    GN_GetSelectorBase
        movzx   edx,word ptr lpPalette+0
        add     eax,edx
        mov     pPalette,eax

        ; Copy the palette given into the GNLOGDEVCX palette.
        ; We need to maintain this for the DIBENGINE.
        ; We have to swap red and blue
        movzx   eax,wStartIndex
        movzx   ecx,wNumEntries
        mov     edi,pPalette
        lea     ebx,[esi][eax * 4].GNLOGDEVCX.dwPalette
@@:
        mov     eax,ds:[edi]
        add     edi,4
        bswap   eax
        ror     eax,8
        mov     ds:[ebx],eax
        add     ebx,4
        dec     ecx
        jne     @B

        ; Run through all the CRTCs attached to this logical device
        ; and program them all.
        mov     dwCRTCCount,0
        lea     edi,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        lea     ebx,[esi].GNLOGDEVCX.dwPalette
        mov     pPalette,ebx

Loopit3:
        ; Now call to set the palette on this DAC
        cmp     dword ptr ds:[edi],0
        je      @F
        push    dword ptr ds:[edi]
        push    pPalette
        movzx   eax,wStartIndex
        push    eax
        movzx   eax,wNumEntries
        push    eax
        call    GN_SetCrtcPalette
@@:
        add     edi,4
        inc     dwCRTCCount
        mov     eax,dwCRTCCount
        cmp     eax,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      Loopit3
		jmp		GN_SetPaletteExit
GN_SetPalette	ENDP

PUBLIC  GN_SetPalettePunt
GN_SetPalettePunt	PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
        pop     eax
        push    cs:[CSlp16LogDevice]
        push    eax
        jmp     DIB_SetPaletteExt
GN_SetPalettePunt	ENDP


;==============================================================================
;
; Function:     GENERIC_SetPaletteTranslate
;
; Purpose:      This function is the SetPaletteTranslate display driver
;               entry point.
;
; Arguments:    SetPaletteTranslate Display Driver Stack Frame
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_SetPaletteTranslate, PASCAL, FRAME, FAR16
PARMD   lpTranslate
OPENPROC
        PUSHR   ds,esi,edi

        ; Call the DIBENG to do what it needs to do
        push    lpTranslate
        push    cs:[CSlp16LogDevice]
        call    DIB_SetPaletteTranslateExt

        ; If we are in a palettized mode then handle the xlat table
        mov     ds,cs:[wFlatDataSel]
        mov     esi,cs:[CSpGNLogicalDevice]
        test    ds:[esi].GNLOGDEVCX.Dibeng.deFlags,PALETTIZED
        jz      done

        ; Load up a few things and break into identity/non-identity cases
        sub     eax,eax
        lea     ebx,[esi].GNLOGDEVCX.bPaletteXlatTable
        lea     edi,[esi].GNLOGDEVCX.bPaletteInverseXlatTable
        mov     ecx,0FFH
        cmp     eax,lpTranslate
        je      isID

        ; There is an xlat table that is not the identity
        or      ds:[esi].GNLOGDEVCX.Dibeng.deFlags,PALETTE_XLAT
        sub     edx,edx
        les     dx,lpTranslate
@@:
        mov     al,es:[edx][ecx * 2]
        mov     ds:[ebx][ecx],al
        mov     ds:[edi][eax],cl
        dec     ecx
        jns     @B
        jmp     done

        ; The xlat table is NULL -- set the identity translate table
isID:
        mov     ds:[ebx][ecx],cl
        mov     ds:[edi][eax],cl
        dec     ecx
        jns     isID
        and     ds:[esi].GNLOGDEVCX.Dibeng.deFlags,NOT PALETTE_XLAT

done:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GENERIC_UpdateColors
;
; Purpose:      This function is the UpdateColors display driver entry point.
;
; Arguments:    UpdateColors Display Driver Stack Frame
;
; Returns:      None
;
;==============================================================================
DECPROC GENERIC_UpdateColors, PASCAL, FRAME, FAR16
PARMW   wStartX
PARMW   wStartY
PARMW   wExtX
PARMW   wExtY
PARMD   lpTranslate

LOCALD  lpBmp
LOCALD  lpBits
OPENPROC
        PUSHR   ds,esi,edi
	jmp	GN_UpdateColors
GENERIC_UpdateColors	ENDP

;==============================================================================
PUBLIC	GN_UpdateColorsExit
GN_UpdateColorsExit PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 0CH
GN_UpdateColorsExit ENDP

;==============================================================================
PUBLIC	GN_UpdateColors
GN_UpdateColors	PROC	NEAR
	sub	ebx,ebx
	mov	lpBmp,ebx
        ; Load up the DstDev for dispatching
        mov     ds,cs:[wFlatDataSel]
        mov     esi,cs:[CSpGNLogicalDevice]

        cmp	ds:[esi].GNLOGDEVCX.Dibeng.bRealBpp,8
	jne	GN_UpdateColorsPunt

        ; See if screen is busy
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
	jne	GN_UpdateColorsPunt

	;Ask memory size for shadow bitmap
	push	cs:[CSlp16LogDevice]
	push	word ptr 5					;OBJ_BITMAP
	push	cs:[CSlp16LogDevice]
	push	ebx
	push	ebx
	push	cs:[CSlp16LogDevice]
	call	DIB_RealizeObjectExt
	or	eax,eax
	jz	GN_UpdateColorsPunt

	;Allocate shadow memory
	call	GN_MemoryAlloc
	or	eax,eax
	jz	GN_UpdateColorsPunt
	shl	eax,10H
	mov	lpBmp,eax
	mov	edi,GN_UpdateColorsPunt

	;Create shadow bitmap in system memory
	sub	ebx,ebx
	push	cs:[CSlp16LogDevice]
	push	word ptr 5					;OBJ_BITMAP
	push	cs:[CSlp16LogDevice]
	push	lpBmp
	push	ebx
	push	cs:[CSlp16LogDevice]
	call	DIB_RealizeObjectExt
	or	eax,eax
	jz	FreeRes

	sub	ebx,ebx
	mov	es,word ptr lpBmp+2
	movzx	eax,word ptr es:[ebx].DIBENGINE.deBits+4
	shl	eax,10H
	mov	ax,word ptr es:[ebx].DIBENGINE.deBits
	mov	lpBits,eax

	;Copy screen --> shadow
        push    cs:[CSpGNLogicalDevice]
        push    lpBmp
        push    ebx
	movzx   eax,word ptr lpBits+2
        mov	ecx,8						;Bpp
        push    eax
	movzx   eax,word ptr lpBits
        push    eax
        push    ecx
        movzx	eax,es:[ebx].DIBENGINE.deWidthBytes
        push    eax
        movzx	eax,wStartX
        push    eax
        movzx	eax,wStartY
        push    eax

        push    ebx						;lpSrcDev
        movzx   eax,word ptr ds:[esi].GNLOGDEVCX.Dibeng.deBitsSelector
        push    eax
        push    dword ptr ds:[esi].GNLOGDEVCX.Dibeng.deBitsOffset
        push    ecx
        push    ds:[esi].GNLOGDEVCX.Dibeng.deDeltaScan
        movzx	eax,wStartX
        push    eax
        movzx	eax,wStartY
        push    eax
        movzx   eax,wExtX
        push    eax
        movzx   eax,wExtY
        push    eax
        mov     ecx,0CC0000H
        push    ecx
        push    ebx
        push    ebx
        movzx   ebx,cs:bTableBppToIndex[8]
	mov	edx,ebx
        imul    ebx,MAX_BPP_INDICES
        add     ebx,edx
        mov     ecx,cs:dwTableBppToXlatFunc[ebx * 4]
	push	ecx
        call    GN_BitBltSrcVramDstSystem
        or      eax,eax
        jbe	FreeRes

	;Copy shadow <-- screen
        mov     ds,cs:[wFlatDataSel]
        sub     ebx,ebx
        push    cs:[CSpGNLogicalDevice]
        movzx   eax,word ptr ds:[esi].GNLOGDEVCX.Dibeng.deBitsSelector
        mov	ecx,8						;Bpp
        push    eax
        push    dword ptr ds:[esi].GNLOGDEVCX.Dibeng.deBitsOffset
        push    ecx
        push    ds:[esi].GNLOGDEVCX.Dibeng.deDeltaScan
        movzx	eax,wStartX
        push    eax
        movzx	eax,wStartY
        push    eax
        movzx   eax,word ptr lpBits+2
        movzx	ecx,word ptr lpBits+0
        push    eax
        push    ecx
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deBitsPixel
        movzx	ecx,ds:[esi].GNLOGDEVCX.Dibeng.deWidthBytes
        push    eax
        push    ecx
        movzx	eax,wStartX
        push    eax
        movzx	eax,wStartY
        push    eax
        movzx   eax,wExtX
        push    eax
        movzx   eax,wExtY
        push    eax
        mov     ecx,0CC0000H
        push    ecx
        push    ebx						;lpBrush
        push    ebx						;lpDrawMode
        push    2						;size color table entry in bytes
        push    100H						;num color table entries
        push    lpTranslate					;lpColorTable
        push    ebx
        call    GN_BitBltSrcColorDstVram
        or      eax,eax
        jbe	FreeRes
	mov	edi,GN_UpdateColorsExit

FreeRes:
	;Delete shadow bitmap if exist
	mov	eax,lpBmp
	or	eax,eax
	je	JustFreeMem
        sub     ebx,ebx
	push	cs:[CSlp16LogDevice]
	push	word ptr -5					;-OBJ_PBITMAP
	push	eax
	push	ebx
	push	ebx
	push	cs:[CSlp16LogDevice]
	call	DIB_RealizeObjectExt

JustFreeMem:
	;Free shadow memory
	mov	eax,lpBmp
	shr	eax,10H
	call	GN_MemoryFree
	mov	eax,1
	jmp	edi
GN_UpdateColors	ENDP

PUBLIC  GN_UpdateColorsPunt
GN_UpdateColorsPunt PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
        pop     eax
        push    cs:[CSlp16LogDevice]
        push    eax
PLABEL	Punt_UpdateColors
        jmp     DIB_UpdateColorsExt
GN_UpdateColorsPunt	ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\gnpanel.asm ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation
;
; File:         gnpanel.asm
;
; Purpose:      This file holds the Control Panel interface as
;               implemented through the display driver escapes.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc
include valmode.inc
include escape.inc
include tvout.inc
include modeext.inc

IF      ((MAX_DISP_CONFIG * 4) LT (SIZE NVTWINVIEW_DISPLAY_CONFIG))
        echo MAX_DISP_CONFIG is less than NVTWINVIEW_DISPLAY_CONFIG
        echo Make MAX_DISP_CONFIG in gnlogdev.h bigger
        .err
ENDIF

CONTROL_FRAME_AND_LOCALS        MACRO
PARMD   pGNLogdevCXOffset
PARMD   lpDstDev
PARMW   wFunction
PARMD   lpIn
PARMD   lpOut
LOCALD  dwRequestedDeviceType
LOCALD  dwRequestedTVFormat
LOCALD  dwSizeEdidBuffer
LOCALS  sLocalEdidBuffer,512
LOCALD  dwCRTCCount
LOCALS  LocalDevData,MAX_ATTACHED_CRTCS*4
LOCALD  lpLocalDevData
LOCALS  aHWCrtcCX,MAX_ATTACHED_CRTCS*4
LOCALD  lpHWCrtcCX
LOCALS  aGNCrtcCX,MAX_ATTACHED_CRTCS*4
LOCALD  lpGNCrtcCX
LOCALD  dwDeviceCount
LOCALD  dwDevicesChanged
LOCALD  OldCrtcDevData
LOCALD  dwDevDataMask
LOCALD  dwMaxMonitors
LOCALD  dwMonitorNum
LOCALD  dwLocalDeviceMask
LOCALD  pGNLogdevCXUsingTheHead
LOCALD  pGNCrtcCXUsingTheHead
LOCALD  pHWCrtcCXUsingTheHead
LOCALD  dwLogCrtcIndex
LOCALD  lpDesktopModeInfo
LOCALD  lpModeInfo
LOCALV  sDesktopModeInfo,MODEINFO
LOCALV  sModeInfo,MODEINFO
LOCALV  sModeOut,MODEOUT
LOCALV  sSettableModeInfo,MODEINFO
LOCALS  aGammaTable,400H
LOCALW  wClone
ENDM

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     ControlPanelInterface
;
; Purpose:      This function is the Control Panel interface to the
;               display driver. We will only get here if a Control
;               panel escape is issued to the display driver.
;
; Arguments:    Control Display Driver Stack Frame
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC ControlPanelInterface, PASCAL, FRAME, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        PUSHR   ds,esi,edi

        sub     ecx,ecx
        movzx   eax,wFunction
        cmp     eax,NV_ESC_SETGET_TWINVIEW_DATA
        jne     Done

        push    OFFSET ReturnAddr
        mov     esi,pGNLogdevCXOffset
        sub     edi,edi
        les     di,lpOut
        mov     eax,es:[edi].NVTWINVIEWDATA.dwAction

        cmp     eax,NVTWINVIEW_ACTION_SETGET_STATE
        je      NV_SetGet_State
        cmp     eax,NVTWINVIEW_ACTION_SETGET_DEVICE_TYPE
        je      NV_SetGet_Device_Type
        cmp     eax,NVTWINVIEW_ACTION_SETGET_VIRTUALDESKTOP
        je      NV_SetGet_VirtualDesktop
        cmp     eax,NVTWINVIEW_ACTION_SETGET_FREEZE_ORIGIN
        je      NV_SetGet_Freeze_Origin
        cmp     eax,NVTWINVIEW_ACTION_SETGET_VIRTUAL_MODE
        je      NV_SetGet_VirtualMode
        cmp     eax,NVTWINVIEW_ACTION_SETGET_PHYSICAL_MODE
        je      NV_SetGet_PhysicalMode
        cmp     eax,NVTWINVIEW_ACTION_VALIDATE_VIRTUAL_MODE
        je      NV_ValidateVirtualMode
        cmp     eax,NVTWINVIEW_ACTION_VALIDATE_PHYSICAL_MODE
        je      NV_ValidatePhysicalMode
        cmp     eax,NVTWINVIEW_ACTION_SETGET_TIMING_OVERRIDE
        je      NV_SetGet_Timing_Override
        cmp     eax,NVTWINVIEW_ACTION_SETGET_CLONE_GAMMA
        je      NV_SetGetCloneGamma
        cmp     eax,NVTWINVIEW_ACTION_ROTATE_CLONE_DEVICES
        je      GN_RotateCloneDevices
        cmp     eax,NVTWINVIEW_ACTION_LOCK_HWCRTC
        je      GN_LockHWCrtcOnHead
        cmp     eax,NVTWINVIEW_ACTION_UNLOCK_HWCRTC
        je      GN_UnlockHWCrtcOnHead
        cmp     eax,NVTWINVIEW_ACTION_SETGET_PHYSICAL_MODE_IMMEDIATE
        je      GN_SpecialSetPhysicalMode
        cmp     eax,NVTWINVIEW_ACTION_MAP_LOG_TO_PHYS_HEAD
        je      GN_MapLogToPhysHead
        cmp     eax,NVTWINVIEW_ACTION_SETGET_DISPLAY_CONFIG
        je      GN_SetGetDisplayConfig
        cmp     eax,NVTWINVIEW_ACTION_GET_LARGEST_EDID_MODE
        je      GN_GetBiggestEdidMode

        add     sp,@WordSize
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,0
        sub     ecx,ecx
        jmp     Done

ReturnAddr:
Done:
        mov     eax,1
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_SetGet_State
;
; Purpose:      This function gets or sets the desktop state.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;               es:edi          NVTWINVIEWDATA
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:
;==============================================================================
DECPROC NV_SetGet_State, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     ax,ss
        shl     eax,10H
        lea     ax,LocalDevData
        mov     lpLocalDevData,eax
        lea     ax,aHWCrtcCX
        mov     lpHWCrtcCX,eax

        sub     edi,edi
        les     di,lpOut

        ; Let's get the current state first!
        mov     eax,NVTWINVIEW_STATE_CLONE
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,1
        ja      @F
        mov     eax,NVTWINVIEW_STATE_MULTIMON
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        cmp     ds:[ebx].GNBOARDCX.dwLogicalDeviceInstancesOnThisBoard,1
        ja      @F
        mov     eax,NVTWINVIEW_STATE_NORMAL
@@:
        mov     edx,es:[edi].NVTWINVIEWDATA.dwFlag
        cmp     edx,NVTWINVIEW_FLAG_GET
        jne     SetState

GetState:
        ; We got it and we're done!
        mov     es:[edi].NVTWINVIEWDATA.dwState,eax
        mov     eax,1
        jmp     Done

SetState:
        cmp     eax,NVTWINVIEW_STATE_NORMAL
        je      CurrentNormal
        cmp     eax,NVTWINVIEW_STATE_CLONE
        je      CurrentClone
        mov     eax,NVTWINVIEW_STATE_CHANGE_FAILED
        jmp     Done

CurrentNormal:
        cmp     es:[di].NVTWINVIEWDATA.dwState,NVTWINVIEW_STATE_NORMAL
        je      NoChange

        ; OK, normal->clone means we attach a crtc
        ; The caller will issue a ChangeDisplaySettings after we return
        push    esi
        call    GN_LogdevAddAClone
        mov     eax,NVTWINVIEW_STATE_CLONE
        mov     ds:[esi].GNCRTCCX.dwDisplayDeviceChange,1
        jmp     WriteItOut

CurrentClone:
        cmp     es:[di].NVTWINVIEWDATA.dwState,NVTWINVIEW_STATE_CLONE
        je      NoChange

        ; Clear panning flag to prevent the next clone limitation
        mov     edi,1
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]

        push    ds:[ebx].GNCRTCCX.lpBoardRegistryData
        push    ds:[ebx].GNCRTCCX.lpCrtcModeInfo
        pushd   0
        CALLFAR16IND lpfnSetClonePanningFlag,es,ax

        ; Save last mode for this device
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    ds:[ebx].GNCRTCCX.lpBoardRegistryData
        push    ds:[ebx].GNCRTCCX.lpCrtcModeInfo
        CALLFAR16IND lpfnSetDeviceDisplayMode,es,ax

        ; Clone->Normal means we detach a CRTCCX.
        ; The caller will issue a ChangeDisplaySettings after we return
        push    esi
        push    edi
        call    GN_LogdevDetachCrtc
        mov     eax,NVTWINVIEW_STATE_NORMAL

WriteItOut:
        ; The change succeeded -- write out the new state
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    eax
        CALLFAR16IND lpfnSetDesktopState,es,ax
        
        mov     ds:[esi].GNLOGDEVCX.dwNvDisplayChangePending,1

NoChange:
        mov     eax,NVTWINVIEW_STATE_CHANGE_DONE

Done:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_SetGet_Device_Type
;
; Purpose:      This function is the Control Panel interface to the
;               display driver. We will only get here if a Control
;               panel escape is issued to the display driver.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;               es:edi          NVTWINVIEWDATA
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:
;==============================================================================
DECPROC NV_SetGet_Device_Type, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     eax,eax

        ; Determine the correct CRTC to address
        mov     edx,es:[edi].NVTWINVIEWDATA.dwCrtc
        cmp     edx,ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        jae     WriteRegistry

        ; Get the CRTC context ptr
        lea     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     esi,ds:[ecx][edx * 4]
        or      esi,esi
        je      DoneIt

        mov     edx,es:[edi].NVTWINVIEWDATA.dwFlag
        cmp     edx,NVTWINVIEW_FLAG_GET
        jne     NV_SetDisplayDeviceType
        jmp     NV_GetDisplayDeviceType

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IDEBUG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; HACK!!!
; JKTODO - Jim, Sorry about this, but it was the only solution I could
;          come up with given the current time constraints. We can talk
;          about this further.
WriteRegistry:
        ; If we are in Normal Mode, and a request is coming in to write
        ; logical head 1 then write the registry with the new display
        ; device to LogicalDevice0 PhysicalDevice1.
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,1
        ja      DoneIt
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        cmp     ds:[ebx].GNBOARDCX.dwLogicalDeviceInstancesOnThisBoard,1
        ja      DoneIt
        
        ; We are in normal mode. Check if we are being asked to write
        ; logical device 1.
        cmp     es:[edi].NVTWINVIEWDATA.dwCrtc,1
        jne     DoneIt

        ; Get the type of device we are pointing to
        ; and convert it to the DEVTYPE_XXX type list.
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceType
        call    HW_MapHWDeviceTypeToGNDeviceType
        mov     (DEVDATA PTR LocalDevData).cType,cl

        ; Map the RM TvFormat to the NVmode Tvformat
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwTVFormat
        call    HW_MapHWTvFormatToGNTvFormat
        mov     (DEVDATA PTR LocalDevData).cFormat,cl

        ; Assume device number 0 for now
        mov     (DEVDATA PTR LocalDevData).cNumber,0

        ; Write this out to the registry.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        mov     eax,0
        push    eax
        inc     eax
        push    eax
        mov     ax,ss
        shl     eax,10h
        lea     ax,LocalDevData
        push    eax
        CALLFAR16IND lpfnSetDisplayDevice,es,ax

        mov     eax,1                   ; return success
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   

DoneIt:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_SetDisplayDeviceType
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is NV_ESC_SET_DISPLAY_DEVICE_TYPE.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNCRTCCX
;               es:edi          NVTWINVIEWDATA
;
; Returns:      ecx             1
;               eax             1
;
; Preserve:
;==============================================================================
DECPROC NV_SetDisplayDeviceType, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     ax,ss
        shl     eax,10H
        lea     ax,LocalDevData
        mov     lpLocalDevData,eax
        lea     ax,aHWCrtcCX
        mov     lpHWCrtcCX,eax
        lea     ax,aGNCrtcCX
        mov     lpGNCrtcCX,eax

        ; Get the type of device we are pointing to
        ; and convert it to the DEVTYPE_XXX type list.
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceType
        call    HW_MapHWDeviceTypeToGNDeviceType
        mov     (DEVDATA PTR LocalDevData).cType,cl
        cmp     cl,DEVTYPE_TV
        mov     cl,0
        jne     @F

        ; Map the RM TvFormat to the NVmode Tvformat
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwTVFormat
        call    HW_MapHWTvFormatToGNTvFormat
@@:
        mov     (DEVDATA PTR LocalDevData).cFormat,cl

        ; Get the device number.
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceMask
        sub     ecx,ecx

Find_Device_Number:     
        test    eax,1
        jz      @F
        mov     ch,cl
        and     ch,07H
        jmp     Got_Device_number
        
@@:     inc     cl
        shr     eax,1
        cmp     cl,18H
        jc      Find_Device_Number
        
        mov     ch,0
        
Got_Device_number:
        mov     (DEVDATA PTR LocalDevData).cNumber,ch

        ; Save off the old device data
        push    esi
        call    GN_GetDevData
        mov     OldCrtcDevData,eax

        ; Temporarily set the new device
        push    esi
        push    dword ptr LocalDevData
        call    GN_SetDevData

        mov     edi,pGNLogdevCXOffset

        ; Make sure that the device desired by this CRTC is not
        ; in use by any other active CRTCCX on the board.
        push    ds:[edi].GNLOGDEVCX.pGNBoardCX
        push    esi
        call    GN_IsDevDataUniqueOnBoard
        or      eax,eax
        je      DeviceInUse

        ; OK, sure it's unique, but is the device connectable to some
        ; head? (any head - it doesn't matter right now which one.)
        mov     ecx,ds:[edi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ecx].GNBOARDCX.pHWBoardCX
        push    dword ptr LocalDevData
        call    HW_IsDeviceAttached
        or      eax,eax
        je      DeviceNotAttached

        ; OK, we have a unique device (from the others in use)
        ; that is connected to the system. Now can we find an
        ; arrangment whereby this device can be used?
        push    ds:[edi].GNLOGDEVCX.pGNBoardCX
        push    lpLocalDevData
        push    lpGNCrtcCX
        push    lpHWCrtcCX
        pushd   MAX_ATTACHED_CRTCS
        call    GN_GetAllDeviceData
        mov     dwDeviceCount,eax

        ; Ask the hardware if it is possible to have all the
        ; devices specified enabled simultaneously by assigning
        ; each to a different head.
        mov     ecx,ds:[edi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ecx].GNBOARDCX.pHWBoardCX
        push    lpLocalDevData
        push    dwDeviceCount
        call    HW_CanDevicesBeMapped
        or      eax,eax
        je      AssignmentNotPossible

        ; Don't bother and try to read the edid on a tv
        mov     ds:[esi].GNCRTCCX.dwEdidSize,0
        cmp     (DEVDATA PTR LocalDevData).cType,DEVTYPE_TV
        je      DoneEdidRead

        ; Read the EDID for this device if it has an EDID
        mov     ds:[esi].GNCRTCCX.dwEdidSize,MAX_EDID_BUFFER_SIZE
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        push    dword ptr LocalDevData
        mov     ax,ds
        push    eax
        call    GN_GetSelectorBase
        lea     ecx,ds:[esi].GNCRTCCX.sEdidBuffer
        add     ecx,eax
        push    ecx
        lea     ecx,ds:[esi].GNCRTCCX.dwEdidSize
        add     ecx,eax
        push    ecx
        call    HW_ReadEdid

        ; Set a flag in this CRTCCX that this is a display device
        ; change
        mov     ds:[esi].GNCRTCCX.dwDisplayDeviceChange,1

DoneEdidRead:
        ; The caller will issue a ChangeDisplaySettings after we return
        mov     eax,1
        jmp     DoneIt

AssignmentNotPossible:
DeviceNotAttached:
DeviceInUse:
        ; Restore the old dev data
        push    esi
        push    dword ptr OldCrtcDevData
        call    GN_SetDevData
        sub     eax,eax

DoneIt:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetDisplayDeviceType
;
; Purpose:      This function gets called from GENERIC_Control when
;               the escape value is NV_ESC_GET_DISPLAY_DEVICE_TYPE.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNCRTCCX
;               es:edi          NVTWINVIEWDATA
;
; Returns:      eax             1
;               ecx             1
;
; Preserve:
;==============================================================================
DECPROC NV_GetDisplayDeviceType, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        lea     ebx,[esi].GNCRTCCX.sCrtcModeInfo
        movzx   ecx,(DEVDATA PTR ds:[ebx].MODEINFO.MIDevData).cType
        call    HW_MapGNDeviceTypeToHWDeviceType
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceType,ecx
        lea     ebx,[esi].GNCRTCCX.sCrtcModeInfo
        movzx   ecx,(DEVDATA PTR ds:[ebx].MODEINFO.MIDevData).cFormat
        call    HW_MapGNTvFormatToHWTvFormat
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwTVFormat,ecx

        ; Create the bitmask for the display type and number.
        lea     ebx,[esi].GNCRTCCX.sCrtcModeInfo
        mov     cl,(DEVDATA PTR ds:[ebx].MODEINFO.MIDevData).cType
        shl     cl,3
        mov     eax,1
        shl     eax,cl
        mov     cl,(DEVDATA PTR ds:[ebx].MODEINFO.MIDevData).cNumber
        shl     eax,cl
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceMask,eax

        mov     eax,1
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_SetGet_VirtualDesktop
;
; Purpose:      This function is for setting or getting the state of the
;               virtual desktop. Panning is only possible if the virtual
;               desktop is enabled.
;
; Arguments:    Control Display Driver Stack Frame
;               ds      Context selector
;               esi     GNLOGDEVCX ptr
;               es:edi  NVTWINVIEWDATA
;
; Returns:      ecx     1
;               eax     0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_SetGet_VirtualDesktop, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     edx,es:[edi].NVTWINVIEWDATA.dwFlag
        cmp     edx,NVTWINVIEW_FLAG_GET
        jne     SetAutoPan

        mov     eax,ds:[esi].GNLOGDEVCX.dwVirtualDesktopEnabled
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwvirtualdesktopdata.dwVirtualDesktop,eax
        jmp     Done

SetAutoPan:
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwvirtualdesktopdata.dwVirtualDesktop
        mov     ds:[esi].GNLOGDEVCX.dwVirtualDesktopEnabled,eax

        ; Write this out to the registry.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        push    ds:[esi].GNLOGDEVCX.dwLogicalDeviceInstanceOnThisBoard
        push    eax
        CALLFAR16IND lpfnSetVirtualDesktop,es,ax
Done:
        sub     edi,edi
        les     di,lpOut
        mov     eax,1
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_SetGet_VirtualMode
;
; Purpose:      This function writes/reads the virtual mode for the
;               desktop to/from the registry.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               es:edi          NVTWINVIEWDATA
;               esi             GNLOGDEVCX ptr
;
; Returns:      ecx     1
;               eax     0 failure
;                       1 success
;
; Preserve:
;==============================================================================
DECPROC NV_SetGet_VirtualMode, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; I need to do this regarless of get or set
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceType
        call    HW_MapHWDeviceTypeToGNDeviceType
        mov     (DEVDATA PTR sModeInfo.MIDevData).cType,cl
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwTVFormat
        call    HW_MapHWTvFormatToGNTvFormat
        mov     (DEVDATA PTR sModeInfo.MIDevData).cFormat,cl

        ; Get the device number.
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceMask
        sub     ecx,ecx

Find_Device_Number:     
        test    eax,1
        jz      @F
        mov     ch,cl
        and     ch,07H
        jmp     Got_Device_number
        
@@:     inc     cl
        shr     eax,1
        cmp     cl,18H
        jc      Find_Device_Number
        
        mov     ch,0
        
Got_Device_number:
        mov     (DEVDATA PTR sModeInfo.MIDevData).cNumber,ch

        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetCloneDesktopSelection,es,ax
        mov     wClone,ax

        sub     edi,edi
        les     di,lpOut

        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     edx,es:[edi].NVTWINVIEWDATA.dwFlag
        cmp     edx,NVTWINVIEW_FLAG_GET
        je      GetVirt

SetVirt:
        ; Get the Twinview data into a MODEINFO structure
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes
        mov     sModeInfo.dwXRes,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes
        mov     sModeInfo.dwYRes,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp
        mov     sModeInfo.dwBpp,eax

        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        push    eax
        cmp     wClone,1
        mov     eax,0
        jne     @F
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,2
        jl      @F
        mov     eax,1
@@:     push    eax     
        CALLFAR16IND lpfnSetDeviceDesktopMode,es,ax
        jmp     DoneIt

GetVirt:
        ; What device is he asking about?
        mov     eax,dword ptr sModeInfo.MIDevData
        lea     ecx,[ebx].GNCRTCCX.sCrtcModeInfo
        xor     eax,ds:[ecx].MODEINFO.MIDevData
        and     eax,0FFFFFFFFH
        jne     NotCurrent

UseCurrent:
        ; He is asking about the current device
        sub     edi,edi
        les     di,lpOut
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes,eax
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes,eax
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deBitsPixel
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp,eax
        jmp     DoneIt

NotCurrent:
        ; Read the registry for the virtual desktops of devices that
        ; are not currently active
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        push    eax
        cmp     wClone,1
        mov     eax,0
        jne     @F
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,2
        jl      @F
        mov     eax,1
@@:     push    eax     
        CALLFAR16IND lpfnGetDeviceDesktopMode,es,ax
        or      ax,ax
        je      UseCurrent

        ; Copy the data back from our MODEINFO to the Twinview struct
        sub     edi,edi
        les     di,lpOut
        mov     eax,sModeInfo.dwXRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes,eax
        mov     eax,sModeInfo.dwYRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes,eax
        mov     eax,sModeInfo.dwBpp
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp,eax

DoneIt:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_SetGet_PhysicalMode
;
; Purpose:      This function writes/reads the physical mode for a
;               specific CRTC to/from the registry.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               es:edi          NVTWINVIEWDATA
;               esi             GNLOGDEVCX ptr
;
; Returns:      ecx     1
;               eax     0 failure
;                       1 success
;
; Preserve:
;==============================================================================
DECPROC NV_SetGet_PhysicalMode, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Determine the correct CRTC to address
        sub     eax,eax
        mov     edx,es:[edi].NVTWINVIEWDATA.dwCrtc
        cmp     edx,ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        jae     DoneIt

        ; Get the CRTC context ptr
        lea     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     esi,ds:[ebx][edx * 4]
        or      esi,esi
        je      DoneIt

        ; I need to do this regardles of set or get
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceType
        call    HW_MapHWDeviceTypeToGNDeviceType
        mov     (DEVDATA PTR sModeInfo.MIDevData).cType,cl
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwTVFormat
        call    HW_MapHWTvFormatToGNTvFormat
        mov     (DEVDATA PTR sModeInfo.MIDevData).cFormat,cl

        ; Get the device number.
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceMask
        sub     ecx,ecx

Find_Device_Number:     
        test    eax,1
        jz      @F
        mov     ch,cl
        and     ch,07H
        jmp     Got_Device_number
        
@@:     inc     cl
        shr     eax,1
        cmp     cl,18H
        jc      Find_Device_Number
        
        mov     ch,0
        
Got_Device_number:
        mov     (DEVDATA PTR sModeInfo.MIDevData).cNumber,ch

        mov     edx,es:[edi].NVTWINVIEWDATA.dwFlag
        cmp     edx,NVTWINVIEW_FLAG_GET
        je      GetPhys

SetPhys:
        ; Get the Twinview data into a MODEINFO structure
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes
        mov     sModeInfo.dwXRes,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes
        mov     sModeInfo.dwYRes,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp
        mov     sModeInfo.dwBpp,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh
        mov     sModeInfo.dwRefreshRate,eax

        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        push    eax
        CALLFAR16IND lpfnSetDeviceDisplayMode,es,ax

        cmp     ds:[esi].GNCRTCCX.dwPhysicalDeviceInstance,0
        je      DoneIt

        ; Set panning flag for the clone device
        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        push    eax
        pushd   1
        CALLFAR16IND lpfnSetClonePanningFlag,es,ax
        jmp     DoneIt

GetPhys:
        ; What device is he asking about?
        movzx   eax,(DEVDATA PTR sModeInfo.MIDevData).cType
        lea     ecx,[esi].GNCRTCCX.sCrtcModeInfo
        xor     eax,ds:[ecx].MODEINFO.MIDevData
        and     eax,0FFFFFFH
        jne     NotCurrent

UseCurrent:
        ; He is asking about the current device
        sub     edi,edi
        les     di,lpOut
        sub     ebx,ebx
        lfs     bx,ds:[esi].GNCRTCCX.lpCrtcModeInfo
        mov     eax,fs:[ebx].MODEINFO.dwXRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes,eax
        mov     eax,fs:[ebx].MODEINFO.dwYRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes,eax
        mov     eax,fs:[ebx].MODEINFO.dwBpp
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp,eax
        mov     eax,fs:[ebx].MODEINFO.dwRefreshRate
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh,eax
        jmp     DoneIt

UseDefault:
        sub     edi,edi
        les     di,lpOut
        mov     eax,640                 ;XRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes,eax
        mov     eax,480                 ;YRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes,eax
        mov     eax,10H                 ;bpp
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp,eax
        mov     eax,60                  ;RefreshRate
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh,eax
        jmp     DoneIt

NotCurrent:
        ; Read the registry for the virtual desktops of devices that
        ; are not currently active
        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        push    eax
        CALLFAR16IND lpfnGetDeviceDisplayMode,es,ax
        or      ax,ax
        je      UseDefault

        ; Copy the data back from our MODEINFO to the Twinview struct
        sub     edi,edi
        les     di,lpOut
        mov     eax,sModeInfo.dwXRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes,eax
        mov     eax,sModeInfo.dwYRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes,eax
        mov     eax,sModeInfo.dwBpp
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp,eax
        mov     eax,sModeInfo.dwRefreshRate
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh,eax

DoneIt:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_ValidateVirtualMode
;
; Purpose:      This function validates a virtual mode for the desktop.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               es:edi          NVTWINVIEWDATA
;               esi             GNLOGDEVCX ptr
;
; Returns:      ecx     1
;               eax     0 failure
;                       1 success
;
; Preserve:
;==============================================================================
DECPROC NV_ValidateVirtualMode, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Load up our context
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes
        push    es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes
        push    es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp
        call    HW_GetModeDimensions

        ; Get the largest block size that we could put this mode in
        push    ebx
        push    esi
        call    GN_GetFreeBlockSizeForMode
        pop     ebx

        ; Is it enough?
        cmp     eax,ebx
        jl      Invalid

Valid:
        mov     eax,1
        jmp     Done

Invalid:
        sub     eax,eax

Done:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_ValidatePhysicalMode
;
; Purpose:      This function validates the physical mode for the
;               desktop.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               es:edi          NVTWINVIEWDATA
;               esi             GNLOGDEVCX ptr
;
; Returns:      ecx     1
;               eax     0 failure
;                       1 success
;
; Preserve:
;==============================================================================
DECPROC NV_ValidatePhysicalMode, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Determine the correct CRTC to address
        sub     eax,eax
        mov     edx,es:[edi].NVTWINVIEWDATA.dwCrtc
        cmp     edx,ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        jae     Done

        ; Get the CRTC context ptr
        lea     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     esi,ds:[ebx][edx * 4]
        or      esi,esi
        je      Done

        ; Get the type of device we are validating the mode on
        ; and convert it to the DEVTYPE_XXX type list.
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceType
        call    HW_MapHWDeviceTypeToGNDeviceType
        mov     (DEVDATA PTR LocalDevData).cType,cl
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwTVFormat
        call    HW_MapHWTvFormatToGNTvFormat
        mov     (DEVDATA PTR LocalDevData).cFormat,cl

        ; Get the device number.
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceMask
        sub     ecx,ecx

Find_Device_Number:     
        test    eax,1
        jz      @F
        mov     ch,cl
        and     ch,07H
        jmp     Got_Device_number
        
@@:     inc     cl
        shr     eax,1
        cmp     cl,18H
        jc      Find_Device_Number
        
        mov     ch,0
        
Got_Device_number:
        mov     (DEVDATA PTR sModeInfo.MIDevData).cNumber,ch
        mov     (DEVDATA PTR LocalDevData).cNumber,ch

        ; Don't bother and try to read the edid on a tv
        mov     dwSizeEdidBuffer,0
        cmp     (DEVDATA PTR LocalDevData).cType,DEVTYPE_TV
        je      DoneEdidRead

        ; Read the EDID for this device if it has an EDID
        mov     dwSizeEdidBuffer,MAX_EDID_BUFFER_SIZE
        push    ds:[esi].GNCRTCCX.pHWCrtcCX
        push    dword ptr LocalDevData
        mov     ax,ss
        push    eax
        call    GN_GetSelectorBase
        lea     ecx,sLocalEdidBuffer
        add     ecx,eax
        push    ecx
        lea     ecx,dwSizeEdidBuffer
        add     ecx,eax
        push    ecx
        call    HW_ReadEdid

DoneEdidRead:
        ; Get everything into a MODEINFO structure
        sub     edi,edi
        les     di,lpOut
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes
        mov     sModeInfo.dwXRes,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes
        mov     sModeInfo.dwYRes,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp
        mov     sModeInfo.dwBpp,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh
        mov     sModeInfo.dwRefreshRate,eax
        mov     eax,dword ptr LocalDevData
        mov     sModeInfo.MIDevData,eax

        ; Validate the mode.
        push    esi
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        push    eax
        lfs     bx,ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    fs:[bx].DISPDATA.dwMonitorInfType
        mov     ax,ss
        shl     eax,10H
        lea     ax,sLocalEdidBuffer
        push    eax
        push    dwSizeEdidBuffer
        call    GN_ValidatePhysicalMode
        mov     edx,eax

        ; Otherwise, we need an exact match
        mov     eax,1
        cmp     edx,MODE_EXACT_MATCH
        je      Done

        ; Fail, but copy back the best match to Twinview
        sub     edi,edi
        les     di,lpOut
        mov     eax,sModeInfo.dwXRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes,eax
        mov     eax,sModeInfo.dwYRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes,eax
        mov     eax,sModeInfo.dwBpp
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp,eax
        mov     eax,sModeInfo.dwRefreshRate
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh,eax
        sub     eax,eax

Done:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_SetGet_Timing_Override
;
; Purpose:      This function gets or sets the timing override.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;               es:edi          NVTWINVIEWDATA
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:
;==============================================================================
DECPROC NV_SetGet_Timing_Override, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Determine the correct CRTC to address
        sub     eax,eax
        mov     edx,es:[edi].NVTWINVIEWDATA.dwCrtc
        ; See we are in clone or extended mode
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,1
        jg      @F
        sub     edx,edx
@@:
        cmp     edx,ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        jae     Done

        ; Get the CRTC context ptr
        lea     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     esi,ds:[ebx][edx * 4]
        or      esi,esi
        je      Done

        mov     edx,es:[edi].NVTWINVIEWDATA.dwFlag
        cmp     edx,NVTWINVIEW_FLAG_GET
        jne     SetTimingOverride

GetTimingOverride:
        ; Read the registry for the virtual desktops of devices that
        ; are not currently active
        lfs     bx,ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        push    fs:[bx].DISPDATA.lpDevData
        mov     ax,es
        shl     eax,10h
        lea     ax,es:[di].NVTWINVIEWDATA.dwState
        push    eax
        CALLFAR16IND lpfnGetTimingOverride,es,ax
        movzx   eax,ax
        or      ax,ax
        jmp     Done

SetTimingOverride:
        ; Write this out to the registry.
        lfs     bx,ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        push    fs:[bx].DISPDATA.lpDevData
        push    es:[di].NVTWINVIEWDATA.dwState
        CALLFAR16IND lpfnSetTimingOverride,es,ax
        mov     eax,1
Done:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_SetGet_Freeze_Origin
;
; Purpose:      This function is the Control Panel interface to the
;               display driver. We will only get here if a Control
;               panel escape is issued to the display driver.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               es:edi          NVTWINVIEWDATA
;               esi             GNLOGDEVCX ptr
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_SetGet_Freeze_Origin, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Determine the correct CRTC to address
        sub     eax,eax
        mov     edx,es:[edi].NVTWINVIEWDATA.dwCrtc
        cmp     edx,ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        jae     Done

        ; Get the CRTC context ptr
        lea     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     esi,ds:[ebx][edx * 4]
        or      esi,esi
        je      Done

        mov     edx,es:[edi].NVTWINVIEWDATA.dwFlag
        cmp     edx,NVTWINVIEW_FLAG_GET
        jne     SetFreeze

        ; dwPanAndScanEnabled has the opposite sense of dwFreezeOrigin.
        mov     eax,ds:[esi].GNCRTCCX.dwPanAndScanEnabled
        cmp     eax,0
        mov     eax,1
        je      WriteData
        mov     eax,0
WriteData:
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwfreezedata.dwFreezeOrigin,eax
        jmp     Done

SetFreeze:
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwfreezedata.dwFreezeOrigin
        cmp     eax,0
        je      Unfreeze

        mov     ds:[esi].GNCRTCCX.dwPanAndScanEnabled,0

        ; Write this out to the registry.
        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        lfs     bx,ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    fs:[bx].DISPDATA.lpDevData
        push    ds:[esi].GNCRTCCX.rcPhysicalViewport.dwTop
        push    ds:[esi].GNCRTCCX.rcPhysicalViewport.dwLeft
        push    ds:[esi].GNCRTCCX.rcPhysicalViewport.dwBottom
        push    ds:[esi].GNCRTCCX.rcPhysicalViewport.dwRight
        push    eax
        CALLFAR16IND lpfnSetAutoPanMode,es,ax

        jmp     Done

Unfreeze:
        mov     ds:[esi].GNCRTCCX.dwPanAndScanEnabled,1

        ; Write this out to the registry.
        push    ds:[esi].GNCRTCCX.lpBoardRegistryData
        lfs     bx,ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    fs:[bx].DISPDATA.lpDevData
        push    ds:[esi].GNCRTCCX.rcPhysicalViewport.dwTop
        push    ds:[esi].GNCRTCCX.rcPhysicalViewport.dwLeft
        push    ds:[esi].GNCRTCCX.rcPhysicalViewport.dwBottom
        push    ds:[esi].GNCRTCCX.rcPhysicalViewport.dwRight
        push    eax
        CALLFAR16IND lpfnSetAutoPanMode,es,ax

Done:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1

CLOSEPROC


;==============================================================================
;
; Function:     NV_SetGetCloneGamma
;
; Purpose:      This function is the Control Panel interface to the
;               display driver. We will only get here if a Control
;               panel escape is issued to the display driver.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               es:edi          NVTWINVIEWDATA
;               esi             GNLOGDEVCX ptr
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_SetGetCloneGamma, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Determine the correct CRTC to address
        sub     eax,eax
        mov     edx,es:[edi].NVTWINVIEWDATA.dwCrtc
        cmp     edx,ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        jae     EndIt

        ; Get the CRTC context ptr
        lea     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     esi,ds:[ebx][edx * 4]
        or      esi,esi
        je      EndIt

        mov     edx,es:[edi].NVTWINVIEWDATA.dwFlag
        cmp     edx,NVTWINVIEW_FLAG_GET
        jne     SetGamma

GetGamma:
        lea     esi,[esi].GNCRTCCX.dwGammaTable
        lea     edi,[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.adwGammaTable
        mov     ecx,100H
        rep     movs dword ptr es:[edi], ds:[esi]
        mov     eax,1
        jmp     EndIt

SetGamma:
        PUSHR   ds
        mov     ax,ds
        mov     cx,es
        mov     es,ax
        mov     ds,cx
        mov     ebx,esi
        lea     esi,[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.adwGammaTable
        lea     edi,[ebx].GNCRTCCX.dwGammaTable
        mov     ecx,100H
        rep     movs dword ptr es:[edi], ds:[esi]
        POPR    ds

        ; Now put it into the hardware
        push    ebx
        call    GN_ResetColorMap
        mov     eax,1

EndIt:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_RotateCloneDevices
;
; Purpose:      This function is the Control Panel interface to the
;               display driver. We will only get here if a Control
;               panel escape is issued to the display driver.
;
;               This escape will take the display device the primary
;               is using and use that device for the first clone. It
;               will take the display device used by the first clone
;               and make the primary use it. For a dual head board
;               this functions as a "Swap display devices". For more
;               than a two head board, it is a "rotate display devices."
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               es:edi          NVTWINVIEWDATA
;               esi             GNLOGDEVCX ptr
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_RotateCloneDevices, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     edi,edi
        mov     dwDeviceCount,edi

        ; Get the primary CRTC dislay device
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        call    GN_GetDevData
        mov     OldCrtcDevData,eax
        jmp     NextCrtc

TopL:
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        or      ecx,ecx
        je      NextCrtc

        ; Aha! Found another one. Get it's DevData
        push    ecx
        call    GN_GetDevData
        push    eax

        ; Set the prior CRTCCX's DevData into this one
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    OldCrtcDevData
        call    GN_SetDevData

        ; Now save this guys old one as the next one to rotate in
        pop     OldCrtcDevData

        ; We actually rotated one
        inc     dwDeviceCount

NextCrtc:
        inc     edi
        cmp     edi,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jb      TopL

        ; Did we rotate any?
        cmp     dwDeviceCount,0
        mov     eax,0
        je      DoneIt

        ; Yes! That means that the display device used by the last
        ; CRTCCX we found should go into the primary.
        sub     edi,edi
        push    ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        push    OldCrtcDevData
        call    GN_SetDevData

        ; Get the Device Data Mask for all display devices.
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        pushd   0
        call    GN_GetDevDataMask
        or      eax,80000000H
        mov     dwLocalDeviceMask,eax

        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwLocalDeviceMask
        call    HW_BeginDisplayChange

        ; Go into each GNCRTCCX and set the physical resolution
        ; equal to the desktop resolution. The mode will be
        ; backed off if it cannot be set directly.
        sub     edi,edi
Loop8:
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[edi * 4]
        or      ecx,ecx
        je      NextCrtc8

        lea     ebx,ds:[ecx].GNCRTCCX.sCrtcModeInfo
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deWidth
        mov     ds:[ebx].MODEINFO.dwXRes,eax
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deHeight
        mov     ds:[ebx].MODEINFO.dwYRes,eax

NextCrtc8:
        inc     edi
        cmp     edi,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jb      Loop8

        ; remap everything
        push    esi
        call    GN_CrtcRemapArray
        push    esi
        call    GN_RestoreAllCrtcStates

        ; Signal the end of a display state change
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwLocalDeviceMask
        call    HW_EndDisplayChange

        mov     ds:[esi].GNCRTCCX.dwDisplayDeviceChange,1
        mov     eax,1

DoneIt:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_LockHWCrtcOnHead
;
; Purpose:      This function locks the HWCRTCCX on the head specified
;               for use by the caller. The display driver will not change
;               the hardware state of the CRTC controller on the head
;               specified for any reason. It is the caller's
;               responsibility to unlock when he is done.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               es:edi          NVTWINVIEWDATA
;               esi             GNLOGDEVCX ptr
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_LockHWCrtcOnHead, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Load up the ptr to the Data
        sub     edi,edi
        les     di,lpOut
        mov     pHWCrtcCXUsingTheHead,0

        ; Find the GNLOGDEVCX that is using this head number
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    es:[edi].NVTWINVIEWDATA.dwCrtc
        call    GN_MapHeadToGNLogdev
        or      eax,eax
        je      DoneIt
        mov     pGNLogdevCXUsingTheHead,ebx
        mov     pGNCrtcCXUsingTheHead,eax
        mov     dwLogCrtcIndex,ecx

        ; We need to reset the panning rectangle to be justified
        ; in the upper left corner.
        sub     ecx,ecx
        mov     ds:[eax].GNCRTCCX.rcPhysicalViewport.dwLeft,ecx
        mov     ds:[eax].GNCRTCCX.rcPhysicalViewport.dwTop,ecx
        lea     ebx,[eax].GNCRTCCX.sCrtcModeInfo
        mov     ecx,ds:[ebx].MODEINFO.dwXRes
        mov     ds:[eax].GNCRTCCX.rcPhysicalViewport.dwRight,ecx
        mov     ecx,ds:[ebx].MODEINFO.dwYRes
        mov     ds:[eax].GNCRTCCX.rcPhysicalViewport.dwBottom,ecx
        push    eax
        call    GN_SetPanRectangle

        ; Save the HWCRTCCX using the head to return to the caller
        mov     eax,pGNCrtcCXUsingTheHead
        mov     ebx,ds:[eax].GNCRTCCX.pHWCrtcCX
        mov     pHWCrtcCXUsingTheHead,ebx

        ; Play some games here! NULL out the HWCRTCCX in the GNCRTCCX
        ; so that the display driver will not mess with that head.
        mov     ds:[eax].GNCRTCCX.pHWCrtcCXWhenLocked,ebx
        mov     ds:[eax].GNCRTCCX.pHWCrtcCX,0

        ; Tell the hwlogdev that the HWCRTCCX is NULL
        mov     eax,pGNLogdevCXUsingTheHead
        push    ds:[eax].GNLOGDEVCX.pHWLogdevCX
        push    dwLogCrtcIndex
        push    pHWCrtcCXUsingTheHead
        call    HW_LogdevDetachCrtc

        ; Reset the gamma ramp to the identity
        lea     ebx,aGammaTable
        sub     ecx,ecx
@@:     mov     ss:[ebx],ecx
        add     ebx,4
        add     ecx,010101H
        or      cl,cl
        jne     @B

        ; Get a flat ptr to the identity gamma table
        mov     ax,ss
        push    eax
        call    GN_GetSelectorBase
        lea     edx,aGammaTable
        add     eax,edx

        ; Tell the hardware to set it
        push    pHWCrtcCXUsingTheHead
        push    eax
        pushd   0
        pushd   100H
        call    HW_SetGamma

        ; Turn the cursor off on the CRTC in question
        push    pHWCrtcCXUsingTheHead
        pushd   0
        call    HW_CursorEnable_FAR32
        mov     eax,1

DoneIt:
        sub     edi,edi
        les     di,lpOut
        mov     eax,pGNLogdevCXUsingTheHead
        mov     es:[edi].NVTWINVIEWDATA.nvtwLockUnlockHwcrtc.pGNLogdevCX,eax
        mov     eax,dwLogCrtcIndex
        mov     es:[edi].NVTWINVIEWDATA.nvtwLockUnlockHwcrtc.dwLogicalCrtcIndex,eax
        mov     eax,pHWCrtcCXUsingTheHead
        mov     es:[edi].NVTWINVIEWDATA.nvtwLockUnlockHwcrtc.pHWCrtcCX,eax
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_UnlockHWCrtcOnHead
;
; Purpose:      This function unlocks the HWCRTCCX on the head specified
;               for use by the caller. The display driver can once again
;               change the hardware state of the CRTC controller on the
;               head specified for any reason.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:     ds
;==============================================================================
DECPROC GN_UnlockHWCrtcOnHead, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Load up the ptr to the Data
        sub     edi,edi
        les     di,lpOut
        mov     ebx,es:[edi].NVTWINVIEWDATA.nvtwLockUnlockHwcrtc.pGNLogdevCX
        mov     pGNLogdevCXUsingTheHead,ebx
        mov     ecx,es:[edi].NVTWINVIEWDATA.nvtwLockUnlockHwcrtc.dwLogicalCrtcIndex
        mov     dwLogCrtcIndex,ecx
        mov     eax,es:[edi].NVTWINVIEWDATA.nvtwLockUnlockHwcrtc.pHWCrtcCX
        mov     pHWCrtcCXUsingTheHead,eax

        ; Check for NULL ptrs.
        mov     eax,1
        cmp     pHWCrtcCXUsingTheHead,0
        je      DoneIt

        ; Is this a legal logical crtc index for this device?
        sub     eax,eax
        cmp     ecx,ds:[ebx].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        jae     DoneIt

        ; Let's just make sure we don't already have a HWCRTCCX there
        sub     eax,eax
        mov     edx,ds:[ebx].GNLOGDEVCX.pGNCrtcCX[ecx * 4]
        cmp     ds:[edx].GNCRTCCX.pHWCrtcCX,0
        jne     DoneIt
        mov     pGNCrtcCXUsingTheHead,edx

        ; Now Attach the HWCRTCCX to the GNCRTCCX
        mov     eax,pHWCrtcCXUsingTheHead
        mov     ds:[edx].GNCRTCCX.pHWCrtcCX,eax
        mov     ds:[edx].GNCRTCCX.pHWCrtcCXWhenLocked,0

        ; Now Attach the HWCRTCCX to the HWLOGDEVCX
        mov     esi,pGNLogdevCXUsingTheHead
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        push    dwLogCrtcIndex
        push    pHWCrtcCXUsingTheHead
        call    HW_LogdevAttachCrtc

        ; Get the Device Data Mask for all display devices.
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        pushd   0
        call    GN_GetDevDataMask
        or      eax,80000000H
        mov     dwLocalDeviceMask,eax

        ; Signal the beginning of a display state change
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwLocalDeviceMask
        call    HW_BeginDisplayChange

        ; Restore the software state into the hardware
        push    pGNCrtcCXUsingTheHead
        push    pGNLogdevCXUsingTheHead
        call    GN_RestoreCrtcState

        ; Reset the last active cursor
        push    pGNCrtcCXUsingTheHead
        call    GN_ResetSelectedCursor

        ; Signal the end of a display state change
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwLocalDeviceMask
        call    HW_EndDisplayChange

        mov     eax,1
DoneIt:
        sub     edi,edi
        les     di,lpOut
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_SpecialSetPhysicalMode
;
; Purpose:      This function can be called as part of the DVD Zoom
;               escapes. Once the caller has locked a HWCRTCCX on a
;               given head, they can call this routine to set the
;               physical mode on the given head.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      The return value depends upon the specific control call.
;
; Preserve:     ds
;==============================================================================
DECPROC GN_SpecialSetPhysicalMode, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; Load up the ptr to the Data
        sub     edi,edi
        les     di,lpOut

        mov     ebx,es:[edi].NVTWINVIEWDATA.nvtwPhysicalModeImmediate.pGNLogdevCX
        mov     pGNLogdevCXUsingTheHead,ebx
        mov     ecx,es:[edi].NVTWINVIEWDATA.nvtwPhysicalModeImmediate.dwLogicalCrtcIndex
        mov     dwLogCrtcIndex,ecx
        mov     eax,es:[edi].NVTWINVIEWDATA.nvtwPhysicalModeImmediate.pHWCrtcCX
        mov     pHWCrtcCXUsingTheHead,eax
        or      eax,eax
        je      DoneIt

        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes
        mov     sModeInfo.dwXRes,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes
        mov     sModeInfo.dwYRes,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp
        mov     sModeInfo.dwBpp,eax
        mov     eax,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh
        mov     sModeInfo.dwRefreshRate,eax
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceType
        call    HW_MapHWDeviceTypeToGNDeviceType
        mov     (DEVDATA PTR sModeInfo.MIDevData).cType,cl
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwTVFormat
        call    HW_MapHWTvFormatToGNTvFormat
        mov     (DEVDATA PTR sModeInfo.MIDevData).cFormat,cl

        ; This gets the timing parameters for the mode requested
        ; or a smaller mode if the requested mode was not settable.
        mov     ebx,pGNLogdevCXUsingTheHead
        mov     ecx,dwLogCrtcIndex
        mov     edx,ds:[ebx].GNLOGDEVCX.pGNCrtcCX[ecx * 4]
        mov     pGNCrtcCXUsingTheHead,edx

        ; Get timings
        push    ds:[edx].GNCRTCCX.lpNvmodeDispData
        push    ds:[edx].GNCRTCCX.lpEdidBuffer
        push    ds:[edx].GNCRTCCX.dwEdidSize
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        push    eax
        lea     ax,sModeOut
        push    eax
        lea     ax,sSettableModeInfo
        push    eax
        CALLFAR16IND lpfnFindModeEntry,es,ax

        ; Get the devices in use
        mov     ebx,pGNLogdevCXUsingTheHead
        push    ds:[ebx].GNLOGDEVCX.pGNBoardCX
        pushd   0
        call    GN_GetDevDataMask
        or      eax,80000000H
        mov     dwDevDataMask,eax

        ; Signal the beginning of a display state change
        mov     ebx,pGNLogdevCXUsingTheHead
        mov     ebx,ds:[ebx].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwDevDataMask
        call    HW_BeginDisplayChange

        ; Call the hardware to program the timings
        mov     eax,pGNCrtcCXUsingTheHead
        mov     ebx,pGNLogdevCXUsingTheHead
        push    pHWCrtcCXUsingTheHead
        push    ds:[ebx].DIBENGINEHDR.deBitsOffset
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeOut
        push    eax
        call    HW_SetCrtcMode

        mov     ebx,pGNLogdevCXUsingTheHead
        mov     ebx,ds:[ebx].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        push    dwDevDataMask
        call    HW_EndDisplayChange

        ; Return the mode actually set
        sub     edi,edi
        les     di,lpOut
        mov     eax,sSettableModeInfo.dwXRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes,eax
        mov     eax,sSettableModeInfo.dwYRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes,eax
        mov     eax,sSettableModeInfo.dwBpp
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp,eax
        mov     eax,sSettableModeInfo.dwRefreshRate
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh,eax
        movzx   ecx,(DEVDATA PTR sSettableModeInfo.MIDevData).cType
        call    HW_MapGNDeviceTypeToHWDeviceType
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwDeviceType,ecx
        movzx   ecx,(DEVDATA PTR sSettableModeInfo.MIDevData).cFormat
        call    HW_MapGNTvFormatToHWTvFormat
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwTVFormat,ecx
        mov     eax,1

DoneIt:
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,eax
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_MapLogToPhysHead
;
; Purpose:      This routine takes a 0 based head logical head number
;               and returns a physical head number.
;
; Arguments:
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      ecx             1
;                               Also the logical head number in
;                               lpOut->NVTINWVIEWDATA.dwCrtc was
;                               replaced with the physical head
;                               number that corresponds to it.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_MapLogToPhysHead, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     edi,edi
        les     di,lpOut

        ; Assume failure
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,0

        ; Get the logical CRTC number -- make sure it is within range
        ; for this display driver.
        mov     ebx,es:[edi].NVTWINVIEWDATA.dwCrtc
        cmp     ebx,ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        jae     MLTPH_End

        ; Is that logical CRTC NULL?
        mov     edx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ebx * 4]
        or      edx,edx
        je      MLTPH_End

        ; Nope it is fine.  Get the physical head number
        mov     eax,ds:[edx].GNCRTCCX.pHWCrtcCX
        or      eax,eax
        jne     @F

        ; This CRTC has already been locked
        mov     eax,ds:[edx].GNCRTCCX.pHWCrtcCXWhenLocked
        or      eax,eax
        je      MLTPH_End

@@:
        push    eax
        call    HW_GetPhysicalCrtcIndex
        mov     es:[edi].NVTWINVIEWDATA.dwCrtc,eax
        mov     es:[edi].NVTWINVIEWDATA.dwSuccess,1

MLTPH_End:
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_SetGetDisplayConfig
;
; Purpose:      This routine either sts or gets the display configuration
;               which includes, the desktop state (normal or clone), the
;               display devices being used, and the physical modes on
;               each display device.
;
; Arguments:
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      ecx             1
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_SetGetDisplayConfig, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        ; We might need these
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        mov     lpModeInfo,eax
        lea     ax,sDesktopModeInfo
        mov     lpDesktopModeInfo,eax
        lea     ax,LocalDevData
        mov     lpLocalDevData,eax

        sub     edi,edi
        les     di,lpOut

        ; Determine Set or Get
        mov     edx,es:[edi].NVTWINVIEWDATA.dwFlag
        cmp     edx,NVTWINVIEW_FLAG_GET
        jne     SetDisplayConfig

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GetDisplayConfig:

        ; Find out info on the display devices
        mov     dwDeviceCount,0
        mov     dwDevDataMask,1
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwDisplayConfig.dwActiveDevices,0
Loop1:
        mov     ecx,dwDeviceCount
        mov     edx,dwDevDataMask
        cmp     ds:[esi].GNLOGDEVCX.pGNCrtcCX[ecx * 4],0
        je      Next1

        ; CRTCCX is present -- OR in a present bit for this
        or      es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwDisplayConfig.dwActiveDevices,edx

        ; Get the device type
        push    dword ptr ds:[esi].GNLOGDEVCX.pGNCrtcCX[ecx * 4]
        call    GN_GetDevData
        mov     OldCrtcDevData,eax

        ; Convert the DevData type to a mask
        shl     al,3
        add     al,ah
        mov     cl,al
        mov     ebx,1
        shl     ebx,cl
        movzx   eax,cl
        or      es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwDisplayConfig.dwDeviceMask,ebx

        ; If this is the primary device, set its mask
        cmp     dwDeviceCount,0
        jne     @F
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwDisplayConfig.dwPrimaryDeviceMask,ebx
@@:
        ; Compute the correct offset to store the PhysMode at
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwDisplayConfig.dwPhysicalModeFlags
        imul    eax,SIZE PHYSICAL_MODE
        lea     edi,[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwDisplayConfig.PhysModes
        add     edi,eax

        ; Is bit mask ebx set in the dwPhysicalModeFlags field?
        test    ebx,ecx
        jz      GetMaxMode

GetCurrentMode:
        mov     ecx,dwDeviceCount
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ecx * 4]
        lea     ebx,[ebx].GNCRTCCX.sCrtcModeInfo
        mov     eax,ds:[ebx].MODEINFO.dwXRes
        mov     es:[edi].PHYSICAL_MODE.dwXRes,eax
        mov     eax,ds:[ebx].MODEINFO.dwYRes
        mov     es:[edi].PHYSICAL_MODE.dwYRes,eax
        mov     eax,ds:[ebx].MODEINFO.dwRefreshRate
        mov     es:[edi].PHYSICAL_MODE.dwRefreshRate,eax
        jmp     Next1

GetMaxMode:
        ; Pass in a ridiculously large mode to FindModeEntry and it
        ; will bump it down to something the device can set.
        mov     sModeInfo.dwXRes,7FFFH
        mov     sModeInfo.dwYRes,7FFFH
        movzx   eax,ds:[esi].GNLOGDEVCX.Dibeng.deBitsPixel
        mov     sModeInfo.dwBpp,eax
        mov     sModeInfo.dwRefreshRate,1000
        mov     eax,OldCrtcDevData
        mov     dword ptr sModeInfo.MIDevData,eax

        mov     ecx,dwDeviceCount
        mov     edx,ds:[esi].GNLOGDEVCX.pGNCrtcCX[ecx * 4]
        push    edx
        push    lpModeInfo
        lfs     bx,ds:[edx].GNCRTCCX.lpNvmodeDispData
        push    fs:[bx].DISPDATA.dwMonitorInfType
        push    ds:[edx].GNCRTCCX.lpEdidBuffer
        push    ds:[edx].GNCRTCCX.dwEdidSize
        call    GN_ValidatePhysicalMode

        ; We don't care about the return value. The point is,
        ; whatever is in sModeInfo is the largest settable mode.
        ; Copy it into the PHYSICAL_MODE structure.
        mov     es,word ptr lpOut+2
        mov     eax,sModeInfo.dwXRes
        mov     es:[edi].PHYSICAL_MODE.dwXRes,eax
        mov     eax,sModeInfo.dwYRes
        mov     es:[edi].PHYSICAL_MODE.dwYRes,eax
        mov     eax,sModeInfo.dwRefreshRate
        mov     es:[edi].PHYSICAL_MODE.dwRefreshRate,eax

Next1:
        inc     dwDeviceCount
        shl     dwDevDataMask,1
        mov     ecx,dwDeviceCount
        cmp     ecx,ds:[esi].GNLOGDEVCX.dwTotalCRTCsOnBoard
        jc      Loop1
        jmp     Success

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SetDisplayConfig:
        ; Let's shotgun save the entire _NVTWINVIEW_DISPLAY_CONFIG
        ; structure into our GNLOGDEVCX in case we need it.
        PUSHR   ds,esi
        mov     ebx,edi
        push    ds
        push    es
        pop     ds
        pop     es
        lea     edi,[esi].GNLOGDEVCX.sDispConfig
        lea     esi,[ebx].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwDisplayConfig
        mov     ecx,SIZE NVTWINVIEW_DISPLAY_CONFIG
        cld
        rep     movs byte ptr es:[edi], ds:[esi]
        POPR    ds,esi
        lea     edi,[esi].GNLOGDEVCX.sDispConfig

        cmp     ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwSetModesNow,0
        jne     FailIt

        ; Now we can reference everything from ds:[edi]
        ; This code assumes only two heads and assumes that
        ; it will never be called when we are in multi-mon mode.
        mov     eax,ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwActiveDevices
        shr     eax,1
        inc     eax
        mov     dwDeviceCount,eax
        or      eax,eax
        je      FailIt
        cmp     eax,2
        ja      FailIt

        ; Convert the dwDeviceMask to an array of DevDatas and ask if
        mov     edx,ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwDeviceMask
        lfs     bx,lpLocalDevData

Loop3:
        sub     ecx,ecx
Loop4:
        test    edx,1
        jz      @F
        mov     dword ptr fs:[bx],0
        mov     ch,cl
        shr     ch,3
        mov     byte ptr fs:[bx].DEVDATA.cType,ch
        mov     ch,cl
        and     ch,07H
        mov     byte ptr fs:[bx].DEVDATA.cNumber,ch
        add     bx,4
        dec     eax
        je      Out1
@@:     inc     cl
        shr     edx,1
        cmp     cl,18H
        jc      Loop4
Out1:

        ; Ask the hardware if it is possible to have all the
        ; devices specified enabled simultaneously by assigning
        ; each to a different head.
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ecx].GNBOARDCX.pHWBoardCX
        push    lpLocalDevData
        push    dwDeviceCount
        call    HW_CanDevicesBeMapped
        or      eax,eax
        je      FailIt

        ; dwPrimaryDeviceMask should be one of dwDeviceMask bits
        mov     eax,ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwDeviceMask
        mov     ebx,ds:[edi].NVTWINVIEW_DISPLAY_CONFIG.dwPrimaryDeviceMask
        and     eax,ebx
        je      FailIt

DeferChange:
        mov     ds:[esi].GNLOGDEVCX.dwDisplayConfigPending,1
        mov     ds:[esi].GNLOGDEVCX.dwNvDisplayChangePending,1
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        mov     ds:[ebx].GNCRTCCX.dwDisplayDeviceChange,1
        
        jmp     Success
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FailIt:
        les     di,lpOut
        mov     es:[di].NVTWINVIEWDATA.dwSuccess,0
        jmp     Done
Success:
        les     di,lpOut
        mov     es:[di].NVTWINVIEWDATA.dwSuccess,1
Done:
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetBiggestEdidMode
;
; Purpose:      This routine gets the largest mode in the EDID for the
;               display device passed in.
;
; Arguments:
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      ecx             1
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetBiggestEdidMode, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC


        ; Need to change dwDeviceMask into DevData
        mov     ecx,es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwDisplayConfig.dwDeviceMask

        ; First look at CRTS
        mov     eax,DEVTYPE_CRT + 0FF00H
@@:     inc     ah
        test    cl,1
        jz      Next1
        jmp     GotDevData
Next1:  shr     cl,1
        cmp     ah,8
        jc      @B

        ; Nope. Try DFPS
        shr     ecx,8
        mov     eax,DEVTYPE_DFP + 0FF00H
@@:     inc     ah
        test    ch,1
        jz      Next2
        jmp     GotDevData
Next2:  shr     ch,1
        cmp     ah,8
        jc      @B

        ; Last hope is TVS
        mov     eax,DEVTYPE_TV + 0FF00H
@@:     inc     ah
        test    cl,1
        jz      Next3
        jmp     GotDevData
Next3:  shr     cl,1
        cmp     ah,8
        jc      @B
        
        ; No valid device attached. Fail
        jmp     FailIt
        
GotDevData:
        mov     (DEVDATA PTR LocalDevData).cType,al
        mov     (DEVDATA PTR LocalDevData).cNumber,ah

        ; TV has no EDID. Return largest TV mode.
        cmp     (DEVDATA PTR LocalDevData).cType,DEVTYPE_TV
        jne     GetEdid

        ; The specific GNCRTCCX is not important as dwMaxTVOutResolution is
        ; the same regardless of the GNCRTCCX.
        mov     edx,ds:[esi].GNLOGDEVCX.pGNCrtcCX

        ; The largest TV mode is in the DispData structure.
        sub     ebx,ebx
        lfs     bx,ds:[edx].GNCRTCCX.lpNvmodeDispData
        mov     eax,fs:[ebx].DISPDATA.dwMaxTVOutResolution
        lea     ecx,ds:[edx].GNCRTCCX.sCrtcModeInfo
        mov     ecx,ds:[ecx].MODEINFO.dwBpp

        mov     ebx,eax
        shr     ebx,16  
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes,ebx
        and     eax,0FFFFh
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes,eax
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp,ecx
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh,60

        jmp     Success

GetEdid:
        ; Read the EDID for this device if it has an EDID
        mov     dwSizeEdidBuffer,MAX_EDID_BUFFER_SIZE
        mov     edx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    ds:[edx].GNCRTCCX.pHWCrtcCX
        push    dword ptr LocalDevData
        mov     ax,ss
        push    eax
        call    GN_GetSelectorBase
        lea     ecx,sLocalEdidBuffer
        add     ecx,eax
        push    ecx
        lea     ecx,dwSizeEdidBuffer
        add     ecx,eax
        push    ecx
        call    HW_ReadEdid
        
        cmp     dwSizeEdidBuffer,0
        jne     DoneEdidRead
        
        ; No EDID for this display device. Return something safe like
        ; 800x600@60Hz.
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes,800
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes,600
        mov     edx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        lea     edx,ds:[edx].GNCRTCCX.sCrtcModeInfo
        mov     edx,ds:[edx].MODEINFO.dwBpp
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp,edx
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh,60
        
        jmp     Success

DoneEdidRead:
        ; Now get the largest mode for this EDID.
        mov     ax,ss
        shl     eax,10h
        lea     ax,sLocalEdidBuffer
        push    eax
        push    dwSizeEdidBuffer
        lea     ax,sModeInfo
        push    eax
        CALLFAR16IND lpfnGetLargestEdidMode,es,ax

        sub     edi,edi
        les     di,lpOut
        sub     ebx,ebx
        lea     bx,sModeInfo
        mov     eax,ss:[ebx].MODEINFO.dwXRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwXRes,eax
        mov     eax,ss:[ebx].MODEINFO.dwYRes
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwYRes,eax
        mov     edx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        lea     edx,ds:[edx].GNCRTCCX.sCrtcModeInfo
        mov     edx,ds:[edx].MODEINFO.dwBpp
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwBpp,edx
        mov     eax,ss:[ebx].MODEINFO.dwRefreshRate
        mov     es:[edi].NVTWINVIEWDATA.NVTWINVIEWUNION.nvtwdevdata.dwRefresh,eax

        jmp     Success

FailIt:
        les     di,lpOut
        mov     es:[di].NVTWINVIEWDATA.dwSuccess,0
        jmp     Done
Success:
        les     di,lpOut
        mov     es:[di].NVTWINVIEWDATA.dwSuccess,1
Done:
        mov     ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     GN_MapHeadToGNLogdev
;
; Purpose:      This routine takes a 0 based head nmber and returns
;               the GNLOGDEVCX ptr that the head number is attached to.
;
; Arguments:
;               ds                      Context Selector
;               pGNBoardCXOffset        GNBOARDCX ptr
;               dwHead                  0 based head number
;
; Returns:      eax                     GNCRTCCX using the head
;               ebx                     GNLOGDEVCX owning the GNCRTCCX
;                                       which is using the head
;               ecx                     dwLogicalCrtcIndex of GNCRTCCX
;                                       in GNLOGDEVCX
;               eax,ebx, are NULL if not found
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_MapHeadToGNLogdev, PASCAL, FRAME, FAR16
PARMD   pGNBoardCXOffset
PARMD   dwHead
LOCALD  dwCRTCCount
LOCALD  dwLogdevCount
OPENPROC
        PUSHR   esi
        mov     ebx,pGNBoardCXOffset
        mov     dwLogdevCount,0
        sub     eax,eax

LoopLogdev:
        mov     edx,ds:[ebx].GNBOARDCX.pGNLogdevCX[eax * 4]
        or      edx,edx
        je      NextLogdev

        ; Is this head on this GNLOGDEVCX?
        lea     ecx,[edx].GNLOGDEVCX.pGNCrtcCX
        mov     dwCRTCCount,0

LoopCrtc:
        mov     eax,ds:[ecx]
        or      eax,eax
        je      NextCrtc

        PUSHR   eax,ebx,ecx,edx
        push    ds:[eax].GNCRTCCX.pHWCrtcCX
        call    HW_GetPhysicalCrtcIndex
        mov     esi,eax
        POPR    eax,ebx,ecx,edx
        cmp     esi,dwHead
        je      Found

NextCrtc:
        inc     dwCRTCCount
        add     ecx,4
        mov     eax,dwCRTCCount
        cmp     eax,ds:[edx].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice
        jc      LoopCrtc

NextLogdev:
        inc     dwLogdevCount
        mov     eax,dwLogdevCount
        cmp     eax,ds:[ebx].GNBOARDCX.dwLogicalDeviceInstancesOnThisBoard
        jc      LoopLogdev

NotFound:
        sub     eax,eax
        sub     ebx,ebx
        jmp     DoneIt

Found:
        mov     ebx,edx
        mov     ecx,dwCRTCCount
DoneIt:
        POPR    esi
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNRECT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnrect.asm
;
; Purpose:      This file holds the Output(OS_RECTANGLE) display driver
;               implementation. The Output display driver entry point
;               jumps to here without creating a FRAME when it is
;               discovered that this is and OS_RECTANGLE style.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include	gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_Rectangle
;
; Purpose:      This function is the Output(OS_RECTANGLE) display driver
;               implementation. The Output display driver entry point
;               jumps to here without creating a FRAME when it is
;               discovered that this is the OS_RECTANGLE style.
;
; Arguments:    Output Display Driver Stack Frame
;
; Returns:      ax      0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_Rectangle, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wStyle
PARMW   wCount
PARMD   lpPoints
PARMD   lpPen
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   lpClipRect
LOCALD	dwDrawInterior
LOCALD  dwPenColor
LOCALD  dwRop2
LOCALD  pHWLogDevCXOffset
LOCALD	dwBottomRight
LOCALD	dwTopLeft
OPENPROC
        PUSHR   ds,esi,edi

        ; Get a ptr to the dst bitmap
        mov     gs,word ptr lpDstDev+2
        movzx   esi,word ptr lpDstDev+0

        ; Load the Context Selector
        mov     ds,cs:[wFlatDataSel]
        mov     edi,cs:[CSpGNLogicalDevice]

        ; Load dst flags and prep some registers
        sub     ebx,ebx
        movzx   eax,gs:[esi].DIBENGINE.deFlags

        ; Filter out old style destinations
        cmp     bx,gs:[esi].DIBENGINE.deType
        je      GN_RectanglePunt

        ; Filter out based upon deFlags
        test    ah,VRAM / 256
        jz      GN_RectanglePunt
        test    ah,PALETTE_XLAT / 256
        jnz     GN_RectanglePunt

        ; Watch for busy hardware -- some other API owns the screen
        cmp     ds:[edi].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_RectanglePunt

        ; If both the pen and brush are null, then we are done!
        ; The only way the two ptrs can be equal is if they are
        ; both NULL!
        mov     eax,lpBrush
        cmp     eax,lpPen
        je      RectangleSuccess

	; Get ready to use points
	sub	esi,esi
        les     si,lpPoints
        mov    	eax,dword ptr es:[esi].RECT.left
        mov    	ebx,dword ptr es:[esi].RECT.right

	; If either the left or top has negative coordinates, then
	; we punt. Handling the interior drawing is not too bad even
	; with signed coordinates, but the border drawing is ugly.
	; Negative coordinates happen VERY rarely.
	test	eax,80008000H
	jnz	GN_RectanglePunt

	; Sometimes we get left > right or top > bottom
        cmp     ax,bx
        jge	GN_RectanglePunt
        cmp     eax,ebx
        jge	GN_RectanglePunt

	mov	dwTopLeft,eax
	mov	dwBottomRight,ebx

        ; Load up the drawmode ptr
        sub     ecx,ecx
        lfs     cx,lpDrawMode

	; Save off the hwlogdev for later
        mov     edx,ds:[edi].GNLOGDEVCX.pHWLogdevCX
	mov     pHWLogDevCXOffset,edx

        ; Get the rop
        movzx   edx,fs:[ecx].DRAWMODE.Rop2
        sub     ecx,ecx
        mov     dwRop2,edx

        ; Get the PenColor if the pen is not null
        cmp     ecx,lpPen
        je      RestP
        les     cx,lpPen
        cmp     es:[ecx].DIB_Pen.dpPenStyle,LS_SOLID
        je     	@F
        mov	lpPen,0
@@:     mov     ecx,es:[ecx].DIB_Pen.dpPenColor
RestP:  mov     dwPenColor,ecx

	; Is there a brush?
	mov	dwDrawInterior,1
	cmp	lpBrush,0
	je	UsePen

UseBrush:
        ; If the brush is hollow, then even if the rop only involves
        ; the dst (like BLACKNESS, WHITENESS, or INVERTDST), we blow
        ; off filling the interior of the rectangle. This sounds
        ; wierd but it is WHQL-correct behavior.
        sub	esi,esi
	les	si,lpBrush
	cmp	es:[esi].DIB_Brush8.dp8BrushStyle,BS_HOLLOW
	je	NoInterior

	; It is not a hollow brush. If the rop only involves the
	; dst (no pattern involvement), then skip the pattern load.
	dec	edx
        je	RetSetPat
        cmp     edx,05H
        je	RetSetPat
        cmp     edx,0AH
        je	RetSetPat
        cmp     edx,0FH
        je	RetSetPat

	; Load up the pattern
        mov     cl,byte ptr es:[esi].DIB_Brush8.dp8BrushStyle
        mov     al,byte ptr es:[esi].DIB_Brush8.dp8BrushFlags
        mov     edx,dword ptr es:[esi].DIB_Brush8.dp8BrushBits
        mov	ebx,pHWLogDevCXOffset
        PUSH	OFFSET RetSetPat
        cmp     cl,BS_HOLLOW
        jnc     @F
        test    al,COLORSOLID
        jz      HW_LoadColorPattern
        jmp     HW_LoadSolidPattern
@@:     cmp     cl,BS_PATTERN
        jc      IsHatch
        ja      GN_BitBltFail
        test    al,PATTERNMONO
        jz	HW_LoadColorPattern
IsMono:
	sub	edx,edx
	lfs	dx,lpDrawMode
	lea	esi,[esi].DIB_Brush16.dp16BrushMono
	mov	ecx,fs:[edx].DRAWMODE.TextColor
	mov	edx,fs:[edx].DRAWMODE.bkColor
	mov	eax,-1
	jmp	HW_LoadMonoPattern
IsHatch:
	sub	edx,edx
	lfs	dx,lpDrawMode
	cmp	fs:[edx].DRAWMODE.bkMode,TRANSPARENT
	sete	al
	cmp	al,1
	sbb	eax,eax
        mov     ecx,es:[esi].DIB_Brush8.dp8BgColor
        mov     edx,es:[esi].DIB_Brush8.dp8FgColor
	lea	esi,[esi].DIB_Brush16.dp16BrushMask
	jmp	HW_LoadMonoPattern

NoInterior:
	mov	dwDrawInterior,0
	jmp	RetSetPat

UsePen:
        mov	ebx,pHWLogDevCXOffset
	mov	edx,dwPenColor
	call	HW_LoadSolidPattern

RetSetPat:
	; The pattern to draw the interior of the rectangle with
	; has now been loaded. This could have been either the
	; brush or the pen. Now call the HW_DrawRectAndBorder routine.

	sub	esi,esi
	lgs	si,lpDstDev
	push	pHWLogDevCXOffset
	push	gs:[esi].DIBENGINEHDR.deBitsOffset
	push	gs:[esi].DIBENGINEHDR.deDeltaScan
	push	dwRop2

        ; pass in the clip rect as an argument
        sub	ebx,ebx
        mov	ecx,7FFF7FFFH
        cmp     ebx,lpClipRect
        je      @F
        sub	ecx,ecx
        lfs     cx,lpClipRect
        mov     ebx,dword ptr fs:[ecx].RECT.left
        mov     ecx,dword ptr fs:[ecx].RECT.right
@@:     push	ecx
	push	ebx

	; If lpPen is NULL, the border won't be drawn
	; in which case dwPenColor is irrelevant
	push	lpPen
	push	dwPenColor

        mov	ebx,dwBottomRight
        mov	eax,dwTopLeft
	push	ebx
	push	eax

	; Always bring in the bottom and right edge of the interior
	; of the rectangle by 1 pixel. If there is a border, then
	; bring in the left and top by 1 pixel as well.

        cmp     lpPen,0
        je      @F
        add     eax,10001H
@@:     sub     ebx,10001H

	push	dwDrawInterior
	push	ebx
	push	eax
	call	HW_DrawRectAndBorder

RectangleSuccess:
        mov     eax,1
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 1CH

GN_RectanglePunt:
        POPR    ds,esi,edi
        STOPPROC
PLABEL	Punt_Rectangle
        jmp     DIB_Output
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNPIXEL.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation
;
; File:         gnpixel.asm
;
; Purpose:      This file holds the Pixel display driver entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_Pixel
;
; Purpose:      This function is the Pixel display driver entry point.
;
; Arguments:    Pixel Display driver stack FRAME
;
; Returns:      If lpDrawMode is NULL then
;                       pixel value at coords wDstX,wDstY if succeesful
;                       80000000H is failure
;               If lpDrawMode is NOT NULL then
;                       00000001H is succeesful
;                       80000000H is failure
;
;==============================================================================
DECPROC GENERIC_Pixel, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wDstX
PARMW   wDstY
PARMD   dwPhysColor
PARMD   lpDrawMode
LOCALV  sPixel,DIB_Brush8
OPENPROC
        PUSHR   ds,esi,edi
        sub     esi,esi
        lgs     si,lpDstDev

        ; Punt old style bitmaps, Selected Dibs, and Mono Bitmaps
        movzx   eax,gs:[esi].DIBENGINE.deType
        movzx   ecx,gs:[esi].DIBENGINE.deFlags
        movzx   edx,gs:[esi].DIBENGINE.deBitsPixel
        mov     ebx,lpDrawMode
        or      eax,eax
        je      GN_PixelPunt
        test    ecx,SELECTEDDIB
        jnz     GN_PixelPunt
        cmp     edx,1
        je      GN_PixelPunt

        ; Switch on Get or Set
        or      ebx,ebx
        je      GN_GetPixel
        jmp     GN_SetPixel

GENERIC_Pixel   ENDP


;==============================================================================
;
; Functions:    Pixel ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of Pixel. You can either return a success code, a failure
;               code, punt to the DIBENG, etc.
;
; Arguments:    Pixel Display Driver Stack Frame
;
;==============================================================================
PUBLIC  GN_PixelPunt
GN_PixelPunt       PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
PLABEL	Punt_Pixel
        jmp     DIB_Pixel
GN_PixelPunt       ENDP

PUBLIC  GN_PixelDone
GN_PixelDone      PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 10H
GN_PixelDone      ENDP


;==============================================================================
;
; Function:     GN_SetPixel
;
; Purpose:      This function jumped to by the Pixel display driver entry
;               point when it is known the operation is to set a pixel.
;
; Arguments:    Display driver Pixel stack FRAME
;               gs:esi  lpDstDev
;               ecx     lpDstDev->deFlags
;
; Returns:      00000001H is succeesful
;               80000000H is failure
;
;==============================================================================
PUBLIC  GN_SetPixel
GN_SetPixel     PROC    NEAR

        ; We won't do a set into a non-VRAM bitmap since we don't want to
        ; have to handle all the different rops
        test    ch,VRAM / 256
        jz      GN_PixelPunt

        ; Check the screen for busy
        mov     ds,cs:[wFlatDataSel]
        mov     edi,cs:[CSpGNLogicalDevice]
        cmp     ds:[edi].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_PixelPunt

        ; Use the hardware specific rect functions to do this
        sub     edx,edx
        lfs     dx,lpDrawMode
        mov     edi,ds:[edi].GNLOGDEVCX.pHWLogdevCX
        movzx   ecx,fs:[edx].DRAWMODE.Rop2
        mov     eax,dword ptr wDstY
        mov	ebx,10001H
        mov     edx,dwPhysColor
        call    HW_SolidColorRectangle
        jmp     GN_PixelDone

GN_SetPixel     ENDP


;==============================================================================
;
; Function:     GN_GetPixel
;
; Purpose:      This function jumped to by the Pixel display driver entry
;               point when it is known the operation is to get a pixel.
;
; Arguments:    Display driver Pixel stack FRAME
;               gs:esi  lpDstDev
;               ecx     lpDstDev->deFlags
;
; Returns:      00000001H is succeesful
;               80000000H is failure
;
;==============================================================================
PUBLIC  GN_GetPixel
GN_GetPixel     PROC    NEAR
        ; If the pixel is in video memory, we must wait for idle
        test    ch,VRAM / 256
        jz      @F

        ; Check the screen for busy
        mov     ds,cs:[wFlatDataSel]
        mov     ebx,cs:[CSpGNLogicalDevice]
        cmp     ds:[ebx].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_PixelPunt
        push    cs:[CSlp16LogDevice]
        push    ebx
        push    ebx
        pushw   FB_ACCESS
        call    FFP16 PTR gs:[esi].DIBENGINE.deBeginAccess
@@:
        ; Compute the address of the pixel to get
        movzx   edx,wDstX
        movzx   ecx,gs:[esi].DIBENGINE.deBitsPixel
        movzx   eax,wDstY
        imul    edx,ecx
        imul    eax,gs:[esi].DIBENGINE.deDeltaScan
        shr     edx,3
        les     edi,fword ptr gs:[esi].DIBENGINE.deBits
        add     edx,eax
        add     edi,edx

        ; Fetch the pixel based upon the size
        mov     edx,0FF00H
        movzx   eax,byte ptr es:[edi]
        cmp     ecx,16
        jc      @F
        movzx   eax,word ptr es:[edi]
        jbe     @F
        mov     dx,word ptr es:[edi+2]
@@:
        ; If the pixel was in vram, call the end access function
        test    gs:[esi].DIBENGINE.deFlags,VRAM OR OFFSCREEN
        jz      GN_PixelDone
        push    cs:[CSlp16LogDevice]
        pushw   FB_ACCESS
        call    FFP16 PTR gs:[esi].DIBENGINE.deEndAccess
        jmp     GN_PixelDone

GN_GetPixel     ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNROBJ.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation
;
; File:       gnrobj.asm
;
; Purpose:    This file holds the RealizeObject display driver entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include	gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

DO_NOT_DITHER_16BPP_SOLID_BRUSHES       TEXTEQU <0>

OPENSEG  _DATA, USE16, DATA
EXTERNDEF                       szUserModuleName:BYTE
PUBLIC  szGDIModuleName
szGDIModuleName                 DB      'GDI',0

lfArray         LABEL   LogFont
LogFont         <-2048,0,0,0,400,0,0,0,0,0,0,0,18,'Times New Roman'>
LogFont         <-1000,0,0,0,400,0,0,0,0,2,0,1,0,'Arial'>
LogFont         <-228,108,0,0,700,0,0,0,0,0,0,2,0,'Arial'>
LogFont         <-169,0,0,0,400,0,0,0,0,4,0,0,32,'Tahoma'>
LogFont         <-96,0,0,0,400,0,0,0,0,0,0,1,34,'Arial'>
LogFont         <-88,44,0,0,700,0,0,0,0,0,0,2,0,'Arial'>
LogFont         <-86,0,0,0,400,0,0,0,0,0,0,0,18,'Times New Roman'>
LogFont         <-85,40,0,0,700,0,0,0,0,0,0,2,0,'Arial'>
LogFont         <-72,36,0,0,700,0,0,0,0,0,0,2,0,'Arial'>
LogFont         <-71,0,0,0,700,0,0,0,0,0,0,0,34,'Arial Narrow'>
LogFont         <-64,32,0,0,700,0,0,0,0,0,0,2,0,'Helvetica'>
LogFont         <-62,0,0,0,700,0,0,0,0,3,2,1,34,'Arial'>
LogFont         <-57,27,0,0,700,0,0,0,0,0,0,2,0,'Arial'>
LogFont         <-56,0,0,0,700,0,0,0,0,3,2,1,34,'Arial'>
LogFont         <-52,0,0,0,700,0,0,0,0,0,0,0,34,'Arial Narrow'>
LogFont         <-48,0,0,0,700,0,0,0,0,3,2,1,34,'Arial'>
LogFont         <-45,0,2700,2700,400,0,0,0,0,7,0,0,18,'Times New Roman'>
LogFont         <-40,0,3600,3600,400,0,0,0,0,7,0,0,18,'Times New Roman'>
LogFont         <-39,0,0,0,400,0,0,0,0,0,0,0,18,'Times New Roman'>
LogFont         <-37,0,3600,3600,700,0,0,0,0,7,0,0,34,'Arial'>
LogFont         <-35,0,0,0,400,0,0,0,0,0,0,0,34,'Arial'>
LogFont         <-33,0,0,0,400,0,0,0,0,0,0,0,18,'Times New Roman'>
LogFont         <-32,0,0,0,700,0,0,0,0,0,0,0,0,'Times New Roman'>
LogFont         <-31,0,0,0,400,0,0,0,0,3,2,1,34,'Arial'>
LogFont         <-30,0,0,0,400,0,0,0,0,0,0,0,34,'Arial'>
LogFont         <-29,0,0,0,400,0,0,0,0,0,0,0,18,'Times New Roman'>
LogFont         <-28,0,0,0,400,0,0,0,0,3,2,1,34,'Arial'>
LogFont         <-27,0,0,0,700,0,0,0,0,0,0,2,34,'Arial'>
LogFont         <-26,0,0,0,400,0,0,0,2,0,0,0,2,'Marlett'>
LogFont         <-25,0,0,0,400,0,0,0,0,0,0,0,18,'Times New Roman'>
LogFont         <-24,12,0,0,700,0,0,0,0,0,0,2,0,'Helvetica'>
LogFont         <-23,0,0,0,700,0,0,0,0,4,0,0,34,'Arial'>
LogFont         <-22,0,0,0,700,0,0,0,0,4,0,0,34,'Arial'>
LogFont         <-21,0,0,0,400,0,0,0,0,0,0,0,18,'Times New Roman'>
LogFont         <-20,0,0,0,400,0,0,0,0,0,0,2,34,'Arial'>
LogFont         <-19,0,0,0,700,0,0,0,1,4,0,2,0,'verdana'>
LogFont         <-18,0,0,0,700,0,0,0,0,0,0,2,0,'Arial'>
LogFont         <-17,0,0,0,700,0,0,0,0,0,0,2,34,'Arial'>
LogFont         <-16,0,0,0,400,0,0,0,0,0,0,0,0,'Arial'>
LogFont         <-15,9,0,0,700,0,0,0,0,0,2,2,2,'MS Sans Serif'>
LogFont         <-14,0,0,0,400,0,0,0,0,0,0,0,18,'Times New Roman'>
LogFont         <-13,0,0,0,700,1,0,0,0,4,0,2,0,'arial'>
LogFont         <-12,0,0,0,400,0,0,0,0,5,0,1,0,'Arial'>
LogFont         <-11,0,0,0,700,0,0,0,0,0,0,0,0,'MS Sans Serif'>
LogFont         <-10,0,0,0,400,0,0,0,0,0,0,0,0,'Times New Roman'>
LogFont         <-9,0,0,0,0,0,0,0,0,4,0,2,34,'Small Fonts'>
LogFont         <-8,0,0,0,400,0,0,0,0,0,0,0,0,'MS Sans Serif'>
LogFont         <-7,0,0,0,400,0,0,0,0,3,2,1,34,'Small Fonts'>
LogFont         <-6,0,0,0,400,0,0,0,0,0,0,0,34,'MS Sans Serif'>
LogFont         <-5,0,0,0,400,0,0,0,0,0,0,0,0,'MS Sans Serif'>
LogFont         <-4,0,0,0,700,0,0,0,0,0,0,1,18,'Times New Roman'>
LogFont         <-3,0,900,900,400,0,0,0,0,7,0,0,18,'Times New Roman'>
LogFont         <-2,0,0,0,700,0,0,0,0,0,0,0,32,'\0'>
LogFont         <-1,0,0,0,400,0,0,0,0,4,0,0,18,'Times New Roman'>
LogFont         <0,10,0,0,1000,0,0,0,0,0,0,0,0,'System'>
LogFont         <1,0,900,900,400,0,0,0,0,7,0,0,18,'Times New Roman'>
LogFont         <2,0,0,0,400,0,0,0,2,0,0,0,0,'MARLETT'>
LogFont         <3,1,0,0,700,0,0,0,0,4,2,2,34,'System'>
LogFont         <4,0,0,0,400,0,0,0,2,0,0,0,0,'MARLETT'>
LogFont         <5,0,3600,3600,400,0,0,0,0,7,0,0,18,'Times New Roman'>
LogFont         <6,0,0,0,400,0,0,0,0,0,0,0,0,'MS Sans Serif'>
LogFont         <7,0,0,0,400,0,0,0,2,0,0,0,0,'MARLETT'>
LogFont         <8,0,3600,3600,400,1,0,0,0,7,0,0,18,'Times New Roman'>
LogFont         <9,0,0,0,400,0,0,0,2,0,0,0,0,'MARLETT'>
LogFont         <10,0,0,0,400,0,0,0,2,0,0,0,0,'MARLETT'>
LogFont         <11,0,0,0,700,0,0,0,0,2,0,2,2,'AdobeSm'>
LogFont         <12,0,0,0,400,0,0,0,2,0,0,0,0,'MARLETT'>
LogFont         <13,0,0,0,400,0,0,0,2,0,0,0,0,'MARLETT'>
LogFont         <14,0,3600,3600,400,0,0,0,0,7,0,0,34,'Arial'>
LogFont         <15,0,0,0,400,0,0,0,2,0,0,0,0,'MARLETT'>
LogFont         <16,0,0,0,500,0,0,0,0,4,0,2,0,'Times New Roman'>
LogFont         <17,0,0,0,400,0,0,0,2,0,0,0,0,'MARLETT'>
LogFont         <18,0,0,0,400,0,0,0,2,0,0,0,0,'MARLETT'>
LogFont         <19,0,3600,3600,700,0,0,0,0,7,0,0,34,'Arial'>
LogFont         <21,0,3600,3600,400,1,0,0,0,7,0,0,18,'Times New Roman'>
LogFont         <22,0,3600,3600,700,0,0,0,0,7,0,0,18,'Times New Roman'>
LogFont         <24,0,3600,3600,400,0,0,0,0,7,0,0,34,'Arial'>
LogFont         <25,0,3600,3600,700,0,0,0,0,7,0,0,34,'Arial'>
LogFont         <26,0,3600,3600,400,0,0,0,0,7,0,0,34,'Arial'>
LogFont         <27,0,3600,3600,400,0,0,0,0,7,0,0,18,'Times New Roman'>
LogFont         <29,0,3600,3600,700,0,0,0,0,7,0,0,34,'Arial'>
LogFont         <46,0,3600,3600,700,0,0,0,0,7,0,0,34,'Arial'>
LogFont         <50,0,0,0,800,1,0,0,1,0,0,2,32,'Arial'>
LogFont         <-10000,0,0,0,0,0,0,0,0,0,0,0,0,'\0'>


szAllChars      LABEL   BYTE
                DW        0,  1,  2,  3,  4,  5,  6,  7,  8,  9
                DW       10, 11, 12, 13, 14, 15, 16, 17, 18, 19
                DW       20, 21, 22, 23, 24, 25, 26, 27, 28, 29
                DW       30, 31, 32, 33, 34, 35, 36, 37, 38, 39
                DW       40, 41, 42, 43, 44, 45, 46, 47, 48, 49
                DW       50, 51, 52, 53, 54, 55, 56, 57, 58, 59
                DW       60, 61, 62, 63, 64, 65, 66, 67, 68, 69
                DW       70, 71, 72, 73, 74, 75, 76, 77, 78, 79
                DW       80, 81, 82, 83, 84, 85, 86, 87, 88, 89
                DW       90, 91, 92, 93, 94, 95, 96, 97, 98, 99
                DW      100,101,102,103,104,105,106,107,108,109
                DW      110,111,112,113,114,115,116,117,118,119
                DW      120,121,122,123,124,125,126,127,128,129
                DW      130,131,132,133,134,135,136,137,138,139
                DW      140,141,142,143,144,145,146,147,148,149
                DW      150,151,152,153,154,155,156,157,158,159
                DW      160,161,162,163,164,165,166,167,168,169
                DW      170,171,172,173,174,175,176,177,178,179
                DW      180,181,182,183,184,185,186,187,188,189
                DW      190,191,192,193,194,195,196,197,198,199
                DW      200,201,202,203,204,205,206,207,208,209
                DW      210,211,212,213,214,215,216,217,218,219
                DW      220,221,222,223,224,225,226,227,228,229
                DW      230,231,232,233,234,235,236,237,238,239
                DW      240,241,242,243,244,245,246,247,248,249
                DW      250,251,252,253,254,255
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
PUBLIC  lpfnUserGetDC, lpfnUserReleaseDC, lpfnGDICreateFontIndirect
PUBLIC  lpfnGDISelectObject, lpfnGDIDeleteObject, lpfnGDIExtTextOut
PUBLIC  dwFontInited
lpfnUserGetDC                   DD      0
lpfnUserReleaseDC               DD      0
lpfnGDICreateFontIndirect       DD      0
lpfnGDISelectObject             DD      0
lpfnGDIDeleteObject             DD      0
lpfnGDIExtTextOut               DD      0
dwFontInited                    DD      0


;==============================================================================
;
; Function:     GENERIC_RealizeObject
;
; Purpose:      This function is the display driver RealizeObject entry point.
;
; Arguments:    RealizeObject Display driver stack FRAME
;
; Returns:      For Object Creation
;               If lpOut is NULL
;                       return the size in bytes of the phys object whose
;                       type is given by wStyle
;               If lpOut is not NULL
;                       for solid brushes to a mono device --   ax = 8001H
;                       for solid brushes to a color device --  ax = 8002H
;                       for bitmaps                             ax = 1
;                       for everything else that is a succes -- ax = 8000H
;                       If unsuccessful                         ax = 0000H
;
;               For Object Deletion
;                       for a success                           ax = 1
;                       for a failure                           ax = 0
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_RealizeObject, PASCAL, NOFRAME, FAR16
OPENPROC
        ; Convert to the DIB_RealizeObjectExt stack FRAME
        pop     eax
        push    dword ptr cs:[CSlp16LogDevice]
        push    eax
        jmp	GN_RealizeObjectExt
CLOSEPROC

;==============================================================================
;
; Function:     GN_RealizeObjectExt
;
; Purpose:      This function is jumped to by the the display driver
;               GENERIC_RealizeObject entry point after the additional
;               parameter (the PDEVICE) is added to the parameter list.
;
; Arguments:    RealizeObjectExt Display Driver Stack Frame
;
; Returns:      If lpOut is NULL
;                       return the size in bytes of the phys object whose
;                       type is given by wStyle
;               If lpOut is not NULL
;                       for solid brushes to a mono device --   ax = 8001H
;                       for solid brushes to a color device --  ax = 8002H
;                       for everything else that is a succes -- ax = 8000H
;                       If unsuccessful                         ax = 0000H
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_RealizeObjectExt, PASCAL, FRAME, FAR16
PARMD   lpDevice
PARMW   wStyle
PARMD   lpIn
PARMD   lpOut
PARMD   lpXForm
PARMD   lpPDevice
OPENPROC
        PUSHR   ds,esi,edi

        ; Dispatch based upon style
        movsx   eax,wStyle
        cmp     eax,2
        je      GN_RealizeObjectExtBrush
        cmp     eax,5
        je      GN_RealizeObjectExtBitmap
        cmp     eax,-5
        je      GN_RealizeObjectExtDeleteBitmap
        cmp     eax,3
        je      GN_RealizeObjectExtFont

        ; Pin: DIBENG doesn't handle DeleteObject anyway
        test    eax, eax
        js      GN_RealizeObjectExtSuccess
        .errnz  $ - OFFSET GN_RealizeObjectExtPunt

GN_RealizeObjectExt     ENDP


;==============================================================================
;
; Function:     RealizeObjectExt ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of RealizeObjectExt. You can either return a success code,
;               a failure code, punt to the DIBENG, etc.
;
; Arguments:    RealizeObjectExt Display Driver Stack Frame
;
;==============================================================================
PUBLIC  GN_RealizeObjectExtPunt
GN_RealizeObjectExtPunt   PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
PLABEL	Punt_RealizeObjectExt
        jmp     DIB_RealizeObjectExt
GN_RealizeObjectExtPunt   ENDP

; NOTE: This routine is not a place to jump for everything. Some of the
; RealizeObjectExt flavors must return specific success codes -- not
; just a 1. See the main header in this file for more info.
PUBLIC  GN_RealizeObjectExtSuccess
GN_RealizeObjectExtSuccess   PROC         NEAR
        mov     eax,1
        .errnz  $ - OFFSET GN_RealizeObjectExtDone
GN_RealizeObjectExtSuccess   ENDP

PUBLIC  GN_RealizeObjectExtDone
GN_RealizeObjectExtDone   PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 16H
GN_RealizeObjectExtDone   ENDP


;==============================================================================
;
; Function:     GN_RealizeObjectExtBrush
;
; Purpose:      This function gets jumped to from RealizeObjectExt when
;               the object is known to be a brush. We need to do two
;               things in here.
;               1) If the brush is a color pattern and it is located in
;                  Video Memory, then we must wait for the graphics engine
;                  to go idle since the bitmap may not yet be drawn.
;               2) We normally let the DIBENG realize brushes. However,
;                  in 16bpp mode, the DIBENG will dither solid brushes
;                  that are not an exact color match. We prevent this by
;                  realizing solid brushes ourselves in 16bpp mode.
;
; Arguments:    RealizeObjectExt Display Driver Stack Frame
;
; Returns:      jump to one of the RealizeObjectExt ending routines
;               when you are done
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  GN_RealizeObjectExtBrush
GN_RealizeObjectExtBrush  PROC    NEAR

        ; We will be needing these
        sub     edi,edi
        les     di,lpDevice
        sub     esi,esi
        lds     si,lpIn

	; Check for ICM
	xor	eax,eax
	cmp     ds:[esi].LogBrush.lbhcmXform,eax
	jne     GN_RealizeObjectExtPunt

        ; Check for a solid brush
        cmp     ds:[esi].LogBrush.lbStyle,BS_SOLID
        je      SolidWorry

NonSolidWorry:
        ; If it is only a sizing call, then pass it on
        cmp     lpOut,0
        je      GN_RealizeObjectExtPunt

        xor     eax,eax
        cmp     cs:[dwFontInited], eax
        jle     @F
        call    GN_LoadAndInitFonts
@@:
        ; Check for color pattern brushes
        cmp     ds:[esi].LogBrush.lbStyle,BS_PATTERN
        jne     GN_RealizeObjectExtPunt

        ; Punt NULL bitmap ptrs
        sub     eax,eax
        cmp     eax,ds:[esi].LogBrush.lbColor
        je      GN_RealizeObjectExtPunt

        ; Punt any bitmaps which are definitely not in VRAM
        lds     si,ds:[esi].LogBrush.lbColor
        cmp     ax,ds:[esi].DIBENGINE.deType
        je      GN_RealizeObjectExtPunt
        test    ds:[esi].DIBENGINE.deFlags,VRAM OR OFFSCREEN
        jz      GN_RealizeObjectExtPunt

        ; Must wait for idle
        xor     edi,edi                 ; clear high word of EDI
        les     di,cs:[CSlp16LogDevice]
        push    cs:[CSlp16LogDevice]
        push    eax
        push    eax
        pushw   FB_ACCESS
        call    FFP16 PTR es:[edi].DIBENGINE.deBeginAccess
        jmp     GN_RealizeObjectExtPunt

SolidWorry:
IF  (DO_NOT_DITHER_16BPP_SOLID_BRUSHES NE 0)
        ; Check for 16bpp
        cmp     es:[edi].DIBENGINE.deBitsPixel,10H
        jne     GN_RealizeObjectExtPunt

        ; Handle the sizing call, also
        mov     ecx,lpOut
        mov     eax,52H
        or      ecx,ecx
        je      GN_RealizeObjectExtDone

        ; Realize a solid brush without dithering
        movzx   edx,es:[edi].DIBENGINE.deFlags
        xor     edi,edi                 ; clear high word of EDI
        les     di,lpOut
        movzx   eax,ds:[esi].LogBrush.lbStyle
        mov     ebx,ds:[esi].LogBrush.lbColor
        mov     es:[edi].DIB_Brush16.dp16BrushStyle,ax
        mov     dword ptr es:[edi].DIB_Brush16.dp16FgColor,ebx
        movzx   eax,ds:[esi].LogBrush.lbHatch
        mov     ecx,dword ptr ds:[esi].LogBrush.lbBkColor
        mov     word ptr es:[edi].DIB_Brush16.dp16Hatch,ax
        mov     dword ptr es:[edi].DIB_Brush16.dp16BgColor,ecx

        ; To be comatible with the DIBENG, we must place
        ; 1) the RGB color in the dp16BrushMono field
        ; 2) the lpXForm argument in the dp16BrushMono+4 field
        ; 3) Use 14H for the BPP for 5-6-5 and 10H for BPP for 5-5-5
        mov     eax,lpXForm
        mov     dword ptr es:[edi].DIB_Brush16.dp16BrushMono,ebx
        mov     dword ptr es:[edi + 4].DIB_Brush16.dp16BrushMono,eax
        mov     ecx,0403H
        mov     eax,01000h+COLORSOLID
        test    edx,FIVE6FIVE
        jz      @F
        mov     ecx,0202H
        mov     eax,01400h+COLORSOLID
@@:     mov     dword ptr es:[edi].DIB_Brush16.dp16BrushFlags,eax

        ; This code is functionally equivalent to the DIBENG
        ; Convert 24bpp RGB (8-8-8) to 16bpp (5-6-6) or 15bpp (5-5-5)
        sub     edx,edx
        mov     dl,bl
        sub     dl,04
        cmc
        sbb     al,al
        and     dl,al
        shl     dx,05

        mov     dl,bh
        sub     dl,ch
        cmc
        sbb     al,al
        and     dl,al
        shr     dx,cl

        shr     ebx,10H
        sub     bl,04
        cmc
        sbb     al,al
        and     bl,al

        shl     ebx,18H
        shld    edx,ebx,05

        mov     bx,dx
        shl     edx,16
        mov     dx,bx
        mov     dword ptr es:[edi].DIB_Brush16.dp16BrushBits,edx
        mov     eax,8002h
        jmp     GN_RealizeObjectExtDone
ELSE
        jmp     GN_RealizeObjectExtPunt
ENDIF

GN_RealizeObjectExtBrush  ENDP


;==============================================================================
;
; Function:     GN_RealizeObjectExtBitmap
;
; Purpose:      This function gets jumped to from RealizeObjectExt when
;               the object is known to be a bitmap. We need to either
;               size the bitmap or create a bitmap header.
;
; Arguments:    RealizeObjectExt Display Driver Stack Frame
;
; Returns:      If sizing call (lpOut is NULL)
;                       dx:ax   number of bytes for header + bits
;               else
;                       fill in bitmap header pointed to by lpOut
;                       ax = 1
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  GN_RealizeObjectExtBitmap
GN_RealizeObjectExtBitmap PROC    NEAR

        ; Load all these up.
        mov     ecx,lpOut
        sub     edi,edi
        les     di,lpIn

        ; Split into a sizing or a creation call
        or      ecx,ecx
        jne     create

        movzx   eax,es:[edi].DIBENGINE.deWidthBytes
        movzx   edx,es:[edi].DIBENGINE.deHeight
        add     eax,3
        and     eax,NOT 3
        imul    eax,edx
        add     eax,SIZE DEVBMP
        shld    edx,eax,10H
        jmp     GN_RealizeObjectExtDone

create:
        ; Build the generic portions of the DEVBMP header
        mov	ds,cs:[wFlatDataSel]
        mov	esi,cs:[CSpGNLogicalDevice]
        mov     eax,dword ptr es:[edi].DIBENGINE.deWidth
        mov     edx,dword ptr es:[edi].DIBENGINE.deWidthBytes
        les     di,lpOut
        mov     es:[edi].DIBENGINE.deType,5250H
        mov     dword ptr es:[edi].DIBENGINE.deWidth,eax
        mov     dword ptr es:[edi].DIBENGINE.deWidthBytes,edx
        mov     eax,cs:[CSlp16LogDevice]
        mov     cx,ds:[esi].DIBENGINE.deVersion
        mov     es:[edi].DIBENGINE.delpPDevice,eax
        mov     es:[edi].DIBENGINE.deVersion,cx
        mov     ax,ds:[esi].DIBENGINEHDR.deBitsSelector
        mov     ecx,ds:[esi].DIBENGINE.deBitmapInfo
        mov     es:[edi].DIBENGINEHDR.deBitsSelector,ax
        mov     es:[edi].DIBENGINE.deBitmapInfo,ecx
        mov     eax,ds:[esi].DIBENGINE.deBeginAccess
        mov     ecx,ds:[esi].DIBENGINE.deEndAccess
        mov     es:[edi].DIBENGINE.deBeginAccess,eax
        mov     es:[edi].DIBENGINE.deEndAccess,ecx

        ; Have to get the flags right.
        movzx   eax,es:[edi].DIBENGINE.deBitsPixel
        mov     es:[edi].DIBENGINEHDR.bRealBpp,al
        mov     ebx,MINIDRIVER OR PALETTIZED
        cmp     eax,10H
        jc      @F
        mov     ebx,MINIDRIVER
        ja      @F
        or      ebx,ds:[esi].GNLOGDEVCX.dw16BppFormat
        test    ebx,FIVE6FIVE
        jnz     @F
        mov     es:[edi].DIBENGINEHDR.bRealBpp,0FH
@@:     mov     es:[edi].DIBENGINEHDR.deFlags,bx

        ; Decide whether to put the bitmap in video memory.
        ; Block if hardware is busy, a DOS box is open, or the
        ; bitmap is to small to make it worthwhile.
        mov	eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        test    ds:[eax].GNBOARDCX.dwOffscreenFlags,NO_OFFS_BMPS
        jnz     regbmp
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
        jne     regbmp
        cmp     es:[edi].DIBENGINEHDR.deHeight,1
        je	regbmp
        cmp     es:[edi].DIBENGINEHDR.deWidth,10H
        jg	@F
        cmp     es:[edi].DIBENGINEHDR.deHeight,10H
        jle	regbmp
        cmp     es:[edi].DIBENGINEHDR.deBitsPixel,08H
        je      @F
        cmp     es:[edi].DIBENGINEHDR.deBitsPixel,10H
        je	@F
        cmp     es:[edi].DIBENGINEHDR.deBitsPixel,20H
        jne	regbmp
@@:
     	push	eax
        call    GN_OffscreenBitmapCreate
        or      eax,eax
        jne     GN_RealizeObjectExtSuccess

regbmp:
        and     es:[edi].DIBENGINE.deFlags,NOT (VRAM OR OFFSCREEN)
        movzx   eax,es:[edi].DIBENGINE.deWidthBytes
        add     eax,3
        and     al,NOT 3
        mov     es:[edi].DIBENGINE.deDeltaScan,eax
        mov     eax,SIZE DEVBMP
        mov     cx,word ptr lpOut+2
        mov     dword ptr es:[edi].DIBENGINE.deBits,eax
        mov      word ptr es:[edi].DIBENGINE.deBits+4,cx
        sub     eax,eax
        mov     es:[edi].DIBENGINE.deBeginAccess,eax
        mov     es:[edi].DIBENGINE.deEndAccess,eax
        jmp     GN_RealizeObjectExtSuccess

GN_RealizeObjectExtBitmap       ENDP


;==============================================================================
;
; Function:     GN_RealizeObjectExtDeleteBitmap
;
; Purpose:      This function gets jumped to from RealizeObjectExt when
;               the action is to delete a bitmap.
;
; Arguments:    RealizeObjectExt Display Driver Stack Frame
;
; Returns:      eax     1
;               edx     0
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  GN_RealizeObjectExtDeleteBitmap
GN_RealizeObjectExtDeleteBitmap PROC    NEAR

        ; If it is only a sizing call, then pass it on. This case shouldn't
        ; happen, but it appears that GDI sometimes passes this case to us.
        cmp     lpOut,0
        je      GN_RealizeObjectExtPunt

	; Load up the DIBENGINEHDR for the bitmap we are deleting
        sub     edi,edi
        les     di,lpOut

        movzx   eax,es:[edi].DIBENGINE.deFlags
        test    eax,VRAM
        jz      GN_RealizeObjectExtSuccess

	; Load up our context
	sub	eax,eax
        mov	ax,cs:[wFlatDataSel]

        ; Is this even a valid selector?
        lar     edx,eax
        jnz     GN_RealizeObjectExtSuccess

        ; The selector must be PRESENT, RING3, DATA
        and     dh,NOT 7
        cmp     dh,0F0H
        jne     GN_RealizeObjectExtSuccess

	mov	ds,ax
        mov	esi,cs:[CSpGNLogicalDevice]

	push	ds:[esi].GNLOGDEVCX.pGNBoardCX
	pushd	0
        call    GN_OffscreenBitmapDelete
        jmp     GN_RealizeObjectExtSuccess

GN_RealizeObjectExtDeleteBitmap ENDP


;==============================================================================
;
; Function:     GN_RealizeObjectExtFont
;
; Purpose:      This function gets jumped to from RealizeObjectExt when
;               the action is to realize a font.
;
; Arguments:    RealizeObjectExt Display Driver Stack Frame
;
; Returns:      Nothing
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  GN_RealizeObjectExtFont
GN_RealizeObjectExtFont         PROC    NEAR

        xor     eax,eax
        cmp     cs:[dwFontInited], eax
        jne     GN_RealizeObjectExtDone
        mov     ds,cs:[wNVTEXT32_Alias_In_NVTEXT32]
        inc     eax
        mov     ds:[dwFontInited], eax
        dec     eax
        jmp     GN_RealizeObjectExtDone

GN_RealizeObjectExtFont         ENDP


;==============================================================================
;
; Function:     GN_InitFunctionPtr
;
; Purpose:      This function returns the function ptr inside the 
;               windows module
;
; Arguments:    eax     ptr to the name of the windows module
;               esi     ORDINAL no of the function
;
; Returns:      eax     16:16 ptr to the requested function
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_InitFunctionPtr, PASCAL, NOFRAME, NEAR
OPENPROC
        push    eax
        call    GetModuleHandle
        and     eax, 0ffffh
        jz      Done
        push    ax
        push    esi
        call    GetProcAddress
        shl     edx, 10H
        mov     dx, ax
        mov     eax, edx
Done:
CLOSEPROC


USER_GETDC_ORDINAL              EQU     66
USER_RELEASEDC_ORDINAL          EQU     68
GDI_CREATEFONTINDIRECT_ORDINAL  EQU     57
GDI_SELECTOBJECT_ORDINAL        EQU     45
GDI_DELETEOBJECT_ORDINAL        EQU     69
GDI_EXTTEXTOUT_ORDINAL          EQU     351


;==============================================================================
;
; Function:     GN_LoadAndInitFonts
;
; Purpose:      This function realizes many common fonts at once
;
; Arguments:    none
;
; Returns:      eax
;
; Preserve:     ds,es,esi,edi,esp
;==============================================================================
DECPROC GN_LoadAndInitFonts, PASCAL, FRAME, NEAR
LOCALV  rcClip,RECT
LOCALW  hDC
OPENPROC
        PUSHR   ds,es,esi,edi,esp
        mov     ax,_DATA
        mov     es,ax
        mov     ds,cs:[wNVTEXT32_Alias_In_NVTEXT32]
        mov     eax,0ffffffffh
        mov     ds:[dwFontInited], eax
        mov     eax,_DATA
        shl     eax,10H
        mov     ax,OFFSET szUserModuleName
        push    eax
        mov     esi, USER_GETDC_ORDINAL
        call    GN_InitFunctionPtr
        test    eax,eax
        jz      InitDone
        mov     ds:[lpfnUserGetDC],eax
        pop     eax
        push    eax
        mov     esi, USER_RELEASEDC_ORDINAL
        call    GN_InitFunctionPtr
        test    eax,eax
        jz      InitDone
        mov     ds:[lpfnUserReleaseDC],eax
        pop     eax

        mov     ax,OFFSET szGDIModuleName
        push    eax
        mov     esi, GDI_CREATEFONTINDIRECT_ORDINAL
        call    GN_InitFunctionPtr
        test    eax,eax
        jz      InitDone
        mov     ds:[lpfnGDICreateFontIndirect],eax
        pop     eax
        push    eax
        mov     esi, GDI_SELECTOBJECT_ORDINAL
        call    GN_InitFunctionPtr
        test    eax,eax
        jz      InitDone
        mov     ds:[lpfnGDISelectObject],eax
        pop     eax
        push    eax
        mov     esi, GDI_DELETEOBJECT_ORDINAL
        call    GN_InitFunctionPtr
        test    eax,eax
        jz      InitDone
        mov     ds:[lpfnGDIDeleteObject],eax
        pop     eax
        push    eax
        mov     esi, GDI_EXTTEXTOUT_ORDINAL
        call    GN_InitFunctionPtr
        test    eax,eax
        jz      InitDone
        mov     ds:[lpfnGDIExtTextOut],eax
        xor     eax, eax
        push    ax
        call    FFP16 PTR ds:[lpfnUserGetDC]
        test    ax,ax
        jz      InitDone
        mov     hDC, ax
        xor     eax,eax
        mov     dword ptr rcClip.RECT.left, eax
        mov     dword ptr rcClip.RECT.right, eax
        mov     ax,_DATA
        mov     ds,ax
        mov     si,ax
        shl     esi,10H
        mov     si,OFFSET lfArray
        mov     edi, esi
        mov     di,OFFSET szAllChars

InitNextFont:
        cmp     [si].LogFont.lfHeight,-10000
        je      DoReleaseDC
        push    esi
        call    FFP16 PTR cs:[lpfnGDICreateFontIndirect]
        test    ax, ax
        jz      DoReleaseDC
        push    ax                                  ; for delete object later

        push    hDC
        push    ax
        call    FFP16 PTR cs:[lpfnGDISelectObject]
        push    hDC                                 ; for select oldfont later
        push    ax

        ; ExtTextOut (hDC, X, Y, fuOptions, lpClipRect, lpString, wCount, lpDX)
        push    hDC
        xor     ebx,ebx
        push    ebx
        mov     eax, 4
        push    ax                                  ; fuOptions=ETO_CLIPPED
        mov     ax,ss
        shl     eax,10H
        lea     ax, rcClip
        push    eax                                 ; lpClip
        push    edi                                 ; szAllChars
        mov     eax, 256
        push    ax
        push    ebx                                 ; lpDX=NULL
        call    FFP16 PTR cs:[lpfnGDIExtTextOut]

        call    FFP16 PTR cs:[lpfnGDISelectObject]  ; select oldfont
        call    FFP16 PTR cs:[lpfnGDIDeleteObject]  ; remove new hfont on stack
        add     si,SIZE LogFont
        jmp     InitNextFont


DoReleaseDC:
        xor     eax, eax
        push    ax
        push    hDC
        call    FFP16 PTR cs:[lpfnUserReleaseDC]

InitDone:
        pop     eax
Done:

        POPR    ds,es,esi,edi,esp
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNSCAN.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnscan.asm
;
; Purpose:      This file holds the Output display driver implementation
;               when the style is either OS_SCANLINE, OS_POLYSCANLINE,
;               OS_BEGINNSCAN, or OS_ENDNSCAN.
;               The Output entry point jumps to here without creating a
;               FRAME when it is discovered that the style is one of
;               these four.
;
;==============================================================================
.586
incOutput = 1
incLogical = 1
incPolyScanline = 1
incDrawMode = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc


EXTERNDEF       GENERIC_BeginScan:FAR16
EXTERNDEF       GENERIC_EndScan:FAR16

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_BeginScan
;
; Purpose:      The Output entry point jumps to here without creating a
;               FRAME when it is discovered that the Output style is
;               OS_BEGINNSCAN.
;
; Arguments:    Output Display Driver Stack Frame
;
; Returns:      ax      1       success
;                       0       failure
;                       -1      have GDI simulate
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_BeginScan, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wStyle
PARMW   wCount
PARMD   lpPoints
PARMD   lpPen
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   lpClipRect
LOCALD  dwRop2
LOCALD  pHWLogDevCXOffset
OPENPROC
        PUSHR   ds,esi,edi

        ; Get a ptr to the logical device context
        mov     ds,cs:[wFlatDataSel]
        mov     edi,cs:[CSpGNLogicalDevice]

        ; Get a ptr to the dst bitmap
        mov     gs,word ptr lpDstDev+2
        movzx   esi,word ptr lpDstDev+0

        ; Keep track of the fact that we are in a BeginScan
        mov     ds:[edi].GNLOGDEVCX.bInScanSequence,1

        ; Load dst flags and prep some registers
        sub     ebx,ebx
        movzx   eax,gs:[esi].DIBENGINE.deFlags

        ; Filter out old style destinations
        cmp     bx,gs:[esi].DIBENGINE.deType
        je      GN_BeginScanPunt

        ; Filter out based upon deFlags
        test    ah,VRAM / 256
        jz      GN_BeginScanPunt
        test    ah,PALETTE_XLAT / 256
        jnz     GN_BeginScanPunt

        ; Watch for busy hardware -- some other API owns the screen
        cmp     ebx,ds:[edi].GNLOGDEVCX.dwHardwareBusy
        jne     GN_BeginScanPunt

        ; If both the pen and brush are null, then we are done!
        ; The only way the two ptrs can be equal is if they are
        ; both NULL!
        mov     eax,lpBrush
        cmp     eax,lpPen
        je      BeginScanHollow

        ; Load up the drawmode ptr
        sub     ecx,ecx
        lfs     cx,lpDrawMode

	; Save off the hwlogdev for later
        mov     edx,ds:[edi].GNLOGDEVCX.pHWLogdevCX
	mov     pHWLogDevCXOffset,edx

        ; Get the rop
        movzx   edx,fs:[ecx].DRAWMODE.Rop2
        mov     dwRop2,edx

        ; Is there a brush?
        or	eax,eax
        je      UsePen

UseBrush:
        ; If the brush is hollow, then even if the rop only involves
        ; the dst (like BLACKNESS, WHITENESS, or INVERTDST), we blow
        ; off doing the output calls whatever they are. This sounds
        ; wierd but it is WHQL-correct behavior.
        sub     esi,esi
        les     si,lpBrush
        cmp     es:[esi].DIB_Brush8.dp8BrushStyle,BS_HOLLOW
        je      BeginScanHollow

        ; It is not a hollow brush. If the rop only involves the
        ; dst (no pattern involvement), then skip the pattern load.
        dec     edx
        je      RetSetPat
        cmp     edx,05H
        je      RetSetPat
        cmp     edx,0AH
        je      RetSetPat
        cmp     edx,0FH
        je      RetSetPat

        ; Load up the pattern
        mov     cl,byte ptr es:[esi].DIB_Brush8.dp8BrushStyle
        mov     al,byte ptr es:[esi].DIB_Brush8.dp8BrushFlags
        mov     edx,dword ptr es:[esi].DIB_Brush8.dp8BrushBits
        mov     ebx,pHWLogDevCXOffset
        PUSH    OFFSET RetSetPat
        cmp     cl,BS_HOLLOW
        jnc     @F
        test    al,COLORSOLID
        jz      HW_LoadColorPattern
        jmp     HW_LoadSolidPattern
@@:     cmp     cl,BS_PATTERN
        jc      IsHatch
        ja      GN_BitBltFail
        test    al,PATTERNMONO
        jz      HW_LoadColorPattern
IsMono:
        sub     edx,edx
        lfs     dx,lpDrawMode
	lea	esi,[esi].DIB_Brush16.dp16BrushMono
        mov     ecx,fs:[edx].DRAWMODE.TextColor
        mov     edx,fs:[edx].DRAWMODE.bkColor
        mov     eax,-1
        jmp     HW_LoadMonoPattern
IsHatch:
        sub     edx,edx
        lfs     dx,lpDrawMode
        cmp     fs:[edx].DRAWMODE.bkMode,TRANSPARENT
        sete    al
        cmp     al,1
        sbb     eax,eax
	mov     ecx,es:[esi].DIB_Brush8.dp8BgColor
        mov     edx,es:[esi].DIB_Brush8.dp8FgColor
	lea	esi,[esi].DIB_Brush16.dp16BrushMask
        jmp     HW_LoadMonoPattern

UsePen:
	sub	ebx,ebx
        les     bx,lpPen
        cmp     es:[ebx].DIB_Pen.dpPenStyle,LS_SOLID
        jne     BeginScanHollow
        mov     edx,es:[ebx].DIB_Pen.dpPenColor
        mov     ebx,pHWLogDevCXOffset
        call    HW_LoadSolidPattern
        jmp     RetSetPat

BeginScanHollow:
        mov     ds:[edi].GNLOGDEVCX.bHollowBrushForScan,1
        jmp     BeginScanSuccess

GN_BeginScanPunt:
        mov     ds:[edi].GNLOGDEVCX.bPuntingScan,1
        POPR    ds,esi,edi
        STOPPROC
PLABEL	Punt_BeginScan
        jmp     DIB_Output

RetSetPat:
        ; We are not punting Scanlines AND they are not hollow
        mov     edi,cs:[CSpGNLogicalDevice]
	movzx	esi,word ptr lpDstDev
        mov     ds:[edi].GNLOGDEVCX.bPuntingScan,0
        mov     ds:[edi].GNLOGDEVCX.bHollowBrushForScan,0

        ; Call the hardware begin rect routine
        sub	ebx,ebx
        mov	ecx,7FFF7FFFH
        mov     edi,ds:[edi].GNLOGDEVCX.pHWLogdevCX
        cmp     lpClipRect,0
        je      @F
        lfs     cx,lpClipRect
        mov     ebx,dword ptr fs:[ecx].RECT.left
        mov     ecx,dword ptr fs:[ecx].RECT.right
@@:
	push	pHWLogDevCXOffset
	push	gs:[esi].DIBENGINEHDR.deBitsOffset
	push	gs:[esi].DIBENGINEHDR.deDeltaScan
	push	dwRop2
	push	ecx
	push	ebx
        call    HW_BeginRect

BeginScanSuccess:
        mov     eax,1

BeginScanDone:
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 1CH
CLOSEPROC


;==============================================================================
;
; Function:     GENERIC_PolyScanOrScanLine
;
; Purpose:      The Output entry point jumps to here without creating a
;               FRAME when it is discovered that the Output style is
;               OS_POLYSCANLIE or OS_SCANLINE. They are very similar
;               except for the inner loop so we process them in the
;               same routine.
;
; Arguments:    Output Display Driver Stack Frame
;
; Returns:      ax      1       success
;                       0       failure
;                       -1      have GDI simulate
;
; Preserve:     ds,esi,edi
; Purpose:      This function is the gdi Polyscan/Scnaline entry point.
;
; Arguments:
;
; Returns:
;
;==============================================================================
DECPROC GENERIC_PolyScanOrScanLine, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wStyle
PARMW   wCount
PARMD   lpPoints
PARMD   lpPen
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   lpClipRect
LOCALD  dwXPairs
LOCALD  dwYPairs
LOCALD  dwLocalBeginScan
OPENPROC
        PUSHR   ds,esi,edi

        ; Get a ptr to the logical device context
        mov     ds,cs:[wFlatDataSel]
        mov     edi,cs:[CSpGNLogicalDevice]

        ; If we are not in a BEGINSCAN sequence, then do BeginScan now
        cmp     ds:[edi].GNLOGDEVCX.bInScanSequence,0
        je      DoBeginScan
        mov     dwLocalBeginScan,0

        ; We did receive a BeginScan call earlier, but are we punting
        ; the whole scan sequence to the DIBENG?
        cmp     ds:[edi].GNLOGDEVCX.bPuntingScan,0
        jne     GN_ScanPunt
DoneBeginScan:

        ; We are supposed to do it, but nothing to do if brush was hollow
        cmp     ds:[edi].GNLOGDEVCX.bHollowBrushForScan,0
        jne     ScanDone

        ; Watch for busy hardware -- some other API owns the screen
        cmp     ds:[edi].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_ScanPunt

        ; Now go into the appropriate loop calling the hardware
        xor     esi,esi                 ; clear high word of ESI
        mov     edi,ds:[edi].GNLOGDEVCX.pHWLogdevCX
        cmp     wStyle,OS_SCANLINES
        je      DoScanline

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DoPolyScan:
        les     si,lpPoints
        movzx   ecx,wCount
        mov     dwYPairs,ecx
LoopY:
        movzx   ecx,es:[esi].SCAN.scnPntCnt
        movsx   eax,es:[esi].SCAN.scnPntTop
        movsx   ebx,es:[esi].SCAN.scnPntBottom
        shr     ecx,1
        je      NextY
        cmp     ebx,eax
        jle     NextY
        lea     esi,es:[esi].SCAN.scnPntX
        shl     eax,10H
        shl     ebx,10H
        mov     dwXPairs,ecx

        ; high word of eax = top of block
        ; high word of ebx = bottom of block
        ; es:esi = ptr to begin of coord pairs for this scan group
LoopX:
        mov     ax,es:[esi + 0]
        mov     bx,es:[esi + 2]
        add     esi,4
        cmp     ax,bx
        jge     @F
        cmp     eax,ebx
        jge     @F
        call    HW_BlockRect
@@:
        dec     dwXPairs
        jg      LoopX
        add     esi,2                    ; skip unused field
NextY:
        dec     dwYPairs
        jg      LoopY
        jmp     ScanDone
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DoScanline:
        les     si,lpPoints
        mov     eax,es:[esi]
        add     esi,4
        movzx   ecx,wCount
        lea     ebx,[eax + 10000H]
        dec     ecx
        mov     dwXPairs,ecx
LoopX1: mov     ax,es:[esi + 0]
        mov     bx,es:[esi + 2]
        add     esi,4
        cmp     ax,bx
        jge     @F
        cmp     eax,ebx
        jge     @F
        call    HW_BlockRect
@@:
        dec     dwXPairs
        jne     LoopX1
        jmp     ScanDone
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ScanDone:
        ; If we are not in a Begin/Scan/End sequence and had to do the
        ; begin locally, then we need to do the end locally as well.
        cmp     dwLocalBeginScan,0
        jne     DoEndScan

DoneEndScan:
        mov     eax,1
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 1CH

GN_ScanPunt:
        POPR    ds,esi,edi
        STOPPROC
PLABEL	Punt_Scan
        jmp     DIB_Output

DoBeginScan:
        mov     dwLocalBeginScan,1
        push    lpDstDev
        pushw   OS_BEGINNSCAN
        push    wCount
        push    lpPoints
        push    lpPen
        push    lpBrush
        push    lpDrawMode
        push    lpClipRect
        CALLFAR16 GENERIC_BeginScan
        cmp     ds:[edi].GNLOGDEVCX.bPuntingScan,0
        je      DoneBeginScan

        ; We are punting to the DIBENG -- let it handle everything
        push    lpDstDev
        push    wStyle
        push    wCount
        push    lpPoints
        push    lpPen
        push    lpBrush
        push    lpDrawMode
        push    lpClipRect
        call    DIB_Output

DoEndScan:
        push    lpDstDev
        pushw   OS_ENDNSCAN
        push    wCount
        push    lpPoints
        push    lpPen
        push    lpBrush
        push    lpDrawMode
        push    lpClipRect
        CALLFAR16  GENERIC_EndScan
        jmp     DoneEndScan

GENERIC_PolyScanOrScanLine      ENDP


;==============================================================================
;
; Function:     GENERIC_EndScan
;
; Purpose:      The Output entry point jumps to here without creating a
;               FRAME when it is discovered that the Output style is
;               OS_ENDNSCAN.
;
; Arguments:    Output Display Driver Stack Frame
;
; Returns:      ax      1       success
;                       0       failure
;                       -1      have GDI simulate
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_EndScan, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wStyle
PARMW   wCount
PARMD   lpPoints
PARMD   lpPen
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   lpClipRect
OPENPROC
        PUSHR   ds,esi,edi

        ; Get a ptr to the logical device context
        mov     ds,cs:[wFlatDataSel]
        mov     edi,cs:[CSpGNLogicalDevice]
        sub     eax,eax

        ; If we are not in a BEGINSCAN sequence, get out
        cmp     al,ds:[edi].GNLOGDEVCX.bInScanSequence
        je      EndScanSuccess
        mov     ds:[edi].GNLOGDEVCX.bInScanSequence,al

        ; If we have a hollow brush, get out
        cmp     al,ds:[edi].GNLOGDEVCX.bHollowBrushForScan
        mov     ds:[edi].GNLOGDEVCX.bHollowBrushForScan,al
        jne     EndScanSuccess

        ; If we have routed the whole scan sequence to the DIBENG,
        ; then don't stop now.
        cmp     al,ds:[edi].GNLOGDEVCX.bPuntingScan
        jne     GN_EndScanPunt

        ; Watch for busy hardware -- some other API owns the screen
        cmp     eax,ds:[edi].GNLOGDEVCX.dwHardwareBusy
        jne     GN_EndScanPunt

        ; call the hardware specific routine
        mov     edi,ds:[edi].GNLOGDEVCX.pHWLogdevCX
        call    HW_EndRect

EndScanSuccess:
        POPR    ds,esi,edi
        mov     eax,1
        STOPPROC
        RETFAR16 1CH

GN_EndScanPunt:
        POPR    ds,esi,edi
        STOPPROC
PLABEL	Punt_EndScan
        jmp     DIB_Output

GENERIC_EndScan     ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNREPNT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation
;
; File:         gnrepnt.asm
;
; Purpose:      This file holds the UserRepaint display driver entry point.
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

USER_REPAINT_ORDINAL    EQU     275
MAX_USER_REPAINT_CALLS  EQU     5
GRAPHICS_IDLE_TIME      EQU     200H

OPENSEG  _DATA, USE16, DATA
; This must be in a DATA segment or else Kernel chokes on it.
PUBLIC  szUserModuleName
szUserModuleName        DB      'USER',0
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE
PUBLIC	lpfnUserRepaint
lpfnUserRepaint	DD	0

IFDEF DEBUG
szIssueRepnt    DB      'DISPLAY:GN_IssueUserRepaint',0DH,0AH,0
ENDIF

;==============================================================================
;
; Function:     GN_InitUserRepaint ()
;
; Purpose:      This function inits the ptr to the GDI function
;               UserRepaint which forces all Windows on the screen
;               to redraw themselves (places a WM_PAINT message in
;               everyones queue for every Window rectangle).
;
; Arguments:	None
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_InitUserRepaint, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds
        mov     ax,_DATA
        shl     eax,10H
        mov     ax,OFFSET szUserModuleName
        push    eax
        call    GetModuleHandle

        mov     edx,USER_REPAINT_ORDINAL
        push    ax
        push    edx
        call    GetProcAddress
        shl     edx,10H
        mov     dx,ax
        mov	ds,wNVTEXT16_Alias_In_NVTEXT16
        mov	ds:[lpfnUserRepaint],edx
        POPR    ds
CLOSEPROC


;==============================================================================
;
; Function:     GENERIC_UserRepaintDisable
;
; Purpose:      This function is the gdi bitblt entry point.
;
; Arguments:    UserRepaintDisable display driver stack FRAME
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_UserRepaintDisable, PASCAL, FRAME, FAR16
PARMB   argRepaintDisable
OPENPROC
        PUSHR   ds,esi
        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]

        ; If we haven't initialized yet, then do so now
        cmp	lpfnUserRepaint,0
        jnz     @F
        call    GN_InitUserRepaint
@@:
        mov     al,argRepaintDisable
        mov     ds:[esi].GNLOGDEVCX.bRepaintDisable,al
        or      al,al
        jne     @F

        ; We can call UserRepaint -- is there one pending?
        cmp     al,ds:[esi].GNLOGDEVCX.bRepaintPending
        je      @F
        mov     ds:[esi].GNLOGDEVCX.bRepaintPending,al
        push	esi
        call    GN_IssueUserRepaint
@@:
        POPR    ds,esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_UserRepaint
;
; Purpose:      This function can be called to transfer a disabled
;               repaint request into a pending request.
;
; Arguments:    ds			CX Selector
;		pGNLogdevCXOffset	GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_UserRepaint, PASCAL, FRAME, FAR16
PARMD	pGNLogdevCXOffset
OPENPROC
        PUSHR   ds,esi
        mov     esi,pGNLogdevCXOffset

        ; If we haven't initialized yet, then do so now
        cmp	lpfnUserRepaint,0
        jnz     @F
        call    GN_InitUserRepaint
@@:
        mov     al,ds:[esi].GNLOGDEVCX.bRepaintDisable
        mov     ds:[esi].GNLOGDEVCX.bRepaintPending,al
        or      al,al
        jne     @F
        push	esi
        call    GN_IssueUserRepaint
@@:
        POPR    ds,esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_IssueUserRepaint
;
; Purpose:      Occassionally there is a problem (Windows OS problem --
;               not our's) with toggling back from a DOS box. The issue
;               is that sometimes our request to USER to repaint the
;               screen is discarded. Hence, the Windows screen is
;               black and gets repainted bit by bit as the user clicks
;               on different pieces of it. The solution is to issue the
;               USER repaint request again if the first request hasn't
;               caused a good amount of graphics activity within a
;               reasonable amount of time.
;
; Arguments:
;		ds			Context Selector
;		pGNLogdevCXOffset	GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_IssueUserRepaint, PASCAL, FRAME, NEAR
PARMD	pGNLogdevCXOffset
OPENPROC
        PUSHR   ds,esi

IFDEF DEBUG
        mov     ax,cs
        shl     eax,10H
        lea     ax,szIssueRepnt
        push    eax
        call    GENERIC_OutputDebugString
ENDIF

        mov	esi,pGNLogdevCXOffset

        ; Set a flag saying a repaint has been issued
        mov     ds:[esi].GNLOGDEVCX.bRepaintIssued,1

        ; Call the hardware specific code to get a cookie
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_GetGraphicsTimeStamp
        mov     ds:[esi].GNLOGDEVCX.dwGraphicsTimeStamp,eax

        ; Now issue a repaint
        call    FFP16 PTR lpfnUserRepaint
        POPR    ds,esi
CLOSEPROC


;==============================================================================
;
; Function:     GN_CheckUserRepaint
;
; Purpose:      Occassionally there is a problem (Windows OS problem --
;               not our's) with toggling back from a DOS box. The issue
;               is that sometimes our request to USER to repaint the
;               screen is discarded. Hence, the Windows screen is
;               black and gets repainted bit by bit as the user clicks
;               on different pieces of it. The solution is to issue the
;               USER repaint request again if the first request hasn't
;               caused a good amount of graphics activity within a
;               reasonable amount of time.
;
; Arguments:
;               ds              Context Selector
;               esi             GNLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     everything!
;==============================================================================
DECPROC GN_CheckUserRepaint, PASCAL, NOFRAME, FAR16
OPENPROC
        cmp     ds:[esi].GNLOGDEVCX.bRepaintIssued,0
        je      DoneIt
        cmp     ds:[esi].GNLOGDEVCX.dwHardwareBusy,0
        jne	DoneIt
        cmp     ds:[esi].GNLOGDEVCX.bDirectXActive,0
        jne	DoneIt
        mov     ds:[esi].GNLOGDEVCX.bRepaintIssued,0

        ; Has alot of graphics activity occurred since then?
        ; Call the hardware specific code to get a cookie
        PUSHR   alld,ds,es,fs,gs

        ; Get the current time stamp
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_GetGraphicsTimeStamp

        ; Has it changed much?
        sub     eax,ds:[esi].GNLOGDEVCX.dwGraphicsTimeStamp
        cmp     eax,GRAPHICS_IDLE_TIME
        ja      NoMoreRepaints
	cmp	ds:[esi].GNLOGDEVCX.bUserRepaintCallCount,MAX_USER_REPAINT_CALLS
	ja	NoMoreRepaints

        ; Not much graphics activity has happened. Better issue
        ; another repaint.
        push	esi
        call    GN_IssueUserRepaint
	inc	ds:[esi].GNLOGDEVCX.bUserRepaintCallCount
	jmp	RepaintIssued

NoMoreRepaints:
	mov	ds:[esi].GNLOGDEVCX.bUserRepaintCallCount,0

RepaintIssued:
        POPR    alld,ds,es,fs,gs
DoneIt:
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNSDIB.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation
;
; File:         gnsdib.asm
;
; Purpose:      This file holds the StretchDIBits display driver entry point.
;
;==============================================================================
.586
incDevice = 1
incDrawMode = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_StretchDIBits
;
; Purpose:      This function is the StretchDIBits display driver entry point.
;
; Arguments:    StretchDIBits Display Driver Stack Frame
;
; Returns:      ax      number of scans copied if successful
;                       0 if not successful
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_StretchDIBits, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   fGet
PARMW   wDstX
PARMW   wDstY
PARMW   wDstExtX
PARMW   wDstExtY
PARMW   wSrcX
PARMW   wSrcY
PARMW   wSrcExtX
PARMW   wSrcExtY
PARMD   lpDIBBits
PARMD   lpDIBInfo
PARMD   lpTranslate
PARMD   dwRop3
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   lpClipRect
LOCALD  dwBmpLeft
LOCALD  dwBmpTop
LOCALD  dwBmpRight
LOCALD  dwBmpBottom
LOCALD  dwDibLeft
LOCALD  dwDibTop
LOCALD  dwDibRight
LOCALD  dwDibBottom
LOCALD  dwDibBitsOffset
LOCALD  dwExtX
LOCALD  dwExtY
LOCALD  dwDibPitch
LOCALD  dwDibWidth
LOCALD  dwDibHeight
LOCALD  dwDstBitsPixel
LOCALD  lpPhysColor
LOCALD  dwPhysColor
LOCALD  dwScaleX
LOCALD  dwScaleY
LOCALD  dwDstExtX
LOCALD  dwDstExtY
LOCALD  dwStretchFlag
OPENPROC
        PUSHR   ds,esi,edi

        ; Load up the DstDev and the DIB Header for dispatching
        sub     eax,eax
        cmp     ax,fGet
        jne     GN_StrDibPunt

        ; Load up the ptrs
        sub     edi,edi
        sub     esi,esi
        lfs     di,lpDIBInfo
        les     si,lpDstDev

        ; We only do RGB DIBs (No Compression)
        cmp     fs:[edi].BitmapInfoHeader.biCompression,BI_RGB
        je      @F
        
        cmp     fs:[edi].BitmapInfoHeader.biCompression,BI_BITFIELDS
        jne     GN_StrDibPunt

@@:
        ; If the bitmap is not in VRAM, then punt it.
        cmp     ax,es:[esi].DIBENGINE.deType
        je      GN_StrDibPunt
        test    es:[esi].DIBENGINE.deFlags,VRAM
        jz      GN_StrDibPunt

        ; Make sure the device is not busy.
        mov     ds,cs:[wFlatDataSel]
        mov     ebx,cs:[CSpGNLogicalDevice]
        cmp     ds:[ebx].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_StrDibPunt

        movsx   eax,wSrcExtX

        ; Punt the negative width (Left-Right mirror Arabic Windows)
        or      eax,eax
        js      GN_StrDibPunt

        movsx   ebx,wDstExtX
        movsx   ecx,wSrcExtY
        movsx   edx,wDstExtY

        cmp     eax,ebx
        mov     eax,1
        jne     @F
        cmp     ecx,edx
        jne     @F
        sub     eax,eax

@@:
        mov     dwStretchFlag,eax

        ; Punt the negative heights
        or      ecx,edx
        js      GN_StrDibPunt

        ; Punt stretched case for the mono dib
        cmp     fs:[edi].BitmapInfoHeader.biBitCount,ax
        je      GN_StrDibPunt

IF DIB_PROCESS_SINGLESCAN
        ; Special case the 8bpp DIBS that are 1 scanline high,
        ; where wSrcExtY = wDstExtY = 1
        cmp     dwStretchFlag,0
        jne     @F
        cmp     fs:[edi].BitmapInfoHeader.biBitCount,8
        jne     @F
        cmp     fs:[edi].BitmapInfoHeader.biHeight,1
        jne     @F
        cmp     ecx,1
        jne     @F

        cmp     byte ptr dwRop3+2,0CCH
        jne     @F
        call    GN_StretchDIBitsSingleScan
        or      eax,eax
        jne     GN_StrDibExit
@@:
ENDIF

IF      (DIB_8BPP_ACCEL NE 0)
        ; If the dst is 8bpp and Rop not srccopy or src is mono, then punt it.
        cmp     es:[esi].DIBENGINE.deBitsPixel,8
        jne     @F
        cmp     byte ptr dwRop3+2,0CCH
        jne     GN_StrDib8BppPunt
        cmp     fs:[edi].BitmapInfoHeader.biBitCount,1
        je      GN_StrDib8BppPunt
@@:
ELSE
        ; If the dst is 8bpp, but not SingleScan case, then punt it.
        cmp     es:[esi].DIBENGINE.deBitsPixel,8
        je      GN_StrDib8BppPunt
ENDIF

        ; First, clip the DIB
        call    GN_StretchDIBitsClip
        or      eax,eax
        je      GN_StrDibExit

        ; If the rop involves a pattern, prepare the pattern now
        movzx   eax,byte ptr [dwRop3 + 2]
        movzx   ecx,byte ptr cs:Rop3Table[eax]
        cmp     ecx,PAD
        je      PrepBrush
        cmp     ecx,PSD
        je      PrepBrush

BackIn:
        ; Break the call out into cases.
        movzx   esi,word ptr lpDstDev+0
        cmp     fs:[edi].BitmapInfoHeader.biBitCount,1
        jne     GN_StretchColorDib
        jmp     GN_StretchMonoDib

PrepBrush:
        mov     es,word ptr lpBrush+2
        movzx   esi,word ptr lpBrush+0
        push    lpDrawMode
        mov     ebx,cs:[CSpGNLogicalDevice]
        call    GN_PrepareBrush
        or      eax,eax
        je      GN_StrDibExit
        mov     eax,0
        jl      GN_StrDibExit

        ; reload some stuff that got trashed
        ; Load up the ptrs
        sub     edi,edi
        sub     esi,esi
        lfs     di,lpDIBInfo
        les     si,lpDstDev
        jmp     BackIn

GENERIC_StretchDIBits   ENDP


;==============================================================================
;
; Function:     StretchDIBits ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of StretchDIBits. You can either return a success code,
;               a failure code, punt to the DIBENG, etc.
;
; Arguments:    StretchDIBits Display Driver Stack Frame
;
;==============================================================================
PUBLIC  GN_StrDibPunt
GN_StrDibPunt     PROC    NEAR

        push    lpDstDev
        push    fGet
        push    wDstX
        push    wDstY
        push    wDstExtX
        push    wDstExtY
        push    wSrcX
        push    wSrcY
        push    wSrcExtX
        push    wSrcExtY
        push    lpDIBBits
        push    lpDIBInfo
        push    lpTranslate
        push    dwRop3
        push    lpBrush
        push    lpDrawMode
        push    lpClipRect
PLABEL  Punt_StrDib
        call    DIB_StretchDIBits
        .errnz  $ - OFFSET GN_StrDibExit

GN_StrDibPunt     ENDP

PUBLIC  GN_StrDibExit
GN_StrDibExit   PROC    NEAR

        POPR    ds,esi,edi
        mov     sp,bp
        mov     ecx,ss:[ebp + 4]
        pop     ebp
IF DIB_FAST_EXIT
        cmp     ax,-1
        je      @F
        cmp     cs:[bUseStretchDIBitsFastExit],0
        je      @F
        cmp     ecx,cs:[lpfnGdiCode03_20B7]
        jne     @F
        mov     ss:[bp - 02H],ax
        test    byte ptr ss:[di + 02H],40H
        jz      @F
        add     sp,4 + 32H
        jmp     GdiCode03_217C
@@:
ENDIF
        ; Clean and return normally
        RETFAR16 32H
GN_StrDibExit   ENDP


;==============================================================================
;
; Function:     GN_StrDib8BppPunt (StretchDIBits ending routine)
;
; Purpose:      This function is a work-around for a bug in the
;               DIBEngine DIB compiler.  At 8bpp, if the destination
;               bitmap is not word aligned (i.e. (wDestX & 1) == 1)
;               AND the clip rect is one (1) pixel wide AND the clip
;               rect is misaligned by 3 (i.e. (wClipLeft & 3) == 3),
;               AND the stretch is 1:1, then the DIB compiler will
;               fail to compile the code to do the pixel copy
;               (tested in the 16bpp source case) but will compile
;               the epilogue code incrementing the source and dest
;               pointers furiously.
;               The result of this is somewhat unsatisfying.
;
; Arguments:    StretchDIBits Display Driver Stack Frame
;
;==============================================================================
DECPROC GN_StrDib8BppPunt, PASCAL, NOFRAME, NEAR
OPENPROC
        test    wDstX,1                 ; Check for unaligned destination
        jz      GN_StrDibPunt
        mov     ax,wDstExtX             ; Check for 1:1 stretch
        mov     bx,wDstExtY
        cmp     ax,wSrcExtX
        jne     GN_StrDibPunt
        cmp     bx,wSrcExtY
        jne     GN_StrDibPunt
        xor     esi,esi
        cmp     word ptr [lpClipRect + 2],si   ; Check for clip rect
        je      GN_StrDibPunt
        lfs     si,lpClipRect

        movzx   eax,fs:[esi].RECT.left
        inc     eax
        cmp     ax,fs:[esi].RECT.right  ; Check if 1 pixel wide
        jne     GN_StrDibPunt
        and     eax,3                   ; Check for (clipleft mod 4) == 3
        jnz     GN_StrDibPunt

        ; Clean and return a failure normally
        POPR    ds,esi,edi
        mov     sp,bp
        mov     eax,-1
        pop     ebp
        RETFAR16 32H
ENDPROC


;==============================================================================
;
; Function:     GN_StretchMonoDib
;
; Purpose:      This function is jumped to from the StretchDIBits
;               display driver entry point. We have already clipped
;               the DIB/Bitmap, made the determination that we will
;               handle the call and locked the display. Here, the
;               parameters should be pushed on the stack to call the
;               HW specific routine to perform the mono transfer.
;
; Arguments:    StretchDIBits Display Driver Stack Frame
;               ds      Context Selector
;               fs:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;               es:esi  lpDstDev ptr  (ptr to DIBENGINE HDR)
;
; Returns:      No returns -- this function is jumped to. When it is done it
;               should jump to one of the StretchDIBits ending routines.
;
;==============================================================================
DECPROC GN_StretchMonoDib, PASCAL, NOFRAME, NEAR
OPENPROC
        ; We can handle this as a mono transfer
        push    cs:[CSpGNLogicalDevice]
        movzx   eax,word ptr es:[esi].DIBENGINE.deBits+4
        push    eax
        push    dword ptr es:[esi].DIBENGINE.deBits
        movzx   eax,es:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    es:[esi].DIBENGINE.deDeltaScan
        push    dwBmpLeft
        push    dwBmpTop
        movzx   eax,word ptr lpDIBBits+2
        push    eax
        push    dwDibBitsOffset
        push    dwDibPitch
        push    dwDibLeft
        push    dwDibTop
        push    dwExtX
        push    dwExtY

        ; The bg and fg colors come from the color table at end of DIB
        lea     esi,dwPhysColor
        ror     esi,10H
        mov     si,ss
        ror     esi,10H
        mov     lpPhysColor,esi

        mov     esi,dword ptr fs:[edi].BitmapInfo.bmiColors[0]
        cmp     fs:[edi].BitmapInfoHeader.biClrUsed,1
        je      @F
        mov     edi,dword ptr fs:[edi].BitmapInfo.bmiColors[4]
        push    lpDstDev
        bswap   edi
        ror     edi,8
        push    edi
        push    lpPhysColor
        call    GENERIC_ColorInfo
        mov     edi,dwPhysColor
@@:
        push    lpDstDev
        bswap   esi
        ror     esi,8
        push    esi
        push    lpPhysColor
        call    GENERIC_ColorInfo

        ; push two translated colors
        push    dwPhysColor
        push    edi

        mov     edx,07FFFH
        sub     ebx,ebx
        push    dwRop3                          ; Rop3
        push    lpBrush                         ; lpBrush
        push    lpDrawMode                      ; lpDrawmode
        push    edx                             ; scans left in start seg
        push    edx                             ; scans per seg
        push    ebx                             ; fill bytes

        call    GN_BitBltSrcMonoDstVram
        or      eax,eax
        je      GN_StrDibPunt
        mov     eax,dwDstExtY
        jmp     GN_StrDibExit
ENDPROC


;==============================================================================
;
; Function:     GN_StretchColorDib
;
; Purpose:      This function is jumped to from the StretchDIBits
;               display driver entry point. We have already clipped
;               the DIB/Bitmap, made the determination that we will
;               handle the call and locked the display. Here, the
;               parameters should be pushed on the stack to call the
;               HW specific routine to perform the mono transfer.
;
; Arguments:    StretchDIBits Display Driver Stack Frame
;               ds      Context Selector
;               fs:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;               es:esi  lpDstDev ptr  (ptr to DIBENGINE HDR)
;
; Returns:      No returns -- this function is jumped to. When it is done it
;               should jump to one of the StretchDIBits ending routines.
;
;==============================================================================
DECPROC GN_StretchColorDib, PASCAL, NOFRAME, NEAR
OPENPROC
        ; The bitcount is tricky. If biCompression is BI_RGB, then 16bpp
        ; is really 15bpp. If biCompression is BI_BITFIELDS, then 16bpp
        ; might be either 16bpp or 15bpp -- have to check the masks.
        movzx   ecx,fs:[edi].BitmapInfoHeader.biBitCount
        cmp     ecx,10H
        jne     @F
        mov     ecx,0FH
        cmp     fs:[edi].BitmapInfoHeader.biCompression,BI_BITFIELDS
        jne     @F
        cmp     fs:[edi].BitmapV4Header.bV4GreenMask,3E0H
        je      GN_StrDibPunt
        inc     ecx
        cmp     fs:[edi].BitmapV4Header.bV4GreenMask,7E0H
        jne     GN_StrDibPunt
@@:
        mov     ebx,cs:[CSpGNLogicalDevice]
        push    ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        movzx   eax,word ptr es:[esi].DIBENGINE.deBits+4
        push    eax
        push    dword ptr es:[esi].DIBENGINE.deBits
        movzx   eax,es:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    es:[esi].DIBENGINE.deDeltaScan
        push    dwBmpLeft
        push    dwBmpTop
        movzx   eax,word ptr lpDIBBits+2
        push    eax
        push    dwDibBitsOffset
        push    ecx
        push    dwDibPitch
        push    dwDibLeft
        push    dwDibTop
        push    dwExtX
        push    dwExtY

        push    dwRop3
        push    lpBrush                         ; lpBrush
        push    lpDrawMode                      ; lpDrawMode
        pushd   4                               ; dwSizeColorTableEntry

        ; If the src is > 8bpp, then there is no color table.
        ; If there is a color table, compute the number of entries.
        sub     eax,eax
        sub     ebx,ebx
        cmp     cl,8
        jbe     IsColorTable
        cmp     es:[esi].DIBENGINEHDR.bRealBpp,8
        jne     @F
        mov     ebx,lpTranslate
        jmp     @F

IsColorTable:
        mov     ebx,lpDIBInfo
        add     bx,word ptr fs:[edi].BitmapInfoHeader.biSize
        mov     edx,fs:[edi].BitmapInfoHeader.biClrUsed
        mov     eax,1
        shl     eax,cl
        or      edx,edx
        je      @F
        cmp     eax,edx
        jc      @F
        mov     eax,edx
@@:
        push    eax                             ; number color table entries
        push    ebx                             ; lpColorTable

        ; pfnCopyXlat - NULL means that HW_BitBltSrcColorDstVram
        ; must determine the correct copy / xlat routine for itself.
        sub     eax,eax
        push    eax

        ; Final check for the stretch case
        cmp     dwStretchFlag,0
        jne     StretchCase
        call    HW_BitBltSrcColorDstVram
        jmp     RetFromClrBlt

StretchCase:
        push    dwDstExtX
        push    dwDstExtY
        push    lpClipRect
        call    GN_StretchBltSrcColorDstVram

RetFromClrBlt:
        or      eax,eax
        je      GN_StrDibPunt
        mov     eax,dwDstExtY
        jmp     GN_StrDibExit

GN_StretchColorDib      ENDP


;==============================================================================
;
; Function:     GN_StretchDIBitsClip
;
; Purpose:      This function clips the DIB and Bitmap for StretchDIBits.
;
; Arguments:    StretchDIBits Display Driver Stack Frame
;               fs:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;
; Returns:      eax     = 0, there is nothing to draw
;                       > 0, there is something to draw
;
; Preserve:     fs,edi,es
;==============================================================================
PUBLIC  GN_StretchDIBitsClip
GN_StretchDIBitsClip    PROC    NEAR

        ; Get the width and height of the DIB and compute the signed pitch.
        mov     ecx,fs:[edi].BitmapInfoHeader.biHeight
        mov     edx,fs:[edi].BitmapInfoHeader.biWidth
        movzx   eax,fs:[edi].BitmapInfoHeader.biBitCount
        imul    eax,edx
        add     eax,1FH
        shr     eax,3
        and     eax,NOT 3
        neg     ecx
        jns     @F
        neg     ecx
        neg     eax
@@:     mov     dwDibWidth,edx
        mov     dwDibHeight,ecx

        movsx   edx,wSrcY
        movsx   ecx,wSrcExtY
        movsx   esi,wDstY
        movsx   ebx,wDstExtY

        or      ecx,ecx
        jns     @F
        add     edx,ecx
        neg     eax
        neg     ecx
@@:
        or      ebx,ebx
        jns     @F
        add     esi,ebx
        neg     eax
        neg     ebx
@@:
        mov     dwDibPitch,eax
        mov     dwExtY,ecx
        mov     dwDstExtY,ebx
        mov     dwDibTop,edx
        mov     dwBmpTop,esi

        ; Compute the unclipped DIB bounding rectangle
        mov     esi,dwDibHeight
        movsx   eax,wSrcX
        mov     edx,dwExtY
        mov     ebx,dwDibTop
        movsx   ecx,wSrcExtX
        add     ecx,eax
        sub     esi,ebx
        mov     dwDibRight,ecx
        mov     dwDibBottom,esi
        mov     dwDibLeft,eax
        sub     esi,edx
        mov     dwDibTop,esi

        ; Compute the unclipped Bitmap bounding rectangle
        movsx   eax,wDstX
        mov     ebx,dwBmpTop
        mov     dwBmpLeft,eax
        movsx   ecx,wDstExtX
        mov     edx,dwDstExtY
        add     eax,ecx
        add     ebx,edx
        mov     dwBmpRight,eax
        mov     dwBmpBottom,ebx

        ; Calculate the scaling factor
        sub     eax,eax
        shrd    eax,ecx,12
        mov     ecx,edx
        movsx   ebx,wSrcExtX
        sub     edx,edx
        idiv    ebx
        mov     dwScaleX,eax
        sub     eax,eax
        shrd    eax,ecx,12
        mov     ebx,dwExtY
        sub     edx,edx
        idiv    ebx
        mov     dwScaleY,eax

        ; Do the source clipping on the left and top of the DIB and bitmap
        mov     eax,dwDibLeft
        mov     ebx,dwDibTop
        or      eax,eax
        jns     @F
        sub     dwDibLeft,eax
        neg     eax
        imul    eax,dwScaleX
        shr     eax,20
        add     dwBmpLeft,eax
@@:     or      ebx,ebx
        jns     @F
        sub     dwDibTop,ebx
        neg     ebx
        imul    ebx,dwScaleY
        shr     ebx,20
        add     dwBmpTop,ebx
@@:
        ; Do source clipping on the right and bottom of the DIB and bitmap
        mov     eax,dwDibBottom
        sub     eax,dwDibHeight
        jle     @F
        sub     dwDibBottom,eax
        imul    eax,dwScaleY
        shr     eax,20
        sub     dwBmpBottom,eax
@@:     mov     eax,dwDibRight
        sub     eax,dwDibWidth
        jle     @F
        sub     dwDibRight,eax
        imul    eax,dwScaleX
        shr     eax,20
        sub     dwBmpRight,eax

@@:
        ; Dst clipping uses the clip rectangle
        sub     esi,esi
        lgs     si,lpClipRect

        ; Clip the dst left and top edges
        mov     eax,dwBmpLeft
        movsx   edx,gs:[esi].RECT.left
        sub     eax,edx
        jge     @F
        neg     eax
        shl     eax,20
        sub     edx,edx
        idiv    dwScaleX
        add     dwDibLeft,eax
        imul    eax,dwScaleX
        shr     eax,20
        add     dwBmpLeft,eax
@@:
        mov     eax,dwBmpTop
        movsx   edx,gs:[esi].RECT.top
        sub     eax,edx
        jge     @F
        neg     eax
        shl     eax,20
        sub     edx,edx
        idiv    dwScaleY
        add     dwDibTop,eax
        imul    eax,dwScaleY
        shr     eax,20
        add     dwBmpTop,eax
@@:

        ; Clip the dst right and bottom edges
        mov     eax,dwBmpRight
        movsx   edx,gs:[esi].RECT.right
        sub     eax,edx
        jle     @F
        shl     eax,20
        sub     edx,edx
        idiv    dwScaleX
        sub     dwDibRight,eax
        imul    eax,dwScaleX
        shr     eax,20
        sub     dwBmpRight,eax
@@:
        mov     eax,dwBmpBottom
        movsx   edx,gs:[esi].RECT.bottom
        sub     eax,edx
        jle     @F
        shl     eax,20
        sub     edx,edx
        idiv    dwScaleY
        sub     dwDibBottom,eax
        imul    eax,dwScaleY
        shr     eax,20
        sub     dwBmpBottom,eax
@@:

DoneClip:
        ; It's all clipped -- now compute the extents
        mov     eax,dwDibRight
        mov     ebx,dwDibBottom
        sub     eax,dwDibLeft
        jle     NothingVisible
        sub     ebx,dwDibTop
        jle     NothingVisible
        mov     dwExtX,eax
        mov     dwExtY,ebx

        mov     eax,dwBmpRight
        mov     ebx,dwBmpBottom
        sub     eax,dwBmpLeft
        jle     NothingVisible
        sub     ebx,dwBmpTop
        jle     NothingVisible
        mov     dwDstExtX,eax
        mov     dwDstExtY,ebx

        ; The bits ptr is normal if the DIB is right side up
        mov     ecx,dwDibPitch
        movzx   ebx,word ptr lpDIBBits
        or      ecx,ecx
        jg      @F
        mov     edx,dwDibHeight
        neg     ecx
        dec     edx
        imul    ecx,edx
        add     ebx,ecx
@@:
        mov     dwDibBitsOffset,ebx
        mov     eax,1
        ret

NothingVisible:
        sub     eax,eax
        ret

GN_StretchDIBitsClip    ENDP


IF DIB_PROCESS_SINGLESCAN
;==============================================================================
;
; Function:     GN_StretchDIBitsSingleScan
;
; Purpose:      This routine is jumped to from GENERIC_StretchDIBits.
;               when the generic code has determined that the call
;               matches this special case: the DIB is 8bpp, 1 scanline
;               high, wSrcExtY = wDstExtY = 1, the rop is 0CCH.
;
; Arguments:    StretchDIBits Display Driver Stack Frame
;               fs:edi  lpDibInfo ptr (ptr to BitmapInfoHeader)
;               es:esi  lpDstDev
;
; Returns:      eax     > 0     Success!
;                       0       this routine wants the normal code
;                               to handle the call.
;
; Preserve:     If you return success, you do not need to preserve
;               anything. If you return that you want the normal
;               code to handle the call, then preserve es,esi,fs,edi.
;==============================================================================
DECPROC GN_StretchDIBitsSingleScan, PASCAL, NOFRAME, NEAR
OPENPROC
        movzx   eax,es:[esi].DIBENGINE.deBitsPixel
        mov     dwDstBitsPixel,eax

        sub     ebx,ebx
        lgs     bx,lpClipRect

        ; Clip the YCoord
        movzx   edx,wDstExtY
        movzx   esi,wSrcY
        movzx   eax,wDstY
        mov     ecx,eax
        sub     ax,gs:[ebx].RECT.top
        jge     @F
        movsx   eax,ax
        add     edx,eax
        sub     ecx,eax
@@:
        mov     eax,ecx
        add     eax,edx
        sub     ax,gs:[ebx].RECT.bottom
        jle     @F
        sub     edx,eax
        add     esi,eax
@@:
        ; The ClippedSrcY must be 0 or we can't special case
        or      esi,esi
        jne     Fallback

        ; The ClippedExtY must be 1 or we can't special case
        cmp     edx,1
        jne     Fallback

        ; We can special case it! NOTE: ecx = clipped starting dst y
        mov     dwBmpTop,ecx

        ; We need to compute the clipped DstX, clipped SrcX,
        ; and clipped ExtX
        movzx   ecx,wDstExtX
        movzx   esi,wSrcX
        movsx   eax,wDstX
        or      eax,eax
        jge     @F
        sub     esi,eax
        add     ecx,eax
        sub     eax,eax
@@:
        mov     edx,eax
        sub     ax,gs:[ebx].RECT.left
        jge     @F
        movsx   eax,ax
        add     ecx,eax
        sub     edx,eax
        sub     esi,eax
@@:
        lea     eax,[edx][ecx]
        sub     ax,gs:[ebx].RECT.right
        jle     @F
        sub     ecx,eax
@@:
        ; At this point:
        ; edx = clipped DstX
        ; ecx = clipped ExtX
        ; esi = clipped SrcX

        ; Get edx = DstY * DeltaScan + deBitsOffset
        mov     eax,edx
        movzx   ebx,word ptr lpDstDev
        mov     edx,dwBmpTop
        imul    edx,es:[ebx].DIBENGINE.deDeltaScan
        add     edx,es:[ebx].DIBENGINEHDR.deBitsOffset
        mov     gs,es:[ebx].DIBENGINEHDR.deBitsSelector

        ; Load up ptr to src
        sub     ebx,ebx
        les     bx,lpDIBBits
        add     ebx,esi
        mov     esi,cs:[CSpGNLogicalDevice]

        ; Point to color table
        add     edi,fs:[edi].BitmapInfoHeader.biSize

        ; Sync with the hardware
        mov     esi,ds:[esi].GNLOGDEVCX.pHWLogdevCX
        call    HW_BeginAccess

        ; Dispatch to correct color depth routine
        cmp     dwDstBitsPixel,10H
        ja      GN_DibSingleScan_Bpp32
        je      GN_DibSingleScan_Bpp16

        ; if not NULL, need to use lpTranslate
        cmp     lpTranslate,0
        je      GN_DibSingleScan_Bpp8
        sub     edi,edi
        lfs     di,lpTranslate
        jmp     GN_DibSingleScan_Bpp8

Fallback:
        movzx   esi,word ptr lpDstDev
        sub     eax,eax
CLOSEPROC
ENDIF

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNSYSBLT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, NVidia Coporation
;
; File:         gnsysblt.asm
;
; Purpose:      This file holds the routines to do Bitblt's involving
;               a source located in video memory and a dst located in
;               system memory. There may also be a pattern involved but
;               maybe not. The code is generic in terms of not touching
;               hardware, but it does make assumptions about hardware
;               capability and to some extent programming order. These
;               should all be fine for Nvidia products.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GN_BitBltSrcVramDstSystem
;
; Purpose:      This function implements BitBlts where the rop involves
;               a src, the src is a color video memory bitmap and the
;               dst is in system memory (color or mono). There may be
;               a pattern involved as well but there may not be.
;
; Arguments:
;               ds              Context Selector
;               pGNLogdevCXOffset  GNLOGDEVCX ptr
;               lpDstDev        Ptr to the dst device (DIBENG header)
;                               Can be NULL if the actual dst is really
;                               a DIB in which case the lpDstDib holds
;                               the real dst. Either lpDstDib or lpDstDev
;                               must be valid and the other must be NULL.
;               lpDstDib        Ptr to the dst Device (BitmapInfoHeader)
;                               Can be NULL if the actual dst is really
;                               a bitmap in which case lpDstDev holds
;                               the real dst. Either lpDstDib or lpDstDev
;                               must be valid and the other must be NULL.
;               dwDstLeft       left edge of the dst rectangle
;               dwDstTop        top  edge of the dst rectangle
;               dwSrcBitsSel    selector to the src bits
;               dwSrcBitsOffset offset to the start of the source bits
;               dwSrcBpp        Bits Per Pixel in the src image
;                               This can be 4, 8, 15, 16, 24, or 32
;               dwSrcPitch      address of first pixel on line n+1 minus
;                               address of first pixel on line n.
;                               This number might be negative if the
;                               DIB is upside down.
;               dwSrcLeft       left edge of the src rectangle
;               dwSrcLeft       top  edge of the src rectangle
;               dwExtX          extent of the src (and dst) rectangle.
;               dwExtY          extent of the src (and dst) rectangle.
;               dwRop3          3-operand rop
;               lpBrush         ptr to a DIB_Brush struct
;               lpDrawMode      This is only needed for the case where
;                               the rop involves a brhs and the brush
;                               is a mono pattern. In this case,
;                               DRAWMODE.TextColor specifies the color
;                               to which to translate src 0 bits, and
;                               DRAWMODE.bkColor specifies the color
;                               to which to translate src 1 bits. Note
;                               that these are not the same colors used
;                               translate 0 and 1 bits from the src
;                               bitmap.
;               pfnCopyXlat     If this argument is not NULL then it is
;                               the correct inner loop to use. If it is
;                               NULL, then the DIBENG should be used.
;
; Returns:      eax     0       The routine will be punted to software
;                       else    the return code to GDI
;
; Preserve:     Nothing
;==============================================================================
DECPROC GN_BitBltSrcVramDstSystem, PASCAL, FRAME, NEAR
PARMD   pGNLogdevCXOffset
PARMD   lpDstDev
PARMD   lpDstDib
PARMD   dwDstBitsSel
PARMD   dwDstBitsOffset
PARMD   dwDstBpp
PARMD   dwDstPitch
PARMD   dwDstLeft
PARMD   dwDstTop
PARMD   lpSrcDev
PARMD   dwSrcBitsSel
PARMD   dwSrcBitsOffset
PARMD   dwSrcBpp
PARMD   dwSrcPitch
PARMD   dwSrcLeft
PARMD   dwSrcTop
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwRop3
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   pfnCopyXlat

LOCALD  pHWLogdevCXOffset
LOCALD  pHWBoardCXOffset
LOCALD  dwScreenPalettized
LOCALD  dwSrcBufferPitch
LOCALD  dwMaxScansPerTransfer
LOCALD  dwDstBltOffset
LOCALD  dwScansRemaining
LOCALD  dwSrcTopOffset
LOCALD  dwSrcWrapWidth
LOCALD  dwDstWrapWidth
LOCALD  dwUseDibeng
LOCALD  lpDMASrcDev
LOCALD  lpDMADstDev
LOCALS  dwBlockTop,8
LOCALS  dwBlockHeight,8
LOCALS  dwBlockTransferInitiated,8
LOCALS  dwBlockOffset,8
LOCALV  sSrcPDevice,DIBENGINEHDR
LOCALV  sDstPDevice,DIBENGINEHDR
OPENPROC
        PUSHR   ds,esi,edi
        mov     esi,pGNLogdevCXOffset
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     eax,ds:[esi].GNLOGDEVCX.pHWLogdevCX
        mov     pHWLogdevCXOffset,eax
        mov     eax,ds:[ebx].GNBOARDCX.pHWBoardCX
        mov     pHWBoardCXOffset,eax
        test    ds:[esi].GNLOGDEVCX.Dibeng.deFlags,PALETTIZED
        setne   al
        movzx   eax,al
        mov     dwScreenPalettized,eax

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Tell the hardware specific code the src bitmap with which
        ; we will be working and have it return some important data.
        push    pHWLogdevCXOffset
        push    dwSrcBitsSel
        push    dwSrcBitsOffset
        push    dwSrcBpp
        push    dwSrcPitch
        push    dwSrcLeft
        push    dwExtX
        call    HW_BeginSrcVramDstSystem
        or      eax,eax
        je      ExitIt
        mov     dwSrcBufferPitch,ebx
        mov     dwMaxScansPerTransfer,ecx

        ; At this point, the generic and hardware code are linked
        ; until the HW_EndSrcVramDstSystem routine is called.
        ; The generic code has agreed not to touch fs -- it is the
        ; hardware's selector for whatever purposes it may need.
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; For each chunk of the bitmap we DMA back, we need to rop it
        ; in with the destination. If the caller passed in a non-NULL
        ; pfnCopyXlat, then it is the routine to use to do the ropping.
        ; Otherwise, we will use the DIBENG to do the ropping.
        push    OFFSET SetupDone
        cmp     pfnCopyXlat,0
        jne     OurRopSetup
        jmp     DibengRopSetup
SetupDone:

        sub     ebx,ebx
        mov     dword ptr dwBlockTransferInitiated[ebx * 4 + 0],0
        mov     dword ptr dwBlockTransferInitiated[ebx * 4 + 4],0
        mov     eax,dwExtY
        mov     dwScansRemaining,eax
        mov     dwSrcTopOffset,ebx

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Enter the following code with ebx = to 0 or 1. ebx is the
        ; ID of which of two ping pong buffers in the DMA transfer
        ; area we are currently using. It doesn't matter which one
        ; you start with -- this inner loop will toggle it for you.
LoopY:
        ; Compute the smaller of:
        ; 1) As many scans as the hardware can
        ; 2) The number of scans remaining to process
        ; Save off the coords of the block we will be DMAing back
        mov     eax,dwMaxScansPerTransfer
        cmp     eax,dwScansRemaining
        jl      @F
        mov     eax,dwScansRemaining
@@:     sub     dwScansRemaining,eax
        or      eax,eax
        je      DoneXfer
        mov     ecx,dwSrcTopOffset
        mov     dword ptr dwBlockHeight[ebx * 4],eax
        mov     dword ptr dwBlockTop[ebx * 4],ecx
        mov     dword ptr dwBlockTransferInitiated[ebx * 4],1
        lea     edx,[eax + ecx]
        mov     dwSrcTopOffset,edx

        ; DMA back what we have computed as the Block rectangle
        push    pHWBoardCXOffset
        push    dwSrcBitsOffset
        push    dwSrcBpp
        push    dwSrcPitch
        push    dwSrcLeft
        add     ecx,dwSrcTop
        push    ecx
        push    dwExtX
        push    eax
        call    HW_BlockSrcVramDstSystem
        mov     dword ptr dwBlockOffset[ebx * 4],ecx

DoneXfer:
        ; Flip to the other block
        xor     ebx,1

        ; Call the hardware specific code to wait for the other block
        ; (the one we did not just issue the transfer for immediately
        ; above) to complete. The first time through, there will be
        ; no "other" block that has yet been transfered, so skip the
        ; waiting and the copy.
        cmp     dword ptr dwBlockTransferInitiated[ebx * 4],0
        je      DoneCopy
        mov     dword ptr dwBlockTransferInitiated[ebx * 4],0
        mov     edx,pHWBoardCXOffset
        call    HW_WaitSrcVramDstSystem

        ; Now call the appropriate routine to handle the Blt for the Block
        cmp     dwUseDibeng,0
        jne     UseDibeng

        ; Using our own internal routines -- faster but only handle
        ; SrcCopy from any color depth to any other.
        push    ebx
        mov     esi,dword ptr dwBlockOffset[ebx * 4]
        mov     edi,dwDstBltOffset
        push    dwExtX
        push    dword ptr dwBlockHeight[ebx * 4]
        push    dwSrcWrapWidth
        push    dwDstWrapWidth
        call    NEAR PTR pfnCopyXlat
        mov     dwDstBltOffset,edi
        pop     ebx

DoneCopy:
        ; We know we are done when there are no active transfers
        mov     eax,dword ptr dwBlockTransferInitiated[0 * 4]
        or      eax,dword ptr dwBlockTransferInitiated[1 * 4]
        jne     LoopY
        jmp     DoneLoop

UseDibeng:
        call    RopBackWithDibeng
        jmp     DoneCopy

DoneLoop:
        ; Let the hardware know we are done
        mov     edx,pHWBoardCXOffset
        call    HW_EndSrcVramDstSystem
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DoneIt:
        mov     eax,1
ExitIt:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     OurRopSetup
;
; Purpose:      This function is called when we will be using some of
;               our own private routines to do the ropping of data that
;               has been DMAed back from the screen. It sets up some
;               variables that are needed for our inner loop.
;
; Arguments:    stack frame for GN_BitBltSrcVramDstSystem
;               ds      Context Selector
;
; Returns:      None
;
; Preserve:     ds
;==============================================================================
PUBLIC  OurRopSetup
OurRopSetup     PROC    NEAR

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Setup variables that we know our pfnCopyXlat routine needs.
        ; Compute the dst addresses. For dst that are multiples of a
        ; byte/pixel, the addresses will be byte addresses. For 4bpp,
        ; addresses will be nibble addresses. For 1bpp, bit addresses.
OurSetup:
        mov     dwUseDibeng,0
        mov     eax,dwDstPitch
        mov     edx,dwDstTop
        imul    edx,eax
        add     edx,dwDstBitsOffset
        mov     es,word ptr dwDstBitsSel

        mov     ecx,dwDstBpp
        mov     ebx,dwExtX
        cmp     ecx,4
        je      Is4
        jc      Is1
Is8orM:
        inc     ecx
        and     ecx,NOT 1
        shr     ecx,3
        imul    ebx,ecx
        sub     eax,ebx
        imul    ecx,dwDstLeft
        add     edx,ecx
        jmp     @F
Is4:
        add     eax,eax
        add     edx,edx
        sub     eax,ebx
        add     edx,dwDstLeft
        jmp     @F
Is1:
        shl     eax,3
        shl     edx,3
        sub     eax,ebx
        add     edx,dwDstLeft
@@:
        mov     dwDstWrapWidth,eax
        mov     dwDstBltOffset,edx

        ; Compute the src wrap width
        mov     eax,dwSrcBufferPitch
        mov     ecx,dwSrcBpp
        inc     ecx
        and     ecx,NOT 1
        shr     ecx,3
        imul    ecx,dwExtX
        sub     eax,ecx
        mov     dwSrcWrapWidth,eax
        ret

OurRopSetup     ENDP


;==============================================================================
;
; Function:     DibengRopSetup
;
; Purpose:      This function is called when the Dibeng will be used
;               to do the ropping of data that has been DMAed back from
;               the screen. It sets up some variables that are needed
;               by either DIB_BitBlt or DIB_DibBlt, one of which will
;               be called by the BitBltSrcVramDstSystem interleaved
;               with calls to the DMA routine. The Dibeng routines
;               need a DIBENGINEHDR structure created that describes
;               the DMA transfer area since that will be the source
;               as far as the DIBENG is concerned.
;
; Arguments:    stack frame for GN_BitBltSrcVramDstSystem
;               ds      Context Selector
;
; Returns:      None
;
; Preserve:     ds
;==============================================================================
PUBLIC  DibengRopSetup
DibengRopSetup  PROC    NEAR

        ; We need a DEVICE descriptor for the src which, as far
        ; as the DIBENG is concerned will be the DMA transfer region.
        mov     dwUseDibeng,1
        sub     esi,esi
        les     si,lpSrcDev
        mov     sSrcPDevice.deType,TYPE_DIBENG
        mov     eax,dwExtX
        mov     ebx,dwExtY
        mov     ecx,dwSrcBpp
        inc     ecx
        shr     ecx,3
        imul    ecx,eax
        mov     sSrcPDevice.deWidth,ax
        mov     sSrcPDevice.deHeight,bx
        mov     eax,dword ptr es:[esi].DIBENGINE.deWidthBytes
        mov     ax,cx
        mov     dword ptr sSrcPDevice.deWidthBytes,eax
        mov     eax,dwSrcBufferPitch
        mov     sSrcPDevice.deDeltaScan,eax
        mov     eax,cs:[CSlp16LogDevice]
        mov     sSrcPDevice.delpPDevice,eax
;       mov     dword ptr sSrcPDevice.deBits,           ; Filled in later
        mov     word ptr sSrcPDevice.deBitsSelector,ds
        mov     eax,dword ptr es:[esi].DIBENGINE.deFlags
        and     eax,NOT (VRAM OR OFFSCREEN OR BUSY)
        test    eax,PALETTE_XLAT
        jz      @F
        or      eax,VRAM
@@:
        mov     dword ptr sSrcPDevice.deFlags,eax
        mov     eax,es:[esi].DIBENGINE.deBitmapInfo
        mov     sSrcPDevice.deBitmapInfo,eax
        sub     eax,eax
        ; The bRealBpp field is not needed for this temporary device
        mov     dword ptr sSrcPDevice.bRealBpp,eax
        mov     sSrcPDevice.deBeginAccess,eax
        mov     sSrcPDevice.deEndAccess,eax
        mov     ax,ss
        lea     esi,sSrcPDevice
        shl     eax,10H
        mov     ax,si
        mov     lpDMASrcDev,eax

        mov     eax,lpDstDev
        or      eax,eax
        jne     @F
        mov     eax,lpDstDib
@@:     mov     lpDMADstDev,eax
        ret

DibengRopSetup  ENDP


;==============================================================================
;
; Function:     RopBackWithDibeng
;
; Purpose:      This function is called when the Dibeng should be called
;               to take the data transferred back from the screen, which
;               is now in the DMA transfer region in system memory, and
;               use it as the src in the blt which needs to happen.
;               Based upon whether the caller gave us an lpDstDev or an
;               lpDstDib argument to GN_BitBltSrcVramDstSystem we will
;               call DIB_BitBlt or DIB_DibBlt respectively.
;
; Arguments:    stack frame for GN_BitBltSrcVramDstSystem
;
; Returns:      None
;
; Preserve:     ds,ebx
;==============================================================================
PUBLIC  RopBackWithDibeng
RopBackWithDibeng       PROC    NEAR

        mov     eax,dword ptr dwBlockOffset[ebx * 4]
        mov     dword ptr sSrcPDevice.deBitsOffset,eax

        ; We are using the DIBENG, so we will call either BitBlt or
        ; DibBlt. The src is definitely a bitmap (it is a bitmap in
        ; VRAM, right? -- that's why we are in this routine). The dst
        ; can either be a DIB or a bitmap. Call BitBlt if it is a
        ; bitmap and DibBlt if it is a DIB.
        cmp     lpDstDev,0
        je      UseDibBlt

        PUSHR   ebx
        push    lpDMADstDev
        push    word ptr dwDstLeft
        mov     eax,dwDstTop
        add     eax,dword ptr dwBlockTop[ebx * 4]
        push    ax
        push    lpDMASrcDev
        sub     eax,eax
        push    eax
        mov     eax,dwExtX
        mov     ecx,dword ptr dwBlockHeight[ebx * 4]
        push    ax
        push    cx
        push    dwRop3
        push    lpBrush
        push    lpDrawMode
        call    DIB_BitBlt
        POPR    ebx
        ret

UseDibBlt:
IF 1
        PUSHR   ds,ebx

        ; Conceptually, the important things are:
        ; iStart = BlockTop
        ; DIBBitsPtr = abs(dwDstPitch * dwBlockTop) + dwDstBitsOffset
        ; But we have to adjust the DIBBitsPtr since we can only pass
        ; 16:16 ptrs to the DIBENG. See comments later about tiling.

        ; We need to make some adjustments. Conceptually
        ; DIBBitsPtr = dwDstBitsOffset + (BlockTop + BlockHeight) * DibPitch
        ; DibHeightInHdr temporarily becomes BlockHeight
        ;
        ; The only problem is that DIBBitsPtr might be >= 64K which
        ; means we will need to adjust the selector appropriately ...
        sub     esi,esi
        lds     si,lpDMADstDev

        ; First save the current DIB Height and reset it to the band height
        push    ds:[esi].BitmapInfoHeader.biHeight
        cmp     ds:[esi].BitmapInfoHeader.biHeight,0
        jg      positive_height

        ; Negative DIB Height
        mov     ecx,dword ptr dwBlockHeight[ebx * 4]
        neg     ecx
        mov     ds:[esi].BitmapInfoHeader.biHeight,ecx
        neg     ecx

        ; Compute the DIBBitsPtr
        sub     edx,edx
        mov     eax,dword ptr dwBlockTop[ebx * 4]
        imul    eax,dwDstPitch
        add     eax,dwDstBitsOffset
        jmp     neg_continue

positive_height:
        mov     ecx,dword ptr dwBlockHeight[ebx * 4]
        mov     ds:[esi].BitmapInfoHeader.biHeight,ecx

        ; Compute the DIBBitsPtr
        sub     edx,edx
        mov     eax,dword ptr dwBlockTop[ebx * 4]
        add     eax,ecx
        dec     eax
        imul    eax,dwDstPitch
        add     eax,dwDstBitsOffset

        ; The offset is >= 64K. Windows will have tiled the selectors
        ; so we can just add 8 to the selector for every multiple we
        ; are over 64K.
neg_continue:
        test    eax,0FFFF0000H
        jz      @F
        shld    edx,eax,10H + 3
        and     edx,NOT 7
@@:     add     edx,dwDstBitsSel

        push    lpDMASrcDev
        pushd   10000H
        push    cx
        push    dx
        push    ax
        push    lpDMADstDev
        push    lpDrawMode
        xor     eax,eax
        push    eax
        push    word ptr dwScreenPalettized
        call    DIB_DibBltExt

        ; Restore the real dib height
        pop     ds:[esi].BitmapInfoHeader.biHeight
        POPR    ds,ebx
        ret
ENDIF

RopBackWithDibeng       ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNSTUB.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnstub.asm
;
; Purpose:      This file holds all the display driver entry points
;               that we just end up punting to the DIBENG or returning
;               true or false -- all the stubs basically.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GENERIC_GetCharWidth
;
; Purpose:      This function is the GetCharWidth display driver entry point.
;
;==============================================================================
DECPROC GENERIC_GetCharWidth, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMD   lpBuffer
;PARMW   wFirstChar
;PARMW   wLastChar
;PARMD   lpFontInfo
;PARMD   lpDrawMode
;PARMD   lpTextXForm
OPENPROC
        jmp     DIB_GetCharWidth
CLOSEPROC

IF 0
;==============================================================================
;
; Function:     GENERIC_ColorInfo
;
; Purpose:      This function is the ColorInfo display driver entry point.
;
;==============================================================================
DECPROC GENERIC_ColorInfo, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMD   dwColorIn
;PARMD   lpPhysColor
OPENPROC
        jmp     DIB_ColorInfo
CLOSEPROC
ENDIF

;==============================================================================
;
; Function:     GENERIC_DeviceBitmap
;
; Purpose:      This function is the DeviceBitmap display driver entry point.
;
; Returns:      Always return 0.
;
;==============================================================================
DECPROC GENERIC_DeviceBitmap, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMW   wCommand
;PARMD   lpBitmap
;PARMD   lpBits
OPENPROC
        sub     eax,eax
        RETFAR16  0EH
CLOSEPROC

;==============================================================================
;
; Function:     GENERIC_EnumDFonts
;
; Purpose:      This function is the EnumDFonts display driver entry point.
;
; Returns:      Always return 1.
;
;==============================================================================
DECPROC GENERIC_EnumDFonts, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMD   lpFaceName
;PARMD   lpfnCallback
;PARMD   lpClinetData
OPENPROC
        mov     eax,1
        RETFAR16  10H
CLOSEPROC

;==============================================================================
;
; Function:     GENERIC_EnumObj
;
; Purpose:      This function is the EnumObj display driver entry point.
;
;==============================================================================
DECPROC GENERIC_EnumObj, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMD   lpFaceName
;PARMD   lpfnCallback
;PARMD   lpClinetData
OPENPROC
        pop     eax
        push    cs:[CSlp16LogDevice_In_NVTEXT16]
        push    eax
        jmp     DIB_EnumObjExt
CLOSEPROC

;==============================================================================
;
; Function:     GENERIC_FastBorder
;
; Purpose:      This function is the FastBorder display driver entry point.
;
; Returns:      Return 0 so GDI will simulate via BitBlt.
;
;==============================================================================
DECPROC GENERIC_FastBorder, PASCAL, NOFRAME, FAR16
;PARMD   lpRect
;PARMW   wHorzBorderThick
;PARMW   wVertBorderThick
;PARMD   dwRop
;PARMD   lpDstDev
;PARMD   lpBrush
;PARMD   lpDrawMode
;PARMD   lpClipRect
OPENPROC
        sub     eax,eax
        RETFAR16  1CH
CLOSEPROC

;==============================================================================
;
; Function:     GENERIC_GetPalette
;
; Purpose:      This function is the GetPalette display driver entry point.
;
;==============================================================================
DECPROC GENERIC_GetPalette, PASCAL, NOFRAME, FAR16
;PARMW   wStartIndex
;PARMW   wNumEntries
;PARMD   lpPalette
OPENPROC
        pop     eax
        push    cs:[CSlp16LogDevice_In_NVTEXT16]
        push    eax
        jmp     DIB_GetPaletteExt
CLOSEPROC

;==============================================================================
;
; Function:     GENERIC_GetPaletteTranslate
;
; Purpose:      This function is the GetPaletteTranslate display driver entry
;               point.
;
;==============================================================================
DECPROC GENERIC_GetPaletteTranslate, PASCAL, NOFRAME, FAR16
;PARMD   lpTranslate
OPENPROC
        pop     eax
        push    cs:[CSlp16LogDevice_In_NVTEXT16]
        push    eax
        jmp     DIB_GetPaletteTranslateExt
CLOSEPROC

;==============================================================================
;
; Function:     GENERIC_Inquire
;
; Purpose:      This function is the Inquire display driver entry point.
;
;==============================================================================
DECPROC GENERIC_Inquire, PASCAL, NOFRAME, FAR16
;PARMD   lpCursorInfo
OPENPROC
        jmp     DIB_Inquire
CLOSEPROC

;==============================================================================
;
; Function:     GENERIC_ScanLR
;
; Purpose:      This function is the ScanLR display driver entry point.
;
;==============================================================================
DECPROC GENERIC_ScanLR, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMW   wX
;PARMW   wY
;PARMD   dwPhysColor
;PARMW   wStyle
OPENPROC
        jmp     DIB_ScanLR
CLOSEPROC

;==============================================================================
;
; Function:     GENERIC_SelectBitmap
;
; Purpose:      This function is the SelectBitmap display driver entry point.
;
; Returns:      Always return 1.
;
;==============================================================================
DECPROC GENERIC_SelectBitmap, PASCAL, NOFRAME, FAR16
;PARMD   lpDevice
;PARMD   lpPrevBitmap
;PARMD   lpBitmap
;PARMD   dwFlags
OPENPROC
        mov     eax,1
        RETFAR16  10H
CLOSEPROC

;==============================================================================
;
; Function:     GENERIC_SetAttribute
;
; Purpose:      This function is the SetAttribute display driver entry point.
;
; Returns:      Always return 0.
;
;==============================================================================
DECPROC GENERIC_SetAttribute, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMW   wStateNum
;PARMW   wIndex
;PARMD   dwAttribute
OPENPROC
        sub     eax,eax
        RETFAR16  0CH
CLOSEPROC

;==============================================================================
;
; Function:     GENERIC_Strblt
;
; Purpose:      This function is the Strblt display driver entry point.
;
; Arguments:
;
; Returns:      This function pushes some additional parameters and
;               jumps to the ExtTextOut function. See ExtTextOut for
;               appropiate return values.
;
;==============================================================================
DECPROC GENERIC_Strblt, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMW   wDstX
;PARMW   wDstY
;PARMD   lpClipRect
;PARMD   lpString
;PARMW   wCount
;PARMD   lpFontInfo
;PARMD   lpDrawMode
;PARMD   lpTextXForm
OPENPROC
        sub     ebx,ebx
        pop     eax
        push    ebx
        push    ebx
        push    bx
        push    eax
        jmp     GENERIC_ExtTextOut
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\gnstrblt.asm ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation
;
; File:         gnstrblt.asm
;
; Purpose:      This file holds the StretchBlt display driver entry point.
;
;==============================================================================
.586
incDevice = 1
incDrawMode = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GENERIC_StretchBlt
;
; Purpose:      This function is the StretchBlt display driver entry point.
;
; Arguments:    StretchDIBits Display Driver Stack Frame
;
; Returns:      ax      1  if successful
;                       0  if not successful
;                       -1 GDI should carry out the operation.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_StretchBlt, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wDstX
PARMW   wDstY
PARMW   wDstExtX
PARMW   wDstExtY
PARMD   lpSrcDev
PARMW   wSrcX
PARMW   wSrcY
PARMW   wSrcExtX
PARMW   wSrcExtY
PARMD   dwRop3
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   lpClipRect

LOCALD  dwBmpLeft
LOCALD  dwBmpTop
LOCALD  dwBmpRight
LOCALD  dwBmpBottom
LOCALD  dwSrcLeft
LOCALD  dwSrcTop
LOCALD  dwSrcRight
LOCALD  dwSrcBottom
LOCALD  dwExtX
LOCALD  dwExtY
LOCALD  dwSrcWidth
LOCALD  dwSrcHeight
LOCALD  dwScaleX
LOCALD  dwScaleY
LOCALD	dwDstExtX
LOCALD	dwDstExtY
OPENPROC
        PUSHR   ds,esi,edi

        sub     eax,eax

        ; Load up the ptrs
        sub     edi,edi
        sub     esi,esi
        lfs     di,lpSrcDev
        les     si,lpDstDev

        ; If the dst bitmap is not in VRAM, then punt it.
        cmp     ax,es:[esi].DIBENGINE.deType
        je      GN_StrBltPunt
        test    es:[esi].DIBENGINE.deFlags,VRAM
        jz      GN_StrBltPunt

        ; If the src bitmap is in VRAM, then punt it.
        cmp     ax,fs:[edi].DIBENGINE.deType
        je      GN_StrBltPunt
        test    fs:[edi].DIBENGINE.deFlags,VRAM
        jnz	GN_StrBltPunt

        movsx   eax,wSrcExtX
        movsx   ebx,wDstExtX
        movsx   ecx,wSrcExtY
        movsx   edx,wDstExtY

	; Punt the negative widths (Left-Right mirror Arabic Windows)
	or	eax,ebx
        js	GN_StrBltPunt

	; Punt the negative heights (Top-Bottom mirror)
	or	ecx,edx
        js	GN_StrBltPunt

	; Punt Stretch for mono source
        cmp     fs:[edi].DIBENGINEHDR.bRealBpp,1
	je	GN_StrBltPunt

        ; Make sure the device is not busy.
        mov     ds,cs:[wFlatDataSel]
        mov     ebx,cs:[CSpGNLogicalDevice]
        cmp     ds:[ebx].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_StrBltPunt

        ; First, do clipping
        call    GN_StretchBltClip
        or      eax,eax
	mov	eax,1
        je      GN_StrBltExit

        ; If the rop involves a pattern, prepare the pattern now
        movzx   eax,byte ptr [dwRop3 + 2]
        movzx   ecx,byte ptr cs:Rop3Table[eax]
        cmp     ecx,PAD
        je      PrepBrush
        cmp     ecx,PSD
        je      PrepBrush
        movzx   esi,word ptr lpDstDev+0
        jmp     GN_StretchColorBlt

PrepBrush:
        mov     es,word ptr lpBrush+2
        movzx   esi,word ptr lpBrush+0
        push    lpDrawMode
        mov     ebx,cs:[CSpGNLogicalDevice]
        call    GN_PrepareBrush
        or      eax,eax
        je      GN_StrBltExit
        mov     eax,0
        jl      GN_StrBltExit

        ; reload some stuff that got trashed
        ; Load up the ptrs
        sub     edi,edi
        sub     esi,esi
        lfs     di,lpSrcDev
        les     si,lpDstDev
        jmp     GN_StretchColorBlt

GENERIC_StretchBlt	ENDP

;==============================================================================
;
; Function:     StretchBlt ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of StretchBlt. You can either return a success code,
;               a failure code, punt to the DIBENG, etc.
;
; Arguments:    StretchBlt Display Driver Stack Frame
;
;==============================================================================
PUBLIC  GN_StrBltPunt
GN_StrBltPunt     PROC    NEAR
	push	lpDstDev
	push	wDstX
	push	wDstY
	push	wDstExtX
	push	wDstExtY
	push	lpSrcDev
	push	wSrcX
	push	wSrcY
	push	wSrcExtX
	push	wSrcExtY
	push	dwRop3
	push	lpBrush
	push	lpDrawMode
	push	lpClipRect
PLABEL	Punt_StrBlt
        call    DIB_StretchBlt
        .errnz  $ - OFFSET GN_StrBltExit

GN_StrBltPunt     ENDP

PUBLIC  GN_StrBltExit
GN_StrBltExit   PROC    NEAR

        POPR    ds,esi,edi
        mov     sp,bp
        pop     ebp

        ; Clean and return normally
        RETFAR16 28H
GN_StrBltExit   ENDP


;==============================================================================
;
; Function:     GN_StretchColorBlt
;
; Purpose:      This function is jumped to from the StretchBlt
;               display driver entry point. We have already clipped
;               the DIB/Bitmap, made the determination that we will
;               handle the call and locked the display. Here, the
;               parameters should be pushed on the stack to call the
;               HW specific routine to perform the mono transfer.
;
; Arguments:    StretchBlt Display Driver Stack Frame
;               ds      Context Selector
;               fs:edi  lpSrcDev ptr (ptr to DIBENGINE HDR)
;               es:esi  lpDstDev ptr  (ptr to DIBENGINE HDR)
;
; Returns:      No returns -- this function is jumped to. When it is done it
;               should jump to one of the StretchBlt ending routines.
;
;==============================================================================
DECPROC GN_StretchColorBlt, PASCAL, NOFRAME, NEAR
OPENPROC
        mov     ebx,cs:[CSpGNLogicalDevice]
        push    ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        movzx   eax,word ptr es:[esi].DIBENGINE.deBits+4
        push    eax
        push    dword ptr es:[esi].DIBENGINE.deBits
        movzx   eax,es:[esi].DIBENGINEHDR.bRealBpp
        push    eax
        push    es:[esi].DIBENGINE.deDeltaScan
        push    dwBmpLeft
        push    dwBmpTop
        movzx   eax,word ptr fs:[edi].DIBENGINE.deBits+4
        push    eax
        push    dword ptr fs:[edi].DIBENGINE.deBits
        movzx   eax,fs:[edi].DIBENGINEHDR.bRealBpp
        push    eax
        push    fs:[edi].DIBENGINE.deDeltaScan
        push    dwSrcLeft
        push    dwSrcTop
        push    dwExtX
        push    dwExtY

        push    dwRop3
        push    lpBrush                         ; lpBrush
        push    lpDrawMode                      ; lpDrawMode

        sub     ebx,ebx
        push	ebx                             ; dwSizeColorTableEntry
        push    ebx                             ; number color table entries
        push    ebx                             ; lpColorTable

        ; pfnCopyXlat - NULL means that HW_BitBltSrcColorDstVram
        ; must determine the correct copy / xlat routine for itself.
        push    ebx
	push	dwDstExtX
	push	dwDstExtY
	push	lpClipRect
        call    GN_StretchBltSrcColorDstVram
        or      eax,eax
        je      GN_StrBltPunt
        mov     eax,1
        jmp     GN_StrBltExit

GN_StretchColorBlt      ENDP


;==============================================================================
;
; Function:     GN_StretchBltClip
;
; Purpose:      This function clips the src and dst Bitmaps for StretchBlt.
;
; Arguments:    StretchBlt Display Driver Stack Frame
;               fs:edi  lpSrcDev ptr (ptr to DIBENGINE HDR)
;
; Returns:      eax     = 0, there is nothing to draw
;                       > 0, there is something to draw
;
; Preserve:     fs,edi,es
;==============================================================================
PUBLIC  GN_StretchBltClip
GN_StretchBltClip    PROC    NEAR

        ; Get the width and height of the DIB and compute the signed pitch.
        movsx	edx,fs:[edi].DIBENGINE.deWidth
        movsx	ecx,fs:[edi].DIBENGINE.deHeight
	mov     dwSrcWidth,edx
        mov     dwSrcHeight,ecx

        movsx   edx,wSrcY
        movsx   ecx,wSrcExtY
        movsx   esi,wDstY
	movsx	ebx,wDstExtY

	mov	dwExtY,ecx
	mov	dwDstExtY,ebx
        mov     dwSrcTop,edx
        mov     dwBmpTop,esi

        ; Compute the unclipped src bounding rectangle
        mov     esi,dwSrcHeight
        movsx   eax,wSrcX
        mov	edx,dwExtY
        mov	ebx,dwSrcTop
        movsx   ecx,wSrcExtX
        add     ecx,eax
        sub     esi,ebx
        mov     dwSrcRight,ecx
        mov     dwSrcBottom,esi
        mov     dwSrcLeft,eax
        sub     esi,edx
        mov     dwSrcTop,esi

        ; Compute the unclipped Bitmap bounding rectangle
        movsx	eax,wDstX
        mov     ebx,dwBmpTop
        mov     dwBmpLeft,eax
	movsx	ecx,wDstExtX
	mov	edx,dwDstExtY
        add     eax,ecx
        add     ebx,edx
        mov     dwBmpRight,eax
        mov     dwBmpBottom,ebx

	; Calculate the scaling factor
	sub	eax,eax
	shrd	eax,ecx,12
	mov	ecx,edx
        movsx   ebx,wSrcExtX
	sub	edx,edx
	idiv	ebx
	mov	dwScaleX,eax
	sub	eax,eax
	shrd	eax,ecx,12
        mov	ebx,dwExtY
	sub	edx,edx
	idiv	ebx
	mov	dwScaleY,eax

        ; Do the source clipping on the left and top of the src and dst bitmaps
        mov	eax,dwSrcLeft
        mov	ebx,dwSrcTop
        or      eax,eax
        jns     @F
        sub     dwSrcLeft,eax
	neg	eax
	imul	eax,dwScaleX
	shr	eax,20
        add	dwBmpLeft,eax
@@:     or      ebx,ebx
        jns     @F
        sub     dwSrcTop,ebx
	neg	ebx
	imul	ebx,dwScaleY
	shr	ebx,20
        add	dwBmpTop,ebx
@@:
        ; Do source clipping on the right and bottom of the src and dst bitmaps
        mov     eax,dwSrcBottom
        sub     eax,dwSrcHeight
        jle	@F
        sub     dwSrcBottom,eax
	imul	eax,dwScaleY
	shr	eax,20
        sub     dwBmpBottom,eax
@@:	mov	eax,dwSrcRight
        sub     eax,dwSrcWidth
        jle	@F
        sub     dwSrcRight,eax
	imul	eax,dwScaleX
	shr	eax,20
        sub     dwBmpRight,eax

@@:
        ; Dst clipping uses the clip rectangle
        sub     esi,esi
        lgs     si,lpClipRect

        ; Clip the dst left and top edges
        mov     eax,dwBmpLeft
        movsx   edx,gs:[esi].RECT.left
        sub     eax,edx
        jge	@F
	neg	eax
	shl	eax,20
	sub	edx,edx
	idiv	dwScaleX
        add     dwSrcLeft,eax
	imul	eax,dwScaleX
	shr	eax,20
        add     dwBmpLeft,eax
@@:
	mov     eax,dwBmpTop
        movsx   edx,gs:[esi].RECT.top
        sub     eax,edx
        jge	@F
	neg	eax
	shl	eax,20
	sub	edx,edx
	idiv	dwScaleY
        add     dwSrcTop,eax
	imul	eax,dwScaleY
	shr	eax,20
        add     dwBmpTop,eax
@@:

        ; Clip the dst right and bottom edges
        mov     eax,dwBmpRight
        movsx   edx,gs:[esi].RECT.right
        sub     eax,edx
        jle	@F
	shl	eax,20
	sub	edx,edx
	idiv	dwScaleX
        sub     dwSrcRight,eax
	imul	eax,dwScaleX
	shr	eax,20
        sub     dwBmpRight,eax
@@:
	mov     eax,dwBmpBottom
        movsx   edx,gs:[esi].RECT.bottom
        sub     eax,edx
        jle	@F
	shl	eax,20
	sub	edx,edx
	idiv	dwScaleY
        sub     dwSrcBottom,eax
	imul	eax,dwScaleY
	shr	eax,20
        sub     dwBmpBottom,eax
@@:

DoneClip:
        ; It's all clipped -- now compute the extents
        mov     eax,dwSrcRight
        mov     ebx,dwSrcBottom
        sub     eax,dwSrcLeft
        jle     NothingVisible
        sub     ebx,dwSrcTop
        jle     NothingVisible
        mov     dwExtX,eax
        mov     dwExtY,ebx

        mov     eax,dwBmpRight
        mov     ebx,dwBmpBottom
        sub     eax,dwBmpLeft
        jle     NothingVisible
        sub     ebx,dwBmpTop
        jle     NothingVisible
        mov     dwDstExtX,eax
        mov     dwDstExtY,ebx
        mov     eax,1
        ret

NothingVisible:
        sub     eax,eax
        ret

GN_StretchBltClip    ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNSSB.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation.
;
; File:         gnssb.asm
;
; Purpose:      This file holds the SaveScreenBitmap display driver
;               entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

; These aren't in any API header file so include them here
SAVE_AREA       EQU     0
RESTORE_AREA    EQU     1
DISCARD_AREA    EQU     2

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     GN_ClearSaveScreenBitmapCache
;
; Purpose:      This function clears the SaveScreenBitmap cache.
;
; Arguments:
;               ds                      CXSel
;               pGNLogevCXOffset        GNLOGDEVCX ptr
;
; Returns:
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_ClearSaveScreenBitmapCache, PASCAL, FRAME, FAR32
PARMD   pGNLogevCXOffset
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogevCXOffset

	PUSHR	ds
	POPR	es
        lea     edi,ds:[esi].GNLOGDEVCX.SaveScreenBitmapCache
        mov     eax,-1
        mov     ebx,MAX_SSBS

        ; Initialize the template SSB headers
@@:
        mov     esi,pGNLogevCXOffset
        mov     ecx,(SIZE DIBENGINE + 3) / 4
        mov     edx,edi
        rep     movs dword ptr es:[edi], ds:[esi]
        and     es:[edx].DIBENGINE.deFlags,MINIDRIVER OR PALETTIZED OR FIVE6FIVE
        mov     es:[edi],eax
        lea     edi,[edx + SIZE DEVBMP]
        dec     ebx
        jne     @B
Done:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GENERIC_SaveScreenBitmap
;
; Purpose:      This function is the SaveScreenBitmap display driver
;               entry point.
;
; Arguments:    SaveScreenBitmap Display Driver Stack Frame
;
; Returns:      ax      0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_SaveScreenBitmap, PASCAL, FRAME, FAR16
PARMD   lpRect
PARMW   wCommand
OPENPROC
        PUSHR   ds,esi,edi
        mov     ds,cs:[wFlatDataSel]
        mov     ebx,cs:[CSpGNLogicalDevice]
        sub     eax,eax

        ; Make sure the screen is free
        cmp     eax,ds:[ebx].GNLOGDEVCX.dwHardwareBusy
        jne     GN_SaveScreenBitmapFail

        cmp     eax,lpRect
        je      GN_SaveScreenBitmapFail

        ; switch on the command
        cmp     wCommand,RESTORE_AREA
        jc      SSB_SaveArea
        jmp     SSB_RestoreOrDiscardArea

GENERIC_SaveScreenBitmap        ENDP


;==============================================================================
;
; Function:     SaveScreenBitmap ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of SaveScreenBitmap. You can either return a success code, a failure
;               code, punt to the DIBENG, etc.
;
; Arguments:    SaveScreenBitmap Display Driver Stack Frame
;
;==============================================================================
PUBLIC  GN_SaveScreenBitmapFail
GN_SaveScreenBitmapFail PROC    NEAR
        sub     eax,eax
        jmp     GN_SaveScreenBitmapExit
GN_SaveScreenBitmapFail ENDP

PUBLIC  GN_SaveScreenBitmapSuccess
GN_SaveScreenBitmapSuccess      PROC    NEAR
        mov     eax,1
GN_SaveScreenBitmapSuccess      ENDP

PUBLIC  GN_SaveScreenBitmapExit
GN_SaveScreenBitmapExit PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 06H
GN_SaveScreenBitmapExit ENDP



;==============================================================================
;
; Function:     SSB_SaveArea
;
; Purpose:      This function is jumped to when the SaveScreenBitmap
;               function flavor is to save the area specified.
;
;               We can try to allocate a bitmap both in offscreen or
;               in a page locked DMAable section of memory. Try the
;               offscreen area first -- if that doesn't work, go for
;               the DMAable memory area.
;               NOTE: Right now, only doing offscreen VRAM SSBs.
;
; Arguments:    SaveScreenBitmap Display Driver Stack Frame
;               ds              Context Selector
;               ebx             GNLOGDEVCX ptr
;
; Returns:      jump to one of the SSB ending routinee when you are done
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  SSB_SaveArea
SSB_SaveArea    PROC    NEAR

        ; Fail if cannot use any of the SSB area (offscreen, DMAable)
        mov     eax,ds:[ebx].GNLOGDEVCX.pGNBoardCX
        mov     eax,ds:[eax].GNBOARDCX.dwOffscreenFlags
        test    eax,NO_OFFS_BMPS
        jnz     GN_SaveScreenBitmapFail

        ; Get the rectangle to save
        sub     edi,edi
        lgs     di,lpRect
        mov     eax,dword ptr gs:[edi].RECT.left
        mov     edx,dword ptr gs:[edi].RECT.right

        ; Make sure the rectangle to save is valid
        mov     edi,edx
        mov     esi,edx
        sub     di,ax
        jle     GN_SaveScreenBitmapFail
        sub     esi,eax
        jle     GN_SaveScreenBitmapFail

        ; If any of the existing save screen areas match the new
        ; area to save, then consider the old area trashed and
        ; resave it.
        lea     edi,[ebx].GNLOGDEVCX.SaveScreenBitmapCache
        mov     esi,MAX_SSBS
Loopy1:
        cmp     eax,dword ptr ds:[edi].DEVBMP.wLeft
        jne     @F
        cmp     edx,dword ptr ds:[edi].DEVBMP.wRight
        je      DoBlt
@@:     add     edi,SIZE DEVBMP
        dec     esi
        jne     Loopy1

        ; Find a free SSB header to use.
        lea     edi,[ebx].GNLOGDEVCX.SaveScreenBitmapCache
        mov     ecx,-1
        mov     esi,MAX_SSBS
Loopy2:
        cmp     ecx,dword ptr ds:[edi].DEVBMP.wLeft
        je      @F
        add     edi,SIZE DEVBMP
        dec     esi
        jne     Loopy2
        jmp     GN_SaveScreenBitmapFail
@@:
        ; Complete one of the SSB headers to descibe the region being saved
        mov     dword ptr ds:[edi].DEVBMP.wLeft,eax
        mov     dword ptr ds:[edi].DEVBMP.wRight,edx
        sub     edx,eax
        mov     dword ptr ds:[edi].DIBENGINE.deWidth,edx
        mov     ax,word ptr ds:[ebx].GNLOGDEVCX.Dibeng.dePlanes
        mov     word ptr ds:[edi].DIBENGINE.dePlanes,ax
        movzx   eax,ah
        movzx	edx,dx
        shr     eax,3
        imul    eax,edx
        mov     ds:[edi].DIBENGINE.deWidthBytes,ax

        ; Can we get an offscreen bitmap?
        PUSHR	ds
        POPR	es
        push    ds:[ebx].GNLOGDEVCX.pGNBoardCX
        call    GN_OffscreenBitmapCreate
        or      eax,eax
        jne     DoBlt

        ; If doing DMAable -- try to allocate one in here

        ; If the offscreen allocation failed, mark the SSB slot as
        ; free again and then fail the call
        mov     dword ptr ds:[edi].DEVBMP.wLeft,-1
        jmp     GN_SaveScreenBitmapFail

DoBlt:
        mov     ebx,cs:[CSpGNLogicalDevice]
        push    ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        mov     eax,edi
        sub     eax,ebx
        add     eax,cs:[CSlp16LogDevice]
        push    eax                             ; lpDstDev
        push    cs:[CSlp16LogDevice]            ; lpSrcDev
        sub     eax,eax
        push    eax                             ; lpBrush
        push    eax                             ; lpDrawMode
        push    eax                             ; dstX:dstY
        mov     eax,dword ptr ds:[edi].DEVBMP.wLeft
        mov     ebx,dword ptr ds:[edi].DIBENGINE.deWidth
        ror     eax,10H
        ror     ebx,10H
        push    eax                             ; srcX:srcY
        push    ebx                             ; extX:extY
        mov     eax,0CC0000H
        push    eax                             ; Rop3
        call    HW_BitBltSrcVramDstVram
        or      eax,eax
        jg      GN_SaveScreenBitmapSuccess
        sub     eax,eax
        call    GN_SaveScreenBitmap
        jmp     GN_SaveScreenBitmapSuccess

SSB_SaveArea    ENDP


;==============================================================================
;
; Function:     SSB_RestoreOrDiscardArea
;
; Purpose:      This function is jumped to when the SaveScreenBitmap
;               function flavor is to restore or discard a saved area.
;
; Arguments:    SaveScreenBitmap Display Driver Stack Frame
;               ds              Context Selector
;               ebx             GNLOGDEVCX ptr
;
; Returns:      jump to one of the SSB ending routines when you are done
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  SSB_RestoreOrDiscardArea
SSB_RestoreOrDiscardArea        PROC    NEAR

        ; Load the rectangle to restore or discard
        sub     esi,esi
        les     si,lpRect
        mov     eax,dword ptr es:[esi].RECT.left
        mov     edx,dword ptr es:[esi].RECT.right

        ; Search for it in the list of saved areas
        lea     edi,[ebx].GNLOGDEVCX.SaveScreenBitmapCache
        sub     edi,SIZE DEVBMP
        mov     esi,MAX_SSBS
        mov     ecx,-1
@@:
        add     edi,SIZE DEVBMP
        dec     esi
        jl      GN_SaveScreenBitmapFail
        cmp     ecx,dword ptr ds:[edi].DEVBMP.wLeft
        je      @B
        cmp     eax,dword ptr ds:[edi].DEVBMP.wLeft
        jne     @B
        cmp     edx,dword ptr ds:[edi].DEVBMP.wRight
        jne     @B

Match:
        ; Only do the copy back if the command was restore
        cmp     wCommand,RESTORE_AREA
        jne     @F

        ; If we are allowing DMAable, figure out which one it is
        ; The below only supports VRAM SSBs

        mov     ebx,cs:[CSpGNLogicalDevice]
        push    ds:[ebx].GNLOGDEVCX.pHWLogdevCX
        push    cs:[CSlp16LogDevice]            ; lpDstDev
        mov     eax,edi
        sub     eax,ebx
        add     eax,cs:[CSlp16LogDevice]
        sub     ecx,ecx
        push    eax                             ; lpSrcDev
        push    ecx                             ; lpBrush
        push    ecx                             ; lpDrawMode
        mov     eax,dword ptr ds:[edi].DEVBMP.wLeft
        mov     ebx,dword ptr ds:[edi].DIBENGINE.deWidth
        ror     eax,10H
        ror     ebx,10H
        push    eax                             ; dstX:dstY
        push    ecx                             ; srcX:srcY
        push    ebx                             ; extX:extY
        mov     eax,0CC0000H
        push    eax                             ; rop3
        call    HW_BitBltSrcVramDstVram
        or      eax,eax
        jg      @F
        mov     eax,1
        call    GN_SaveScreenBitmap
@@:
        ; Inidicate the SSB cache slot is now free and release the
        ; memory used by the saved area.
        mov     eax,-1
        mov     dword ptr ds:[edi].DEVBMP.wLeft,eax
        mov     ebx,cs:[CSpGNLogicalDevice]
        push    ds:[ebx].GNLOGDEVCX.pGNBoardCX
	pushd	0
        PUSHR	ds
        POPR	es
        call    GN_OffscreenBitmapDelete
        jmp     GN_SaveScreenBitmapSuccess

SSB_RestoreOrDiscardArea        ENDP



;==============================================================================
;
; Function:     GN_SaveScreenBitmap
;
; Purpose:      This function will save or restore the screen area
;               in software. It is used only if the hardware specific
;               routine fails.
;
; Arguments:    ds      Context Selector
;               edi     DEVBMP ptr. This structure is a DIBENGINE struct
;                       with four extra fields DEVBMP.wLeft, DEVBMP.wRight,
;                       DEVBMP.wTop, DEVBMP.wBottom. These fields specify
;                       a rectangular area of the screen that the bitmap
;                       ds:esi is currently holding or is waiting to hold.
;               eax     0 then copy the rectangle from the primary screen
;                         given by the DEVBMP rectangle specifiers to the
;                         bitmap specified by the DIBENGINE portion of the
;                         DEVBMP structure. This is a SAVE operation.
;                       1 ten copy the bitmap specified by the DIBENGINE
;                         portion of the DEVBMP structure to the rectangle
;                         on the main screen given by the DEVBMP rectangle
;                         specifiers. This is a RESTORE operation.
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_SaveScreenBitmap, PASCAL, FRAME, NEAR
LOCALD  dwRestoreOperation
LOCALD  dwWidthInBytes
LOCALD  dwWholeDwords
LOCALD  dwExtraBytes
LOCALD  dwSrcWrapWidth
LOCALD  dwDstWrapWidth
LOCALD  dwHeight
OPENPROC
        PUSHR   ds,esi,edi

        ; Save this for later
        mov     dwRestoreOperation,eax

        ; Compute the Blt width in a few different formats
        movzx   eax,ds:[edi].DEVBMP.wRight
        movzx   ebx,ds:[edi].DEVBMP.wLeft
        movzx   ecx,ds:[edi].DIBENGINE.deBitsPixel
        sub     eax,ebx
        shr     ecx,3
        imul    eax,ecx
        mov     edx,eax
        mov     ecx,eax
        mov     dwWidthInBytes,eax
        and     eax,3
        mov     dwExtraBytes,eax
        shr     edx,2
        mov     dwWholeDwords,edx

        ; Compute the wrap widths
        mov     ebx,cs:[CSpGNLogicalDevice]
        mov     eax,ds:[ebx].GNLOGDEVCX.Dibeng.deDeltaScan
        mov     edx,ds:[edi].DIBENGINE.deDeltaScan
        sub     eax,ecx
        sub     edx,ecx
        mov     dwSrcWrapWidth,eax
        mov     dwDstWrapWidth,edx

        ; Compute the Blt height
        movzx   eax,ds:[edi].DEVBMP.wBottom
        movzx   ecx,ds:[edi].DEVBMP.wTop
        sub     eax,ecx
        mov     dwHeight,eax

        ; Compute the starting address on the primary display
        movzx   eax,ds:[edi].DIBENGINE.deBitsPixel
        movzx   edx,ds:[edi].DEVBMP.wTop
        movzx   ecx,ds:[edi].DEVBMP.wLeft
        shr     eax,3
        imul    edx,ds:[ebx].GNLOGDEVCX.Dibeng.deDeltaScan
        imul    eax,ecx
        add     eax,edx
        les     edi,fword ptr ds:[edi].DIBENGINE.deBits
        lds     esi,fword ptr ds:[ebx].DIBENGINE.deBits
        add     esi,eax

        ; If it is a save, then we are ready to go. If it is a restore
        ; then we need to switch the src and dst ptrs and wrap widths.
        cmp     dwRestoreOperation,0
        je      @F
        xchg    esi,edi
        mov     ax,es
        mov     dx,ds
        mov     ds,ax
        mov     es,dx
        mov     eax,dwSrcWrapWidth
        mov     edx,dwDstWrapWidth
        mov     dwSrcWrapWidth,edx
        mov     dwDstWrapWidth,eax
@@:
        mov     ecx,dwWholeDwords
        rep     movs dword ptr es:[edi], ds:[esi]
        mov     ecx,dwExtraBytes
        rep     movs byte ptr es:[edi], ds:[esi]
        add     esi,dwSrcWrapWidth
        add     edi,dwDstWrapWidth
        dec     dwHeight
        jne     @B

        POPR    ds,esi,edi
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNTEXT.ASM ===
;==============================================================================
;
; Copyright (C) 1998,Nvidia Corporation
;
; File:         gntext.asm
;
; Purpose:      This file holds the ExtTextOut display driver entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
incFont     = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; GLYPHLOOP MACRO IndexSize,TableSize,IsKerning
;
; This macro generates all the inner loops for the text code. There are
; three arguments each of which can be one of two options giving a total
; of 8 inner loops. The options for each argument are as follows:
; IndexSize     ByteGlyph or WordGlyph
; TableSize     WordTable or DwordTable
; IsKerning     Kerning   or NoKerning
;
; The following registers/variables are expected to be setup before
; invoking the macro. The registers on the far right are just notes -
; they describe what registers will be used to hold the variable
; values when they are being used in the macro.
;
; ds                    NewFontSeg selector
; dwGlyphCount          number of glyphs to do
; word ptr lpString+2   selector to list of glyphs      gs
; dwStringOffset        offset to list of glyphs        ecx
; word ptr lpKerning+2  selector to Kerning Vector      fs
; dwkerningOffset       offset to Kerning vector        esi

GLYPHLOOP       MACRO   IndexSize,TableSize,IsKerning
        LOCAL   Loopy

        ;; Load up a few ptrs outside the main loop
        mov     gs,word ptr lpString+2

        IFIDNI  <IsKerning>,<Kerning>
                mov     fs,word ptr lpKerning+2
        ENDIF
Loopy:
        mov     ecx,dwStringOffset
        mov     edi,(NewFontSeg PTR ds:[0]).nfGlyphOffset

        IFDIFI  <IsKerning>,<Kerning>
                ;; If there is no Kerning,we need to know the character width
                mov     esi,(NewFontSeg PTR ds:[0]).nfAWTable
        ENDIF

        ;; Load a byte or word character glyph based upon the glyph size
        IFIDNI  <IndexSize>,<ByteIndex>
                movzx   edx,byte ptr gs:[ecx]
                inc     ecx
        ELSE
                movzx   edx,word ptr gs:[ecx]
                add     ecx,2
        ENDIF

        ;; Handle SMALLBITGLYHP and LARGEBITGLYPH separately.
        IFIDNI  <TableSize>,<WordTable>
                ;; If there is no Kerning,save the glyph width for later
                IFDIFI  <IsKerning>,<Kerning>
                        movzx   eax,word ptr ds:[esi][edx * 2]
                        movzx   esi,word ptr ds:[edi][edx * 2]
                        mov     dwStringOffset,ecx
                        mov     dwGlyphWidth,eax
                ELSE
                        movzx   esi,word ptr ds:[edi][edx * 2]
                        mov     dwStringOffset,ecx
                ENDIF

                mov     ebx,dwDstYDstX
                movsx   eax,ds:[esi].SMALLBITGLYPH.sbgOrgX
                movsx   ecx,ds:[esi].SMALLBITGLYPH.sbgOrgY
                movsx   edx,ds:[esi].SMALLBITGLYPH.sbgHeight
                add     bx,ax
                shl     ecx,10H
                shl     edx,10H

	        ;; Handle the right edge clipping
		cmp     bx,word ptr dwClipRight
	        jge     Doneit

                sub     ebx,ecx
                or      dl,ds:[esi].SMALLBITGLYPH.sbgWidth
                je      next1
                movzx   ecx,ds:[esi].SMALLBITGLYPH.sbgPixels
                add     esi,SIZE SMALLBITGLYPH
        ELSE
                IFDIFI  <IsKerning>,<Kerning>
                        movzx   eax,word ptr ds:[esi][edx * 2]
                        mov     esi,dword ptr ds:[edi][edx * 4]
                        mov     dwStringOffset,ecx
                        mov     dwGlyphWidth,eax
                ELSE
                        mov     esi,dword ptr ds:[edi][edx * 4]
                        mov     dwStringOffset,ecx
                ENDIF

                mov     ebx,dwDstYDstX
                mov     edx,dword ptr ds:[esi].LARGEBITGLYPH.lbgWidth
                add     bx,ds:[esi].LARGEBITGLYPH.lbgOrgX
                mov     ecx,ds:[esi].LARGEBITGLYPH.lbgPixels

	        ;; Handle the right edge clipping
		cmp     bx,word ptr dwClipRight
	        jge     Doneit

                ror     ebx,10H
                sub     bx,ds:[esi].LARGEBITGLYPH.lbgOrgY
                or      dx,dx
                je      next1
                ror     ebx,10H
                add     esi,SIZE LARGEBITGLYPH
        ENDIF

        ;; Call the hardware specific routine to blt the glyph
        call    HW_TextBlt

next1:
        IFIDNI  <IsKerning>,<Kerning>
                mov     edi,dwKerningOffset
                movsx   eax,word ptr fs:[edi]
                add     edi,2
                add     eax,dwDstYDstX
                mov     dwKerningOffset,edi
                mov     word ptr dwDstYDstX,ax
        ELSE
                mov     eax,dwGlyphWidth
                add     eax,dwDstYDstX
                mov     word ptr dwDstYDstX,ax
        ENDIF

        ;; Do all the glyphs in the string
        dec     dwGlyphCount
        jg      Loopy
Doneit:
ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


OPENSEG  _DATA,USE16,DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32,%DEF_CODE_SIZE,CODE

PUBLIC  GlyphBltTable
GlyphBltTable   LABEL   NEAR
DD      OFFSET  GlyphBltByteIndexWordTableIsKerning
DD      OFFSET  GlyphBltWordIndexWordTableIsKerning
DD      OFFSET  GlyphBltByteIndexWordTableNoKerning
DD      OFFSET  GlyphBltWordIndexWordTableNoKerning
DD      OFFSET  GlyphBltByteIndexDWordTableIsKerning
DD      OFFSET  GlyphBltWordIndexDWordTableIsKerning
DD      OFFSET  GlyphBltByteIndexDWordTableNoKerning
DD      OFFSET  GlyphBltWordIndexDWordTableNoKerning

;==============================================================================
;
; Function:     GENERIC_ExtTextOut
;
; Purpose:      This function is the ExtTextOut display driver entry point.
;
; Arguments:    ExtTextOut Display Driver Stack Frame
;
; Returns:      This function returns one of the following values:
;
;               If wCount is negative and the function is successful,
;               it returns the X extent in AX,and the Y extent in DX.
;               If wCount is negative and the function is unsuccessful,
;               it returns the 7FFFH in AX,and wDstY in DX.
;
;               If wCount is 0 or positive and the the function is
;               successful,it returns DX:AX set to 1.
;               If wCount is 0 or positive and the the function is
;               unsuccessful,it returns DX:AX set to 80000000H.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GENERIC_ExtTextOut,PASCAL,FRAME,FAR16
EXTTEXTOUT_FRAME_AND_LOCALS
OPENPROC
        PUSHR   ds,esi,edi

        ; Grab some arguments for initial filtering
        movsx   edx,wCount
        movzx   eax,wOptions
        mov     ds,word ptr lpDstDev+2
        movzx   esi,word ptr lpDstDev+0

        ; If this is a sizing call,then punt it.
        or      edx,edx
        jl      GN_ExtTextOutPunt

        ; If the text is anti-aliased,then punt it.
        test    ah,ETO_LEVEL_MODE / 256
        jnz     GN_ExtTextOutPunt

        ; If the font is not packed properly,then punt it.
        test    ah,ETO_BIT_PACKED / 256
        jz      GN_ExtTextOutPunt

        ; Grab some parameters from the dst.
        movzx   ecx,ds:[esi].DIBENGINE.deType
        movzx   eax,ds:[esi].DIBENGINE.deFlags

        ; If the font is not in VRAM,then punt it.
        or      ecx,ecx
        je      GN_ExtTextOutPunt
        test    ah,VRAM / 256
        jz      GN_ExtTextOutPunt

        mov     es,cs:[wFlatDataSel]
        mov     ebx,cs:[CSpGNLogicalDevice]

        ; If the text operation involves palette translation then punt it.
        test    ah,PALETTE_XLAT / 256
        jnz     GN_ExtTextOutPunt

        mov     eax,es:[ebx].GNLOGDEVCX.pHWLogdevCX
        mov     ecx,es:[ebx].GNLOGDEVCX.pGNBoardCX
        cmp     es:[ebx].GNLOGDEVCX.dwHardwareBusy,0
        jne     GN_ExtTextOutPunt
        mov     edx,es:[ecx].GNBOARDCX.pHWBoardCX
        mov     pHWLogDevCXOffset_ForExtTextOut,eax
        mov     pHWBoardCXOffset_ForExtTextOut,edx

        ; Save off a few things from the dst device we will need.
        mov     eax,dword ptr ds:[esi].DIBENGINE.deBits
        mov     ecx,ds:[esi].DIBENGINE.deDeltaScan
        mov     dwDstBitsOffset,eax
        mov     dwDstBitsDeltaScan,ecx

        ; We will need the colors from the DRAWMODE structure
        sub     edi,edi
        lds     di,lpDrawMode
        mov     eax,ds:[edi].DRAWMODE.TextColor
        mov     edx,ds:[edi].DRAWMODE.bkColor
        mov     dwFgColor,eax
        mov     dwBgColor,edx

        ; Save the clip rect now for later use.
        lds     di,lpClipRect
        mov     eax,dword ptr ds:[edi].RECT.left
        mov     edx,dword ptr ds:[edi].RECT.right
        mov     dword ptr wOpaqueClipRect.left,eax
        mov     dword ptr wOpaqueClipRect.right,edx
        mov     dword ptr wTextClipRect.left,eax
        mov     dword ptr wTextClipRect.right,edx

        ; Draw opaque rectangles if there are some
        cmp     lpOpaqueRects,0
        je      @F
        call    HW_DrawOpaqueRects
        or      eax,eax
        je      GN_ExtTextOutPunt
@@:
        ; Is there any text to do?
        movsx   eax,wCount
        or      eax,eax
        jle     GN_ExtTextOutSuccess
        mov     dwGlyphCount,eax

IF  (INTERSECT_TEXTXFORM_WITH_CLIP NE 0)
        cmp     lpTextXForm,0
        je      NoX
        mov     eax,dword ptr wTextClipRect.left
        mov     edx,dword ptr wTextClipRect.right
        sub     edi,edi
        lds     di,lpTextXForm
        cmp     ax,ds:[edi].RECT.left
        jg      @F
        mov     ax,ds:[edi].RECT.left
@@:     cmp     dx,ds:[edi].RECT.right
        jl      @F
        mov     dx,ds:[edi].RECT.right
@@:     cmp     dx,ax
        jle     GN_ExtTextOutSuccess
        ror     eax,10H
        ror     edx,10H
        cmp     ax,ds:[edi].RECT.top
        jg      @F
        mov     ax,ds:[edi].RECT.top
@@:     cmp     dx,ds:[edi].RECT.bottom
        jl      @F
        mov     dx,ds:[edi].RECT.bottom
@@:     cmp     dx,ax
        jle     GN_ExtTextOutSuccess
        ror     eax,10H
        ror     edx,10H
        mov     dword ptr wTextClipRect.left,eax
        mov     dword ptr wTextClipRect.right,edx
NoX:
ENDIF
        ; Setup up variables for the glyph loop
        mov     ds,word ptr lpFontInfo+2
        movzx   ecx,wTextClipRect.right
        mov     edx,dword ptr wDstY
        ror     edx,10H
        mov     dwClipRight,ecx
        mov     dwDstYDstX,edx
        movzx   eax,word ptr lpString
        movzx   ecx,word ptr lpKerning
        mov     dwStringOffset,eax
        mov     dwKerningOffset,ecx

        ; Call the hardware specific routine to prepare for glyphs
        call    HW_TextBegin
        or      eax,eax
        je      GN_ExtTextOutPunt1

HostTextBlt:
        ; Dispatch to the correct handler
        sub     ebx,ebx
        push    OFFSET GN_ExtTextOutRet
        mov     cl,byte ptr ds:[ebx].NewFontSeg.nfFormat
        mov     ebx,lpKerning
        mov     al,byte ptr wOptions
        test    cl,NF_LARGE
        jnz     IsLG
IsSG:   or      ebx,ebx
        jne     IsSGK
IsSGNK: test    al,ETO_GLYPH_INDEX
        jz      GlyphBltByteIndexWordTableNoKerning
        jmp     GlyphBltWordIndexWordTableNoKerning
IsSGK:  test    al,ETO_GLYPH_INDEX
        jz      GlyphBltByteIndexWordTableIsKerning
        jmp     GlyphBltWordIndexWordTableIsKerning
IsLG:   or      ebx,ebx
        jne     IsLGK
IsLGNK: test    al,ETO_GLYPH_INDEX
        jz      GlyphBltByteIndexDWordTableNoKerning
        jmp     GlyphBltWordIndexDWordTableNoKerning
IsLGK:  test    al,ETO_GLYPH_INDEX
        jz      GlyphBltByteIndexDWordTableIsKerning
        jmp     GlyphBltWordIndexDWordTableIsKerning

GENERIC_ExtTextOut  ENDP


;==============================================================================
;
; Functions:    ExtTextOut ending routines
;
; Purpose:      These functions are all the possible ways of getting out
;               of ExtTextOut. You can either return a success code,a
;               failure code,punt to the DIBENG,etc.
;
; Arguments:    ExtTextOut Display Driver Stack Frame
;               fs      selector of PDEVICE
;
;==============================================================================
PUBLIC  GN_ExtTextOutPunt1
GN_ExtTextOutPunt1      PROC    NEAR
        ; Jump to here when the opaqueing rects have been drawn but you
        ; wish to punt the text.
        mov     lpOpaqueRects,0
GN_ExtTextOutPunt1      ENDP

PUBLIC  GN_ExtTextOutPunt
GN_ExtTextOutPunt     PROC    NEAR
        ; Jump to here when you want to punt the whole call.
        POPR    ds,esi,edi
        STOPPROC
PLABEL	Punt_ExtTextOut
        jmp     DIB_ExtTextOut
GN_ExtTextOutPunt     ENDP

PUBLIC  GN_ExtTextOutRet
GN_ExtTextOutRet  PROC    NEAR
        call    HW_TextEnd
GN_ExtTextOutRet  ENDP

PUBLIC  GN_ExtTextOutSuccess
GN_ExtTextOutSuccess   PROC    NEAR
        mov     eax,1
GN_ExtTextOutSuccess   ENDP

PUBLIC  GN_ExtTextOutExit
GN_ExtTextOutExit     PROC    NEAR
        POPR    ds,esi,edi
        STOPPROC
        RETFAR16 28H
GN_ExtTextOutExit     ENDP


;==============================================================================
;
; Function:     GlyphBltByteIndexWordTableIsKerning
;
; Purpose:      This glyphblt routine handles the case where the:
;               1) Glyph Index is a byte quantity
;               2) The Glyph Table is a word array
;               3) There is a Kerning vector
;
; Arguments:    Same as for the GLYPHLOOP macro
;
;==============================================================================
PUBLIC  GlyphBltByteIndexWordTableIsKerning
GlyphBltByteIndexWordTableIsKerning     PROC    NEAR

        GLYPHLOOP  ByteIndex,WordTable,Kerning
        ret

GlyphBltByteIndexWordTableIsKerning     ENDP



;==============================================================================
;
; Function:     GlyphBltWordIndexWordTableIsKerning
;
; Purpose:      This glyphblt routine handles the case where the:
;               1) Glyph Index is a byte quantity
;               2) The Glyph Table is a word array
;               3) There is a Kerning vector
;
; Arguments:    Same as for the GLYPHLOOP macro
;
;==============================================================================
PUBLIC  GlyphBltWordIndexWordTableIsKerning
GlyphBltWordIndexWordTableIsKerning     PROC    NEAR

        GLYPHLOOP  WordIndex,WordTable,Kerning
        ret

GlyphBltWordIndexWordTableIsKerning     ENDP



;==============================================================================
;
; Function:     GlyphBltByteIndexWordTableNoKerning
;
; Purpose:      This glyphblt routine handles the case where the:
;               1) Glyph Index is a byte quantity
;               2) The Glyph Table is a word array
;               3) There is a Kerning vector
;
; Arguments:    Same as for the GLYPHLOOP macro
;
;==============================================================================
PUBLIC  GlyphBltByteIndexWordTableNoKerning
GlyphBltByteIndexWordTableNoKerning PROC    NEAR

        GLYPHLOOP  ByteIndex,WordTable,NoKerning
        ret

GlyphBltByteIndexWordTableNoKerning ENDP



;==============================================================================
;
; Function:     GlyphBltWordIndexWordTableNoKerning
;
; Purpose:      This glyphblt routine handles the case where the:
;               1) Glyph Index is a byte quantity
;               2) The Glyph Table is a word array
;               3) There is a Kerning vector
;
; Arguments:    Same as for the GLYPHLOOP macro
;
;==============================================================================
PUBLIC  GlyphBltWordIndexWordTableNoKerning
GlyphBltWordIndexWordTableNoKerning PROC    NEAR

        GLYPHLOOP  WordIndex,WordTable,NoKerning
        ret

GlyphBltWordIndexWordTableNoKerning ENDP



;==============================================================================
;
; Function:     GlyphBltByteIndexDWordTableIsKerning
;
; Purpose:      This glyphblt routine handles the case where the:
;               1) Glyph Index is a byte quantity
;               2) The Glyph Table is a word array
;               3) There is a Kerning vector
;
; Arguments:    Same as for the GLYPHLOOP macro
;
;==============================================================================
PUBLIC  GlyphBltByteIndexDWordTableIsKerning
GlyphBltByteIndexDWordTableIsKerning    PROC    NEAR

        GLYPHLOOP  ByteIndex,DWordTable,Kerning
        ret

GlyphBltByteIndexDWordTableIsKerning    ENDP



;==============================================================================
;
; Function:     GlyphBltWordIndexDWordTableIsKerning
;
; Purpose:      This glyphblt routine handles the case where the:
;               1) Glyph Index is a byte quantity
;               2) The Glyph Table is a word array
;               3) There is a Kerning vector
;
; Arguments:    Same as for the GLYPHLOOP macro
;
;==============================================================================
PUBLIC  GlyphBltWordIndexDWordTableIsKerning
GlyphBltWordIndexDWordTableIsKerning PROC    NEAR

        GLYPHLOOP  WordIndex,DWordTable,Kerning
        ret

GlyphBltWordIndexDWordTableIsKerning ENDP



;==============================================================================
;
; Function:     GlyphBltByteIndexDWordTableNoKerning
;
; Purpose:      This glyphblt routine handles the case where the:
;               1) Glyph Index is a byte quantity
;               2) The Glyph Table is a word array
;               3) There is a Kerning vector
;
; Arguments:    Same as for the GLYPHLOOP macro
;
;==============================================================================
PUBLIC  GlyphBltByteIndexDWordTableNoKerning
GlyphBltByteIndexDWordTableNoKerning PROC    NEAR

        GLYPHLOOP  ByteIndex,DWordTable,NoKerning
        ret

GlyphBltByteIndexDWordTableNoKerning ENDP



;==============================================================================
;
; Function:     GlyphBltWordIndexDWordTableNoKerning
;
; Purpose:      This glyphblt routine handles the case where the:
;               1) Glyph Index is a byte quantity
;               2) The Glyph Table is a word array
;               3) There is a Kerning vector
;
; Arguments:    Same as for the GLYPHLOOP macro
;
;==============================================================================
PUBLIC  GlyphBltWordIndexDWordTableNoKerning
GlyphBltWordIndexDWordTableNoKerning PROC    NEAR

        GLYPHLOOP  WordIndex,DWordTable,NoKerning
        ret

GlyphBltWordIndexDWordTableNoKerning ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNTHK16.ASM ===
;==============================================================================
;
; Copyright (C) 1998, NVidia Coporation
;
; File:         gnblt.asm
;
; Purpose:      This file holds the 16 bit entry point for compatibility
;               with some old apps that patch display driver entry points
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc

ReserveForPatch	macro name
	nop
	nop
	nop
	nop
	nop
public	Patch_&name&
Patch_&name&	proc	FAR16
Patch_&name&	endp
        jmp     GENERIC_&name&
	endm

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

PUBLIC  wLog, wBreak16
wLog                    DW      1
wBreak16                DW      0

;==============================================================================
;
; Function:     Bitblt
;
; Purpose:      This function is the 16 Bit BitBlt display driver
;               entry point. It jumps to the real 32 Bit BitBlt to
;               do all the work.
;
; Arguments:    BitBlt Display Driver Stack Frame
;
;==============================================================================
DECPROC BitBlt, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	BitBlt
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor
;
; Purpose:      This function is the 16 Bit SetCursor display driver
;               entry point. It jumps to the real 32 Bit SetCursor to
;               do all the work.
;
; Arguments:    SetCursor Display Driver Stack Frame
;
;==============================================================================
DECPROC SetCursor, PASCAL, NOFRAME, FAR16
OPENPROC
        jmp     GENERIC_SetCursor
CLOSEPROC


;==============================================================================
;
; Function:     MoveCursor
;
; Purpose:      This function is the 16 Bit MoveCursor display driver
;               entry point. It jumps to the real 32 Bit MoveCursor to
;               do all the work.
;
; Arguments:    MoveCursor Display Driver Stack Frame
;
;==============================================================================
DECPROC MoveCursor, PASCAL, NOFRAME, FAR16
OPENPROC
        jmp     GENERIC_MoveCursor
CLOSEPROC


;==============================================================================
;
; Function:     SetPalette
;
; Purpose:      This function is the 16 Bit SetPalette display driver
;               entry point. It jumps to the real 32 Bit SetPalette to
;               do all the work.
;
; Arguments:    SetPalette Display Driver Stack Frame
;
;==============================================================================
DECPROC SetPalette, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	SetPalette
CLOSEPROC

;==============================================================================
;
; Function:     BitmapBits
;
; Purpose:      This function is the 16 Bit BitmapBits display driver
;               entry point. It jumps to the real 32 Bit BitmapBits to
;               do all the work.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;
;==============================================================================
DECPROC BitmapBits, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	BitmapBits
CLOSEPROC

;==============================================================================
;
; Function:     Control
;
; Purpose:      This function is the 16 Bit Control display driver
;               entry point. It jumps to the real 32 Bit Control to
;               do all the work.
;
; Arguments:    Control Display Driver Stack Frame
;
;==============================================================================
DECPROC Control, PASCAL, NOFRAME, FAR16
OPENPROC
        jmp     GENERIC_Control
CLOSEPROC

;==============================================================================
;
; Function:     ExtTextOut
;
; Purpose:      This function is the 16 Bit ExtTextOut display driver
;               entry point. It jumps to the real 32 Bit ExtTextOut to
;               do all the work.
;
; Arguments:    ExtTextOut Display Driver Stack Frame
;
;==============================================================================
DECPROC ExtTextOut, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	ExtTextOut
CLOSEPROC

;==============================================================================
;
; Function:     DibBlt
;
; Purpose:      This function is the 16 Bit DibBlt display driver
;               entry point. It jumps to the real 32 Bit DibBlt to
;               do all the work.
;
; Arguments:    DibBlt Display Driver Stack Frame
;
;==============================================================================
DECPROC DibBlt, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	DibBlt
CLOSEPROC

;==============================================================================
;
; Function:     FastBorder
;
; Purpose:      This function is the 16 Bit FastBorder display driver
;               entry point.
;
; Arguments:    FastBorder Display Driver Stack Frame
;
;==============================================================================
DECPROC FastBorder, PASCAL, NOFRAME, FAR16
OPENPROC
        sub     eax,eax
        retf	1CH
CLOSEPROC

;==============================================================================
;
; Function:     Output
;
; Purpose:      This function is the 16 Bit Output display driver
;               entry point. It jumps to the real 32 Bit Output to
;               do all the work.
;
; Arguments:    Output Display Driver Stack Frame
;
;==============================================================================
DECPROC Output, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	Output
CLOSEPROC

;==============================================================================
;
; Function:     Pixel
;
; Purpose:      This function is the 16 Bit Pixel display driver
;               entry point. It jumps to the real 32 Bit Pixel to
;               do all the work.
;
; Arguments:    Pixel Display Driver Stack Frame
;
;==============================================================================
DECPROC Pixel, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	Pixel
CLOSEPROC

;==============================================================================
;
; Function:     RealizeObject
;
; Purpose:      This function is the 16 Bit RealizeObject display driver
;               entry point. It jumps to the real 32 Bit RealizeObject to
;               do all the work.
;
; Arguments:    RealizeObject Display Driver Stack Frame
;
;==============================================================================
DECPROC RealizeObject, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	RealizeObject
CLOSEPROC

;==============================================================================
;
; Function:     ReEnable
;
; Purpose:      This function is the 16 Bit ReEnable display driver
;               entry point. It jumps to the real 32 Bit ReEnable to
;               do all the work.
;
; Arguments:    ReEnable Display Driver Stack Frame
;
;==============================================================================
DECPROC ReEnable, PASCAL, NOFRAME, FAR16
OPENPROC
        jmp     GENERIC_ReEnable
CLOSEPROC

;==============================================================================
;
; Function:     ScanLR
;
; Purpose:      This function is the 16 Bit ScanLR display driver
;               entry point. It jumps to the real 32 Bit ScanLR to
;               do all the work.
;
; Arguments:    ScanLR Display Driver Stack Frame
;
;==============================================================================
DECPROC ScanLR, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	ScanLR
CLOSEPROC

;==============================================================================
;
; Function:     SetDIBitsToDevice
;
; Purpose:      This function is the 16 Bit SetDIBitsToDevice display driver
;               entry point. It jumps to the real 32 Bit SetDIBitsToDevice to
;               do all the work.
;
; Arguments:    SetDIBitsToDevice Display Driver Stack Frame
;
;==============================================================================
DECPROC SetDIBitsToDevice, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	SetDIBitsToDevice
CLOSEPROC

;==============================================================================
;
; Function:     SetPaletteTranslate
;
; Purpose:      This function is the 16 Bit SetPaletteTranslate display driver
;               entry point. It jumps to the real 32 Bit SetPaletteTranslate to
;               do all the work.
;
; Arguments:    SetPaletteTranslate Display Driver Stack Frame
;
;==============================================================================
DECPROC SetPaletteTranslate, PASCAL, NOFRAME, FAR16
OPENPROC
        jmp     GENERIC_SetPaletteTranslate
CLOSEPROC

;==============================================================================
;
; Function:     StrBlt
;
; Purpose:      This function is the 16 Bit StrBlt display driver
;               entry point. It jumps to the real 32 Bit StrBlt to
;               do all the work.
;
; Arguments:    StrBlt Display Driver Stack Frame
;
;==============================================================================
DECPROC StrBlt, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	StrBlt
CLOSEPROC

;==============================================================================
;
; Function:     StretchBlt
;
; Purpose:      This function is the 16 Bit StretchBlt display driver
;               entry point. It jumps to the real 32 Bit StretchBlt to
;               do all the work.
;
; Arguments:    StretchBlt Display Driver Stack Frame
;
;==============================================================================
DECPROC StretchBlt, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	StretchBlt
CLOSEPROC

;==============================================================================
;
; Function:     StretchDIBits
;
; Purpose:      This function is the 16 Bit StretchDIBits display driver
;               entry point. It jumps to the real 32 Bit StretchDIBits to
;               do all the work.
;
; Arguments:    StretchDIBits Display Driver Stack Frame
;
;==============================================================================
DECPROC StretchDIBits, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	StretchDIBits
CLOSEPROC


;==============================================================================
;
; Function:     SaveScreenBitmap
;
; Purpose:      This function is the 16 Bit SaveScreenBitmap display driver
;               entry point. It jumps to the real 32 Bit SaveScreenBitmap to
;               do all the work.
;
; Arguments:    SaveScreenBitmap Display Driver Stack Frame
;
;==============================================================================
DECPROC SaveScreenBitmap, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	SaveScreenBitmap
CLOSEPROC

;==============================================================================
;
; Function:     UpdateColors
;
; Purpose:      This function is the 16 Bit UpdateColors display driver
;               entry point. It jumps to the real 32 Bit UpdateColors to
;               do all the work.
;
; Arguments:    UpdateColors Display Driver Stack Frame
;
;==============================================================================
DECPROC UpdateColors, PASCAL, NOFRAME, FAR16
OPENPROC
	ReserveForPatch	UpdateColors
CLOSEPROC

IFDEF DEBUG
;==============================================================================
;
; Function:     GENERIC_OutputDebugString
;
; Purpose:      This function checks a global logging variable and then
;               calls OutputDebugString if logging is enabled.
;
;               DO NOT USE the DECPROC macro to define this routine.
;               The DECPROC macro logs when in debug mode. The logging
;               calls this routine. We will nest until the stack
;               overflows.
;
; Arguments:    16:16 ptr to string to print
;
; Returns:      None
;
; Preserve:     All registers
;==============================================================================
PUBLIC  GENERIC_OutputDebugString
GENERIC_OutputDebugString       PROC    FAR16

        cmp     cs:[wLog],0
        je      DoneIt

        push    bp
        mov     bp,sp
        PUSHR   alld,ds,es,fs,gs
        push    dword ptr ss:[bp + 06H]
        call    OutputDebugString
        POPR    alld,ds,es,fs,gs
        pop     bp
DoneIt:
        retf    4

GENERIC_OutputDebugString       ENDP
ENDIF

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\INCLUDE\GNBOARD.H ===
/*=============================================================================

    Copyright (C) 1997, NVidia Coporation

    File:       gnboard.h

    Purpose:    This file holds structures and equates dealing with the
                GNBOARDCX.

=============================================================================*/

typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;


// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// The following data structure holds information about a logical device
// to board context.

typedef struct  _LOGDEVTOBOARD
{
    ULONG   dwBoardDevnodeHandle;
    ULONG   dwGNBoardCXOffset;
}   LOGDEVTOBOARD;

// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// The following data structure holds information about a particular
// offscreen bitmap. There is an array of these structures.

typedef struct  _OFFBMPINFO
{
    ULONG   dwBitmapSel;
    ULONG   dwBitmapOffset;
    ULONG   dwBitmapLength;
    ULONG   dwBitmapVRAMOffset;
}   OFFBMPINFO;
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// The following is for the shared memory allocation escapes.
typedef struct  _ID_AND_DATA
{
    ULONG   dwID;
    ULONG   dwData;
}   ID_AND_DATA;
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// ;;;;;;;;;;;;;;;;;;;  The Generic Board Context  ;;;;;;;;;;;;;;;;;;;;;;;;

#define MAX_OFFSCREEN_BITMAPS       0x0300
#define MAX_SHARED_MEM_BLOCKS       0x04

typedef struct  _GNBOARDCX
{
    // Set to 1 when initting. Cleared on first modeset.
    ULONG       dwInitting;

    // How many CRTCs are available on this board?
    ULONG       dwNumCrtcsOnBoard;

    // How many GNLOGDEV structs are attached to this board.
    ULONG       dwLogicalDeviceInstancesOnThisBoard;

    // Here are all the logical devices attached to the board
    ULONG       pGNLogdevCX[MAX_ATTACHED_CRTCS];

    // This is the flat data selector that this board is using.
    ULONG       dwFlatDataSelector;

    // This field is TRUE if DX is active, and FALSE if not.
    ULONG       dwDirectXActive;

    // Keep track of this.
    ULONG       pHWBoardCX;

    // This variable holds the number of bytes of video memory needed
    // to validate mode.
    ULONG       dwMemorySizeForValidateMode;

    // This is the registry path that this board will be using as
    // the local base path -- the place in the registry where values
    // specific to this board are stored.
    ULONG       dwDeviceNodeHandle;
    ULONG       lpLocalDisplayBasePath;
    UCHAR       szLocalDisplayBasePath[128];

    // The starting offset and length in video memory of the space
    // available for offscreen allocations.
    ULONG       dwOffscreenBaseAddress;
    ULONG       dwOffscreenLength;

    // Offscreen Memory And Bitmap Management
    ULONG       dwOffscreenHeap;
    ULONG       dwOffscreenFlags;
    ULONG       dwOffscreenLockCount;

    ULONG       dwOffscreenBitmapsAllocatedSinceLastFlush;
    ULONG       dwOffscreenBitmapsCurrentlyAllocated;
    ULONG       dwBytesOfOffscreenMemoryCurrentlyAllocatedForBitmaps;
    ULONG       pNextOffbmpinfo;
    OFFBMPINFO  OffscreenBitmapCache[MAX_OFFSCREEN_BITMAPS];

    // Used for some crazy display device management stuff.
    ULONG       dwCheckCursorTicksSinceSecondDriverLoaded;
    ULONG       dwOldTwinviewState;
    ULONG       dwOldPrimaryDevData;
    ULONG       dwOldCloneDevData;

    // This array is for shared memory allocated by clients.
    ID_AND_DATA sSharedMemBlocks[MAX_SHARED_MEM_BLOCKS];
}   GNBOARDCX;

// These flags can be used in the dwOffscreenFlags field.
#define OFFS_ALLOCS_BLOCKED         0x0001
#define OFFS_HEAP_UNAVAILABLE       0x0002
#define NO_OFFS_BMPS                0x0003
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNVALMOD.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnvalmod.asm
;
; Purpose:      This file holds the ValidateMode display driver entry point.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include valmode.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include modeext.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GENERIC_ValidateMode
;
; Purpose:      This function is the ValidateMode driver entry
;               point. Make sure that the requested mode can be
;               supported. This will be based upon the amount of
;               memory, memory speed, output device (tv, monitor),
;               and maybe other things.
;
; Arguments:    ValidateMode display driver stack frame
;
; Returns:      eax     VALMODE_NO_UNKNOWN Can't be sure mode is supported
;                       VALMODE_YES        Mode definitely can be supported
;
; Preserve:     ds,esi,edi
;==============================================================================
PUBLIC  ValidateMode
ValidateMode    PROC    FAR
        ; Windows requires that ValidateMode be exported by name. I
        ; have the real routine GENERIC_ValidateMode equated to the
        ; same address.
        .errnz  $ - OFFSET GENERIC_ValidateMode
ValidateMode    ENDP

DECPROC GENERIC_ValidateMode, PASCAL, FRAME, FAR16
PARMD   lpValMode
LOCALD  dwCRTCCount
LOCALD  dwMemoryNeededForMode
LOCALV  sModeInfo,MODEINFO
LOCALV  sValModeCopy,DISPVALMODE
OPENPROC
        PUSHR   ds,esi,edi

        ; This may be the first call into the display driver besides
        ; the driver entry point which does not do anything. If we
        ; have not initted the driver, then just return VALMODE_YES.
        mov     eax,VALMODE_YES
        cmp     cs:[wNVTEXT16_Alias_In_NVTEXT16],0
        je      DoneIt

        ; Load the context selector and GNLOGDEVCX ptr
        mov     ds,cs:[wFlatDataSel_In_NVTEXT16]
        mov     esi,cs:[CSpGNLogicalDevice_In_NVTEXT16]

        ; if we are the primary, ...
        cmp     cs:[dwThisLogicalDeviceHandle_In_NVTEXT16],1
        jne     @F

        ; then don't bother trying to validate modes on a secondary
        ; right now -- just say yes.
        ; Kludge!! Peek up into GDI's stack frame and see if they
        ; want to validate on the primary or secondary
        mov     bx,ss:[bp]
        cmp     dword ptr ss:[bx + 14H],1
        je      @F
        
        ; If we fall through then we are validating a secondary mode on the
        ; primary driver. Check if this mode is overridden by the OEM.
        push    esi
        push    lpValMode
        call    GN_CheckForOEMOverrides
        or      ax,ax
        jne     FailMode
        
        ; Windows has a nasty habit of validating modes for the disabled
        ; secondary display on the primary driver. If we do not validate this
        ; mode, then Windows, in its infinite wisdom, will not let us change
        ; the mode on the primary. Since the secondary is disabled, we don't
        ; know what the actual display device is and therefore can not
        ; properly validate the mode. Therefore, we just say yes for all these
        ; modes. When the secondary display is actually enabled, the secondary
        ; driver will properly fall back to a mode that the display device can
        ; handle.
        jmp     Success
        
@@:
        ; Make sure pGNCrtcCX is not a null pointer.
        cmp     ds:[esi].GNLOGDEVCX.pGNCrtcCX,0
        je      Success

        ; Make a copy of the ValidateMode structure passed in by Windows
        ; so we can modify it if the mode is bogus.
        sub     ebx,ebx
        lfs     bx,lpValMode

        push    esi
        push    edi
        mov     cx,size DISPVALMODE
        sub     edi,edi
        mov     di,ss
        mov     es,di
        lea     di,sValModeCopy
        mov     esi,ebx
        rep     movs byte ptr es:[edi], fs:[esi]
        pop     edi
        pop     esi
        
        ; Load the copy into ES:[EBX] 
        mov     ax,ss
        shl     eax,10h
        lea     ax,sValModeCopy
        mov     lpValMode,eax
        sub     ebx,ebx
        les     bx,lpValMode
        
        ; Check if this mode is overridden by the OEM.
        push    esi
        push    lpValMode
        call    GN_CheckForOEMOverrides
        or      ax,ax
        jne     FailMode

        ; Check if this is a bogus multiple of 8 mode passed in because 
        ; Win98 in multimon mode wants resolutions to be a multiple of 8
        ; so 1600x900 gets changed to 1600x896 and 1400x1050 gets changed
        ; to 1400x1048. GN_CheckForMultipleOf8Mode will adjust to a mode
        ; we can handle
        mov     ax,ss
        shl     eax,10h
        lea     ax,es:[ebx].DISPVALMODE.dvmXRes
        push    eax
        lea     ax,es:[ebx].DISPVALMODE.dvmYRes
        push    eax
        call    GN_CheckForMultipleOf8Mode

        ; Check for bogus mode 604x402 that we sometimes get
        cmp     es:[ebx].DISPVALMODE.dvmXRes,604
        je      FailMode
        cmp     es:[ebx].DISPVALMODE.dvmYRes,402
        je      FailMode

        ; Get the memory needed for the mode
        mov     eax,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[eax].GNBOARDCX.pHWBoardCX
        movzx   eax,es:[ebx].DISPVALMODE.dvmXRes
        push    eax
        movzx   eax,es:[ebx].DISPVALMODE.dvmYRes
        push    eax
        movzx   eax,es:[ebx].DISPVALMODE.dvmBpp
        push    eax
        call    HW_GetModeDimensions
        mov     dwMemoryNeededForMode,ebx

        ; Get the largest memory size that we could put this mode in.
        ; We suppose we can purge DX heap if we'll need an extra free space.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     eax,ds:[ebx].GNBOARDCX.dwMemorySizeForValidateMode

        ; Is it enough?
        cmp     eax,dwMemoryNeededForMode
        jb      FailMode

        ; For right now, if this is 480x360 or 960x720, and the device
        ; is a DFP, then disallow the mode. PLEASE NOTE: There is a
        ; corresponding check for these modes in the Modeset DLL.
        sub     ebx,ebx
        les     bx,lpValMode
        movzx   eax,es:[ebx].DISPVALMODE.dvmXRes
        movzx   edx,es:[ebx].DISPVALMODE.dvmYRes
        
Check480x360:
        cmp     eax,1E0H
        jne     Check960x720
        cmp     edx,168H
        jne     Check960x720
        jmp     CheckDisplayType
        
Check960x720:
        cmp     eax,3C0H
        jne     NotBadMode
        cmp     edx,2D0H
        jne     NotBadMode
        
CheckDisplayType:
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        lea     ebx,[ecx].GNCRTCCX.sCrtcModeInfo
        mov     eax,ds:[ebx].MODEINFO.MIDevData
        cmp     al,DEVTYPE_DFP
        je      FailMode

NotBadMode:
        ; Check for the registry key that says we allow all the modes.
        ; If set, then any desktop is OK and everyone will just pan and
        ; scan as needed.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetAllowMightyModesFlag,es,ax
        or      ax,ax
        jne     Success

MustValPhys:
        ; Always validate on the primary CRTC. We always allow the
        ; secondary to pan.

        ; Get everything into a MODEINFO structure
        sub     ebx,ebx
        les     bx,lpValMode
        movzx   eax,es:[ebx].DISPVALMODE.dvmXRes
        mov     sModeInfo.dwXRes,eax
        movzx   eax,es:[ebx].DISPVALMODE.dvmYRes
        mov     sModeInfo.dwYRes,eax
        movzx   eax,es:[ebx].DISPVALMODE.dvmBpp
        mov     sModeInfo.dwBpp,eax

        ; If this mode validation is occuring after a SetDisplayConfig
        ; escape, then the display device information in the GNCRTCCX
        ; may be stale. Check the dwDisplayDeviceChange flag, and if it
        ; is equal to 1, then just validate the mode. After all display
        ; devices are mapped during Enable, we will clear the flag and
        ; revalidate to make sure the mode can actually be set.
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        cmp     ds:[ecx].GNCRTCCX.dwDisplayDeviceChange,1
        je      Success

        ; We don't know what refresh rate they really want. Just
        ; choose a large value so that if we support any refresh
        ; rate at the resolution and pixel depth desired, then
        ; we will validate the mode.
        mov     sModeInfo.dwRefreshRate,1000
        lea     ebx,[ecx].GNCRTCCX.sCrtcModeInfo
        mov     eax,ds:[ebx].MODEINFO.MIDevData
        mov     sModeInfo.MIDevData,eax

        ; Maybe we should re read the EDID
        push    ecx
        call    GN_CheckAndMaybeReadEdid

        mov     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        push    ecx
        mov     ax,ss
        shl     eax,10H
        lea     ax,sModeInfo
        push    eax
        sub     ebx,ebx
        lfs     bx,ds:[ecx].GNCRTCCX.lpNvmodeDispData
        push    fs:[ebx].DISPDATA.dwMonitorInfType
        push    ds:[ecx].GNCRTCCX.lpEdidBuffer
        push    ds:[ecx].GNCRTCCX.dwEdidSize
        call    GN_ValidatePhysicalMode

        test    eax,MODE_RESOLUTION_ADJUSTED
        jnz     FailMode

Success:
        mov     eax,VALMODE_YES
        jmp     DoneIt

FailMode:
        mov     eax,VALMODE_NO_UNKNOWN

DoneIt:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_ValidatePhysicalMode
;
; Purpose:      This function is a more specific version of the
;               Validate Mode call. The mode passed in is validated
;               and adjusted downwards to something that can be set
;               if it is out of range.
;
; Arguments:
;               ds                      Context Selector
;               pGNCrtcCXOffset         GNCRTCCX
;               lpModeInfoToValidate    MODEINFO ptr
;               dwTypeMonitorInf
;               lpEdidBuffer            Edid Buffer ptr
;               dwEdidBufferSize        size of lpEdidBuffer. This
;                                       will be 0 if there is no EDID
;
; Returns:      eax                     A combination of the bitflags
;                                       defined in modeext.h like
;                                       MODE_RESOLUTION_ADJUSTED
;                                       MODE_REFRESHRATE_ADJUSTED
;                                       etc..
;
;               Note that if eax indicates that the lpModeInfoToValidate
;               could not be supported, then lpModeInfoToValidate will
;               have been modified on return to reflect the
;               next largest possible mode that can.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_ValidatePhysicalMode, PASCAL, FRAME, FAR16
PARMD   pGNCrtcCXOffset
PARMD   lpModeInfoToValidate
PARMD   dwTypeMonitorInf
PARMD   lpLocalEdidBuffer
PARMD   dwEdidBufferSize
LOCALD  dwSaveMonitorInfType
LOCALV  sDispData,DISPDATA
LOCALV  sMO,MODEOUT
LOCALV  sSettableCrtcModeInfo,MODEINFO
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNCrtcCXOffset

        ; Build a correct DISPDATA structure
        sub     ebx,ebx
        lfs     bx,ds:[esi].GNCRTCCX.lpNvmodeDispData
        mov     eax,fs:[ebx].DISPDATA.dwMonitorInfType
        mov     dwSaveMonitorInfType,eax
        mov     eax,dwTypeMonitorInf
        mov     fs:[ebx].DISPDATA.dwMonitorInfType,eax

        ; Modify refresh rate list in registry.
        mov     ebx,lpModeInfoToValidate
        lea     bx,[bx].MODEINFO.MIDevData
        push    ebx
        push    ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    lpLocalEdidBuffer
        push    dwEdidBufferSize
        call    FFP16 PTR lpfnResetRefreshRates

        ; Now we are ready to validate!
        push    ds:[esi].GNCRTCCX.lpNvmodeDispData
        push    lpLocalEdidBuffer
        push    dwEdidBufferSize
        push    lpModeInfoToValidate
        mov     ax,ss
        shl     eax,10H
        lea     ax,sMO
        push    eax
        lea     ax,sSettableCrtcModeInfo
        push    eax
        CALLFAR16IND lpfnFindModeEntry,es,ax

        ; Return the mode that can be set
        sub     edi,edi
        les     di,lpModeInfoToValidate
        push    ss
        pop     fs
        lea     esi,sSettableCrtcModeInfo
        mov     ecx,SIZE MODEINFO
        rep     movs byte ptr es:[edi], fs:[esi]
        mov     esi,pGNCrtcCXOffset

        ; Restore the NvmodeDispData
        sub     ebx,ebx
        lfs     bx,ds:[esi].GNCRTCCX.lpNvmodeDispData
        mov     ecx,dwSaveMonitorInfType
        mov     fs:[ebx].DISPDATA.dwMonitorInfType,ecx

        POPR    esi,edi
CLOSEPROC

;==============================================================================
;
; Function:     GN_GetFreeBlockSizeForMode
;
; Purpose:      This function is called to get the FreeBlock size
;               that we can fit a mode into. This whole determination
;               is actually very complicated because it depends upon
;               many things. Like whether we are running just one
;               logical device on this board, or more. And, if more
;               than one, whether DirectX is running on the device
;               that we are NOT trying to get a FreeBlock size for.
;               Argh! Just follow the comments along in the code.
;               That is where the details are.
;
; Arguments:
;               ds                      COntext Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;
; Returns:      eax     The largest free block that would be available
;                       to set the mode in.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetFreeBlockSizeForMode, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
LOCALD  dwMyOffscreenFlags
LOCALD  dwJustOnePrimaryCanMove
LOCALD  pOtherGNLogdevCXOffset
LOCALD  dwValidationFreeBlockSize
OPENPROC
        PUSHR   esi,edi
        mov     esi,pGNLogdevCXOffset
        mov     edi,ds:[esi].GNLOGDEVCX.pGNBoardCX

        ; Assume only one primary surface can move and that there is
        ; not even a second primary surface sharing video memory.
        mov     dwJustOnePrimaryCanMove,1
        mov     pOtherGNLogdevCXOffset,0

        ; Is there another primary surface on this board?
        cmp     ds:[edi].GNBOARDCX.dwLogicalDeviceInstancesOnThisBoard,1
        je      GotPrimaryData

        ; OK, there is more than 1 primary (that means 2 right now),
        ; but can the other primary be moved? If DX is running on it,
        ; then it cannot. Otherwise it can.
        mov     eax,ds:[edi].GNBOARDCX.pGNLogdevCX[0]
        cmp     eax,esi
        jne     @F
        mov     eax,ds:[edi].GNBOARDCX.pGNLogdevCX[4]
@@:     mov     pOtherGNLogdevCXOffset,eax

        cmp     ds:[eax].GNLOGDEVCX.bDirectXActive,0
        jne     GotPrimaryData
        mov     dwJustOnePrimaryCanMove,0

GotPrimaryData:
        ; NOTE: The general fitting algorithm is too difficult to do in
        ; its full generality. Hence, we just implement the two specific
        ; cases that we know are the only ones that can happen right now.
        cmp     dwJustOnePrimaryCanMove,0
        jne     JustOnePrimaryCanMove


BothPrimariesCanMove:
        ; This scenario allows us the ultimate in flexibility. We
        ; will be able to host the highest resolutions on both
        ; logical devices in small video memory configurations if
        ; we have the flexibility to move both primaries.

        ; First, we need to remember if we currently have an offscreen
        ; heap for bitmaps
        mov     edi,ds:[esi].GNLOGDEVCX.pGNBoardCX
        mov     eax,ds:[edi].GNBOARDCX.dwOffscreenFlags
        mov     dwMyOffscreenFlags,eax

        ; Now purge this heap if it exists sweeping all bitmaps to
        ; system memory.
        push    edi
        pushd   0
        call    GN_ControlOffscreenAllocations

        ; Until we get the RM call we want, cross your fingers and
        ; use the largest two things of: 1) The size for one of the
        ; primaries. 2) The size for the other primary. 3) The size
        ; of the largest other free block.

        ; This is not quite accurate since the block may be large
        ; emough if it starts at its base address, but starting at
        ; its aligned address, it may not be large enough. For now
        ; that is all we have.
        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        mov     eax,-1
        cmp     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        je      @F
        mov     eax,ds:[esi].DIBENGINEHDR.deBitsOffset
@@:
        push    eax

        mov     ebx,pOtherGNLogdevCXOffset
        mov     eax,-1
        cmp     ds:[ebx].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        je      @F
        mov     eax,ds:[ebx].DIBENGINEHDR.deBitsOffset
@@:
        push    eax
        call    HW_GetLargestOffscreenSpace
        or      ebx,ebx
        je      OneBlock

TwoBlocks:
        ; See if the other guy will fit in one of the two blocks
        mov     ecx,pOtherGNLogdevCXOffset
        mov     ecx,ds:[ecx].GNLOGDEVCX.dwMemorySizeForPrimarySurface

        ; Will other guy fit in the smaller block?
        sub     ebx,ecx
        jge     GotIt
        add     ebx,ecx

OneBlock:
        ; Other guy has to go in larger block (Note, this must work
        ; since the "free" blocks were gotten assuming that both
        ; primaries were freed.)
        mov     ecx,pOtherGNLogdevCXOffset
        mov     ecx,ds:[ecx].GNLOGDEVCX.dwMemorySizeForPrimarySurface
        sub     eax,ecx

GotIt:
        ; The larger of the two free pieces, after the other logical
        ; device's primary surface has been placed in one of them,
        ; should go into dwValidationFreeBlockSize
        cmp     eax,ebx
        jae     @F
        mov     eax,ebx
@@:
        mov     dwValidationFreeBlockSize,eax

        ; If we had an offscreen heap, then let us turn it back on.
        test    dwMyOffscreenFlags,OFFS_HEAP_UNAVAILABLE
        jnz     @F
        push    ds:[esi].GNLOGDEVCX.pGNBoardCX
        pushd   1
        call    GN_ControlOffscreenAllocations
@@:
        jmp     GotValidationSize


JustOnePrimaryCanMove:
        ; There is only one primary onthis board OR the other primary
        ; cannot be moved for some reason (DX is running on it maybe.)

        mov     ebx,ds:[esi].GNLOGDEVCX.pGNBoardCX
        push    ds:[ebx].GNBOARDCX.pHWBoardCX
        mov     eax,-1
        cmp     ds:[esi].GNLOGDEVCX.dwMemorySizeForPrimarySurface,0
        je      @F
        mov     eax,ds:[esi].DIBENGINEHDR.deBitsOffset
@@:
        push    eax
        mov     eax,ds:[ebx].GNBOARDCX.dwOffscreenBaseAddress
        cmp     ds:[ebx].GNBOARDCX.dwOffscreenLength,0
        jne     @F
        mov     eax,-1
@@:
        push    eax
        call    HW_GetLargestOffscreenSpace
        mov     dwValidationFreeBlockSize,eax

GotValidationSize:
        mov     eax,dwValidationFreeBlockSize
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_CheckForMultipleOf8Mode
;
; Purpose:      The following is a HACK! Win98 in multimon mode wants
;               resolutions to be a multiple of 8 so 1600x900 gets
;               changed to 1600x896. When a mode is being changed on
;               the secondary, Windows revalidates the mode on the
;               primary. Since 1600x896 is not in our master mode list,
;               we reject it, and Windows aborts the mode set. Since
;               1600x900 is what was really set, all we need to do is
;               validate 1600x896 and Windows is happy. Please also note
;               that Microsoft has fixed this problem under WinME.
;               NOTE: This is also a problem with 1400x1050 which Windows
;               asks to validate as 1400x1048. Chnage these modes to the
;               real mode so we can validate.
;
; Arguments:
;               lpXRes                  X Res ptr
;               lpYRes                  Y Res ptr
;
; Returns:      Corrected Y Res for modes in question
;
; Preserve:     ds,es,fs,esi,edi
;==============================================================================
DECPROC GN_CheckForMultipleOf8Mode, PASCAL, FRAME, FAR16
PARMD   lpXRes
PARMD   lpYRes
OPENPROC
        PUSHR   es,fs,esi,edi

        sub     esi,esi
        les     si,lpXRes
        sub     edi,edi
        lfs     di,lpYRes
        cmp     word ptr es:[esi],1600
        jne     Check_1400x1048
        cmp     word ptr fs:[edi],896
        jne     Check_1400x1048
        mov     word ptr fs:[edi],900
        jmp     DoneIt

Check_1400x1048:
        cmp     word ptr es:[esi],1400
        jne     DoneIt
        cmp     word ptr fs:[edi],1048
        jne     DoneIt
        mov     word ptr fs:[edi],1050
        
DoneIt:

        POPR    es,fs,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_CheckForOEMOverrides
;
; Purpose:      This routine checks for certain modes that certain OEMs
;               want blocked.
;
; Arguments:
;               ds                      COntext Selector
;               pGNLogdevCXOffset       GNLOGDEVCX ptr
;               lpModeInfoToValidate    MODEINFO ptr
;
; Returns:      AX = 0                  Continue Mode Validation
;               AX = 1                  Invalidate Mode
;
; Preserve:     ds,es,fs,ebx,esi,edi
;==============================================================================
DECPROC GN_CheckForOEMOverrides, PASCAL, FRAME, FAR16
PARMD   pGNLogdevCXOffset
PARMD   lpLocalValMode
LOCALS  sEdidBuf,MAX_EDID_BUFFER_SIZE
LOCALD  dwEdidSze;
LOCALV  sModeInfo,MODEINFO
LOCALD  dwCheckedBothDisplayFlag
OPENPROC
        PUSHR   es,fs,ebx,esi,edi

        mov     esi,pGNLogdevCXOffset

        ; This routine returns TRUE if we want to exclude 1400x1050 when
        ; a 1400x1050 panel is not installed.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGet1400x1050Override,es,ax
        cmp     ax,1
        jne     CheckRestrictLargestMode
        
        ; Only allow 1400x1050 if we are on the SXGA+ panel (1400x1050 panel).
        ; First, check to see if the mode in question is 1400x1050. Then, read
        ; the EDID for DFP0 and check to see if the largest mode is 1400x1050.
        ; If so, PassMode, otherwise FailMode. 
        sub     ebx,ebx
        les     bx,lpLocalValMode
        cmp     es:[ebx].DISPVALMODE.dvmXRes,1400
        jne     CheckRestrictLargestMode
        cmp     es:[ebx].DISPVALMODE.dvmYRes,1050
        jne     CheckRestrictLargestMode

        ; Now read the EDID.
        mov     dwEdidSze,MAX_EDID_BUFFER_SIZE
        push    ds:[esi].GNLOGDEVCX.pHWLogdevCX
        mov     eax,10000h              ; Device mask for DFP0
        push    eax
        mov     ax,ss
        shl     eax,10h
        lea     ax,sEdidBuf
        push    eax
        lea     ax,dwEdidSze
        push    eax
        call    HW_ReadEdidForDevice

        ; Make sure we read the EDID. If EAX != 0, then FailMode.
        or      eax,eax
        je      FailMode
        
        cmp     dwEdidSze,0
        je      FailMode

        ; Now get the largest mode for this EDID which will be the native
        ; mode of DFP0.
        mov     ax,ss
        shl     eax,10h
        lea     ax,sEdidBuf
        push    eax
        push    dwEdidSze
        lea     ax,sModeInfo
        push    eax
        CALLFAR16IND lpfnGetLargestEdidMode,es,ax

        sub     ebx,ebx
        lea     bx,sModeInfo
        cmp     ss:[ebx].MODEINFO.dwXRes,1400
        jne     FailMode
        cmp     ss:[ebx].MODEINFO.dwYRes,1050
        jne     FailMode
        
CheckRestrictLargestMode:
        ; This OEM Override is for OEMs who, in clone mode, only want
        ; modes up to the greatest EDID mode for the lesser display device.
        ; This is due to the fact tha they do not want panning.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        CALLFAR16IND lpfnGetRestrictLargestMode,es,ax
        cmp     ax,1
        jne     CheckMaxDfpMode

        ; If not in clone mode, pass mode to standard validation.
        cmp     ds:[esi].GNLOGDEVCX.dwNumCRTCsAttachedToThisLogicalDevice,2
        jl      CheckMaxDfpMode
        
        ; We are on restricted desktop system and in clone mode. Get the
        ; largest EDID modes for each display device and make sure the
        ; requested mode is less than or equal to the smaller of the two.
        mov     dwCheckedBothDisplayFlag,0
        
        ; Make sure there is an EDID for the primary. If not, check display
        ; type and use safe mode.
        mov     edi,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        cmp     ds:[edi].GNCRTCCX.dwEdidSize,0
        je      NoEdidForDevice
        
        ; Get the largest EDID mode of the primary display.
        push    edi
        mov     ax,ss
        shl     eax,10h
        lea     ax,sModeInfo
        push    eax
        call    GN_GetLargestEdidMode

        ; Now, compare to see if the requested mode is greater than the
        ; maximum mode this EDID can handle.
        sub     ebx,ebx
        lea     bx,sModeInfo
        mov     eax,ss:[ebx].MODEINFO.dwXRes

        sub     ebx,ebx
        les     bx,lpLocalValMode
        cmp     es:[ebx].DISPVALMODE.dvmXRes,ax
        jg      FailMode

CheckSecondary:
        mov     dwCheckedBothDisplayFlag,1
        
        ; Make sure there is an EDID for the secondary. If not, check display
        ; type and use safe mode.
        mov     edi,ds:[esi].GNLOGDEVCX.pGNCrtcCX+4
        cmp     ds:[edi].GNCRTCCX.dwEdidSize,0
        je      NoEdidForDevice

        ; Now get the largest EDID mode for the clone device.
        push    edi
        mov     ax,ss
        shl     eax,10h
        lea     ax,sModeInfo
        push    eax
        call    GN_GetLargestEdidMode

        ; Now, compare to see if the requested mode is greater than the
        ; maximum mode this EDID can handle.
        sub     ebx,ebx
        lea     bx,sModeInfo
        mov     eax,ss:[ebx].MODEINFO.dwXRes

        sub     ebx,ebx
        les     bx,lpLocalValMode
        cmp     es:[ebx].DISPVALMODE.dvmXRes,ax
        jg      FailMode
        
        jmp     CheckMaxDfpMode

NoEdidForDevice:
        lea     ebx,[edi].GNCRTCCX.sCrtcModeInfo
        mov     eax,ds:[ebx].MODEINFO.MIDevData
        cmp     al,DEVTYPE_TV
        je      UseMaxTvResolution

        ; There is no EDID and the display device is not a TV. Use 800x600
        ; as a safe mode.
        sub     ebx,ebx
        les     bx,lpLocalValMode
        cmp     es:[ebx].DISPVALMODE.dvmXRes,800
        jg      FailMode
        
        cmp     dwCheckedBothDisplayFlag,1
        jne     CheckSecondary
        
        jmp     CheckMaxDfpMode

UseMaxTvResolution:
        sub     ebx,ebx
        lfs     bx,ds:[edi].GNCRTCCX.lpNvmodeDispData
        mov     eax,fs:[ebx].DISPDATA.dwMaxTVOutResolution
        shr     eax,10h
        sub     ebx,ebx
        les     bx,lpLocalValMode
        cmp     es:[ebx].DISPVALMODE.dvmXRes,ax
        jg      FailMode

        cmp     dwCheckedBothDisplayFlag,1
        jne     CheckSecondary
        
CheckMaxDfpMode:
        ; This OEM override is for OEMs who want to limit the maximum
        ; allowable mode for the DFP. First, check the display type to
        ; make sure this is a DFP.
        mov     ecx,ds:[esi].GNLOGDEVCX.pGNCrtcCX
        lea     ebx,[ecx].GNCRTCCX.sCrtcModeInfo
        mov     eax,ds:[ebx].MODEINFO.MIDevData
        cmp     al,DEVTYPE_DFP
        jne     PassMode
        
        ; Now check if the registry key MaxDfpMode exists. If so, the max
        ; DFP mode will be returned in sModeInfo.
        push    ds:[esi].GNLOGDEVCX.lpBoardRegistryData
        mov     ax,ss
        shl     eax,10h
        lea     ax,sModeInfo
        push    eax
        CALLFAR16IND lpfnGetMaxDfpMode,es,ax
        
        cmp     ax,1
        jne     PassMode

        ; Now, compare to see if the requested mode is greater than the
        ; maximum mode for the DFP in the registry. Please note that Windows
        ; considers a mode greater if the XRes is greater.
        sub     ebx,ebx
        lea     bx,sModeInfo
        mov     eax,ss:[ebx].MODEINFO.dwXRes

        sub     ebx,ebx
        les     bx,lpLocalValMode
        cmp     es:[ebx].DISPVALMODE.dvmXRes,ax
        jg      FailMode

PassMode:
        mov     eax,0
        jmp     DoneIt

FailMode:
        mov     eax,1

DoneIt:

        POPR    es,fs,ebx,esi,edi
CLOSEPROC


CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\gnwrap.asm ===
;==============================================================================
;
; Copyright (C) 1998, NVidia Coporation
;
; File:         gnwrap.asm
;
; Purpose:      This file holds the entry points to drawing functions
;		that may require cursor exclusion / unexclusion. The
;		idea is to see if exclusion is necessary. If not jump
;		to the real code. If it is, then do the exclusion,
;		call the real code, do the unexclusion and return.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
incOutput = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc

IsItScreen	MACRO	bm,jump
	cmp	bm.DIBENGINE.deType,0
	je	jump
	mov	ax,bm.DIBENGINE.deFlags
	and	ax,VRAM + OFFSCREEN + PALETTE_XLAT
	cmp	ax,VRAM
	jne	jump
	cmp	bm.DIBENGINE.deBeginAccess,0
	je	jump
	ENDM

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     BitBlt_WithExclude
;
; Purpose:      This function is the BitBlt display driver entry point
;		when we are running a software cursor.
;
; Arguments:    BitBlt Display Driver Stack Frame
;
; Returns:      ax      0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC BitBlt_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wDstX
PARMW   wDstY
PARMD   lpSrcDev
PARMW   wSrcX
PARMW   wSrcY
PARMW   wExtX
PARMW   wExtY
PARMD   dwRop3
PARMD   lpBrush
PARMD   lpDrawMode
LOCALW	wExclude
LOCALW	wRet
OPENPROC
	PUSHR	ds,si
	mov	wExclude,0

if 0;!!
	; Check the rop and see what type of exclusion to check for
        movzx   bx,byte ptr [dwRop3 + 2]
	mov	ax,cs:[wNVTEXT32_Alias_In_NVTEXT16]
	mov	es,ax
        movzx  	ax,es:Rop3Table[bx]
        cmp	ax,PAD
        jae	SrcAndDstCheck
else
	cmp	lpSrcDev,0
	jne	SrcAndDstCheck
endif

JustDstCheck:
	les	bx,lpDstDev
	IsItScreen es:[bx],DoCall

JustDst:
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	mov	ax,wDstX
	mov	cx,wDstY
	push	ax
	push	cx
	add	ax,wExtX
	add	cx,wExtY
	push	ax
	push	cx
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR es:[bx].DIBENGINE.deBeginAccess
	jmp	DoCall_WithExclude

SrcAndDstCheck:
	; See if we have to exclude the src rectangle also
	lfs	si,lpSrcDev
	IsItScreen fs:[si],JustDstCheck

	; Clip the src rect
	call	BitBlt_ClipSrc
	or	ax,ax
	mov	ax,1
	je	DoneIt

	; We have to do the src rect.  How about the dst?
	les	bx,lpDstDev
	IsItScreen es:[bx],JustSrc

SrcAndDst:
	; We need to exclude based on both the src and dst rectangles
        push	cs:[CSlp16LogDevice_In_NVTEXT16]
	mov	ax,wDstX
	mov	si,wSrcX
	mov	cx,wDstY
	mov	dx,wSrcY

	; Order the src and dst X,Y coordinates
	cmp	ax,si
	jc	@F
	xchg	ax,si
@@:	cmp	cx,dx
	jc	@F
	xchg	cx,dx
@@:
	push	ax
	push	cx

	add	si,wExtX
	add	dx,wExtY
	push	si
	push	dx
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR es:[bx].DIBENGINE.deBeginAccess
	jmp	DoCall_WithExclude

JustSrc:
        push	cs:[CSlp16LogDevice_In_NVTEXT16]
	mov	ax,wSrcX
	mov	cx,wSrcY
	push	ax
	push	cx
	add	ax,wExtX
	add	cx,wExtY
	push	ax
	push	cx
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR fs:[si].DIBENGINE.deBeginAccess

DoCall_WithExclude:
	mov	wExclude,1

DoCall:
	push	lpDstDev
	push	wDstX
	push	wDstY
	push	lpSrcDev
	push	wSrcX
	push	wSrcY
	push	wExtX
	push	wExtY
	push	dwRop3
	push	lpBrush
	push	lpDrawMode

	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	call	DIB_BitBlt
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_BitBlt

	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoneIt

	; Do we need to unexclude?
	cmp	wExclude,0
	je	DoneIt

	; Yes so do it. Don't forget to save return value
	mov	wRet,ax
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deEndAccess
	mov	ax,wRet

DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     BitBlt_ClipSrc
;
; Purpose:      This function clips the src adjusting the stack parameters
;               for BitBlt appropriately to represent the clipped coords
;               and clipped extents.
;
; Arguments:    BitBlt Display Driver Stack Frame
;               fs:si  lpSrcDev
;
; Returns:      eax     1 - there is something to draw
;                       0 - there is nothing to draw
;
; Preserve:     ds,esi,es,edi,fs
;==============================================================================
PUBLIC  BitBlt_ClipSrc
BitBlt_ClipSrc	PROC    NEAR

        mov   	ax,wSrcX
        mov   	cx,wSrcY
        mov   	bx,fs:[si].DIBENGINE.deWidth
        mov   	dx,fs:[si].DIBENGINE.deHeight
        or      ax,ax
        js      ClipLeft
cld1:   or      cx,cx
        js      ClipTop
clt:    add     ax,wExtX
        add     cx,wExtY
        sub     ax,bx
        jg      ClipRight
clr:    sub     cx,dx
        jg      ClipBottom
clb:    mov     ax,1
        ret

ClipLeft:
        add     wExtX,ax
        jle     ClipDone
        sub     wDstX,ax
        sub     ax,ax
        mov     wSrcX,ax
        jmp     cld1

ClipTop:
        add     wExtY,cx
        jle     ClipDone
        sub     wDstY,cx
        sub     cx,cx
        mov     wSrcY,cx
        jmp     clt

ClipRight:
        sub     wExtX,ax
        jg      clr
        jmp     ClipDone

ClipBottom:
        sub     wExtY,cx
        jg      clb

ClipDone:
        sub     ax,ax
        ret

BitBlt_ClipSrc	ENDP


;==============================================================================
;
; Function:     BitmapBits_WithExclude
;
; Purpose:      This function is the BitmapBits display driver
;               entry point
;		when we are running a software cursor.
;
; Arguments:    BitmapBits Display Driver Stack Frame
;
; Returns:      ax      0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;
;==============================================================================
DECPROC BitmapBits_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMD   dwFlags
PARMD   dwCount
PARMD   lpBits
OPENPROC
	PUSHR	ds,si

	push	lpDstDev
	push	dwFlags
	push	dwCount
	push	lpBits

	; We don't need exclude here because BitmapBits never use screen.
	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	call	DIB_BitmapBits
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_BitmapBits

	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT

DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     DibBlt_WithExclude
;
; Purpose:      This function is the DibBlt display driver
;               entry point
;		when we are running a software cursor.
;
; Arguments:    DibBlt Display Driver Stack Frame
;
; Returns:      ax      0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;
;==============================================================================
DECPROC DibBlt_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   fGet
PARMW   iStart
PARMW   cScans
PARMD   lpDIBBits
PARMD   lpDIBInfo
PARMD   lpDrawMode
PARMD   lpTranslate
OPENPROC
	PUSHR	ds,si

	push	lpDstDev
	push	fGet
	push	iStart
	push	cScans
	push	lpDIBBits
	push	lpDIBInfo
	push	lpDrawMode
	push	lpTranslate

	; We don't need exclude here because DibBlt never use screen.
	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	les	bx,lpDstDev
        ; The DIBENG DibBltExt takes an extra parameter which indicates
        ; whether we are running in a palettized mode right now.
        test    es:[bx].DIBENGINEHDR.deFlags,PALETTE_XLAT
        setne   al
        movzx   ax,al
	push	ax
	call	DIB_DibBltExt
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_DibBlt

	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT

DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     ExtTextOut_WithExclude
;
; Purpose:      This function is the ExtTextOut display driver entry point
;		when we are running a software cursor.
;
; Arguments:    ExtTextOut Display Driver Stack Frame
;
; Returns:      This function returns one of the following values:
;
;               If wCount is negative and the function is successful,
;               it returns the X extent in AX,and the Y extent in DX.
;               If wCount is negative and the function is unsuccessful,
;               it returns the 7FFFH in AX,and wDstY in DX.
;
;               If wCount is 0 or positive and the the function is
;               successful,it returns DX:AX set to 1.
;               If wCount is 0 or positive and the the function is
;               unsuccessful,it returns DX:AX set to 80000000H.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC ExtTextOut_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wDstX
PARMW   wDstY
PARMD   lpClipRect
PARMD   lpString
PARMW   wCount
PARMD   lpFontInfo
PARMD   lpDrawMode
PARMD   lpTextXForm
PARMD   lpKerning
PARMD   lpOpaqueRects
PARMW   wOptions
LOCALW	wExclude
LOCALW	wRet1
LOCALW	wRet2
OPENPROC
	PUSHR	ds,si
	mov	wExclude,0

	cmp	wCount,0
	jl	DoCall
	les	bx,lpDstDev
	IsItScreen es:[bx],DoCall

	; Here is a problem! I don't know what the exclusion rect is!
	; Oh well, just do the scan for the entire extent of the bitmap.
	lds	si,lpClipRect
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	push	ds:[si].RECT.left
	push	ds:[si].RECT.top
	push	ds:[si].RECT.right
	push	ds:[si].RECT.bottom
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR es:[bx].DIBENGINE.deBeginAccess

DoCall_WithExclude:
	mov	wExclude,1

DoCall:
	push	lpDstDev
	push	wDstX
	push	wDstY
	push	lpClipRect
	push	lpString
	push	wCount
	push	lpFontInfo
	push	lpDrawMode
	push	lpTextXForm
	push	lpKerning
	push	lpOpaqueRects
	push	wOptions

	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	call	DIB_ExtTextOut
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_ExtTextOut

	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoneIt

	; Do we need to unexclude?
	cmp	wExclude,0
	je	DoneIt

	; Yes so do it. Don't forget to save return value
	mov	wRet1,ax
	mov	wRet2,dx
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deEndAccess
	mov	ax,wRet1
	mov	dx,wRet2
DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     Output_WithExclude
;
; Purpose:      This function is the Output display driver
;               entry point
;		when we are running a software cursor.
;
; Arguments:    Output Display Driver Stack Frame
;
; Returns:      ax      0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC Output_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wStyle
PARMW   wCount
PARMD   lpPoints
PARMD   lpPen
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   lpClipRect
LOCALW	wExclude
LOCALW	wRet
OPENPROC
	PUSHR	ds,si
	mov	wExclude,0

	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]

	IsItScreen ds:[si],DoCall

	; We dont need to exclude if we are in scan sequence
        cmp	ds:[si].GNLOGDEVCX.bInScanSequence,0
	je	@F

	; We need to unexclude cursor after endscan
	cmp	wStyle,OS_ENDNSCAN
	je	DoCall_WithExclude
	jmp	DoCall

@@:

	; Exclude the save / restore rect
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	cmp	lpClipRect,0
	je	NoClipRect
	les	bx,lpClipRect

	mov	ax,es:[bx].RECT.left
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,es:[bx].RECT.top
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,es:[bx].RECT.right
	cmp	ax,ds:[si].DIBENGINE.deWidth
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deWidth
@@:	push	ax

	mov	ax,es:[bx].RECT.bottom
	cmp	ax,ds:[si].DIBENGINE.deHeight
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deHeight
@@:	push	ax
	jmp	@F

NoClipRect:
	sub	ax,ax
	push	ax
	push	ax
	mov	ax,ds:[si].DIBENGINE.deWidth
	push	ax
	mov	ax,ds:[si].DIBENGINE.deHeight
	push	ax

@@:
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deBeginAccess

DoCall_WithExclude:
	mov	wExclude,1

DoCall:
	push	lpDstDev
	push	wStyle
	push	wCount
	push	lpPoints
	push	lpPen
	push	lpBrush
	push	lpDrawMode
	push	lpClipRect

	; Busy bit already set if we are in scan sequence
        cmp	ds:[si].GNLOGDEVCX.bInScanSequence,0
	jne	DoRegularCall

	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	call	DIB_Output
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_Output

	; We need to keep busy bit until scan sequence end.
        cmp	ds:[si].GNLOGDEVCX.bInScanSequence,0
	jne	KeepBusy

	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoneIt

	; Do we need to unexclude?
	cmp	wExclude,0
	je	DoneIt

	; Yes so do it. Don't forget to save return value
	mov	wRet,ax
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deEndAccess
	mov	ax,wRet
KeepBusy:
DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     Pixel_WithExclude
;
; Purpose:      This function is the Pixel display driver entry point
;		when we are running a software cursor.
;
; Arguments:    Pixel Display driver stack FRAME
;
; Returns:      If lpDrawMode is NULL then
;                       pixel value at coords wDstX,wDstY if succeesful
;                       80000000H is failure
;               If lpDrawMode is NOT NULL then
;                       00000001H is succeesful
;                       80000000H is failure
;
;==============================================================================
DECPROC Pixel_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wDstX
PARMW   wDstY
PARMD   dwPhysColor
PARMD   lpDrawMode
LOCALW	wExclude
LOCALW	wRet1
LOCALW	wRet2
OPENPROC
	PUSHR	ds,si
	mov	wExclude,0

	les	bx,lpDstDev
	IsItScreen es:[bx],DoCall

	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	mov	ax,wDstX
	mov	cx,wDstY
	push	ax
	push	cx
	inc	ax
	inc	cx
	push	ax
	push	cx
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR es:[bx].DIBENGINE.deBeginAccess

DoCall_WithExclude:
	mov	wExclude,1

DoCall:
	push	lpDstDev
	push	wDstX
	push	wDstY
	push	dwPhysColor
	push	lpDrawMode

	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	call	DIB_Pixel
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_Pixel

	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoneIt

	; Do we need to unexclude?
	cmp	wExclude,0
	je	DoneIt

	; Yes so do it. Don't forget to save return value
	mov	wRet1,ax
	mov	wRet2,dx
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deEndAccess
	mov	ax,wRet1
	mov	dx,wRet2
DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     ScanLR_WithExclude
;
; Purpose:      This function is the ScanLR display driver entry point
;		when we are running a software cursor.
;
;==============================================================================
DECPROC	ScanLR_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wX
PARMW   wY
PARMD   dwPhysColor
PARMW   wStyle
LOCALW	wExclude
LOCALW	wRet1
LOCALW	wRet2
OPENPROC
	PUSHR	ds,si
	mov	wExclude,0

	les	bx,lpDstDev
	IsItScreen es:[bx],DoCall

	; Here is a problem! I don't know what the exclusion rect is!
	; Oh well, just do the scan for the entire extent of the bitmap.
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	mov	ax,wX
	mov	cx,wY
	push	ax
	push	cx
	mov	ax,es:[bx].DIBENGINE.deWidth
	inc	cx
	push	ax
	push	cx
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR es:[bx].DIBENGINE.deBeginAccess


DoCall_WithExclude:
	mov	wExclude,1

DoCall:
	push	lpDstDev
	push	wX
	push	wY
	push	dwPhysColor
	push	wStyle

	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	call	DIB_ScanLR
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_ScanLR

	; Turn off BUSY bit because we don't use h/w here
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoneIt

	; Do we need to unexclude?
	cmp	wExclude,0
	je	DoneIt

	; Yes so do it. Don't forget to save return value
	mov	wRet1,ax
	mov	wRet2,dx
	les	bx,lpDstDev
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR es:[bx].DIBENGINE.deEndAccess
	mov	ax,wRet1
	mov	dx,wRet2
DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     SetDIBitsToDevice_WithExclude
;
; Purpose:      This function is the SetDIBitsToDevice driver entry point
;		when we are running a software cursor.
;
; Arguments:    SetDIBitsToDevice Display Driver Stack Frame
;
; Returns:      ax      number of scans copied if successful
;                       0 if not successful
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC SetDIBitsToDevice_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wDstX
PARMW   wDstY
PARMW   wInitScan
PARMW   wNumScans
PARMD   lpClipRect
PARMD   lpDrawMode
PARMD   lpDIBBits
PARMD   lpDIBInfo
PARMD   lpTranslate
LOCALW	wExclude
LOCALW	wRet1
LOCALW	wRet2
OPENPROC
	PUSHR	ds,si
	mov	wExclude,0

	lds	si,lpDstDev
	IsItScreen ds:[si],DoCall

	; The lpClipRect may not be entirely accurate. To get it correct,
	; I really need to clip against the src rectangle. However, why
	; bother? Just make sure the clip coordinates are bounded by the
	; screen borders. Then it will be close enough -- that is we
	; might be excluding the cursor from a little larger an area than
	; necessary, but it won;t hurt.
	les	bx,lpClipRect
	push	cs:[CSlp16LogDevice_In_NVTEXT16]

	mov	ax,es:[bx].RECT.left
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,es:[bx].RECT.top
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,es:[bx].RECT.right
	cmp	ax,ds:[si].DIBENGINE.deWidth
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deWidth
@@:	push	ax

	mov	ax,es:[bx].RECT.bottom
	cmp	ax,ds:[si].DIBENGINE.deHeight
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deHeight
@@:	push	ax

	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deBeginAccess

DoCall_WithExclude:
	mov	wExclude,1

DoCall:
	push	lpDstDev
	push	wDstX
	push	wDstY
	push	wInitScan
	push	wNumScans
	push	lpClipRect
	push	lpDrawMode
	push	lpDIBBits
	push	lpDIBInfo
	push	lpTranslate

	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	call	DIB_DibToDevice
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_SetDIBitsToDevice

	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoneIt

	; Do we need to unexclude?
	cmp	wExclude,0
	je	DoneIt

	; Yes so do it. Don't forget to save return value
	mov	wRet1,ax
	mov	wRet2,dx
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deEndAccess
	mov	ax,wRet1
	mov	dx,wRet2
DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     StretchBlt_WithExclude
;
; Purpose:      This function is the StretchBlt display driver entry point.
;		when we are running a software cursor.
;
;==============================================================================
DECPROC StretchBlt_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   wDstX
PARMW   wDstY
PARMW   wDstExtX
PARMW   wDstExtY
PARMD   lpSrcDev
PARMW   wSrcX
PARMW   wSrcY
PARMW   wSrcExtX
PARMW   wSrcExtY
PARMD   dwRop3
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   lpClipRect
LOCALW	wExclude
LOCALW	wRet
OPENPROC
	PUSHR	ds,si
	mov	wExclude,0

if 0;!!
	; Check the rop and see what type of exclusion to check for
        movzx   bx,byte ptr [dwRop3 + 2]
	mov	ax,cs:[wNVTEXT32_Alias_In_NVTEXT16]
	mov	es,ax
        movzx  	ax,es:Rop3Table[bx]
        cmp	ax,PAD
        jae	SrcAndDstCheck
else
	cmp	lpSrcDev,0
	jne	SrcAndDstCheck
endif

JustDstCheck:
	lds	si,lpDstDev
	IsItScreen ds:[si],DoCall

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Just exclude the dst rect. Use cliprect for this but bound it
	; to the bitmap coords
	les	bx,lpClipRect
	push	cs:[CSlp16LogDevice_In_NVTEXT16]

	mov	ax,es:[bx].RECT.left
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,es:[bx].RECT.top
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,es:[bx].RECT.right
	cmp	ax,ds:[si].DIBENGINE.deWidth
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deWidth
@@:	push	ax

	mov	ax,es:[bx].RECT.bottom
	cmp	ax,ds:[si].DIBENGINE.deHeight
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deHeight
@@:	push	ax

	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deBeginAccess
	jmp	DoCall_WithExclude
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


SrcAndDstCheck:
	; See if we have to exclude the src rectangle also
	lfs	si,lpSrcDev
	IsItScreen fs:[si],JustDstCheck

	; Clip the src rect
	call	StretchBlt_ClipSrc
	or	ax,ax
	mov	ax,1
	je	DoneIt

	; We have to do the src rect.  How about the dst?
	les	bx,lpDstDev
	IsItScreen es:[bx],JustSrc

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SrcAndDst:
	; We need to exclude based on both the src and dst rectangles
	; I don't actually do the clip to generate the smallest possible
	; nounding rectangle. This might result in occassionally
	; excluding the cursor when we don't need to, but it won't hurt.
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	push	cs:[CSlp16LogDevice_In_NVTEXT16]

	; Order the src and dst X coordinates
	mov	ax,wDstX
	mov	bx,wSrcX
	cmp	ax,bx
	jl	@F
	mov	ax,bx
@@:	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	; Order the src and dst Y coordinates
	mov	ax,wDstY
	mov	bx,wSrcY
	cmp	ax,bx
	jl	@F
	mov	ax,bx
@@:	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	; Now find the larger of the src/dst right edges
	mov	ax,wDstX
	mov	bx,wSrcX
	add	ax,wDstExtX
	add	bx,wSrcExtX
	cmp	ax,bx
	jg	@F
	mov	ax,bx
@@:	cmp	ax,ds:[si].DIBENGINE.deWidth
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deWidth
@@:	push	ax

	; Now find the larger of the src/dst bottom edges
	mov	ax,wDstY
	mov	bx,wSrcY
	add	ax,wDstExtY
	add	bx,wSrcExtY
	cmp	ax,bx
	jg	@F
	mov	ax,bx
@@:	cmp	ax,ds:[si].DIBENGINE.deHeight
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deHeight
@@:	push	ax

	sub	bx,bx
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR es:[bx].DIBENGINE.deBeginAccess
	jmp	DoCall_WithExclude
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
JustSrc:
	; Just exclude the dst rect. Use cliprect for this but bound it
	; to the bitmap coords
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	les	bx,lpClipRect
	push	cs:[CSlp16LogDevice_In_NVTEXT16]

	mov	ax,wSrcX
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,wSrcY
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,wSrcX
	add	ax,wSrcExtX
	cmp	ax,ds:[si].DIBENGINE.deWidth
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deWidth
@@:	push	ax

	mov	ax,wSrcY
	add	ax,wSrcExtY
	cmp	ax,ds:[si].DIBENGINE.deHeight
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deHeight
@@:	push	ax

	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deBeginAccess
	jmp	DoCall_WithExclude
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


DoCall_WithExclude:
	mov	wExclude,1

DoCall:
	push	lpDstDev
	push	wDstX
	push	wDstY
	push	wDstExtX
	push	wDstExtY
	push	lpSrcDev
	push	wSrcX
	push	wSrcY
	push	wSrcExtX
	push	wSrcExtY
	push	dwRop3
	push	lpBrush
	push	lpDrawMode
	push	lpClipRect

	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	call	DIB_StretchBlt
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_StretchBlt

	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoneIt

	; Do we need to unexclude?
	cmp	wExclude,0
	je	DoneIt

	; Yes so do it. Don't forget to save return value
	mov	wRet,ax
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deEndAccess
	mov	ax,wRet

DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     StretchBlt_ClipSrc
;
; Purpose:      This function clips the src adjusting the stack parameters
;               for StrBlt appropriately to represent the clipped coords
;               and clipped extents.
;
; Arguments:    StretchBlt Display Driver Stack Frame
;               fs:si  lpSrcDev
;
; Returns:      eax     1 - there is something to draw
;                       0 - there is nothing to draw
;
; Preserve:     ds,esi,es,edi,fs
;==============================================================================
PUBLIC	StretchBlt_ClipSrc
StretchBlt_ClipSrc	PROC	NEAR

        mov   	ax,wSrcX
        mov   	cx,wSrcY
        mov   	bx,fs:[si].DIBENGINE.deWidth
        mov   	dx,fs:[si].DIBENGINE.deHeight
        or      ax,ax
        js      ClipLeft
cld1:   or      cx,cx
        js      ClipTop
clt:    add     ax,wExtX
        add     cx,wExtY
        sub     ax,bx
        jg      ClipRight
clr:    sub     cx,dx
        jg      ClipBottom
clb:    mov     ax,1
        ret

ClipLeft:
        add     wExtX,ax
        jle     ClipDone
        sub     wDstX,ax
        sub     ax,ax
        mov     wSrcX,ax
        jmp     cld1

ClipTop:
        add     wExtY,cx
        jle     ClipDone
        sub     wDstY,cx
        sub     cx,cx
        mov     wSrcY,cx
        jmp     clt

ClipRight:
        sub     wExtX,ax
        jg      clr
        jmp     ClipDone

ClipBottom:
        sub     wExtY,cx
        jg      clb

ClipDone:
        sub     ax,ax
        ret

StretchBlt_ClipSrc	ENDP


;==============================================================================
;
; Function:     StretchDIBits_WithExclude
;
; Purpose:      This function is the StretchDIBits display driver entry point
;		when we are running a software cursor.
;
; Arguments:    StretchDIBits Display Driver Stack Frame
;
; Returns:      ax      number of scans copied if successful
;                       0 if not successful
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC StretchDIBits_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpDstDev
PARMW   fGet
PARMW   wDstX
PARMW   wDstY
PARMW   wDstExtX
PARMW   wDstExtY
PARMW   wSrcX
PARMW   wSrcY
PARMW   wSrcExtX
PARMW   wSrcExtY
PARMD   lpDIBBits
PARMD   lpDIBInfo
PARMD   lpTranslate
PARMD   dwRop3
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   lpClipRect
LOCALW	wExclude
LOCALW	wRet1
LOCALW	wRet2
OPENPROC
	PUSHR	ds,si
	mov	wExclude,0

	lds	si,lpDstDev
	IsItScreen ds:[si],DoCall

	; The lpClipRect may not be entirely accurate. To get it correct,
	; I really need to clip against the src rectangle. However, why
	; bother? Just make sure the clip coordinates are bounded by the
	; screen borders. Then it will be close enough -- that is we
	; might be excluding the cursor from a little larger an area than
	; necessary, but it won't hurt.
	les	bx,lpClipRect
	push	cs:[CSlp16LogDevice_In_NVTEXT16]

	mov	ax,es:[bx].RECT.left
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,es:[bx].RECT.top
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,es:[bx].RECT.right
	cmp	ax,ds:[si].DIBENGINE.deWidth
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deWidth
@@:	push	ax

	mov	ax,es:[bx].RECT.bottom
	cmp	ax,ds:[si].DIBENGINE.deHeight
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deHeight
@@:	push	ax

	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deBeginAccess

DoCall_WithExclude:
	mov	wExclude,1

DoCall:
	push	lpDstDev
	push	fGet
	push	wDstX
	push	wDstY
	push	wDstExtX
	push	wDstExtY
	push	wSrcX
	push	wSrcY
	push	wSrcExtX
	push	wSrcExtY
	push	lpDIBBits
	push	lpDIBInfo
	push	lpTranslate
	push	dwRop3
	push	lpBrush
	push	lpDrawMode
	push	lpClipRect

	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	call	DIB_StretchDIBits
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_StretchDIBits

	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoneIt

	; Do we need to unexclude?
	cmp	wExclude,0
	je	DoneIt

	; Yes so do it. Don't forget to save return value
	mov	wRet1,ax
	mov	wRet2,dx
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deEndAccess
	mov	ax,wRet1
	mov	dx,wRet2
DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     StrBlt_WithExclude
;
; Purpose:      This function is the StrBlt display driver
;               entry point
;		when we are running a software cursor.
;
; Arguments:    StrBlt Display Driver Stack Frame
;
; Returns:      ax      0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;
;==============================================================================
DECPROC StrBlt_WithExclude, PASCAL, NOFRAME, FAR16
;PARMD   lpDstDev
;PARMW   wDstX
;PARMW   wDstY
;PARMD   lpClipRect
;PARMD   lpString
;PARMW   wCount
;PARMD   lpFontInfo
;PARMD   lpDrawMode
;PARMD   lpTextXForm
OPENPROC
        sub     ebx,ebx
        pop     eax
        push    ebx
        push    ebx
        push    bx
        push    eax
        jmp     ExtTextOut_WithExclude
CLOSEPROC


;==============================================================================
;
; Function:     UpdateColors_WithExclude
;
; Purpose:      This function is the UpdateColors display driver entry point
;		when we are running a software cursor.
;
; Arguments:    UpdateColors Display Driver Stack Frame
;
; Returns:      None
;
;==============================================================================
DECPROC UpdateColors_WithExclude, PASCAL, FRAME, FAR16
PARMW   wStartX
PARMW   wStartY
PARMW   wExtX
PARMW   wExtY
PARMD   lpTranslate
LOCALW	wExclude
LOCALW	wRet1
LOCALW	wRet2
OPENPROC
	PUSHR	ds,si
	mov	wExclude,0

	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]
	IsItScreen ds:[si],DoCall

	; Exclude the update rectangle
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	mov	ax,wStartX
	mov	bx,wStartX
	push	ax
	push	bx
	add	ax,wExtX
	add	bx,wExtX
	push	ax
	push	bx
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deBeginAccess

DoCall_WithExclude:
	mov	wExclude,1

DoCall:
	push	wStartX
	push	wStartY
	push	wExtX
	push	wExtY
	push	lpTranslate

	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoRegularCall

	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	call	DIB_UpdateColorsExt
	jmp	DoneIt

DoRegularCall:
	call	GENERIC_UpdateColors

	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoneIt

	; Do we need to unexclude?
	cmp	wExclude,0
	je	DoneIt

	; Yes so do it. Don't forget to save return value
	mov	wRet1,ax
	mov	wRet2,dx
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deEndAccess
	mov	ax,wRet1
	mov	dx,wRet2
DoneIt:
	POPR	ds,si
CLOSEPROC


;==============================================================================
;
; Function:     SaveScreenBitmap_WithExclude
;
; Purpose:      This function is the SaveScreenBitmap display driver
;               entry point
;		when we are running a software cursor.
;
; Arguments:    SaveScreenBitmap Display Driver Stack Frame
;
; Returns:      ax      0 failure
;                       1 success
;
; Preserve:     ds,esi,edi
;==============================================================================
; These aren't in any API header file so include them here
SAVE_AREA       EQU     0
RESTORE_AREA    EQU     1
DISCARD_AREA    EQU     2

DECPROC SaveScreenBitmap_WithExclude, PASCAL, FRAME, FAR16
PARMD   lpRect
PARMW   wCommand
LOCALW	wExclude
LOCALW	wRet
OPENPROC
	PUSHR	ds,si
	mov	wExclude,0
	lds	si,cs:[CSlp16LogDevice_In_NVTEXT16]

	; Discard does not require exclude
        cmp     wCommand,DISCARD_AREA
        je	DoCall

	IsItScreen ds:[si],DoCall

	; Exclude the save / restore rect
	les	bx,lpRect
	push	cs:[CSlp16LogDevice_In_NVTEXT16]

	mov	ax,es:[bx].RECT.left
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,es:[bx].RECT.top
	or	ax,ax
	jg	@F
	sub	ax,ax
@@:	push	ax

	mov	ax,es:[bx].RECT.right
	cmp	ax,ds:[si].DIBENGINE.deWidth
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deWidth
@@:	push	ax

	mov	ax,es:[bx].RECT.bottom
	cmp	ax,ds:[si].DIBENGINE.deHeight
	jb	@F
	mov	ax,ds:[si].DIBENGINE.deHeight
@@:	push	ax

	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deBeginAccess

	mov	wExclude,1

	; Prepare return value if busy bit set.
	xor	ax,ax

	; We must set the BUSY bit with a software cursor when we use h/w
	; because that is what the DIBENG uses to know when it can draw
	; and when it can't.
	bts	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jc	DoneIt

DoCall:
	push	lpRect
	push	wCommand
	call	GENERIC_SaveScreenBitmap

DoneCall:
	; Turn off BUSY bit
	btr	ds:[si].DIBENGINE.deFlags,BUSY_BIT
	jnc	DoneIt

	; Do we need to unexclude?
	cmp	wExclude,0
	je	DoneIt

	; Yes so do it. Don't forget to save return value
	mov	wRet,ax
	push	cs:[CSlp16LogDevice_In_NVTEXT16]
	pushw	FB_ACCESS + CURSOREXCLUDE
	call	FFP16 PTR ds:[si].DIBENGINE.deEndAccess
	mov	ax,wRet
DoneIt:
	POPR	ds,si
CLOSEPROC

;==============================================================================
;
; Function:     Wrap_BitBlt
;
; Purpose:      This function is junction to dibengine.
;               It clear busy bit before jmp because dibengine
;		return error if this bit set.
;
; Arguments:    none
;
; Returns:      none
;
;==============================================================================
DECPROC Wrap_BitBlt, PASCAL, NOFRAME, FAR16
OPENPROC
	les	bx,cs:[CSlp16LogDevice_In_NVTEXT16]
	and	es:[bx].DIBENGINE.deFlags,NOT BUSY
        jmp     DIB_BitBlt
CLOSEPROC

;==============================================================================
;
; Function:     Wrap_BitmapBits
;
; Purpose:      This function is junction to dibengine.
;               It clear busy bit before jmp because dibengine
;		return error if this bit set.
;
; Arguments:    none
;
; Returns:      none
;
;==============================================================================
DECPROC Wrap_BitmapBits, PASCAL, NOFRAME, FAR16
OPENPROC
	les	bx,cs:[CSlp16LogDevice_In_NVTEXT16]
	and	es:[bx].DIBENGINE.deFlags,NOT BUSY
        jmp     DIB_BitmapBits
CLOSEPROC

;==============================================================================
;
; Function:     Wrap_ExtTextOut
;
; Purpose:      This function is junction to dibengine.
;               It clear busy bit before jmp because dibengine
;		return error if this bit set.
;
; Arguments:    none
;
; Returns:      none
;
;==============================================================================
DECPROC Wrap_ExtTextOut, PASCAL, NOFRAME, FAR16
OPENPROC
	les	bx,cs:[CSlp16LogDevice_In_NVTEXT16]
	and	es:[bx].DIBENGINE.deFlags,NOT BUSY
        jmp     DIB_ExtTextOut
CLOSEPROC

;==============================================================================
;
; Function:     Wrap_DibBltExt
;
; Purpose:      This function is junction to dibengine.
;               It clear busy bit before jmp because dibengine
;		return error if this bit set.
;
; Arguments:    none
;
; Returns:      none
;
;==============================================================================
DECPROC Wrap_DibBltExt, PASCAL, NOFRAME, FAR16
OPENPROC
	les	bx,cs:[CSlp16LogDevice_In_NVTEXT16]
	and	es:[bx].DIBENGINE.deFlags,NOT BUSY
        jmp     DIB_DibBltExt
CLOSEPROC

;==============================================================================
;
; Function:     Wrap_DibToDevice
;
; Purpose:      This function is junction to dibengine.
;               It clear busy bit before jmp because dibengine
;		return error if this bit set.
;
; Arguments:    none
;
; Returns:      none
;
;==============================================================================
DECPROC Wrap_DibToDevice, PASCAL, NOFRAME, FAR16
OPENPROC
	les	bx,cs:[CSlp16LogDevice_In_NVTEXT16]
	and	es:[bx].DIBENGINE.deFlags,NOT BUSY
        jmp     DIB_DibToDevice
CLOSEPROC

;==============================================================================
;
; Function:     Wrap_Output
;
; Purpose:      This function is junction to dibengine.
;               It clear busy bit before jmp because dibengine
;		return error if this bit set.
;
; Arguments:    none
;
; Returns:      none
;
;==============================================================================
DECPROC Wrap_Output, PASCAL, NOFRAME, FAR16
OPENPROC
	les	bx,cs:[CSlp16LogDevice_In_NVTEXT16]
	and	es:[bx].DIBENGINE.deFlags,NOT BUSY
        jmp     DIB_Output
CLOSEPROC

;==============================================================================
;
; Function:     Wrap_Pixel
;
; Purpose:      This function is junction to dibengine.
;               It clear busy bit before jmp because dibengine
;		return error if this bit set.
;
; Arguments:    none
;
; Returns:      none
;
;==============================================================================
DECPROC Wrap_Pixel, PASCAL, NOFRAME, FAR16
OPENPROC
	les	bx,cs:[CSlp16LogDevice_In_NVTEXT16]
	and	es:[bx].DIBENGINE.deFlags,NOT BUSY
        jmp     DIB_Pixel
CLOSEPROC

;==============================================================================
;
; Function:     Wrap_StretchBlt
;
; Purpose:      This function is junction to dibengine.
;               It clear busy bit before jmp because dibengine
;		return error if this bit set.
;
; Arguments:    none
;
; Returns:      none
;
;==============================================================================
DECPROC Wrap_StretchBlt, PASCAL, NOFRAME, FAR16
OPENPROC
	les	bx,cs:[CSlp16LogDevice_In_NVTEXT16]
	and	es:[bx].DIBENGINE.deFlags,NOT BUSY
        jmp     DIB_StretchBlt
CLOSEPROC

;==============================================================================
;
; Function:     Wrap_StretchDIBits
;
; Purpose:      This function is junction to dibengine.
;               It clear busy bit before jmp because dibengine
;		return error if this bit set.
;
; Arguments:    none
;
; Returns:      none
;
;==============================================================================
DECPROC Wrap_StretchDIBits, PASCAL, NOFRAME, FAR16
OPENPROC
	les	bx,cs:[CSlp16LogDevice_In_NVTEXT16]
	and	es:[bx].DIBENGINE.deFlags,NOT BUSY
        jmp     DIB_StretchDIBits
CLOSEPROC

;==============================================================================
;
; Function:     Wrap_UpdateColorsExt
;
; Purpose:      This function is junction to dibengine.
;               It clear busy bit before jmp because dibengine
;		return error if this bit set.
;
; Arguments:    none
;
; Returns:      none
;
;==============================================================================
DECPROC Wrap_UpdateColorsExt, PASCAL, NOFRAME, FAR16
OPENPROC
	les	bx,cs:[CSlp16LogDevice_In_NVTEXT16]
	and	es:[bx].DIBENGINE.deFlags,NOT BUSY
        jmp     DIB_UpdateColorsExt
CLOSEPROC

;================================================================
DECPROC DIB_DibBlt, PASCAL, NOFRAME, FAR16
OPENPROC
        ; The DIBENG DibBltExt takes an extra parameter which indicates
        ; whether we are running in a palettized mode right now.
	mov	bx,sp
	lgs	bx,ss:[bx+30]
        test    gs:[bx].DIBENGINEHDR.deFlags,PALETTIZED
        setne   bl
        movzx   bx,bl
        pop     eax
        push    bx
        push    eax
        jmp     DIB_DibBltExt
CLOSEPROC

;================================================================
DECPROC DIB_RealizeObject, PASCAL, NOFRAME, FAR16
OPENPROC
        pop     eax
        push    cs:[CSlp16LogDevice_In_NVTEXT16]
        push    eax
        jmp     DIB_RealizeObjectExt
CLOSEPROC

;================================================================
DECPROC DIB_SetPalette, PASCAL, NOFRAME, FAR16
OPENPROC
        pop     eax
        push    cs:[CSlp16LogDevice_In_NVTEXT16]
        push    eax
        jmp     DIB_SetPaletteExt
CLOSEPROC

;================================================================
DECPROC DIB_UpdateColors, PASCAL, NOFRAME, FAR16
OPENPROC
        pop     eax
        push    cs:[CSlp16LogDevice_In_NVTEXT16]
        push    eax
        jmp     DIB_UpdateColorsExt
CLOSEPROC

;================================================================
DECPROC DIB_SaveScreenBitmap, PASCAL, NOFRAME, FAR16
OPENPROC
	sub	eax,eax
        RETFAR16 06H
CLOSEPROC

;================================================================
GN_PatchedProcTable:
	dd	[Patch_BitBlt]
	dd	[Patch_BitmapBits]
	dd	[Patch_DibBlt]
	dd	[Patch_ExtTextOut]
	dd	[Patch_Output]
	dd	[Patch_Pixel]
	dd	[Patch_RealizeObject]
	dd	[Patch_ScanLR]
	dd	[Patch_SetDIBitsToDevice]
	dd	[Patch_SetPalette]
	dd	[Patch_StretchBlt]
	dd	[Patch_StretchDIBits]
	dd	[Patch_StrBlt]
	dd	[Patch_UpdateColors]
	dd	[Patch_SaveScreenBitmap]
PatchedProcTableSize	equ	( $ - GN_PatchedProcTable ) / 4

GN_HWCursorProcTable:
	dd	[GENERIC_BitBlt]
	dd	[GENERIC_BitmapBits]
	dd	[GENERIC_DibBlt]
	dd	[GENERIC_ExtTextOut]
	dd	[GENERIC_Output]
	dd	[GENERIC_Pixel]
	dd	[GENERIC_RealizeObject]
	dd	[GENERIC_ScanLR]
	dd	[GENERIC_SetDIBitsToDevice]
	dd	[GENERIC_SetPalette]
	dd	[GENERIC_StretchBlt]
	dd	[GENERIC_StretchDIBits]
	dd	[GENERIC_StrBlt]
	dd	[GENERIC_UpdateColors]
	dd	[GENERIC_SaveScreenBitmap]
        .errnz  $ - GN_HWCursorProcTable - PatchedProcTableSize * 4

GN_SWCursorProcTable:
	dd	[BitBlt_WithExclude]
	dd	[BitmapBits_WithExclude]
	dd	[DibBlt_WithExclude]
	dd	[ExtTextOut_WithExclude]
	dd	[Output_WithExclude]
	dd	[Pixel_WithExclude]
	dd	[GENERIC_RealizeObject]
	dd	[DIB_ScanLR]
	dd	[SetDIBitsToDevice_WithExclude]
	dd	[GENERIC_SetPalette]
	dd	[StretchBlt_WithExclude]
	dd	[StretchDIBits_WithExclude]
	dd	[StrBlt_WithExclude]
	dd	[UpdateColors_WithExclude]
	dd	[SaveScreenBitmap_WithExclude]
        .errnz  $ - GN_SWCursorProcTable - PatchedProcTableSize * 4

GN_PuntProcTable:
	dd	[DIB_BitBlt]
	dd	[DIB_BitmapBits]
	dd	[DIB_DibBlt]
	dd	[DIB_ExtTextOut]
	dd	[DIB_Output]
	dd	[DIB_Pixel]
;;	dd	[GENERIC_RealizeObject]
	dd	[DIB_RealizeObject]; do not create offscreen objects
	dd	[DIB_ScanLR]
	dd	[DIB_DibToDevice]
	dd	[GENERIC_SetPalette]	;[DIB_SetPalette]; to exclude h/w access at all
	dd	[DIB_StretchBlt]
	dd	[DIB_StretchDIBits]
	dd	[DIB_StrBlt]
	dd	[DIB_UpdateColors]
	dd	[DIB_SaveScreenBitmap]
        .errnz  $ - GN_PuntProcTable - PatchedProcTableSize * 4

;================================================================
GN_PatchedPuntTable:
	dd	[Punt_BitmapBits]
	dd	[Punt_BitBlt]
	dd	[Punt_DibBlt]
	dd	[Punt_DibToDevice]
	dd	[Punt_ExtTextOut]
	dd	[Punt_Output]
	dd	[Punt_Polyline]
	dd	[Punt_Rectangle]
	dd	[Punt_BeginScan]
	dd	[Punt_Scan]
	dd	[Punt_EndScan]
	dd	[Punt_Pixel]
	dd	[Punt_StrBlt]
	dd	[Punt_StrDib]
	dd	[Punt_UpdateColors]
PatchedPuntTableSize	equ	( $ - GN_PatchedPuntTable ) / 4

GN_DibengTable:
	dd	[DIB_BitmapBits]
	dd	[DIB_BitBlt]
	dd	[DIB_DibBltExt]
	dd	[DIB_DibToDevice]
	dd	[DIB_ExtTextOut]
	dd	[DIB_Output]
	dd	[DIB_Output]
	dd	[DIB_Output]
	dd	[DIB_Output]
	dd	[DIB_Output]
	dd	[DIB_Output]
	dd	[DIB_Pixel]
	dd	[DIB_StretchBlt]
	dd	[DIB_StretchDIBits]
	dd	[DIB_UpdateColorsExt]
        .errnz  $ - GN_DibengTable - PatchedPuntTableSize * 4

GN_JuncToDibTable:
	dd	[Wrap_BitmapBits]
	dd	[Wrap_BitBlt]
	dd	[Wrap_DibBltExt]
	dd	[Wrap_DibToDevice]
	dd	[Wrap_ExtTextOut]
	dd	[Wrap_Output]
	dd	[Wrap_Output]
	dd	[Wrap_Output]
	dd	[Wrap_Output]
	dd	[Wrap_Output]
	dd	[Wrap_Output]
	dd	[Wrap_Pixel]
	dd	[Wrap_StretchBlt]
	dd	[Wrap_StretchDIBits]
	dd	[Wrap_UpdateColorsExt]
        .errnz  $ - GN_JuncToDibTable - PatchedPuntTableSize * 4

;==============================================================================
;
; Function:     GN_TurnExcludeOffOrOn
;
; Purpose:      This function do patch of drv entry points
;		to work with h/w - s/w cursors.
;
; Arguments:    dwCursorFlags
;
;==============================================================================
DECPROC GN_TurnExcludeOffOrOn, PASCAL, FRAME, FAR16
PARMD   dwCursorFlags
OPENPROC
	PUSHR	ds,es,si,di
	mov	ax,cs:[wNVTEXT16_Alias_In_NVTEXT16]
	mov	es,ax
	mov	bx,GN_PuntProcTable
	or	ax,ax

	;;;In order to punt everything to dibengine change jz --> jnz
	jz	@F
	mov	bx,GN_HWCursorProcTable
@@:
	test	dwCursorFlags,CURSOR_HAS_TRAILS
	jz	@F
	mov	bx,GN_SWCursorProcTable
@@:
	mov	si,offset GN_PatchedProcTable
	mov	cx,PatchedProcTableSize
ProcLoop:
	mov	di,word ptr cs:[si]
	inc	di
	mov	eax,dword ptr cs:[bx]
	mov	dword ptr es:[di],eax
	add	bx,size DWORD
	add	si,size DWORD
	dec	cx
	jnz	ProcLoop

	mov	ax,cs:[wNVTEXT32_Alias_In_NVTEXT16]
	mov	es,ax
	mov	bx,GN_DibengTable
	test	dwCursorFlags,CURSOR_HAS_TRAILS
	jz	@F
	mov	bx,GN_JuncToDibTable
@@:
	mov	si,offset GN_PatchedPuntTable
	mov	cx,PatchedPuntTableSize
PuntLoop:
	mov	di,word ptr cs:[si]
	add	di,2
	mov	eax,dword ptr cs:[bx]
	mov	dword ptr es:[di],eax
	add	bx,size DWORD
	add	si,size DWORD
	dec	cx
	jnz	PuntLoop
	POPR	ds,es,si,di
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNUTIL.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnutil.asm
;
; Purpose:      This file holds services that the rest of the driver
;               commonly needs.
;==============================================================================
.586
incLogical  = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include modeext.inc
include escape.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     GN_MemoryAlloc
;
; Purpose:      This function is called to purchase system memory.
;
; Arguments:    eax     amount of memory to purchase
;
; Returns:      eax     0       then failed
;                       non-0   then success
;                               In this case edx = selector to memory block
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_MemoryAlloc, PASCAL, NOFRAME, FAR16
OPENPROC
        ; 2000H = GMEM_SHARE and 0040H = GMEM_ZEROINIT
        mov     edx,2040H
        push    dx
        push    eax
        call    GlobalAlloc
        sub     edx,edx
        or      ax,ax
        je      done

        ; Allocation was successful. Now lock the memory
        push    ax
        push    ax
        call    GlobalLock
        or      dx,dx
        jne     @F

        ; Lock failed so free the memory
        call    GlobalFree
        sub     edx,edx
        jmp     done
@@:
        ; Return edx = selector and ax nonzero to indicate success
        movzx   edx,dx
        pop     ax
done:
CLOSEPROC


;==============================================================================
;
; Function:     GN_MemoryFree
;
; Purpose:      This function is called to free system memory.
;
; Arguments:    eax     selector of memory block to free
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_MemoryFree, PASCAL, NOFRAME, FAR16
OPENPROC
        ; Get the handle corresponding to this selector
        push    ax
        call    GlobalHandle
        or      ax,ax
        je      done

        ; Unlock the memory block and free it
        push    ax
        push    ax
        call    GlobalUnlock
        call    GlobalFree
done:
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetSelectorBase
;
; Purpose:      This function is called to get the base of
;               a selector.
;
; Arguments:
;               dwSelector              Selctor to get base of
;
; Returns:
;               eax                     Linear Base of selector
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_GetSelectorBase, PASCAL, FRAME, FAR16
PARMD   dwSelector
OPENPROC
        push    word ptr dwSelector
        call    GetSelectorBase
        shl     edx,10H
        mov     dx,ax
        mov     eax,edx
CLOSEPROC


;==============================================================================
;
; Function:     GN_AllocSelectorAndNullIt
;
; Purpose:      This function allocates a selector and sets its base
;               and limit to zero.
;
; Arguments:    None
;
; Returns:      eax     selector if successful
;                       0        if failure
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_AllocSelectorAndNullIt, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   edi

        ; Alloc a selector
        mov     ax,cs
        push    ax
        call    AllocCSToDSAlias
        movzx   edi,ax
        or      eax,eax
        je      Done

        ; Set selector to be small, data, and read/write
        mov     eax,00010012H
        push    di
        push    eax
        call    SelectorAccessRights

        ; Set selector base to NULL
        sub     eax,eax
        push    di
        push    eax
        call    SetSelectorBase

        ; Set selector limit to NULL
        sub     eax,eax
        push    di
        push    eax
        call    SetSelectorLimit

        ; Return the selector
        mov     eax,edi
Done:
        POPR    edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_AllocSelectorAndMapIt
;
; Purpose:      This function allocates a selector and sets its base
;               and limit to the values passed in. The selector is
;               always forced to be large, data, read/write.
;
; Arguments:    eax     0       then address in ebx is a physical address
;                       non-0   then address in ebx is a linear address
;               ebx     base address -- physical or linear based on eax
;               ecx     limit of selector
;
; Returns:      eax     selector if successful
;                       0        if failure
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_AllocSelectorAndMapIt, PASCAL, FRAME, FAR16
LOCALD  dwBase
LOCALD  dwLimit
LOCALW  wSelector
OPENPROC
        PUSHR   esi,edi

        mov     dwBase,ebx
        mov     dwLimit,ecx

        or      eax,eax
        jne     @F

        ; Convert the physical address to a linear address
        mov     cx,word ptr dwBase+0
        mov     bx,word ptr dwBase+2
        mov     di,word ptr dwLimit+0
        mov     si,word ptr dwLimit+2
        mov     eax,800H
        int     31H
        mov     eax,0
        jc      Done

        ; Call succeeded -- linear address is in bx:cx
        mov     word ptr dwBase+0,cx
        mov     word ptr dwBase+2,bx
@@:
        ; Get a selector
        call    GN_AllocSelectorAndNullIt
        or      eax,eax
        je      Done
        mov     wSelector,ax

        ; Set the selector to be large, data, read/write
        push    wSelector
        pushd   00008012H
        call    SelectorAccessRights

        ; Set the selector base
        push    wSelector
        push    dwBase
        call    SetSelectorBase

        ; Set the selector limit
        dec     dwLimit
        push    wSelector
        push    dwLimit
        call    SetSelectorLimit
        movzx   eax,wSelector
Done:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_UnmapAndFreeSelector
;
; Purpose:      This function sets the mapping for a selector to be
;               small, data. read/write with a NULL base and limit and
;               then frees the selector.
;
; Arguments:    eax     selector to free
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_UnmapAndFreeSelector, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   edi

        ; Safety check
        or      eax,eax
        jz      Exit

        mov     edi,eax

        ; Set selector to be small, data, and read/write
        mov     eax,00010012H
        push    di
        push    eax
        call    SelectorAccessRights

        ; Set selector base to NULL
        sub     eax,eax
        push    di
        push    eax
        call    SetSelectorBase

        ; Set selector limit to NULL
        sub     eax,eax
        push    di
        push    eax
        call    SetSelectorLimit

        ; Free selector
        push    di
        call    FreeSelector

Exit:
        POPR    edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_GetDeviceLocalBasePath
;
; Purpose:      This function just gets the local base path for
;               the specified devnode.
;
; Arguments:
;               dwDevnodeHandle         Device Node handle
;               dwPathSel               sel:offset of place to store
;               dwPathOffset               the monitor registry path
;               dwDeviceNameSel         sel:offset of the device type
;               dwDeviceNameOffset      should be either "Display"
;                                       or "Monitor"
;
;
; Returns:
;               If this routine is successful then the first dword
;               pointed to by dwPathSel:dwPathOffset gets stuffed
;               with a constant HKEY like HKEY_LOCAL_MACHINE. All
;               bytes after that are a registry path inside the key
;               given in the first dword that are that local base
;               registry path for the given device.
;
;               ecx     SPECIFIC_DEVICE
;                       UNKNOWN_DEVICE
;                       PLUG_AND_PLAY_DEVICE
;
; Preserve:     ds,es,fs,esi,edi
;==============================================================================
szToDevice      DB      "System\CurrentControlSet\Services\Class\",0

USE_EBP TEXTEQU <1>

DECPROC GN_GetDeviceLocalBasePath, PASCAL, FRAME, FAR16
PARMD   dwDevnodeHandle
PARMD   dwPathSel
PARMD   dwPathOffset
PARMD   dwDeviceNameSel
PARMD   dwDeviceNameOffset
LOCALS  szPath,MAX_KEY_LEN
LOCALS  szDevice,MAX_KEY_LEN
LOCALS  szDeviceName,MAX_KEY_LEN
LOCALS  szDriver,16
LOCALS  szDeviceDesc,16
LOCALD  dwStackOffsetToDeviceName
LOCALD  hLocalKey
LOCALD  dwSize
LOCALD  dwUnknownDevice
OPENPROC
        PUSHR   alld,ds,es,fs
        mov     dwUnknownDevice,SPECIFIC_DEVICE

        ; Place "Enum\" into szPath
        mov     dword ptr szPath[0],'munE'
        mov     byte  ptr szPath[4],'\'

        cmp     dwDevnodeHandle,0
        je      SetDefaultPath

        ; Create a flat selector to all of memory
        mov     eax,1
        sub     ebx,ebx
        mov     ecx,0FFFFFFFEH
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      SetDefaultPath
        mov     fs,ax

        ; The second DWORD in the devnode structure is a ptr to
        ; a registry path string name.
        mov     eax,dwDevnodeHandle
        mov     edi,fs:[eax + 4]
        cmp     edi,0AAAAAAAAH
        je      SkipCopy

        ; Copy the string to local storage
        mov     ecx,5
@@:     mov     al,fs:[edi]
        inc     edi
        mov     szPath[ecx],al
        inc     ecx
        or      al,al
        jne     @B

SkipCopy:
        mov     ax,fs
        call    GN_UnmapAndFreeSelector
        cmp     edi,0AAAAAAAAH
        je      SetDefaultPath

        ; Open the key
        pushd   HKEY_LOCAL_MACHINE      ; hKey
        mov     ax,ss
        lea     ebx,szPath
        push    ax
        push    bx                      ; lpSubKey
        lea     ebx,hLocalKey
        push    ax
        push    bx                      ; phkResult
        call    RegCreateKey
        shl     edx,10H
        mov     dx,ax
        cmp     edx,ERROR_SUCCESS
        jne     SetDefaultPath

        ; Read the "Driver" string in this key. It should be equal
        ; to something like: "Display\0003"  or "Monitor\0001"
        ; Monitor or Display may be upper or lower case
        mov     dword ptr szDriver[0],'virD'
        mov     dword ptr szDriver[4],'re'
        sub     ecx,ecx
        mov     szDevice[0],cl
        mov     dwSize,128
        mov     ax,ss
        shl     eax,10H
        push    hLocalKey
        lea     ax,szDriver
        push    eax
        push    ecx
        push    ecx
        lea     ax,szDevice
        push    eax
        lea     ax,dwSize
        push    eax
        call    RegQueryValueEx

        ; Read the "DeviceDesc" string in this key. It should be equal
        ; to something like: "(Unknown Monitor)" or "Default Monitor".
        ; If it is, then we should flag it as an unknown device.
        mov     dword ptr szDeviceDesc[0],'iveD'
        mov     dword ptr szDeviceDesc[4],'eDec'
        mov     dword ptr szDeviceDesc[8],'cs'
        sub     ecx,ecx
        mov     szDeviceName[0],cl
        mov     dwSize,128
        mov     ax,ss
        shl     eax,10H
        push    hLocalKey
        lea     ax,szDeviceDesc
        push    eax
        push    ecx
        push    ecx
        lea     ax,szDeviceName
        push    eax
        lea     ax,dwSize
        push    eax
        call    RegQueryValueEx

        push    hLocalKey
        call    RegCloseKey

        cmp     byte ptr szDevice[0],0
        je      SetDefaultPath

MakePath:
        ; Let's build the final string. First,
        ; System\CurrentControlSet\Services\Class\
        mov     ds,dwPathSel
        mov     ebx,dwPathOffset
        mov     dword ptr ds:[ebx],HKEY_LOCAL_MACHINE
        add     ebx,4
        sub     ecx,ecx
@@:     mov     al,cs:szToDevice[ecx]
        inc     ecx
        mov     ds:[ebx],al
        inc     ebx
        or      al,al
        jne     @B

        ; Attach the device and number for something like
        ; System\CurrentControlSet\Services\Class\Display\0005
        dec     ebx
        sub     ecx,ecx
@@:     mov     al,szDevice[ecx]
        inc     ecx
        mov     ds:[ebx],al
        inc     ebx
        or      al,al
        jne     @B

        ; If DeviceDesc="(Unknown Monitor)" , then flag it.
        ; Windows 98 uses this string to indicate unknown monitors.
        sub     eax,eax
        cmp     dword ptr szDeviceName[0],'knU('
        jne     Check2
        cmp     dword ptr szDeviceName[4],'nwon'
        jne     Check2
        cmp     dword ptr szDeviceName[8],'noM '
        jne     Check2
        cmp     dword ptr szDeviceName[12],'roti'
        jne     Check2
        cmp     byte ptr szDeviceName[16],')'
        je      MarkAsUnknown

        ; If DeviceDesc="Default Monitor" , then flag it as unknown.
        ; Windows 98 SE2 uses this string to indicate unknown monitors.
Check2: cmp     dword ptr szDeviceName[0],'afeD'
        jne     Check3
        cmp     dword ptr szDeviceName[4],' tlu'
        jne     Check3
        cmp     dword ptr szDeviceName[8],'inoM'
        jne     Check3
        cmp     dword ptr szDeviceName[12],'rot'
        jne     Check3
        je      MarkAsUnknown

        ; If DeviceDesc="Plug and Play Monitor" , then flag it as
        ; an unknown monitor since no INF file is really installed.
Check3: sub     eax,eax
        cmp     dword ptr szDeviceName[0],'gulP'
        jne     Check4
        cmp     dword ptr szDeviceName[4],'dna '
        jne     Check4
        cmp     dword ptr szDeviceName[8],'alP '
        jne     Check4
        cmp     dword ptr szDeviceName[12],'oM y'
        jne     Check4
        cmp     dword ptr szDeviceName[16],'otin'
        jne     Check4
        cmp     byte ptr szDeviceName[20],'r'
        mov     dwUnknownDevice,PLUG_AND_PLAY_DEVICE

Check4: jmp     Done

MarkAsUnknown:
        mov     dwUnknownDevice,UNKNOWN_DEVICE
        jmp     Done

SetDefaultPath:
        mov     ds,dwDeviceNameSel
        mov     ecx,dwDeviceNameOffset
        sub     ebx,ebx
@@:     mov     al,ds:[ecx][ebx]
        mov     szDevice[ebx],al
        inc     ebx
        or      al,al
        jne     @B
        mov     dword ptr szDevice[ebx - 1],'000\'
        mov     dword ptr szDevice[ebx + 3],'0'
        mov     dwUnknownDevice,UNKNOWN_DEVICE
        jmp     MakePath

Done:
        POPR    alld,ds,es,fs
        mov     ecx,dwUnknownDevice
CLOSEPROC

;==============================================================================
;
; Function:     GN_CheckInterlacedStereoConnection
;
; Purpose:      This function determines if stereo is enabled and 
;               stereo connection type is interlaced (aka ASUS).
;
; Arguments:
;               None
;
;
; Returns:
;               If stereo is disabled or stereo connection type 
;               is not interlaced the function returns 0 otherwise
;               guess what? Absolutely right. Not zero.
;               bytes after that are a registry path inside the key
;
; Preserve:     ds,es,fs,esi,edi
;==============================================================================
szToStereo      DB      "Software\NVIDIA Corporation\Global\Stereo3D",0

DECPROC GN_CheckInterlacedStereoConnection, PASCAL, FRAME, FAR16
LOCALS  szSubKey,MAX_KEY_LEN
LOCALD  hLocalKey
LOCALD  dwSize
LOCALD  dwInterlacedStereo
LOCALD  dwValue
OPENPROC
        PUSHR   alld,ds,es,fs
        mov     dwInterlacedStereo,0

        ; Open the key
        pushd   HKEY_LOCAL_MACHINE      ; hKey
        mov     ax,cs
        lea     ebx,szToStereo
        push    ax
        push    bx                      ; lpSubKey
        lea     ebx,hLocalKey
        mov     ax,ss
        push    ax
        push    bx                      ; phkResult
        call    RegOpenKey
        shl     edx,10H
        mov     dx,ax
        cmp     edx,ERROR_SUCCESS
        jne     Done

        ; Read the "StereoEnable" string. If it is not 0 then stereo is enable
        ; Place "StereoEnable" into szSubKey
        mov     dword ptr szSubKey[ 0],'retS'
        mov     dword ptr szSubKey[ 4],'nEoe'
        mov     dword ptr szSubKey[ 8],'elba'
        mov     dword ptr szSubKey[12],0

        sub     ecx,ecx
        mov     dwValue, ecx
        mov     dwSize,4
        mov     ax,ss
        shl     eax,10H
        push    hLocalKey
        lea     ax,szSubKey
        push    eax
        push    ecx
        push    ecx
        lea     ax,dwValue
        push    eax
        lea     ax,dwSize
        push    eax
        call    RegQueryValueEx
        shl     edx,10H
        mov     dx,ax
        cmp     edx,ERROR_SUCCESS
        jne     Done_And_Close

        cmp     dwValue,0
        je      Done_And_Close

        ; Read the "StereoViewerType" string. If it is STEREOCFG_INTERLACED then stereo is interlaced
        ; Place "StereoViewerType" into szSubKey
        mov     dword ptr szSubKey[ 0],'retS'
        mov     dword ptr szSubKey[ 4],'iVoe'
        mov     dword ptr szSubKey[ 8],'rewe'
        mov     dword ptr szSubKey[12],'epyT'
        mov     dword ptr szSubKey[16],0

        sub     ecx,ecx
        mov     dwValue, ecx
        mov     dwSize,4
        mov     ax,ss
        shl     eax,10H
        push    hLocalKey
        lea     ax,szSubKey
        push    eax
        push    ecx
        push    ecx
        lea     ax,dwValue
        push    eax
        lea     ax,dwSize
        push    eax
        call    RegQueryValueEx
        shl     edx,10H
        mov     dx,ax
        cmp     edx,ERROR_SUCCESS
        jne     Done_And_Close

        cmp     dwValue,STEREOCFG_INTERLACED
        jne      Done_And_Close
        mov     dwInterlacedStereo,1

Done_And_Close:
        push    hLocalKey
        call    RegCloseKey

Done:
        POPR    alld,ds,es,fs
        mov     eax,dwInterlacedStereo
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\CODE\GNVDD.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gnvdd.asm
;
; Purpose:      This file holds the interface calls to the main VDD.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gndata.inc
include gnlogdev.inc
include gnboard.inc
include gncrtc.inc
include gngdi.inc
include hwgdi.inc
include minivdd.inc
include ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
PUBLIC  dwThisLogicalDeviceHandle
dwThisLogicalDeviceHandle       DD      0
CLOSESEG _NVTEXT32

OPENSEG  _NVTEXT16, USE16, CODE
PUBLIC  lpfnVddEntryPoint
lpfnVddEntryPoint               DD      0

PUBLIC  dwThisLogicalDeviceHandle_In_NVTEXT16
dwThisLogicalDeviceHandle_In_NVTEXT16   DD      0

;==============================================================================
;
; Function:     GN_VddGetEntryPoint
;
; Purpose:      This function gets the entry point for the VDD Protected
;               Mode API services.
;
; Arguments:    None
;
; Returns:      eax     0       Failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddGetEntryPoint, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,edi
        mov     eax,1684h
        mov     ebx,0AH
        int     2fh
        mov     ax,es
        shl     eax,10H
        mov     ax,di
        mov     ds,cs:[wNVTEXT16_Alias_In_NVTEXT16]
        mov     ds:[lpfnVddEntryPoint],eax
        POPR    ds,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddGetDeviceHandle
;
; Purpose:      This function gets the device handle for this
;               instance of the driver. This function should
;               not rely on the CSlp16LogDevice being set.
;
; Arguments:    eax     lpDstDevType argument to GENERIC_Enable
;
; Returns:      eax     0     then there was an error getting the handle
;                       non-0 then ecx has the dwDeviceHandle
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddGetDeviceHandle, PASCAL, FRAME, FAR16
PARMD   lpDstDevType
OPENPROC
        PUSHR   ds,esi,edi

        ; If lpDstDevType is NULL, then we are the primary display.
        mov     ecx,1
        mov     eax,1
        cmp     lpDstDevType,0
        je      DoneIt

        ; Call the main VDD to have it open us as a secondary device
        mov     eax,lpDstDevType
        movzx   edi,ax
        shr     eax,10H
        mov     es,ax
        mov     eax,VDD_OPEN
        sub     edx,edx
        sub     ecx,ecx
        mov     si,es
        sub     ebx,ebx                 ; use EBX to point to PDEVICE
        call    FFP16 PTR lpfnVddEntryPoint

        ; 0 and -1 are not valid device handles
        ; Anything else we must accept as valid
        ; (Note: minivdd.inc does not specify any error codes.)
        mov     ecx,eax
        sub     eax,eax
        cmp     ecx,-1
        je      DoneIt

        mov     eax,1
        cmp     ecx,0
        jne     DoneIt
        mov     ecx,1

DoneIt:
        mov     ds,cs:[wNVTEXT16_Alias_In_NVTEXT16]
        mov     ds:[dwThisLogicalDeviceHandle_In_NVTEXT16],ecx
        mov     ds,cs:[wNVTEXT32_Alias_In_NVTEXT16]
        mov     ds:[dwThisLogicalDeviceHandle],ecx
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddEnableDevice
;
; Purpose:      This function will make a call to the VDD to enable
;               some type of access to the device.
;
; Arguments:
;               dwEnableType            Enable type like ENABLE_MEM, etc.
;                                       minivdd.inc has all the equates
;
; Returns:      eax     ENABLE_ERROR if there was a problem
;                       anything else if there was no problem
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddEnableDevice, PASCAL, FRAME, FAR16
PARMD   dwEnableType
OPENPROC
        PUSHR   ds,esi,edi
        mov     ebx,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        mov     edx,dwEnableType
        mov     eax,VDD_ENABLE
        sub     edi,edi
        mov     es,di
        mov     esi,edi
        sub     ecx,ecx
        call    FFP16 PTR lpfnVddEntryPoint
        cmp     eax,VDD_ENABLE
        jne     @F
        mov     eax,ENABLE_ERROR
@@:     POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddCloseDevice
;
; Purpose:      This function closes the device specified in
;               GNBOARDCX.dwDeviceHandle
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddCloseDevice, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi
	mov	eax,VDD_CLOSE
        mov     ebx,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        sub     ecx,ecx
        sub     edx,edx
        mov     es,dx
        sub     edi,edi
        call    FFP16 PTR lpfnVddEntryPoint
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddGetDisplayInfo
;
; Purpose:      This function gets the DISPLAYINFO strcuture from the
;               main VDD.
;
; Arguments:
;               lpDisplayInfo           16:16 ptr to DUISPLAYINFO
;               dwDisplayCallIndex      either VDD_GET_DISPLAY_CONFIG
;                                       or VDD_GET_DISPLAY_CONFIG2
;
; Returns:      The DISPLAYINFO structure is filled in
;               There are no failure codes listed in minivdd.h
;               although the DISPLAYINFO.diInfoFlags has some error info.
;
; Preserve:     ds,esi,es,edi
;==============================================================================
DECPROC GN_VddGetDisplayInfo, PASCAL, FRAME, FAR16
PARMD   lpDisplayInfo
PARMD   dwDisplayCallIndex
OPENPROC
        PUSHR   ds,es,esi,edi
        sub     edi,edi
        les     di,lpDisplayInfo
        mov     eax,dwDisplayCallIndex
        mov     ebx,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        mov     ecx,SIZE DISPLAYINFO
        mov     es:[edi].DISPLAYINFO.diHdrSize,cx
        call    FFP16 PTR lpfnVddEntryPoint
        POPR    ds,es,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddDriverRegister
;
; Purpose:      This function calls the main VDD to register the
;               display driver. The driver can tell the VDD the function
;               that should be called when the driver needs to be put
;               back in a high resolution mode. Also, the driver can
;               specify an area of offscreen memory to be used for
;               VGA virtualization and whether or not planar modes
;               are supported in a Windowed DOS box.
;
;               The call to the VDD requires the following:
;               es:edi  ptr to ResetHiResMode function
;               ecx     Offscreen virtualization offset. The VDD may use
;                       from 32K to 64K beginning at this offset into
;                       video memory. If you don't want to allow
;                       VGA virtualization, pass in ecx equal to 0
;                       and edx below equal to -1.
;               edx     0 if planar mode virtualization is to be supported
;                         for Windowed DOS boxes.
;                       -1 if not
;                          If edx is set to -1, then ecx should be set
;                          to 0 -- ignore the minivdd.inc documentation.
;                          There was a bug in an early cut of the main VDD.
;
; Arguments:
;
; Returns:      eax     The offset of the end of the virtualization area
;                       if virtualization is being allowed (via edx,ecx).
;                       Hence, eax minus the value of ecx passed in will
;                       give the amount of memory the VDD is using for
;                       planar mode virtualization.
;                       If the caller requested no virtualization, then
;                       there is no return value.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddDriverRegister, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi
        mov     ebx,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        mov     ax,SEG GENERIC_ResetHiresMode
        mov     es,ax
        mov     edi,OFFSET GENERIC_ResetHiresMode
        sub     ecx,ecx
        mov     edx,-1
        mov     eax,VDD_DRIVER_REGISTER
        call    FFP16 PTR lpfnVddEntryPoint
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddDriverUnregister
;
; Purpose:      This function unregisters the display driver with the VDD.
;
; Arguments:
;
; Returns:      Nothing.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddDriverUnregister, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi
        mov     eax,VDD_DRIVER_UNREGISTER
        mov     ebx,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        call    FFP16 PTR lpfnVddEntryPoint
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddRegisterDisplayDriver
;
; Purpose:      This function was setup up by Windows to allow the
;               display driver to have a private communication with
;               its minivdd. The only required parameters for the
;               VDD_REGISTER_DISPLAY_DRIVER_INFO call are eax equal
;               to this service number and ebx equal to the
;               dwDeviceHandle. All other registers values are
;               private to the driver.
;
; Arguments:
;               ax                      desired value for ds
;               ebx                     desired value for esi
;
;               Whatever other arguments are desired in registers.
;               ax will be moved into ds and ebx will be moved into
;               esi. Then eax will be set to the value
;               VDD_REGISTER_DISPLAY_DRIVER_INFO and ebx will be set
;               the dwDeviceHandle and the call will be made to the
;               main VDD.
;
; Returns:      Whatever is returned from the
;               VDD_REGISTER_DISPLAY_DRIVER_INFO call.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddRegisterDisplayDriver, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi
        mov     ds,ax
        mov     esi,ebx
        mov     eax,VDD_REGISTER_DISPLAY_DRIVER_INFO
        mov     ebx,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        call    FFP16 PTR lpfnVddEntryPoint
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddSaveDriverState
;
; Purpose:      This function tells the VDD to save the driver state.
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddSaveDriverState, PASCAL, NOFRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi
        mov     eax,VDD_SAVE_DRIVER_STATE
        mov     ebx,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        call    FFP16 PTR lpfnVddEntryPoint
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddEnableIOTrapping
;
; Purpose:      This function can enable or disable IO trapping. The
;               routine is a NOP is we are not the primary display.
;
; Arguments:
;               dwEnableFlag            1 to enable trapping,
;                                       0 to disable trapping
;
; Returns:      None
;
; Preserve:     ds,esi
;==============================================================================
STOP_IO_TRAP    TEXTEQU         <4000H>
START_IO_TRAP   TEXTEQU         <4007H>
DECPROC GN_VddEnableIOTrapping, PASCAL, FRAME, FAR16
PARMD   dwEnableFlag
OPENPROC
        PUSHR   ds,esi,edi

        ; If we are the secondary display or if we are unsure what
        ; display we are -- do NOT enable trapping.
        cmp     cs:[dwThisLogicalDeviceHandle_In_NVTEXT16],1
        jne     done

        ; Otherwise, enable or disable based upon eax
        mov     eax,STOP_IO_TRAP
        cmp     dwEnableFlag,0
        je      @F
        mov     eax,START_IO_TRAP
@@:
        int     2FH
done:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddSetLockAndUnlockOffscreen
;
; Purpose:      Send the address of the Lock and Unlock Offscreen
;               Allocations up to the miniVDD. When a DOS box is created
;               the miniVDD will call Lock and whenever one is destroyed,
;               Unlock will be called. Since the display driver does not
;               get control in time to save the offscreen memory area
;               before a DOS box flips full screen, offscreen allocations
;               are inhibited while DOS boxes are active.
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddSetLockAndUnlockOffscreen, PASCAL, FRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi
        mov     eax,VDD_REGISTER_DISPLAY_DRIVER_INFO
        mov     ebx,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        mov     ecx,MVDD_SET_LOCK_AND_UNLOCK_OFFSCREEN_FUNCS
        mov     dx,SEG GN_OffscreenAllocationsLock
        movzx   edx,dx
        mov     esi,OFFSET GN_OffscreenAllocationsLock
        mov     edi,OFFSET GN_OffscreenAllocationsUnlock
        call    FFP16 PTR lpfnVddEntryPoint
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddSetPowerManagementCallbacks
;
; Purpose:      Send the address of the PowerOn and PowerOff
;               routines up to the miniVDD. When a power state will change
;               the miniVDD will call these routines respectively
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddSetPowerManagementCallbacks, PASCAL, FRAME, FAR16
OPENPROC
        PUSHR   ds,esi,edi
        mov     eax,VDD_REGISTER_DISPLAY_DRIVER_INFO
        mov     ebx,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        mov     ecx,MVDD_SET_POWER_MANAGEMENT_CALLBACKS
        mov     dx,SEG GN_PowerOn
        movzx   edx,dx
        mov     esi,OFFSET GN_PowerOn
        mov     edi,OFFSET GN_PowerOff
        call    FFP16 PTR lpfnVddEntryPoint
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddReenumerateDevNode
;
; Purpose:      Reenumerate the current DevNode.
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddReenumerateDevNode, PASCAL, FRAME, FAR16
PARMD   dwLogicalDevIndex
PARMD   dwCrtcHead
OPENPROC
        PUSHR   ds,esi,edi
        mov     eax,VDD_REGISTER_DISPLAY_DRIVER_INFO
        mov     ebx,cs:[dwThisLogicalDeviceHandle_In_NVTEXT16]
        mov     ecx,MVDD_REENUMERATE_DEVNODE
        mov     edx,dwCrtcHead
        mov     esi,dwLogicalDevIndex
        call    FFP16 PTR lpfnVddEntryPoint
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     GN_VddIsDriverAttachedToDesktop
;
; Purpose:      This routine determines if the display driver
;               is drivering a windows logical device that is
;               "attached to the desktop" -- i.e. is it enabled.
;               NOTE: If this is the primary driver, it is
;               always attached.
;
; Arguments:    ds      Context Selector
;               dwLogicalDeviceInstance
;
; Returns:      eax     0       not attached to the desktop
;                       non-0   is attached to the desktop
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC GN_VddIsDriverAttachedToDesktop, PASCAL, FRAME, FAR16
LOCALS  szPciSpec,80H
OPENPROC
        mov     eax,1
        cmp     dwThisLogicalDeviceHandle_In_NVTEXT16,1
        je      DoneIt

        ; Copy the Pci Specifier to a local stack location
        mov     eax,dwThisLogicalDeviceHandle_In_NVTEXT16
        and     eax,NOT 03H
        mov     ebx,ds:[eax + 4]
        sub     edx,edx
        sub     ecx,ecx
        lea     cx,szPciSpec
@@:
        mov     al,ds:[ebx][edx]
        mov     ss:[ecx][edx],al
        inc     edx
        or      al,al
        jne     @B

        mov     ax,ss
        shl     eax,10H
        lea     ax,szPciSpec
        push    eax

        mov     eax,dwThisLogicalDeviceHandle_In_NVTEXT16
        and     eax,03H
        push    eax
        call    FFP16 PTR cs:[lpfnIsDriverAttachedToDesktop]
        movzx   eax,ax
DoneIt:
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\INCLUDE\gndata.inc ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Copyright (C) 1998-1999, Nvidia Corporation
;
; File:         gndata.inc
;
; Purpose:      This file holds some data/structures/externs that
;               the generic code needs.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DibBlt, SetDIBitsToDevice, StretchDIBits 8 bpp h/w acceleration define.
; Set to 1 will turn on.
DIB_FAST_EXIT           TEXTEQU <1>
DIB_8BPP_ACCEL          TEXTEQU <1>
DIB_PROCESS_SINGLESCAN  TEXTEQU <1>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPENSEG  _DATA, USE16, DATA
EXTERNDEF       szUserModuleName:BYTE
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

; gnaccess.asm
EXTERNDEF       GENERIC_BeginAccess:FAR16
EXTERNDEF       GENERIC_EndAccess:FAR16

; gnblt.asm
NOROP   TEXTEQU <0>
OND     TEXTEQU <1>
PAD     TEXTEQU <2>
SAD     TEXTEQU <3>
PSD     TEXTEQU <4>
EXTERNDEF       GENERIC_BitBlt:FAR16
EXTERNDEF       Punt_BitBlt:NEAR
EXTERNDEF       GN_BitBltPatDstRop:NEAR
EXTERNDEF       GN_BitBltPatUnknownSrcUnknownDstVram:NEAR
EXTERNDEF       GN_BitBltSrcUnknownDstVram:NEAR
EXTERNDEF       GN_BitBltClipSrc:NEAR
EXTERNDEF       GN_BitBltSrcVramDstVram:NEAR
EXTERNDEF       GN_BitBltSrcMonoDstVram_1:NEAR
EXTERNDEF       GN_BitBltSrcColorDstVram_1:NEAR
EXTERNDEF       GN_BitBltSystemMemoryDst:NEAR
EXTERNDEF       GN_PrepareBrush:NEAR
EXTERNDEF       Rop3Table:BYTE

; gnbmpbts.asm
EXTERNDEF       GENERIC_BitmapBits:FAR16
EXTERNDEF       Punt_BitmapBits:NEAR
EXTERNDEF       GN_BitmapBitsSuccess:NEAR
EXTERNDEF       BitmapBits_Set:NEAR
EXTERNDEF       BitmapBits_SetWithFiller:NEAR
EXTERNDEF       BitmapBits_Get:NEAR
EXTERNDEF       BitmapBits_Copy:NEAR
EXTERNDEF       BitmapBits_CopyVramToVram:NEAR
EXTERNDEF       BitmapBits_CopySystemToVram:NEAR
EXTERNDEF       BitmapBits_CopyVramToSystem:NEAR
EXTERNDEF       BitmapBits_CopySystemToSystem:NEAR
EXTERNDEF       BitmapBits_CopyByScan:NEAR
EXTERNDEF       BitmapBits_CopyAll:NEAR

; gnclrinf.asm
EXTERNDEF       GENERIC_ColorInfo:FAR16

; gnclrblt.asm
EXTERNDEF       bTableBppToIndex:BYTE
EXTERNDEF       dwTableBppToXlatFunc:DWORD
; This needs to reflect how many entries per color depth are in the
; above table. Right now, we have routines for 1,4,8,15,16,24,32
; which is 7 different color depths. So MAX_BPP_INDICES should be 7.
MAX_BPP_INDICES TEXTEQU <7>
EXTERNDEF       GN_XferWholeColorScans:NEAR
EXTERNDEF       GN_XferPartialColorScans:NEAR
EXTERNDEF       GN_ConvertColorTableFrom32To16:NEAR

; gncp8.asm
EXTERNDEF       GN_Xfer1To8:NEAR
EXTERNDEF       GN_Xfer4To8WordXlat:NEAR
EXTERNDEF       GN_Xfer8To8NoXlat:NEAR
EXTERNDEF       GN_Xfer8To8ByteXlat:NEAR
EXTERNDEF       GN_Xfer8To8WordXlat:NEAR
EXTERNDEF       GN_Xfer15To8:NEAR
EXTERNDEF       GN_Xfer16To8:NEAR
EXTERNDEF       GN_Xfer24To8:NEAR
EXTERNDEF       GN_Xfer32To8:NEAR
EXTERNDEF       FindLMSPaletteIndex:NEAR

; gncp15.asm
EXTERNDEF       GN_Xfer4To15DwordXlat:NEAR
EXTERNDEF       GN_Xfer4To15WordXlat:NEAR
EXTERNDEF       GN_Xfer8To15WordXlat:NEAR
EXTERNDEF       GN_Xfer8To15DwordXlat:NEAR
EXTERNDEF       GN_Xfer15To15:NEAR
EXTERNDEF       GN_Xfer16To15:NEAR
EXTERNDEF       GN_Xfer24To15:NEAR
EXTERNDEF       GN_Xfer32To15:NEAR

; gncp16.asm
EXTERNDEF       GN_Xfer4To16DwordXlat:NEAR
EXTERNDEF       GN_Xfer4To16WordXlat:NEAR
EXTERNDEF       GN_Xfer8To16WordXlat:NEAR
EXTERNDEF       GN_Xfer8To16DwordXlat:NEAR
EXTERNDEF       GN_Xfer15To16:NEAR
EXTERNDEF       GN_Xfer16To16:NEAR
EXTERNDEF       GN_Xfer24To16:NEAR
EXTERNDEF       GN_Xfer32To16:NEAR

; gncp32.asm
EXTERNDEF       GN_Xfer4To32:NEAR
EXTERNDEF       GN_Xfer8To32:NEAR
EXTERNDEF       GN_Xfer15To32:NEAR
EXTERNDEF       GN_Xfer16To32:NEAR
EXTERNDEF       GN_Xfer24To32:NEAR
EXTERNDEF       GN_Xfer32To32:NEAR

; gncursor.asm
EXTERNDEF       GN_CreateCursorCache:FAR32
EXTERNDEF       GN_DestroyCursorCache:FAR32
EXTERNDEF       GN_ClearCursorCache:FAR32
EXTERNDEF       GN_ClearAllCursorCaches:FAR32
EXTERNDEF       GN_Convert8BppCursorTo32BppCursor:NEAR
EXTERNDEF       GENERIC_SetCursor:FAR16
EXTERNDEF       GN_CursorAction:NEAR
EXTERNDEF       GENERIC_MoveCursor:FAR16
EXTERNDEF       GENERIC_CheckCursor:FAR16
EXTERNDEF       GN_TurnCursorOffOrOn:FAR32
EXTERNDEF       GN_ResetSelectedCursor:FAR32

; gndibblt.asm
EXTERNDEF       GENERIC_DibBlt:FAR16
EXTERNDEF       Punt_DibBlt:NEAR
EXTERNDEF       GN_DibBltSuccess:NEAR
EXTERNDEF       GN_DibBltSetMono:NEAR
EXTERNDEF       GN_DibBltSetColor:NEAR
EXTERNDEF       GN_DibBltGet:NEAR
EXTERNDEF       GN_DibBltClip:NEAR

; gndibdev.asm
EXTERNDEF       GENERIC_SetDIBitsToDevice:FAR16
EXTERNDEF       Punt_DibToDevice:NEAR
EXTERNDEF       GN_DibDevExit:NEAR
EXTERNDEF       GN_SetMonoDibToDevice:NEAR
EXTERNDEF       GN_SetColorDibToDevice:NEAR
EXTERNDEF       GN_SetDIBitsToDeviceClip:NEAR
EXTERNDEF       GN_SetDIBitsSingleScan:NEAR

; gndibs.asm
EXTERNDEF       GN_DibSingleScan_Bpp8:NEAR
EXTERNDEF       GN_DibSingleScan_Bpp16:NEAR
EXTERNDEF       GN_DibSingleScan_Bpp32:NEAR

; gndibxit.asm
EXTERNDEF       GN_InitDibFastExit:FAR16
EXTERNDEF       bUseSetDIBitsFastExit:BYTE
EXTERNDEF       bUseStretchDIBitsFastExit:BYTE
EXTERNDEF       lpfnGdiCode03_2119:DWORD
EXTERNDEF       lpfnGdiCode03_20B7:DWORD
EXTERNDEF       GdiCode03_2119:FAR16
EXTERNDEF       GdiCode03_217C:FAR16

; gngamma.asm
EXTERNDEF       GENERIC_GammaRamp:FAR16

; gninit.asm
EXTERNDEF       wFlatDataSel:WORD
EXTERNDEF       CSlp16LogDevice:DWORD
EXTERNDEF       CSpGNLogicalDevice:DWORD

; gnline
;EXTERNDEF      GENERIC_Polyline:FAR16
EXTERNDEF       GN_PoylineNonSolid:NEAR
EXTERNDEF       Punt_Polyline:NEAR
EXTERNDEF       GN_PolylineSuccess:NEAR

; gnmem.asm
EXTERNDEF       GN_HeapCreate:FAR32
EXTERNDEF       GN_HeapInit:FAR32
EXTERNDEF       GN_HeapDestroy:FAR32
EXTERNDEF       GN_HeapAlloc:NEAR
EXTERNDEF       GN_HeapFree:NEAR

; gnmonblt.asm
EXTERNDEF       GN_BitBltSrcMonoDstVram:NEAR
EXTERNDEF       GN_XferWholeAlignedMonoScans:NEAR
EXTERNDEF       GN_XferWholeUnalignedMonoScans:NEAR
EXTERNDEF       GN_XferPartialAlignedMonoScans:NEAR
EXTERNDEF       GN_XferPartialUnalignedMonoScans:NEAR

; gnoffbmp.asm
EXTERNDEF       GN_ClearOffscreenBitmapCache:FAR32
EXTERNDEF       GN_OffscreenBitmapCreate:NEAR
EXTERNDEF       GN_OffscreenBitmapDelete:NEAR
EXTERNDEF       GN_OffscreenBitmapValidCheck:NEAR
EXTERNDEF       GN_FlushOffscreenBitmap:NEAR

; gnoutput.asm
EXTERNDEF       GENERIC_Output:FAR16
EXTERNDEF       Punt_Output:NEAR
;EXTERNDEF      GENERIC_Polygon:FAR16
;EXTERNDEF      GENERIC_Polyline:FAR16
;EXTERNDEF      GENERIC_PolyScanOrScanLine:FAR16

; gnpalet.asm
EXTERNDEF       GENERIC_SetPalette:FAR16
EXTERNDEF       GENERIC_SetPaletteTranslate:FAR16
EXTERNDEF       GENERIC_UpdateColors:FAR16
EXTERNDEF       GN_UpdateColorsExit:NEAR
EXTERNDEF       GN_UpdateColors:NEAR
EXTERNDEF       Punt_UpdateColors:NEAR

; gnpixel.asm
EXTERNDEF       GENERIC_Pixel:FAR16
EXTERNDEF       Punt_Pixel:NEAR
EXTERNDEF       GN_PixelDone:NEAR
EXTERNDEF       GN_SetPixel:NEAR
EXTERNDEF       GN_GetPixel:NEAR

; gnrect.asm
;EXTERNDEF      GENERIC_Rectangle:FAR16
EXTERNDEF       Punt_Rectangle:NEAR

; gnrobj.asm
EXTERNDEF       GENERIC_RealizeObject:FAR16
EXTERNDEF       GN_RealizeObjectExt:FAR16
EXTERNDEF       Punt_RealizeObjectExt:NEAR
EXTERNDEF       GN_RealizeObjectExtSuccess:NEAR
EXTERNDEF       GN_RealizeObjectExtDone:NEAR
EXTERNDEF       GN_RealizeObjectExtBrush:NEAR
EXTERNDEF       GN_RealizeObjectExtBitmap:NEAR
EXTERNDEF       GN_RealizeObjectExtDeleteBitmap:NEAR
EXTERNDEF       GN_RealizeObjectExtFont:NEAR
EXTERNDEF       GN_InitFunctionPtr:NEAR
EXTERNDEF       GN_LoadAndInitFonts:NEAR

; gnscan.asm
;EXTERNDEF      GENERIC_BeginScan:FAR16
;EXTERNDEF      GENERIC_EndScan:FAR16
;EXTERNDEF      GENERIC_PolyScanOrScanLine:FAR16
EXTERNDEF       Punt_BeginScan:NEAR
EXTERNDEF       Punt_Scan:NEAR
EXTERNDEF       Punt_EndScan:NEAR

; gnsdib.asm
EXTERNDEF       GENERIC_StretchDIBits:FAR16
EXTERNDEF       Punt_StrDib:NEAR
EXTERNDEF       GN_StrDibExit:NEAR
EXTERNDEF       GN_StretchMonoDib:NEAR
EXTERNDEF       GN_StretchColorDib:NEAR
EXTERNDEF       GN_StretchDIBitsClip:NEAR
EXTERNDEF       GN_StretchDIBitsSingleScan:NEAR

; gnssb.asm
EXTERNDEF       GN_ClearSaveScreenBitmapCache:FAR32
EXTERNDEF       SaveScreenBitmap:FAR16
EXTERNDEF       GENERIC_SaveScreenBitmap:FAR16
EXTERNDEF       GN_SaveScreenBitmapFail:NEAR
EXTERNDEF       GN_SaveScreenBitmapSuccess:NEAR
EXTERNDEF       GN_SaveScreenBitmapExit:NEAR
EXTERNDEF       SSB_SaveArea:NEAR
EXTERNDEF       SSB_RestoreOrDiscardArea:NEAR
EXTERNDEF       GN_SaveScreenBitmap:NEAR

; gnstrblt.asm
EXTERNDEF       GENERIC_StretchBlt:FAR16
EXTERNDEF       Punt_StrBlt:NEAR

; gnstub.asm
EXTERNDEF       GENERIC_GetCharWidth:FAR16
EXTERNDEF       GENERIC_DeviceBitmap:FAR16
EXTERNDEF       GENERIC_EnumDFonts:FAR16
EXTERNDEF       GENERIC_EnumObj:FAR16
EXTERNDEF       GENERIC_FastBorder:FAR16
EXTERNDEF       GENERIC_GetPalette:FAR16
EXTERNDEF       GENERIC_GetPaletteTranslate:FAR16
EXTERNDEF       GENERIC_Inquire:FAR16
EXTERNDEF       GENERIC_ScanLR:FAR16
EXTERNDEF       GENERIC_SetAttribute:FAR16
EXTERNDEF       GENERIC_StrBlt:FAR16

; gnsysblt.asm
EXTERNDEF       GN_BitBltSrcVramDstSystem:NEAR
EXTERNDEF       OurRopSetup:NEAR
EXTERNDEF       DibengRopSetup:NEAR

; gntext.asm
EXTERNDEF       GENERIC_ExtTextOut:FAR16
EXTERNDEF       Punt_ExtTextOut:NEAR
EXTERNDEF       GN_ExtTextOutRet:NEAR
EXTERNDEF       GN_ExtTextOutSuccess:NEAR
EXTERNDEF       GN_ExtTextOutExit:NEAR
EXTERNDEF       GlyphBltByteIndexWordTableIsKerning:NEAR
EXTERNDEF       GlyphBltWordIndexWordTableIsKerning:NEAR
EXTERNDEF       GlyphBltByteIndexWordTableNoKerning:NEAR
EXTERNDEF       GlyphBltWordIndexWordTableNoKerning:NEAR
EXTERNDEF       GlyphBltByteIndexDWordTableIsKerning:NEAR
EXTERNDEF       GlyphBltWordIndexDWordTableIsKerning:NEAR
EXTERNDEF       GlyphBltByteIndexDWordTableNoKerning:NEAR
EXTERNDEF       GlyphBltWordIndexDWordTableNoKerning:NEAR

; gnvdd.asm
EXTERNDEF       dwThisLogicalDeviceHandle:DWORD
CLOSESEG _NVTEXT32
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPENSEG  _NVTEXT16, USE16, CODE
; gnboard.asm
EXTERNDEF       GN_FindBoardContext:FAR16
EXTERNDEF       GN_CreateBoardContext:FAR16
EXTERNDEF       GN_DestroyBoardContext:FAR16
EXTERNDEF       GN_AttachLogicalDeviceToBoard:FAR16
EXTERNDEF       GN_ReattachLogicalDeviceToBoard:FAR16
EXTERNDEF       GN_DetachLogicalDeviceFromBoard:FAR16
EXTERNDEF       GN_GetPciDeviceID:FAR16
EXTERNDEF       GN_GetFrameBufferSelector:FAR16
EXTERNDEF       GN_GetNumCRTCs:FAR16
EXTERNDEF       GN_GetBoardRegistryPath:FAR16

; gnboard2.asm
EXTERNDEF       GN_BoardMessage:FAR16
EXTERNDEF       GN_FindFirstCloneDevice:FAR16
EXTERNDEF       GN_FindUnusedDevice:FAR16
EXTERNDEF       GN_SendDevicesRemapMsgToAllLogDevs:FAR16
EXTERNDEF       GN_FindLogdevWaitingToClone:FAR16
EXTERNDEF       GN_IsDevDataUniqueOnBoard:FAR16
EXTERNDEF       GN_GetAllDeviceData:FAR16
EXTERNDEF       GN_GetDevDataMask:FAR16

; gncntrl.asm
EXTERNDEF       GENERIC_Control:FAR16
EXTERNDEF       GN_ControlQuery:NEAR
EXTERNDEF       GN_ControlDDraw:NEAR
EXTERNDEF       GN_ControlDDrawNewCallbackFns:NEAR
EXTERNDEF       GN_ControlDDrawGet32BitDriverName:NEAR
EXTERNDEF       GN_ControlDDrawCreateDriverObject:NEAR
EXTERNDEF       GN_ControlDDrawDestroyDriverObject:NEAR
EXTERNDEF       GN_ControlDDrawDDVersionInfo:NEAR
EXTERNDEF       GN_MouseTrails:NEAR
EXTERNDEF       GN_ControlReturnPDevice:NEAR
EXTERNDEF       GN_ControlAllocSelectorAndMap:NEAR
EXTERNDEF       GN_ControlUnmapAndFreeSelector:NEAR
EXTERNDEF       GN_ControlSetCursor:NEAR
EXTERNDEF       GN_DvdMacrovisionCommand:NEAR
EXTERNDEF       GN_OpenGLGetInfo:NEAR
EXTERNDEF       GN_OpenGLCommand:NEAR
EXTERNDEF       GN_VideoParameters:NEAR
EXTERNDEF       GN_VpCommandGet:NEAR
EXTERNDEF       GN_VpCommandSet:NEAR
EXTERNDEF       GN_GetLocalRegistryPath:NEAR
EXTERNDEF       GN_GetRegistryModeList:NEAR

; gncrtc.asm
EXTERNDEF       GN_CreateCrtcContext:FAR16
EXTERNDEF       GN_DestroyCrtcContext:FAR16
EXTERNDEF       GN_SetLogicalCrtcInstance:FAR16
EXTERNDEF       GN_CrtcSetMonitorDevNode:FAR16
EXTERNDEF       GN_GetLargestEdidMode:FAR16
EXTERNDEF       GN_GetRefreshRateForDesktop:FAR16
EXTERNDEF       GN_DoOddballStuffAtBoot:FAR16
EXTERNDEF       GN_CheckAndMaybeReadEdid:FAR16
EXTERNDEF       GN_Far16GetModeSize:FAR16

; gncrtc2.asm
EXTERNDEF       GN_CrtcMessage:FAR16
EXTERNDEF       GN_RestoreCrtcState:FAR16
EXTERNDEF       GN_CrtcRemapArray:FAR16
EXTERNDEF       GN_RestoreAllCrtcStates:FAR16
EXTERNDEF       GN_CrtcDeviceHasBeenRemapped:FAR16
EXTERNDEF       GN_SetBytesPerPixelAndBytesPerLine:FAR16
EXTERNDEF       GN_SetPanRectangle:FAR16
EXTERNDEF       GN_GetDevData:FAR16
EXTERNDEF       GN_SetDevData:FAR16
EXTERNDEF       GN_AssignCrtcModeOnlyBackOffSpatial:FAR16
EXTERNDEF       GN_CrtcWriteModeToReg:FAR16
EXTERNDEF       GN_GetCrtcMode:FAR16
EXTERNDEF       GN_RestrictOtherModeSpatial:FAR16
EXTERNDEF       GN_RestrictCrtcModeSpatial:FAR16
EXTERNDEF       GN_SetCrtcMode:FAR16
EXTERNDEF       GN_GetDisplayDevice:FAR16
EXTERNDEF       GN_SetCrtcGamma:FAR16
EXTERNDEF       GN_GetCrtcGamma:FAR16
EXTERNDEF       GN_SetCrtcPalette:FAR16
EXTERNDEF       GN_ResetColorMap:FAR16

; gndisabl.asm
EXTERNDEF       GENERIC_Disable:FAR16
EXTERNDEF       GN_DisableDevice:NEAR
EXTERNDEF       GN_BlankScreen:NEAR

; gnenable.asm
EXTERNDEF       GENERIC_ReEnable:FAR16
EXTERNDEF       GENERIC_Enable:FAR16
EXTERNDEF       GN_EnableGdiInfo:NEAR
EXTERNDEF       GN_EnableDevice:NEAR
EXTERNDEF       GN_GetLogicalAndPhysicalModes:FAR16
EXTERNDEF       GN_SetLogicalAndPhysicalModes:FAR16
EXTERNDEF       GN_NoPrimarySurfaceRecovery:NEAR
EXTERNDEF       GN_DoFullStateChange:FAR16

; gngetid.asm
EXTERNDEF       GENERIC_GetDriverResourceID:FAR16

; gninit.asm
EXTERNDEF       wFlatDataSel_In_NVTEXT16:WORD
EXTERNDEF       CSlp16LogDevice_In_NVTEXT16:DWORD
EXTERNDEF       CSpGNLogicalDevice_In_NVTEXT16:DWORD
EXTERNDEF       lpfnFindModeEntry:DWORD
EXTERNDEF       lpfnFindVirtualModeEntry:DWORD
EXTERNDEF       lpfnGetModeList:DWORD
EXTERNDEF       lpfnGetDesktopModeList:DWORD
EXTERNDEF       lpfnSetVirtualDesktop:DWORD
EXTERNDEF       lpfnGetVirtualDesktop:DWORD
EXTERNDEF       lpfnSetDesktopState:DWORD
EXTERNDEF       lpfnGetDesktopState:DWORD
EXTERNDEF       lpfnSetAutoPanMode:DWORD
EXTERNDEF       lpfnGetAutoPanMode:DWORD
EXTERNDEF       lpfnSetTimingOverride:DWORD
EXTERNDEF       lpfnGetTimingOverride:DWORD
EXTERNDEF       lpfnGetBootDevice:DWORD
EXTERNDEF       lpfnGetLastDisplayFormat:DWORD
EXTERNDEF       lpfnGetDisplayDevice:DWORD
EXTERNDEF       lpfnSetDisplayDevice:DWORD
EXTERNDEF       lpfnGetRefreshRateForDesktop:DWORD
EXTERNDEF       lpfnGetForcedDesktopMode:DWORD
EXTERNDEF       lpfnGetLargestEdidMode:DWORD
EXTERNDEF       lpfnGetDeviceDesktopMode:DWORD
EXTERNDEF       lpfnSetDeviceDesktopMode:DWORD
EXTERNDEF       lpfnGetForcedDisplayMode:DWORD
EXTERNDEF       lpfnGetDeviceDisplayMode:DWORD
EXTERNDEF       lpfnSetDeviceDisplayMode:DWORD
EXTERNDEF       lpfnGetEdidRegistryKey:DWORD
EXTERNDEF       lpfnDeleteLocalRegEntry:DWORD
EXTERNDEF       lpfnResetRefreshRates:DWORD
EXTERNDEF       lpfnGetSafeTiming:DWORD
EXTERNDEF       lpfnSetResolutionAndColorDepth:DWORD
EXTERNDEF       lpfnGetControlVisionFlag:DWORD
EXTERNDEF       lpfnGetBootDeviceSelection:DWORD
EXTERNDEF       lpfnIsDriverAttachedToDesktop:DWORD
EXTERNDEF       lpfnGetAllowAllModesFlag:DWORD
EXTERNDEF       lpfnResetDisabledDeviceResolutions:DWORD
EXTERNDEF       lpfnGetAllowMightyModesFlag:DWORD
EXTERNDEF       lpfnGetCheckSXGAPanelFlag:DWORD
EXTERNDEF       lpfnGetClonePanningFlag:DWORD
EXTERNDEF       lpfnSetClonePanningFlag:DWORD
EXTERNDEF       lpfnFreeMasterLists:DWORD
EXTERNDEF       lpfnGetCloneDesktopSelection:DWORD
EXTERNDEF       lpfnGetRestrictLargestMode:DWORD
EXTERNDEF       lpfnGet1400x1050Override:DWORD
EXTERNDEF       lpfnGetMaxDfpMode:DWORD
EXTERNDEF       lpfnGetModesetStopImage:DWORD


EXTERNDEF       DllEntryPoint:FAR16
EXTERNDEF       GN_DllEntryPoint:FAR16
EXTERNDEF       GENERIC_WEP:FAR16
EXTERNDEF       WEP:FAR16
EXTERNDEF       GN_CreateConstants:FAR16
EXTERNDEF       GN_DestroyConstants:FAR16

; gnint2f.asm
EXTERNDEF       lpUserFullscreenDOSBoxFlag:DWORD

EXTERNDEF       GN_HookInt2F:FAR16
EXTERNDEF       GN_UnhookInt2F:FAR16
EXTERNDEF       Int2FHandler:FAR16
EXTERNDEF       Int2FSwitchingToWindows:FAR16
EXTERNDEF       Int2FSwitchingToDos:FAR16
EXTERNDEF       GENERIC_ResetHiresMode:FAR16
EXTERNDEF       GN_Int2FSwitchingToWindows:FAR16

; gnlogdev.asm
EXTERNDEF       GN_CreateLogdevContext:FAR16
EXTERNDEF       GN_DestroyLogdevContext:FAR16
EXTERNDEF       GN_SetGdiInfoPtr:FAR16
EXTERNDEF       GN_LogdevAttachCrtc:FAR16
EXTERNDEF       GN_LogdevDetachCrtc:FAR16
EXTERNDEF       GN_LogdevAddAClone:FAR16

; gnlogdev2.asm
EXTERNDEF       GN_LogdevMessage:FAR16
EXTERNDEF       GN_OffscreenHeapDisappearing:FAR16
EXTERNDEF       GN_ResolveDeviceConnectionsOnLoad:FAR16
EXTERNDEF       GN_ResolveDeviceConnectionsOnUnload:FAR16

; gnoffmgr.asm
EXTERNDEF       GN_ControlOffscreenAllocations:FAR16
EXTERNDEF       GN_OffscreenAllocationsLock:FAR16
EXTERNDEF       GN_OffscreenAllocationsUnlock:FAR16

; gnpanel.asm
EXTERNDEF       ControlPanelInterface:NEAR
EXTERNDEF       NV_SetGet_State:NEAR
EXTERNDEF       NV_SetGet_Device_Type:NEAR
EXTERNDEF       NV_SetDisplayDeviceType:NEAR
EXTERNDEF       NV_GetDisplayDeviceType:NEAR
EXTERNDEF       NV_SetGet_Autopan:NEAR
EXTERNDEF       NV_SetGet_VirtualMode:NEAR
EXTERNDEF       NV_SetGet_PhysicalMode:NEAR
EXTERNDEF       NV_SetGet_PhysicalModeImmediate:NEAR
EXTERNDEF       NV_ValidateVirtualMode:NEAR
EXTERNDEF       NV_ValidatePhysicalMode:NEAR
EXTERNDEF       NV_SetGet_Freeze_Origin:NEAR
EXTERNDEF       NV_SetGet_PanOffset:NEAR
EXTERNDEF       NV_SetGet_Primary_Crtc:NEAR
EXTERNDEF       GN_MapHeadToGNLogdev:FAR16

; gnpower.asm
EXTERNDEF       GN_PowerOn:FAR16
EXTERNDEF       GN_PowerOff:FAR16
EXTERNDEF       GN_VddSetPowerManagementCallbacks:FAR16

; gnrepnt
EXTERNDEF       GN_InitUserRepaint:FAR16
EXTERNDEF       GENERIC_UserRepaintDisable:FAR16
EXTERNDEF       GN_UserRepaint:FAR16
EXTERNDEF       GN_IssueUserRepaint:NEAR
EXTERNDEF       GN_CheckUserRepaint:FAR16

; gnthk16.asm
EXTERNDEF       wLog:WORD
EXTERNDEF       Patch_BitBlt:FAR16
EXTERNDEF       SetCursor:FAR16
EXTERNDEF       MoveCursor:FAR16
EXTERNDEF       SetPalette:FAR16
EXTERNDEF       Patch_BitmapBits:FAR16
EXTERNDEF       Control:FAR16
EXTERNDEF       Patch_ExtTextOut:FAR16
EXTERNDEF       Patch_DibBlt:FAR16
EXTERNDEF       FastBorder:FAR16
EXTERNDEF       Patch_Output:FAR16
EXTERNDEF       Patch_Pixel:FAR16
EXTERNDEF       RealizeObject:FAR16
EXTERNDEF       ReEnable:FAR16
EXTERNDEF       Patch_RealizeObject:FAR16
EXTERNDEF       Patch_ScanLR:FAR16
EXTERNDEF       Patch_SetDIBitsToDevice:FAR16
EXTERNDEF       Patch_SetPalette:FAR16
EXTERNDEF       SetPaletteTranslate:FAR16
EXTERNDEF       Patch_StrBlt:FAR16
EXTERNDEF       Patch_StretchBlt:FAR16
EXTERNDEF       Patch_StretchDIBits:FAR16
EXTERNDEF       Patch_SaveScreenBitmap:FAR16
EXTERNDEF       Patch_UpdateColors:FAR16
EXTERNDEF       GENERIC_OutputDebugString:FAR16

; gnvalmod
EXTERNDEF       ValidateMode:FAR16
EXTERNDEF       GENERIC_ValidateMode:FAR16
EXTERNDEF       GN_ValidatePhysicalMode:FAR16
EXTERNDEF       GN_GetFreeBlockSizeForMode:FAR16
EXTERNDEF       GN_CheckForMultipleOf8Mode:FAR16

; gnvdd.asm
EXTERNDEF       lpfnVddEntryPoint:DWORD
EXTERNDEF       dwThisLogicalDeviceHandle_In_NVTEXT16:DWORD
EXTERNDEF       GN_VddGetEntryPoint:FAR16
EXTERNDEF       GN_VddGetDeviceHandle:FAR16
EXTERNDEF       GN_VddEnableDevice:FAR16
EXTERNDEF       GN_VddCloseDevice:FAR16
EXTERNDEF       GN_VddGetDisplayInfo:FAR16
EXTERNDEF       GN_VddDriverRegister:FAR16
EXTERNDEF       GN_VddDriverUnregister:FAR16
EXTERNDEF       GN_VddRegisterDisplayDriver:FAR16
EXTERNDEF       GN_VddSaveDriverState:FAR16
EXTERNDEF       GN_VddEnableIOTrapping:FAR16
EXTERNDEF       GN_VddSetLockAndUnlockOffscreen:FAR16
EXTERNDEF       GN_VddReenumerateDevNode:FAR16
EXTERNDEF       GN_VddDriverRegister:FAR16
EXTERNDEF       GN_VddSaveDriverState:FAR16
EXTERNDEF       GN_VddEnableIOTrapping:FAR16
EXTERNDEF       GN_VddGetDisplayInfo:FAR16
EXTERNDEF       GN_VddIsDriverAttachedToDesktop:FAR16

;  gnwrap.asm
EXTERNDEF       BitBlt_WithExclude:FAR16
EXTERNDEF       Pixel_WithExclude:FAR16
EXTERNDEF       ScanLR_WithExclude:FAR16
EXTERNDEF       ExtTextOut_WithExclude:FAR16
EXTERNDEF       SetDIBitsToDevice_WithExclude:FAR16
EXTERNDEF       UpdateColors_WithExclude:FAR16
EXTERNDEF       StretchBlt_WithExclude:FAR16
EXTERNDEF       StretchDIBits_WithExclude:FAR16
EXTERNDEF       SaveScreenBitmap_WithExclude:FAR16
EXTERNDEF       Output_WithExclude:FAR16
EXTERNDEF       GN_TurnExcludeOffOrOn:FAR16
CLOSESEG _NVTEXT16
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; DIBENG exports
EXTERNDEF       DIB_BeginAccess:FAR16
EXTERNDEF       DIB_EndAccess:FAR16
EXTERNDEF       DIB_BitBlt:FAR16
EXTERNDEF       DIB_BitmapBits:FAR16
EXTERNDEF       DIB_ColorInfo:FAR16
EXTERNDEF       DIB_Control:FAR16
EXTERNDEF       DIB_DibBltExt:FAR16
EXTERNDEF       DIB_Disable:FAR16
EXTERNDEF       DIB_Enable:FAR16
EXTERNDEF       DIB_EnumObjExt:FAR16
EXTERNDEF       DIB_ExtTextOut:FAR16
EXTERNDEF       DIB_GetCharWidth:FAR16
EXTERNDEF       DIB_GetPaletteExt:FAR16
EXTERNDEF       DIB_GetPaletteTranslateExt:FAR16
EXTERNDEF       DIB_Inquire:FAR16
EXTERNDEF       DIB_Output:FAR16
EXTERNDEF       DIB_Pixel:FAR16
EXTERNDEF       DIB_RealizeObjectExt:FAR16
EXTERNDEF       DIB_ScanLR:FAR16
EXTERNDEF       DIB_DibToDevice:FAR16
EXTERNDEF       DIB_SetPaletteExt:FAR16
EXTERNDEF       DIB_SetPaletteTranslateExt:FAR16
EXTERNDEF       DIB_StrBlt:FAR16
EXTERNDEF       DIB_StretchBlt:FAR16
EXTERNDEF       DIB_StretchDIBits:FAR16
EXTERNDEF       DIB_UpdateColorsExt:FAR16
EXTERNDEF       DIB_SetCursorExt:FAR16
EXTERNDEF       DIB_MoveCursorExt:FAR16
EXTERNDEF       DIB_CheckCursorExt:FAR16
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\INCLUDE\GNCRTC.h ===
/*=============================================================================

    Copyright (C) 1997, NVidia Coporation

    File:       gncrtc.h

    Purpose:    This file holds structures and equates dealing with the
                GNCRTCCX.

=============================================================================*/

typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;

#define MAX_DISPDATA_SIZE                   96
#define MAX_EDID_BUFFER_SIZE                512
#define MAX_MODEINFO_SIZE                   48
#define MAX_MODEOUT_SIZE                    40
#define MIN_TICKS_BEFORE_REREADING_EDID     40

///////////////////////////////////////////////////////////////////////
#define XOR_DATA_SIZE   ((CURSOR_WIDTH * CURSOR_HEIGHT) * 4)

typedef struct  _CURSOREXTRA
{
    ULONG       dwCursorType;       // This is for H/W specific code
    ULONG       dwCursorHash;       // This is for generic code
}   CURSOREXTRA;

typedef struct  _CURSORDESCEX
{
    CURSOREXTRA ExtraData;
    USHORT      wHotX;
    USHORT      wHotY;
    USHORT      wWidth;
    USHORT      wHeight;
    USHORT      wWidthBytes;
    UCHAR       bPlanes;
    UCHAR       bBitsPerPixel;
    UCHAR       bCursorAndMask[AND_MASK_SIZE];
    UCHAR       bCursorXorData[XOR_DATA_SIZE];
}   CURSORDESCEX;

//  This structure is immediately followed by some number of
//  CURSORDESC structures which hold all the cached cursor desciptions.
typedef struct  _CURSORCACHE
{
    ULONG       dwCursorFlags;
    USHORT      wCursorX;
    USHORT      wCursorY;
    ULONG       dwNextCacheSlot;
    ULONG       dwSelectedCacheSlot;
}   CURSORCACHE;

// These flags are for the dwCursorFlags field in the CURSORCACHE structure
// The interrupt handler which changes cursor settings will only look at
// the low 3 bits if the CURSOR_IS_NULL bit is not set.

#define CURSOR_HAS_TRAILS       0x0001
#define CURSOR_MOVE             0x0002
#define CURSOR_SELECT           0x0004
#define CURSOR_IS_NULL          0x0008
#define CURSOR_SEMAPHORE        0x0010
#define CURSOR_IS_SOFTWARE      0x0020
#define CURSOR_SEMAPHORE_BIT    4

// Bits 8 through 31 are the 'SETTING' bits. They indicate that SetCursor
// was called with a cursor pattern, but the pattern has not yet been
// supplied to the hardware. Bit n set means that the cursor corresponding
// to Cache slot n-8 needs to be placed in the hardware's cache. This is
// done to allow for lazy setting of cursor shapes. The CURSOR_SET bit
// is a global SETTING bit to indicate at least one of bits 8 - 31 is set.
#define NUM_CURSOR_FLAGS        8
#define MAX_CACHEABLE_CURSORS   (32 - NUM_CURSOR_FLAGS)

#if (MAX_CACHEABLE_CURSORS > (32 - NUM_CURSOR_FLAGS))
    error
#endif
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// ;;;;; The Generic CRTC Instance Specific portion of the DEVICE ;;;;;;;;
typedef struct  _GNCRTCCX
{
    // 1 means we are initting. Cleared to 0 on first mode set.
    ULONG           dwInitting;

    // This GNCRTCCX is tied to the following board.
    ULONG           pGNBoardCX;

    // The HW specific crtc context data ptr
    ULONG           pHWCrtcCX;

    // For VideoMirror modes, the Video module issues an Escape to
    // "LOCK" the hw crtccx. What this means is that the GNCRTCCX
    // no longer controls the HW CRTC. To implement this, we NULL
    // out the pHWCrtcCX ptr above. In order that we can still
    // make some hwcrtc calls (just to get state information and
    // maybe do macrovision), we keep a copy of what the HWCRTCCX
    // was in the field below.
    ULONG           pHWCrtcCXWhenLocked;

    // This gives the windows logical device number considering this
    /// board as 0 based. So in normal and clone mode, this will be 0.
    // In multi-mon mode, this number is 0 or 1 (for a 2 head board.)
    ULONG           dwLogicalDeviceInstance;

    // This is a number from 0 to the number of physical devices - 1
    // as an ordinal. It tells which physical device number this is
    // that is attached to the logical device in the prior variable.
    // So for normal and multi-mon mode this will be a 0. For clone
    // mode, you can have several physical devices attached to a
    // given logical device. This would tell which one it is.
    ULONG           dwPhysicalDeviceInstance;

    // This is true if this is the primary CRTC.
    ULONG           dwBootCrtc;

    // This is the registry path that this CRTC will be using as
    // the local monitor base path -- the place in the registry
    // where values specific to the monitor are stored. It may not,
    // however, always be valid since the user can plug new monitors
    // in on the fly. Basically it tells the last .inf that was
    // installed, or the EDID monitor that was seen at boot.
    ULONG           lpLocalMonitorBasePath;
    UCHAR           szLocalMonitorBasePath[128];

    // There is some data in the DISPDATA structure that is specific
    // to each CRTC.
    ULONG           lpBoardRegistryData;
    ULONG           lpNvmodeDispData;
    ULONG           sNvmodeDispData[(MAX_DISPDATA_SIZE + 3) / 4];
    ULONG           lpCrtcModeOut;
    ULONG           sCrtcModeOut[(MAX_MODEOUT_SIZE + 3) / 4];

    // Save the Edid buffer so we don't have to reread all the time.
    ULONG           lpEdidBuffer;
    UCHAR           sEdidBuffer[MAX_EDID_BUFFER_SIZE];
    ULONG           dwEdidSize;

    // Don't want to read the EDID too often because if a monitor
    // doesn't have an EDID, the timeouts take a long time.
    ULONG           dwTicksSinceLastEdidRead;

    // Tells how many bits per color gun the hardware supports for this CRTC
    ULONG           dwBitsPerColorChannel;

    // Tells how many cached cursor slots the hardware has allowed.
    ULONG           dwMaxCacheableCursors;

    // When changing the display device, we ask Windows to recompute
    // the .inf status by reenumerating the attached display devices.
    // Unfortunately, this is asyncronous, and so the modeset that
    // occurs when changing display devices will not give a valid
    // .inf status. This flag tells us to ignore the status
    ULONG           dwDisplayDeviceChange;

    // Our cursor cache for this CRTC
    ULONG           pCursorCache;

    // A flag to indicate whether pan and scan is enabled and also
    // the coordinates of the monitor viewport on the desktop.
    // Enough additional stuff to fully specify the mode.
    ULONG           dwPanAndScanEnabled;
    MYRECTL         rcPhysicalViewport;
    ULONG           dwBytesPerPixelInCurrentMode;
    ULONG           dwBytesPerLineInCurrentMode;
    UCHAR           sCrtcModeInfo[MAX_MODEINFO_SIZE];
    ULONG           lpCrtcModeInfo;

    // The LOGDEV needs one copy of these for each CRTC
    ULONG           dwPaletteTable[256];
    ULONG           dwGammaTable[256];
}   GNCRTCCX;
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVAPI\INCLUDE\GNLOGDEV.H ===
/*=============================================================================

    Copyright (C) 1997, NVidia Coporation

    File:       gnlogdev.h

    Purpose:    This file holds structures and equates dealing with the
                pdevice.

=============================================================================*/

typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;

#define MAX_DISP_CONFIG 80

// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// ;;;;;;;;;;;;;;;;;;;  A DEVICE BITMAP HEADER  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
// This structure must have a DIBENGINEHDR as the first field. After that,
// anything is fine.
typedef struct  _DEVBMP
{
    DIBENGINEHDR    Dibeng;
    USHORT          wLeft;
    USHORT          wTop;
    USHORT          wRight;
    USHORT          wBottom;
}   DEVBMP;

#define MAX_SSBS    3
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// ;;;;;;;;;;;;;;;;;;;;;  The PHYSICAL DEVICE ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

typedef struct  _GNLOGDEVCX
{
    // This must go first
    DIBENGINEHDR    Dibeng;

    // Tells us if we are initting or not. This is cleared after
    // the second enable call (the one that inits the PPDEVICE.
    ULONG       dwInitting;

    // The GNBOARDCX that is attached to this GNLOGDEV
    ULONG       pGNBoardCX;

    // Which GNLOGDEV instance this is on the board (0, 1, 2, ...)
    ULONG       dwLogicalDeviceInstanceOnThisBoard;

    // How many CRTCs are attached to this logical device
    ULONG       dwNumCRTCsAttachedToThisLogicalDevice;

    // The number of clone devices that this logical device is
    // waiting for. Generally a logical device is waiting for a
    // clone if a clone device got stolen from it at one point
    // in time. As the stolen CRTCCXs get freed, they will be
    // restored when they become available again.
    ULONG       dwNumClonesAwaited;

    // How many CRTCs are on this board
    ULONG       dwTotalCRTCsOnBoard;

    // Do we allow desktops larger than a CRTC will set?
    ULONG       dwVirtualDesktopEnabled;

    // Is this an Nvidia Control Panel SetMode?
    ULONG       lpBoardRegistryData;

    // This variable holds the number of bytes of video memory needed
    // by the primary surface. For safety sake, because we can set
    // low res DX modes, this will never be less than the amount of
    // memory required for a 640x480x8 screen even if the actual
    // display is smaller.
    ULONG       dwMemorySizeForPrimarySurface;

    // OK, this is a bit ugly. We keep the two code segments we are
    // using in the driver in here.
    ULONG       dw16BitCodeSegment;
    ULONG       dw32BitCodeSegment;

    // There can be a number of GNCRTCCXs attached to this GNLOGDEVCX.
    ULONG       pGNCrtcCX[MAX_ATTACHED_CRTCS];

    // How about the hw logdevice data
    ULONG       pHWLogdevCX;

    // Keep a ptr to the GDI info for this PDEVICE.
    ULONG       lpGdiInfo;

    // If the hardware uses a 5-6-5 format for 16bpp, then set this
    // field to FIVE6FIVE. If the hardware uses 1-5-5-5 format, then
    // set this field to 0.
    ULONG       dw16BppFormat;      // FIVE6FIVE or 0 (which means 5-5-5)
    ULONG       dwFontFormat;        // C1_BIT_PACKED or C1_BYTE_PACKED

    // Here is where we crate pseudo bitmap headers for
    // save-screen offscreen bitmaps.
    DEVBMP      SaveScreenBitmapCache[MAX_SSBS];

    // These are for handling a Windows bug having to do with
    // Screen repaints coming back from a DOS box.
    ULONG       dwCheckCursorCount;
    ULONG       dwGraphicsTimeStamp;
    ULONG       lpfnUserRepaint;

    // This flag indiactes that device(s) has been remapped.
    ULONG       dwDeviceHasBeenRemapped;

    //--------------- Begin byte alignment!!! ------------
    UCHAR       bRepaintDisable;
    UCHAR       bRepaintPending;
    UCHAR       bUserRepaintCallCount;
    UCHAR       bRepaintIssued;

    // Scanline and Polyscanline stuff
    UCHAR       bInScanSequence;
    UCHAR       bHollowBrushForScan;
    UCHAR       bPuntingScan;

    UCHAR       bDirectXActive;

    UCHAR       bInterlacedStereo;
    UCHAR       bSetModeBypass;
    UCHAR       bReserved1;
    UCHAR       bReserved2;
    //---------------   End byte alignment!!!  ------------

    // Macrovision Support
    ULONG       dwMacrovisionNavigatorID;
    ULONG       dwCurrentMacrovisionKey;
    ULONG       dwNextMacrovisionKey;
    ULONG       dwMacrovisionMode;

    // This flag indiactes that the hardware should not be touched.
    ULONG       dwHardwareBusy;

    // fInt2FScreenSwitchOut is used to indicate we have received
    // a ScreenSwitchOut but not a screenSwitchIn.
    ULONG       dwInt2FScreenSwitchOut;

    // This is used to store some black-box control panel data
    ULONG       dwCplData;

    // dwCurrentLine is used as the last address for GN_RollerToolEscape
    ULONG       dwCurrentLine;

    // This memory block will be used for the hotkey display switch
    // escape. We save off the state information for the state that
    // the hotkey handler wants us to switch to on the next Enable.
    // We don't know the exact size in here, but there is a sizecheck
    // in the file that references this data structure, so that the
    // build will break if it is not big enough.
    ULONG       sDispConfig[MAX_DISP_CONFIG];
    ULONG       dwDisplayConfigPending;
    ULONG       dwNvDisplayChangePending;
    ULONG       dwBeginDisplayChangeIssued;

    // This will temporarily hold the xres,yres that Windows wants
    // us to change to. In multimon, Windows will truncate our
    // mode heights so that they are a multiple of 8. Hence, we
    // have to play a few games with the mode they ask us to
    // set and the mode that we validate against our table.
    USHORT      wWindowsXRes;
    USHORT      wWindowsYRes;

    DIBHEADER   bmi;
    ULONG       dwPalette[256];
    UCHAR       bPaletteXlatTable[256];
    UCHAR       bPaletteInverseXlatTable[256];
}   GNLOGDEVCX;
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVRES\CODE\FONTS.ASM ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

	title	High Resolution Font Definitions
	%out	fonts
	page	,132




OEM	segment public


;	OEM Font Description

OEMFixed	dw	12		;lfheight
		dw	8		;lfwidth
		dw	0		;lfescapement
		dw	0		;character orientation
		dw	0		;weight
		db	0		;Italic
		db	0		;underline
		db	0		;strikeout
		db	255		;charset
		db	0		;output precision
		db	2		;clip precision
		db	2		;quality
		db	1		;pitch
		db	'Terminal',0	;face

;	Ansi Fixed Font Description

AnsiFixed	dw	12		;lfheight
		dw	9		;lfwidth
		dw	0		;lfescapement
		dw	0		;character orientation
		dw	0		;weight
		db	0		;Italic
		db	0		;underline
		db	0		;strikeout
		db	0		;charset
		db	0		;output precision
		db	2		;clip precision
		db	2		;quality
		db	1		;pitch
		db	'Courier',0	;face

;	Ansi Variable Pitch Font Definition

AnsiVar 	dw	12		;lfheight
		dw	9		;lfwidth
		dw	0		;lfescapement
		dw	0		;character orientation
		dw	0		;weight
		db	0		;Italic
		db	0		;underline
		db	0		;strikeout
		db	0		;charset
		db	0		;output precision
		db	2		;clip precision
		db	2		;quality
		db	2		;pitch
		db	'Helv',0	;face


OEM	ends
end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVRES\CODE\COLORTAB.ASM ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

        title   Control Panel Color Table
	%out	config
	page	,132


RGB     macro   R, G, B
        db      R,G,B,0
	endm



COLORTABLE  segment public

        dw  48                  ; # colors in table
        RGB 0FFh,080h,080h
        RGB 0FFh,0FFh,0E8h
        RGB 080h,0FFh,080h
        RGB 000h,0FFh,080h
        RGB 080h,0FFh,0FFh
        RGB 000h,080h,0FFh
        RGB 0FFh,080h,0C0h
        RGB 0FFh,080h,0FFh
        RGB 0FFh,000h,000h
        RGB 0FFh,0FFh,080h
        RGB 080h,0FFh,000h
        RGB 000h,0FFh,040h
        RGB 000h,0FFh,0FFh
        RGB 000h,080h,0C0h
        RGB 080h,080h,0C0h
        RGB 0FFh,000h,0FFh
        RGB 080h,040h,040h
        RGB 0FFh,0FFh,000h
;       RGB 0FFh,080h,040h
        RGB 000h,0FFh,000h
        RGB 000h,080h,080h
        RGB 000h,040h,080h
        RGB 080h,080h,0FFh
        RGB 080h,000h,040h
        RGB 0FFh,000h,080h
        RGB 080h,000h,000h
        RGB 0FFh,080h,000h
        RGB 000h,080h,000h
        RGB 000h,080h,040h
        RGB 000h,000h,0FFh
        RGB 000h,000h,0A0h
        RGB 080h,000h,080h
        RGB 080h,000h,0FFh
        RGB 040h,000h,000h
        RGB 080h,040h,000h
        RGB 000h,040h,000h
        RGB 000h,040h,040h
        RGB 000h,000h,080h
        RGB 000h,000h,040h
        RGB 040h,000h,040h
        RGB 040h,000h,080h
        RGB 000h,000h,000h
        RGB 080h,080h,000h
        RGB 080h,080h,040h
        RGB 080h,080h,080h
        RGB 040h,080h,080h
        RGB 0C0h,0C0h,0C0h
        RGB 082h,082h,082h
        RGB 0FFh,0FFh,0FFh
COLORTABLE     ends
end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVRES\CODE\FONTS120.ASM ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

        title   High Resolution Font Definitions
        %out    fonts
        page    ,132


        FONT_WIDTH      equ     10
        FONT_HEIGHT     equ     20


OEM     segment public


;       OEM Font Description

OEMFixed        dw      FONT_HEIGHT     ;lfheight
                dw      FONT_WIDTH      ;lfwidth
                dw      0               ;lfescapement
                dw      0               ;character orientation
                dw      0               ;weight
                db      0               ;Italic
                db      0               ;underline
                db      0               ;strikeout
                db      255             ;charset
                db      0               ;output precision
                db      2               ;clip precision
                db      2               ;quality
                db      1               ;pitch
                db      'Terminal',0    ;face

;       Ansi Fixed Font Description

AnsiFixed       dw      12              ;lfheight
                dw      9               ;lfwidth
                dw      0               ;lfescapement
                dw      0               ;character orientation
                dw      0               ;weight
                db      0               ;Italic
                db      0               ;underline
                db      0               ;strikeout
                db      0               ;charset
                db      0               ;output precision
                db      2               ;clip precision
                db      2               ;quality
                db      1               ;pitch
                db      'Courier',0     ;face

;       Ansi Variable Pitch Font Definition

AnsiVar         dw      12              ;lfheight
                dw      9               ;lfwidth
                dw      0               ;lfescapement
                dw      0               ;character orientation
                dw      0               ;weight
                db      0               ;Italic
                db      0               ;underline
                db      0               ;strikeout
                db      0               ;charset
                db      0               ;output precision
                db      2               ;clip precision
                db      2               ;quality
                db      2               ;pitch
                db      'Helv',0        ;face



OEM     ends
end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWACCESS.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwaccess.asm
;
; Purpose:      This file implements the BeginAccess Functions and
;               functions for creating and deleting offscreen bitmaps.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include hwmacs.inc
include gngdi.inc
include hwgdi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     HW_GetGraphicsTimeStamp
;
; Purpose:      This function returns should return a value that is
;               some measure of graphics activity time. The DMA buffer
;               ptr is good since it increases with increasing graphics
;               activity (except when it is reset to the start of the
;               buffer, but I'll ignore that for now.)
;
; Arguments:
;               ds                      CXSel
;               pHWLogdevCXOffset       HWLOGDEVCX ptr
;
; Returns:
;               eax     A graphics time stamp
;
; Preserve:     All registers except eax
;==============================================================================
DECPROC HW_GetGraphicsTimeStamp, PASCAL, FRAME, NEAR
PARMD   pHWLogdevCXOffset
OPENPROC
        mov     eax,pHWLogdevCXOffset
        mov     eax,ds:[eax].HWLOGDEVCX.pHWBoardCX
        mov     eax,ds:[eax].HWBOARDCX.pCurrentPushBufferOffset
CLOSEPROC

CLOSESEG _NVTEXT16

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     HW_BeginAccess
;
; Purpose:      This function should wait until all hardware contexts
;               are idle before returning. It is probably being called
;               so that the CPU can access the frame buffer directly
;               so wait for idle here to preserve order of operations.
;
; Arguments:
;               ds 	CXSel
;               esi     HWLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     All registers
;==============================================================================
DECPROC HW_BeginAccess, PASCAL, NOFRAME, NEAR
OPENPROC
	PUSHR	eax,ecx

        mov     eax,ds:[esi].HWLOGDEVCX.pHWBoardCX
        mov	ecx,ds:[eax].HWBOARDCX.dwGdiDriverChannelID
        cmp	ecx,ds:[eax].HWBOARDCX.dwCurrentChannelID
        jne	SyncOtherChannels

	; If we are still idle from the last sync, then don't sync again
        mov     ecx,ds:[eax].HWBOARDCX.pCurrentPushBufferOffset
        cmp     ecx,ds:[eax].HWBOARDCX.dwGetOffsetAtLastBeginAccess
        jne     SyncThisChannel

Done:
	STOPPROC
	POPR	eax,ecx
	ret

SyncThisChannel:
        PUSHR   alld

	; set edi = HWBOARDCX and edi = PushBufferOffset
        mov	esi,eax
	mov	edi,ecx

        CHECKDMASPACE ds,esi,edi,10H
        SETDMASTATUS <ds:[esi].HWBOARDCX.sPushBufferNotifier.status>
        mov     eax,CHNRUN(ContextClipRect.Notify,1)
        mov     ecx,NV019_NOTIFY_WRITE_ONLY
        mov     edx,CHNRUN(ContextClipRect.NoOperation,1)
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        mov     ds:[edi + 08H],edx
        mov     ds:[edi + 0CH],esi
        add     edi,10H

        ; Cyrix reorders cached reads ahead of uncached writes. If we
        ; don't execute a serializing instruction, we might spin on the
        ; notifier preventing the command from getting out to the chip.
        xchg    eax,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        SETPUTPTR ds,esi,edi

        ; Now wait until the notify is complete
        WAITDMASTATUS <ds:[esi].HWBOARDCX.sPushBufferNotifier.status>

        ; Remember the last "synced" get offset. People that want to
        ; write the frame buffer directly can compare the
        ; dwCurrentPushBufferOffset with this value. If they are the
        ; same then, there is no need to issue another sync.
        mov     ds:[esi].HWBOARDCX.dwGetOffsetAtLastBeginAccess,edi
        POPR    alld
	jmp	Done

SyncOtherChannels:
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,eax,ecx
	jmp	Done
CLOSEPROC

;==============================================================================
DECPROC HW_BeginAccess_Far32, PASCAL, NOFRAME, FAR32
OPENPROC
	call	HW_BeginAccess
CLOSEPROC

;==============================================================================
;
; Function:     HW_EndAccess
;
; Purpose:      This is the hardware specific EndAccess routine.
;               There is probably nothing you need to do here,
;               but it is called after the CPU is done touching
;               the display so if you need to put the hardware
;               back in "bltter" mode, do so now.
;
; Arguments:
;               ds              Context Selector
;               ebx             HWBOARDCX ptr
;
; Returns:      None
;
; Preserve:     All registers
;==============================================================================
DECPROC HW_EndAccess, PASCAL, NOFRAME, NEAR
OPENPROC
CLOSEPROC

IF	(HW_WAIT NE 0)
;==============================================================================
;
; Function:     WaitUntilGdiContextIdle
;
; Purpose:      This function should wait until all hardware contexts
;               are idle before returning. It is probably being called
;               so that the CPU can access the frame buffer directly
;               so wait for idle here to preserve order of operations.
;
; Arguments:
;               pHWBoardCXOffset
;
; Returns:      None
;
; Preserve:     All registers
;==============================================================================
DECPROC WaitUntilGdiContextIdle, PASCAL, FRAME, NEAR
PARMD   pHWBoardCXOffset
OPENPROC
	PUSHR	ds,alld

        mov     ds,cs:[wFlatDataSel]
        mov     eax,pHWBoardCXOffset

	; If we are still idle from the last sync, then don't sync again
        mov     ecx,ds:[eax].HWBOARDCX.pCurrentPushBufferOffset
        cmp     ecx,ds:[eax].HWBOARDCX.dwGetOffsetAtLastBeginAccess
        je	Done

	; set edi = HWBOARDCX and edi = PushBufferOffset
        mov	esi,eax
	mov	edi,ecx

        CHECKDMASPACE ds,esi,edi,10H
        SETDMASTATUS <ds:[esi].HWBOARDCX.sPushBufferNotifier.status>
        mov     eax,CHNRUN(ContextClipRect.Notify,1)
        mov     ecx,NV019_NOTIFY_WRITE_ONLY
        mov     edx,CHNRUN(ContextClipRect.NoOperation,1)
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        mov     ds:[edi + 08H],edx
        mov     ds:[edi + 0CH],esi
        add     edi,10H

        ; Cyrix reorders cached reads ahead of uncached writes. If we
        ; don't execute a serializing instruction, we might spin on the
        ; notifier preventing the command from getting out to the chip.
        xchg    eax,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        SETPUTPTR ds,esi,edi

        ; Now wait until the notify is complete
        WAITDMASTATUS <ds:[esi].HWBOARDCX.sPushBufferNotifier.status>

IFDEF DEBUG;!!
	;;Trap for MMIO corruption
        mov     eax,ds:[esi].HWBOARDCX.pDmaChannel
	sub	eax,0F0000H
	;;Read RM objects data
	mov	ebx,ds:[eax+50H]
	or	ebx,ebx
	jz	@F
        mov     ecx,ds:[esi].HWBOARDCX.dwGetOffsetAtLastBeginAccess
	int	3
@@:
ENDIF
        ; Remember the last "synced" get offset. People that want to
        ; write the frame buffer directly can compare the
        ; dwCurrentPushBufferOffset with this value. If they are the
        ; same then, there is no need to issue another sync.
        mov     ds:[esi].HWBOARDCX.dwGetOffsetAtLastBeginAccess,edi

Done:
	POPR	ds,alld
CLOSEPROC
ENDIF


;==============================================================================
;
; Function:     HW_CreateOffscreenBitmap
;
; Purpose:      This function is called by the generic code when it wants
;               to create an offscreen bitmap. You need to do two things
;               in here:
;               1) If the hardware cannot accept any bitmap from 1x1 up
;                  to 32K pixels by 32K pixels then check the bitmap size
;                  and succeed or fail appropriately.
;               2) If you accept the creation, fill in the
;                  ds:[esi].DIBENGINE.deDeltaScan field with the pitch
;                  you wish for the bitmap.
;
; Arguments:
;               ds              Context Selector
;               ebx             HWBOARDCX ptr
;               es:edi          ptr to DEVBMP.
;                               The fields below are valid:
;               deWidth
;               deHeight
;               deWidthBytes
;               dePlanes
;               deBitsPixel
;               delpPDevice
;
; Returns:      eax     0       Do not place this bitmap in offscreen
;                       non-0   OK to put the bitmap in offscreen
;                               In this case you should also fill in
;                               ds:[esi].DIBENGINE.deDeltaScan with
;                               the desired bitmap pitch. The pitch
;                               must be a multiple of 4, but your
;                               hardware may have other restrictions
;                               as well.
;
; Preserve:     ds,esi,edi,es
;               Do not destroy any other fields in the DEVBMP or PDEVICE
;==============================================================================
DECPROC HW_CreateOffscreenBitmap, PASCAL, NOFRAME, NEAR
OPENPROC
        movzx   eax,es:[edi].DIBENGINE.deWidthBytes
        mov     ecx,ds:[ebx].HWBOARDCX.dwMinContextSurface2dPitch
        dec     ecx
        add     eax,ecx
        not     ecx
        and     eax,ecx
        mov     es:[edi].DIBENGINE.deDeltaScan,eax
        dec     eax
        sub     eax,ds:[ebx].HWBOARDCX.dwMaxContextSurface2dPitch
        sbb     eax,eax
CLOSEPROC


;==============================================================================
;
; Function:     HW_DeleteOffscreenBitmap
;
; Purpose:      This routine is called when an offscreen bitmap is being
;               deleted. The hardware specific code can do anything it
;               needs to. Typically, you will need to check to see if
;               the current active bitmap has been set to the one being
;               deleted and set the active base and pitch in the chip
;               to, say, -1. Another bitmap may be allocated at the
;               same address with a different pitch and unless the
;               base and pitch get reset properly, things could get
;               drawn incorrectly.
;
; Arguments:
;               ds              Context Selector
;               ebx             HWBOARDCX ptr
;               eax		DIBENGINEHDR.deBitsOffset
;
; Returns:      None
;
; Preserve:     ds,esi,edi,es
;==============================================================================
DECPROC HW_DeleteOffscreenBitmap, PASCAL, NOFRAME, NEAR
OPENPROC
        cmp     eax,ds:[ebx].HWBOARDCX.dwContextSurface2dSrcOffset
        jne     @F
        mov     ds:[ebx].HWBOARDCX.dwContextSurface2dSrcOffset,0FFFF0000h
@@:
        cmp     eax,ds:[ebx].HWBOARDCX.dwContextSurface2dDstOffset
        jne     @F
        mov     ds:[ebx].HWBOARDCX.dwContextSurface2dDstOffset,0FFFF0000h
@@:
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\DRVRES\CODE\CONFIG.ASM ===
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

	title	Hardware Dependent Parameters
	%out	config
	page	,132


RGB     macro   R, G, B
        db      R,G,B,0
	endm



OEM	segment public

;	Machine dependent parameters

        dw      17                      ;Height of vertical thumb
        dw      17                      ;Width of horizontal thumb
	dw	2			;Icon horiz compression factor
	dw	2			;Icon vert compression factor
; Notes on the cursor compression factors:
;       Cursor size = int(32 / compression factor)
;       i.e. 1 = 32 pixels, 2 = 16, 3 = 10, 4 = 8, 5 = 6, 6 = 5, 7 = 4, 8 = 4, ... 32 = 1
;       DO NOT USE 0 - Windows98 will shut down immediately (divide by 0 probably...)
;       64 will give you a single 32x32 cursor
;       -1 gives NO cursor - always calls SetCursor with NULL
	dw	1			;Cursor horz compression factor
	dw	1			;Cursor vert compression factor
	dw	0			;Kanji window height
	dw	1			;cxBorder (thickness of vertical lines)
	dw	1			;cyBorder (thickness of horizontal lines)

;	Default system color values

        RGB 192,192,192     ;clrScrollbar
        RGB 192,192,192     ;clrDesktop
        RGB 000,000,128     ;clrActiveCaption
        RGB 255,255,255     ;clrInactiveCaption
        RGB 255,255,255     ;clrMenu
        RGB 255,255,255     ;clrWindow
        RGB 000,000,000     ;clrWindowFrame
        RGB 000,000,000     ;clrMenuText
        RGB 000,000,000     ;clrWindowText
        RGB 255,255,255     ;clrCaptionText
        RGB 192,192,192     ;clrActiveBorder
        RGB 192,192,192     ;clrInactiveBorder
        RGB 255,255,255     ;clrAppWorkspace
        RGB 000,000,128     ;clrHiliteBk
        RGB 255,255,255     ;clrHiliteText
        RGB 192,192,192     ;clrBtnFace
        RGB 128,128,128     ;clrBtnShadow
        RGB 192,192,192     ;clrGrayText
        RGB 000,000,000     ;clrBtnText


;	dw	0			;Unused words
;	dw	0
;	dw	0
;	dw	0
;	dw	0
;	dw	0
	dw	0
	dw	0

OEM	ends
end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWBOARD2.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwboard2.asm
;
; Purpose:      This file contains all the hardware specific BOARD
;               routines for run-time. The board specific init
;               routines are in hwboard.asm.
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gngdi.inc
include hwgdi.inc
include files.inc
include nvcm.inc
include nvreg.inc
include hwmacs.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include nvos.inc
include modeext.inc
include ..\..\..\..\..\sdk\nvidia\inc\nvrmarch.inc
include ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     HW_BoardMessage
;
; Purpose:      This routine gets called whenver there is an
;               message to send to all objects. There are
;               a few different messages.  See gngdi.inc
;               for details.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwMessage               which message
;               dwData1                 additional data that depends
;                                       upon the message type
;               dwData2                 additional data that depends
;                                       upon the message type
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_BoardMessage, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwMessage
PARMD   dwData1
PARMD   dwData2
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        mov     eax,dwMessage
        cmp     eax,MSG_PREMODESET
        je      PreMS
        cmp     eax,MSG_POSTMODESET
        je      PostMS
        cmp     eax,MSG_DIRECTX_ENUM
        je      DXEnum
        cmp     eax,MSG_DIRECTXON
        je      DXOn
        cmp     eax,MSG_DIRECTXOFF
        je      DXOff
        cmp     eax,MSG_DOSON
        je      DosOn
        cmp     eax,MSG_DOSOFF
        je      DosOff
        cmp     eax,MSG_POWERON
        je      PowerOn
        cmp     eax,MSG_POWEROFF
        je      PowerOff
        cmp     eax,MSG_DISABLE
        je      DrvDis
        jmp     DoneIt

PreMS:
        ; OpenGL mode switch count must be changed to an odd
        ; number before setting the mode.
        add     ds:[esi].HWBOARDCX.dwModeSwitchCount,2
        or      ds:[esi].HWBOARDCX.dwModeSwitchCount,1

        ; Wait until everyone goes idle
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,esi,eax

        ; JKTODO - Talk to the RM guys about getting rid of this.
        ; We can't possibly need it.  One thing that happens right
        ; now is that if the RM sees this call come before a heap
        ; allocation, then they treat the heap as an NV11 type heap
        ; where nothing goes away on a modeset. But I'm sure we can
        ; work out some better strategy than using this call.
        push    esi
        call    Enable_HiRes
        jmp     DoneIt

PostMS:
        ; Sync with other channels
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,esi,eax

        ; Reset the two offsets and pitches
        mov     eax,ds:[esi].HWBOARDCX.dwMinContextSurface2dPitch
        imul    eax,10001H
        mov     ds:[esi].HWBOARDCX.dwContextSurface2dDstSrcPitch,eax
        mov     eax,0FFFF0000h
        mov     ds:[esi].HWBOARDCX.dwContextSurface2dSrcOffset,eax
        mov     ds:[esi].HWBOARDCX.dwContextSurface2dDstOffset,eax
        push    esi
        push    eax
        mov     ebx,dwData1
        push    ds:[ebx].DIBENGINEHDR.deDeltaScan
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        call    SetDstBaseAndPitchToDsEdi
        SETPUTPTR ds,esi,edi

        ; OpenGL mode switch should be bumped to next even number
        add     ds:[esi].HWBOARDCX.dwModeSwitchCount,2
        and     ds:[esi].HWBOARDCX.dwModeSwitchCount,-2

        ; We are no longer initting after the first modeset
        mov     ds:[esi].HWBOARDCX.dwInitting,0
        jmp     DoneIt

DXEnum:
DXOn:
DXOff:
        jmp     DoneIt

DosOff:
PowerOn:
        push    esi
        call    Enable_HiRes

        add     ds:[esi].HWBOARDCX.dwModeSwitchCount,2
        and     ds:[esi].HWBOARDCX.dwModeSwitchCount,-2
        jmp     DoneIt

DosOn:
PowerOff:
        push    esi
        call    Enable_VGA

        ; OpenGL mode switch count must be changed to an odd
        ; number before setting the mode or while in DOS or POWERDOWN.
        add     ds:[esi].HWBOARDCX.dwModeSwitchCount,2
        or      ds:[esi].HWBOARDCX.dwModeSwitchCount,1
        jmp     DoneIt

DrvDis:
        ; Always enable VGA mode for the boards with single head.
        cmp     ds:[esi].HWBOARDCX.dwNumCRTCsOnBoard,1
        je      @F

        ; Check for the secondary device to prevent FIFO disable.
        ; dwData2 = dwThisLogicalDeviceHandle.
        cmp     dwData2,1
        je      @F
        test    dwData2, 03H
        jnz     DoneIt

@@:
        ; OpenGL mode switch count must be changed to an odd
        ; number before setting the mode or while in DOS.
        add     ds:[esi].HWBOARDCX.dwModeSwitchCount,2
        or      ds:[esi].HWBOARDCX.dwModeSwitchCount,1

        push    esi
        call    Enable_VGA
        jmp     DoneIt

DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     Enable_HiRes
;
; Purpose:      This routine calls the ResMan to disable VGA (enable hires)
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC Enable_HiRes, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
OPENPROC
        PUSHR   esi,edi

        ; Tell RM to disable VGA
        pushd   0
        mov     eax,pHWBoardCXOffset
        push    ds:[eax].HWBOARDCX.dwDeviceNum
        call    FFP16 PTR lpfnNvConfigVga

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     Enable_VGA
;
; Purpose:      This routine calls the ResMan to enable VGA (disable hires)
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC Enable_VGA, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
OPENPROC
        PUSHR   esi,edi

        ; Tell RM to enable VGA
        pushd   1
        mov     eax,pHWBoardCXOffset
        push    ds:[eax].HWBOARDCX.dwDeviceNum
        call    FFP16 PTR lpfnNvConfigVga

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetLargestOffscreenBlock
;
; Purpose:      This routine returns the size in bytes of the
;               largest contiguous offscreen block.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:
;               eax     length in bytes of offscreen block
;               ebx     offset in bytes of offscreen block
;
;               eax can be 0 if there is no offscreen memory
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetLargestOffscreenBlock, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
LOCALV  heapParams,NVIOCONTROL_PARAM
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        mov     eax,ds:[esi].HWBOARDCX.dwRootHandle
        mov     heapParams.NVIOCONTROL_hRoot,eax
        mov     heapParams.NVIOCONTROL_hObjectParent,NV_WIN_DEVICE
        mov     heapParams.NVIOCONTROL_owner,GDI2D_HEAP_OWNER
        mov     heapParams.NVIOCONTROL_function,NVIOCONTROL_HEAP_INFO

        pushd   NVIOCONTROL_ARCH_HEAP
        mov     ax,ss
        push    ax
        lea     ax,heapParams
        push    ax
        call    FFP16 PTR lpfnNvIoControl

        ; Return the correct things
        ; The size field is the size of the largest linearly
        ; contguous free block.
        mov     eax,heapParams.NVIOCONTROL_size
        mov     ebx,heapParams.NVIOCONTROL_offset
        POPR    esi
CLOSEPROC

;==============================================================================
;
; Function:     HW_GetLargestOffscreenSpace
;
; Purpose:      This routine returns the size in bytes of the
;               largest TWO contiguous offscreen spaces assuming
;		that the allocations at offset1 and offset2 are
;		free (note, the offset1 and offset2 allocations
;		are NOT freed, but the contiguous block sizes
;		returned are what they would be IF THE TWO
;		offets were freed.)
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               offset1                 framebuffer offset or -1
;               offset2                 offscreen heap offset or -1
;
; Returns:
;               eax     length of largest contiguous offscreen
;			block in bytes. (can be 0, if none available)
;               eax     length of second largest contiguous offscreen
;			block in bytes. (can be 0, if none available)
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetLargestOffscreenSpace, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   offset1
PARMD   offset2
LOCALV  heapParams,NVIOCONTROL_PARAM
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        mov     eax,ds:[esi].HWBOARDCX.dwRootHandle
        mov     heapParams.NVIOCONTROL_hRoot,eax
        mov     heapParams.NVIOCONTROL_hObjectParent,NV_WIN_DEVICE
        mov     heapParams.NVIOCONTROL_owner,GDI2D_HEAP_OWNER
        mov     heapParams.NVIOCONTROL_function,NVIOCONTROL_HEAP_INFO_FREE_BLOCKS
        mov     eax,offset1
        mov     heapParams.NVIOCONTROL_offset,eax
        mov     eax,offset2
        mov     heapParams.NVIOCONTROL_limit,eax

        pushd   NVIOCONTROL_ARCH_HEAP
        mov     ax,ss
        push    ax
        lea     ax,heapParams
        push    ax
        call    FFP16 PTR lpfnNvIoControl

        ; Return the correct things
        ; The size field is the size of the largest linearly
        ; contguous free block.
        mov     eax,heapParams.NVIOCONTROL_size
        sub	ebx,ebx
        POPR    esi
CLOSEPROC

;==============================================================================
;
; Function:     HW_AllocOffscreenBlock
;
; Purpose:      This routine allocates a block of offscreen
;               memory the size requested.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwSizeInBytesToAlloc
;
; Returns:
;               eax     offset into video memory of start of offscreen block
;               ebx     length in bytes of offscreen block
;
;               eax can be 0 if there isn't a contguous block
;               of the size requested.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_AllocOffscreenBlock, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwSizeInBytesToAlloc
OPENPROC
        push    pHWBoardCXOffset
        pushd   NVIOCONTROL_HEAP_ALLOC_SIZE
        pushd   GDI2D_HEAP_OWNER
        pushd   NVIOCONTROL_TYPE_IMAGE
        push    dwSizeInBytesToAlloc
        call    NV_OffscreenHeapAlloc
CLOSEPROC


;==============================================================================
;
; Function:     HW_FreeOffscreenBlock
;
; Purpose:      This routine frees a block of offscreen memory
;               that was allocated via HW_AllocOffscreenBlock.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwOffsetToBlockStart
;
; Returns:
;               None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_FreeOffscreenBlock, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwOffsetToBlockStart
OPENPROC
        ; Comment to avoid assembler error.
        push    pHWBoardCXOffset
        pushd   GDI2D_HEAP_OWNER
        push    dwOffsetToBlockStart
        call    NV_OffscreenHeapFree
CLOSEPROC



;==============================================================================
;
; Function:     HW_OffscreenHeapPurge
;
; Purpose:      This function purges the offscreen heap of all
;               allocations whose owner is GDI2D_HEAP_OWNER.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_OffscreenHeapPurge, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
OPENPROC
        push    pHWBoardCXOffset
        pushd   GDI2D_HEAP_OWNER
        call    NV_OffscreenHeapPurge
CLOSEPROC


DX_HEAP_ID      TEXTEQU <'NVDX'>
;==============================================================================
;
; Function:     HW_DxHeapPurge
;
; Purpose:      This function purges the offscreen heap of all
;               allocations whose owner is DX_HEAP_ID.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_DxHeapPurge, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
OPENPROC
        push    pHWBoardCXOffset
        pushd   DX_HEAP_ID
        call    NV_OffscreenHeapPurge
CLOSEPROC


;==============================================================================
;
; Function:     HW_HeapPurgeAllExceptPrimarySurface
;
; Purpose:      This routine purges everything except for a non-NVRM primary
;               surface.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_HeapPurgeAllExceptPrimarySurface, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
LOCALV  heapParams,NVIOCONTROL_PARAM
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        mov     eax,ds:[esi].HWBOARDCX.dwRootHandle
        mov     heapParams.NVIOCONTROL_hRoot,eax
        mov     heapParams.NVIOCONTROL_hObjectParent,NV_WIN_DEVICE
        mov     heapParams.NVIOCONTROL_owner,GDI2D_HEAP_OWNER
        mov     heapParams.NVIOCONTROL_function,NVOS11_HEAP_DESTROY

        pushd   NVIOCONTROL_ARCH_HEAP
        mov     ax,ss
        push    ax
        lea     ax,heapParams
        push    ax
        call    FFP16 PTR lpfnNvIoControl

        ; Now that everything is purged, we need to realloc 'NVBD'.
        call    NV_AllocRequiredMemory

        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_AllocPrimarySurface
;
; Purpose:      This routine allocates a block of offscreen
;               memory for a primary surface.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwSizeInBytesToAlloc
;
; Returns:
;               eax     offset into video memory of start of offscreen block
;                       (-1 if failure)
;               ebx     length in bytes of offscreen block
;
;
;               This routine really can't fail. Do whatever
;               you can to make it succeed.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_AllocPrimarySurface, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwPitch
PARMD   dwHeight
PARMD   dwCRTCIndex
LOCALV  heapParams,NVIOCONTROL_PARAM
OPENPROC
        push    pHWBoardCXOffset
        pushd   NVIOCONTROL_HEAP_ALLOC_TILED_PITCH_HEIGHT
        pushd   GDI2D_DESKTOP_OWNER
        mov     eax,dwCRTCIndex
        shl     eax,31
        or      eax,NVIOCONTROL_TYPE_PRIMARY
        push    eax
        mov     eax,dwHeight
        shl     eax,10H
        mov     ax,word ptr dwPitch
        push    eax
        call    NV_OffscreenHeapAlloc
CLOSEPROC


;==============================================================================
;
; Function:     HW_FreePrimarySurface
;
; Purpose:      This routine frees a block of offscreen
;               memory that is used as an offscreen surface.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwOffsetToBlockStart    vram offset to start of block to free
;
; Returns:
;               None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_FreePrimarySurface, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwOffsetToBlockStart
OPENPROC
        push    pHWBoardCXOffset
        pushd   GDI2D_DESKTOP_OWNER
        push    dwOffsetToBlockStart
        call    NV_OffscreenHeapFree
CLOSEPROC


;==============================================================================
;
; Function:     HW_PrimarySurfaceHeapPurge
;
; Purpose:      This routine purges all primary surface allocations
;               from video memory.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_PrimarySurfaceHeapPurge, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
LOCALV  heapParams,NVIOCONTROL_PARAM
OPENPROC
        push    pHWBoardCXOffset
        pushd   GDI2D_DESKTOP_OWNER
        call    NV_OffscreenHeapPurge
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetPciDeviceID
;
; Purpose:      This function gets the PCI Device ID for this board.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:
;               eax                     PCI Device ID
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetPciDeviceID, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset
        pushd   NV_CFG_PCI_ID
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        call    FFP16 PTR lpfnNvConfigGet
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetFrameBufferSelector
;
; Purpose:      This function gets the frame buffer selector.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:
;               eax                     frame buffer selector
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetFrameBufferSelector, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset
        mov     eax,ds:[esi].HWBOARDCX.dwVideoMemorySel
        POPR    esi
CLOSEPROC

;==============================================================================
;
; Function:     HW_GetModeDimensions
;
; Purpose:      This function gets the pitch and the amount of memory
;               used for the mode specified.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwXResolution           Xresolution of mode
;               dwYResolution           Yresolution of mode
;               dwBitsPerPixel          Bits Per Pixel of mode
;
; Returns:      eax             Pitch in bytes for the mode
;               ebx             Total amount of memory in bytes for the mode
;                               (including tiling)
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetModeDimensions, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwXResolution
PARMD   dwYResolution
PARMD   dwBitsPerPixel
LOCALV  Params,NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS
OPENPROC

        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        ; Get the parameters for NV_CFGEX_GET_SURFACE_PITCH from stack.
        mov     eax,dwXResolution
        mov     Params.dwWidth,eax
        mov     eax,dwYResolution
        mov     Params.Height,eax
        mov     eax,dwBitsPerPixel
        mov     Params.Depth,eax
        mov     ax,ss
        shl     eax,10H
        lea     ax,Params
        mov     ebx,SIZE NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS
        mov     ecx,NV_CFGEX_GET_SURFACE_DIMENSIONS
        call    NV_ConfigExCall

        ; Return pitch in DX:AX
        mov     eax,Params.Pitch
        mov     ebx,Params.dwSize

		cmp		ds:[esi].HWBOARDCX.dwStereoConnectionType, INTERLACED_STEREO
		jnz		@F
		shl		eax, 1
		shl		ebx, 1
@@:

        POPR    esi

CLOSEPROC


;==============================================================================
;
; Function:     HW_GetNumCRTCs
;
; Purpose:      This routine returns the number of CRTCs on the
;               board.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:      eax     Num total CRTCs on the board
;               ebx     number of available CRTCs
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetNumCRTCs, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset
        mov     ecx,ds:[esi].HWBOARDCX.dwNumCRTCsOnBoard
        mov     eax,1
        sub     ebx,ebx
Back1:
        test    eax,ds:[esi].HWBOARDCX.dwCRTCsAllocatedFlags
        jnz     @F
        inc     ebx
@@:     shl     eax,1
        dec     ecx
        jne     Back1

        mov     eax,ds:[esi].HWBOARDCX.dwNumCRTCsOnBoard
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     NV_ConfigExCall
;
; Purpose:      This function returns TRUE if the monitor is connected
;               and FALSE if it is not.
;
; Arguments:
;               ds:esi  HWBOARDCX
;               eax     16:16 ptr to particular EX structure
;               ebx     size of particular ex structure in bytes
;               ecx     index of EX function
;
; Returns:      eax     status
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_ConfigExCall, PASCAL, FRAME, FAR32
LOCALV  sExGetParams,NVOS_CONFIG_GET_EX_PARAMS
OPENPROC
        ; Get client
        mov     sExGetParams.paramSize,ebx
        mov     sExGetParams.index,ecx
        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     sExGetParams.hClient,ecx
        mov     ecx,ds:[esi].HWBOARDCX.dwhDevice
        mov     sExGetParams.hDevice,ecx

        ; Get flat ptr to EX structure
        push    eax
        shr     eax,10H
        push    eax
        call    GN_GetSelectorBase
        pop     ebx
        and     ebx,0FFFFh
        add     eax,ebx
        mov     sExGetParams.paramStructPtr,eax

        ; Call ConfigGetEx
        mov     ax,ss
        shl     eax,10H
        lea     ax,sExGetParams
        push    eax
        call    FFP16 PTR lpfnArch_Nv04ConfigGetEx

        mov     eax,sExGetParams.status
CLOSEPROC

;==============================================================================
;
; Function:     NV_ConfigExSetCall
;
; Purpose:      This function returns TRUE if the monitor is connected
;               and FALSE if it is not.
;
; Arguments:
;               ds:esi  HWBOARDCX
;               eax     16:16 ptr to particular EX structure
;               ebx     size of particular ex structure in bytes
;               ecx     index of EX function
;
; Returns:      eax     status
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_ConfigExSetCall, PASCAL, FRAME, FAR32
LOCALV  sExSetParams,NVOS_CONFIG_SET_EX_PARAMS
OPENPROC
        ; Get client
        mov     sExSetParams.paramSize,ebx
        mov     sExSetParams.index,ecx
        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     sExSetParams.hClient,ecx
        mov     ecx,ds:[esi].HWBOARDCX.dwhDevice
        mov     sExSetParams.hDevice,ecx

        ; Get flat ptr to EX structure
        push    eax
        shr     eax,10H
        push    eax
        call    GN_GetSelectorBase
        pop     ebx
        and     ebx,0FFFFh
        add     eax,ebx
        mov     sExSetParams.paramStructPtr,eax

        ; Call ConfigSetEx
        mov     ax,ss
        shl     eax,10H
        lea     ax,sExSetParams
        push    eax
        call    FFP16 PTR lpfnArch_Nv04ConfigSetEx

        mov     eax,sExSetParams.status
CLOSEPROC


;==============================================================================
;
; Function:     NV_OffscreenHeapAlloc
;
; Purpose:      This function allocates from the offscreen heap.
;
; Arguments:
;       ds                      Context Selector
;       pHWBoardCXOffset        HWBOARDCX ptr
;       dwFunction              what type of allocation
;                               like NVIOCONTROL_HEAP_ALLOC_SIZE or
;       dwOwnerID               ID you want for the owner
;       dwAllocType             heapParams.type value
;                               Like:  NVIOCONTROL_TYPE_CURSOR, etc.
;       dwSizeInBytes           if type is NVIOCONTROL_HEAP_ALLOC_SIZE,
;                               then this is num bytes for allocation
;                               if type is NVIOCONTROL_TYPE_PRIMARY
;                               then high word is height and low
;                               word is pitch in bytes
;
; Returns:      eax     video memory offset to allocation
;               ebx     size of allocation (may be bigger than requested)
;               ecx     number of free bytes left in the heap
;
;               If the allocation fails, then eax = -1.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_OffscreenHeapAlloc, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwFunction
PARMD   dwOwnerID
PARMD   dwAllocType
PARMD   dwSizeInBytes
LOCALV  heapParams,NVIOCONTROL_PARAM
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        mov     eax,dwFunction
        mov     heapParams.NVIOCONTROL_function,eax
        mov     eax,ds:[esi].HWBOARDCX.dwRootHandle
        mov     heapParams.NVIOCONTROL_hRoot,eax
        mov     eax,ds:[esi].HWBOARDCX.dwhDevice
        mov     heapParams.NVIOCONTROL_hObjectParent,eax
        mov     eax,dwOwnerID
        mov     heapParams.NVIOCONTROL_owner,eax
        mov     ebx,dwAllocType
        mov     heapParams.NVIOCONTROL_type,ebx
        mov     ecx,dwSizeInBytes
        mov     heapParams.NVIOCONTROL_size,ecx
        cmp     dwFunction,NVIOCONTROL_HEAP_ALLOC_SIZE
        je      @F
        movzx   eax,cx
        shr     ecx,10H
        mov     heapParams.NVIOCONTROL_pitch,eax
        mov     heapParams.NVIOCONTROL_height,ecx
@@:
        pushd   NVIOCONTROL_ARCH_HEAP
        mov     ax,ss
        push    ax
        lea     ax,heapParams
        push    ax
        call    FFP16 PTR lpfnNvIoControl

        mov     eax,-1
        cmp     heapParams.NVIOCONTROL_status,NVIOCONTROL_STATUS_SUCCESS
        jne     Done

        ; Return the correct things
        mov     eax,heapParams.NVIOCONTROL_offset
        mov     ebx,heapParams.NVIOCONTROL_limit
        inc     ebx
        mov     ecx,heapParams.NVIOCONTROL_free
Done:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     NV_OffscreenHeapFree
;
; Purpose:      This routine frees a block of offscreen memory
;               that was allocated via HW_AllocOffscreenBlock.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwOwnerID               ID you want for the owner
;               dwOffsetToBlockStart
;
; Returns:
;               None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_OffscreenHeapFree, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwOwnerID
PARMD   dwOffsetToBlockStart
LOCALV  heapParams,NVIOCONTROL_PARAM
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     heapParams.NVIOCONTROL_hRoot,ecx
        mov     eax,ds:[esi].HWBOARDCX.dwhDevice
        mov     heapParams.NVIOCONTROL_hObjectParent,eax
        mov     heapParams.NVIOCONTROL_function,NVIOCONTROL_HEAP_FREE
        mov     eax,dwOwnerID
        mov     heapParams.NVIOCONTROL_owner,eax
        mov     eax,dwOffsetToBlockStart
        mov     heapParams.NVIOCONTROL_offset,eax
        pushd   NVIOCONTROL_ARCH_HEAP
        mov     ax,ss
        push    ax
        lea     ax,heapParams
        push    ax
        call    FFP16 PTR lpfnNvIoControl

        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     NV_OffscreenHeapPurge
;
; Purpose:      This routine purges all primary surface allocations
;               from video memory.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwOwnerID               Owner ID of allocations to purge
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_OffscreenHeapPurge, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwOwnerID
LOCALV  heapParams,NVIOCONTROL_PARAM
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        pushd   NVIOCONTROL_ARCH_HEAP
        mov     cx,ss
        push    cx
        lea     cx,heapParams
        push    cx
        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     heapParams.NVIOCONTROL_hRoot,ecx
        mov     eax,ds:[esi].HWBOARDCX.dwhDevice
        mov     heapParams.NVIOCONTROL_hObjectParent,eax
        mov     eax,dwOwnerID
        mov     heapParams.NVIOCONTROL_owner,eax
        mov     heapParams.NVIOCONTROL_function,NVIOCONTROL_HEAP_PURGE
        call    FFP16 PTR lpfnNvIoControl

        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetAllAttachedDevices
;
; Purpose:      This routine returns a mask that describes all attached
;               devices.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:
;               eax             bits 7:0   indicate if CRTC #X is attached
;                               bits 15:8  indicate if TV   #X is attached
;                               bits 23:16 indicate if DFP  #X is attached
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetAllAttachedDevices, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
LOCALD  dwAllDevices
OPENPROC
        PUSHR   esi

        ; First get all the device ports
        mov     esi,pHWBoardCXOffset
        pushd   NV_CFG_GET_ALL_DEVICES
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        call    FFP16 PTR lpfnNvConfigGet
        shl     edx,10H
        mov     dx,ax
        mov     dwAllDevices,edx

        ; OK, it is. Find out if the device is connected
        mov     ax,ss
        shl     eax,10H
        lea     ax,dwAllDevices
        mov     ebx,4
        mov     ecx,NV_CFGEX_CHECK_CONNECTED_DEVICES
        call    NV_ConfigExCall

        mov     eax,dwAllDevices
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_IsDeviceAttached
;
; Purpose:      This routine determines if the specified device is
;               attached.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwDevData               low byte:       0 - CRT
;                                                       1 - TV
;                                                       2 - DFP
;                                       next byte:      0-7 for device number
;
; Returns:
;               eax                     TRUE, the device is attached
;                                       FALSE is is not
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_IsDeviceAttached, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwDevData
LOCALD  dwDeviceToCheck
OPENPROC
        PUSHR   esi

        ; First get all the device ports
        mov     esi,pHWBoardCXOffset
        pushd   NV_CFG_GET_ALL_DEVICES
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        call    FFP16 PTR lpfnNvConfigGet
        shl     edx,10H
        mov     dx,ax
        mov     dwAllDevices,edx

        ; Form the bitmask 1 << (devtype * 8 + dev num) and
        ; see if device port is even available
        mov     ecx,dwDevData
        shl     cl,3
        add     cl,ch
        mov     eax,1
        shl     eax,cl
        test    eax,edx
        jz      DeviceNotPresent

        ; OK, it is. Find out if the device is connected
        mov     dwDeviceToCheck,eax
        mov     ax,ss
        shl     eax,10H
        lea     ax,dwDeviceToCheck
        mov     ebx,4
        mov     ecx,NV_CFGEX_CHECK_CONNECTED_DEVICES
        call    NV_ConfigExCall

        ; a 0 is success!
        or      eax,eax
        je      @F

DeviceNotPresent:
        mov     dwDeviceToCheck,0

@@:
        ; The bit for the device we were checking is turned off
        ; if the device is not connected. Otherwise it is left on.
        mov     eax,dwDeviceToCheck

DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_CanDevicesBeMapped
;
; Purpose:      This routine checks to see whether all the devices
;               specified can be used simultaneously. It doesn't
;               matter what the head assignment actually is, just
;               indicate whether it is possible.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               lpDevData               dword array ptr
;                                       Each dword looks like
;                                       low byte:       0 - CRT
;                                                       1 - TV
;                                                       2 - DFP
;                                       next byte:      0-7 for device number
;                                       next two bytes ignored
;               array length
;
; Returns:
;               eax                     TRUE, then they can
;                                       In this case ebx is the mapping
;                                       FALSE, then they can't
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CanDevicesBeMapped, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   lpDevData
PARMD   dwArrayLen
LOCALV  sConfig,NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS
OPENPROC
        PUSHR   esi,edi

        ; Form a bitmask of the desired device connections
        sub     eax,eax
        sub     edx,edx
        sub     ebx,ebx
        les     bx,lpDevData
@@:
        mov     ecx,es:[ebx][edx * 4]
        shl     cl,3
        add     cl,ch
        mov     esi,1
        shl     esi,cl
        or      eax,esi
        inc     edx
        cmp     edx,dwArrayLen
        jc      @B

        ; OK, it is. Find out if the device is connected
        mov     sConfig.DevicesConfig,eax
        sub     edx,edx
        mov     sConfig.DevicesAllocationMap,edx
        mov     sConfig.OldDevicesConfig,edx
        mov     sConfig.OldDevicesAllocationMap,edx
        mov     ax,ss
        shl     eax,10H
        lea     ax,sConfig
        mov     ebx,SIZE NV_CFGEX_GET_DEVICES_CONFIGURATION_PARAMS
        mov     ecx,NV_CFGEX_GET_DEVICES_CONFIGURATION
        mov     esi,pHWBoardCXOffset
        call    NV_ConfigExCall
        mov     ebx,sConfig.DevicesAllocationMap

        ; a 0 is success!
        mov     ecx,eax
        sub     eax,eax
        or      ecx,ecx
        jne     DoneIt
        mov     eax,1
DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_MapDevices
;
; Purpose:      This routine shuffles around the heads for the
;               CRTCs to get a mapping of heads to devices that
;               uses all the devices in the list passed in. It
;               is the callers responsibility to check and make
;               sure that such a mapping is possible by calling
;               HW_CanDevicesBeMapped before calling this routine.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               lpDevData               dword array ptr
;                                       Each dword looks like
;                                       low byte:       0 - CRT
;                                                       1 - TV
;                                                       2 - DFP
;                                       next byte:      0-7 for device number
;                                       next two bytes ignored
;               lpHWCrtcCX              array of HWCRTCCXs
;               array length
;
; Returns:
;               eax                     A dword specifying which devices
;                                       have changed. If bit 0 is a 1,
;                                       then first device in the lpDevData
;                                       array was remapped. If bit 1, is a
;                                       1, then the 2nd device in lpDevData
;                                       array was remapped, etc...
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_MapDevices, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   lpDevData
PARMD   lpHWCrtcCX
PARMD   dwArrayLen
LOCALD  dwPass
LOCALD  dwArrayCount
LOCALD  lpHWCrtcCX_Inc
LOCALD  lpDevData_Inc
LOCALD  dwPitchInBytes
LOCALD  dwDevicesConfig
LOCALD  dwDevicesAllocationMap
LOCALD  dwDeviceBit
LOCALD  dwDevicesChanged
OPENPROC
        PUSHR   esi,edi
        mov     dwDevicesChanged,0

        push    pHWBoardCXOffset
        push    lpDevData
        push    dwArrayLen
        call    HW_CanDevicesBeMapped
        or      eax,eax
        je      DoneIt
        mov     dwDevicesAllocationMap,ebx

        ; Form a bitmask of the desired device connections
        sub     eax,eax
        sub     edx,edx
        sub     ebx,ebx
        les     bx,lpDevData
@@:
        mov     ecx,es:[ebx][edx * 4]
        shl     cl,3
        add     cl,ch
        mov     esi,1
        shl     esi,cl
        or      eax,esi
        inc     edx
        cmp     edx,dwArrayLen
        jc      @B
        mov     dwDevicesConfig,eax

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; OK, everything is fine. We have the mapping. Now
        ; we just need to change VidLutCursorDac objects
        ; in each HWCRTCCX to match the mapping.
        ;
        ; In an attempt to be spiffy, we make two passes through
        ; the array of all CRTCCXs. The first will free every
        ; VidLutCursorDac object corresponding to a device whose
        ; head is changing. Any CRTCCXs that by chance are on the
        ; same head this time as last time will not be freed and
        ; realloced. This eliminates flashing when there is no
        ; need for it to flash.

        ; Let the RM know we are beginning a CHANGE
        push    pHWBoardCXOffset
        push    dwDevicesConfig
        call    HW_BeginDisplayChange

        mov     dwPass,0

LoopOnAction:
        mov     eax,dwArrayLen
        mov     dwArrayCount,eax
        mov     eax,lpHWCrtcCX
        mov     lpHWCrtcCX_Inc,eax
        mov     eax,lpDevData
        mov     lpDevData_Inc,eax
        mov     dwDeviceBit,1

LoopOnCX:
        les     bx,lpDevData_Inc
        mov     ecx,es:[bx]
        shl     cl,3
        add     cl,ch
        mov     eax,1
        shl     eax,cl

        ; Count the number of 1 bits less than the bit set in eax.
        ; This will be the nibble number in dwDevicesAllocationMap
        ; that holds the head number to use for this HWCRTCCX
        mov     edx,1
        sub     ebx,ebx

LoopOnNibble:
        test    edx,eax
        jnz     GotNibbleNumber
        test    edx,dwDevicesConfig
        jz      @F
        inc     ebx
@@:     shl     edx,1
        jmp     LoopOnNibble

GotNibbleNumber:
        ; ebx holds the nibble number
        mov     ecx,ebx
        shl     ecx,2
        mov     edi,dwDevicesAllocationMap
        shr     edi,cl
        and     edi,0FH
        les     bx,lpHWCrtcCX_Inc
        push    dword ptr es:[bx]
        call    HW_GetPhysicalCrtcIndex
        cmp     edi,eax
        je      SameHead

        ; Which Pass is this?
        cmp     dwPass,0
        jne     ReAlloc

FreeIt:
        ; OK, if this is the first pass, then we want to free
        ; all head related info in the HWCRTCCX if it is changing.
        les     bx,lpHWCrtcCX_Inc
        push    dword ptr es:[bx]
        call    NV_FreeHeadRelatedInfo
        jmp     NextCX

ReAlloc:
        ; If it is the second pass, then realloc all head related
        ; info to get the new stuff.
        les     bx,lpHWCrtcCX_Inc
        push    dword ptr es:[bx]
        push    edi
        call    NV_AllocHeadRelatedInfo

        ; If we are reallocing, then the device must have changed head.
        mov     eax,dwDeviceBit
        or      dwDevicesChanged,eax
        jmp     NextCX

NextCX:
SameHead:
        shl     dwDeviceBit,1
        add     lpHWCrtcCX_Inc,4
        add     lpDevData_Inc,4
        dec     dwArrayCount
        jne     LoopOnCX

        inc     dwPass
        cmp     dwPass,2
        jc      LoopOnAction
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ; Let the RM know we are beginning a CHANGE
        push    pHWBoardCXOffset
        push    dwDevicesConfig
        call    HW_EndDisplayChange

DoneIt:
        mov     eax,dwDevicesChanged
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_BeginDisplayChange
;
; Purpose:      This routine issues the DISPLAY_CHANGE_START
;               message to the RM. It is an API because the
;               generic code can call this whenever they
;               are about to detach or attach devices.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwDeviceMask            correclty formatted
;                                       mask that syas which devices
;                                       will be enabled after the
;                                       change is completed.
;
; Returns:
;               Nothing
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_BeginDisplayChange, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwDeviceMask
LOCALV  Params,NV_CFGEX_DISPLAY_CHANGE_START_PARAMS
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

	; OK, this is a hack for now. We have multiple nested calls to
	; BeginDisplayChange all over the driver. We are working to
	; change this, but for now I keep a "lock count". The first
	; Begin call gets changed up to the RM. No other begin call
	; goes up until I receive the matching end call.
	inc	ds:[esi].HWBOARDCX.dwDisplayChangeCount
	cmp	ds:[esi].HWBOARDCX.dwDisplayChangeCount,1
	jne	SkipIt

        mov     eax,dwDeviceMask
        mov     Params.NewDevices,eax
        sub     eax,eax
        mov     Params.Properties,eax
        mov     ax,ss
        shl     eax,10H
        lea     ax,Params
        mov     ebx,SIZE NV_CFGEX_DISPLAY_CHANGE_START_PARAMS
        mov     ecx,NV_CFGEX_DISPLAY_CHANGE_START
        call    NV_ConfigExSetCall

SkipIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_EndDisplayChange
;
; Purpose:      This routine issues the DISPLAY_CHANGE_END
;               message to the RM. It is an API because the
;               generic code can call this whenever they
;               are done detaching or attaching devices.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:
;               Nothing
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_EndDisplayChange, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwDeviceMask
LOCALV  Params,NV_CFGEX_DISPLAY_CHANGE_END_PARAMS
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

	; OK, this is a hack for now. We have multiple nested calls to
	; BeginDisplayChange all over the driver. We are working to
	; change this, but for now I keep a "lock count". The first
	; Begin call gets changed up to the RM. No other begin call
	; goes up until I receive the matching end call.
	cmp	ds:[esi].HWBOARDCX.dwDisplayChangeCount,1
	jne	SkipIt

        mov     eax,dwDeviceMask
        mov     Params.NewDevices,eax
        sub     eax,eax
        mov     Params.Properties,eax
        mov     ax,ss
        shl     eax,10H
        lea     ax,Params
        mov     ebx,SIZE NV_CFGEX_DISPLAY_CHANGE_END_PARAMS
        mov     ecx,NV_CFGEX_DISPLAY_CHANGE_END
        call    NV_ConfigExSetCall

SkipIt:
	dec	ds:[esi].HWBOARDCX.dwDisplayChangeCount
        POPR    esi
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWCLRBLT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwclrblt.asm
;
; Purpose:      This file transfers color bitmaps or DIBs from system
;               memory to video memory. The src color Bitmap can be
;               4, 8, 15, 16, 24, 32 bpp, and, the dst video memory
;               bitmap can be 8, 15, 16, or 32 bpp. There may be
;               a rop and a pattern as well.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include hwgdi.inc
include hwmacs.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     HW_BeginSrcColorDstVram
;
; Purpose:      This function is an easy way to implement color
;               bitmap transfers. This routine gets called to do setup,
;               and then the HW_BlockSrcColorDstVram gets called before
;               each chunk of lines is transferred, and finally the
;               function HW_EndColorSrcDstVram is called when the main
;               routine is done. You need to do the following:
;
;               2) Set the Rop (which is the byte at dwRop3+2)
;
;               3) Set the starting destination coordinates to be:
;                  dwDstTop, dwDstLeft
;
;               4) Set the extents of the transfer which are:
;                  dwExtX, dwExtY
;
;                  Note that the number of pixels sent for each scan
;                  will not necessarily be dwExtX, but will be instead
;                  dwExtXAligned. dwExtXAligned is equal to dwExtX plus
;                  from 0 to 3 extra pixels required to make the byte
;                  length of a transferred scan a multiple of a dword.
;                  dwExtX is simply the dst rectangle width in pixels.
;                  If there are any extra pixels beyond dwExtX, they
;                  should be dropped by the hardware. That may mean
;                  you need to tell the hardware the blt width is
;                  really dwExtXAligned and set a hardware clip rect.
;
;               5) Program the base and pitch of the dst bitmap which are:
;                  dwDstBitsOffset, dwDstPitch
;
;               6) Anything else you need to do to prepare the
;                  hardware for a transfer of the src bitmap.
;
;               7) You must return three important values to the generic
;                  code. One is a pseudo wrap width.  The second is the
;                  maximum number of bytes you can handle in a single
;                  transfer (without waiting or writing new header info,
;                  or whatever the hardware requires.) The third is
;                  your hardware ptr (either MMIO or DMA buffer.)
;
;                  Here is how it works:
;
;                  When you return from this routine, you should have
;                  es set to your hardware selector.
;
;                  The generic code will call HW_BlockSrcColorDstVram
;                  and have it wait for enough fifo slots or DMA buffer
;                  space. HW_BlockSrcColorDstVram will return a ptr to
;                  the generic code telling it where to begin writing
;                  pixels. The generic code starts xlatting and copying
;                  pixels incrementing this ptr as it goes. When the
;                  generic code reaches the end of a scanline, it will
;                  add in the pseudo wrap width you returned to the current
;                  value of the ptr and begin transferring pixels on
;                  the next scanline at this new address. If the
;                  generic code reaches the maximum number of pixels
;                  that can be handled in a single transfer (which was
;                  the second parameter you returned) before transferring
;                  the whole bitmap, it will call the block routine
;                  HW_BlockSrcColorDstVram again to both wait for more
;                  space and get a new dst ptr.
;
;                  So what exactly should these return values be?
;
;                  For a fifo based part like NV3/ZX, the pseudo wrap width
;                  should be -dwExtAligned * (dwDstBpp which is simply the
;                  negative of one of the locals on the predefined frame.
;                  The maximum single transfer size should be 128 bytes
;                  (or whatever the size of the fifo is in bytes.)
;
;                  For a DMA based part like NV4, the pseudo wrap width
;                  should be somewhere near 0 -- what does this mean?
;                  What we would like is for the next scanline's data to
;                  immediately follow the preceeding scanline's data.
;                  You might think that this implies the pseudo wrap
;                  width is 0. However, we will need to play with the
;                  dwExtX and dwExtXAligned to see if this is true.
;                  If dwExtX and dwExtXAligned are equal, the pseudo
;                  wrap width should be 0. If dwExtXAligned is greater
;                  (it can't be less since it is equal to dwExtX
;                  rounded up to the next number of pixels which gives
;                  a dword aligned scanline length), then the pseudo
;                  wrap width should be
;                  (dwExtXAligned - dwExtX) * dwDstBytesPerPixel
;
;                  The maximum single transfer size in bytes for DMAs is
;                  the size of the method to which the color pixels
;                  will be written. (Or the size of the DMA buffer if
;                  it is smaller, but for other driver policy reasons,
;                  the DMA buffer must be more than twice the size of
;                  the largest method so go with the method size.)
;
; Arguments:
;               ds                      Context Sel
;               pHWLogdevCXOffset       HWLOGDEVCX
;               dwDstBitsOffset         offset of dst bitmap in VRAM
;               dwDstPitch              pitch of dst bitmap in VRAM
;               dwDstBpp                bpp of dst bitmap (8,15,16,or 32)
;               dwDstLeft               left edge coord of dst rectangle
;               dwDstTop                top edge coord of dst rectangle
;               dwExtX                  width of dst rectangle in pixels
;               dwExtY                  height of dst rectangle in scanlines
;               dwExtXAligned           See description above for definition
;               lpBrush                 ptr to DIB_Brush
;               lpDrawMode              ptr to DRAWMODE
;               dwRop3                  rop 3 in Microsoft rop format
;
; Returns:
;       eax     0       need to punt
;               else    Keep going -- everything's fine
;                       In this case, you must also return
;                       ebx  - The pseudo wrap width
;                       ecx  - The max single transfer size in bytes
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_BeginSrcColorDstVram, PASCAL, FRAME, NEAR
PARMD   pHWLogdevCXOffset
PARMD   dwDstBitsOffset
PARMD   dwDstPitch
PARMD   dwDstBpp
PARMD   dwDstLeft
PARMD   dwDstTop
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwExtXAligned
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   dwRop3
OPENPROC
        mov     edx,pHWLogdevCXOffset
        mov     esi,ds:[edx].HWLOGDEVCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,esi,eax

        ; Load the push buffer ptr
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,dwDstBitsOffset
        CHECKDSTBASE ds,esi,edi,eax,dwDstPitch

        ; Prepare for a src transfer
        CHECKDMASPACE ds,esi,edi,30H
        mov     eax,CHNRUN(ContextPattern.SetMonochromeColor0,2)
        mov     ebx,ds:[edx].HWLOGDEVCX.dwPatternAlpha0
        mov     ecx,ds:[edx].HWLOGDEVCX.dwPatternAlpha1
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx
        mov     ds:[edi + 08H],ecx
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        movzx   ebx,byte ptr dwRop3+2
        mov     ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],ebx
        mov     eax,CHNRUN(ImageFromCpuHdr.object,1)
        mov     ebx,OBJ_IMAGE_FROM_CPU
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ebx
        mov     eax,CHNRUN(ImageFromCpu.SetColorFormat,4)
        mov     ebx,ds:[edx].HWLOGDEVCX.dwImageFromCpuColorFormat
        mov     ds:[edi + 1CH],eax
        mov     ds:[edi + 20H],ebx
        mov     ebx,dwDstTop
        mov     ecx,dwExtY
        shl     ebx,10H
        shl     ecx,10H
        mov     edx,ecx
        mov     bx,word ptr dwDstLeft
        mov     cx,word ptr dwExtX
        mov     dx,word ptr dwExtXAligned
        mov     ds:[edi + 24H],ebx
        mov     ds:[edi + 28H],ecx
        mov     ds:[edi + 2CH],edx
        add     edi,30H

        ; I need to return a few things
        mov     ebx,dwExtXAligned
        sub     ebx,dwExtX
        mov     ecx,dwDstBpp
        inc     ecx
        shr     ecx,3
        imul    ebx,ecx         ; pseudo wrap width
        mov     ecx,1792 * 4    ; size of color transfer method
        mov     ax,ds
        mov     es,ax
        mov     eax,1
Done:
CLOSEPROC


;==============================================================================
;
; Function:     HW_BlockSrcColorDstVram
;
; Purpose:      This function is an easy way to implement color
;               bitmap transfers. It is one of a sequence. For full
;               details, please see HW_BeginSrcColorDstVram eariler
;               in this file.
;
;               Here, wait for eax bytes of space in the DMA buffer or
;               in the fifo. You may adjust es:edi to whatever you wish.
;               Hence, if you need to wrap the DMA buffer, you may do
;               do and then reset es:edi to the start of the buffer.
;               The generic code never touches es and only adjusts edi
;               by incrementing it appropriately for every dst pixel
;               that is transferred.
;
; Arguments:
;               es      Context Seletor
;               eax     bytes to wait for
;               esi     pHWBoardCX
;               edi     push buffer ptr
;
; Returns:      This routine is not failable. If you wish to fail the
;               sequence, you must fail at HW_BeginSrcColorDstVram time.
;               es:edi must point to the location for the generic code
;               to copy the next eax bytes of dst pixels translated from
;               src pixels.
;
; Preserve:     ds,esi,fs,ebx
;==============================================================================
DECPROC HW_BlockSrcColorDstVram, PASCAL, NOFRAME, NEAR
OPENPROC
        SETPUTPTR es,esi,edi
        shrd    ecx,eax,10H
        lea     edx,[eax + 4]
        mov     cx,CHNRUN(ImageFromCpu.Color,0)
        CHECKDMASPACE es,esi,edi,edx
        mov     es:[edi],ecx
        add     edi,4
CLOSEPROC


;==============================================================================
;
; Function:     HW_EndSrcColorDstVram
;
; Purpose:      This function is an easy way to implement color
;               bitmap transfers. It is one of a sequence. For full
;               details, please see HW_BeginSrcColorDstVram eariler
;               in this file.
;
;               You may do anything you wish to here. There is nothing
;               specifically required. Some possibiliites are:
;               1) Bump the DMA ptr if you are DMA based
;               2) Reset the hardware clip rect if that was needed.
;
; Arguments:
;               es      Context Selector
;               esi     pHWBoardCX
;               edi     es has not changed since the last call to
;                       HW_BlockSrcColorDstVram and edi has only
;                       changed by being incremented for each dst
;                       pixel transferred.
;
; Returns:      This routine is not failable. If you wish to fail the
;               sequence, you must fail at HW_BeginSrcColorDstVram time.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_EndSrcColorDstVram, PASCAL, NOFRAME, NEAR
OPENPROC
        SETPUTPTR es,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_BitBltSrcColorDstVram
;
; Purpose:      This function implements BitBlts where the rop involves
;               a src, the src is a color system memory bitmap and the
;               dst is in VRAM. There may be a pattern involved as well
;               but there may not be.
;
;               Unless the blt is from one pixel depth to another and
;               you have hardware that handles the pixel translation
;               itself, you may just wish to call the generic routine
;               GN_BitBltSrcColorDstVram which will handle 95% of the
;               work of this routine for you. If you use the
;               GN_BitBltSrcColorDstVram service, you must implement
;               the three functions: HW_BeginSrcColorDstVram,
;               HW_BlockSrcColorDstVram and HW_EndSrcColorDstVram.
;
; Arguments:
;               ds                      Context Selector
;               pHWLogdevCXOffset       HWLOGDEVCX
;               lpDstDev                Ptr to dst device (DIBENG header)
;               dwDstLeft               left edge of the dst rectangle
;               dwDstTop                top  edge of the dst rectangle
;               dwSrcBitsSel            selector to the src bits
;               dwSrcBitsOffset         offset to start of the source bits
;               dwSrcBpp                Bits Per Pixel in the src image
;                                       This can be 4, 8, 15, 16, 24, or 32
;               dwSrcPitch              address first pixel on line n+1 minus
;                                       address of first pixel on line n.
;                                       This number might be negative if the
;                                       DIB is upside down.
;               dwSrcLeft               left edge of the src rectangle
;               dwSrcLeft               top  edge of the src rectangle
;               dwExtX                  extent of src (and dst) rectangle.
;               dwExtY                  extent of the (and dst) rectangle.
;               dwRop3                  3-operand rop
;               lpBrush                 ptr to a DIB_Brush struct
;               lpDrawMode              This is only needed for case where
;                                       the rop involves a a bursh which
;                                       is a mono pattern. In this case,
;                                       DRAWMODE.TextColor gives the color
;                                       to which to translate src 0 bits,
;                                       DRAWMODE.bkColor gives the color
;                                       to which to translate src 1 bits.
;                                       Note that these are not the same
;                                       colors used translate 0 and 1 bits
;                                       from the src bitmap.
;               dwSizeColorTableEntry   bytes per entry in the color table
;               dwColorTableEntries     number of entries in the color table
;               lpColorTable            ptr to a color table. This ptr will
;                                       be NULL if no color table is
;                                       necessary.
;               pfnCopyXlatArg          If this argument is not NULL then
;                                       it is the correct inner loop to use.
;                                       If it is NULL, then the correct
;                                       inner loop needs to be computed
;                                       from the pixel depths of the src
;                                       and dst, and the color table.
;
;       There will be a color table if:
;
;       1) The src is 4bpp. If the dst is 8bpp, then each entry will be
;          2 bytes. Only the low byte is used and is the remapped dst
;          color. If the dst is any other color depth besides 8bpp, then
;          each entry is 4 bytes -- a 32bpp logical color. These entries
;          will need to be mapped to the correct dst color depth.
;
;       2) the src is 8bpp and the dst is not 8bpp. Each entry is is
;          4 bytes -- a 32bpp logical color. These entries will need
;          to be mapped to the correct dst color depth.
;
;       There may be a color table if the src is 8bpp and the dst is
;       8bpp, but there also may not. If there is a color table then
;       each entry is 2 bytes in length. Only the low byte is used and
;       is the remapped dst color.
;
;       In all other cases, there is no color table. In some cases you
;       don't need one. i.e. if you are going from 15bpp->15bpp no
;       remapping is necessary -- just copy the source to the dst. On
;       the other hand if you are going from 24bpp->15bpp, there is no
;       color table either, but you need to convert each 24bit pixel to
;       a 15bit pixel. You MUST do these conversions in a manner identical
;       to the way the DIBENG does the conversions. If you aren't familiar
;       with the various algorithms the DIBENG uses for converting colors,
;       ask someone who is. They are not necessarily what you think. i.e.
;       15->24 does not just expand each 5bit color to an 8bit color by
;       tacking three 0 bits on the low end. There is a pseudo rounding
;       algorithm that is used.
;
; Returns:      eax     0       Can't handle the call -- please punt
;                       non-0   return code
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_BitBltSrcColorDstVram, PASCAL, FRAME, NEAR
PARMD   pHWLogdevCXOffset
PARMD   dwDstBitsSel
PARMD   dwDstBitsOffset
PARMD   dwDstBpp
PARMD   dwDstPitch
PARMD   dwDstLeft
PARMD   dwDstTop
PARMD   dwSrcBitsSel
PARMD   dwSrcBitsOffset
PARMD   dwSrcBpp
PARMD   dwSrcPitch
PARMD   dwSrcLeft
PARMD   dwSrcTop
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwRop3
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   dwSizeColorTableEntry
PARMD   dwColorTableEntries
PARMD   lpColorTable
PARMD   pfnCopyXlatArg
LOCALD  pHWBoardCXOffset
LOCALD  dwColorIndexFormat
LOCALD  dwNotAlignMask
LOCALD  dwAlignedSrcLeft
LOCALD  dwAlignedDstLeft
LOCALD  dwAlignMask
LOCALD  dwAlignedExtXPixels
LOCALD  dwSrcPixelsToSrcBytesShiftCount
LOCALD  dwAlignedExtXInDwords
LOCALD  dwLUTEntriesShiftCount
LOCALD  dwSrcWrapWidth
LOCALD  dwBlockBytes
LOCALD  dwBlockHeader
LOCALD  dwWholeScansPerBlock
OPENPROC

        ; Filter out NV5 devices before the first beginaccess call
        ; because of hardware bug
        cmp     dwDstBpp,32
        jne     @F
        mov     eax,pHWLogdevCXOffset
        mov     eax,ds:[eax].HWLOGDEVCX.pHWBoardCX
        cmp     ds:[eax].HWBOARDCX.dwGetOffsetAtLastBeginAccess,-1
        jne     @F
        cmp     ds:[eax].HWBOARDCX.dwDeviceVersion, NV_DEVICE_VERSION_5
        je      Nope

@@:
        ; Filter out the 4->N and 8->N conversions to use special
        ; pixel translation hardware. Since we have to transfer
        ; the color table, however, only do so for 8bit if there
        ; are at least as many pixels to be translated as there
        ; are color table entries to be transferred.
        cmp     dwDstBpp,8
        jbe     Nope
        cmp     dwSrcBpp,4
        je      Yup
        cmp     dwSrcBpp,8
        jne     Nope
        mov     eax,dwExtX
        imul    eax,dwExtY
        cmp     eax,dwColorTableEntries
        ja      Yup
Nope:   STOPPROC
        jmp     GN_BitBltSrcColorDstVram

Yup:
        PUSHR   ds,esi,edi

        ; Compute a few things which depend upon some arguments
        mov     dwLUTEntriesShiftCount,0
        cmp     dwDstBpp,32
        je      @F
        mov     dwLUTEntriesShiftCount,1
@@:
        mov     eax,03H
        sub     ecx,ecx
        mov     dwColorIndexFormat,NV060_INDEX_FORMAT_LE_I8
        cmp     dwSrcBpp,8
        je      @F
        mov     eax,07H
        mov     ecx,1
        mov     dwColorIndexFormat,NV060_INDEX_FORMAT_SVGA65_I4
@@:     mov     dwNotAlignMask,eax
        not     eax
        mov     dwSrcPixelsToSrcBytesShiftCount,ecx
        mov     dwAlignMask,eax

        ; Align the src ptr on a dword boundary. Back up the dst
        ; as needed to match the alignment and extend the ExtX by
        ; the amount we backed up. Then pad the ExtX onthe right
        ; to make it a multiple of a dword.
        mov     eax,dwSrcLeft
        mov     ebx,dwDstLeft
        mov     ecx,eax
        mov     edx,dwExtX
        and     eax,dwNotAlignMask
        sub     ecx,eax
        sub     ebx,eax
        add     edx,eax
        mov     dwAlignedSrcLeft,ecx
        mov     dwAlignedDstLeft,ebx
        add     edx,dwNotAlignMask
        and     edx,dwAlignMask
        mov     dwAlignedExtXPixels,edx

        ; We will not do the transfer if we are forced to break up a
        ; src scan into more than one block (greater than 1792 dwords)
        ; as determined by the hardware method size.
        mov     ecx,dwSrcPixelsToSrcBytesShiftCount
        shr     edx,cl
        cmp     edx,1792 * 4
        ja      GN_BitBltSrcColorDstVram
        shr     edx,2
        mov     dwAlignedExtXInDwords,edx

        ; Load the DMA ptr
        mov     esi,pHWLogdevCXOffset
        push    ds:[esi].HWLOGDEVCX.dwPatternAlpha1
        push    ds:[esi].HWLOGDEVCX.dwPatternAlpha0
        mov     esi,ds:[esi].HWLOGDEVCX.pHWBoardCX
        mov     pHWBoardCXOffset,esi

        ; Wait for other contexts
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,esi,eax

        ; Load the push buffer ptr
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,ds:[esi].HWBOARDCX.dwIndexedLUTOffset
        CHECKDSTBASE ds,esi,edi,eax,<400H>

        mov     edx,dwColorTableEntries
        lea     edx,[edx * 4 + 34H]
        CHECKDMASPACE ds,esi,edi,edx
        mov     dword ptr ds:[edi + 00H],CHNRUN(ContextPattern.SetMonochromeColor0,2)
        pop     dword ptr ds:[edi + 04H]
        pop     dword ptr ds:[edi + 08H]
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        mov     ecx,0CCH
        mov     ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],ecx
        mov     eax,CHNRUN(ImageFromCpuHdr.object,1)
        mov     ecx,OBJ_IMAGE_FROM_CPU
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ecx
        mov     ecx,pHWLogdevCXOffset
        mov     eax,CHNRUN(ImageFromCpu.SetColorFormat,4)
        mov     ecx,ds:[ecx].HWLOGDEVCX.dwImageFromCpuColorFormat
        mov     ds:[edi + 1CH],eax
        sub     eax,eax
        mov     ds:[edi + 20H],ecx
        mov     ds:[edi + 24H],eax
        mov     eax,dwColorTableEntries
        mov     ecx,dwLUTEntriesShiftCount
        shl     eax,cl
        or      eax,10000H
        lea     ecx,[eax + 3]
        and     ecx,NOT 3
        mov     ds:[edi + 28H],eax
        mov     ds:[edi + 2CH],ecx
        sub     edx,34H
        shl     edx,10H
        mov     dx,CHNRUN(ImageFromCpu.Color,0)
        mov     ds:[edi + 30H],edx
        add     edi,34H

        mov     ecx,dwColorTableEntries
        mov     eax,dwSizeColorTableEntry
        sub     esi,esi
        les     si,lpColorTable
        push    OFFSET RetLUT
        cmp     dwDstBpp,16
        ja      CopyLUT32
        je      CopyLUT16
        jmp     CopyLUT15
RetLUT:
        mov     esi,pHWBoardCXOffset

        ; Set the dst base and pitch if need be
        mov     eax,dwDstBitsOffset
        CHECKDSTBASE ds,esi,edi,eax,<dwDstPitch>

        ; Prepare to transfer the pixels
        CHECKDMASPACE ds,esi,edi,34H
        mov     ecx,dwDstTop
        mov     edx,dwExtY
        shl     ecx,10H
        shl     edx,10H
        mov     cx,word ptr dwDstLeft
        mov     dx,word ptr dwExtX
        mov     eax,CHNRUN(ContextClipRect.SetPoint,2)
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        mov     ds:[edi + 08H],edx
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        movzx   ecx,byte ptr [dwRop3 + 2]
        mov     ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],ecx
        mov     eax,CHNRUN(IndexedImageFromCpuHdr.object,1)
        mov     ecx,OBJ_INDEXED_IMAGE_FROM_CPU
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ecx

        ; We do not need to set the SetColorFormat method on the fly
        ; for this object BECAUSE for the hardware to work correctly,
        ; the 32bpp color format, NV060_SET_COLOR_FORMAT_LE_X8R8G8B8,
        ; MUST be set. The operation actually gets the color format
        ; from the CONTEXT_SURFACES_2D object embedded in it, so it
        ; seems like the SetColorFormat field should be irrelevant,
        ; but if it is not set to NV060_SET_COLOR_FORMAT_LE_X8R8G8B8
        ; the hardware draws weird color pixels. The 32Bpp format
        ; is set once when the object is created.

        mov     eax,CHNRUN(IndexedImageFromCpu.IndexFormat,5)
        mov     edx,dwColorIndexFormat
        mov     ecx,ds:[esi].HWBOARDCX.dwIndexedLUTOffset
        mov     ds:[edi + 1CH],eax
        mov     ds:[edi + 20H],edx
        mov     ds:[edi + 24H],ecx
        mov     ecx,dwExtY
        mov     eax,dwDstTop
        shl     ecx,10H
        shl     eax,10H
        mov     ax,word ptr dwAlignedDstLeft
        mov     cx,word ptr dwAlignedExtXPixels
        mov     ds:[edi + 28H],eax
        mov     ds:[edi + 2CH],ecx
        mov     ds:[edi + 30H],ecx
        add     edi,34H

        ; Load up the pointer and trasnfer the src image
        mov     eax,dwSrcTop
        mov     ebx,dwSrcPitch
        mov     esi,dwAlignedSrcLeft
        mov     ecx,dwSrcPixelsToSrcBytesShiftCount
        imul    eax,ebx
        shr     esi,cl
        mov     edx,dwAlignedExtXInDwords
        shl     edx,2
        sub     ebx,edx
        add     eax,dwSrcBitsOffset
        mov     dwSrcWrapWidth,ebx
        push    ds
        pop     es
        mov     ds,word ptr dwSrcBitsSel
        add     esi,eax

        ; Figure out how many whole scans we can do with one method header
        mov     eax,1792
        sub     edx,edx
        div     dwAlignedExtXInDwords
        mov     dwWholeScansPerBlock,eax
        imul    eax,dwAlignedExtXInDwords
        mov     ecx,eax
        lea     eax,[eax * 4 + 4]
        mov     dwBlockBytes,eax
        shl     ecx,12H
        mov     cx,CHNRUN(IndexedImageFromCpu.Indices,0)
        mov     dwBlockHeader,ecx

        ; Let's transfer as many complete src lines as we can in one chunk
LoopY:  mov     edx,dwExtY
        mov     eax,dwBlockBytes
        sub     edx,dwWholeScansPerBlock
        mov     ecx,dwBlockHeader
        mov     dwExtY,edx
        mov     edx,dwWholeScansPerBlock
        jge     @F

        ; There is only a partial block left. Adjust the parameters
        mov     edx,dwExtY
        mov     dwExtY,0
        add     edx,dwWholeScansPerBlock
        mov     eax,dwAlignedExtXInDwords
        shl     eax,2
        imul    eax,edx
        mov     ecx,eax
        add     eax,4
        shl     ecx,10H
        mov     cx,CHNRUN(IndexedImageFromCpu.Indices,0)
@@:
        ; Wait for space and transfer a whole block
        mov     ebx,pHWBoardCXOffset
        CHECKDMASPACE es,ebx,edi,eax
        mov     es:[edi],ecx
        add     edi,4
@@:
        mov     ecx,dwAlignedExtXInDwords
        rep     movs dword ptr es:[edi], ds:[esi]
        add     esi,dwSrcWrapWidth
        dec     edx
        jne     @B

        ; Let some data go
        SETPUTPTR es,ebx,edi
        cmp     ecx,dwExtY
        jl      LoopY

        ; Reset the ContextClip rectangle to the default
        CHECKDMASPACE es,ebx,edi,0CH
        mov     eax,CHNRUN(ContextClipRect.SetPoint,2)
        sub     edx,edx
        mov     ecx,07FFF7FFFH
        mov     es:[edi + 00H],eax
        mov     es:[edi + 04H],edx
        mov     es:[edi + 08H],ecx
        add     edi,0CH
        SETPUTPTR es,ebx,edi
Done:
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CopyLUT15
;
; Purpose:      This routine copies the LUT from a src color table with
;               dword entries into a dst area also with dword entries
;               also except the color are really 5-5-5 shifted left by
;               3 bits (the bottom 3 bits should always be 0.)
;
; Arguments:    es:esi          ptr to src LUT
;               ecx             number of LUT entries
;               ds:edi          dst LUT
;
; Returns:      ds:edi          must point immediately after last LUT
;                               entry copied
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  CopyLUT15
CopyLUT15       PROC    NEAR

        mov     eax,es:[esi]
        add     esi,4

        shld    edx,eax,10H
        sub     dl,04
        cmc
        sbb     dh,dh
        and     dh,dl
        and     dh,NOT 7

        mov     dl,ah
        sub     dl,4
        cmc
        sbb     ah,ah
        and     dl,ah
        and     dl,NOT 7

        sub     al,04
        cmc
        sbb     ah,ah
        and     al,ah
        and     al,NOT 7

        shl     eax,18H
        shld    edx,eax,8

        mov     ds:[edi],edx
        add     edi,4
        dec     ecx
        jne     CopyLUT15
        ret

CopyLUT15       ENDP


;==============================================================================
;
; Function:     CopyLUT16
;
; Purpose:      This routine copies the LUT from a src color table with
;               dword entries into a dst area also with dword entries
;               also except the color are really 5-6-5 shifted left by
;               3 bits for the red&blue and 2 bits for the green. (The
;               bottom bits should always be 0.)
;
; Arguments:    es:esi          ptr to src LUT
;               ecx             number of LUT entries
;               ds:edi          dst LUT
;
; Returns:      ds:edi          must point immediately after last LUT
;                               entry copied
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  CopyLUT16
CopyLUT16       PROC    NEAR

        mov     eax,es:[esi]
        add     esi,4

        shld    edx,eax,10H
        sub     dl,04
        cmc
        sbb     dh,dh
        and     dh,dl
        and     dh,NOT 7

        mov     dl,ah
        sub     dl,2
        cmc
        sbb     ah,ah
        and     dl,ah
        and     dl,NOT 3

        sub     al,04
        cmc
        sbb     ah,ah
        and     al,ah
        and     al,NOT 7

        shl     eax,18H
        shld    edx,eax,8

        mov     ds:[edi],edx
        add     edi,4
        dec     ecx
        jne     CopyLUT16
        ret

CopyLUT16       ENDP


;==============================================================================
;
; Function:     CopyLUT32
;
; Purpose:      This routine copies the LUT from a src color table with
;               dword entries into a dst area also with dword entries.
;
; Arguments:    es:esi          ptr to src LUT
;               ecx             number of LUT entries
;               ds:edi          dst LUT
;
; Returns:      ds:edi          must point immediately after last LUT
;                               entry copied
;
; Preserve:     Nothing
;==============================================================================
PUBLIC  CopyLUT32
CopyLUT32       PROC    NEAR

        mov     eax,es:[esi + 0]
        add     esi,4
        mov     ds:[edi + 0],eax
        add     edi,4
        dec     ecx
        jne     CopyLUT32
        ret

CopyLUT32       ENDP


CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWBOARD.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwboard.asm
;
; Purpose:      This file contains all the hardware specific BOARD
;               specific routines for init. The board specific run-
;               time routines are in hwboard2.asm.
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include gngdi.inc
include hwgdi.inc
include files.inc
include hwmacs.inc
include nvcm.inc
include nvreg.inc
include dxshare.inc
include ..\..\..\..\..\sdk\nvidia\inc\nvrmarch.inc
include ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc
include escape.inc

OPENSEG  _DATA, USE16, DATA
szNvSysDll              DB      NV4_RM_16_BINARY,0
szModeSetDll            DB      NV4_MODESET_BINARY,0
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     HW_CreateBoardContext
;
; Purpose:      This routine gets called from the generic code
;               the first time a PDEVICE is created on a given
;               board. This routine should create its BOARD
;               specific data and fill it in.
;
;               This routine will only be matched by a call to
;               HW_DestroyBoardContext when the last PDEVICE
;               initted on this board is going away.
;
; Arguments:
;               ds                      Context Selector
;
; Returns:      eax     0       failure
;                       else    This should be a ptr to what the HW
;                               wants as its HWBOARDCX ptr.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CreateBoardContext, PASCAL, FRAME, FAR32
PARMD   dwThisLogDeviceHandle
OPENPROC
        PUSHR   esi,edi
        sub     esi,esi

        pushd   SIZE HWBOARDCX
        call    HW_AllocFlatMemory
        or      eax,eax
        je      DoneIt
        mov     esi,eax
        mov     ds:[esi].HWBOARDCX.pHWBoardCXReal,eax

        ; Set this to 1 right now.
        mov     ds:[esi].HWBOARDCX.dwInitting,1

        ; Get our device Number from the RM
        push    dwThisLogDeviceHandle
        call    NV_GetDeviceNumber
        or      eax,eax
        je      DoneIt

        ; Allocate the root node from the RM
        call    NV_AllocRoot
        or      eax,eax
        je      DoneIt

        ; Allocate our device slot from the RM
        call    NV_AllocDevice
        or      eax,eax
        je      DoneIt

        ; Get information about video memory.
        call    NV_GetMemoryInfo
        or      eax,eax
        je      DoneIt

        ; Get information on the chip base
        call    NV_GetDeviceInfo
        or      eax,eax
        je      DoneIt

        ; Get information on the chip version
        call    NV_GetDeviceVersion
        or      eax,eax
        je      DoneIt

        ; Get information of bus type
        call    NV_GetBusType
        or      eax,eax
        je      DoneIt

        ; We need to know how many CRTCs there are on this board.
        call    NV_GetNumCRTCs
        or      eax,eax
        je      DoneIt

        ; Allocate the push buffer
        call    NV_AllocPushBuffer
        or      eax,eax
        je      DoneIt

        ; OK, Here is the linear base of the real push buffer
        mov     ds:[esi].HWBOARDCX.pRealPushBuffer,ebx

        ; Allocate a context DMA for the PUSHBUFFER
        push    esi
        pushd   OBJ_DMA_PUSH_BUFFER
        push    ds:[esi].HWBOARDCX.pRealPushBuffer
        push    ds
        pushd   (DMA_PUSH_BUFFER_SIZE + 0FFFH) AND 0FFFFF000H
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY
        call    NV_AllocContextDma
        or      eax,eax
        je      DoneIt

        ; Allocate a channel for use with the DMA push buffer
        mov     eax,OBJ_DMA_PUSH_BUFFER
        call    NV_AllocChannelDma
        or      eax,eax
        je      DoneIt
        mov     ds:[esi].HWBOARDCX.pDmaChannel,eax

        ; Allocate linear address space of the same size as the
        ; HWBOARDCX + DMA_PUSH_BUFFER_SIZE so we can remap pages.
        mov     eax,(SIZE HWBOARDCX + DMA_PUSH_BUFFER_SIZE + 0FFFH) AND 0FFFFF000H
        call    NV_AllocLinearAddressSpace
        or      eax,eax
        je      DoneIt
        mov     ds:[esi].HWBOARDCX.pAliasedHWBoardCX,eax

        ; Copy the PTEs for the HWBOARDCX ptr passed in to the
        ; aliased HWBOARDCX so the two ptrs reference the same
        ; physical memory.
        mov     eax,esi
        mov     ebx,ds:[esi].HWBOARDCX.pAliasedHWBoardCX
        mov     ecx,(SIZE HWBOARDCX) AND 0FFFFF000H
        call    NV_CopyPTEsForLinearRange
        or      eax,eax
        je      DoneIt

        ; Copy the PTEs for the Real DMA_PUSH_BUFFER memory allocated
        ; previously into the PTEs of our linear address space to the
        ; pages immediately after the ones mapping the HWBOARDCX. This
        ; way the HWBOARDCX and DMA_PUSH_BUFFER are linearly contiguous.
        mov     eax,ds:[esi].HWBOARDCX.pRealPushBuffer
        mov     ebx,ds:[esi].HWBOARDCX.pAliasedHWBoardCX
        add     ebx,(SIZE HWBOARDCX) AND 0FFFFF000H
        mov     ecx,(DMA_PUSH_BUFFER_SIZE + 0FFFH) AND 0FFFFF000H
        call    NV_CopyPTEsForLinearRange
        or      eax,eax
        je      DoneIt

        ; Modify the mapping of the page in the middle of the
        ; HWBOARDCX structure that is supposed to point to the
        ; Nv04ControlDma structure.
        mov     eax,ds:[esi].HWBOARDCX.pDmaChannel
        mov     ebx,ds:[esi].HWBOARDCX.pAliasedHWBoardCX
        lea     ebx,[ebx].HWBOARDCX.bHWPageStart
        mov     ecx,1000H
        call    NV_CopyPTEsForLinearRange
        or      eax,eax
        je      DoneIt

        ; Now we have to switch over to the mapped HWBOARDCX ptr
        ; since it also has pages that point to the hardware and
        ; to the push buffer mapped after the end of the HWBOARDCX
        ; itself.
        mov     esi,ds:[esi].HWBOARDCX.pAliasedHWBoardCX

        ; Create all the DMA contexts we will need.
        call    NV_CreateDmaContexts
        or      eax,eax
        je      DoneIt

        ; Watch out for chipsets that can't get the cache coherency
        ; implemented correctly.
IF (DOIOTOFLUSHCACHE NE 0)
        pushd   NV_CFG_IO_NEEDED
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigGet,es,ax
        mov     ds:[esi].HWBOARDCX.dwFlushCacheWithIO,eax
ELSE
        mov     ds:[esi].HWBOARDCX.dwFlushCacheWithIO,0
ENDIF

        ; Init the push buffer variables
        lea     edi,ds:[esi].HWBOARDCX.bScrapSpace
        mov     ds:[esi].HWBOARDCX.pPushBufferContextStartOffset,edi
        lea     edi,ds:[esi].HWBOARDCX.bDmaPushBuffer
        mov     ds:[esi].HWBOARDCX.pPushBufferStartOffset,edi
        mov     ds:[esi].HWBOARDCX.dwPushBufferLength,DMA_PUSH_BUFFER_SIZE - WRITE_COMBINE_PAD_SIZE - 10H
        mov     ds:[esi].HWBOARDCX.dwBytesFree,DMA_PUSH_BUFFER_SIZE - WRITE_COMBINE_PAD_SIZE - 08H

        ; The minimum and maximum pitces of a context surface 2D are
        ; dependent upon whether the board is nv04, 05, 10, etc.
        mov     eax,20H
        mov     ebx,8160
        cmp     ds:[esi].HWBOARDCX.dwDeviceVersion,NV_DEVICE_VERSION_10
        jl      @F
        mov     eax,40H
        mov     ebx,10000H
@@:     mov     ds:[esi].HWBOARDCX.dwMinContextSurface2dPitch,eax
        mov     ds:[esi].HWBOARDCX.dwMaxContextSurface2dPitch,ebx
        imul    eax,10001H
        mov     ds:[esi].HWBOARDCX.dwContextSurface2dDstSrcPitch,eax

        ; Make sure that this gets reinitted properly in BeginAccess
        ; by setting it to an impossible push buffer offset now.
        mov     eax,-1
        mov     ds:[esi].HWBOARDCX.dwGetOffsetAtLastBeginAccess,eax

        ; The DMA pusher should be up and running. I'm going to put
        ; some NOPS in the push buffer to get it started. The first
        ; 20H bytes or so of the push buffer are not used because
        ; may need them as a place to access that we know is far
        ; enough away from the last CPU access to WRITE COMBINE
        ; memory so that a flush of the CPU WRITE COMBINE buffers
        ; is forced.
        push    ds
        pop     es
        mov     edi,ds:[esi].HWBOARDCX.pPushBufferContextStartOffset
        sub     eax,eax
        mov     ecx,(WRITE_COMBINE_PAD_SIZE + 3) / 4
        rep     stos dword ptr es:[edi]
        SETPUTPTR  ds,esi,edi

        ; Now let's just wait until the push buffer fetches those
        ; NOP commands.
        mov     eax,edi
        sub     eax,ds:[esi].HWBOARDCX.pPushBufferContextStartOffset
@@:     cmp     ds:[esi].HWBOARDCX.dwDmaGetPtr,eax
        jne     @B

        ; Create all the obects we will need.
        call    NV_CreateObjects
        or      eax,eax
        je      DoneIt

        ; Let's figure out our channel mask
        call    NV_GetGdiChannelMask

        ; Now we have to allocate some memory that will NEVER
        ; go away. This will be for the LUT and for however
        ; many cursors are on the board.
        call    NV_AllocRequiredMemory
        or      eax,eax
        je      DoneIt

        ; Return the HWBOARDCX ptr that we really want to use
        mov     eax,esi

DoneIt:
        ; If eax is 0, then we failed, BUT if esi is non-0, then
        ; some of the HWBOARDCX was filled in. We must handle
        ; this case and free any portion that got initted.
        or      eax,eax
        jne     ExitIt
        or      esi,esi
        je      ExitIt

        ; HW_DestroyBoardContext can clean up partial inits
        push    esi
        call    HW_DestroyBoardContext
        sub     eax,eax

ExitIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_DestroyBoardContext
;
; Purpose:      This routine gets called to destroy a HWBOARDCX.
;
; Arguments:
;               ds                      context selector
;               pHWBoardCXOffset        HWBOARDCX to destroy
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_DestroyBoardContext, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
LOCALV  FreeParam,NV01FREE_PARAM
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWBoardCXOffset
        or      esi,esi
        je      DoneIt

        ; Destroy the objects
        call    NV_DestroyObjects

        ; Destroy the context DMAs
        call    NV_DestroyDmaContexts

        ; pAliasedHWBoardCX was allocated via the function
        ; NV_AllocLinearAddressSpace an must be freed by calling
        ; NV_FreeLinearAddressSpace.
        cmp     ds:[esi].HWBOARDCX.pAliasedHWBoardCX,0
        je      @F

        ; esi is currently using the aliased HWBoardCX.
        ; We are about to free this memory block, so we must
        ; switch esi back over to the real allocation offset
        ; which is a different linear range the first part
        ; of which maps to the ssame physical range -- the HWBOARDCX.
        mov     esi,ds:[esi].HWBOARDCX.pHWBoardCXReal

        mov     eax,ds:[esi].HWBOARDCX.pAliasedHWBoardCX
        mov     ebx,(SIZE HWBOARDCX + DMA_PUSH_BUFFER_SIZE + 0FFFH) AND 0FFFFF000H
        call    NV_FreeLinearAddressSpace
        mov     ds:[esi].HWBOARDCX.pAliasedHWBoardCX,0
@@:
        ; Destroy the DMA channel
        mov     bx,ss
        shl     ebx,10H
        lea     bx,FreeParam
        push    ebx
        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     FreeParam.NV01FREE_hClient,ecx
        mov     FreeParam.NV01FREE_hObjectParent,NV_WIN_DEVICE
        mov     FreeParam.NV01FREE_hObjectOld,NV_WIN_CHANNEL
        mov     FreeParam.NV01FREE_status,NV01FREE_STATUS_SUCCESS
        CALLFAR16IND lpfnArch_Nv01Free,es,ax

        ; Destroy the push buffer context DMA
        push    esi
        pushd   OBJ_DMA_PUSH_BUFFER
        call    NV_FreeContextDma

        ; If the real push buffer was allocated via SysAllocPages, we
        ; need to free the memory now. If it was allocated with the
        ; NV_AllocMemory function, then the memory will get freed when
        ; we free the RootHandle.
        cmp     esi,ds:[esi].HWBOARDCX.dwRealPushBufferPageHandle
        je      @F
        push    ds:[esi].HWBOARDCX.dwRealPushBufferPageHandle
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvSysFreePages,es,ax
        mov     ds:[esi].HWBOARDCX.dwRealPushBufferPageHandle,0
@@:

        ; Free the screen sel
        mov     eax,ds:[esi].HWBOARDCX.dwVideoMemorySel
        or      eax,eax
        je      @F
        call    GN_UnmapAndFreeSelector
        mov     ds:[esi].HWBOARDCX.dwVideoMemorySel,0
@@:
        ; Now we can free the root.
        call    NV_FreeRoot

        mov     eax,ds:[esi].HWBOARDCX.dwDeviceNum
        or      eax,eax
        jz      @F
        push    eax
        CALLFAR16IND lpfnNvSysDriverDisConnect,es,ax
@@:
        push    esi
        call    HW_FreeFlatMemory

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetDeviceNumber
;
; Purpose:      Determines the device number for the board controlled by
;               this particular driver since there may be multiple NVidia
;               cards in the same system.
;
; Arguments:    ds:esi          HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_GetDeviceNumber, PASCAL, FRAME, NEAR
PARMD   dwThisLogDeviceHandle
OPENPROC
        ; Call SysDriverConnect to get the device number.
        mov     edx,dwThisLogDeviceHandle
        sub     eax,eax
        cmp     edx,1
        je      @F
        and     edx, NOT 3H
@@:
        push    edx
        push    eax
        CALLFAR16IND lpfnNvSysDriverConnect,es,ax
        shl     edx,16
        mov     dx,ax
        mov     ds:[esi].HWBOARDCX.dwDeviceNum,edx
        mov     eax,edx
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocRoot
;
; Purpose:      Allocates the root node for this device.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocRoot, PASCAL, FRAME, NEAR
LOCALV  AllocRootParam,ALLOC_ROOT_PARAM
OPENPROC
        ; Get and save the handle to the root
        mov     ax,ss
        lea     bx,AllocRootParam
        push    ax
        push    bx
        mov     edx,ALLOC_ROOT_CLASS_ROOT
        mov     ecx,ALLOC_ROOT_STATUS_SUCCESS
        mov     AllocRootParam.ALLOC_ROOT_PARAM.ALLOC_ROOT_hClass,edx
        mov     AllocRootParam.ALLOC_ROOT_PARAM.ALLOC_ROOT_status,ecx
        CALLFAR16IND lpfnArch_Nv01AllocRoot,es,ax
        mov     eax,AllocRootParam.ALLOC_ROOT_PARAM.ALLOC_ROOT_hObjectNew
        mov     ds:[esi].HWBOARDCX.dwRootHandle,eax

        mov     ecx,ALLOC_ROOT_STATUS_SUCCESS
        cmp     ecx,AllocRootParam.ALLOC_ROOT_PARAM.ALLOC_ROOT_status
        sete    al
        movzx   eax,al
CLOSEPROC


;==============================================================================
;
; Function:     NV_FreeRoot
;
; Purpose:      Frees the root node for this device. This will cause
;               everything allocated under this root to be freed also.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_FreeRoot, PASCAL, FRAME, NEAR
LOCALV  FreeParam,NV01FREE_PARAM
OPENPROC
        mov     bx,ss
        push    bx
        lea     bx,FreeParam
        push    bx
        mov     eax,ds:[esi].HWBOARDCX.dwRootHandle
        mov     FreeParam.NV01FREE_hClient,eax
        mov     FreeParam.NV01FREE_hObjectParent,eax
        mov     FreeParam.NV01FREE_hObjectOld,eax
        mov     FreeParam.NV01FREE_status,NV01FREE_STATUS_SUCCESS
        CALLFAR16IND lpfnArch_Nv01Free,es,ax

        cmp     FreeParam.NV01FREE_status,NV01FREE_STATUS_SUCCESS
        sete    al
        movzx   eax,al
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocDevice
;
; Purpose:      Allocates a device slot from the RM.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocDevice, PASCAL, FRAME, NEAR
LOCALV  AllocDevParam,ALLOC_DEV_PARAM
LOCALS  szDevName,10H
OPENPROC
        ; Call and allocate our "device"
        mov     ax,ss
        lea     bx,AllocDevParam
        push    ax
        push    bx
        mov     eax,ds:[esi].HWBOARDCX.dwRootHandle
        mov     AllocDevParam.ALLOC_DEV_PARAM.ALLOC_DEV_hObjectParent,eax
        mov     eax,NV_WIN_DEVICE
        mov     AllocDevParam.ALLOC_DEV_PARAM.ALLOC_DEV_hObjectNew,eax
        mov     eax,ds:[esi].HWBOARDCX.dwDeviceNum
        add     eax,(NV01_DEVICE_0 - 1)
        mov     AllocDevParam.ALLOC_DEV_PARAM.ALLOC_DEV_hClass,eax

        push    ss
        call    GN_GetSelectorBase
        lea     edx,szDevName
        add     edx,eax
        mov     AllocDevParam.ALLOC_DEV_PARAM.ALLOC_DEV_szName,edx
        mov     ecx,ALLOC_DEV_STATUS_SUCCESS
        mov     AllocDevParam.ALLOC_DEV_PARAM.ALLOC_DEV_status,ecx
        CALLFAR16IND lpfnArch_Nv01AllocDevice,es,ax

        ; Now get the handle and save it
        mov     eax,AllocDevParam.ALLOC_DEV_PARAM.ALLOC_DEV_hObjectNew
        mov     ds:[esi].HWBOARDCX.dwhDevice,eax

        ; Set the return code.
        mov     ecx,ALLOC_DEV_STATUS_SUCCESS
        cmp     ecx,AllocDevParam.ALLOC_DEV_PARAM.ALLOC_DEV_status
        sete    al
        movzx   eax,al
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetMemoryInfo
;
; Purpose:      This routine gets the amount of onboard memory and
;               information about the memory capabilities.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_GetMemoryInfo, PASCAL, NOFRAME, NEAR
OPENPROC
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvSysGetRamInfo,es,ax
        movzx   eax,ax
        shl     edx,20
        mov     ds:[esi].HWBOARDCX.dwRamFlags,eax
        mov     ds:[esi].HWBOARDCX.dwVideoMemorySize,edx

        pushd   NV_DEV_BUFFER_0
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvDeviceBaseGet,es,ax
        shl     edx,10H
        mov     dx,ax
        mov     ds:[esi].HWBOARDCX.pVideoMemory,edx

        ; Alloc a selector to map to this linear address
        mov     eax,1
        mov     ebx,edx
        mov     ecx,ds:[esi].HWBOARDCX.dwVideoMemorySize
        call    GN_AllocSelectorAndMapIt
        mov     ds:[esi].HWBOARDCX.dwVideoMemorySel,eax
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetDeviceInfo
;
; Purpose:      This routine gets the linear base address of the device
;               and maps a selector to this linear base.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_GetDeviceInfo, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Get the linear base address of the chip
        pushd   NV_DEV_BASE
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvDeviceBaseGet,es,ax
        shl     edx,10H
        mov     dx,ax
        mov     ds:[esi].HWBOARDCX.pChipRegs,edx
        mov     eax,edx
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetDeviceVersion
;
; Purpose:      This routine gets the device version from the RM.
;               Basically, are we running on NV4, NV5, or NV10.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_GetDeviceVersion, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Get the linear base address of the chip
        pushd   NV_CFG_ARCHITECTURE
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigGet,es,ax
        push    eax

        pushd   NV_CFG_REVISION
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigGet,es,ax
        pop     ebx

        ; Is it an NV20 or better?
        mov     ecx,NV_DEVICE_VERSION_20
        cmp     ebx,NV_20_ARCHITECTURE
        jge     Done

        ; Is it an NV10?
        mov     ecx,NV_DEVICE_VERSION_10
        cmp     ebx,NV_10_ARCHITECTURE
        je      Done

        ; If the architecture is < 5, then revision 0 is NV4, else NV5
        mov     ecx,NV_DEVICE_VERSION_4
        or      eax,eax
        je      Done
        mov     ecx,NV_DEVICE_VERSION_5
Done:
        mov     ds:[esi].HWBOARDCX.dwDeviceVersion,ecx

        ; We also want the revision
        pushd   NV_CFG_REVISION
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigGet,es,ax
        mov     ds:[esi].HWBOARDCX.dwDeviceRevision,eax

        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetBusType
;
; Purpose:      This routine gets the bus type of the card -- PCI or AGP.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_GetBusType, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Get the linear base address of the chip
        pushd   NV_CFG_BUS_TYPE
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigGet,es,ax
        movzx   eax,al
        mov     ds:[esi].HWBOARDCX.dwBusType,eax
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetNumCRTCs
;
; Purpose:      This routine returns the number of CRTCs on the
;               board.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_GetNumCRTCs, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Get the linear base address of the chip
        pushd   NV_CFG_NUMBER_OF_HEADS
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigGet,es,ax
        mov     ds:[esi].HWBOARDCX.dwNumCRTCsOnBoard,eax
        mov     ds:[esi].HWBOARDCX.dwCRTCsAllocatedFlags,0
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocPushBuffer
;
; Purpose:      This routine allocates the push buffer. I made it a
;               separate routine because potentially I want to be able
;               to allocate the push buffer in PCI, AGP or video memory.
;               There may be some heuristic for determining which one.
;
;               Right now, the push buffer always goes in PCI memory
;               for a retail build, but for testing, I can stick it
;               in video memory and AGP as well.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       Failure
;                       non-0   Success in which case
;                               ebx     linear base of push buffer
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocPushBuffer, PASCAL, FRAME, NEAR
LOCALV  sMem,ALLOC_MEMORY_PARAM
OPENPROC
IFDEF   DEBUG
        cmp     cs:[bLocatePushBuffer],0
        je      PciBuffer
        cmp     cs:[bLocatePushBuffer],1
        je      VidBuffer
        cmp     cs:[bLocatePushBuffer],2
        je      AgpBuffer
        jmp     PciBuffer

PUBLIC  bLocatePushBuffer
bLocatePushBuffer       DB      0

AgpBuffer:
        mov     eax,(DMA_PUSH_BUFFER_SIZE + 0FFFH) AND 0FFFFF000H
        mov     ebx,ALLOC_MEMORY_FLAGS_CONTIGUOUS_PHYSICALITY + ALLOC_MEMORY_FLAGS_LOCATION_AGP
        mov     ecx,OBJ_DMA_PUSH_MEMORY
        call    NV_AllocMemory
        or      eax,eax
        je      PciBuffer
        jmp     DoneBuffer

VidBuffer:
        push    esi
        pushd   NVIOCONTROL_HEAP_ALLOC_SIZE
        pushd   GDI2D_HEAP_OWNER
        pushd   NVIOCONTROL_TYPE_CURSOR
        pushd   (DMA_PUSH_BUFFER_SIZE + 0FFFH) AND 0FFFFF000H
        call    NV_OffscreenHeapAlloc
        cmp     eax,-1
        je      PciBuffer

        add     eax,ds:[esi].HWBOARDCX.pVideoMemory
        mov	ebx,eax
        jmp     DoneBuffer
ENDIF

PciBuffer:
        ; Allocate the push buffer in PCI memory
        mov     eax,(DMA_PUSH_BUFFER_SIZE + 0FFFH) SHR 0CH
        call    NV_AllocPages
        mov     ds:[esi].HWBOARDCX.dwRealPushBufferPageHandle,eax

DoneBuffer:
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocChannelDma
;
; Purpose:      This function allocates a channel for an existing
;               context DMA object.
;
; Arguments:
;               ds:esi  HWBOARDCX
;               eax     Object ID
;
; Returns:      eax     linear base of a Nv04ControlDma structure
;                       0 if there was an error
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocChannelDma, PASCAL, FRAME, NEAR
LOCALV  AllocChannelDmaParam,ALLOC_CHL_DMA_PARAM
OPENPROC
        PUSHSREG ss
        lea     bx,AllocChannelDmaParam
        push    bx
        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     AllocChannelDmaParam.ALLOC_CHL_DMA_hClient,ecx
        mov     AllocChannelDmaParam.ALLOC_CHL_DMA_hObjectParent,NV_WIN_DEVICE
        mov     AllocChannelDmaParam.ALLOC_CHL_DMA_hObjectNew,NV_WIN_CHANNEL
        mov     AllocChannelDmaParam.ALLOC_CHL_DMA_hClass,NV04_CHANNEL_DMA
        mov     AllocChannelDmaParam.ALLOC_CHL_DMA_hObjectError,NV01_NULL_OBJECT
        mov     AllocChannelDmaParam.ALLOC_CHL_DMA_hObjectBuffer,eax
        sub     edx,edx
        mov     AllocChannelDmaParam.ALLOC_CHL_DMA_offset,edx
        mov     AllocChannelDmaParam.ALLOC_CHL_DMA_pControl,edx
        mov     AllocChannelDmaParam.ALLOC_CHL_DMA_pControl+4,edx
        mov     AllocChannelDmaParam.ALLOC_CHL_DMA_status,edx
        CALLFAR16IND lpfnArch_Nv03AllocChannelDma,es,ax
        mov     eax,AllocChannelDmaParam.ALLOC_CHL_DMA_pControl
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocPages
;
; Purpose:      This routine allocates a number of pages of memory
;               typically to be used as a DMA buffer, but they can
;               be used for anything.
;
; Arguments:    ds:esi  HWBOARDCX
;               eax     number of pages to allocate
;
; Returns:      eax     PageHandle      (0 if failure)
;               ebx     LinearBase
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocPages, PASCAL, FRAME, NEAR
LOCALD  dwLinearBase
LOCALD  dwPageHandle
OPENPROC
        ; Call the RM to allocate some pages
        mov     cx,ss
        lea     bx,dwLinearBase
        push    cx
        push    bx
        lea     bx,dwPageHandle
        push    cx
        push    bx
        push    eax
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvSysAllocPages,es,ax

        ; Return the right things
        mov     eax,dwPageHandle
        mov     ebx,dwLinearBase
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocMemory
;
; Purpose:      This routine allocates different amounts and types
;               of memory. It is typically used to allocate a DMA
;               buffer, but can be used for anything. It also maps
;               a selector:0 to the base address of the allocation.
;
; Arguments:    ds:esi  HWBOARDCX
;               eax     number of bytes to allocate
;               ebx     allocation flags
;               ecx     Object ID
;
; Returns:      eax     0       Failure
;                       non-0   Success in which case
;                               ebx     LinearBase
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocMemory, PASCAL, FRAME, FAR32
LOCALV  nvAllocMemoryParam,ALLOC_MEMORY_PARAM
OPENPROC
        mov     dx,ss
        push    dx
        lea     dx,nvAllocMemoryParam
        push    dx
        mov     edx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     nvAllocMemoryParam.ALLOC_MEMORY_hObjectClient,edx
        mov     edx,ds:[esi].HWBOARDCX.dwhDevice
        mov     nvAllocMemoryParam.ALLOC_MEMORY_hObjectParent,edx
        sub     edx,edx
        mov     nvAllocMemoryParam.ALLOC_MEMORY_hObjectNew,ecx
        mov     nvAllocMemoryParam.ALLOC_MEMORY_hClass,NV1_MEMORY_SYSTEM
        mov     nvAllocMemoryParam.ALLOC_MEMORY_flags,ebx
        mov     nvAllocMemoryParam.ALLOC_MEMORY_pBase,edx
        mov     nvAllocMemoryParam.ALLOC_MEMORY_pBase+4,edx
        dec     eax
        mov     nvAllocMemoryParam.ALLOC_MEMORY_pLimit,eax
        mov     nvAllocMemoryParam.ALLOC_MEMORY_pLimit+4,edx
        mov     nvAllocMemoryParam.ALLOC_MEMORY_status,ALLOC_MEMORY_STATUS_SUCCESS
        CALLFAR16IND lpfnArch_Nv01AllocMemory,es,ax

        cmp     nvAllocMemoryParam.ALLOC_MEMORY_status,ALLOC_MEMORY_STATUS_SUCCESS
        sete    al
        movzx   eax,al
        mov     ebx,nvAllocMemoryParam.ALLOC_MEMORY_pBase
CLOSEPROC


;==============================================================================
;
; Function:     NV_FreeMemory
;
; Purpose:      This routine allocates different amounts and types
;               of memory. It is typically used to allocate a DMA
;               buffer, but can be used for anything. It also maps
;               a selector:0 to the base address of the allocation.
;
; Arguments:    ds:esi  HWBOARDCX
;               ecx     Object ID
;
; Returns:      eax     0       Failure
;                       non-0   Success in which case
;                               ebx     LinearBase
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_FreeMemory, PASCAL, FRAME, FAR32
LOCALV  FreeParam,NV01FREE_PARAM
OPENPROC
        mov     bx,ss
        push    bx
        lea     bx,FreeParam
        push    bx
        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     FreeParam.NV01FREE_hClient,ecx
        mov     edx,ds:[esi].HWBOARDCX.dwhDevice
        mov     FreeParam.NV01FREE_hObjectParent,ecx
        mov     FreeParam.NV01FREE_hObjectOld,ecx
        mov     FreeParam.NV01FREE_status,NV01FREE_STATUS_SUCCESS
        CALLFAR16IND lpfnArch_Nv01Free,es,ax

        cmp     FreeParam.NV01FREE_status,NV01FREE_STATUS_SUCCESS
        sete    al
        movzx   eax,al
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocLinearAddressSpace
;
; Purpose:      This function can be used to allocate linear address
;               space via the minivdd. There is no physical memory to
;               back the address space.
;
; Arguments:    ds:esi  HWBOARDCX
;               eax     bytes of linear address space to allocate
;
; Returns:      eax     linear base of address space  (0 if error)
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocLinearAddressSpace, PASCAL, FRAME, NEAR
LOCALV  rmRegs,RMPARAMS
OPENPROC
        mov     rmRegs.RegEDX,eax
        mov     rmRegs.RegECX,MVDD_ALLOC_LINEAR_ADDRESS_SPACE
        mov     ax,ss
        lea     ebx,rmRegs
        push    ax
        push    bx
        CALLFAR16IND lpfnNvSysRegisterDisplayDriver,es,ax
        mov     eax,rmRegs.RegEAX
CLOSEPROC

;==============================================================================
;
; Function:     NV_FreeLinearAddressSpace
;
; Purpose:      This function can be used to free linear address
;               space via the minivdd.
;
; Arguments:    ds:esi  HWBOARDCX
;               eax     base of linear address space to free
;               ebx     length in bytes of linear address range to free
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_FreeLinearAddressSpace, PASCAL, FRAME, NEAR
LOCALV  rmRegs,RMPARAMS
OPENPROC
        mov     rmRegs.RegEDX,eax
        mov     rmRegs.RegECX,MVDD_FREE_LINEAR_ADDRESS_SPACE
        mov     rmRegs.RegEBX,ebx
        mov     ax,ss
        lea     ebx,rmRegs
        push    ax
        push    bx
        CALLFAR16IND lpfnNvSysRegisterDisplayDriver,es,ax
CLOSEPROC

;==============================================================================
;
; Function:     NV_CopyPTEsForLinearRange
;
; Purpose:      This function can be used to copy the PTEs behind one
;               linear address range to the PTEs behind another linear
;               address range making both ranges address the same
;               physical memory.
;
; Arguments:    ds:esi  HWBOARDCX
;               eax     src linear range
;               ebx     dst linear range
;               ecx     length of linear range in bytes
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_CopyPTEsForLinearRange, PASCAL, FRAME, NEAR
LOCALV  rmRegs,RMPARAMS
OPENPROC
        mov     rmRegs.RegEDX,eax
        mov     rmRegs.RegEBX,ebx
        mov     rmRegs.RegEDI,ecx
        mov     rmRegs.RegECX,MVDD_COPY_PTES_FOR_LINEAR_RANGE
        mov     ax,ss
        lea     ebx,rmRegs
        push    ax
        push    bx
        CALLFAR16IND lpfnNvSysRegisterDisplayDriver,es,ax
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetGdiChannelMask
;
; Purpose:      This function determines which bit mask position our
;               DMA pusher holds in a chip register so we can tell
;               whether ours and other DMA contexts are active.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      HWBOARDCX.dwGdiPushBufferMask set correctly
;               HWBOARDCX.dwGdiPushBufferIndex set correctly
;               HWBOARDCX.dwGdiDriverChannelID set correctly
;
; Preserve:     ds,esi,edi
;==============================================================================
NV4_PFIFO_CACHE1_PUSH1          EQU     00003204H
DECPROC NV_GetGdiChannelMask, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   edi
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset

        mov     ecx,-1
        mov     ds:[esi].HWBOARDCX.dwGdiPushBufferIndex,1
        mov     ds:[esi].HWBOARDCX.dwGdiPushBufferMask,ecx
@@:
        ; This is what we think the PushBufferIndex is
        mov     ds:[esi].HWBOARDCX.dwGdiPushBufferIndex,ecx

        ; Trigger off some DMA activity.
        ; The easy thing is to write NOPS in the push buffer!
        CHECKDMASPACE ds,esi,edi,04H
        sub     eax,eax
        mov     ds:[edi + 00H],eax
        add     edi,4
        SETPUTPTR ds,esi,edi

        ; Read the ID of the current active DMA channel
        sub     ebx,ebx
        mov     eax,ds:[esi].HWBOARDCX.pChipRegs
        mov     ecx,ds:[eax + NV4_PFIFO_CACHE1_PUSH1]
        and     ecx,0FH

        ; If not what we thought, go back and test again.
        cmp     ecx,ds:[esi].HWBOARDCX.dwGdiPushBufferIndex
        jne     @B

DMAChannelQueryDone:
        mov     eax,1
        shl     eax,cl
        not     eax
        mov     ds:[esi].HWBOARDCX.dwGdiPushBufferMask,eax
        mov     ds:[esi].HWBOARDCX.dwGdiDriverChannelID,ecx

        ; Set up a ptr to the location of the current channel ID
        ; This ptr is used by all the clients with DMA pushers.
        lea     edx,[esi].HWBOARDCX.dwCurrentChannelID
        mov     ds:[esi].HWBOARDCX.pCurrentChannelID,edx

        POPR    edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocRequiredMemory
;
; Purpose:      This routine allocates memory for the IndexedImageLUT
;               and enough for cursors for all heads on the board.
;               The addresses are saved off so that other objects
;               can ask for them later.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       Failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocRequiredMemory, PASCAL, FRAME, NEAR
LOCALD  dwPitchInBytes
LOCALD  dwCRTCCount
OPENPROC
        PUSHR   edi

        ; The Indexed Image Lut needs to be 1K aligned on a 1K boundary
        ; so we have to alloc at least 2K - 1 to be certain of alignment.
        mov     eax,800H
        push    esi
        pushd   NVIOCONTROL_HEAP_ALLOC_SIZE
        pushd   GDI2D_BOARD_OWNER
        pushd   NVIOCONTROL_TYPE_CURSOR
        push    eax
        call    NV_OffscreenHeapAlloc
        cmp     eax,-1
        je      FailIt
        mov     ds:[esi].HWBOARDCX.dwIndexedLUTOffset,eax

        ; Set the cursor cache size
        mov     ds:[esi].HWBOARDCX.dwCursorCacheSize,24

        ; Now allocate a cursor cache for each/all heads.
        ; We are going to assume the largest cursor at 32x32 with
        ; alpha which is a 32bpp cursor. This takes 4K bytes. We
        ; must also align to a 4K boundary which means an extra 4K.
        mov     eax,ds:[esi].HWBOARDCX.dwNumCRTCsOnBoard
        imul    eax,ds:[esi].HWBOARDCX.dwCursorCacheSize
        inc     eax
        imul    eax,1000H
        push    esi
        pushd   NVIOCONTROL_HEAP_ALLOC_SIZE
        pushd   GDI2D_BOARD_OWNER
        pushd   NVIOCONTROL_TYPE_CURSOR
        push    eax
        call    NV_OffscreenHeapAlloc
        cmp     eax,-1
        je      FailIt

        ; Align to a 4K boundary
        add     eax,0FFFH
        and     eax,NOT 0FFFH

        lea     edi,[esi].HWBOARDCX.adwCursorCacheVramOffset
        sub     ecx,ecx
        mov     edx,ds:[esi].HWBOARDCX.dwCursorCacheSize
        imul    edx,1000H
@@:     mov     ds:[edi + ecx * 4],eax
        add     eax,edx
        inc     ecx
        cmp     ecx,ds:[esi].HWBOARDCX.dwNumCRTCsOnBoard
        jc      @B

        mov     eax,1
        jmp     DoneIt

FailIt:
        sub     eax,eax
DoneIt:
        POPR    edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetCursorCacheInfo
;
; Purpose:      This routine returns informatin about the cursor
;               cache for the given head.
;
; Arguments:    ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwPhysicalCRTCIndex     index of CRTC to get the cursor
;                                       cache info for
;
; Returns:      eax     offset of cursor cache in video mnemory
;               ebx     number of cache slots
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_GetCursorCacheInfo, PASCAL, FRAME, NEAR
PARMD   pHWBoardCXOffset
PARMD   dwPhysicalCRTCIndex
OPENPROC
        mov     edx,pHWBoardCXOffset
        mov     ebx,ds:[edx].HWBOARDCX.dwCursorCacheSize
        mov     ecx,dwPhysicalCRTCIndex
        mov     eax,ds:[edx].HWBOARDCX.adwCursorCacheVramOffset[ecx * 4]
CLOSEPROC


;==============================================================================
;
; Function:     NV_BoardSetDXSharedData
;
; Purpose:      This routine sets the shared DX data structure fields
;               that have board specific information.
;
; Arguments:    ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               pDXShare                DISPDRVDIRECTXCOMMON ptr
;
; Returns:      eax     offset of cursor cache in video mnemory
;               ebx     number of cache slots
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_BoardSetDXSharedData, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   pDXShare
OPENPROC
        mov     ebx,pHWBoardCXOffset
        mov     edx,pDXShare
        mov     eax,ds:[ebx].HWBOARDCX.dwDeviceNum
        mov     ds:[edx].DISPDRVDIRECTXCOMMON.dwNVDeviceID,eax
        mov     eax,ds:[ebx].HWBOARDCX.dwDeviceVersion
        mov     ds:[edx].DISPDRVDIRECTXCOMMON.dwDeviceVersion,eax
        mov     eax,ds:[ebx].HWBOARDCX.dwRootHandle
        mov     ds:[edx].DISPDRVDIRECTXCOMMON.dwRootHandle,eax
        mov     eax,ds:[ebx].HWBOARDCX.pChipRegs
        mov     ds:[edx].DISPDRVDIRECTXCOMMON.dwDeviceLinearBase,eax
CLOSEPROC

;==============================================================================
;
; Function:     NV_SetInterlacedStereoMode
;
; Purpose:      This routine sets the interlaced stereo mode if needed
;               and lets resman know about it. If stereo type is interlaced 
;               then stereo buffers have to be adjacent in video memory. So 
;               resman must know about it in order to adjust the pitch
;               to accomodate the right eye.
;
; Arguments:    ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwInterlacedMode        1/0
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_SetInterlacedStereoMode, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwInterlacedMode
LOCALV  StereoParams,NV_CFG_STEREO_PARAMS
OPENPROC
        PUSHR   ds,esi,edi
        
        mov		eax,dwInterlacedMode
        lea     edi,StereoParams
        mov     esi,pHWBoardCXOffset
        mov     ss:[edi].NV_CFG_STEREO_PARAMS.Flags, STEREOCFG_EXIT_ADJACENT 
		mov     ds:[esi].HWBOARDCX.dwStereoConnectionType, eax
        test	eax, eax
        jz      @F
        mov     ss:[edi].NV_CFG_STEREO_PARAMS.Flags, STEREOCFG_ENTER_ADJACENT 
@@:
        pushd   NV_CFG_STEREO_CONFIG    
        mov     ax,ss
        push    ax
        lea     ax,StereoParams
        push    ax
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigSet,es,ax

        POPR    ds,esi,edi
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWCRTC2.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwcrtc2.asm
;
; Purpose:      This file contains all the hardware specific CRTC
;               routines for run-time. The CRTC specific init
;               routines are in hwcrtc.asm.
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include files.inc
include hwmacs.inc
include nvcm.inc
include nvreg.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include modeext.inc
include ..\..\..\..\..\sdk\nvidia\inc\nvrmarch.inc
include ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
PUBLIC  TableMonitorTypeRMToModeset
TableMonitorTypeRMToModeset     LABEL   BYTE
DB      DEVTYPE_CRT, DEVTYPE_CRT, DEVTYPE_TV, DEVTYPE_TV, DEVTYPE_DFP

PUBLIC  TableMonitorTypeModesetToRM
TableMonitorTypeModesetToRM     LABEL   BYTE
DB      MONITOR_TYPE_VGA, MONITOR_TYPE_NTSC, MONITOR_TYPE_FLAT_PANEL

PUBLIC  TableTvFormatRMToModeset
TableTvFormatRMToModeset        LABEL   BYTE
DB      TVTYPE_NTSCM, TVTYPE_NTSCJ, TVTYPE_PALM, TVTYPE_PALA, TVTYPE_PALN
DB      TVTYPE_PALNC

PUBLIC  TableTvFormatModesetToRM
TableTvFormatModesetToRM        LABEL   BYTE
DB      NTSC_M, NTSC_J, PAL_M, PAL_A, PAL_N, PAL_NC

IFDEF DEBUG
szSetMode       DB      'DISPLAY:HW_SetCrtcMode',0DH,0AH,0
ENDIF

;==============================================================================
;
; Function:     HW_CrtcMessage
;
; Purpose:      This routine gets called whenver there is an
;               message to send to all objects. There are
;               a few different messages.  See gngdi.inc
;               for details.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX ptr
;               dwMessage               which message
;               dwData1                 additional data that depends
;                                       upon the message type
;               dwData2                 additional data that depends
;                                       upon the message type
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CrtcMessage, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   dwMessage
PARMD   dwData1
PARMD   dwData2
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      DoneIt

        mov     eax,dwMessage
        cmp     eax,MSG_PREMODESET
        je      PreMS
        cmp     eax,MSG_POSTMODESET
        je      PostMS
        cmp     eax,MSG_DIRECTX_ENUM
        je      DXEnum
        cmp     eax,MSG_DIRECTXON
        je      DXOn
        cmp     eax,MSG_DIRECTXOFF
        je      DXOff
        cmp     eax,MSG_DOSON
        je      DosOn
        cmp     eax,MSG_DOSOFF
        je      DosOff
        cmp     eax,MSG_DISABLE
        je      DrvDis
        jmp     DoneIt

PreMS:
        jmp     DoneIt

PostMS:
        ; We are no longer initting after the first modeset
        mov     ds:[esi].HWCRTCCX.dwInitting,0
        jmp     DoneIt

DXEnum:
DXOn:
DXOff:
        jmp     DoneIt

DosOff:
        jmp     DoneIt

DosOn:
        jmp     DoneIt

DrvDis:

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_SetCrtcMode
;
; Purpose:      This routine gets called to stuff the CRTCs
;               timings into the push buffer and physically
;               set the mode.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX ptr
;               lpModeOut               16:16 ptr to MODEOUT
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_SetCrtcMode, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   dwImageOffset
PARMD   lpModeOut
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      SkipSet

IFDEF DEBUG
        mov     ax,cs
        shl     eax,10H
        lea     ax,szSetMode
        push    eax
        call    GENERIC_OutputDebugString
ENDIF

        sub     ebx,ebx
        les     bx,lpModeOut

        mov     edx,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        mov     ecx,ds:[esi].HWCRTCCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ecx,eax

        mov     edi,ds:[ecx].HWBOARDCX.pCurrentPushBufferOffset

        SETDMASTATUS <ds:[esi].HWCRTCCX.sVideoLutCursorDacNotifier1.status>

        CHECKDMASPACE ds,ecx,edi,38H

        ; Set the object in a sub-channel.
        mov     eax,CHNRUN(VideoLutCursorDacHdr.object,1)
        mov     ds:[edi + 00H],eax
        add     edx,OBJ_VIDEO_LUT_CURSOR_DAC
        mov     ds:[edi + 04H],edx

        ; get X-res and Y-res
        mov     eax,CHNRUN(VideoLutCursorDac.SetDac.imagedwSize,8)
        mov     ds:[edi + 08H],eax
        mov     eax,dword ptr es:[ebx].MODEOUT.wXRes
        mov     ds:[edi + 0CH],eax

        ; horz blank start and width
        mov     eax,dword ptr es:[ebx].MODEOUT.wHBlankStart
        mov     ds:[edi + 10H],eax

        ; horz sync start and width
        mov     eax,dword ptr es:[ebx].MODEOUT.wHSyncStart
        mov     ds:[edi + 14H],eax

        ; vert blank start and width
        mov     eax,dword ptr es:[ebx].MODEOUT.wVBlankStart
        mov     ds:[edi + 18H],eax

        ; vert sync start and width
        mov     eax,dword ptr es:[ebx].MODEOUT.wVSyncStart
        mov     ds:[edi + 1CH],eax

        ; set total size
        mov     eax,dword ptr es:[ebx].MODEOUT.wHTotal
        mov     ds:[edi + 20H],eax

        ; set pixel clock
        mov     eax,dword ptr es:[ebx].MODEOUT.dwPixelClock
        mov     ds:[edi + 24H],eax

        ; set format
        mov     eax,dword ptr es:[ebx].MODEOUT.dwFormat
        mov     ds:[edi + 28H],eax

        ; set image offset and pitch
        mov     eax,CHNRUN(VideoLutCursorDac.SetImage.dwdwOffset,2)
        mov     edx,dwImageOffset
        mov     ds:[edi + 2CH],eax
        mov     ds:[edi + 30H],edx
        mov     edx,dword ptr es:[ebx].MODEOUT.dwPitchInBytes
        mov     ds:[edi + 34H],edx
        mov     ds:[esi].HWCRTCCX.dwPanPitch,edx

        add     edi,38H
        SETPUTPTR ds,ecx,edi

        ; Now wait until the notify is complete
        WAITDMASTATUS <ds:[esi].HWCRTCCX.sVideoLutCursorDacNotifier1.status>

SkipSet:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_SetStopImage
;
; Purpose:      This routine gets called to send the StopImage method
;               to the VideoLutCursorDac class. This will blank the screen.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_SetStopImage, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      SkipSet

        mov     edx,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        mov     ecx,ds:[esi].HWCRTCCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ecx,eax

        mov     edi,ds:[ecx].HWBOARDCX.pCurrentPushBufferOffset

        SETDMASTATUS <ds:[esi].HWCRTCCX.sVideoLutCursorDacNotifier0.status>

        CHECKDMASPACE ds,ecx,edi,18H

        ; Set the object in a sub-channel.
        mov     eax,CHNRUN(VideoLutCursorDacHdr.object,1)
        mov     ds:[edi + 00H],eax
        add     edx,OBJ_VIDEO_LUT_CURSOR_DAC
        mov     ds:[edi + 04H],edx

        ; Request a notifier
        mov     eax,CHNRUN(VideoLutCursorDac.Notify,1)
        mov     ds:[edi + 08H],eax
        mov     eax,NV07C_NOTIFY_WRITE_ONLY
        mov     ds:[edi + 0CH],eax
        
        ; Set StopImage.
        mov     eax,CHNRUN(VideoLutCursorDac.StopImage,1)
        mov     ds:[edi + 10H],eax
        mov     eax,NV07C_STOP_IMAGE_AS_SOON_AS_POSSIBLE
        mov     ds:[edi + 14H],eax

        add     edi,18H
        SETPUTPTR ds,ecx,edi

        ; Now wait until the notify is complete
        WAITDMASTATUS <ds:[esi].HWCRTCCX.sVideoLutCursorDacNotifier0.status>

SkipSet:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_SetPanOffset
;
; Purpose:      This routine sets the offset in video memory of the
;               first byte scanned out by this crtc for each frame.
;
; Arguments:
;               ds                      The context selector.
;               pHWCrtcCXOffset         offset of HWCRTCCX
;               dwwPanOffset            offset into the screen surface
;                                       (not into video memory), of the
;                                       new panning position.
;
; Returns:
;               None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_SetPanOffset, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   dwNewPanOffset
OPENPROC
        PUSHR   esi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      SkipPan

        mov     eax,OBJ_VIDEO_LUT_CURSOR_DAC
        mov     edx,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     eax,edx
        mov     ecx,ds:[esi].HWCRTCCX.pHWBoardCX

        push    dwNewPanOffset
        push    ds:[esi].HWCRTCCX.dwPanPitch
        push    ds:[ecx].HWBOARDCX.dwGdiDriverChannelID
        push    eax
        push    ds:[ecx].HWBOARDCX.dwDeviceNum
        push    edx
        call    FFP16 PTR lpfnNvSysUpdateImageOffsetFormat

SkipPan:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_SetGamma
;
; Purpose:      This is the hardware specific SetGamma routine.
;               Place the gamma passed in into the hardware.
;
; Arguments:
;               ds                      CXSel
;               pHWCrtcCXOffset         HWCRTCCX ptr
;               pGammaRamp              ptr to 256 dwords of XBGR
;               dwFirstEntry            0-255 index of first entry to set
;               dwNumEntries            number of contiguous palette
;                                       indices to set
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_SetGamma, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   pGammaRamp
PARMD   dwFirstEntry
PARMD   dwNumEntries
OPENPROC
        PUSHR   esi,edi
        mov     edi,pHWCrtcCXOffset
        or      edi,edi
        je      DoneIt

        ; First, copy the gamma table passed in
        mov     esi,pGammaRamp
        lea     edi,[edi].HWCRTCCX.dwGammaTable
        mov     eax,dwFirstEntry
        lea     esi,[esi][eax * 4]
        lea     edi,[edi][eax * 4]
        mov     ecx,dwNumEntries
@@:
        mov     eax,ds:[esi]
        add     esi,4
        mov     ds:[edi],eax
        add     edi,4
        dec     ecx
        jne     @B

        push    pHWCrtcCXOffset
        pushd   OBJ_DMA_IN_SYSRAM_FOR_GAMMA
        push    dwFirstEntry
        push    dwNumEntries
        call    NV_SetColorMap

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_SetPalette
;
; Purpose:      This is the hardware specific SetGamma routine.
;               Place the gamma passed in into the hardware.
;
; Arguments:
;               ds                      CXSel
;               pHWCrtcCXOffset         HWCRTCCX ptr
;               pPalette                ptr to 256 dwords of XBGR
;               dwFirstEntry            0-255 index of first entry to set
;               dwNumEntries            number of contiguous palette
;                                       indices to set
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_SetPalette, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   pPalette
PARMD   dwFirstEntry
PARMD   dwNumEntries
OPENPROC
        PUSHR   esi,edi
        mov     edi,pHWCrtcCXOffset
        or      edi,edi
        je      DoneIt

        ; First, copy the gamma table passed in
        mov     esi,pPalette
        lea     edi,[edi].HWCRTCCX.dwPaletteTable
        mov     eax,dwFirstEntry
        lea     esi,[esi][eax * 4]
        lea     edi,[edi][eax * 4]
        mov     ecx,dwNumEntries
@@:
        mov     eax,ds:[esi]
        add     esi,4
        mov     ds:[edi],eax
        add     edi,4
        dec     ecx
        jne     @B

        push    pHWCrtcCXOffset
        pushd   OBJ_DMA_IN_SYSRAM_FOR_PALETTE
        push    dwFirstEntry
        push    dwNumEntries
        call    NV_SetColorMap

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_SetColorMap
;
; Purpose:      This routine sets a color map into the hardware.
;               It is called by both the set palette and set
;               gamma fcuntions.
;
; Arguments:
;               ds                      CXSel
;               pHWCrtcCXOffset         HWCRTCCX ptr
;               object base to set      Should be either:
;                                       OBJ_DMA_IN_SYSRAM_FOR_PALETTE
;                                       OBJ_DMA_IN_SYSRAM_FOR_GAMMA
;               pColorMap               Ptr to a color map
;               dwFirstEntry            0-255 index of first entry to set
;               dwNumEntries            number of contiguous palette
;                                       indices to set
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_SetColorMap, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   dwBaseObjectID
PARMD   dwFirstEntry
PARMD   dwNumEntries
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      SkipSet

        mov     ebx,ds:[esi].HWCRTCCX.pHWBoardCX

        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ebx,eax

        ; Load the push buffer ptr
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Tell the hardware to load this color map
        CHECKDMASPACE ds,ebx,edi,1CH

        ; Set VideoLutCursorDac in a sub-channel
        mov     eax,CHNRUN(VideoLutCursorDacHdr.object,1)
        mov     edx,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     edx,OBJ_VIDEO_LUT_CURSOR_DAC
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],edx

        ; Set the correct color map object
        mov     eax,CHNRUN(VideoLutCursorDac.SetContextDmaLut,1)
        mov     edx,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     edx,dwBaseObjectID
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],edx

        ; Program the buffer offset for the color map.
        ; We have created a ContextDma just for the
        ; dwColorMap so the offset will be 0.
        mov     eax,CHNRUN(VideoLutCursorDac.SetLut,2)
        sub     edx,edx
        mov     ecx,NV049_SET_LUT_FORMAT_NOTIFY_WRITE_ONLY
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],edx
        mov     ds:[edi + 18H],ecx
        add     edi,1CH

        SETPUTPTR ds,ebx,edi
        sub     edi,ds:[ebx].HWBOARDCX.pPushBufferContextStartOffset
@@:
        cmp     ds:[ebx].HWBOARDCX.dwDmaGetPtr,edi
        jne     @B

SkipSet:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_IsBandwidthOK
;
; Purpose:      This function checks to see whether the mode(s)
;               specified violate bandwidth requirements on the
;               display device.
;
; Arguments:
;               dwTotalWidth0           paramters for physical head 0
;               dwVisibleWidth0
;               dwTotalHeight0
;               dwVisibleHeight0
;               dwPixelDepth0
;               dwPixelClock0
;               dwRefreshRate0
;
;               dwTotalWidth1           parameters for physical head 1
;               dwVisibleWidth1
;               dwTotalHeight1
;               dwVisibleHeight1
;               dwPixelDepth1
;               dwPixelClock1
;               dwRefreshRate1
;
;               If the dwTotaldwWidth field is 0, then that head
;               is not being used.
;
; Returns:      eax     non-0   then bandwidth is OK
;                       0       then bandwidth is violated
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_IsBandwidthOK, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   dwTotaldwWidth0
PARMD   dwVisibledwWidth0
PARMD   dwTotalHeight0
PARMD   dwVisibleHeight0
PARMD   dwPixelDepth0
PARMD   dwPixelClock0
PARMD   dwRefreshRate0
PARMD   dwTotaldwWidth1
PARMD   dwVisibledwWidth1
PARMD   dwTotalHeight1
PARMD   dwVisibleHeight1
PARMD   dwPixelDepth1
PARMD   dwPixelClock1
PARMD   dwRefreshRate1
LOCALV  Params,NV_CFGEX_VALIDATE_BANDWIDTH_PARAMS
OPENPROC
        PUSHR   esi
        mov     esi,pHWCrtcCXOffset
        mov     esi,ds:[esi].HWCRTCCX.pHWBoardCX

        mov     Params.VidScalerHead,NV_CFGEX_VALIDATE_BANDWIDTH_SCALER_WORST_CASE

        mov     eax,dwTotaldwWidth0
        mov     Params.HeadActive0,eax
        or      eax,eax
        je      Skip0
        mov     Params.HeadActive0,-1
        mov     Params.TotaldwWidth0,eax
        mov     eax,dwVisibledwWidth0
        mov     Params.VisibledwWidth0,eax
        mov     eax,dwTotalHeight0
        mov     Params.TotalHeight0,eax
        mov     eax,dwVisibleHeight0
        mov     Params.VisibleHeight0,eax
        mov     eax,dwPixelDepth0
        mov     Params.PixelDepth0,eax
        mov     eax,dwPixelClock0
        mov     Params.PixelClock0,eax

        ; Isn't being used now
;       mov     Params.RefreshRate0,eax

Skip0:
        mov     eax,dwTotaldwWidth1
        mov     Params.HeadActive1,eax
        or      eax,eax
        je      Skip1
        mov     Params.HeadActive1,-1
        mov     eax,dwTotaldwWidth1
        mov     Params.TotaldwWidth1,eax
        mov     eax,dwVisibledwWidth1
        mov     Params.VisibledwWidth1,eax
        mov     eax,dwTotalHeight1
        mov     Params.TotalHeight1,eax
        mov     eax,dwVisibleHeight1
        mov     Params.VisibleHeight1,eax
        mov     eax,dwPixelDepth1
        mov     Params.PixelDepth1,eax
        mov     eax,dwPixelClock1
        mov     Params.PixelClock1,eax

        ; Isn't being used now
;       mov     Params.RefreshRate1,0

Skip1:
;       mov     Params.status;

        mov     ax,ss
        shl     eax,10H
        lea     ax,Params
        mov     ebx,SIZE NV_CFGEX_VALIDATE_BANDWIDTH_PARAMS
        mov     ecx,NV_CFGEX_VALIDATE_BANDWIDTH
        call    NV_ConfigExCall

        ; Return success/fail in eax
        ; Status = 0 is Success, so flip the sense
        or      eax,eax
        mov     eax,1
        je      @F
        sub     eax,eax
@@:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_MapHWDeviceTypeToGNDeviceType
;
; Purpose:      This function maps the device type constants
;               MONITOR_XXXX defined in nvcm.h to the device type
;               constants defined in modeext.h.
;
; Arguments:    ecx     RM device type -- MONITOR_XXX
;
; Returns:      ecx     Modeset device constant -- DEVTYPE_XXXX
;
; Preserve:     everything except ecx
;==============================================================================
DECPROC HW_MapHWDeviceTypeToGNDeviceType, PASCAL, FRAME, FAR32
OPENPROC
        cmp     ecx,MONITOR_TYPE_FLAT_PANEL
        jbe     @F
        mov     ecx,MONITOR_TYPE_VGA
@@:     movzx   ecx,TableMonitorTypeRMToModeset[ecx]
CLOSEPROC


;==============================================================================
;
; Function:     HW_MapGNDeviceTypeToHWDeviceType
;
; Purpose:      This function maps the device type constants
;               DEVTYPE_XXXX defined in modeext.h to the device type
;               constants MONITOR_XXXX defined in nvcm.h.
;
; Arguments:    ecx     Modeset device type -- DEVTYPE_XXX
;
; Returns:      ecx     RM device constant -- MONITOR_XXXX
;
; Preserve:     everythin except ecx
;==============================================================================
DECPROC HW_MapGNDeviceTypeToHWDeviceType, PASCAL, FRAME, FAR32
OPENPROC
        cmp     ecx,DEVTYPE_DFP
        jbe     @F
        mov     ecx,DEVTYPE_CRT
@@:     movzx   ecx,TableMonitorTypeModesetToRM[ecx]
CLOSEPROC


;==============================================================================
;
; Function:     HW_MapHWTvFormatToGNTvFormat
;
; Purpose:      This function maps the Tv Format constants
;               NTSC_X and PAL_X defined in nvcm.h to the
;               Tv Format constants defined in modeext.h
;
; Arguments:    ecx     RM Tv Format -- NTSC_X and PAL_X
;
; Returns:      ecx     Modeset TV Format -- TVTYPE_XXX
;
; Preserve:     everything except ecx
;==============================================================================
DECPROC HW_MapHWTvFormatToGNTvFormat, PASCAL, FRAME, FAR32
OPENPROC
        cmp     ecx,KNOWN_TV_FORMATS
        jbe     @F
        mov     ecx,NTSC_M
@@:     movzx   ecx,TableTvFormatRMToModeset[ecx]
CLOSEPROC


;==============================================================================
;
; Function:     HW_MapGNTvFormatToHWTvFormat
;
; Purpose:      This function maps the Tv Format constants
;               TVTYPE_XXXX defined in modeext.h to the TV Format
;               constants NTSC_X and PAL_X defined in nvcm.h.
;
; Arguments:    ecx     Modeset Tv Format -- TVTYPE_XXX
;
; Returns:      ecx     RM Tv Format -- NTSC_X and PAL_X
;
; Preserve:     everything except ecx
;==============================================================================
DECPROC HW_MapGNTvFormatToHWTvFormat, PASCAL, FRAME, FAR32
OPENPROC
        cmp     ecx,TVTYPE_PALNC
        jbe     @F
        mov     ecx,TVTYPE_NTSCM
@@:     movzx   ecx,TableTvFormatModesetToRM[ecx]
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWCURSOR.ASM ===
;==============================================================================
;
; Copyright (C) 1997, Nvidia Coporation
;
; File:         hwcursor.asm
;
; Purpose:      This file implements the hardware specific code to
;               support the cursor.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include nvreg.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA


OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
PUBLIC  dwAlphaCursorsEnabled
dwAlphaCursorsEnabled   DD      0

; These are shifted left to shift the alpha bit into the MSB
PUBLIC  wConvert4bppTo15bpp
wConvert4bppTo15bpp     LABEL   WORD
        DW      0000H SHL 1,    4000H SHL 1,    0200H SHL 1,    4200H SHL 1
        DW      0010H SHL 1,    4010H SHL 1,    0210H SHL 1,    6318H SHL 1
        DW      4210H SHL 1,    7C00H SHL 1,    03E0H SHL 1,    7FE0H SHL 1
        DW      001FH SHL 1,    7C1FH SHL 1,    03FFH SHL 1,    7FFFH SHL 1


;==============================================================================
;
; Function:     HW_CursorEnable
;
; Purpose:      This function will turn the cursor on or off as specified
;               by the enable argument.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX
;               dwEnable                0 then turn cursor off
;                                       non-0 then turn cursor on
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CursorEnable_FAR32, PASCAL, FRAME, FAR32, LOGOFF
PARMD   pHWCrtcCXOffset
PARMD   dwEnable
OPENPROC
        push    pHWCrtcCXOffset
        push    dwEnable
        call    HW_CursorEnable
CLOSEPROC

DECPROC HW_CursorEnable, PASCAL, FRAME, NEAR, LOGOFF
PARMD   pHWCrtcCXOffset
PARMD   dwEnable
OPENPROC
        mov     ebx,pHWCrtcCXOffset
        or      ebx,ebx
        je      DoneIt
        mov     eax,ds:[ebx].HWCRTCCX.pHWBoardCX
        cmp     dwEnable,1
        sbb     ecx,ecx
        and     ecx,NV_CURSOR_DISABLE - NV_CURSOR_ENABLE
        add     ecx,NV_CURSOR_ENABLE
        or      ecx,NV_CURSOR_SET_ENABLE
        push    ecx
        push    ecx
        push    ecx
        push    ecx
        pushd   0
        push    ds:[eax].HWBOARDCX.dwDeviceNum
        push   ds:[ebx].HWCRTCCX.dwPhysicalCRTCInstance
        call    FFP16 PTR lpfnNvSysSetCursorImage
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:     HW_CursorSet
;
; Purpose:      This function places a cursor pattern in offscreen video
;               memory. It does not make this new pattern the active
;               cursor, nor should it change the state of the cursor
;               on/off. Remember that the cursor can be many different
;               color depths -- you need to convert it to the color
;               depth in which you store the cursor in video memory.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX
;               dwCursorCacheSlot       0 based cache slot
;               pCursorDesc             CURSORDESC ptr
;
; Returns:
;               eax                     Any piece of data the hardware
;                                       wants passed back in on other
;                                       calls ....
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CursorSet, PASCAL, FRAME, NEAR, LOGOFF
PARMD   pHWCrtcCXOffset
PARMD   dwCursorCacheSlot
PARMD   pCursorDesc
LOCALD  dwCursorHWType
OPENPROC
        PUSHR   esi,edi
        mov     ebx,pHWCrtcCXOffset
        or      ebx,ebx
        je      DoneIt

        mov     ecx,ds:[ebx].HWCRTCCX.pHWBoardCX

IF  (USE_ALPHA_CURSOR NE 0)
        ; If this is at least an NV10, then we can try to use alpha
        cmp     ds:[ecx].HWBOARDCX.dwDeviceVersion,NV_DEVICE_VERSION_10
        jl      Is1555Cursor

        ; Revision BX MUST use the 32bit cursor beause of the DFP
        ; downscale dither using the 16bpp cursor cycles
        mov     eax,ds:[ecx].HWBOARDCX.dwDeviceRevision
        and     eax,0F0H
        cmp     eax,0B0H
        jne     Is1555Cursor

        ; Try to set an 8888 cursor.
        push    pHWCrtcCXOffset
        push    dwCursorCacheSlot
        push    pCursorDesc
        call    HW_CursorSet8888
        mov     dwCursorHWType,ebx
        
        or      eax,eax
        jne     SetRet

Is1555Cursor:
        mov     ebx,pHWCrtcCXOffset
        mov     ecx,ds:[ebx].HWCRTCCX.pHWBoardCX
ENDIF

        ; Get a ptr to the place to store the cursor pattern, and then
        ; call the correct routine to convert the incoming cursor
        ; pattern to the hardware format and store it in vram.
        mov     edi,dwCursorCacheSlot
        imul    edi,HW_CURSOR_SIZE
        add     edi,ds:[ecx].HWBOARDCX.pVideoMemory
        add     edi,ds:[ebx].HWCRTCCX.dwCursorCacheVramOffset
        mov     esi,pCursorDesc
        mov     dwCursorHWType,NV067_SET_CURSOR_IMAGE_FORMAT_COLOR_LE_ROP1R5G5B5

        push    OFFSET SetRet
        mov     al, ds:[esi].CURSORDESC.bBitsPerPixel
        cmp     al,01H
        je      SetCursor_1Bpp_1555
        cmp     al,10H
        je      SetCursor_16Bpp_1555
        cmp     al,20H
        je      SetCursor_32Bpp_1555
        cmp     al,04H
        je      SetCursor_4Bpp_1555
        cmp     al,18H
        je      SetCursor_24Bpp_1555
        cmp     al,0FH
        je      SetCursor_15Bpp_1555
        cmp     al,08H
        je      SetCursor_8Bpp_1555
        pop     eax

SetRet:
DoneIt:        
                mov     eax,dwCursorHWType
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_CursorSelect
;
; Purpose:      This function will select one of the cached cursors
;               to be the currently active cursor. It should not change
;               the state of the cursor on/off.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX
;               dwCursorCacheSlot       0 based cache slot
;               dwCursorHWType          returned from HW_CursorSet
;               pCursorDesc             CURSORDESC ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CursorSelect, PASCAL, FRAME, NEAR, LOGOFF
PARMD   pHWCrtcCXOffset
PARMD   dwCursorCacheSlot
PARMD   dwCursorHWType
PARMD   pCursorDesc
OPENPROC
        PUSHR   esi
        mov     ebx,pHWCrtcCXOffset
        or      ebx,ebx
        je      DoneIt
        mov     ecx,ds:[ebx].HWCRTCCX.pHWBoardCX

        mov     eax,dwCursorCacheSlot
        imul    eax,HW_CURSOR_SIZE
        add     eax,ds:[ebx].HWCRTCCX.dwCursorCacheVramOffset
        mov     esi,ds:[ebx].HWCRTCCX.dwPhysicalCRTCInstance
        mov     ebx,pCursorDesc

        ; Call the RM to select the correct cursor
        pushd   NV_CURSOR_SET_PARAM
        push    eax                                     ; Cursor Offset
        movzx   edx,ds:[ebx].CURSORDESC.wWidth
        push    edx
        movzx   edx,ds:[ebx].CURSORDESC.wHeight
        push    edx
        push    dwCursorHWType
        push    ds:[ecx].HWBOARDCX.dwDeviceNum
        push   esi
        call    FFP16 PTR lpfnNvSysSetCursorImage
DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_CursorMove
;
; Purpose:      This function should move the cursor to the location
;               specified. Do not change the on/off state of the cursor.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX
;               dwYCoordHiXCoordLo      Ycoord:XCoord
;               dwYSpotHiXSpotLo        HotSpotY:HotSpotX (0-63:0-63)
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CursorMove, PASCAL, FRAME, NEAR, LOGOFF
PARMD   pHWCrtcCXOffset
PARMD   dwYCoordHiXCoordLo
PARMD   dwYSpotHiXSpotLo
OPENPROC
        mov     ebx,pHWCrtcCXOffset
        or      ebx,ebx
        je      DoneIt
        mov     ecx,ds:[ebx].HWCRTCCX.pHWBoardCX

        mov     eax,dwYCoordHiXCoordLo
        sub     ax,word ptr dwYSpotHiXSpotLo
        ror     eax,10H
        sub     ax,word ptr dwYSpotHiXSpotLo + 2
        push    eax
        push    ds:[ecx].HWBOARDCX.dwDeviceNum
        push    ds:[ebx].HWCRTCCX.dwPhysicalCRTCInstance
        call    FFP16 PTR lpfnNvSysMoveCursor
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_1Bpp_1555
;
; Purpose:      This function places a 1Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_1Bpp_1555, PASCAL, FRAME, NEAR, LOGOFF
LOCALD  dwAndMaskSize
OPENPROC
        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        shr     ecx,3                          ; CX = bytes in the AND mask
        mov     [dwAndMaskSize],ecx
        shr     ecx,2                          ; CL = dwords of pixel data
        lea     esi,[esi].CURSORDESC.bCursorAndMask

Next_Dword:
        mov     ebx,[dwAndMaskSize]
        mov     eax,ds:[esi]                   ; EAX = 32 bits of AND mask
        mov     ebx,ds:[esi + ebx]             ; EBX = 32 bits of pixel data
        add     esi,4                          ; Src ptr++
        not     eax
        mov     ch,16                          ; One dword takes 16 passes
        bswap   eax
        bswap   ebx

Cont_Dword:
        add     ebx,ebx                        ; Carry = SHL pixel data
        sbb     dx,dx                          ; DX == 0000 or FFFF
        add     eax,eax                        ; Carry = SHL AND mask
        rcr     dx,1                           ; MSB of DX == ROP
        ror     edx,10H                        ; Save in the high word of EDX
        add     ebx,ebx                        ; Carry = SHL pixel data
        sbb     dx,dx                          ; DX == 0000 or FFFF
        add     eax,eax                        ; Carry = SHL AND mask
        rcr     dx,1                           ; MSB of DX == ROP
        ror     edx,10H                        ; Rstore the order of the 2 pixels
        mov     ds:[edi],edx                   ; Save the two pixels
        add     edi,4                          ; Increment the destination
        dec     ch
        jne     Cont_Dword
        dec     cl
        jne     Next_Dword
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_4Bpp_1555
;
; Purpose:      This function places a 4Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_4Bpp_1555, PASCAL, NOFRAME, NEAR, LOGOFF
OPENPROC
        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     ebx,[esi + ecx]                ; EBX = ptr to pixel data
        shr     ecx,2                          ; CL = dwords of mask data

Next_Dword:
        ; 4bpp case
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; increment AND mask pointer
        not     edx
        mov     ch,(32/2)                      ; 16 pairs of 4bpp pixels per 32 bit AND
        bswap   edx

        ; This loop decodes one dword of AND mask,
        ; 32 pixel or 16 bytes of pixel data
Cont_Dword:
        movzx   eax,byte ptr ds:[ebx]
        shr     eax,4                          ; EAX = first 4bpp pixel in byte
        mov     ax,cs:wConvert4bppTo15bpp[eax * 2]
        add     edx,edx                        ; Put AND bit in CARRY
        rcr     ax,1                           ; Put AND bit in MSB of AX
        mov     ds:[edi],ax                    ; Save the 16bpp pixel
        movzx   eax,byte ptr ds:[ebx]
        inc     ebx                            ; Increment pixel pointer
        and     eax,0FH                        ; second 4bpp pixel in byte
        mov     ax,cs:wConvert4bppTo15bpp[eax * 2]
        add     edx,edx                        ; Put AND bit in CARRY
        rcr     ax,1                           ; Put AND bit in MSB of AX
        mov     ds:[edi+2],ax                  ; Save the 16bp pixel
        add     edi,4                          ; Increment the destination
        dec     ch
        jne     Cont_Dword
        dec     cl
        jne     Next_Dword
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_8Bpp_1555
;
; Purpose:      This function places a 8Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_8Bpp_1555, PASCAL, FRAME, NEAR, LOGOFF
LOCALB  bColumn
LOCALB  bRow
OPENPROC
        movzx   eax,ds:[esi].CURSORDESC.wHeight
        imul    ax,ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     eax,3                          ; AX = bytes in the AND mask
        lea     ebx,[ebx].HWCRTCCX.dwPaletteTable
        lea     ecx,[esi + eax]                ; DS:ECX -> cursor pixel data
        shr     eax,2                          ; AL = dwords of mask data
        mov     [bRow],al

Next_Dword:
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; next dword of AND mask
        not     edx
        mov     [bColumn],32                   ; Prepare to handle one dword
        bswap   edx                            ; Roll the bits off the left

Cont_Dword:
        movzx   eax,byte ptr ds:[ecx]          ; E:A:X = 0000:00:XX one pixel
        inc     ecx                            ; Next src pixel
        mov     eax,ds:[ebx][eax * 4]          ; EAX   = XRGB for 8bpp pixel
        shr     eax,3                          ; Convert to 5 bits of blue
        ror     eax,5                          ; EAX = 5B:X:8R:8G
        shr     ax,3                           ; EAX = 5B:X:8R:5G
        ror     eax,5                          ; EAX = 5G:5B:X:8R
        shr     ax,3                           ; EAX = 5G:5B:X:5R
        rol     eax,10                         ; AX  = X:5R:5G:5B
        add     ax,ax                          ; AX  = 5R:5G:5B:0
        add     edx,edx                        ; Carry <= SHL AND mask
        rcr     ax,1                           ; AX  = A:5R:5G:5B
        mov     ds:[edi],ax                    ; Store the new pixel
        add     edi,2                          ; Next dst pixel
        dec     [bColumn]
        jne     Cont_Dword
        dec     [bRow]
        jne     Next_Dword
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_15Bpp_1555
;
; Purpose:      This function places a 15Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_15Bpp_1555, PASCAL, NOFRAME, NEAR, LOGOFF
OPENPROC
        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx, ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     ebx,[esi + ecx]                ; DS:EBX -> cursor pixel data
        shr     ecx,2                          ; CL = dwords of mask data

Next_Dword:
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; next dword of AND mask
        not     edx
        mov     ch,(32 / 2)                    ; 2 pixels per iteration
        bswap   edx

Cont_Dword:
        mov     ax,ds:[ebx]                    ; AX = 1 pixel data
        add     ebx,2
        add     ax,ax
        add     edx,edx
        rcr     ax,1
        ror     eax,10H                        ; E:AX = A555:0000
        mov     ax,ds:[ebx]                    ; AX = 1 pixel data
        add     ebx,2
        add     ax,ax
        add     edx,edx
        rcr     ax,1
        ror     eax,10H                        ; E:AX = Pixel2:Pixel1
        mov     ds:[edi],eax                   ; Save both pixels
        add     edi,4                          ; Next dst pixel
        dec     ch
        jne     Cont_Dword
        dec     cl
        jne     Next_Dword
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_16Bpp_1555
;
; Purpose:      This function places a 16Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_16Bpp_1555, PASCAL, NOFRAME, NEAR, LOGOFF
OPENPROC
        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx, ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     ebx,[esi + ecx]
        shr     ecx,2                          ; CL = dwords of mask data

Next_Dword:
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; next dword of AND mask
        not     edx
        mov     ch,32                          ; Handle 1 pixel per iteration
        bswap   edx

Cont_Dword:
        movzx   eax,word ptr ds:[ebx]          ; Get one pixel
        add     ebx,2                          ; Increment source pointer
        ror     eax,5
        shr     ax,1
        rol     eax,5
        add     ax,ax
        add     edx,edx
        rcr     ax,1
        mov     ds:[edi],ax                    ; Save pixel
        add     edi,2                          ; Next dst pixel
        dec     ch
        jne     Cont_Dword
        dec     cl
        jne     Next_Dword
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_24Bpp_1555
;
; Purpose:      This function places a 24Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_24Bpp_1555, PASCAL, NOFRAME, NEAR, LOGOFF
OPENPROC
        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     ebx,[esi + ecx]
        shr     ecx,2                          ; CL = dwords of mask data

Next_Dword:
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; next dword of AND mask
        not     edx
        mov     ch,32                          ; 1 pixel per iteration
        bswap   edx

Cont_Dword:
        mov     al,ds:[ebx+2]
        shl     eax,10H
        mov     ax,ds:[ebx]                    ; EAX = 24 bpp pixel
        add     ebx,3                          ; Increment source pointer
        shr     eax,3
        ror     eax,5
        shr     ax,3
        ror     eax,5
        shr     ax,3
        rol     eax,11                         ; AX = 555X pixel
        add     edx,edx
        rcr     ax,1                           ; AX = R555
        mov     ds:[edi],ax                    ; Save pixel
        add     edi,2                          ; Next dst pixel
        dec     ch
        jg      Cont_Dword
        dec     cl
        jg      Next_Dword
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_32Bpp_1555
;
; Purpose:      This function places a 32Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_32Bpp_1555, PASCAL, NOFRAME, NEAR, LOGOFF
OPENPROC
        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     ebx,[esi + ecx]
        shr     ecx,2                          ; CL = dwords of mask data

Next_Dword:
        ; 32bpp case
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; next dword of AND mask
        not     edx
        mov     ch,32                          ; Handle 1 pixel per iteration
        bswap   edx

Cont_Dword:
        mov     eax,ds:[ebx]                   ; EAX = 32 bpp pixel
        add     ebx,4                          ; Increment source pointer
        shr     eax,3
        ror     eax,5
        shr     ax,3
        ror     eax,5
        shr     ax,3
        rol     eax,11                         ; AX = 555X
        add     edx,edx
        rcr     ax,1                           ; AX = R555
        mov     ds:[edi],ax                    ; Save pixel
        add     edi,2
        dec     ch
        jg      Cont_Dword
        dec     cl
        jg      Next_Dword
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWCNTRL.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation
;
; File:         hwcntrl.asm
;
; Purpose:      This file implements hardware-specific escape support.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include nvcm.inc
include escape.inc
include nv32.inc
include hwlogdev.inc
include hwcrtc.inc
include hwboard.inc

CONTROL_FRAME_AND_LOCALS        MACRO
PARMD   pHWLogdevCXOffset
PARMD   lpDstDev
PARMW   wFunction
PARMD   lpIn
PARMD   lpOut
ENDM

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     HW_ControlQuery
;
; Purpose:      This function implements a hardware specific escape call
;               when it is already known that the call is a QUERYESCSUPPORT.
;               The generic code did not recognize the escape function in
;               the first word of the lpIn structure and so passed it on.
;
; Arguments:    Control Display Driver Stack Frame
;               ds      Context Selector
;
; Returns:      ecx     0   queried-escape was not recognized
;                       1   queried-escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds
;==============================================================================
DECPROC HW_ControlQuery, PASCAL, FRAME, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     ebx,ebx
        les     bx,lpIn
        mov     ecx,1
        movzx   edx,word ptr es:[ebx]

        cmp     edx,NV_ESC_INTEL_DIAG
        jne     @F
        mov     eax,1
        jmp     Done
@@:
        ; Unrecognized query escape
        sub     ecx,ecx
Done:
CLOSEPROC


;==============================================================================
;
; Function:     HW_ControlAction
;
; Purpose:      This function implements a hardware specific escape call.
;               The generic code did not recognize the escape number and
;               so passed it on.
;
; Arguments:    Control Display Driver Stack Frame
;
; Returns:      ecx     0   escape was not recognized
;                       1   escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds
;==============================================================================
DECPROC HW_ControlAction, PASCAL, FRAME, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        movzx   eax,wFunction

        push    OFFSET ReturnAddr
        cmp     eax,NV_ESC_DMAPUSHMODESWITCHCOUNT
        je      NV_GetFlatModeSwitchPtrCount
        cmp     eax,NV_ESC_GETACTIVECHANNELPTR
        je      NV_GetFlatActiveChannelPtr
IFDEF   NV_ESCAPE_ID
        cmp     eax,NV_ESCAPE_ID
        je      NV_GetEscapeID
ENDIF
        cmp     eax,NV_ESC_IS_NVIDIA_BOARD_AND_DRIVER
        je      NV_IsNvidiaBasedBoardAndDiver
        cmp     eax,NV_ESC_GET_HARDWARE_POINTERS
        je      NV_GetHardwarePointers
        cmp     eax,NV_ESC_GET_FLAT_DIRECTX_SHARED_DATA
        je      NV_GetFlatDirectXSharedData
        cmp     eax,NV_ESC_INC_MODE_SWITCH
        je      NV_IncModeSitchCounter
        cmp     eax,NV_ESC_INTEL_DIAG
        je      NV_IntelDiags
        add     sp,@WordSize
        sub     ecx,ecx
        jmp     Done

ReturnAddr:
Done:
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetFlatModeSwitchPtrCount
;
; Purpose:      This function returns a flat ptr to the mode switch
;               count variable that open gl uses to track modeswitch
;               state and changes.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;
; Returns:      ecx     0   escape was not recognized
;                       1   escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds
;==============================================================================
DECPROC NV_GetFlatModeSwitchPtrCount, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     esi,pHWLogdevCXOffset
        mov     edi,ds:[esi].HWLOGDEVCX.pHWBoardCX

        mov     ax,ds
        push    ax
        call    GetSelectorBase
        shl     edx,10H
        mov     dx,ax
        lea     eax,[edi].HWBOARDCX.dwModeSwitchCount
        add     eax,edx

        sub     edi,edi
        les     di,lpOut
        mov     es:[edi],eax
        mov     eax,1
        mov	ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetFlatActiveChannelPtr
;
; Purpose:      This function returns a flat ptr to the current
;               channelID variable that is used to sync between
;               channels.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;
; Returns:      ecx     0   escape was not recognized
;                       1   escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds
;==============================================================================
DECPROC NV_GetFlatActiveChannelPtr, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     esi,pHWLogdevCXOffset
        mov     edi,ds:[esi].HWLOGDEVCX.pHWBoardCX

        mov     ax,ds
        push    ax
        call    GetSelectorBase
        shl     edx,10H
        mov     dx,ax
        mov     eax,[edi].HWBOARDCX.pCurrentChannelID
        add     eax,edx

        sub     edi,edi
        les     di,lpOut
        mov     es:[edi],eax
        mov     eax,1
        mov	ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetEscapeID
;
; Purpose:      This function returns a constant indicating that
;               this is an NVIDIA driver (as opposed to an OEM
;               driver based upon nvidia source).
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;
; Returns:      ecx     0   escape was not recognized
;                       1   escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds
;==============================================================================
DECPROC NV_GetEscapeID, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        sub     eax,eax
        cmp     eax,lpOut
        je      @F
        sub     edi,edi
        les     di,lpOut
        mov     dword ptr es:[edi],NV_ESCAPE_ID_RETURN
        mov     eax,1
@@:
        mov	ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_IsNvidiaBasedBoardAndDiver
;
; Purpose:      This function returns a constant indicating that
;               this is an NVIDIA based board and driver (it might
;               be nvidia's own board and driver or a customers
;               modified driver and board).
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;
; Returns:      ecx     0   escape was not recognized
;                       1   escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds
;==============================================================================
DECPROC NV_IsNvidiaBasedBoardAndDiver, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     esi,pHWLogdevCXOffset
	push	ds:[esi].HWLOGDEVCX.pHWCrtcCX
	call	HW_GetPhysicalCrtcIndex

        sub     edi,edi
        les     di,lpOut
        mov     dword ptr es:[edi],NV_ESC_IS_NVIDIA_BOARD_AND_DRIVER
        mov     ebx,ds:[esi].HWLOGDEVCX.pHWBoardCX
        mov     ecx,ds:[ebx].HWBOARDCX.dwDeviceNum
        mov     es:[edi + 4],ecx
        mov     es:[edi + 8],eax
        mov     eax,1
        mov	ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetHardwarePointers
;
; Purpose:      This function returns a ptr to the screen and
;               the linear base of the chip registers.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;
; Returns:      ecx     0   escape was not recognized
;                       1   escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds
;==============================================================================
DECPROC NV_GetHardwarePointers, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     esi,pHWLogdevCXOffset
        mov     esi,ds:[esi].HWLOGDEVCX.pHWBoardCX

        sub     edi,edi
        les     di,lpOut

        sub     eax,eax
        mov     es:[edi].HARDWAREPOINTERS.lp16Chip,eax
        mov     eax,ds:[esi].HWBOARDCX.dwVideoMemorySel
        shl     eax,10H
        mov     es:[edi].HARDWAREPOINTERS.lp16FrameBuffer,eax
        mov     eax,ds:[esi].HWBOARDCX.pVideoMemory
        mov     es:[edi].HARDWAREPOINTERS.lp32FrameBuffer,eax
        mov     eax,ds:[esi].HWBOARDCX.pChipRegs
        mov     es:[edi].HARDWAREPOINTERS.lp32Chip,eax
        mov     eax,1
        mov	ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetFlatDirectXSharedData
;
; Purpose:      This function returns a flat ptr to the
;               DirectX shared data structure.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;
; Returns:      ecx     0   escape was not recognized
;                       1   escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds
;==============================================================================
DECPROC NV_GetFlatDirectXSharedData, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     esi,pHWLogdevCXOffset

        push    word ptr ds:[esi].HWLOGDEVCX.lpDirectXSharedData+2
        call    GetSelectorBase
        shl     edx,10H
        mov     dx,ax
        xor     edi,edi
        les     di,lpOut
        mov     es:[edi],edx
        mov     eax,1
        mov	ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_IncModeSitchCounter
;
; Purpose:      This function increments the mode switch counter.
;               It is used for testing OGL stuff.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;
; Returns:      ecx     0   escape was not recognized
;                       1   escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds
;==============================================================================
DECPROC NV_IncModeSitchCounter, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        mov     esi,pHWLogdevCXOffset
        mov     esi,ds:[esi].HWLOGDEVCX.pHWBoardCX
        inc     ds:[esi].HWBOARDCX.dwModeSwitchCount

        cmp     lpOut,0
        je      @F
        sub     edi,edi
        les     di,lpOut
        mov     eax,ds:[esi].HWBOARDCX.dwModeSwitchCount
        mov     es:[edi],eax
@@:
        mov     eax,1
        mov	ecx,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_IntelDiags
;
; Purpose:      This function is a set of Intel diagnostics.
;               Intel requires this Escape and diagnostics in
;               order to purchase our boards.
;
; Arguments:    Control Display Driver Stack Frame
;               ds              Context Selector
;
; Returns:      ecx     0   escape was not recognized
;                       1   escape was recognized
;                           in this case, ax has the value to return to GDI
;
; Preserve:     ds
;==============================================================================
DECPROC NV_IntelDiags, PASCAL, ShareFrameNear16, NEAR
CONTROL_FRAME_AND_LOCALS
OPENPROC
        push    pHWLogdevCXOffset
        push    lpIn
        push    lpOut
        call    NV_IntelDiagnostics
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWINIT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwinit.asm
;
; Purpose:      This file does hardware specific initialization that
;               needs to be done before anything else in the driver
;               executes. Also, it holds the routine that gets called
;               just before the driver DLL unloads (the WEP) routine.
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include files.inc
include hwmacs.inc
include nvcm.inc
include nvreg.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include ..\..\..\..\..\sdk\nvidia\inc\nvrmarch.inc
include ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc

OPENSEG  _DATA, USE16, DATA
szNvSysDll              DB      NV4_RM_16_BINARY,0
CLOSESEG _DATA


OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
PUBLIC  NvSysTable
NvSysTable      LABEL   WORD
DW      OFFSET szNvSysDll, SEG szNvSysDll
hNvSysDll                       DW      0
lpfnNvSysMoveCursor             MODULELINK      <0, ORD_NvSysMoveCursorMulti>
lpfnNvSysUpdateImageOffsetFormat MODULELINK     <0, ORD_NvSysUpdateImageOffsetFormat>
lpfnNvSysGetRamInfo             MODULELINK      <0, ORD_NvSysGetRamInfo>
lpfnNvSysAllocPages             MODULELINK      <0, ORD_NvSysAllocPages>
lpfnNvSysFreePages              MODULELINK      <0, ORD_NvSysFreePages>
lpfnNvConfigGet                 MODULELINK      <0, ORD_NvConfigGet>
lpfnNvConfigSet                 MODULELINK      <0, ORD_NvConfigSet>
lpfnNvConfigUpdate              MODULELINK      <0, ORD_NvConfigUpdate>
lpfnNvConfigVga                 MODULELINK      <0, ORD_NvConfigVga>
lpfnNvSysSetCursorImage         MODULELINK      <0, ORD_NvSysSetCursorImageMulti>
lpfnNvSysGetHardwarePointers    MODULELINK      <0, ORD_NvSysGetHardwarePointers>
lpfnNvDeviceBaseGet             MODULELINK      <0, ORD_NvDeviceBaseGet>
lpfnNvDeviceLimitGet            MODULELINK      <0, ORD_NvDeviceLimitGet>
lpfnNvSysDriverConnect          MODULELINK      <0, ORD_NvSysDriverConnect>
lpfnNvSysDriverDisConnect       MODULELINK      <0, ORD_NvSysDriverDisConnect>
lpfnNvSysRegisterDisplayDriver  MODULELINK      <0, ORD_NvSysRegisterDisplayDriver>
lpfnNvIoControl                 MODULELINK      <0, ORD_NvIoControl>
lpfnArch_Nv01Free               MODULELINK      <0, ORD_Nv01Free>
lpfnArch_Nv01AllocRoot          MODULELINK      <0, ORD_Nv01AllocRoot>
lpfnArch_Nv01AllocMemory        MODULELINK      <0, ORD_Nv01AllocMemory>
lpfnArch_Nv01AllocContextDma    MODULELINK      <0, ORD_Nv01AllocContextDma>
lpfnArch_Nv01AllocChannelPio    MODULELINK      <0, ORD_Nv01AllocChannelPio>
lpfnArch_Nv01AllocObject        MODULELINK      <0, ORD_Nv01AllocObject>
lpfnArch_Nv01AllocDevice        MODULELINK      <0, ORD_Nv01AllocDevice>
lpfnArch_Nv03AllocChannelDma    MODULELINK      <0, ORD_Nv03AllocChannelDma>
lpfnArch_Nv03DmaFlowControl     MODULELINK      <0, ORD_Nv03DmaFlowControl>
lpfnArch_Nv01Interrupt          MODULELINK      <0, ORD_Nv01Interrupt>
lpfnArch_Nv01AllocEvent         MODULELINK      <0, ORD_Nv01AllocEvent>
lpfnArch_NvI2CAccess            MODULELINK      <0, ORD_NvI2CAccess>
lpfnArch_Nv04ConfigGetEx        MODULELINK      <0, ORD_Nv04ConfigGetEx>
lpfnArch_Nv04ConfigSetEx        MODULELINK      <0, ORD_Nv04ConfigSetEx>
lpfnArch_Nv04Alloc              MODULELINK      <0, ORD_Nv04Alloc>
                                MODULELINK      <0, 0>
CLOSESEG _NVTEXT32

OPENSEG  _NVTEXT16, USE16, CODE
;==============================================================================
;
; Function:     HW_CreateConstants
;
; Purpose:      This functions should init any things that are
;               effectively constants in the driver. Usually these
;               are items that go in the code segment. This routine
;               is called only once at boot and no context has yet
;               been created.
;
; Arguments:    None
;
; Returns:      eax     0       Failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CreateConstants, PASCAL, FRAME, FAR16
OPENPROC
        PUSHR   ds,esi
        mov     ds,wNVTEXT32_Alias_In_NVTEXT16
        lea     esi,NvSysTable
        call    GN_LoadDllAndGetExports
        POPR    ds,esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_DestroyConstants
;
; Purpose:      This functions should destroy any "constants"
;               created by the CreateConstants routine. This
;               routine is called once when the driver is about
;               to be unloaded.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_DestroyConstants, PASCAL, FRAME, FAR16
PARMD   dwThisLogDeviceHandle
OPENPROC
        ; In multi-monitor applications, the secondary device must not
        ; attempt to unload the Dlls, otherwise the system will gpf on
        ; a windows 'quick-boot' (shift-enter on restart). We are
        ; assuming that the primary device has a device handle of 1.
        cmp     dwThisLogDeviceHandle,1
        jne     SkipDllUnload

        ; Unload the RM 16bit dll.
        mov     es,wNVTEXT32_Alias_In_NVTEXT16
        push    es:[hNvSysDll]
        mov     es:[hNvSysDll],0
        call    FreeLibrary
SkipDllUnload:
CLOSEPROC


;==============================================================================
;
; Function:     HW_AllocFlatMemory
;
; Purpose:      This routine buys memory in VDD land (3Gig-4Gig),
;               zeros it out and returns a flat ptr to it.
;
; Arguments:
;               dwAmount                How much to buy
;
; Returns:
;               eax     Flat ptr to memory block
;                       0 if failure
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_AllocFlatMemory, PASCAL, FRAME, FAR16
PARMD   dwAmount
LOCALV  rmRegs,RMPARAMS
OPENPROC
        mov     rmRegs.RegECX,MVDD_ALLOC_MEMORY_BLOCK
        mov     eax,dwAmount
        mov     rmRegs.RegEDX,eax
        mov     ax,ss
        lea     ebx,rmRegs
        push    ax
        push    bx
        CALLFAR16IND lpfnNvSysRegisterDisplayDriver,es,ax
        mov     eax,rmRegs.RegEAX
CLOSEPROC


;==============================================================================
;
; Function:     HW_FreeFlatMemory
;
; Purpose:      This routine frees a memory block allocated
;               via HW_AllocFlatMemory
;
; Arguments:
;               pFlatMem                ptr to memory to free
;
; Returns:
;               eax     Flat ptr to memory block
;                       0 if failure
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_FreeFlatMemory, PASCAL, FRAME, FAR16
PARMD   pFlatMem
LOCALV  rmRegs,RMPARAMS
OPENPROC
        mov     rmRegs.RegECX,MVDD_FREE_MEMORY_BLOCK
        mov     eax,pFlatMem
        mov     rmRegs.RegEDX,eax
        mov     ax,ss
        lea     ebx,rmRegs
        push    ax
        push    bx
        CALLFAR16IND lpfnNvSysRegisterDisplayDriver,es,ax
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetLogdevToBoardPtr
;
; Purpose:      This function gets the shared block of memory used
;               for managing logical device to board instance stuff.
;               The memory must be shared across all driver contexts.
;
; Arguments:	None
;
; Returns:      eax                     context ptr to shared memory
;               THIS ROUTINE CANNOT FAIL.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetLogdevToBoardPtr, PASCAL, FRAME, FAR16
LOCALV  rmRegs,RMPARAMS
OPENPROC
        mov     rmRegs.RegECX,MVDD_GET_LOGDEV_SHARED_MEMORY
        mov     ax,ss
        lea     ebx,rmRegs
        push    ax
        push    bx
        CALLFAR16IND lpfnNvSysRegisterDisplayDriver,es,ax
        mov     eax,rmRegs.RegEAX
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWCRTC.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwcrtc.asm
;
; Purpose:      This file contains all the hardware specific CRTC
;               specific routines for init. The crtc specific run-
;               time routines are in hwcrtc2.asm.
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include files.inc
include hwmacs.inc
include nvcm.inc
include nvreg.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include modeext.inc
include ..\..\..\..\..\sdk\nvidia\inc\nvrmarch.inc
include ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

IFDEF DEBUG
szCreate        DB      'DISPLAY:HW_CreateCrtcContext',0DH,0AH,0
szDestroy       DB      'DISPLAY:HW_DestroyCrtcContext',0DH,0AH,0
ENDIF

;==============================================================================
;
; Function:     HW_CreateCrtcContext
;
; Purpose:      This routine allocates memory for and initializes
;               a HWCRTCCX structure.
;
; Arguments:
;               ds                      The context selector.
;               pHWBoardCXOffset        HWBOARDCX ptr
;
; Returns:      eax     0       failure
;                       non-0   HWCRTCCX ptr
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CreateCrtcContext, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
OPENPROC
        PUSHR   esi,edi

        sub     esi,esi
        pushd   SIZE HWCRTCCX
        call    HW_AllocFlatMemory
        or      eax,eax
        je      DoneIt
        mov     esi,eax

        ; We are initting
        mov     ds:[esi].HWCRTCCX.dwInitting,1

        ; Save the HWBoardCX owning this CRTC
        mov     edi,pHWBoardCXOffset
        mov     ds:[esi].HWCRTCCX.pHWBoardCX,edi

        ; For the rest of init, just assume head 0. It won't
        ; matter. This will all get updated later.
        mov     ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance,0

        ; We may not be head 0, but that doesn't really matter.
        ; We just need to get the max cacheable cursors, which
        ; we will assume is the same for both heads. The cursor
        ; cache offset will actually be regotten later so if
        ; the head is different it won't matter.
        push    pHWBoardCXOffset
        pushd   0
        call    NV_GetCursorCacheInfo
        mov     ds:[esi].HWCRTCCX.dwCursorCacheVramOffset,eax
        mov     ds:[esi].HWCRTCCX.dwMaxCachedCursors,ebx

        ; Determine the cursor alpha value... Init to -1 for now
        mov     ds:[esi].HWCRTCCX.dwCursorAlpha,-1

        ; Get the encoder information
        push    esi
        call    NV_GetEncoderInfo

        ; Now set it to -1 to show there is no instance
        mov     ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance,-1

IFDEF DEBUG
        mov     ax,cs
        shl     eax,10H
        lea     ax,szCreate
        push    eax
        call    GENERIC_OutputDebugString
ENDIF

        mov     eax,esi

DoneIt:
        ; If eax is 0, then we failed, BUT if esi is non-0, then
        ; some of the HWCRTCCX was filled in. We must handle
        ; this case and free any portion that got initted.
        or      eax,eax
        jne     ExitIt
        or      esi,esi
        je      ExitIt

        ; HW_DestroyBoardContext can clean up partial inits
        push    esi
        call    HW_DestroyCrtcContext
        sub     eax,eax

ExitIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_DestroyCrtcContext
;
; Purpose:      This routine allocates memory for and initializes
;               an array of HWCRTCCX structure.
;
; Arguments:
;               ds              The context selector.
;               pHWCrtcCXOffset offset of HWCRTCCX to destroy.
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_DestroyCrtcContext, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      DoneIt

IFDEF DEBUG
        mov     ax,cs
        shl     eax,10H
        lea     ax,szDestroy
        push    eax
        call    GENERIC_OutputDebugString
ENDIF

        push    esi
        call    NV_FreeHeadRelatedInfo

        ; Clear out the HWBoard ptr
        mov     ds:[esi].HWCRTCCX.pHWBoardCX,0

        push    esi
        call    HW_FreeFlatMemory

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocHeadRelatedInfo
;
; Purpose:      This routine allocates all head related info. This
;               include the VidLutCursorDac and the physical CRTC.
;
; Arguments:
;               ds                      The context selector.
;               pHWCrtcCXOffset         HWCRTCCX ptr
;               dwPhysicalHead          physical head to use
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocHeadRelatedInfo, PASCAL, FRAME, NEAR
PARMD   pHWCrtcCXOffset
PARMD   dwPhysicalHead
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      DoneIt

        mov     eax,dwPhysicalHead
        mov     ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance,eax
        mov     edi,ds:[esi].HWCRTCCX.pHWBoardCX

        ; Ask the board for the cursor cache offset and the
        ; maximum size of the cursor cache ...
        push    edi
        push    ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        call    NV_GetCursorCacheInfo
        mov     ds:[esi].HWCRTCCX.dwCursorCacheVramOffset,eax
        mov     ds:[esi].HWCRTCCX.dwMaxCachedCursors,ebx

        ; Allocate a VideoLutCursorDac object (this shouldn't fail)
        call    CreateVideoLutCursorDac
DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_FreeHeadRelatedInfo
;
; Purpose:      This routine frees all head related info. This
;               include the VidLutCursorDac and the physical CRTC.
;
; Arguments:
;               ds                      The context selector.
;               pHWCrtcCXOffset         HWCRTCCX ptr
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_FreeHeadRelatedInfo, PASCAL, FRAME, NEAR
PARMD   pHWCrtcCXOffset
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      DoneIt

        mov     edi,ds:[esi].HWCRTCCX.pHWBoardCX
        call    DestroyVideoLutCursorDac

        mov     ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance,-1
DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_CrtcSetLogdev
;
; Purpose:      This routine tells the crtc what logical device
;               owns it.
;
; Arguments:
;               ds                      The context selector.
;               pHWCrtcCXOffset         HWCRTCCX ptr
;               pHWLogdevCXOffset       HWLOGDEVCX ptr
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_CrtcSetLogdev, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   pHWLogdevCXOffset
OPENPROC
        mov     ebx,pHWCrtcCXOffset
        or      ebx,ebx
        je      SkipSet
        mov     eax,pHWLogdevCXOffset
        mov     ds:[ebx].HWCRTCCX.pHWLogdevCX,eax
SkipSet:
CLOSEPROC


;==============================================================================
;
; Function:     NV_GetEncoderInfo
;
; Purpose:      This routine gets the Encoder type on the card and
;               the I2C address at which it is located.
;
; Arguments:
;               ds                      The context selector.
;               pHWCrtcCXOffset         HWCRTCCX ptr
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_GetEncoderInfo, PASCAL, FRAME, NEAR
PARMD   pHWCrtcCXOffset
LOCALV  sVidTypeParams,NV_CFGEX_VIDEO_ENCODER_TYPE_PARAMS
LOCALV  sVidIDInfoParams,NV_CFGEX_VIDEO_ENCODER_ID_PARAMS
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      SkipGet
        mov     edi,ds:[esi].HWCRTCCX.pHWBoardCX

        ; Get the CRTC head number.
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        mov     sVidTypeParams.Head,eax
        mov     sVidIDInfoParams.Head,eax

        ; Get the encoder type
        mov     ax,ss
        shl     eax,10H
        lea     ax,sVidTypeParams
        mov     ebx,SIZE NV_CFGEX_VIDEO_ENCODER_TYPE_PARAMS
        mov     ecx,NV_CFGEX_VIDEO_ENCODER_TYPE
        push    esi
        mov     esi,edi
        call    NV_ConfigExCall
        pop     esi
        mov     eax,sVidTypeParams.EncoderdwType
        mov     ds:[esi].HWCRTCCX.dwTVOutDeviceID,eax

        mov     ax,ss
        shl     eax,10H
        lea     ax,sVidIDInfoParams
        mov     ebx,SIZE NV_CFGEX_VIDEO_ENCODER_ID_PARAMS
        mov     ecx,NV_CFGEX_VIDEO_ENCODER_ID
        push    esi
        mov     esi,edi
        call    NV_ConfigExCall
        pop     esi
        mov     eax,sVidIDInfoParams.EncoderID
        shr     eax,1
        mov     ds:[esi].HWCRTCCX.dwTVOutDeviceAddr,eax

SkipGet:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetMaxTVOutResolution
;
; Purpose:      Find out the maximum resolution for Encoder
;
; Arguments:
;               ds                      The context selector.
;               pHWCrtcCXOffset         HWCRTCCX ptr
;
; Returns:      eax     XRes, YRes
;               ebx     TVEncoder ID
;
;==============================================================================
DECPROC HW_GetMaxTVOutResolution, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
OPENPROC
        mov     ecx,pHWCrtcCXOffset

        ; Set 1024X768 for Brooktree 871
        mov     eax,04000300h
        mov     ebx,ds:[ecx].HWCRTCCX.dwTVOutDeviceID
        cmp     ebx,NV_ENCODER_BROOKTREE_871
        je      @F
        ; Default 800X600
        mov     eax,03200258h
@@:
CLOSEPROC



;==============================================================================
;
; Function:     CreateVideoLutCursorDac
;
; Purpose:      This function creates a VideoLutCursorDac object
;               for use in the WIN_CHANNEL.
;
; Arguments:
;               ds:esi  HWCRTCCX
;               ds:edi  HWBOARDCX
;
; Returns:
;               eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi
;==============================================================================
DECPROC CreateVideoLutCursorDac, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Allocate a Context DMA for the VidLutCurDac notifier
        mov     ds:[esi].HWCRTCCX.bNotifierCreated,0
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     eax,OBJ_VIDEO_LUT_CURSOR_DAC_NOTIFIER
        push    edi
        push    eax
        lea     ebx,[esi].HWCRTCCX.sVideoLutCursorDacNotifier0
        push    ebx
        mov     ax,ds
        push    eax
        pushd   9 * (SIZE NvNotification)
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY
        call    NV_AllocContextDma
        or      eax,eax
        je      DoneIt
        mov     ds:[esi].HWCRTCCX.bNotifierCreated,1

        ; Allocate a Context DMA for the Palette
        mov     ds:[esi].HWCRTCCX.bPaletteContextDmaCreated,0
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     eax,OBJ_DMA_IN_SYSRAM_FOR_PALETTE
        push    edi
        push    eax
        lea     eax,[esi].HWCRTCCX.dwPaletteTable
        push    eax
        mov     ax,ds
        push    eax
        pushd   400H
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY
        call    NV_AllocContextDma
        or      eax,eax
        je      DoneIt
        mov     ds:[esi].HWCRTCCX.bPaletteContextDmaCreated,1

        ; Allocate a Context DMA for the Gamma
        mov     ds:[esi].HWCRTCCX.bGammaContextDmaCreated,0
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     eax,OBJ_DMA_IN_SYSRAM_FOR_GAMMA
        push    edi
        push    eax
        lea     eax,[esi].HWCRTCCX.dwGammaTable
        push    eax
        mov     ax,ds
        push    eax
        pushd   400H
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY
        call    NV_AllocContextDma
        or      eax,eax
        je      DoneIt
        mov     ds:[esi].HWCRTCCX.bGammaContextDmaCreated,1

        ; Create the object
        mov     ds:[esi].HWCRTCCX.bVidLutCursorDacObjectCreated,0
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     eax,OBJ_VIDEO_LUT_CURSOR_DAC
        push    esi
        push    edi
        pushd   NV15_VIDEO_LUT_CURSOR_DAC
        push    eax
        call    NV_RMAllocObject
        or      eax,eax
        je      @F
        jmp     ObjectCreated
@@:
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     eax,OBJ_VIDEO_LUT_CURSOR_DAC
        push    edi
        pushd   NV04_VIDEO_LUT_CURSOR_DAC
        push    eax
        call    NV_AllocWinChannelObject
        or      eax,eax
        je      DoneIt
        
ObjectCreated:
        mov     ds:[esi].HWCRTCCX.bVidLutCursorDacObjectCreated,1

        ; Set the object in a sub-channel
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,edi,eax

        mov     edx,edi
        mov     edi,ds:[edi].HWBOARDCX.pCurrentPushBufferOffset

        CHECKDMASPACE ds,edx,edi,18H
        mov     eax,CHNRUN(VideoLutCursorDacHdr.object,1)
        mov     ebx,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     ebx,OBJ_VIDEO_LUT_CURSOR_DAC
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(VideoLutCursorDac.SetContextDmaNotifies,1)
        mov     ebx,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     ebx,OBJ_VIDEO_LUT_CURSOR_DAC_NOTIFIER
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(VideoLutCursorDac.SetContextDmaImage,1)
        mov     ebx,OBJ_DMA_IN_VRAM
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ebx

        add     edi,18H
        SETPUTPTR ds,edx,edi
        mov     edi,edx
        mov     eax,1
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:     DestroyVideoLutCursorDac
;
; Purpose:      This function destroys the VideoLutCursorDac object.
;
; Arguments:
;               ds:esi  HWCRTCCX
;               ds:edi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi
;==============================================================================
DECPROC DestroyVideoLutCursorDac, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Destroy the VidLutCurDac object
        cmp     ds:[esi].HWCRTCCX.bVidLutCursorDacObjectCreated,0
        je      @F
        push    edi
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     eax,OBJ_VIDEO_LUT_CURSOR_DAC
        push    eax
        call    NV_FreeWinChannelObject
        mov     ds:[esi].HWCRTCCX.bVidLutCursorDacObjectCreated,0
@@:
        ; Destroy the Context DMA for the gamma
        cmp     ds:[esi].HWCRTCCX.bPaletteContextDmaCreated,0
        je      @F
        push    edi
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     eax,OBJ_DMA_IN_SYSRAM_FOR_PALETTE
        push    eax
        call    NV_FreeWinChannelObject
        mov     ds:[esi].HWCRTCCX.bPaletteContextDmaCreated,0
@@:
        ; Destroy the Context DMA for the gamma
        cmp     ds:[esi].HWCRTCCX.bGammaContextDmaCreated,0
        je      @F
        push    edi
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     eax,OBJ_DMA_IN_SYSRAM_FOR_GAMMA
        push    eax
        call    NV_FreeWinChannelObject
        mov     ds:[esi].HWCRTCCX.bGammaContextDmaCreated,0
@@:
        ; Destroy the Context DMA for the VidLutCurDac notifier.
        cmp     ds:[esi].HWCRTCCX.bNotifierCreated,0
        je      @F
        push    edi
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        add     eax,OBJ_VIDEO_LUT_CURSOR_DAC_NOTIFIER
        push    eax
        call    NV_FreeWinChannelObject
        mov     ds:[esi].HWCRTCCX.bNotifierCreated,0
@@:
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetDacLimits
;
; Purpose:      This routine gets the DAC limits in all pixel depths.
;
; Arguments:
;               ds              Context Selector
;               pHWCrtcCXOffset HWCRTCCX ptr
;
; Returns:
;               eax             Dac Speed limit in 8bpp in Hertz
;               ebx             Dac Speed limit in 16bpp in Hertz
;               ecx             Dac Speed limit in 32bpp in Hertz
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetDacLimits, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
LOCALD  dw8BppLimit
LOCALD  dw16BppLimit
LOCALD  dw32BppLimit
LOCALV  sDACInfoParams,NV_CFGEX_DAC_PCLK_LIMIT_PARAMS
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      SkipGet
        
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        mov     sDACInfoParams.Head,eax
        mov     esi,ds:[esi].HWCRTCCX.pHWBoardCX

        mov     ax,ss
        shl     eax,10H
        lea     ax,sDACInfoParams
        mov     ebx,SIZE NV_CFGEX_DAC_PCLK_LIMIT_PARAMS 
        mov     ecx,NV_CFGEX_DAC_PCLK_LIMIT_8BPP
        call    NV_ConfigExCall
        mov     eax,sDACInfoParams.pclkLimit
        mov     dw8BppLimit,eax

        mov     ax,ss
        shl     eax,10H
        lea     ax,sDACInfoParams
        mov     ebx,SIZE NV_CFGEX_DAC_PCLK_LIMIT_PARAMS 
        mov     ecx,NV_CFGEX_DAC_PCLK_LIMIT_16BPP
        call    NV_ConfigExCall
        mov     eax,sDACInfoParams.pclkLimit
        mov     dw16BppLimit,eax

        mov     ax,ss
        shl     eax,10H
        lea     ax,sDACInfoParams
        mov     ebx,SIZE NV_CFGEX_DAC_PCLK_LIMIT_PARAMS 
        mov     ecx,NV_CFGEX_DAC_PCLK_LIMIT_32BPP
        call    NV_ConfigExCall
        mov     eax,sDACInfoParams.pclkLimit
        mov     dw32BppLimit,eax

        mov     eax,dw8BppLimit
        mov     ebx,dw16BppLimit
        mov     ecx,dw32BppLimit
        
SkipGet:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_BitsPerColorGun
;
; Purpose:      This routine returns the number of bits per
;               color channel in the CRTC given.
;
; Arguments:
;               ds                      The context selector.
;               pHWCrtcCXOffset         offset of HWCRTCCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_BitsPerColorGun, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
OPENPROC
        mov     eax,8
CLOSEPROC


;==============================================================================
;
; Function:     HW_SizeCursorCache
;
; Purpose:      This routine tells the hardware the maximum
;               number of cursors the generic cursor cache
;               can support. The hardware returns the number
;               of cursors it wants to cache that is less than
;               or equal to the number provided.
;
; Arguments:
;               ds                      The context selector.
;               pHWCrtcCXOffset         offset of HWCRTCCX
;               dwMaxCursorCacheSize    maximum size of cursor cache
;
; Returns:
;               eax             Number of cursors the hardware wants
;                               to cache. Must be less than
;                               dwMaxCursorCacheSize
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_SizeCursorCache, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   dwMaxCursorCacheSize
OPENPROC
        mov     ebx,pHWCrtcCXOffset
        or      ebx,ebx
        je      @F
        mov     eax,dwMaxCursorCacheSize
        cmp     eax,ds:[ebx].HWCRTCCX.dwMaxCachedCursors
        jc      @F
        mov     eax,ds:[ebx].HWCRTCCX.dwMaxCachedCursors
@@:
CLOSEPROC


;==============================================================================
;
; Function:     HW_IsCRTConnected
;
; Purpose:      This function returns TRUE if the CRT is connected
;               and FALSE if it is not.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX ptr
;
; Returns:      eax     TRUE  if CRT is connected
;                       FALSE if it is not connected
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_IsCRTConnected, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
LOCALV  sCRTInfoParams,NV_CFGEX_GET_MONITOR_INFO_MULTI_PARAMS
OPENPROC
        PUSHR   esi
        mov     esi,pHWCrtcCXOffset
        sub     eax,eax
        or      esi,esi
        je      DoneIt

        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        mov     sCRTInfoParams.Head,eax
        mov     esi,ds:[esi].HWCRTCCX.pHWBoardCX
        .errnz  NV_CFGEX_GET_MONITOR_INFO_NOT_CONNECTED

        sub     eax,eax
        mov     sCRTInfoParams.MonitorConnected,eax
        mov     ax,ss
        shl     eax,10H
        lea     ax,sCRTInfoParams
        mov     ebx,SIZE NV_CFGEX_GET_MONITOR_INFO_MULTI_PARAMS
        mov     ecx,NV_CFGEX_GET_MONITOR_INFO_MULTI
        call    NV_ConfigExCall
        mov     eax,sCRTInfoParams.MonitorConnected
DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_IsDFPConnected
;
; Purpose:      This function returns TRUE if the DFP is connected
;               and FALSE if it is not.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX ptr
;
; Returns:      eax     TRUE  if DFP is connected
;                       FALSE if it is not connected
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_IsDFPConnected, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
LOCALV  sDFPInfoParams,NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS
OPENPROC
        PUSHR   esi
        mov     esi,pHWCrtcCXOffset
        sub     eax,eax
        or      esi,esi
        je      DoneIt

        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        mov     sDFPInfoParams.Head,eax
        mov     esi,ds:[esi].HWCRTCCX.pHWBoardCX

        .errnz  NV_CFGEX_GET_FLATPANEL_INFO_NOT_CONNECTED

        sub     eax,eax
        mov     sDFPInfoParams.FlatPanelConnected,eax
        mov     ax,ss
        shl     eax,10H
        lea     ax,sDFPInfoParams
        mov     ebx,SIZE NV_CFGEX_GET_FLATPANEL_INFO_MULTI_PARAMS
        mov     ecx,NV_CFGEX_GET_FLAT_PANEL_INFO_MULTI
        call    NV_ConfigExCall
        mov     eax,sDFPInfoParams.FlatPanelConnected
DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_IsTVConnected
;
; Purpose:      This function returns TRUE if the TV is connected
;               and FALSE if it is not.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX ptr
;
; Returns:      eax     TRUE  if tv is connected
;                       FALSE if it is not connected
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_IsTVConnected, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
LOCALV  sTVInfoParams,NV_CFGEX_GET_TV_ENCODER_MULTI_PARAMS
OPENPROC
        PUSHR   esi
        mov     esi,pHWCrtcCXOffset
        sub     eax,eax
        or      esi,esi
        je      DoneIt

        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        mov     sTVInfoParams.Head,eax
        mov     esi,ds:[esi].HWCRTCCX.pHWBoardCX

        .errnz  TV_NOT_CONNECTED

        sub     eax,eax
        mov     sTVInfoParams.TVConnected,eax
        mov     ax,ss
        shl     eax,10H
        lea     ax,sTVInfoParams
        mov     ecx,NV_CFGEX_GET_TV_ENCODER_INFO_MULTI
        call    NV_ConfigExCall
        mov     eax,sTVInfoParams.TVConnected
DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetMaxDfpScaledXRes
;
; Purpose:      This function returns the maximum scanline length
;               in pixels that the hardware can scale to on a DFP.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX ptr
;
; Returns:      eax     max XRes scaling length in pixels
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetMaxDfpScaledXRes, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
LOCALV  sTVInfoParams,NV_CFGEX_TV_ENCODER_PARAMS
OPENPROC
        mov     eax,400H
CLOSEPROC


;==============================================================================
;
; Function:     HW_IsMacroVisionEncoderAttached
;
; Purpose:      This function returns whether or not we have a macro
;               vision capable TV out device attached.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX ptr
;
; Returns:      eax                     0       then no macrovision encoder
;                                       non-0   then yes
;
; Preserve:     ds,esi,edi,es
;==============================================================================
DECPROC HW_IsMacroVisionEncoderAttached, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
OPENPROC
        mov     ebx,pHWCrtcCXOffset
        sub     eax,eax
        or      ebx,ebx
        je      DoneIt
        mov     ebx,ds:[ebx].HWCRTCCX.dwTVOutDeviceID

        ; Check for devices that is not support macrovision
        cmp     ebx,NV_ENCODER_BROOKTREE_868
        je      DoneIt
        cmp     ebx,NV_ENCODER_CHRONTEL_7003
        je      DoneIt
        cmp     ebx,NV_ENCODER_CHRONTEL_7006
        je      DoneIt
        cmp     ebx,NV_ENCODER_CHRONTEL_7008
        je      DoneIt

        ; We assume all next generations should support macrovision.
        mov     eax,ebx
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:     HW_ReadEdid
;
; Purpose:      This function reads the EDID.
;
; Arguments:
;               ds              Context Selector
;               pHWCrtcCXOffset offset in Context selector to HWCRTCCX
;               dwDevData       type in low byte, num in next byte
;               pEdidBuffer     offset to EDID buffer
;               pEdidSize       offset to place to store edid size
;                               The variable this points to has been
;                               set to the maximum size it can handle.
;
; Returns:      eax     0       then there was a problem reading the EDID.
;                       non-0   then there was no problem
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_ReadEdid, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   dwDevData
PARMD   pEdidBuffer
PARMD   pEdidSize
LOCALV  sEdidParams,NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS
OPENPROC
        PUSHR   esi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      WasProb

        ; Form the bitmask 1 << (devtype * 8 + dev num) and
        ; see if device port is even available
        mov     ecx,dwDevData
        shl     cl,3
        add     cl,ch
        mov     eax,1
        shl     eax,cl
        mov     sEdidParams.displayMap,eax

        ; Get the base address of the CX selector
        mov     ax,ds
        push    eax
        call    GN_GetSelectorBase

        ; Build a flat offset to the EdidBuffer and EdidSize
        mov     edx,pEdidBuffer
        add     edx,eax
        mov     sEdidParams.edidBuffer,edx
        mov     edx,pEdidSize
        add     eax,edx
        mov     sEdidParams.bufferLength,eax

        ; Make the call to the RM to read the EDID
        mov     esi,ds:[esi].HWCRTCCX.pHWBoardCX
        mov     ax,ss
        shl     eax,10H
        lea     ax,sEdidParams
        mov     ebx,SIZE NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS
        mov     ecx,NV_CFGEX_GET_LOGICAL_DEV_EDID
        call    NV_ConfigExCall

        or      eax,eax
        mov     eax,1
        je      DoneIt

WasProb:
        sub     eax,eax
        mov     ecx,pEdidSize
        mov     ds:[ecx],eax

DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_ReadEdidForDevice
;
; Purpose:      This function reads the EDID to a buffer for the specific
;               display device requested (i.e., CRT0, DFP1, . . .)
;
; Arguments:
;               ds              Context Selector
;               pHWLogDevCXOffset offset in Context selector to HWLOGDEVCX
;               dwDisplayDev    display type device mask for device to read
;               lpEdidBuffer    ptr to EDID buffer
;               lpEdidSize      ptrt to place to store edid size
;                               The variable this points to has been
;                               set to the maximum size it can handle.
;
; Returns:      eax     0       then there was a problem reading the EDID.
;                       non-0   then there was no problem
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_ReadEdidForDevice, PASCAL, FRAME, FAR32
PARMD   pHWLogDevCxOffset
PARMD   dwDisplayDev
PARMD   lpEdidBuffer
PARMD   lpEdidSize
LOCALV  sEdidParams,NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS
OPENPROC
        PUSHR   esi
        mov     esi,pHWLogDevCxOffset
        or      esi,esi
        je      WasProb

        ; Get the base address of the selector for EdidBuffer. This will
        ; also be used for EdidSize.
        mov     eax,lpEdidBuffer
        shr     eax,10h
        push    eax
        call    GN_GetSelectorBase

        ; Build a flat offset to the EdidBuffer and EdidSize
        sub     edx,edx
        les     dx,lpEdidBuffer
        add     edx,eax
        mov     sEdidParams.edidBuffer,edx
        sub     edx,edx
        les     dx,lpEdidSize
        add     eax,edx
        mov     sEdidParams.bufferLength,eax

        ; Make the call to the RM to read the EDID. Set the displayMap to DFP0.
        mov     eax,dwDisplayDev
        mov     sEdidParams.displayMap,eax
        mov     esi,ds:[esi].HWLOGDEVCX.pHWBoardCX
        mov     ax,ss
        shl     eax,10H
        lea     ax,sEdidParams
        mov     ebx,SIZE NV_CFGEX_GET_LOGICAL_DEV_EDID_PARAMS
        mov     ecx,NV_CFGEX_GET_LOGICAL_DEV_EDID
        call    NV_ConfigExCall

        or      eax,eax
        mov     eax,1
        je      DoneIt

WasProb:
        sub     eax,eax

DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetPhysicalCrtcIndex
;
; Purpose:      This function returns the physical CRTC index that this
;               HWCRTCCX is attached to.
;
; Arguments:
;               ds              Context Selector
;               pHWCrtcCXOffset offset in Context selector to HWCRTCCX
;
; Returns:      eax     0-based physical CRTC number
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetPhysicalCrtcIndex, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
OPENPROC
        mov     ebx,pHWCrtcCXOffset
        or      ebx,ebx
        je      @F
        sub     eax,eax
        or      ebx,ebx
        je      @F
        mov     eax,ds:[ebx].HWCRTCCX.dwPhysicalCRTCInstance
@@:
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetBootDevice
;
; Purpose:      This function returns the device the HW would like us
;               to use for this CRTC.
;
; Arguments:
;               ds              Context Selector
;               pHWCrtcCXOffset offset in Context selector to HWCRTCCX
;               dwDeviceInstance Primary device (0), secondary device (1), etc.
;
; Returns:      eax             bits 7:0  - Device Type to use
;                               bits 15:8 - Device Number to use
;                               bits 23:16 - format to use if type is TV
;                       -1 if no there are fewer than dwDeviceInstance+1
;                       bits set.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetBootDevice, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwDeviceInstance
LOCALD  dwFoundInstance
LOCALB  dbDeviceNumber
OPENPROC
        mov     ebx,pHWBoardCXOffset
        sub     eax,eax
        or      ebx,ebx
        je      NoDevice

        cmp     dwDeviceInstance,7
        ja      NoDevice

        mov     dbDeviceNumber,0
        mov     dwFoundInstance,0

        pushd   NV_CFG_GET_BOOT_DEVICES
        push    ds:[ebx].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigGet,es,ax

        ; Result from ConfigGet is in dx:ax
        ; Put CRTs in DL, TVs in CL, and DFPs in CH. DH = bit to test.
        mov     ch,dl
        mov     cl,ah
        mov     dl,al
        mov     dh,1
        sub     eax,eax

        ; The order of precedence is DFP0, CRT0, TV0, DFP1, CRT1, TV1, . . .
DeviceNumberLoop:

        mov     al,DEVTYPE_DFP
        test    ch,dh
        jz      CheckCRT
        mov     ebx,dwDeviceInstance
        cmp     dwFoundInstance,ebx
        je      FoundDevice
        inc     dwFoundInstance

CheckCRT:
        mov     al,DEVTYPE_CRT
        test    dl,dh
        jz      CheckTV
        mov     ebx,dwDeviceInstance
        cmp     dwFoundInstance,ebx
        je      FoundDevice
        inc     dwFoundInstance

CheckTV:
        mov     al,DEVTYPE_TV
        test    cl,dh
        jz      NextDeviceNumber
        mov     ebx,dwDeviceInstance
        cmp     dwFoundInstance,ebx
        je      FoundDevice
        inc     dwFoundInstance

NextDeviceNumber:
        cmp     dh,80h
        je      NoDevice
        shl     dh,1
        inc     dbDeviceNumber
        jmp     DeviceNumberLoop

FoundDevice:
        mov     ah,dbDeviceNumber
        cmp     al,DEVTYPE_TV
        jne     DoneIt

        ; With the TV, we need the format also
        push    eax
        mov     ebx,pHWBoardCXOffset
        pushd   NV_CFG_BIOS_DEFAULT_TV_TYPE
        push    ds:[ebx].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigGet,es,ax
        movzx   ecx,ax
        call    HW_MapHWTvFormatToGNTvFormat
        shl     ecx,10H
        pop     eax
        or      eax,ecx
        jmp     DoneIt

NoDevice:
        mov     eax,-1
        jmp     DoneIt

DoneIt:

CLOSEPROC


;==============================================================================
;
; Function:     HW_GetResManTvFormat
;
; Purpose:      This function returns the TV Format
;
; Arguments:
;               ds              Context Selector
;               pHWCrtcCXOffset offset in Context selector to HWCRTCCX
;               dwDevData       Device for which we want the TV Format
;
; Returns:      eax             TvFormat                
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetResManTvFormat, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   dwDevData
LOCALV  sTVParams,NV_CFGEX_GET_VIDEO_TV_STANDARD_PARAMS
OPENPROC

        PUSHR   esi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      WasProb

        ; Make sure this is a TV or don't call ResMan
        mov     cl,(DEVDATA PTR dwDevData).cType
        cmp     cl,DEVTYPE_TV
        jne     WasProb
        
        ; Form the bitmask 1 << (devtype * 8 + dev num) and
        ; see if device port is even available
        mov     ecx,dwDevData
        shl     cl,3
        add     cl,ch
        mov     eax,1
        shl     eax,cl
        mov     sTVParams.DevicesConfig,eax

        ; Make the call to the RM to read the EDID
        mov     esi,ds:[esi].HWCRTCCX.pHWBoardCX
        mov     ax,ss
        shl     eax,10H
        lea     ax,sTVParams
        mov     ebx,SIZE NV_CFGEX_GET_VIDEO_TV_STANDARD_PARAMS
        mov     ecx,NV_CFGEX_GET_VIDEO_TV_STANDARD
        call    NV_ConfigExCall

        or      eax,eax
        mov     eax,sTVParams.TVStandard
        je      DoneIt

WasProb:
        sub     eax,eax

DoneIt:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_SetResManTvFormat
;
; Purpose:      This function sets the Tv Format in the ResMan
;
; Arguments:
;               ds              Context Selector
;               pHWCrtcCXOffset offset in Context selector to HWCRTCCX
;               dwDevData       Device and TV Format to set
;
; Returns:      
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_SetResManTvFormat, PASCAL, FRAME, FAR32
PARMD   pHWCrtcCXOffset
PARMD   dwDevData
LOCALV  sTVParams,NV_CFGEX_GET_VIDEO_TV_STANDARD_PARAMS
OPENPROC

        PUSHR   esi
        mov     esi,pHWCrtcCXOffset
        or      esi,esi
        je      WasProb

        ; Make sure this is a TV or don't call ResMan
        mov     cl,(DEVDATA PTR dwDevData).cType
        cmp     cl,DEVTYPE_TV
        jne     WasProb
        
        ; Form the bitmask 1 << (devtype * 8 + dev num) and
        ; see if device port is even available
        mov     ecx,dwDevData
        shl     cl,3
        add     cl,ch
        mov     eax,1
        shl     eax,cl
        mov     sTVParams.DevicesConfig,eax
        
        ; Store the TV Format we want to set in sTVParams.
        mov     ecx,dwDevData
        shr     ecx,10h
        and     ecx,0FFh        
        mov     sTVParams.TVStandard,ecx

        ; Make the call to the RM to read the EDID
        mov     esi,ds:[esi].HWCRTCCX.pHWBoardCX
        mov     ax,ss
        shl     eax,10H
        lea     ax,sTVParams
        mov     ebx,SIZE NV_CFGEX_GET_VIDEO_TV_STANDARD_PARAMS
        mov     ecx,NV_CFGEX_GET_VIDEO_TV_STANDARD
        call    NV_ConfigExCall

        or      eax,eax
        je      DoneIt

WasProb:
        sub     eax,eax

DoneIt:
        POPR    esi
CLOSEPROC


CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWCUR32.ASM ===
;==============================================================================
;
; Copyright (C) 1997, Nvidia Coporation
;
; File:         hwcursor.asm
;
; Purpose:      This file implements the hardware specific code to
;               support the cursor.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include nvreg.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc

XOR_IS_OK       TEXTEQU <1>

IF  (USE_ALPHA_CURSOR NE 0)

OPENSEG  _DATA, USE16, DATA
PUBLIC  szNVDisplayKey
szNVDisplayKey  DB      NV4_REG_GLOBAL_BASE_PATH, '\'
                DB      NV4_REG_DISPLAY_DRIVER_SUBKEY, 0

PUBLIC  szCursorAlpha
szCursorAlpha   DB      NV4_REG_DRV_CURSOR_ALPHA, 0
CLOSESEG _DATA


OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

PUBLIC  dwEnableCursorShadow
dwEnableCursorShadow    DD      0

PUBLIC  dwConvert4bppTo32bpp
dwConvert4bppTo32bpp    LABEL   DWORD
        DD      00000000H, 00800000H, 00008000H, 00808000H
        DD      00000080H, 00800080H, 00008080H, 00C0C0C0H
        DD      00808080H, 00FF0000H, 0000FF00H, 00FFFF00H
        DD      000000FFH, 00FF00FFH, 0000FFFFH, 00FFFFFFH

PUBLIC  bConvert5bppTo8bpp
bConvert5bppTo8bpp      LABEL   BYTE
        DB    0,  10h,  18h,  20h,  28h,  30h,  38h,  40h
        DB  48h,  50h,  58h,  60h,  68h,  70h,  78h,  80h
        DB  88h,  90h,  98h, 0A0h, 0A8h, 0B0h, 0B8h, 0C0h
        DB 0C8h, 0D0h, 0D8h, 0E0h, 0E8h, 0F0h, 0F8h, 0FFh

PUBLIC  bConvert6bppTo8bpp
bConvert6bppTo8bpp      LABEL   BYTE
        DB    0,    8,  0Ch,  10h,  14h,  18h,  1Ch,  20h
        DB  24h,  28h,  2Ch,  30h,  34h,  38h,  3Ch,  40h
        DB  44h,  48h,  4Ch,  50h,  54h,  58h,  5Ch,  60h
        DB  64h,  68h,  6Ch,  70h,  74h,  78h,  7Ch,  80h
        DB  84h,  88h,  8Ch,  90h,  94h,  98h,  9Ch, 0A0h
        DB 0A4h, 0A8h, 0ACh, 0B0h, 0B4h, 0B8h, 0BCh, 0C0h
        DB 0C4h, 0C8h, 0CCh, 0D0h, 0D4h, 0D8h, 0DCh, 0E0h
        DB 0E4h, 0E8h, 0ECh, 0F0h, 0F4h, 0F8h, 0FCh, 0FFh


;==============================================================================
;
; Function:     HW_CursorSet8888
;
; Purpose:      This function places a cursor pattern in offscreen video
;               memory. It does not make this new pattern the active
;               cursor, nor should it change the state of the cursor
;               on/off. Remember that the cursor can be many different
;               color depths -- you need to convert it to the color
;               depth in which you store the cursor in video memory.
;
;               This routine in particular tries to set the cursor
;               using the 8888 format which has an alpha component.
;               The hardware is slightly broken with this cursor
;               on NV10 (which was the first noard to support 8888
;               format) and it is not always possible to do this
;               format. Basically, if the XOR mask is used to invert
;               a pixel, the cursor is not doable on NV10.
;
;               Hence, this routine can fail.
;
; Arguments:
;               ds                      Context Selector
;               pHWCrtcCXOffset         HWCRTCCX
;               dwCursorCacheSlot       0 based cache slot
;               pCursorDesc             CURSORDESC ptr
;
; Returns:
;               eax                     0       Failure
;                                       non-0   Success
;               ebx     If eax indicates success, then this is a value
;                       that the hardware needs cached with the cursor
;                       information.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CursorSet8888, PASCAL, FRAME, NEAR, LOGOFF
PARMD   pHWCrtcCXOffset
PARMD   dwCursorCacheSlot
PARMD   pCursorDesc
LOCALD  dwCursorHWType
OPENPROC
        PUSHR   esi,edi
        mov     ebx,pHWCrtcCXOffset
        mov     edx,ds:[ebx].HWCRTCCX.pHWBoardCX

        ; Get a ptr to the place to store the cursor pattern.
        mov     edi,dwCursorCacheSlot
        imul    edi,HW_CURSOR_SIZE
        add     edi,ds:[edx].HWBOARDCX.pVideoMemory
        add     edi,ds:[ebx].HWCRTCCX.dwCursorCacheVramOffset
        mov     esi,pCursorDesc
        mov     dwCursorHWType,NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8

        ; Dispatch to the routine to copy/convert the cursor
        ; pattern to the hardware format and store it in vidmem.
        push    OFFSET Ret8888
        mov     al,ds:[esi].CURSORDESC.bBitsPerPixel
        cmp     al,01H
        je      SetCursor_1Bpp_8888
        cmp     al,10H
        je      SetCursor_16Bpp_8888
        cmp     al,20H
        je      SetCursor_32Bpp_8888
        cmp     al,04H
        je      SetCursor_4Bpp_8888
        cmp     al,18H
        je      SetCursor_24Bpp_8888
        cmp     al,0FH
        je      SetCursor_15Bpp_8888
        cmp     al,08H
        je      SetCursor_8Bpp_8888

        ; 21H bits/pixel is a DEBUG only thing. It allows for playing
        ; around with the alpha. The cursor depth is really 32bpp.
        ; We just say it is 33bpp as a flag.
        cmp     al,21H
        je      SetCursor_3XBpp_8888

        ; 22H bits/pixel is a DEBUG only thing. It allows for playing
        ; around with premultipliedalpha. The cursor depth is really
        ; 32bpp. We just say it is 34bpp as a flag.
        mov     dwCursorHWType,NV07C_SET_CURSOR_IMAGE_FORMAT_COLOR_PM_LE_A8R8G8B8
        cmp     al,22H
        je      SetCursor_3XBpp_8888
        pop     eax
        sub     eax,eax
        jmp     SetDone

Ret8888:
        or      eax,eax
        sete    al
        movzx   eax,al
        mov     ebx,dwCursorHWType
SetDone:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_1Bpp_8888
;
; Purpose:      This function places a 1Bpp cursor pattern in
;               offscreen video memory converting it to the
;               hardware format on the fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Returns:
;               eax                     0       Failure
;                                       non-0   Success
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_1Bpp_8888, PASCAL, FRAME, NEAR, LOGOFF
LOCALD  dwAlpha
LOCALD  dwAlpha1
LOCALD  dwAndMaskSize
OPENPROC
        mov     eax,ds:[ebx].HWCRTCCX.dwCursorAlpha
        shl     eax,16                         ; E:AX = alpha_shadow:alpha_cursor:0
        mov     [dwAlpha1],eax                 ; Save shadow alpha value
        shl     eax,8                          ; E:AX   = alpha_cursor:0
        mov     [dwAlpha],eax                  ; Save cursor alpha value

        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        shr     ecx,3                          ; CX = bytes in the AND mask
        mov     [dwAndMaskSize],ecx
        mov     ebx,ecx                        ; EBX = AndMaskSize
        shr     ecx,2                          ; CL = dwords of pixel data
        lea     esi,[esi].CURSORDESC.bCursorAndMask

IF      (XOR_IS_OK EQ 0)
        ; Check for any inverted pixels in the cursor.
        ; You can tell this because the AND mask and the XOR mask
        ; are both non-0 at the same pixel.
        ; If there are none, then we can use alpha.
        ; Otherwise, we must use ROP555 format (no alpha).
        mov     edx,esi
Check_XOR_Loop:
        mov     eax,ds:[edx]                   ; EAX = 32 bits of AND mask
        and     eax,ds:[edx + ebx]             ; EAX = 32 bits of pixel data AND mask
        jnz     SetCursorFail                  ; Ooops, there is an XOR, must use ROP555
        add     edx,4
        dec     ecx
        jnz     Check_XOR_Loop
ENDIF

        ; Set the cursor into video memory.
        mov     ecx,ebx                        ; ECX = bytes of pixel data
        shr     ecx,2                          ; CL = dwords of pixel data
Next_Dword:
        mov     ebx,[dwAndMaskSize]
        mov     eax,ds:[esi]                   ; EAX = 32 bits of AND mask
        mov     ebx,ds:[esi + ebx]             ; EBX = 32 bits of pixel data
        add     esi,4                          ; Src ptr++
        mov     ch,32                          ; 32 pixels per dword
        bswap   eax
        bswap   ebx

        ; On any bit which is not transparent (i.e. which is part of
        ; the actual cursor image), add in the alpha value.
Cont_Dword:
        add     ebx,ebx                        ; Carry = SHL pixel data
        sbb     edx,edx                        ; DX == 0000 or FFFF
        and     edx,00FFFFFFh                  ; Set alpha = 0
        add     eax,eax                        ; Carry = SHL AND mask
        jnc     @F
        or      edx,edx
        je      NoAlfa
        sub     edx,edx
@@:     add     edx,[dwAlpha]
NoAlfa: mov     ds:[edi],edx                   ; Save the two pixels
        add     edi,4                          ; Increment the destination
        dec     ch
        jne     Cont_Dword
        dec     cl
        jne     Next_Dword

        xor     eax, eax                        ; Return success
SetCursorFail:                                  ; Return failure (EAX != 0)
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_4Bpp_8888
;
; Purpose:      This function places a 4Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Returns:
;               eax                     0       Failure
;                                       non-0   Success
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_4Bpp_8888, PASCAL, FRAME, NEAR, LOGOFF
LOCALD  dwAlpha
OPENPROC
        mov     eax,ds:[ebx].HWCRTCCX.dwCursorAlpha
        shl     eax,24                         ; E:AX   = alpha_cursor:0
        mov     [dwAlpha],eax                  ; Save cursor alpha value

        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        lea     ebx,[esi + ecx]
        shr     ecx,2                          ; CL = dwords of pixel data

Next_Row:
        ; 4bpp case
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; DS:ESI next row of AND mask
        mov     ch,(32 / 2)                    ; CH is bytes to handle
        bswap   edx                            ; Roll the bits off the left

Cont_Row:
        movzx   eax,byte ptr ds:[ebx]          ; EAX = 000000:XX two pixels
        shr     eax,4                          ; EAX = 1 nibble of pixel data
        mov     eax,cs:dwConvert4bppTo32bpp[eax * 4]  ; EAX = converted pixel
        add     edx,edx                        ; Carry <= SHL AND mask
        jnc     @F
        or      eax,eax
        je      NoAlf0
        sub     eax,eax
@@:	add     eax,[dwAlpha]
NoAlf0: mov     ds:[edi],eax                   ; Save the pixel

        movzx   eax,byte ptr ds:[ebx]          ; E:A:X = 000000:XX two pixels of cursor data
        inc     ebx                            ; DS:EBX -> cursor pixel data++
        and     eax,0FH                        ; EAX   = 1 nibble of pixel data
        mov     eax,cs:dwConvert4bppTo32bpp[eax * 4]   ; EAX = converted pixel
        add     edx,edx                        ; Carry <= SHL AND mask
        jnc     @F
        or      eax,eax
        je      NoAlf1
        sub     eax,eax
@@:	add     eax,[dwAlpha]
NoAlf1: mov     ds:[edi+4],eax                 ; Save the pixel

        add     edi,8                          ; Increment the destination
        dec     ch                             ; Decrement the loops on this DWORD (EDX)
        jne     Cont_Row
        dec     cl                             ; Decrement the DWORD count
        jne     Next_Row

        xor     eax,eax                        ; Return success
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_8Bpp_8888
;
; Purpose:      This function places a 8Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_8Bpp_8888, PASCAL, FRAME, NEAR, LOGOFF
LOCALD  dwAlpha
LOCALB  bColumn
LOCALB  bRow
OPENPROC
        mov     eax,ds:[ebx].HWCRTCCX.dwCursorAlpha
        shl     eax,24                         ; E:AX   = alpha_cursor:0
        mov     [dwAlpha],eax                  ; Save cursor alpha value

        movzx   eax,ds:[esi].CURSORDESC.wHeight
        imul    ax,ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     eax,3                          ; AX = bytes in the AND mask
        lea     ecx,[ebx].HWCRTCCX.dwPaletteTable
        lea     ebx,[esi + eax]                ; DS:EBX -> cursor pixel data
        shr     eax,2                          ; AL = dwords of mask data
        mov     [bRow],al

Next_Dword:
        ; 8bpp case
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; DS:ESI next byte of AND mask
        mov     [bColumn],32                   ; Prepare to handle one dword
        bswap   edx                            ; Roll the bits off the left

Cont_Dword:
        movzx   eax,byte ptr ds:[ebx]          ; E:A:X = 0000:00:XX one pixel
        inc     ebx                            ; Next src pixel
        mov     eax,ds:[ecx][eax * 4]          ; EAX   = XRGB for 8bpp pixel
        and     eax,000FFFFFFh                 ; Clear alpha
        add     edx,edx                        ; Carry <= SHL AND mask
        jnc     @F
        or      eax,eax
        je      NoAlfa
        sub     eax,eax
@@:	add     eax,[dwAlpha]
NoAlfa: mov     ds:[edi],eax                   ; Save the pixel

        add     edi,4                          ; Next dst pixel
        dec     [bColumn]
        jne     Cont_Dword
        dec     [bRow]
        jne     Next_Dword

        xor     eax,eax                        ; Return success
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_15Bpp_8888
;
; Purpose:      This function places a 15Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_15Bpp_8888, PASCAL, FRAME, NEAR, LOGOFF
LOCALB  bColumn
LOCALB  bRow
LOCALD  dwAlpha
OPENPROC
        mov     eax,ds:[ebx].HWCRTCCX.dwCursorAlpha
        shl     eax,24                         ; E:AX   = alpha_cursor:0
        mov     [dwAlpha],eax                  ; Save cursor alpha value

        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     eax,[esi + ecx]                ; DS:EBX -> cursor pixel data
        shr     ecx,2                          ; CL = dwords of mask data
        mov     [bRow],cl
        sub     ebx,ebx

Next_Dword:
        ; 15bpp case
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; ESI next byte of AND mask
        mov     [bColumn],32                   ; Prepare to handle one dword
        bswap   edx                            ; Roll the bits off the left

Cont_Dword:
        movzx   ecx,word ptr ds:[eax]          ; CX = next pixel
        add     eax,2                          ; Next src pixel
        mov     bl,cl
        shl     ecx,3                          ; Save Red and Green
        and     bl,01Fh                        ; Get Blue 5bpp
        mov     cl,cs:bConvert5bppTo8bpp[ebx]  ; Convert to byte
        ror     ecx,8                          ; green to low, blue to high
        mov     bl,cl                          ; BL = some red & green
        shl     cx,3                           ; CH = red
        and     bl,01Fh                        ; Get Green 5bpp
        mov     cl,cs:bConvert5bppTo8bpp[ebx]  ; Convert to byte
        ror     ecx,8                          ; red to low, green to high
        mov     bl,cl
        and     bl,01Fh                        ; Get Red 5bpp
        mov     cl,cs:bConvert5bppTo8bpp[ebx]  ; Convert to byte
        ror     ecx,10H                        ; E:CX = R:G:B:0
        add     edx,edx                        ; Carry <= SHL AND mask
        jnc     @F
        or      ecx,ecx
        je      NoAlfa
        sub     ecx,ecx
@@:	add     ecx,[dwAlpha]
NoAlfa: mov     ds:[edi],ecx                   ; Save the pixel

        add     edi,4                          ; Next dst pixel
        dec     [bColumn]
        jne     Cont_Dword
        dec     [bRow]
        jne     Next_Dword

        xor     eax,eax                        ; Return success
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_16Bpp_8888
;
; Purpose:      This function places a 16Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_16Bpp_8888, PASCAL, FRAME, NEAR, LOGOFF
LOCALB  bColumn
LOCALB  bRow
LOCALD  dwAlpha
OPENPROC
        mov     eax,ds:[ebx].HWCRTCCX.dwCursorAlpha
        shl     eax,24                         ; E:AX   = alpha_cursor:0
        mov     [dwAlpha],eax                  ; Save cursor alpha value

        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     eax,[esi + ecx]                ; DS:EBX -> cursor pixel data
        shr     ecx,2                          ; CL = dwords of mask data
        mov     [bRow],cl
        sub     ebx,ebx

Next_Dword:
        ; 16bpp case
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; ESI next byte of AND mask
        mov     [bColumn],32                   ; 32 pixels per scanline
        bswap   edx                            ; Roll the bits off the left

Cont_Dword:
        movzx   ecx,word ptr ds:[eax]          ; CX = next pixel
        add     eax,2                          ; Next src pixel
        mov     bl,cl
        shl     ecx,3                          ; Save Red and Green
        and     bl,01Fh                        ; Get Blue 5bpp
        mov     cl,cs:bConvert5bppTo8bpp[ebx]  ; Convert to byte
        ror     ecx,8                          ; green to low, blue to high
        mov     bl,cl                          ; BL = some red & green
        shl     cx,2                           ; CH = red
        and     bl,03Fh                        ; Get Green 5bpp
        mov     cl,cs:bConvert6bppTo8bpp[ebx]  ; Convert to byte
        ror     ecx,8                          ; red to low, green to high
        mov     bl,cl
        and     bl,01Fh                        ; Get Red 5bpp
        mov     cl,cs:bConvert5bppTo8bpp[ebx]  ; Convert to byte
        ror     ecx,10H                        ; E:CX = R:G:B:0
        add     edx,edx                        ; Carry <= SHL AND mask
        jnc     @F
        or      ecx,ecx
        je      NoAlfa
        sub     ecx,ecx
@@:	add     ecx,[dwAlpha]
NoAlfa: mov     ds:[edi],ecx                   ; Save the pixel

        add     edi,4                          ; Next dst pixel
        dec     [bColumn]
        jne     Cont_Dword
        dec     [bRow]
        jne     Next_Dword

        xor     eax,eax                        ; Return success
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_24Bpp_8888
;
; Purpose:      This function places a 24Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_24Bpp_8888, PASCAL, FRAME, NEAR, LOGOFF
LOCALD  dwAlpha
OPENPROC
        mov     eax,ds:[ebx].HWCRTCCX.dwCursorAlpha
        shl     eax,24                         ; E:AX   = alpha_cursor:0
        mov     [dwAlpha],eax                  ; Save cursor alpha value

        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     ebx,[esi + ecx]                ; DS:EBX -> cursor pixel data
        shr     ecx,2                          ; CL = dwords of mask data

Next_Dword:
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; ESI next byte of AND mask
        mov     ch,32                          ; 32 pixels per scan
        bswap   edx                            ; Roll the bits off the left

Cont_Dword:
        xor     eax,eax                        ; EAX = 0:0:0:0
        mov     al,ds:[ebx + 2]                ; EAX = 0:0:0:R
        shl     eax,16                         ; EAX = 0:R:0:0
        mov     ax,ds:[ebx]                    ; EAX = 0:R:G:B
        add     ebx,3                          ; Next src pixel
        add     edx,edx                        ; Carry <= SHL AND mask
        jnc     @F
        or      eax,eax
        je      NoAlfa
        sub     eax,eax
@@:	add     eax,[dwAlpha]
NoAlfa: mov     ds:[edi],eax                   ; Save the pixel

        add     edi,4                          ; Next dst pixel
        dec     ch
        jne     Cont_Dword
        dec     cl
        jne     Next_Dword

        xor     eax,eax                        ; Return success
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_32Bpp_8888
;
; Purpose:      This function places a 32Bpp cursor pattern in offscreen
;               video memory converting it to the hardware format on the
;               fly.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_32Bpp_8888, PASCAL, FRAME, NEAR, LOGOFF
LOCALD  dwAlpha
OPENPROC
        mov     eax,ds:[ebx].HWCRTCCX.dwCursorAlpha
        shl     eax,24                         ; E:AX   = alpha_cursor:0
        mov     [dwAlpha],eax                  ; Save cursor alpha value

        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     ebx,[esi + ecx]                ; DS:EBX -> cursor pixel data
        shr     ecx,2                          ; CL = dwords of mask data

Next_Dword:
        mov     edx,ds:[esi]                   ; EDX = 32 bits of AND mask
        add     esi,4                          ; ESI next byte of AND mask
        mov     ch,32                          ; 32 pixels per scan
        bswap   edx                            ; Roll the bits off the left

Cont_Dword:
        mov     eax,ds:[ebx]                   ; EAX = X:R:G:B
        add     ebx,4                          ; Next src pixel
        and     eax,00FFFFFFh                  ; EAX = 0:R:G:B
        add     edx,edx                        ; Carry <= SHL AND mask
        jnc     @F
        or      eax,eax
        je      NoAlfa
        sub     eax,eax
@@:	add     eax,[dwAlpha]
NoAlfa: mov     ds:[edi],eax                   ; Save the pixel

        add     edi,4                          ; Next dst pixel
        dec     ch
        jne     Cont_Dword
        dec     cl
        jne     Next_Dword

        xor     eax,eax                        ; Return success
CLOSEPROC


;==============================================================================
;
; Function:     SetCursor_3XBpp_8888
;
; Purpose:      This function places a 32Bpp ARGB cursor pattern in
;               offscreen video memory converting it to the hardware
;               format on the fly.  This is a nonstandard format that
;               is for testing only. The AND mask is ignored.
;
; Arguments:
;               ds      Context Selector
;               ebx     HWCRTCCX ptr
;               esi     CURSORDESC ptr
;               edi     ptr to place to store cursor pattern
;
; Preserve:     ds
;==============================================================================
DECPROC SetCursor_3XBpp_8888, PASCAL, FRAME, NEAR, LOGOFF
OPENPROC
        movzx   ecx,ds:[esi].CURSORDESC.wHeight
        imul    cx,ds:[esi].CURSORDESC.wWidth
        lea     esi,[esi].CURSORDESC.bCursorAndMask
        shr     ecx,3                          ; CX = bytes in the AND mask
        lea     ebx,[esi + ecx]                ; DS:EBX -> cursor pixel data
        shl     ecx,3                          ; ECX = bytes of mask data

Next_Dword:
        mov     eax,ds:[ebx]                   ; EAX = X:R:G:B
        add     ebx,4                          ; Next src pixel
        mov     ds:[edi],eax                   ; Store the new pixel
        add     edi,4                          ; Next dst pixel
        dec     ecx
        jne     Next_Dword
        xor     eax,eax                        ; Return success
CLOSEPROC

CLOSESEG _NVTEXT32

ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\hwidiag.asm ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Coporation
;
; File:         hwidiag.asm
;
; Purpose:      This file implements diagnostics that Intel requires
;               for purchase of our boards. The functions in here
;               are all reached via a driver Escape mechanism.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include hwmacs.inc
include gngdi.inc
include hwgdi.inc
include nvcm.inc

INTEL_DIAG_FRAME_AND_LOCALS	MACRO
PARMD	pHWLogdevCXOffset
PARMD   lpIn
PARMD   lpOut
ENDM

IDIAG_OPEN_INTERFACE            TEXTEQU <0>
IDIAG_CLOSE_INTERFACE           TEXTEQU <1>
IDIAG_GET_ERROR_CODE            TEXTEQU <2>
IDIAG_GET_CRC                   TEXTEQU <3>
IDIAG_GET_DRIVER_INFO           TEXTEQU <4>
IDIAG_GET_MEMORY_INFO           TEXTEQU <5>
IDIAG_GET_CLOCK_RATES           TEXTEQU <6>
IDIAG_GET_PCI_CONFIG            TEXTEQU <7>
IDIAG_GET_BUS_CONFIG            TEXTEQU <8>

IDIAG_ERROR_NONE                TEXTEQU <0>
IDIAG_ERROR_GENERIC             TEXTEQU <1>
IDIAG_ERROR_INVALID_PARAM       TEXTEQU <2>
IDIAG_ERROR_NOT_SUPPORTED       TEXTEQU <3>

; This is bad to redefine these here, but I am doing it for now!
; JKTODO ...
NV_PRAMDAC_TEST_CONTROL		TEXTEQU	<680608H>
NV_PRAMDAC_CHECKSUM		TEXTEQU	<68060CH>


OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

PUBLIC dwBuildYear, dwBuildMonth, dwBuildDay
TWO_DIGIT_YEAR      	TEXTEQU @SubStr( %@Date, 7, 2 )
CURRENT_YEAR    	TEXTEQU <2000 + TWO_DIGIT_YEAR>
dwBuildYear     	DD      CURRENT_YEAR
dwBuildMonth		DD	@SubStr( %@Date, 1, 2 )
dwBuildDay		DD	@SubStr( %@Date, 4, 2 )
szNVCompanyString       DB      NV_COMPANY_NAME_STRING_SHORT,0
szDriverVersion         DB      NV_VERSION_STRING,0

;==============================================================================
;
; Function:	NV_IntelDiagnostics
;
; Purpose:      This function is a set of Intel diagnostics.
;               Intel requires this Escape and diagnostics in
;               order to purchase our boards.
;
; Arguments:
;		ds			CX Sel
;		pHWLogdevCXOffset	HWLOGDEVCX ptr
;		lpIn			lpIn ptr of Escape function
;		lpOut			lpOut ptr of Escape function
; Returns:
;		ecx	0 	then pretend the escape was not implemented
;			non-0	then it was handled and eax has the
;				return code.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_IntelDiagnostics, PASCAL, FRAME, FAR16
INTEL_DIAG_FRAME_AND_LOCALS
OPENPROC
        PUSHR   esi,edi
        mov	ebx,pHWLogdevCXOffset

	; Verify the lpIn and lpOut parameters
	sub	eax,eax
	cmp	eax,lpIn
	je	FailIt
	cmp	eax,lpOut
	je	FailIt

	; Proceed with diagnostics subfunction
	lfs	si,lpIn
	les	di,lpOut
	mov	eax,fs:[si]

	push	OFFSET RetAddr
	cmp	eax,IDIAG_OPEN_INTERFACE
	je	NV_OpenIntelDiagInterface
	add	sp,@WordSize

	; If the interface is not open and this was not an open
	; request, the Intel spec says to pretend that the escape
	; is not implemented.
	cmp	ds:[ebx].HWLOGDEVCX.wDiagInterfaceOpen,0
	je	NotUs

	push	OFFSET RetAddr
	cmp	eax,IDIAG_CLOSE_INTERFACE
	je	NV_CloseIntelDiagInterface
	cmp	eax,IDIAG_GET_ERROR_CODE
	je	NV_IntelDiagGetErrorCode
	cmp	eax,IDIAG_GET_CRC
	je	NV_IntelDiagGetCRC
	cmp	eax,IDIAG_GET_DRIVER_INFO
	je	NV_IntelDiagDriverInfo
	cmp	eax,IDIAG_GET_MEMORY_INFO
	je      NV_IntelDiagMemoryInfo
	cmp	eax,IDIAG_GET_CLOCK_RATES
	je	NV_IntelDiagClockRates
	cmp	eax,IDIAG_GET_PCI_CONFIG
	je	NV_IntelDiagPciConfig
	cmp	eax,IDIAG_GET_BUS_CONFIG
	je	NV_IntelDiagBusConfig
	add	sp,@WordSize

NotSupported:
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,IDIAG_ERROR_NOT_SUPPORTED
	mov	ecx,1
	mov	ax,-1
	jmp	DoneIt

NotUs:
	sub	ecx,ecx
	jmp	DoneIt

FailIt:
	; Comment to keep assembler from weird error
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,IDIAG_ERROR_INVALID_PARAM
	mov	ecx,1
	sub	ax,ax
	jmp	DoneIt

RetAddr:
	mov	ecx,1

DoneIt:
	POPR	esi,edi
CLOSEPROC



;==============================================================================
;
; Function:     NV_OpenIntelDiagInterface
;
; Purpose:      This function is called if
;		lpIn->DIAGINPUT.dwFunction = IDIAG_OPEN_INTERFACE
;
; Arguments:
;		Same frame as NV_ControlIntelDiagnostics
;		ds:ebx	HWLOGDEVCX
;		fs:si	lpIn
;		es:di	lpOut
;
; Returns:
;		if	lpIn->DIAGINPUT.dwOpenKey == INTEL_DIAG_OPEN_KEY
;			lpOut->DIAGOUTPUT.dwOpenAck = INTEL_DIAG_OPEN_ACK
;		ax	Error Code to return
;
; Preserve:	Nothing
;==============================================================================
OPEN_INPUT	STRUCT
	dwFunction	DD	0
	dwOpenKey	DD	0
OPEN_INPUT	ENDS

OPEN_OUTPUT	STRUCT
	dwOpenAck	DD	0
OPEN_OUTPUT	ENDS

INTEL_DIAG_OPEN_KEY	TEXTEQU	<0B295F38DH>
INTEL_DIAG_OPEN_ACK	TEXTEQU	<070CA14E6h>

DECPROC NV_OpenIntelDiagInterface, PASCAL, ShareFrameNear16, NEAR
INTEL_DIAG_FRAME_AND_LOCALS
OPENPROC
	sub	cx,cx
	mov	ax,IDIAG_ERROR_INVALID_PARAM
	cmp	fs:[si].OPEN_INPUT.dwOpenKey,INTEL_DIAG_OPEN_KEY
	jne	SetErrorCode

	; return the correct value
        mov     es:[di].OPEN_OUTPUT.dwOpenAck,INTEL_DIAG_OPEN_ACK

	; Tell our logical device that the interface is open
	mov	ds:[ebx].HWLOGDEVCX.wDiagInterfaceOpen,1
	mov	ax,IDIAG_ERROR_NONE
	mov	ecx,1

SetErrorCode:
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,ax
	mov	ax,cx
CLOSEPROC


;==============================================================================
;
; Function:     NV_CloseIntelDiagInterface
;
; Purpose:      This function is called if
;		lpIn->DIAGINPUT.dwFunction = IDIAG_CLOSE_INTERFACE
;
; Arguments:
;		Same frame as NV_ControlIntelDiagnostics
;		ds:ebx	HWLOGDEVCX
;		fs:si	lpIn
;		es:di	lpOut
;
; Returns:
;		Close the interface
;		Set the last error code to None
;		ax	Error Code to return
;
; Preserve:	Nothing
;==============================================================================
DECPROC NV_CloseIntelDiagInterface, PASCAL, ShareFrameNear16, NEAR
INTEL_DIAG_FRAME_AND_LOCALS
OPENPROC
	; Tell our logical device that the interface is closed
	mov	ds:[ebx].HWLOGDEVCX.wDiagInterfaceOpen,0
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,IDIAG_ERROR_NONE
	mov	ax,1
CLOSEPROC


;==============================================================================
;
; Function:	NV_IntelDiagGetErrorCode
;
; Purpose:      This function is called if
;		lpIn->DIAGINPUT.dwFunction = IDIAG_GET_ERROR_CODE
;
; Arguments:
;		Same frame as NV_ControlIntelDiagnostics
;		ds:ebx	HWLOGDEVCX
;		fs:si	lpIn
;		es:di	lpOut
;
; Returns:
;		The output structure is filled in
;		ax	Error Code to return
;
; Preserve:	Nothing
;==============================================================================
GET_ERROR_CODE_OUTPUT	STRUCT
	dwError		DD	0
GET_ERROR_CODE_OUTPUT	ENDS

DECPROC NV_IntelDiagGetErrorCode, PASCAL, ShareFrameNear16, NEAR
INTEL_DIAG_FRAME_AND_LOCALS
OPENPROC
	; Tell our logical device that the interface is closed
	movzx	eax,ds:[ebx].HWLOGDEVCX.wLastDiagError
	mov	es:[di].GET_ERROR_CODE_OUTPUT.dwError,eax
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,IDIAG_ERROR_NONE
	mov	ax,1
CLOSEPROC


;==============================================================================
;
; Function:	NV_IntelDiagGetCRC
;
; Purpose:      This function is called if
;		lpIn->DIAGINPUT.dwFunction = IDIAG_GET_CRC
;
; Arguments:
;		Same frame as NV_ControlIntelDiagnostics
;		ds:ebx	HWLOGDEVCX
;		fs:si	lpIn
;		es:di	lpOut
;
; Returns:
;		The output structure is filled in
;		ax	Error Code to return
;
; Preserve:	Nothing
;==============================================================================
GET_CRC_OUTPUT	STRUCT
	dwCRC0		DD	0	; Red   Channel (if applicable)
	dwCRC1		DD	0       ; Green Channel (if applicable)
	dwCRC2		DD	0       ; Blue  Channel (if applicable)
	dwCRC3		DD	0
GET_CRC_OUTPUT	ENDS

DECPROC NV_IntelDiagGetCRC, PASCAL, ShareFrameNear16, NEAR
INTEL_DIAG_FRAME_AND_LOCALS
OPENPROC
	; Comment to keep assembler from choking... Don't ask me why.
	; We already know that there are no errors in this sequence
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,IDIAG_ERROR_NONE
        mov     esi,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        mov     esi,ds:[esi].HWBOARDCX.pChipRegs

	; Read Red Channel
	mov	ecx,2
	call	GetCRC
	mov	es:[di].GET_CRC_OUTPUT.dwCRC0,eax

	; Read Green Channel
	mov	ecx,1
	call	GetCRC
	mov	es:[di].GET_CRC_OUTPUT.dwCRC1,eax

	; Read Blue Channel
	sub	ecx,ecx
	call	GetCRC
	mov	es:[di].GET_CRC_OUTPUT.dwCRC2,eax

	; I don't know what this one is for, but return 0 in it.
	sub	eax,eax
	mov	es:[di].GET_CRC_OUTPUT.dwCRC3,eax
	mov	ax,1
	jmp	DoneIt

GetCRC:
        pushf
        cli

Loopy:	test	dword ptr ds:[esi + 6013DAH],8
	jnz	Loopy
@@:	test	dword ptr ds:[esi + 6013DAH],8
	jz	@B

        mov	eax,11H
        or      ds:[esi + NV_PRAMDAC_TEST_CONTROL],eax
        mov	eax,ecx
        shl     eax,8
        or      eax,10h
        mov     ds:[esi + NV_PRAMDAC_TEST_CONTROL],eax
        sub	eax,eax
        mov     ds:[esi + NV_PRAMDAC_CHECKSUM],eax
        mov     eax,ds:[esi + NV_PRAMDAC_CHECKSUM]

        ; For TNT2 checksum bug.  If the reset bit is on.  Reset again
        test    eax,1 SHL 24
        jnz     Loopy

        ; Wait one frame
@@:	test	dword ptr ds:[esi + 6013DAH],8
	jnz	@B
@@:	test	dword ptr ds:[esi + 6013DAH],8
	jz	@B

	; read the checksum
        mov     eax,ds:[esi + NV_PRAMDAC_CHECKSUM]
        and     eax,0FFFFFFH

	; The popf should restore the interrupt state.
        popf
	ret
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:	NV_IntelDiagDriverInfo
;
; Purpose:      This function is called if
;		lpIn->DIAGINPUT.dwFunction = IDIAG_GET_DRIVER_INFO
;
; Arguments:
;		Same frame as NV_ControlIntelDiagnostics
;		ds:ebx	HWLOGDEVCX
;		fs:si	lpIn
;		es:di	lpOut
;
; Returns:
;		The output structure is filled in
;		ax	Error Code to return
;
; Preserve:	Nothing
;==============================================================================
GET_DRIVER_INFO_OUTPUT	STRUCT
	dwInterfaceRev	DD	0	; major in hi word, minor in lo word
	dwDay		DD	0	; e.g. 23
	dwMonth		DD	0       ; e.g. 2
	dwYear		DD	0       ; e.g. 1999
	szManufacturer	DB	80 DUP(0)
	szDriverVer	DB	80 DUP(0)
	szBiosVer 	DB	80 DUP(0)
GET_DRIVER_INFO_OUTPUT	ENDS

DECPROC NV_IntelDiagDriverInfo, PASCAL, ShareFrameNear16, NEAR
INTEL_DIAG_FRAME_AND_LOCALS
OPENPROC
	; We already know that there are no errors in this sequence
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,IDIAG_ERROR_NONE
	mov	ecx,ebx

	mov	es:[di].GET_DRIVER_INFO_OUTPUT.dwInterfaceRev,00004H
	mov	eax,dwBuildDay
	mov	es:[di].GET_DRIVER_INFO_OUTPUT.dwDay,eax
	mov	eax,dwBuildMonth
	mov	es:[di].GET_DRIVER_INFO_OUTPUT.dwMonth,eax
	mov	eax,dwBuildYear
	mov	es:[di].GET_DRIVER_INFO_OUTPUT.dwYear,eax

	lea	si,[di].GET_DRIVER_INFO_OUTPUT.szManufacturer
	lea	bx,szNVCompanyString
@@:	mov	al,cs:[bx]
	inc	bx
	mov	es:[si],al
	inc	si
	or	al,al
	jne	@B

	lea	si,[di].GET_DRIVER_INFO_OUTPUT.szDriverVer
	lea	bx,szDriverVersion
@@:	mov	al,cs:[bx]
	inc	bx
	mov	es:[si],al
	inc	si
	or	al,al
	jne	@B

        mov     esi,ds:[ecx].HWLOGDEVCX.pHWBoardCX
        pushd   NV_CFG_BIOS_REVISION
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        mov	ax,SEG lpfnNvConfigGet
        mov	gs,ax
        call    FFP16 PTR gs:[lpfnNvConfigGet]
        shl     edx,16
        mov     dx,ax
        mov     eax,edx
        les	di,lpOut

	mov	cx,8
Loopy:
	shld	edx,eax,4
	shl	eax,4
	and	edx,0FH
	cmp	edx,10
	sbb	ebx,ebx
	not	ebx
	and	ebx,7
	lea	edx,[edx + ebx + 30H]
	mov	es:[di].GET_DRIVER_INFO_OUTPUT.szBiosVer,dl
	inc	di

	cmp	cx,7
	je	DoDot
	cmp	cx,5
	jne	SkipDot
DoDot:
	mov	es:[di].GET_DRIVER_INFO_OUTPUT.szBiosVer,'.'
	inc	di

SkipDot:
	dec	cx
	jne	Loopy
	mov	ax,1
CLOSEPROC


;==============================================================================
;
; Function:	NV_IntelDiagMemoryInfo
;
; Purpose:      This function is called if
;		lpIn->DIAGINPUT.dwFunction = IDIAG_GET_MEMORY_INFO
;
; Arguments:
;		Same frame as NV_ControlIntelDiagnostics
;		ds:ebx	HWLOGDEVCX
;		fs:si	lpIn
;		es:di	lpOut
;
; Returns:
;		The output structure is filled in
;		ax	Error Code to return
;
; Preserve:	Nothing
;==============================================================================
GET_MEMORY_INFO_OUTPUT	STRUCT
	dwKSize		DD	0 ; size in Kilobytes
	dwType		DD	0 ; DRAM (EDO/FPM) = 1, SDRAM = 2, SGRAM = 3
GET_MEMORY_INFO_OUTPUT	ENDS

DECPROC NV_IntelDiagMemoryInfo, PASCAL, ShareFrameNear16, NEAR
INTEL_DIAG_FRAME_AND_LOCALS
OPENPROC
	; We already know that there are no errors in this sequence
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,IDIAG_ERROR_NONE
        mov     esi,ds:[ebx].HWLOGDEVCX.pHWBoardCX

        mov     eax,ds:[esi].HWBOARDCX.dwVideoMemorySize
        shr	eax,10
	mov	es:[di].GET_MEMORY_INFO_OUTPUT.dwKSize,eax

        pushd   NV_CFG_RAM_TYPE
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        mov     ax,SEG lpfnNvConfigGet
        mov     gs,ax
        call    FFP16 PTR gs:[lpfnNvConfigGet]
        les	di,lpOut
	mov	es:[di].GET_MEMORY_INFO_OUTPUT.dwType,eax

	mov	ax,1
CLOSEPROC


;==============================================================================
;
; Function:	NV_IntelDiagClockRates
;
; Purpose:      This function is called if
;		lpIn->DIAGINPUT.dwFunction = IDIAG_GET_CLOCK_RATES
;
; Arguments:
;		Same frame as NV_ControlIntelDiagnostics
;		ds:ebx	HWLOGDEVCX
;		fs:si	lpIn
;		es:di	lpOut
;
; Returns:
;		The output structure is filled in
;		ax	Error Code to return
;
; Preserve:	Nothing
;==============================================================================
GET_CLOCK_RATES_OUTPUT	STRUCT
	dwEngClockKHz	DD	0
	dwMemClockKHz	DD	0
GET_CLOCK_RATES_OUTPUT	ENDS

DECPROC NV_IntelDiagClockRates, PASCAL, ShareFrameNear16, NEAR
INTEL_DIAG_FRAME_AND_LOCALS
OPENPROC
	; We already know that there are no errors in this sequence
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,IDIAG_ERROR_NONE
        mov     esi,ds:[ebx].HWLOGDEVCX.pHWBoardCX

        pushd   NV_CFG_DAC_GRAPHICS_CLOCK
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        mov     ax,SEG lpfnNvConfigGet
        mov     gs,ax
        call    FFP16 PTR gs:[lpfnNvConfigGet]
        shl     edx,16
        mov     dx,ax
        mov     eax,edx
        mov     ecx,1000
        xor     edx,edx
        div     ecx
        les	di,lpOut
        mov     es:[di].GET_CLOCK_RATES_OUTPUT.dwEngClockKHz,eax

        pushd   NV_CFG_DAC_MEMORY_CLOCK
        push    ds:[esi].HWBOARDCX.dwDeviceNum
        mov     ax,SEG lpfnNvConfigGet
        mov     gs,ax
        call    FFP16 PTR gs:[lpfnNvConfigGet]
        shl     edx,16
        mov     dx,ax
        mov     eax,edx
        mov     ecx,1000
        xor     edx,edx
        div     ecx
        les	di,lpOut
        mov     es:[di].GET_CLOCK_RATES_OUTPUT.dwMemClockKHz,eax

	mov	ax,1
CLOSEPROC


;==============================================================================
;
; Function:	NV_IntelDiagPciConfig
;
; Purpose:      This function is called if
;		lpIn->DIAGINPUT.dwFunction = IDIAG_GET_PCI_CONFIG
;
; Arguments:
;		Same frame as NV_ControlIntelDiagnostics
;		ds:ebx	HWLOGDEVCX
;		fs:si	lpIn
;		es:di	lpOut
;
; Returns:
;		The output structure is filled in
;		ax	Error Code to return
;
; Preserve:	Nothing
;==============================================================================
GET_PCI_CONFIG_OUTPUT	STRUCT
	dwPCI0	DD	0	; PCI DEVICE hi 16 bits: PCI Vendor lo 16
	dwPCI1	DD	0	; PCI Class high 24 bits: PCI Revision lo 8
	dwPCI2	DD	0	; PCI SubSys hi 16 bits: PCI subsys vendor lo 16
	dwPCI3	DD	0	; PCI framebuffer address
GET_PCI_CONFIG_OUTPUT	ENDS

DECPROC NV_IntelDiagPciConfig, PASCAL, ShareFrameNear16, NEAR
INTEL_DIAG_FRAME_AND_LOCALS
OPENPROC
	; We already know that there are no errors in this sequence
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,IDIAG_ERROR_NONE
        mov     esi,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        mov     ecx,ds:[esi].HWBOARDCX.pChipRegs

        ; return PCI Device ID (upper 16), PCI Vendor ID (lower 16)
        mov     eax,ds:[ecx + 1800H]
        mov     es:[di].GET_PCI_CONFIG_OUTPUT.dwPCI0,eax

        ; return PCI Class Code high high 24 bits, Revision ID low 8 bits
        mov     eax,ds:[ecx + 1808H]
        mov     es:[di].GET_PCI_CONFIG_OUTPUT.dwPCI1,eax

        ; return PCI Subsystem ID (upper 16), PCI Subsystem Vendor ID (lower 16)
        mov     eax,ds:[ecx + 180CH]
        mov     es:[di].GET_PCI_CONFIG_OUTPUT.dwPCI2,eax

        ; return PCI Frame buffer base address
        mov     eax,ds:[ecx + 1814H]
        and     eax,0FF000000H
        mov     es:[di].GET_PCI_CONFIG_OUTPUT.dwPCI3,eax
        mov	ax,1
CLOSEPROC


;==============================================================================
;
; Function:	NV_IntelDiagBusConfig
;
; Purpose:      This function is called if
;		lpIn->DIAGINPUT.dwFunction = IDIAG_GET_BUS_CONFIG
;
; Arguments:
;		Same frame as NV_ControlIntelDiagnostics
;		ds:ebx	HWLOGDEVCX
;		fs:si	lpIn
;		es:di	lpOut
;
; Returns:
;		The output structure is filled in
;		ax	Error Code to return
;
; Preserve:	Nothing
;==============================================================================
GET_BUS_CONFIG_OUTPUT	STRUCT
	dwBusMode	DD	0 ; PCI 33MHZ = 1, PCI 66MHZ = 2, AGP = 3
	dwAGPRate	DD	0 ; NA = 0, 1X = 1, 2X = 2, 4X = 3
	dwAGPMode	DD	0 ; NA = 0, Pipelined = 1, Sideband = 2
	dwFastWrite	DD	0 ; NA = 0, Disabled = 1, Enabled = 2
GET_BUS_CONFIG_OUTPUT	ENDS

DECPROC NV_IntelDiagBusConfig, PASCAL, ShareFrameNear16, NEAR
INTEL_DIAG_FRAME_AND_LOCALS
OPENPROC
	; We already know that there are no errors in this sequence
	mov	ds:[ebx].HWLOGDEVCX.wLastDiagError,IDIAG_ERROR_NONE
        mov     esi,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        mov     ecx,ds:[esi].HWBOARDCX.pChipRegs

        mov     eax,ds:[esi].HWBOARDCX.dwBusType
	cmp	eax,NV_BUS_TYPE_AGP
	jne	BusPci
BusAgp:
        mov     es:[di].GET_BUS_CONFIG_OUTPUT.dwBusMode,3

	; Bus rate is in chip reg at 184CH
        mov     eax,ds:[ecx + 184CH]
        mov     ebx,eax
        and     ebx,7
        test    ebx,4
        jz      @f
        mov     ebx,3
@@:     mov     es:[di].GET_BUS_CONFIG_OUTPUT.dwAGPRate,ebx

        ; AGP side band
        test    eax,1 SHL 8
        setnz   bl
        inc     ebx
	mov     es:[di].GET_BUS_CONFIG_OUTPUT.dwAGPMode,ebx

        ; AGP fast write
        test    eax,1 SHL 3
        setnz   bl
        inc     ebx
	mov     es:[di].GET_BUS_CONFIG_OUTPUT.dwFastWrite,ebx
	jmp	DoneIt

BusPci:
        ; Bus type is PCI
        mov     es:[di].GET_BUS_CONFIG_OUTPUT.dwBusMode,1

	sub	eax,eax
     	mov     es:[di].GET_BUS_CONFIG_OUTPUT.dwAGPRate,eax
	mov     es:[di].GET_BUS_CONFIG_OUTPUT.dwAGPMode,eax
	mov     es:[di].GET_BUS_CONFIG_OUTPUT.dwFastWrite,eax

DoneIt:
	mov	ax,1
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWLDPAT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwldpat.asm
;
; Purpose:      This file contains routines to load the different kinds
;               of patterns into the hardware when the patterns are
;               going to be used for 3operand blts or cases where there
;               might be xparency.
;
;==============================================================================
.586
incLogical = 1
incDrawMode = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwcrtc.inc
include hwboard.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     HW_LoadSolidPattern
;
; Purpose:      This function is called by the generic code to load
;               up a solid pattern that will be used in a 3operand blt
;               or in a situation where xparency may be required.
;
; Arguments:
;               ds                      CXSel
;               ebx                     HWLOGDEVCX ptr
;               edx                     Solid Color
;
; Returns:      None
;
; Preserve:     ds,es,esi
;==============================================================================
DECPROC HW_LoadSolidPattern, PASCAL, NOFRAME, NEAR
OPENPROC
	mov	ecx,ds:[ebx].HWLOGDEVCX.dwPatternColorFormat
        or      edx,ds:[ebx].HWLOGDEVCX.dwColorAlphaMask
        mov	ds:[ebx].HWLOGDEVCX.dwPatternAlpha0,edx
        mov	ds:[ebx].HWLOGDEVCX.dwPatternAlpha1,edx

        mov     ebx,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ebx,eax

        ; Load the push buffer ptr
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        CHECKDMASPACE ds,ebx,edi,18H
        mov     eax,CHNRUN(ContextPattern.SetColorFormat,1)
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        mov     eax,CHNRUN(ContextPattern.SetPatternSelect,3)
        mov     ecx,NV044_SET_PATTERN_SELECT_MONOCHROME
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ecx
        mov     ds:[edi + 10H],edx
        mov     ds:[edi + 14H],edx
        add     edi,18H

        mov     ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_LoadMonoPattern
;
; Purpose:      This function is called by the generic code to load
;               up a mono pattern that will be used in a 3operand blt
;               or in a situation where xparency may be required.
;
; Arguments:
;               ds                      CXSel
;               ebx                     HWLOGDEVCX ptr
;               es:esi                  ptr to pattern to use
;               ecx                     Color for 0 bits
;               edx                     Color for 1 bits
;               eax                     0 if 0 src bits should be skipped
;                                               (transparent mode)
;                                       -1 if 0 src bits should be expanded
;                                               and written (opaque mode)
; Returns:      None
;
; Preserve:     ds
;==============================================================================
DECPROC HW_LoadMonoPattern, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Hatch is similar to mono, except we have to worry about
        ; the possibility of the bg being xparent.
        or      edx,ds:[ebx].HWLOGDEVCX.dwColorAlphaMask
        or      ecx,ds:[ebx].HWLOGDEVCX.dwColorAlphaMask
        and     ecx,eax
        mov	ds:[ebx].HWLOGDEVCX.dwPatternAlpha0,ecx
        mov	ds:[ebx].HWLOGDEVCX.dwPatternAlpha1,edx
        push    edx
        push    ecx

        mov     eax,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,eax,ecx

        ; Load the push buffer ptr
        mov     edi,ds:[eax].HWBOARDCX.pCurrentPushBufferOffset

        ; Get the pattern
        mov     cl,es:[esi + 08H]
        mov     dl,es:[esi + 18H]
        mov     ch,es:[esi + 0CH]
        mov     dh,es:[esi + 1CH]
        shl     ecx,10H
        shl     edx,10H
        mov     cl,es:[esi + 00H]
        mov     dl,es:[esi + 10H]
        mov     ch,es:[esi + 04H]
        mov     dh,es:[esi + 14H]

        ; Put code in here to set the mono or hatch pattern.
        ; ecx = 0 pattern bits map to this color
        ; edx = 1 pattern bits map to this color

        CHECKDMASPACE ds,eax,edi,20H
        mov	esi,ds:[ebx].HWLOGDEVCX.dwPatternColorFormat
        mov     dword ptr ds:[edi + 00H],CHNRUN(ContextPattern.SetColorFormat,1)
        mov     ds:[edi + 04H],esi
        mov     dword ptr ds:[edi + 08H],CHNRUN(ContextPattern.SetPatternSelect,5)
        mov     dword ptr ds:[edi + 0CH],NV044_SET_PATTERN_SELECT_MONOCHROME
        pop     dword ptr ds:[edi + 10H]
        pop     dword ptr ds:[edi + 14H]
        mov     ds:[edi + 18H],ecx
        mov     ds:[edi + 1CH],edx
        add     edi,20H

        mov     ds:[eax].HWBOARDCX.pCurrentPushBufferOffset,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_LoadColorPattern
;
; Purpose:      This function is called by the generic code to load
;               up a color pattern that will be used in a 3operand blt
;               or in a situation where xparency may be required.
;
; Arguments:
;               ds                      CXSel
;               ebx                     HWLOGDEVCX ptr
;               es:esi                  DIB_Brush ptr
;
; Returns:      None
;
; Preserve:     ds
;==============================================================================
DECPROC HW_LoadColorPattern, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Load the HWBOARDCX
        mov     eax,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,eax,ecx

        mov     ecx,ds:[ebx].HWLOGDEVCX.dwColorPatternAndHeaderSize

        ; Load the push buffer ptr
        mov     edi,ds:[eax].HWBOARDCX.pCurrentPushBufferOffset
        lea     esi,[esi].DIB_Brush8.dp8BrushBits

        ; Put code in here to set the color brush
        ; eax   bits per pixel of a pixel in the pattern
        ; es:esi ptr to 64 consecutive pixels describing the pattern

        ; Setup and copy the color pattern into the chip
        CHECKDMASPACE ds,eax,edi,ecx
        mov     edx,ds:[ebx].HWLOGDEVCX.dwPatternColorFormat
        mov     dword ptr ds:[edi + 00H],CHNRUN(ContextPattern.SetColorFormat,6)
        mov     ds:[edi + 04H],edx
        mov	dword ptr ds:[edi + 08H],NV044_SET_MONOCHROME_FORMAT_CGA6_M1
        mov	dword ptr ds:[edi + 0CH],NV044_SET_MONOCHROME_SHAPE_8X_8Y
        mov     dword ptr ds:[edi + 10H],NV044_SET_PATTERN_SELECT_COLOR
        mov	edx,ds:[ebx].HWLOGDEVCX.dwPatternAlpha0
        mov     dword ptr ds:[edi + 14H],edx
        mov	edx,ds:[ebx].HWLOGDEVCX.dwPatternAlpha1
        mov     dword ptr ds:[edi + 18H],edx
        mov     edx,ds:[ebx].HWLOGDEVCX.dwColorPatternMethodOffset
        mov     ds:[edi + 1CH],edx
        sub     ecx,20H
        add     edi,20H
@@:
	mov     ebx,es:[esi + 00H]
        mov     edx,es:[esi + 04H]
        add     esi,08H
        mov     ds:[edi + 00H],ebx
        mov     ds:[edi + 04H],edx
        add     edi,08H
        sub     ecx,08H
        jg      @B

        mov     ds:[eax].HWBOARDCX.pCurrentPushBufferOffset,edi
        mov     eax,1
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWLINE.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwline.asm
;
; Purpose:      This file implements the hardware specific Polyline function.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
incFont     = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

PUBLIC  bRop2ToSrc3
bRop2ToSrc3     LABEL   BYTE
DB      000H,   011H,   022H,   033H
DB      044H,   055H,   066H,   077H
DB      088H,   099H,   0AAH,   0BBH
DB      0CCH,   0DDH,   0EEH,   0FFH
DB      000H,   011H,   022H,   033H
DB      044H,   055H,   066H,   077H
DB      088H,   099H,   0AAH,   0BBH
DB      0CCH,   0DDH,   0EEH,   0FFH

PUBLIC  dwLineStyle
dwLineStyle     LABEL   DWORD
DD      000000000H      ; LS_SOLID
DD      00000FF00H      ; LS_DASHED
DD      00F0F0F0FH      ; LS_DOTTED
DD      00FF0FF00H      ; LS_DOTDASHED
DD      00F0F0F00H      ; LS_DASHDOTDOT
DD      000000000H      ; LS_SOLID
DD      000FF0000H      ; LS_DASHED
DD      0F0F0F0F0H      ; LS_DOTTED
DD      000FF0FF0H      ; LS_DOTDASHED
DD      000F0F0F0H      ; LS_DASHDOTDOT
DD      000000000H      ; LS_SOLID
DD      000FF0000H      ; LS_DASHED
DD      0F0F0F0F0H      ; LS_DOTTED
DD      00FF000FFH      ; LS_DOTDASHED
DD      0F0F0F000H      ; LS_DASHDOTDOT

PUBLIC  dwMultiPassSafe
dwMultiPassSafe LABEL   DWORD  ; Rop3  Reverse Polish
DD      1               ; Rop2 =  00   0
DD      0               ; Rop2 =  11   DSon
DD      1               ; Rop2 =  22   DSna
DD      1               ; Rop2 =  33   Sn
DD      0               ; Rop2 =  44   SDna
DD      0               ; Rop2 =  55   Dn
DD      0               ; Rop2 =  66   DSx
DD      0               ; Rop2 =  77   DSan
DD      1               ; Rop2 =  88   DSa
DD      0               ; Rop2 =  99   DSxn
DD      1               ; Rop2 =  AA   D
DD      1               ; Rop2 =  BB   DSno
DD      1               ; Rop2 =  CC   S
DD      0               ; Rop2 =  DD   SDno
DD      1               ; Rop2 =  EE   DSo
DD      1               ; Rop2 =  FF   1

;==============================================================================
;
; Function:     HW_Polyline
;
; Purpose:      This is the hardware specific Polyline routine.
;
; Arguments:
;               ds                      CXSel
;               pHWLogdevCXOffset       HWLOGDEV ptr
;               gs:esi                  lpDstDev ptr
;               lpPoints                list of points
;               dwCount                 Number of points in list lpPoints
;                                       Lines should be drawn between the
;                                       first and second pair of points,
;                                       the second and third pair, the
;                                       third and fourth, etc.  Hence,
;                                       you will draw dwCount - 1 lines.
;               dwPenColor              Line Color
;               dwRop2                  Rop 2 -- from 00H to 0FH inclusive
;               wClipBottom             These four values define the clip
;               wClipRight              rectangle. If wClipLeft equals -1,
;               wClipTop                there is no clip rectangle. The
;               wClipLeft               clip rect is validated by the
;                                       generic code.
;
; Returns:
;               eax     0       punt call to the DIBENG
;                       > 0     the call succeeded
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_Polyline, PASCAL, FRAME, NEAR
PARMD   pHWLogdevCXOffset
PARMD   lpPoints
PARMD   dwCount
PARMD   dwPenColor
PARMD   dwBkColor
PARMD   dwRop
PARMD   dwStyle
PARMW   wClipBottom
PARMW   wClipRight
PARMW   wClipTop
PARMW   wClipLeft
LOCALD  dwCountCopy
LOCALD  pHWBoardCXOffset
OPENPROC
        mov     ebx,pHWLogdevCXOffset
        push    ds:[ebx].HWLOGDEVCX.dwPatternAlpha1
        push    ds:[ebx].HWLOGDEVCX.dwPatternAlpha0

        mov     ebx,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        mov     pHWBoardCXOffset,ebx
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ebx,eax

        ; Load the push buffer ptr
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,gs:[esi].DIBENGINEHDR.deBitsOffset
        CHECKDSTBASE ds,ebx,edi,eax,<gs:[esi].DIBENGINEHDR.deDeltaScan>

        ; The global clip rect must be set if lpClipRect is not NULL
        cmp     wClipLeft,-1
        je      @F
        CHECKDMASPACE ds,ebx,edi,0CH
        mov     eax,CHNRUN(ContextClipRect.SetPoint,2)
        mov     ecx,dword ptr wClipLeft
        mov     edx,dword ptr wClipRight
        sub     edx,ecx
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        mov     ds:[edi + 08H],edx
        add     edi,0CH
@@:
        ; Set the rop and then the color
        CHECKDMASPACE ds,ebx,edi,34H
        mov     dword ptr ds:[edi + 00H],CHNRUN(ContextPattern.SetMonochromeColor0,2)
        pop     dword ptr ds:[edi + 04H]
        pop     dword ptr ds:[edi + 08H]

        mov     eax,dwRop
        mov     ebx,CHNRUN(ContextRop.SetRop5,1)
        movzx   ecx,cs:bRop2ToSrc3[eax]
        mov     ds:[edi + 0CH],ebx
        mov     ds:[edi + 10H],ecx

        ; Must set the line object in the sub-channel
        mov     eax,CHNRUN(RenderSolidLinHdr.object,1)
        mov     ecx,OBJ_SOLID_LINE
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ecx
        mov     ebx,pHWLogdevCXOffset
        mov     eax,CHNRUN(RenderSolidLin.SetColorFormat,2)
        mov     edx,ds:[ebx].HWLOGDEVCX.dwSolidLinColorFormat
        mov     ecx,dwPenColor
        mov     ds:[edi + 1CH],eax
        mov     ds:[edi + 20H],edx
        mov     ds:[edi + 24H],ecx

        ; Blast in the first pair of points
        sub     esi,esi
        les     si,lpPoints
        mov     eax,CHNRUN(RenderSolidLin.Lin.point0,2)
        mov     ecx,es:[esi]
        mov     edx,es:[esi + 4]
        add     esi,8
        mov     ds:[edi + 28H],eax
        mov     ds:[edi + 2CH],ecx
        mov     ds:[edi + 30H],edx
        add     edi,34H

        ; If we are done, then get out. Otherwise wait for space.
        ; We can draw 20H lines with one header and we have already
        ; used the first two points to draw the first line. Hence
        ; the number of dwords of space we need is:
        ; 21H * (dwCount >> 5) + (dwCount AND 1FH) +
        ;       1 (if (dwCount AND 1FH) != 0)
        mov     ecx,dwCount
        sub     ecx,2
        jle     Next
        mov     edx,ecx
        mov     ebx,ecx
        shr     edx,5
        and     ebx,1FH
        imul    eax,edx,(21H * 4)
        sub     ecx,ecx
        cmp     ebx,1
        sbb     ecx,-1
        add     ecx,ebx
        lea     eax,[eax][ecx * 4]
        mov     ecx,pHWBoardCXOffset
        CHECKDMASPACE ds,ecx,edi,eax

        ; There are edx chunks of 20H lines to do
        or      edx,edx
        je      Parts
Big1:   mov     ecx,08H
        mov     dword ptr ds:[edi],CHNRUN(RenderSolidLin.PolyLin,20H)
        add     edi,4
Small1: mov     eax,es:[esi]
        mov     ds:[edi],eax
        mov     eax,es:[esi + 04H]
        mov     ds:[edi + 04H],eax
        mov     eax,es:[esi + 08H]
        mov     ds:[edi + 08H],eax
        mov     eax,es:[esi + 0CH]
        mov     ds:[edi + 0CH],eax
        add     esi,10H
        add     edi,10H
        dec     ecx
        jne     Small1
        dec     edx
        jne     Big1

Parts:  ; There are ebx lines left to do
        or      ebx,ebx
        je      Next
        mov     ecx,ebx
        shl     ebx,10H + 2
        mov     bx,CHNRUN(RenderSolidLin.PolyLin,0)
        mov     ds:[edi],ebx
        add     edi,4
@@:     mov     eax,es:[esi]
        add     esi,4
        mov     ds:[edi],eax
        add     edi,04H
        dec     ecx
        jne     @B
Next:
        ; Reset the clip rect if needed
        cmp     wClipLeft,-1
        je      Done
        mov     ecx,pHWBoardCXOffset
        CHECKDMASPACE ds,ecx,edi,0CH
        mov     eax,CHNRUN(ContextClipRect.SetPoint,2)
        sub     ecx,ecx
        mov     edx,07FFF7FFFH
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        mov     ds:[edi + 08H],edx
        add     edi,0CH
Done:
        mov     ebx,pHWBoardCXOffset
        SETPUTPTR ds,ebx,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_PolyStyledLine
;
; Purpose:      This is the hardware specific PolyStyledLine routine.
;
; Arguments:
;               ds                      CXSel
;               pHWLogdevCXOffset       HWLOGDEV ptr
;               lpDstDev                lpDstDev ptr
;               lpPoints                list of points
;               dwCount                 Number of points in list lpPoints
;                                       Lines should be drawn between the
;                                       first and second pair of points,
;                                       the second and third pair, the
;                                       third and fourth, etc.  Hence,
;                                       you will draw dwCount - 1 lines.
;               dwPenColor              Line Color
;               dwRop2                  Rop 2 -- from 00H to 0FH inclusive
;               wClipBottom             These four values define the clip
;               wClipRight              rectangle. If wClipLeft equals -1,
;               wClipTop                there is no clip rectangle. The
;               wClipLeft               clip rect is validated by the
;                                       generic code.
;
; Returns:
;               eax     0       punt call to the DIBENG
;                       > 0     the call succeeded
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_PolyStyledLine, PASCAL, FRAME, NEAR
PARMD   pHWLogdevCXOffset
PARMD   lpPoints
PARMD   dwCount
PARMD   dwPenColor
PARMD   dwBkColor
PARMD   dwRop
PARMD   dwStyle
PARMW   wClipBottom
PARMW   wClipRight
PARMW   wClipTop
PARMW   wClipLeft
LOCALD  dwDestLeft
LOCALD  dwDestRight
LOCALD  dwStyleOffset
LOCALD  dwHWStyle
LOCALD  dwLocalStyle
LOCALD  dwRet
LOCALD  pHWBoardCXOffset
OPENPROC
        cmp     word ptr dwCount,2
        je      @f

        ; We can't handle some rops that change if we render more than once.
        ; We need to be able to back out and fail to DIBENG if there are
        ; non-slope0 lines bury inside a long chain of polylines
        mov     eax,dwRop
        cmp     cs:dwMultiPassSafe[eax*4],1
        jne     Fail
@@:
        mov     ecx,gs:[esi].DIBENGINEHDR.deBitsOffset
        mov     edx,gs:[esi].DIBENGINEHDR.deDeltaScan
        xor     esi,esi
        les     si,lpPoints
        mov     eax,es:[esi]
        mov     ebx,es:[esi + 4]
        add     esi,4
        call    SETUPPATTERNHWFORSTYLELINE
        test    eax,eax
        jz      Fail

DoStyleLine:
        dec     word ptr dwCount
        mov     dwRet,1

        mov     ebx,pHWLogdevCXOffset
        push    ds:[ebx].HWLOGDEVCX.dwPatternAlpha1
        push    ds:[ebx].HWLOGDEVCX.dwPatternAlpha0

        ; Sync to other contexts
        mov     ebx,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        mov     pHWBoardCXOffset,ebx
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ebx,eax

        ; Load the push buffer ptr
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        CHECKDSTBASE ds,ebx,edi,ecx,edx

        ; Set the pattern color even if it is not used
        CHECKDMASPACE ds,ebx,edi,0CH
        mov     eax,CHNRUN(ContextPattern.SetMonochromeColor0,2)
        mov     ds:[edi + 00H],eax
        pop     dword ptr ds:[edi + 04H]
        pop     dword ptr ds:[edi + 08H]
        add     edi,0CH

DoNextLine:
        ; Check for space and program the blt
        mov     edx,pHWBoardCXOffset
        CHECKDMASPACE ds,edx,edi,44H
        mov     eax,CHNRUN(ContextPattern.SetMonochromeShape,6)
        mov     ebx,dwHWStyle
        mov     ecx,NV044_SET_PATTERN_SELECT_MONOCHROME
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx
        mov     ds:[edi + 08H],ecx
        mov     eax,dwPenColor
        mov     ecx,dwBkColor
        mov     edx,pHWLogdevCXOffset
        or      eax,ds:[edx].HWLOGDEVCX.dwColorAlphaMask
        or      ecx,ds:[edx].HWLOGDEVCX.dwColorAlphaMask
        mov     ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],ecx
        mov     eax,dwLocalStyle
        mov     eax,cs:dwLineStyle[eax*4]
        mov     ecx,dwStyleOffset
        ror     eax,cl
        bswap   eax
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],eax
        mov     eax,dwRop
        movzx   ecx,cs:bConvertRop2ToRop3[eax]
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        mov     ds:[edi + 1CH],eax
        mov     ds:[edi + 20H],ecx
        xor     ecx,ecx
        mov     edx,7FFF7FFFH
        cmp     wClipLeft,-1
        je      @F
        mov     ecx,dword ptr wClipLeft
        mov     edx,dword ptr wClipRight
@@:
        mov     eax,pHWLogdevCXOffset
        mov     dword ptr ds:[edi + 24H],CHNRUN(RectAndText.SetColorFormat,1)
        mov     eax,ds:[eax].HWLOGDEVCX.dwSolidLinColorFormat
        mov     ds:[edi + 28H],eax

        mov     eax,CHNRUN(RectAndText.ClipPoint0B,5)
        mov     ds:[edi + 2CH],eax
        mov     ds:[edi + 30H],ecx
        mov     ds:[edi + 34H],edx
        mov     ecx,dwDestLeft
        mov     edx,dwDestRight
        ; The color field next is irrelevant but NV architecture requires it
        mov     ds:[edi + 38H],eax
        mov     ds:[edi + 3CH],ecx
        mov     ds:[edi + 40H],edx
        add     edi,44H
        dec     word ptr dwCount
        jle     CleanUp
        mov     eax,es:[esi]
        mov     ebx,es:[esi + 4]
        add     esi,4
        push    edi
        call    SETUPPATTERNHWFORSTYLELINE
        pop     edi
        test    eax,eax
        jnz     DoNextLine
        mov     dwRet,eax

CleanUp:
        mov     edx,pHWBoardCXOffset
        CHECKDMASPACE ds,edx,edi,14H
        mov     eax,CHNRUN(ContextPattern.SetMonochromeShape,4)
        mov     ebx,NV044_SET_MONOCHROME_SHAPE_8X_8Y
        mov     ecx,NV044_SET_PATTERN_SELECT_MONOCHROME
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx
        mov     ds:[edi + 08H],ecx
        mov     eax,-1
        mov     ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],eax
        add     edi,14H
        SETPUTPTR ds,edx,edi
        mov     eax,dwRet
        jmp     Done
Fail:
        xor     eax,eax
Done:
CLOSEPROC


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SETUPPATTERNHWFORSTYLELINE
;
; This macro breaks down the input line into HW rectagular format.  The
; style offset of each start line is also computed and stored.
;
; dwDestLeft    line describes in HW rect (left, top)
; dwDestRight   line describes in HW rect (right, bottom)
; dwStyleOffset Offset to the pattern for starting pixel
; dwHWStyle     Format of the Style (x major or y major)
;
; Arguments:
;       eax     Point0 (x,y)
;       ebx     Point1 (x,y)
;
; Returns:
;       eax     0   Cannot convert.  The line is not a slope 0 line
;       eax     1   Success
;
PUBLIC  SETUPPATTERNHWFORSTYLELINE
SETUPPATTERNHWFORSTYLELINE      PROC    NEAR

        xor     edi,edi
        cmp     ax,bx
        jne     NotVerticalLine
        cmp     eax,ebx
        jle     VerticalForwardLine
        mov     edi,eax
        mov     eax,ebx
        mov     ebx,edi
        add     eax,10000H
        add     ebx,10001H
        mov     dwDestLeft,eax
        mov     dwDestRight,ebx
        ror     eax,16
        dec     eax
        and     eax,31
        mov     edi,39
        sub     edi,eax
        mov     dwStyleOffset,edi
        mov     eax,5
        add     eax,dwStyle
        mov     dwLocalStyle,eax
        mov     eax,NV044_SET_MONOCHROME_SHAPE_1X_64Y
        mov     dwHWStyle,eax
        jmp     Success1

VerticalForwardLine:
        inc     ebx
        mov     dwDestLeft,eax
        mov     dwDestRight,ebx
        ror     eax,16
        and     eax,31
        mov     dwStyleOffset,eax
        mov     eax,NV044_SET_MONOCHROME_SHAPE_1X_64Y
        mov     dwHWStyle,eax
        mov     eax,dwStyle
        mov     dwLocalStyle,eax
        jmp     Success1

NotVerticalLine:
        ror     eax,16
        ror     ebx,16
        cmp     ax,bx
        jne     Fail1
        cmp     eax,ebx
        jle     HorizontalForwardLine

        ;!!! Punt Horizontal Backward Styled Line to dibengine for now. Temporal fix for 33580.
        jmp     Fail1

        mov     edi,eax
        mov     eax,ebx
        mov     ebx,edi
        ror     eax,16
        ror     ebx,16
        inc     eax
        add     ebx,10001H
        mov     dwDestLeft,eax
        mov     dwDestRight,ebx
        dec     eax
        and     eax,31
        mov     edi,41
        sub     edi,eax
        mov     dwStyleOffset,edi
        mov     eax,10
        add     eax,dwStyle
        mov     dwLocalStyle,eax
        mov     eax,NV044_SET_MONOCHROME_SHAPE_64X_1Y
        mov     dwHWStyle,eax
        jmp     Success1

HorizontalForwardLine:
        inc     ebx
        ror     eax,16
        ror     ebx,16
        mov     dwDestLeft,eax
        mov     dwDestRight,ebx
        and     eax,31
        mov     dwStyleOffset,eax
        mov     eax,NV044_SET_MONOCHROME_SHAPE_64X_1Y
        mov     dwHWStyle,eax
        mov     eax,dwStyle
        mov     dwLocalStyle,eax

Success1:
        mov     eax,1
        jmp     Done1
Fail1:
        xor     eax,eax
Done1:
        ret

SETUPPATTERNHWFORSTYLELINE      ENDP

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWLOGDEV2.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwlogdev2.asm
;
; Purpose:      This file contains all the hardware specific
;               logical DEVICE specific run-time routines.
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include gngdi.inc
include hwgdi.inc
include files.inc
include hwmacs.inc
include nvcm.inc
include nvreg.inc
include dxshare.inc
include escape.inc
include ..\..\..\..\..\sdk\nvidia\inc\nvrmarch.inc
include ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc

OPENSEG  _DATA, USE16, DATA
TempStack       DB 400H DUP(0)
TempStackTop    DB 10H  DUP(0)
dwOldSS         DD      0
dwOldEsp        DD      0
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE
PUBLIC  szDDrawBinaryName, szDDrawEntryPointName, szOGLRegKeyName
szDDrawBinaryName       DB      NV4_DDRAW_BINARY,0
szDDrawEntryPointName   DB      "DriverInit",0
szOGLRegKeyName         DB      "RIVATNT",0

;==============================================================================
;
; Function:     HW_LogdevMessage
;
; Purpose:      This routine gets called whenver there is an
;               message to send to all objects. There are
;               a few different messages.  See gngdi.inc
;               for details.
;
; Arguments:
;               ds                      Context Selector
;               pHWLogdevCXOffset               HWCRTCCX ptr
;               dwMessage               which message
;               dwData1                 additional data that depends
;                                       upon the message type
;               dwData2                 additional data that depends
;                                       upon the message type
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_LogdevMessage, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD   dwMessage
PARMD   dwData1
PARMD   dwData2
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWLogdevCXOffset

        mov     eax,dwMessage
        cmp     eax,MSG_PREMODESET
        je      PreMS
        cmp     eax,MSG_POSTMODESET
        je      PostMS
        cmp     eax,MSG_DIRECTX_ENUM
        je      DXEnum
        cmp     eax,MSG_DIRECTXON
        je      DXOn
        cmp     eax,MSG_DIRECTXOFF
        je      DXOff
        cmp     eax,MSG_DOSON
        je      DosOn
        cmp     eax,MSG_DOSOFF
        je      DosOff
        cmp     eax,MSG_POWERON
        je      PowerOn
        cmp     eax,MSG_POWEROFF
        je      PowerOff
        cmp     eax,MSG_DISABLE
        je      DrvDis
        cmp     eax,MSG_LOGDEVMOVED
        je      logdevMoved
        cmp     eax,MSG_DEVICESREMAPPED
        je      DevRemap
        cmp     eax,MSG_DISPLAY_DRIVER_UNLOADING
        je      DispUnload
        jmp     DoneIt

PreMS:
        cmp     ds:[esi].HWLOGDEVCX.dwDirectXActive,0
        je      DoneIt

        ; Tell DDRAW we are going to switch the mode.
        les     di,ds:[esi].HWLOGDEVCX.lpDirectXSharedData
        movzx   edi,di
        push    esi
        push    es:[edi].DISPDRVDIRECTXCOMMON.dwFlatCodeSel
        push    es:[edi].DISPDRVDIRECTXCOMMON.pfnInterfaceFunc
        pushd   GDIDX_PRE_MODESET_NOTIFY
        pushd   0
        call    DirectCallToFlatland
        jmp     DoneIt

PostMS:
        push    pHWLogdevCXOffset
        push    dwData1
        call    NV_PostModeset

        ; We are no longer initting after the first modeset
        mov     ds:[esi].HWLOGDEVCX.dwInitting,0

        jmp     DoneIt

DXEnum:
        ; Init the shared Data structure and inform DirectX
        ; of our 16 bit capabilities
        push    pHWLogdevCXOffset
        pushd   0
        CALLFAR16 NV_CreateDrvObj
        jmp     DoneIt

DXOn:
        ; DirectX is coming up
        mov     ds:[esi].HWLOGDEVCX.dwDirectXActive,1
        jmp     DoneIt

DXOff:
        mov     ds:[esi].HWLOGDEVCX.dwDirectXActive,0
        jmp     DoneIt

DosOff:
PowerOn:
        les     di,ds:[esi].HWLOGDEVCX.lpDirectXSharedData
        movzx   edi,di
        push    esi
        push    es:[edi].DISPDRVDIRECTXCOMMON.dwFlatCodeSel
        push    es:[edi].DISPDRVDIRECTXCOMMON.pfnInterfaceFunc
        pushd   GDIDX_EXIT_FULL_SCREEN_DOS
        pushd   0
        call    DirectCallToFlatland
        jmp     DoneIt

DosOn:
PowerOff:
        les     di,ds:[esi].HWLOGDEVCX.lpDirectXSharedData
        movzx   edi,di
        push    esi
        push    es:[edi].DISPDRVDIRECTXCOMMON.dwFlatCodeSel
        push    es:[edi].DISPDRVDIRECTXCOMMON.pfnInterfaceFunc
        pushd   GDIDX_ENTER_FULL_SCREEN_DOS
        pushd   0
        call    DirectCallToFlatland
        jmp     DoneIt

DrvDis:
        jmp     DoneIt

logdevMoved:
        push    esi
        push    dwData1
        call    NV_PostModeset
        jmp     DoneIt

DevRemap:
        push    esi
        call    NV_DevicesRemapped
        jmp     DoneIt

DispUnload:
        les     di,ds:[esi].HWLOGDEVCX.lpDirectXSharedData
        movzx   edi,di
        push    esi
        push    es:[edi].DISPDRVDIRECTXCOMMON.dwFlatCodeSel
        push    es:[edi].DISPDRVDIRECTXCOMMON.pfnInterfaceFunc
        pushd   GDIDX_DRIVER_UNLOADING
        pushd   0
        call    DirectCallToFlatland
        jmp     DoneIt

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:	HW_DriverTwinviewStateChanging
;
; Purpose:	This is called when the twinview state is changing
;		We may be going in or out of clone mode or in or out
;		of multimon mode.
;		Right now we are only calling this when going in or
;		out of muti-mon to inform the DX driver so they can
;		change resource allocation.
;
; Arguments:
;               pHWLogdevCXOffsetPrimary
;               pHWLogdevCXOffsetSecondary
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_DriverTwinviewStateChanging, PASCAL, FRAME, FAR16
PARMD	pHWLogdevCXOffsetPrimary
PARMD	pHWLogdevCXOffsetSecondary
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWLogdevCXOffsetPrimary

        les     di,ds:[esi].HWLOGDEVCX.lpDirectXSharedData
        movzx   edi,di
        push    esi
        push    es:[edi].DISPDRVDIRECTXCOMMON.dwFlatCodeSel
        push    es:[edi].DISPDRVDIRECTXCOMMON.pfnInterfaceFunc
        pushd   GDIDX_EARLY_DX_CONNECT
        pushd   0
        call    DirectCallToFlatland

        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_DevicesRemapped
;
; Purpose:      This routine gets called to update info when the devices
;               get remapped.
;
; Arguments:
;               pHWLogdevCXOffset
;               pDibeng
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_DevicesRemapped, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
LOCALD  dwNumCRTCs
LOCALD  dwCountCRTCs
OPENPROC
        PUSHR   esi
        mov     esi,pHWLogdevCXOffset
        mov     ebx,ds:[esi].HWLOGDEVCX.pDirectXSharedData

        ; We need to get the correct head number for this DX share
        ; structure. We can peek at our HWCRTCCXs. If we have more
        ; than 1 HWCRTCCX attached, then we must be in clone mode in
        ; which case, we can set head 0. If we only have 1 HWCRTCCX
        ; attached, then use the PhysicalCRTCInstance from it.
        lea     eax,ds:[esi].HWLOGDEVCX.pHWCrtcCX
        mov     dwCountCRTCs,MAX_ATTACHED_CRTCS
        mov     dwNumCRTCs,0

        ; Keep head number for the video mirror device.
        mov     ecx,ds:[ebx].DISPDRVDIRECTXCOMMON.dwHeadNumber
BackIt:
        mov     edx,ds:[eax]
        or      edx,edx
        je      @F
        mov     ecx,ds:[edx].HWCRTCCX.dwPhysicalCRTCInstance
        inc     dwNumCRTCs
@@:     add     eax,4
        dec     dwCountCRTCs
        jne     BackIt

        ; More than 1 CRTC implies Clone mode which means Physical
        ; Instance 0.
        cmp     dwNumCRTCs,1
        jbe     @F
        sub     ecx,ecx
@@:     mov     ds:[ebx].DISPDRVDIRECTXCOMMON.dwHeadNumber,ecx

        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     NV_PostModeset
;
; Purpose:      This routine gets called right after a modeset from the
;               HW_LogdevMessage routine.
;
; Arguments:
;               pHWLogdevCXOffset
;               pDibeng
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_PostModeset, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD   pDibeng
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWLogdevCXOffset
        mov     edi,pDibeng

        ; Let the RM know the desktop mode.
        mov     ebx,ds:[esi].HWLOGDEVCX.pHWBoardCX
        pushd   NV_CFG_SCREEN_WIDTH
        movzx   eax,ds:[edi].DIBENGINEHDR.deWidth
        push    eax
        push    ds:[ebx].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigSet,es,ax

        mov     ebx,ds:[esi].HWLOGDEVCX.pHWBoardCX
        pushd   NV_CFG_SCREEN_HEIGHT
        movzx   eax,ds:[edi].DIBENGINEHDR.deHeight
        push    eax
        push    ds:[ebx].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigSet,es,ax

        mov     ebx,ds:[esi].HWLOGDEVCX.pHWBoardCX
        pushd   NV_CFG_PIXEL_DEPTH
        movzx   eax,ds:[edi].DIBENGINEHDR.deBitsPixel
        push    eax
        push    ds:[ebx].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigSet,es,ax

        ; Fill in a few fields for the shared data structure
        ; that are changeable or that we coiuldn't know at
        ; HW_CreateLogdevConetext time.
        movzx   ecx,ds:[edi].DIBENGINEHDR.deBitsSelector
        push    ecx
        call    GN_GetSelectorBase
        mov     ebx,ds:[esi].HWLOGDEVCX.pDirectXSharedData
        mov     ds:[ebx].DISPDRVDIRECTXCOMMON.dwScreenLinearBase,eax
        mov     ds:[ebx].DISPDRVDIRECTXCOMMON.pFlatDibeng,edi

        ; Let the DD driver object know about the modeset
        cmp     ds:[esi].HWLOGDEVCX.dwDirectXActive,0
        je      @F
        push    pHWLogdevCXOffset
        pushd   1
        CALLFAR16 NV_CreateDrvObj
@@:
        ; Start this off at -1 after a mode switch. It is used for
        ; temporary storage of the last value written into the
        ; ContextPattern.SetMonochromeColor0 method. -1 is an OK
        ; value to have because it means the alpha is fully on.
        mov     ds:[esi].HWLOGDEVCX.dwPatternAlpha0,-1
        mov     ds:[esi].HWLOGDEVCX.dwPatternAlpha1,-1

        ; Figure out all the color depth specific object values
        mov     ax,SEG wNVTEXT32_Alias_In_NVTEXT16
        mov     es,ax
        mov     es,es:[wNVTEXT32_Alias_In_NVTEXT16]
        mov     al,ds:[edi].DIBENGINEHDR.bRealBpp
        cmp     al,20H
        je      Is32
        cmp     al,0FH
        je      Is15
        ja      Is16

Is8:
        mov     es:[dwContextSurface2DColorFormat],NV042_SET_COLOR_FORMAT_LE_Y8
        mov     ds:[esi].HWLOGDEVCX.dwRectAndTextColorFormat,NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwIndexedImageColorFormat,NV060_SET_COLOR_FORMAT_LE_X8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwImageFromCpuColorFormat,NV061_SET_COLOR_FORMAT_LE_X8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwSolidLinColorFormat,NV05C_SET_COLOR_FORMAT_LE_X8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwColorAlphaMask,0FF00H
        mov     ds:[esi].HWLOGDEVCX.dwPatternColorFormat,NV044_SET_COLOR_FORMAT_LE_A8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwColorPatternAndHeaderSize,40H + 20H
        mov     ds:[esi].HWLOGDEVCX.dwColorPatternMethodOffset,CHNRUN(ContextPattern.SetPatternY8,10H)
        jmp     DoneCD

Is15:
        mov     es:[dwContextSurface2DColorFormat],NV042_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5
        mov     ds:[esi].HWLOGDEVCX.dwRectAndTextColorFormat,NV04A_SET_COLOR_FORMAT_LE_X17R5G5B5
        mov     ds:[esi].HWLOGDEVCX.dwIndexedImageColorFormat,NV060_SET_COLOR_FORMAT_LE_X1R5G5B5
        mov     ds:[esi].HWLOGDEVCX.dwImageFromCpuColorFormat,NV061_SET_COLOR_FORMAT_LE_X1R5G5B5
        mov     ds:[esi].HWLOGDEVCX.dwSolidLinColorFormat,NV05C_SET_COLOR_FORMAT_LE_X17R5G5B5
        mov     ds:[esi].HWLOGDEVCX.dwColorAlphaMask,8000H
        mov     ds:[esi].HWLOGDEVCX.dwPatternColorFormat,NV044_SET_COLOR_FORMAT_LE_X16A1R5G5B5
        mov     ds:[esi].HWLOGDEVCX.dwColorPatternAndHeaderSize,80H + 20H
        mov     ds:[esi].HWLOGDEVCX.dwColorPatternMethodOffset,CHNRUN(ContextPattern.SetPatternX1R5G5B5,20H)
        jmp     DoneCD

Is16:
        mov     es:[dwContextSurface2DColorFormat],NV042_SET_COLOR_FORMAT_LE_R5G6B5
        mov     ds:[esi].HWLOGDEVCX.dwRectAndTextColorFormat,NV04A_SET_COLOR_FORMAT_LE_X16R5G6B5
        mov     ds:[esi].HWLOGDEVCX.dwIndexedImageColorFormat,NV060_SET_COLOR_FORMAT_LE_R5G6B5
        mov     ds:[esi].HWLOGDEVCX.dwImageFromCpuColorFormat,NV061_SET_COLOR_FORMAT_LE_R5G6B5
        mov     ds:[esi].HWLOGDEVCX.dwSolidLinColorFormat,NV05C_SET_COLOR_FORMAT_LE_X16R5G6B5
        mov     ds:[esi].HWLOGDEVCX.dwColorAlphaMask,0FFFF0000H
        mov     ds:[esi].HWLOGDEVCX.dwPatternColorFormat,NV044_SET_COLOR_FORMAT_LE_A16R5G6B5
        mov     ds:[esi].HWLOGDEVCX.dwColorPatternAndHeaderSize,80H + 20H
        mov     ds:[esi].HWLOGDEVCX.dwColorPatternMethodOffset,CHNRUN(ContextPattern.SetPatternR5G6B5,20H)
        jmp     DoneCD

Is32:
        mov     es:[dwContextSurface2DColorFormat],NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwRectAndTextColorFormat,NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwIndexedImageColorFormat,NV060_SET_COLOR_FORMAT_LE_X8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwImageFromCpuColorFormat,NV061_SET_COLOR_FORMAT_LE_X8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwSolidLinColorFormat,NV05C_SET_COLOR_FORMAT_LE_X8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwColorAlphaMask,0FF000000H
        mov     ds:[esi].HWLOGDEVCX.dwPatternColorFormat,NV044_SET_COLOR_FORMAT_LE_A8R8G8B8
        mov     ds:[esi].HWLOGDEVCX.dwColorPatternAndHeaderSize,100H + 20H
        mov     ds:[esi].HWLOGDEVCX.dwColorPatternMethodOffset,CHNRUN(ContextPattern.SetPatternX8R8G8B8,40H)
        jmp     DoneCD

DoneCD:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_AllocLogicalSurface
;
; Purpose:      This routine gets called to free the logical display
;               surface.
;
; Arguments:
;               ds                              Context Selector
;               pHWLogdevCXOffset               HWLOGDEVCX ptr
;               lpDibeng                        Describes logical surface
; Returns:
;               eax     offset into video memory of start of offscreen block
;                       (-1 if failure)
;               ebx     length in bytes of offscreen block
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_AllocLogicalSurface, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD   lpDibeng
OPENPROC
        mov     ebx,pHWLogdevCXOffset
        or      ebx,ebx
        je      DoneIt

        mov     ecx,lpDibeng
        push    ds:[ebx].HWLOGDEVCX.pHWBoardCX
        push    ds:[ecx].DIBENGINE.deDeltaScan
        movzx   eax,ds:[ecx].DIBENGINE.deHeight
        push    eax
        push    ds:[ebx].HWLOGDEVCX.pHWCrtcCX
        call    HW_GetPhysicalCrtcIndex
        push    eax
        call    HW_AllocPrimarySurface
        cmp     eax,-1
        je	DoneIt
	push	ebx
        mov     ebx,pHWLogdevCXOffset
        mov     ds:[ebx].HWLOGDEVCX.dwLogicalSurfaceOffset,eax
	pop	ebx
DoneIt:
CLOSEPROC


;==============================================================================
;
; Function:     HW_FreeLogicalSurface
;
; Purpose:      This routine gets called to free the logical display
;               surface.
;
; Arguments:
;               pHWLogdevCXOffset
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_FreeLogicalSurface, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
OPENPROC
        mov     ebx,pHWLogdevCXOffset
        or      ebx,ebx
        je      @F
        push    ds:[ebx].HWLOGDEVCX.pHWBoardCX
        push    ds:[ebx].HWLOGDEVCX.dwLogicalSurfaceOffset
        call    HW_FreePrimarySurface
@@:
CLOSEPROC


;==============================================================================
;
; Function:     NV_CreateDrvObj
;
; Purpose:      This is the hardware specific CreateDriverObject
;               routine. You must fill in the "16bit portion" of the
;               HALInfo structure. It is not well documented what
;               fields exactly must be filled in here vs. which you
;               can put off and fill in when you get to the DirectX
;               driver. You will just have to look at the sample
;               Microsoft code to figure it out.
;
;               After the 16bit portion if filled out, you must call
;               the lpSetInfo routine with the apprpriate parameters
;               like this:
;               (*lpSetInfo) ((DDHALINFO FAR *)lpDDHalInfo, (WORD)dwReason);
;
;               The generic code also calls this routine whenever the
;               DDCREATEDRIVEROBJECT escape is received. This means that
;               the DirectX driver is coming up for use.
;
;               This routine is also called by the hardware specific
;               code itself when a modeset has occurred.
;
;               In both cases, before getting here, the generic code
;               has flushed all offscreen bitmaps. When NV_CreateDrvObj
;               returns, the generic code will re-init the offscreen
;               memory manager based upon the variables returned.
;
;               This gives the hardware specific code the chance to change
;               the amount of offscreen memory used for offscreen bitmaps
;               when DirectX starts up. By setting dwOffscreenLength
;               to 0, the HW specific code can eliminate offscreen
;               bitmap allocation while DirectX is active.
;
; Arguments:
;               ds                      CXSel
;               pHWLogdevCXOffset       HWLOGDEVCX
;               dwReason        non-0   then the call to this routine is
;                                       because the mode has changed and
;                                       the DrvObj needs to be updated to
;                                       reflect the new mode.
;                               0       then the call to this routine is
;                                       because the DDCREATEDRIVEROBJECT
;                                       escape was received by the generic
;                                       code.
;
; Returns:      eax     0       then driver object not created. This
;                               probably means that we have not connected
;                               with the 32bit DirectX driver yet.
;                       hModule the HINSTANCE handle of the DirectX driver
;                               which was passed into its DllMain procedure.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_CreateDrvObj, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD   dwReason
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWLogdevCXOffset
        mov     edi,ds:[esi].HWLOGDEVCX.pDirectXSharedData

        ; If we don't have any DirectX context data, then we probably
        ; didn't connect with the DirectX driver, or we did, but there
        ; was an init failure.
        cmp     ds:[edi].DISPDRVDIRECTXCOMMON.pDirectXData,0
        je      Done

        ; If we don't have the ptr to the pfnInterfaceFunc routine which
        ; is now located in the DirectX driver, then we can't call it.
        cmp     ds:[edi].DISPDRVDIRECTXCOMMON.pfnInterfaceFunc,0
        je      Done

        ; I don't know if this will ever happen, but I was worried
        ; because of some new code paths that have been added to both
        ; display and DX driver, so it won't hurt to check this here.
        cmp     ds:[esi].HWLOGDEVCX.sDDHalDDrawFns.lpSetInfo,0
        je      Done

        ; If we get here, then the DirectX driver must be loaded and
        ; DriverInit must have been called, because that is where the
        ; pDirectXData and pfnInterfaceFunc fields get filled in.

        ; Now do a Direct call into the DirectX driver so it can init
        ; the "16bit portion" of the DDHALINFO structure.
        mov     ebx,ds:[esi].HWLOGDEVCX.pDirectXSharedData
        push    esi
        push    ds:[edi].DISPDRVDIRECTXCOMMON.dwFlatCodeSel
        push    ds:[edi].DISPDRVDIRECTXCOMMON.pfnInterfaceFunc
        pushd   GDIDX_PRE_SETINFOINIT
        pushd   0
        call    DirectCallToFlatland

        ; One last conversion -- the ddraw16.dll SetInfo routine needs
        ; a 16:16 ptr to the DDHALInfo structure and ours is currently
        ; a flat32 pointer.
        mov     ebx,ds:[esi].HWLOGDEVCX.pDirectXSharedData
        mov     eax,1
        mov     ebx,ds:[edi].DISPDRVDIRECTXCOMMON.pHalInfo
        mov     ecx,ds:[edi].DISPDRVDIRECTXCOMMON.dwHALInfoSize
        call    GN_AllocSelectorAndMapIt

        ; Save the selector so we can restore it later.
        push    eax

        ; Now call the ddraw16.dll SetInfo routine
        shl     eax,10H
        push    eax
        push    word ptr dwReason
        call    FFP16 PTR ds:[esi].HWLOGDEVCX.sDDHalDDrawFns.lpSetInfo

        ; Free the selector used to map the DDHALInfo structure
        pop     eax
        call    GN_UnmapAndFreeSelector

SkipIt:
        ; Return the hInstance for the DirectX driver
        mov     eax,ds:[edi].DISPDRVDIRECTXCOMMON.hDirectXInstance

Done:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     DirectCallToFlatland
;
; Purpose:      This procedure calls the far routine passed in. The
;               far routine must be in code that wants a USE32 stack
;               and assumes a flat space (ds = es = ss).
;               We map the current stack offset to a 32bit stack and
;               set ds, es, and ss to the flat data selector.
;
; Arguments:
;               ds                      CXSel
;               pHWLogdevCXOffset       HWLOGDEVCX
;               dwFarCallCS             cs:eip of call dst
;               dwFarCallOffset
;               dwInterfaceID           GDIDX_XXXX in dxshare.h
;               dwExtraData             parameter to pass up
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DirectCallToFlatland, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD   dwFarCallCS
PARMD   dwFarCallOffset
PARMD   dwInterfaceID
PARMD   dwExtraData
LOCALD  pfnSharedData
LOCALD  dwFlatDataSelector
OPENPROC
        PUSHR   ds,esi,edi
        mov     esi,pHWLogdevCXOffset

        mov     edi,ds:[esi].HWLOGDEVCX.pDirectXSharedData
        mov     pfnSharedData,edi
        mov     ecx,ds:[edi].DISPDRVDIRECTXCOMMON.dwFlatDataSel
        mov     dwFlatDataSelector,ecx

        ; If we don't have any DirectX context data, then we probably
        ; didn't connect with the DirectX driver, or we did, but there
        ; was an init failure.
        cmp     ds:[edi].DISPDRVDIRECTXCOMMON.pDirectXData,0
        je      Done

        ; If we don't have the ptr to the pfnInterfaceFunc routine which
        ; is now located in the DirectX driver, then we can't call it.
        cmp     ds:[edi].DISPDRVDIRECTXCOMMON.pfnInterfaceFunc,0
        je      Done

        ; Push the return address on the stack (this is a FAR32)
        sub     eax,eax
        mov     ax,SEG ComeBack
        push    eax
        mov     eax,OFFSET ComeBack
        push    eax

        ; Push the call address on the stack
        push    dwFarCallCS
        push    dwFarCallOffset

        ; Get the linear base address of the current ss and add to sp
        mov     ax,ss
        push    eax
        call    GN_GetSelectorBase
        movzx   edx,sp
        add     edx,eax

        ; Save the old ss and sp in registers that won't get trashed
        ; It's a bit tricky because, the "saved sp" should actually
        ; be the value of sp before pushing the return and calling
        ; addresses above. Why? Because when the addresses are popped
        ; off (via return calls), these returns are made with the
        ; other stack pointer!
        mov     di,ss
        mov     si,sp
        add     si,10H

        ; Load up the flat data segments
        mov     eax,dwFlatDataSelector
        mov     ds,ax
        mov     es,ax

        ; We need to pass these in
        mov     eax,pfnSharedData
        mov     ebx,dwInterfaceID
        mov     ecx,dwExtraData

        ; Load up the new ss and sp. The processor inhibits interrupts
        ; for an additional instruction after loading ss to give you a
        ; chance to load sp as well and prevent non-coherency.
        push    ds
        pop     ss
        mov     esp,edx
        RETFAR32     ; this far return will "call" the pfnInterfaceFunc func

ComeBack:
        ; We still are on the 32bit flat stack. Change back to our stack
        mov     ss,di
        mov     sp,si
Done:

        ; Restore the registers
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetDirectXRuntimeVersion
;
; Purpose:      This routine returns the DD runtime version.
;
; Arguments:
;               pHWLogdevCXOffset       HWLOGDEVCX
;               dwOSDirectXVersion      OS version of direct X
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetDirectXRuntimeVersion, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD   dwOSDirectXVersion
OPENPROC
        ; If we get asked what version DirectX the driver was built for,
        ; then we will also inform the DirectX driver what version of DX
        ; the OS is running.
        mov     edx,pHWLogdevCXOffset
        les     bx,ds:[edx].HWLOGDEVCX.lpDirectXSharedData
        movzx   ebx,bx
        push    edx
        push    es:[ebx].DISPDRVDIRECTXCOMMON.dwFlatCodeSel
        push    es:[ebx].DISPDRVDIRECTXCOMMON.pfnInterfaceFunc
        pushd   GDIDX_DIRECTX_OS_VERSION
        push    dwOSDirectXVersion
        call    DirectCallToFlatland

        mov     eax,DD_RUNTIME_VERSION
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetDirectXDllNameAndEntryPoint
;
; Purpose:      This routine returns the names of the DirectX DLL
;               and the entry point name.
;
; Arguments:
;               ds                      Context selector
;               pHWLogdevCXOffset       offset to HWLOGDEVCX
;               dwDllNameSel            Selector of where to put dll name
;               dwDllNameOffset         Offset of where to put dll name
;               dwEntryPointNameSel     Selector of where to put entry
;                                       point name
;               dwEntryPointNameOffset  Offset of where to put entry
;                                       point name
;
; Returns:      eax     Ptr to DirectX Context Data (must be 16:16 ptr)
;
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetDirectXDllNameAndEntryPoint, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD   dwDllNameSel
PARMD   dwDllNameOffset
PARMD   dwEntryPointNameSel
PARMD   dwEntryPointNameOffset
OPENPROC
        PUSHR   ds,esi,edi

        ; Copy the DLL Name
        mov     es,dwDllNameSel
        mov     edi,dwDllNameOffset
        mov     ax,SEG szDDrawBinaryName
        mov     fs,ax
        lea     esi,szDDrawBinaryName
@@:
        mov     ax,fs:[esi]
        inc     esi
        mov     es:[edi],al
        inc     edi
        or      al,al
        jne     @B

        ; Copy the DLL Entry Point Name
        mov     es,dwEntryPointNameSel
        mov     edi,dwEntryPointNameOffset
        mov     ax,SEG szDDrawEntryPointName
        mov     fs,ax
        lea     esi,szDDrawEntryPointName
@@:
        mov     ax,fs:[esi]
        inc     esi
        mov     es:[edi],al
        inc     edi
        or      al,al
        jne     @B

        ; Return a 16:16 ptr to the DirectX shared data
        mov     esi,pHWLogdevCXOffset
        mov     eax,ds:[esi].HWLOGDEVCX.pDirectXSharedData

        POPR    ds,esi,edi
CLOSEPROC



;==============================================================================
;
; Function:     HW_SetNewDirxCallbacks
;
; Purpose:      This routine tells the ardware what the addresses
;               of the DirectX callback functions are.
;
; Arguments:
;               ds                      Context selector
;               pHWLogdevCXOffset       offset to HWLOGDEVCX
;               lpDDHalDDrawFuncs       16:16 ptr to DDraw callbacks
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_SetNewDirxCallbacks, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD   lpDDHalDDrawFuncs
OPENPROC
        PUSHR   ds,esi,edi
        PUSHR   ds
        POPR    es
        mov     edi,pHWLogdevCXOffset
        lea     edi,[edi].HWLOGDEVCX.sDDHalDDrawFns

        sub     esi,esi
        lds     si,lpDDHalDDrawFuncs

        pushf
        cld
        mov     ecx,(SIZE MYDDHALDDRAWFNS) / 4
        rep     movs dword ptr es:[edi], ds:[esi]
        popf

        POPR    ds,esi,edi
CLOSEPROC



;==============================================================================
;
; Function:     HW_GetDirectXInstance
;
; Purpose:      This routine returns the instance handle of the
;               DirectX dll.
;
; Arguments:
;               ds                      Context selector
;               pHWLogdevCXOffset       offset to HWLOGDEVCX
;
; Returns:
;               eax             DirectX Driver instance handle.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetDirectXInstance, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
OPENPROC
        PUSHR   esi
        mov     esi,pHWLogdevCXOffset
        mov     eax,ds:[esi].HWLOGDEVCX.pDirectXSharedData
        mov     eax,ds:[eax].DISPDRVDIRECTXCOMMON.hDirectXInstance
        POPR    esi
CLOSEPROC



;==============================================================================
;
; Function:     HW_GetOpenGLRegistryName
;
; Purpose:      This routine returns the names of the OpenGL
;               Registry subkey that should be used by the system.
;
; Arguments:
;               ds                      Context selector
;               pHWLogdevCXOffset       offset to HWLOGDEVCX
;               dwDllNameSel            Selector of where to put dll name
;               dwDllNameOffset         Offset of where to put dll name
;
; Returns:      eax                     The OGL ICD version
;               ebx                     The OGL driver version
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetOpenGLRegistryName, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD   dwDllNameSel
PARMD   dwDllNameOffset
OPENPROC
        PUSHR   ds,esi,edi

        ; Copy the DLL Name
        mov     es,dwDllNameSel
        mov     edi,dwDllNameOffset
        mov     ax,SEG szOGLRegKeyName
        mov     fs,ax
        lea     esi,szOGLRegKeyName
@@:
        mov     ax,fs:[esi]
        inc     esi
        mov     es:[edi],al
        inc     edi
        or      al,al
        jne     @B

        mov     eax,OPENGL_ICD_VER
        mov     ebx,OPENGL_DRIVER_VER
        POPR    ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_DirectXService
;
; Purpose:      This routine can be called from the DirectX driver
;               when it is executing within the context of a
;               DirectCallToFlatland. There are various services
;               that are supported.
;
;               This routine is a bit of a pain. The caller is
;               running on a flat 32bit stack. Any system functions
;               we call can only handle 16bit stacks, so we have
;               to switch the stack over before doing anything.
;
; Arguments:    None
;
; Returns:
;
; Preserve:     Everything
;==============================================================================
DECPROC NV_DirectXServiceNoFrame, PASCAL, NOFRAME, FAR32
;PARMD  pHWLogdevCX
;PARMD  dwFunction
;PARMD  pIn
;PARMD  pOut
OPENPROC
        ; Save some registers -- 30H bytes worth
        ; on the 32bit stack.
        PUSHR   alld,ds,es,fs,gs

        ; Load up the parameters
        lea     edi,[esp + 20H + 4 * @WordSize + 08H]
        mov     ebp,ss:[edi + 0CH]                      ; pHWLogdevCX
        mov     eax,ss:[edi + 08H]                      ; dwFunction
        mov     ebx,ss:[edi + 04H]                      ; pIn
        mov     ecx,ss:[edi + 00H]                      ; pOut
        mov     edi,esp
        sub     esi,esi
        mov     si,ss

        ; Load up a temporary stack we have in our data segment
        mov     dx,_DATA
        mov     ss,dx
        mov     sp,OFFSET TempStackTop

        ; Save the 32bit stack registers
        mov     ss:[dwOldSS],esi
        mov     ss:[dwOldEsp],edi

        ; Now push the arguments on the new stack
        push    ebp
        push    eax
        push    ebx
        push    ecx
        call    NV_DirectXService

        ; restore the 32bit stack
        mov     eax,ss:[dwOldSS]
        mov     ecx,ss:[dwOldEsp]
        mov     ss,ax
        mov     esp,ecx

        ; pop all the registers
        POPR    alld,ds,es,fs,gs

        RETFAR32 10H
CLOSEPROC

DECPROC NV_DirectXService, PASCAL, FRAME, NEAR
PARMD   pHWLogdevCX
PARMD   dwFunction
PARMD   pIn
PARMD   pOut
LOCALD  dwFlatSelector
OPENPROC
        ; pIn and pOut are both flat ptrs. We need the flat selector
        ; loaded in order to access them.
        sub     esi,esi
        mov     ds,wFlatDataSel_In_NVTEXT16
        mov     edi,pHWLogdevCX
        mov     edi,ds:[edi].HWLOGDEVCX.pDirectXSharedData
        mov     eax,ds:[edi].DISPDRVDIRECTXCOMMON.dwFlatDataSel
        mov     dwFlatSelector,eax

        mov     eax,dwFunction
        cmp     eax,NV_DRVSERVICE_ALLOC_MEMORY
        je      AllocMem
        cmp     eax,NV_DRVSERVICE_FREE_MEMORY
        je      FreeMem
        cmp     eax,NV_DRVSERVICE_BEGINACCESS
        je      DoBegAcc
        cmp     eax,NV_DRVSERVICE_ENDACCESS
        je      DoEndAcc
        sub     eax,eax
        jmp     Done

AllocMem:
        mov     es,dwFlatSelector
        mov     edx,pIn
        mov     eax,es:[edx].DRVSERVICE_ALLOC_MEMORY.dwNumBytes
        mov     ebx,es:[edx].DRVSERVICE_ALLOC_MEMORY.dwAllocFlags
        mov     ecx,es:[edx].DRVSERVICE_ALLOC_MEMORY.dwObjectID
        mov     esi,pHWLogdevCX
        mov     esi,ds:[esi].HWLOGDEVCX.pHWBoardCX
        call    NV_AllocMemory
        mov     es,dwFlatSelector
        mov     edx,pOut
        mov     es:[edx],eax
        jmp     Done

FreeMem:
        mov     esi,pHWLogdevCX
        mov     esi,ds:[esi].HWLOGDEVCX.pHWBoardCX
        mov     es,dwFlatSelector
        mov     edx,pIn
        mov     ecx,es:[edx].DRVSERVICE_FREE_MEMORY.dwObjectID
        call    NV_FreeMemory
        mov     es,dwFlatSelector
        mov     edx,pOut
        mov     es:[edx],eax
        jmp     Done

DoBegAcc:
        sub     eax,eax
        les     bx,pIn
        mov     di,es:[bx].DIBENGINE.deFlags
        and     di,BUSY
        and     es:[bx].DIBENGINE.deFlags,NOT BUSY
        push    pIn
        push    eax
        push    eax
        pushw   FB_ACCESS OR CURSOREXCLUDE
        call    FFP16 PTR es:[bx].DIBENGINE.deBeginAccess
        les     bx,pIn
        or      es:[bx].DIBENGINE.deFlags,di
        jmp     Done

DoEndAcc:
        les     bx,pIn
        mov     di,es:[bx].DIBENGINE.deFlags
        and     di,BUSY
        and     es:[bx].DIBENGINE.deFlags,NOT BUSY
        push    pIn
        pushw   FB_ACCESS OR CURSOREXCLUDE
        call    FFP16 PTR es:[bx].DIBENGINE.deEndAccess
        les     bx,pIn
        or      es:[bx].DIBENGINE.deFlags,di
        jmp     Done

Done:
CLOSEPROC


;==============================================================================
;
; Function:     HW_TellResManSpanningState
;
; Purpose:      This routine informs the Resource Manager that we are
;               in spanning mode.
;
; Arguments:
;               ds                      Context selector
;               pHWLogdevCXOffset       offset to HWLOGDEVCX
;
; Returns:      
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_TellResManSpanningState, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD   dwSpanningState
OPENPROC
        PUSHR   ds,esi,edi
        
        mov     esi,pHWLogdevCXOffset
        mov     edi,ds:[esi].HWLOGDEVCX.pHWBoardCX

        pushd   NV_CFG_DISPLAY_CHANGE_CONFIG    
        push    dwSpanningState
        push    ds:[edi].HWBOARDCX.dwDeviceNum
        CALLFAR16IND lpfnNvConfigSet,es,ax

        POPR    ds,esi,edi
CLOSEPROC


CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWMONBLT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwmonblt.asm
;
; Purpose:      This file trasnfers mono system memory bitmaps or DIBS
;               to a dst video memory bitmap. The dst bitmap may be 8,
;               15, 16, or 32bpp. There may be a rop and pattern as well.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     HW_BeginSrcMonoDstVram
;
; Purpose:      This function is an easy way to implement mono
;               bitmap transfers. This routine gets called to do setup,
;               and then the HW_BlockSrcMonoDstVram gets called before
;               each chunk of lines is transferred, and finally the
;               function HW_EndSrcMonoDstVram is called when the main
;               routine is done. You need to do the following:
;
;               2) Set the Rop (which is the byte at dwRop3+2)
;
;               3) Set the hardware clipping rectangle to the coords
;                  (dwDstLeft, dwDstTop, dwDstLeft+dwExtX, dwDstTop+dwExtY)
;
;               4) Set the starting destination coordinates to be:
;                  dwAlignedDstLeft, dwDstTop
;
;               5) Set the extents of the transfer. The number of pixels
;                  sent in per line will always be a multiple of 32 and
;                  is given by the parameter dwAlignedSrcExtXInPixels.
;                  Of course, the number of pixels to be written to the
;                  dst rectangle is given by the paramter dwExtX. The
;                  number of scanlines sent in is the same as the number
;                  to be displayed and is given by dwExtY.
;
;               6) Program in the colors to which to expand the bits
;                  in the mono src. These colors should NOT be used
;                  to expand mono bits in a mono pattern if a pattern
;                  is involved. The DRAWMODE TextColor and bkColor
;                  are to be used for that. The generic code would
;                  already have called HW_LoadXXXPattrn to load the
;                  pattrn properly if one were involved.
;
;               7) Program the base and pitch of the dst bitmap which are:
;                  dwDstBitsOffset, dwDstPitch
;
;               8) Anything else you need to do to prepare the
;                  hardware for a transfer of the src bitmap.
;
;               9) You must return three important values to the generic
;                  code. One is a pseudo wrap width.  The second is the
;                  maximum number of bytes you can handle in a single
;                  transfer (without waiting or writing new header info,
;                  or whatever the hardware requires.) The third is
;                  your hardware ptr (either MMIO or DMA buffer.)
;
;                  Here is how it works:
;
;                  When you return from this routine, you should have
;                  es:edi pointing to either the next location in the
;                  DMA buffer if you are DMA based, or pointing to the
;                  MMIO area if you are fifo based.
;
;                  The generic code will call HW_BlockSrcMonoDstVram
;                  and have it wait for enough fifo slots or DMA buffer
;                  space. HW_BlockSrcMonoDstVram will return a ptr to
;                  the generic code telling it where to begin writing
;                  pixels. The generic code starts xlatting and copying
;                  pixels incrementing this ptr as it goes. When the
;                  generic code reaches the end of a scanline, it will
;                  add in the pseudo wrap width you returned to the current
;                  value of the ptr and begin transferring pixels on
;                  the next scanline at this new address. If the
;                  generic code reaches the maximum number of pixels
;                  that can be handled in a single transfer (which was
;                  the second parameter you returned) before transferring
;                  the whole bitmap, it will call the block routine
;                  HW_BlockSrcMonoDstVram again to both wait for more
;                  space and get a new dst ptr.
;
;                  So what exactly should these return values be?
;
;                  For a fifo based part like NV3/ZX, the pseudo wrap width
;                  should be -dwAlignedSrcExtXInBytes -- this is the
;                  negative of one of the locals on the predefined frame.
;                  The maximum single transfer size should be 128 bytes
;                  (or whatever the size of the fifo is in bytes.)
;
;                  For a DMA based part like NV4, the pseudo wrap width
;                  should be 0. This will mean that the data for
;                  the next scanline will fall 0 bytes after the end
;                  of the data for the previous scanline -- exactly
;                  what is needed for DMA buffer sceanrios. The
;                  maximum single transfer size in bytes for DMAs is
;                  the size of the method to which the mono pixels
;                  will be written. (Or the size of the DMA buffer if
;                  it is smaller, but for other driver policy reasons,
;                  the DMA buffer must be more than twice the size of
;                  the largest method so go with the method size.)
;
; Arguments:
;               ds                      CXSel
;               pHWLogdevCXOffset       HWLOGDEVCX ptr
;               dwDstBitsOffset         base address of dst bitmap in VRAM
;               dwDstPitch              pitch of dst bitmap in VRAM
;               dwDstBpp                bpp of dst bitmap (be 8,15,16,or 32)
;               dwDstLeft               left edge coord of dst clip rectangle
;               dwDstTop                top edge coord of dst rectangle
;               dwAlignedDstLeft        left edge of unclipped dst rectangle
;               dwExtX                  width of dst rectangle in pixels
;               dwExtY                  height of dst rectangle in scanlines
;               dwAlignedSrcExtXInBytes number of bytes transferred per
;                                       line - will always be a multiple of 4
;               dwAlignedSrcExtXInPixels number of pixels sent per src line
;                                       -- will always be a multiple of 32 so
;                                       the lines have a multiple of 4 bytes
;               dwPixelsIgnoredOnLeft   number of pixels (bits) of the
;                                       src to be ignored. i.e. ignore this
;                                       many pixels, then then next dwExtX
;                                       pixels should be expanded and placed
;                                       in the dst beginning at the dwDstLeft
;                                       coord. There will be some pixels on
;                                       the right to be ignored also. The
;                                       number of these is:
;                                       dwAlignedSrcExtXInPixels - dwExtX -
;                                       dwPixelsIgnoredOnLeft.
;               dwBgColor               expand 0 bits in src to this color
;               dwFgColor               expand 1 bits in src to this color
;               lpBrush                 ptr to DIB_Brush
;               lpDrawMode              ptr to DRAWMODE
;               dwRop3                  rop 3 in Microsoft rop format
;               dwRopFlags              one of NOROP, OND, PAD, SAD, PSD
;                                       See file gngdi.inc for definitions
;                                       and description above for purpose.
;
; Returns:
;       eax     0       need to punt
;               else    Keep going -- everything's fine
;                       In this case, you must also return
;                       ebx  - The pseudo wrap width
;                       ecx  - The max single transfer size in bytes
;                       edi  - push buffer offset
;                       es   - whatever you want (probably CXSel)
;                       See the discussion under purpose for more
;                       info about these return values.
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_BeginSrcMonoDstVram, PASCAL, FRAME, NEAR
PARMD   pHWLogdevCXOffset
PARMD   dwDstBitsOffset
PARMD   dwDstPitch
PARMD   dwDstBpp
PARMD   dwDstLeft
PARMD   dwDstTop
PARMD   dwAlignedDstLeft
PARMD   dwExtX
PARMD   dwExtY
PARMD   dwAlignedSrcExtXInBytes
PARMD   dwAlignedSrcExtXInPixels
PARMD   dwPixelsIgnoredOnLeft
PARMD   dwBgColor
PARMD   dwFgColor
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   dwRop3
OPENPROC
        PUSHR   esi

        mov     edx,pHWLogdevCXOffset
        mov     esi,ds:[edx].HWLOGDEVCX.pHWBoardCX

        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,esi,eax

        ; Load the push buffer ptr
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,dwDstBitsOffset
        CHECKDSTBASE ds,esi,edi,eax,dwDstPitch

        ; Prepare for a src transfer
        CHECKDMASPACE ds,esi,edi,3CH
        mov	eax,CHNRUN(ContextPattern.SetMonochromeColor0,2)
        mov	ebx,ds:[edx].HWLOGDEVCX.dwPatternAlpha0
        mov	ecx,ds:[edx].HWLOGDEVCX.dwPatternAlpha1
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx
        mov     ds:[edi + 08H],ecx
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        movzx   ebx,byte ptr dwRop3+2
        mov     ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],ebx
        mov     eax,CHNRUN(RectAndText.SetColorFormat,1)
        mov     ebx,ds:[edx].HWLOGDEVCX.dwRectAndTextColorFormat
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ebx
        mov     eax,CHNRUN(RectAndText.ClipPoint0E,7)
        mov     ecx,dwExtY
        mov     ebx,dwDstTop
        shl     ecx,10H
        shl     ebx,10H
        mov     bx,word ptr dwDstLeft
        mov     cx,word ptr dwExtX
        add     ecx,ebx
        mov     ds:[edi + 1CH],eax
        mov     ds:[edi + 20H],ebx
        mov     ds:[edi + 24H],ecx
        mov     eax,dwBgColor
        mov     ebx,dwFgColor
        or      eax,ds:[edx].HWLOGDEVCX.dwColorAlphaMask
        or      ebx,ds:[edx].HWLOGDEVCX.dwColorAlphaMask
        mov     ds:[edi + 28H],eax
        mov     ds:[edi + 2CH],ebx
        mov     eax,dwExtY
        mov     ebx,dwDstTop
        shl     eax,10H
        shl     ebx,10H
        mov     ecx,eax
        mov     bx,word ptr dwAlignedDstLeft
        mov     ax,word ptr dwExtX
        mov     cx,word ptr dwAlignedSrcExtXInPixels
        add     ax,word ptr dwPixelsIgnoredOnLeft
        mov     ds:[edi + 30H],ecx
        mov     ds:[edi + 34H],eax
        mov     ds:[edi + 38H],ebx
        add     edi,3CH
        mov     ds:[esi].HWBOARDCX.pCurrentPushBufferOffset,edi

        ; I need to return a few things
        sub     ebx,ebx         ; pseudo wrap width is 0
        mov     ecx,80H * 4     ; size of mono transfer method
        mov     ax,ds
        mov     es,ax
Done:
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     HW_BlockSrcMonoDstVram
;
; Purpose:      This function is an easy way to implement mono
;               bitmap transfers. It is one of a sequence. For full
;               details, please see HW_BeginSrcMonoDstVram eariler
;               in this file.
;
;               Here, wait for eax bytes of space in the DMA buffer or
;               in the fifo. You may adjust es:edi to whatever you wish.
;               Hence, if you need to wrap the DMA buffer, you may do
;               do and then reset es:edi to the start of the buffer.
;               The generic code never touches es and only adjusts edi
;               by incrementing it appropriately for every dst pixel
;               that is transferred.
;
; Arguments:
;               es      Context Seletor
;               eax     bytes to wait for
;               esi     pHWBoardCX
;               edi     push buffer ptr
;
; Returns:      This routine is not failable. If you wish to fail the
;               sequence, you must fail at HW_BeginSrcMonoDstVram time.
;               es:edi must point to the location for the generic code
;               to copy the next eax bytes of dst pixels translated from
;               src pixels.
;
; Preserve:     ds
;==============================================================================
DECPROC HW_BlockSrcMonoDstVram, PASCAL, NOFRAME, NEAR
OPENPROC
        SETPUTPTR es,esi,edi
        shrd    ecx,eax,10H
        lea     edx,[eax + 4]
        mov     cx,CHNRUN(RectAndText.MonochromeColor01E,0)
        CHECKDMASPACE es,esi,edi,edx
        mov     es:[edi],ecx
        add     edi,4
CLOSEPROC


;==============================================================================
;
; Function:     HW_EndSrcMonoDstVram
;
; Purpose:      This function is an easy way to implement color
;               bitmap transfers. It is one of a sequence. For full
;               details, please see HW_BeginSrcMonoDstVram eariler
;               in this file.
;
;               You may do anything you wish to here. There is nothing
;               specifically required. Some possibiliites are:
;               1) Bump the DMA ptr if you are DMA based
;               2) Reset the hardware clip rect if that was needed.
;
; Arguments:
;               es      Context Selector
;               esi     pHWBoardCX
;               edi     es has not changed since the last call to
;                       HW_BlockSrcMonoDstVram and edi has only
;                       changed by being incremented for each dst
;                       pixel transferred.
;
; Returns:      This routine is not failable. If you wish to fail the
;               sequence, you must fail at HW_BeginSrcMonoDstVram time.
;
; Preserve:     ds
;==============================================================================
DECPROC HW_EndSrcMonoDstVram, PASCAL, NOFRAME, NEAR
OPENPROC
        SETPUTPTR es,esi,edi
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWPATBLT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwpatblt.asm
;
; Purpose:      This file performs BitBlts involving just
;               the dst or the dst and a pattern.
;
;==============================================================================
.586
incDrawMode = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwcrtc.inc
include hwboard.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

PUBLIC  bConvertPatDstToSrcDstRop
bConvertPatDstToSrcDstRop       LABEL   BYTE
DB      000h, 011h, 022h, 033h
DB      000h, 011h, 022h, 033h
DB      000h, 011h, 022h, 033h
DB      000h, 011h, 022h, 033h
DB      044h, 055h, 066h, 077h
DB      044h, 055h, 066h, 077h
DB      044h, 055h, 066h, 077h
DB      044h, 055h, 066h, 077h
DB      088h, 099h, 0AAh, 0BBh
DB      088h, 099h, 0AAh, 0BBh
DB      088h, 099h, 0AAh, 0BBh
DB      088h, 099h, 0AAh, 0BBh
DB      0CCh, 0DDh, 0EEh, 0FFh
DB      0CCh, 0DDh, 0EEh, 0FFh
DB      0CCh, 0DDh, 0EEh, 0FFh
DB      0CCh, 0DDh, 0EEh, 0FFh


;==============================================================================
;
; Function:     HW_BitBltSolidPatDstRop
;
; Purpose:      This function implements Bitblts that involve only
;               a pattern and dst and the pattern is a solid color.
;               At this point, all that needs to be done is to program
;               the chip for the blt.
;
; Arguments:
;               ds              Context Selector
;               ebx             HWLOGDEVCX ptr
;               ecx             dwRop3
;               edx             physical color
;               gs:esi          lpDstDev
;
; Returns:      If you want to
;               report this     then do this
;               Success         jmp to GN_BitBltSuccess
;               Failure         jmp to GN_BitBltFail
;               Punt to DIBENG  jmp to GN_BitBltPunt
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_BitBltSolidPatDstRop, PASCAL, ShareFrameFar16, NEAR
BITBLT_FRAME_AND_LOCALS
OPENPROC
        ; Save the color format for later use.
        push    ds:[ebx].HWLOGDEVCX.dwRectAndTextColorFormat
        push    ds:[ebx].HWLOGDEVCX.dwPatternAlpha1
        push    ds:[ebx].HWLOGDEVCX.dwPatternAlpha0

        mov     ebx,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ebx,eax

        ; Load the push buffer ptr
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,gs:[esi].DIBENGINEHDR.deBitsOffset
        CHECKDSTBASE ds,ebx,edi,eax,<gs:[esi].DIBENGINEHDR.deDeltaScan>

        ; Check for space and program the blt
        CHECKDMASPACE ds,ebx,edi,2CH
        mov     eax,CHNRUN(ContextPattern.SetMonochromeColor0,2)
        mov     ds:[edi + 00H],eax
        pop     dword ptr ds:[edi + 04H]
        pop     dword ptr ds:[edi + 08H]
        shr     ecx,2
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        movzx   ecx,cs:bConvertPatDstToSrcDstRop[ecx]
        mov     ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],ecx
        mov     eax,CHNRUN(RectAndText.SetColorFormat,1)
        mov     ds:[edi + 14H],eax
        pop     dword ptr ds:[edi + 18H]
        mov     eax,CHNRUN(RectAndText.Color1A,3)
        mov     ds:[edi + 1CH],eax
        mov     ds:[edi + 20H],edx
        mov     eax,dword ptr wDstY
        mov     ecx,dword ptr wExtY
        mov     ds:[edi + 24H],eax
        mov     ds:[edi + 28H],ecx
        add     edi,2CH
        SETPUTPTR ds,ebx,edi
        jmp     GN_BitBltSuccess
CLOSEPROC


;==============================================================================
;
; Function:     HW_BitBltMonoPatDstRop
;
; Purpose:      This function implements Bitblts that involve only
;               a pattern and dst and the pattern is a mono pattern.
;               At this point, all that needs to be done is to program
;               the chip for the blt.
;
; Arguments:
;               ds              Context Selector
;               ebx             HWLOGDEVCX ptr
;               gs:esi          lpDstDev
;               es:edi          ptr to pattern to load
;               wDstX,wDstY     dst upper left corner
;               wExtX,wExtY     extent of blt rectangle
;               eax             Color For 0 bits
;               ecx             Color For 1 bits
;
; Returns:      If you want to
;               report this     then do this
;               Success         jmp to GN_BitBltSuccess
;               Failure         jmp to GN_BitBltFail
;               Punt to DIBENG  jmp to GN_BitBltPunt
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_BitBltMonoPatDstRop, PASCAL, ShareFrameFar16, NEAR
BITBLT_FRAME_AND_LOCALS
OPENPROC
        ; Save the color format for later use.
        push    ds:[ebx].HWLOGDEVCX.dwRectAndTextColorFormat
        or      ecx,ds:[ebx].HWLOGDEVCX.dwColorAlphaMask
        or      eax,ds:[ebx].HWLOGDEVCX.dwColorAlphaMask
        mov    	ds:[ebx].HWLOGDEVCX.dwPatternAlpha0,eax
        mov    	ds:[ebx].HWLOGDEVCX.dwPatternAlpha1,ecx
        push    ecx
        push    eax
        push    ds:[ebx].HWLOGDEVCX.dwPatternColorFormat

        mov	edx,edi
        mov     ebx,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ebx,eax

        ; Load the push buffer ptr
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,gs:[esi].DIBENGINEHDR.deBitsOffset
        CHECKDSTBASE ds,ebx,edi,eax,<gs:[esi].DIBENGINEHDR.deDeltaScan>
        mov	esi,edx

        ; Check for space and program the blt
        CHECKDMASPACE ds,ebx,edi,40H
        mov     dword ptr ds:[edi + 00H],CHNRUN(ContextPattern.SetColorFormat,1)
        pop     dword ptr ds:[edi + 04H]
        mov     eax,CHNRUN(ContextPattern.SetPatternSelect,5)
        mov     ecx,NV044_SET_PATTERN_SELECT_MONOCHROME
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ecx
        pop     dword ptr ds:[edi + 10H]
        pop     dword ptr ds:[edi + 14H]
        mov     al,es:[esi + 08H]
        mov     cl,es:[esi + 18H]
        mov     ah,es:[esi + 0CH]
        mov     ch,es:[esi + 1CH]
        ror     eax,10H
        ror     ecx,10H
        mov     al,es:[esi + 00H]
        mov     cl,es:[esi + 10H]
        mov     ah,es:[esi + 04H]
        mov     ch,es:[esi + 14H]
        mov     ds:[edi + 18H],eax
        mov     ds:[edi + 1CH],ecx
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        movzx   ecx,byte ptr dwRop3+2
        mov     ds:[edi + 20H],eax
        mov     ds:[edi + 24H],ecx
        mov     eax,CHNRUN(RectAndText.SetColorFormat,1)
        mov     ds:[edi + 28H],eax
        pop     dword ptr ds:[edi + 2CH]
        mov     eax,CHNRUN(RectAndText.Color1A,3)
        mov     ecx,dword ptr wDstY
        mov     edx,dword ptr wExtY
        mov     ds:[edi + 30H],eax

        ; The Color1A field next is irrelevant but the NV
        ; architecture requires that it at least be written.
        mov     ds:[edi + 34H],eax
        mov     ds:[edi + 38H],ecx
        mov     ds:[edi + 3CH],edx
        add     edi,40H
        SETPUTPTR ds,ebx,edi
        jmp     GN_BitBltSuccess
CLOSEPROC


;==============================================================================
;
; Function:     HW_BitBltColorPatDstRop
;
; Purpose:      This function implements Bitblts that involve only
;               a pattern and dst and the pattern is a color pattern.
;               At this point, all that needs to be done is to program
;               the chip for the blt.
;
; Arguments:    ds:ebx          HWLOGDEV ptr
;               es:edi          lpBrush
;               gs:esi          lpDstDev
;               wDstX,wDstY     dst upper left corner
;               wExtX,wExtY     extent of blt rectangle
;
; Returns:      If you want to
;               report this     then do this
;               Success         jmp to GN_BitBltSuccess
;               Failure         jmp to GN_BitBltFail
;               Punt to DIBENG  jmp to GN_BitBltPunt
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_BitBltColorPatDstRop, PASCAL, ShareFrameFar16, NEAR
BITBLT_FRAME_AND_LOCALS
OPENPROC
        ; Save the Rect and Text color format for later use.
        push    ds:[ebx].HWLOGDEVCX.dwRectAndTextColorFormat

        ; Save these for later use.
        push    ds:[ebx].HWLOGDEVCX.dwPatternAlpha1
        push    ds:[ebx].HWLOGDEVCX.dwPatternAlpha0
        push    ds:[ebx].HWLOGDEVCX.dwPatternColorFormat
        mov     ecx,ds:[ebx].HWLOGDEVCX.dwColorPatternAndHeaderSize
        mov     edx,ds:[ebx].HWLOGDEVCX.dwColorPatternMethodOffset

        mov     ebx,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ebx,eax

        ; Load the push buffer ptr
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,gs:[esi].DIBENGINEHDR.deBitsOffset
        CHECKDSTBASE ds,ebx,edi,eax,<gs:[esi].DIBENGINEHDR.deDeltaScan>

        ; Setup and copy the color pattern into the chip
        CHECKDMASPACE ds,ebx,edi,ecx
        mov	eax,CHNRUN(ContextPattern.SetColorFormat,6)
        mov	esi,NV044_SET_MONOCHROME_FORMAT_CGA6_M1
        mov     ds:[edi + 00H],eax
        pop     dword ptr ds:[edi + 04H]
        mov	ds:[edi + 08H],esi
        mov	eax,NV044_SET_MONOCHROME_SHAPE_8X_8Y
        mov	esi,NV044_SET_PATTERN_SELECT_COLOR
        mov	ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],esi
        pop     dword ptr ds:[edi + 14H]
        pop     dword ptr ds:[edi + 18H]
        movzx   esi,word ptr lpBrush
        mov     ds:[edi + 1CH],edx
        sub     ecx,20H
        lea     esi,[esi].DIB_Brush8.dp8BrushBits
        add     edi,20H

@@:     mov     eax,es:[esi + 00H]
        mov     edx,es:[esi + 04H]
        add     esi,08H
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],edx
        add     edi,08H
        sub     ecx,08H
        jg      @B

        ; Now trigger the blt
        CHECKDMASPACE ds,ebx,edi,20H
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        movzx   ecx,byte ptr dwRop3+2
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        mov     dword ptr ds:[edi + 08H],CHNRUN(RectAndText.SetColorFormat,1)
        pop     dword ptr ds:[edi + 0CH]
        mov     eax,CHNRUN(RectAndText.Color1A,3)
        mov     ecx,dword ptr wDstY
        mov     edx,dword ptr wExtY
        mov     ds:[edi + 10H],eax
        ; The color field next is irrelevant but NV architecture requires it
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ecx
        mov     ds:[edi + 1CH],edx
        add     edi,20H
        SETPUTPTR ds,ebx,edi
        jmp     GN_BitBltSuccess
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWLOGDEV.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwlogdev.asm
;
; Purpose:      This file contains all the hardware specific
;               logical DEVICE specific init routines.
;==============================================================================
.586
incDevice = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include gngdi.inc
include hwgdi.inc
include files.inc
include hwmacs.inc
include nvcm.inc
include nvreg.inc
include modeext.inc
include dxshare.inc
include ..\..\..\..\..\sdk\nvidia\inc\nvrmarch.inc
include ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     HW_CreateLogdevContext
;
; Purpose:      This routine allocates memory for and initializes
;               a HWLOGDEVCX structure.
;
; Arguments:
;               ds                      Context Selector
;		pHWBoardCXOffset	HWBOARDCX ptr
;
; Returns:      eax     0       failure
;                       non-0   Success and eax is a ptr to the HWLOGDEVCX
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_CreateLogdevContext, PASCAL, FRAME, FAR16
PARMD	pHWBoardCXOffset
OPENPROC
        PUSHR   esi,edi
        sub     esi,esi

        pushd   SIZE HWLOGDEVCX
        call    HW_AllocFlatMemory
        or      eax,eax
        je      DoneIt
        mov     esi,eax

        ; We are initting
        mov     ds:[esi].HWLOGDEVCX.dwInitting,1

        ; We don't know this until an attach
        mov	eax,pHWBoardCXOffset
        mov     ds:[esi].HWLOGDEVCX.pHWBoardCX,eax

        ; DirectX is not active right now
        mov     ds:[esi].HWLOGDEVCX.dwDirectXActive,0

        ; Allocate memory for a mastr mode list to give to
        ; DirectX early on.
        pushd   2048 * (SIZE MODEENTRYANDPITCH)
        call    HW_AllocFlatMemory
        or      eax,eax
        je      DoneIt
        mov     ds:[esi].HWLOGDEVCX.pMasterModeList,eax

        ; Create a 16:16 ptr to the MasterModeList
        mov     eax,1
        mov     ebx,ds:[esi].HWLOGDEVCX.pMasterModeList
        mov     ecx,2048 * (SIZE MODEENTRYANDPITCH)
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
        shl     eax,10H
        mov     ds:[esi].HWLOGDEVCX.lpMasterModeList,eax

        ; Alloc memory for the DirectX shared data structure
        pushd   SIZE DISPDRVDIRECTXCOMMON
        call    HW_AllocFlatMemory
        or      eax,eax
        je      DoneIt
        mov     ds:[esi].HWLOGDEVCX.pDirectXSharedData,eax

        ; Create a 16:16 ptr to the Shared Data
        mov     eax,1
        mov     ebx,ds:[esi].HWLOGDEVCX.pDirectXSharedData
        mov     ecx,SIZE DISPDRVDIRECTXCOMMON
        call    GN_AllocSelectorAndMapIt
        or      eax,eax
        je      DoneIt
        shl     eax,10H
        mov     ds:[esi].HWLOGDEVCX.lpDirectXSharedData,eax

        ; Fill in the DirectX Shared Data
        mov     edi,ds:[esi].HWLOGDEVCX.pDirectXSharedData
        mov     ds:[edi].DISPDRVDIRECTXCOMMON.dwDeviceHandle,NV_WIN_DEVICE
        mov     eax,ds:[esi].HWLOGDEVCX.pMasterModeList
        mov     ds:[edi].DISPDRVDIRECTXCOMMON.lpMasterModeList,eax
	mov	ax,cs
	and	eax,0FFFFH
	mov	ds:[edi].DISPDRVDIRECTXCOMMON.dwDrvCallbackSelector,eax
	mov	eax,OFFSET NV_DirectXServiceNoFrame
	mov	ds:[edi].DISPDRVDIRECTXCOMMON.dwDrvCallbackOffset,eax
	mov	ds:[edi].DISPDRVDIRECTXCOMMON.pDispDriverHWLogDevCX,esi

	; Ask the HWBOARD to fill in its DXShare data
        push	ds:[esi].HWLOGDEVCX.pHWBoardCX
        push	ds:[esi].HWLOGDEVCX.pDirectXSharedData
        call	NV_BoardSetDXSharedData

        mov     eax,esi
DoneIt:
        ; If eax is 0, then we failed, BUT if esi is non-0, then
        ; some of the HWLOGDEVCX. was filled in. We must handle
        ; this case and free any portion that got initted.
        or      eax,eax
        jne     ExitIt
        or      esi,esi
        je      ExitIt

        ; HW_DestroyLogdevContext can clean up partial inits
        push    esi
        call    HW_DestroyLogdevContext
        sub     eax,eax

ExitIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_DestroyLogdevContext
;
; Purpose:      This routine allocates memory for and initializes
;               an array of HWCRTCCX structure.
;
; Arguments:
;               ds                      The context selector.
;               pHWLogdevCXOffset       offset of HWLOGDEVCX to destroy
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_DestroyLogdevContext, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWLogdevCXOffset
        or      esi,esi
        je      DoneIt

        ; Destroy the 16:16 alias for the shared data
        cmp     ds:[esi].HWLOGDEVCX.lpDirectXSharedData,0
        je      @F

        movzx   eax,word ptr ds:[esi].HWLOGDEVCX.lpDirectXSharedData+2
        call    GN_UnmapAndFreeSelector
        mov     ds:[esi].HWLOGDEVCX.lpDirectXSharedData,0
@@:
        ; Destroy the shared data memory
        cmp     ds:[esi].HWLOGDEVCX.pDirectXSharedData,0
        je      @F

        push    ds:[esi].HWLOGDEVCX.pDirectXSharedData
        call    HW_FreeFlatMemory
        mov     ds:[esi].HWLOGDEVCX.pDirectXSharedData,0
@@:

        ; Destroy the 16:16 alias for the shared data
        cmp     ds:[esi].HWLOGDEVCX.lpMasterModeList,0
        je      @F

        movzx   eax,word ptr ds:[esi].HWLOGDEVCX.lpMasterModeList+2
        call    GN_UnmapAndFreeSelector
        mov     ds:[esi].HWLOGDEVCX.lpMasterModeList,0

@@:
        ; Destroy the modelist memory
        cmp     ds:[esi].HWLOGDEVCX.pMasterModeList,0
        je      @F

        push    ds:[esi].HWLOGDEVCX.pMasterModeList
        call    HW_FreeFlatMemory
        mov     ds:[esi].HWLOGDEVCX.pMasterModeList,0
@@:
        push    esi
        call    HW_FreeFlatMemory

DoneIt:
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:	HW_LogdevAttachCrtc
;
; Purpose:      This function is called to tell the HWLOGDEVCX a
;		new HWCRTCCX.
;
; Arguments:
;               ds                      Context Selector
;               pHWLogdevCXOffset       HWLOGDEVCX ptr
;		dwLogicalCRTCIndex	The logical index for this
;					attachment (0, 1, 2, etc..
;		pHWCrtcCXOffset		HWCRTCCX ptr
;
; Returns:      eax			0 Fail
;					non-0 success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_LogdevAttachCrtc, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD	dwLogicalCRTCIndex
PARMD	pHWCrtcCXOffset
OPENPROC
	; First, put the HWCRTCCX into the HWLOGDEVCX
	mov	ebx,pHWLogdevCXOffset
	mov	eax,dwLogicalCRTCIndex
	mov	ecx,pHWCrtcCXOffset
	mov	ds:[ebx].HWLOGDEVCX.pHWCrtcCX[eax * 4],ecx

	; This HWCRTCCX has a parent HWLOGDEVCX
	push	pHWCrtcCXOffset
	push    pHWLogdevCXOffset
	call	NV_CrtcSetLogdev

	mov	eax,1
CLOSEPROC


;==============================================================================
;
; Function:	HW_LogdevDetachCrtc
;
; Purpose:      This function is called to tell the HWLOGDEVCX to
;		remove a HWCRTCCX from its list of active contexts.
;
; Arguments:
;               ds                      Context Selector
;               pHWLogdevCXOffset       HWLOGDEVCX ptr
;		dwLogicalCRTCIndex	The logical index for this
;					attachment (0, 1, 2, etc..
;		pHWCrtcCXOffset		HWCRTCCX ptr
;
; Returns:	None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_LogdevDetachCrtc, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
PARMD	dwLogicalCRTCIndex
PARMD	pHWCrtcCXOffset
LOCALD	dwPitchInBytes
OPENPROC
	mov	ebx,pHWLogdevCXOffset
	mov	eax,dwLogicalCRTCIndex
	sub	ecx,ecx
	mov	ds:[ebx].HWLOGDEVCX.pHWCrtcCX[eax * 4],ecx

	; This HWCRTCCX no longer has a parent HWLOGDEVCX
	sub	eax,eax
	push	pHWCrtcCXOffset
	push    eax
	call	NV_CrtcSetLogdev
CLOSEPROC


;==============================================================================
;
; Function:     HW_Get16BppPixelFormat
;
; Purpose:      This function should return information about whether
;               the 16bpp mode is 1-5-5-5 or 5-6-5. Note that this is
;               not a per CRTC choice. It is per Logical Device choice.
;
; Arguments:
;               ds                      Context Selector
;               pHWLogdevCXOffset       HWLOGDEVCX ptr
;
; Returns:
;               eax     FIVE6FIVE if supporting 5-6-5
;                       0  if supporting 1-5-5-5
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_Get16BppPixelFormat, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
OPENPROC
        mov     eax,FIVE6FIVE
CLOSEPROC


;==============================================================================
;
; Function:     HW_GetTextFormat
;
; Purpose:      This function should return information about whether
;               the controller handles bit packed or byte packed
;               text. Bit packed is much better if you can support it.
;
; Arguments:
;               ds                      Context Selector
;               pHWLogdevCXOffset       HWLOGDEVCX ptr
;
; Returns:
;               eax     C1_BIT_PACKED
;                       or
;                       C1_BYTE_PACKED
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_GetTextFormat, PASCAL, FRAME, FAR16
PARMD   pHWLogdevCXOffset
OPENPROC
        mov     eax,C1_BIT_PACKED
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWRECT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwrect.asm
;
; Purpose:      This file contains a special sequence of three hardware
;               routines which the generic code calls frequently. They
;               are used for ropping a patterned rectangle into a dst
;               bitmap.
;
;==============================================================================
.586
incLogical = 1
incDrawMode = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwcrtc.inc
include hwboard.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

PUBLIC  bConvertRop2ToRop3
bConvertRop2ToRop3      LABEL   BYTE
DB      000H,   005H,   00AH,   00FH
DB      050H,   055H,   05AH,   05FH
DB      0A0H,   0A5H,   0AAH,   0AFH
DB      0F0H,   0F5H,   0FAH,   0FFH

;==============================================================================
;
; Function:     HW_DrawRectAndBorder
;
; Purpose:      This function will be called by the generic code to have
;               the hardware draw a rectangle and/or its border int a
;               random bitmap. There is a rop and maybe a clip rect.
;               If the rectangle should be filled, the generic code will
;               already have called one of the pattern load routines to
;               put the appropriate fill pattern into the hardware
;               before calling this routine. Hence, program the dst
;               base, pitch, clip rect, rop, and issue the blt. Once
;               that is done, the border is always drawn in the solid
;               color, dwSolidBorderColor with the same rop at the
;               border coordinates given.
;
; Arguments:
;               ds                      CXSel
;               pHWLogDevCXOffset       HWLOGDEVCX ptr
;               dwDstBase               offset of dst bitmap in video memory
;               dwDstPitch              pitch of dst bitmap in video memory
;               dwRop2                  two operand Rop (1 based)
;               wClipBottom             clip rectangle
;               wClipRight              if there is no clip rect then
;               wClipTop                wClipLeft = wClipTop = 0   and
;               wClipLeft               wclipRight = wClipBottom = 7FFF
;               dwDrawBorder            0       then no border,
;                                       non-0   then there is a border
;               dwSolidBorderColor      border color
;               wBorderBottom           border rectangle.
;               wBorderRight
;               wBorderTop
;               wBorderLeft
;               dwDrawInterior          non-0 then draw inside, 0 then don't
;               wRectBottom             Rectangle coordinates
;               wRectRight
;               wRectTop
;               wRectLeft
;
;               Using the border rect, draw the following four edges
;               as the border
;               inclusive       to      exclusive
;               (left,top)      to      (right,top+1)
;               (right-1,top+1) to      (right,bottom)
;               (left,top+1)    to      (left+1,bottom-1)
;               (left,bottom-1) to      (right-1,bottom)
;
; Returns:      eax             0       Punt to Dibeng
;                               non-0   Success
;
; Preserve:     ds
;==============================================================================
DECPROC HW_DrawRectAndBorder, PASCAL, FRAME, NEAR
PARMD   pHWLogDevCXOffset
PARMD   dwDstBase
PARMD   dwDstPitch
PARMD   dwRop2
PARMW   wClipBottom
PARMW   wClipRight
PARMW   wClipTop
PARMW   wClipLeft
PARMD   dwDrawBorder
PARMD   dwSolidBorderColor
PARMW   wBorderBottom
PARMW   wBorderRight
PARMW   wBorderTop
PARMW   wBorderLeft
PARMD   dwDrawInterior
PARMW   wRectBottom
PARMW   wRectRight
PARMW   wRectTop
PARMW   wRectLeft
OPENPROC
        ; Load up the logical device CX and the board CX
        mov     esi,pHWLogDevCXOffset
        mov     ebx,ds:[esi].HWLOGDEVCX.pHWBoardCX

        ; Restore the pattern alpha to -1 in stucture. It may have been 
	; changed because this output call used	a hatch brush with a 
	; transparent background.
        mov      ds:[esi].HWLOGDEVCX.dwPatternAlpha0,-1

        ; sync with other channels
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ebx,eax

        ; Load the push buffer ptr
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,dwDstBase
        CHECKDSTBASE ds,ebx,edi,eax,<dwDstPitch>

        ; Set the Rop, ColorFormat and Local Clip Rect
        CHECKDMASPACE ds,ebx,edi,10H
        mov     eax,dwRop2
        mov     ecx,ds:[esi].HWLOGDEVCX.dwRectAndTextColorFormat
        movzx   eax,cs:bConvertRop2ToRop3[eax - 1]
        mov     dword ptr ds:[edi + 00H],CHNRUN(ContextRop.SetRop5,1)
        mov     dword ptr ds:[edi + 04H],eax
        mov     dword ptr ds:[edi + 08H],CHNRUN(RectAndText.SetColorFormat,1)
        mov     dword ptr ds:[edi + 0CH],ecx
        add     edi,10H

        cmp     dwDrawInterior,0
        je      DoneInterior

        CHECKDMASPACE ds,ebx,edi,18H
        mov     eax,dword ptr wClipLeft
        mov     ecx,dword ptr wClipRight
        mov     dword ptr ds:[edi + 00H],CHNRUN(RectAndText.ClipPoint0B,5)
        mov     ds:[edi + 04H],eax
        mov     ds:[edi + 08H],ecx

        ; The Color1B value is irrelevant but must be written
        mov     ds:[edi + 0CH],eax

        mov     eax,dword ptr wRectLeft
        mov     ecx,dword ptr wRectRight
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ecx
        add     edi,18H

DoneInterior:
        cmp     dwDrawBorder,0
        je      DoneIt

        CHECKDMASPACE ds,ebx,edi,40H

        ; The format of the rop we have set requires that we use the
        ; image pattern sub-channel rather than the solid color field
        ; in the rect and text object for the solid color border.
        mov     edx,dwSolidBorderColor
        mov     eax,CHNRUN(ContextPattern.SetPatternSelect,3)
        mov     ecx,NV044_SET_PATTERN_SELECT_MONOCHROME
        or      edx,ds:[esi].HWLOGDEVCX.dwColorAlphaMask
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        mov     ds:[edi + 08H],edx
        mov     ds:[edi + 0CH],edx

        ; Now we need to reset the clip rect in RectAndText since we
        ; switched the sub-channel and the volatile data was lost.
        mov     eax,CHNRUN(RectAndText.ClipPoint0B,11)
        mov     ecx,dword ptr wClipLeft
        mov     edx,dword ptr wClipRight
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ecx
        mov     ds:[edi + 18H],edx
        mov     ds:[edi + 1CH],eax  ; Solid color irrelevant but required

        ; Program up the coordinates for the 4 borders edges
        movzx   eax,wBorderLeft
        movzx   ebx,wBorderTop
        movzx   ecx,wBorderRight
        movzx   edx,wBorderBottom

        ; (left,top)      to      (right,top+1)
        mov     ds:[edi + 20H],ax               ; left
        mov     ds:[edi + 22H],bx               ; top
        inc     ebx
        mov     ds:[edi + 24H],cx               ; right
        mov     ds:[edi + 26H],bx               ; top + 1

        ; (right-1,top+1) to      (right,bottom)
        dec     ecx
        mov     ds:[edi + 28H],cx               ; right - 1
        mov     ds:[edi + 2AH],bx               ; top + 1
        inc     ecx
        mov     ds:[edi + 2CH],cx               ; right
        mov     ds:[edi + 2EH],dx               ; bottom

        ; (left,top+1)    to      (left+1,bottom-1)
        mov     ds:[edi + 30H],ax               ; left
        mov     ds:[edi + 32H],bx               ; top + 1
        inc     eax
        dec     edx
        mov     ds:[edi + 34H],ax               ; left + 1
        mov     ds:[edi + 36H],dx               ; bottom - 1

        ; (left,bottom-1) to      (right-1,bottom)
        dec     eax
        mov     ds:[edi + 38H],ax               ; left
        mov     ds:[edi + 3AH],dx               ; bottom - 1
        dec     ecx
        inc     edx
        mov     ds:[edi + 3CH],cx               ; right - 1
        mov     ds:[edi + 3EH],dx               ; bottom

        mov     ebx,ds:[esi].HWLOGDEVCX.pHWBoardCX
        add     edi,40H

DoneIt:
        SETPUTPTR ds,ebx,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_BeginRect
;
; Purpose:      Before calling this function, the generic code will have
;               called a LoadPattern function to load a solid, mono, or
;               color pattern into the pattern registers. After that,
;               this function will be called by the generic code to have
;               the hardware prepare for receiving a list of rectangles.
;               This routine should set the rop, the clip rect, and set
;               the dst base and pitch in preparation for a random number
;               (including 0) of HW_BlockRect calls. When the generic code
;               is done drawing all the rectangles via HW_BlockRect,
;               it will call the HW_EndRect routine to allow the hardware
;               specific code to clean up after itself.
;
; Arguments:
;               ds                      CXSel
;               pHWLogDevCXOffset       HWLOGDEVCX ptr
;               dwDstBase               offset of dst bitmap in video memory
;               dwDstPitch              pitch of dst bitmap in video memory
;               dwRop2                  two operand Rop (1 based)
;               wClipBottom             clip rectangle
;               wClipRight              if there is no clip rect then
;               wClipTop                wClipLeft = wClipTop = 0   and
;               wClipLeft               wclipRight = wClipBottom = 7FFF
;
; Returns:
;               eax             0       Punt to Dibeng
;                               non-0   Success
;
; Preserve:     ds
;==============================================================================
DECPROC HW_BeginRect, PASCAL, FRAME, NEAR
PARMD   pHWLogDevCXOffset
PARMD   dwDstBase
PARMD   dwDstPitch
PARMD   dwRop2
PARMW   wClipBottom
PARMW   wClipRight
PARMW   wClipTop
PARMW   wClipLeft
OPENPROC
        ; Load up the logical device CX and the board CX
        mov     esi,pHWLogDevCXOffset
        mov     ebx,ds:[esi].HWLOGDEVCX.pHWBoardCX

        ; sync with other channels
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ebx,eax

        ; Load the push buffer ptr
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,dwDstBase
        CHECKDSTBASE ds,ebx,edi,eax,<dwDstPitch>

        ; Set the Rop, ColorFormat and Local Clip Rect
        CHECKDMASPACE ds,ebx,edi,20H
        mov     eax,dwRop2
        mov     ecx,ds:[esi].HWLOGDEVCX.dwRectAndTextColorFormat
        movzx   eax,cs:bConvertRop2ToRop3[eax - 1]
        mov     dword ptr ds:[edi + 00H],CHNRUN(ContextRop.SetRop5,1)
        mov     dword ptr ds:[edi + 04H],eax
        mov     dword ptr ds:[edi + 08H],CHNRUN(RectAndText.SetColorFormat,1)
        mov     dword ptr ds:[edi + 0CH],ecx
        mov     eax,dword ptr wClipLeft
        mov     ecx,dword ptr wClipRight
        mov     dword ptr ds:[edi + 10H],CHNRUN(RectAndText.ClipPoint0B,3)
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ecx

        ; The Color1B field value is irrelevant but it must be written
        mov     ds:[edi + 1CH],eax
        add     edi,20H

        mov     ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_BlockRect
;
; Purpose:      This function can be called a random number of times
;               after HW_BeginRect is called and before HW_EndRect is
;               called. See Purpose under HW_BeginRect for more details.
;
; Arguments:
;               ds      CXSel
;               edi     HWLOGDEVCX ptr
;               eax     top:left of rectangle to draw
;               ebx     bottom:right of rectangle to draw
;
; Returns:      None
;
; Preserve:     ds,es,esi,edi,eax,ebx
;==============================================================================
DECPROC HW_BlockRect, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   edi

        ; Load the push buffer ptr
        mov     ecx,ds:[edi].HWLOGDEVCX.pHWBoardCX
        mov     edi,ds:[ecx].HWBOARDCX.pCurrentPushBufferOffset

        mov     edx,CHNRUN(RectAndText.ClippedRectangle.point0,2)
        CHECKDMASPACE ds,ecx,edi,0CH
        mov     ds:[edi + 00H],edx
        mov     ds:[edi + 04H],eax
        mov     ds:[edi + 08H],ebx
        add     edi,0CH
        mov     ds:[ecx].HWBOARDCX.pCurrentPushBufferOffset,edi

        POPR    edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_EndRect
;
; Purpose:      This function will get called after some random number
;               of HW_BlockRect calls. See Purpose
;               under HW_BeginRect for more details.
;
;               You can do whatever you want to do in here. Probably
;               reset the hardware clip rect if one was needed or
;               bump the DMA ptr or whatever.
;
; Arguments:
;               ds      CXSel
;               edi     HWLOGDEVCX ptr
;
; Returns:      None
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_EndRect, PASCAL, NOFRAME, NEAR
OPENPROC

        ; Restore the pattern alpha to -1. It may have been changed
        ; via a hwldpat.asm call prior to the HW_BeginRect call. It
        ; also may have been changed because this output call used
        ; a hatch brush with a transparent background.
        mov     ecx,-1
        mov     ds:[edi].HWLOGDEVCX.dwPatternAlpha0,ecx

        ; Load the push buffer ptr
        mov     ebx,ds:[edi].HWLOGDEVCX.pHWBoardCX
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(ContextPattern.SetMonochromeColor0,1)
        CHECKDMASPACE ds,ebx,edi,08H
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        add     edi,08H

        ; Don't need to reset clip rect here because I use the local
        ; clip rect for this sequence which will get cleared by any
        ; sub-channel change. Hence, just bang the put ptr.
        SETPUTPTR ds,ebx,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_SolidColorRectangle
;
; Purpose:      This function draws a solid color rectangle gievn
;               the coordinates and rop as below. No clipping
;               is done.
;
; Arguments:
;               ds              Context Selector
;               eax             left:top
;               ebx             width:height
;               ecx             dwRop2
;               edx             physical color
;               edi             HWLOGDEVCX ptr
;               gs:esi          DIBENGINEHDR of bitmap in which to draw
;
; Returns:      None
;
; Preserve:     ds
;==============================================================================
DECPROC HW_SolidColorRectangle, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Save the color
        or      edx,ds:[edi].HWLOGDEVCX.dwColorAlphaMask

        ; Save the color format for later use.
        push    ds:[edi].HWLOGDEVCX.dwRectAndTextColorFormat

        ; remap the rop

        movzx   ecx,cs:bConvertRop2ToRop3[ecx - 1]
        push    ecx

        ; Save the pattern alpha
	push	edx
	push	edx
	mov	ds:[edi].HWLOGDEVCX.dwPatternAlpha0,edx
	mov	ds:[edi].HWLOGDEVCX.dwPatternAlpha1,edx

        mov     ecx,ds:[edi].HWLOGDEVCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ecx,edx

        ; Load the push buffer ptr
        mov     edi,ds:[ecx].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     edx,gs:[esi].DIBENGINEHDR.deBitsOffset
        CHECKDSTBASE ds,ecx,edi,edx,<gs:[esi].DIBENGINEHDR.deDeltaScan>

        ; Check for space and program the blt
        CHECKDMASPACE ds,ecx,edi,30H
        mov     dword ptr ds:[edi + 00H],CHNRUN(ContextPattern.SetPatternSelect,3)
        mov     dword ptr ds:[edi + 04H],NV044_SET_PATTERN_SELECT_MONOCHROME
        pop     dword ptr ds:[edi + 08H]
        pop     dword ptr ds:[edi + 0CH]
        mov     dword ptr ds:[edi + 10H],CHNRUN(ContextRop.SetRop5,1)
        pop     dword ptr ds:[edi + 14H]
        mov     dword ptr ds:[edi + 18H],CHNRUN(RectAndText.SetColorFormat,1)
        pop     dword ptr ds:[edi + 1CH]
        mov     dword ptr ds:[edi + 20H],CHNRUN(RectAndText.Color1A,3)
        mov     dword ptr ds:[edi + 24H],0
        mov     ds:[edi + 28H],eax
        mov     ds:[edi + 2CH],ebx
        add     edi,30H
        SETPUTPTR ds,ecx,edi
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWTEXT.ASM ===
;==============================================================================
;
; Copyright (C) 1998,Nvidia Corporation
;
; File:         hwtext.asm
;
; Purpose:      This file implements the hardware specific text functions.
;
;==============================================================================
.586
incDrawMode = 1
incDevice   = 1
incLogical  = 1
incFont     = 1
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc

OPENSEG  _DATA,USE16,DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32,%DEF_CODE_SIZE,CODE

;==============================================================================
;
; Function:     HW_DrawOpaqueRects
;
; Purpose:      This function should draw any opaqueing rectangles
;               that exist. Do not do the text now -- that will be
;               done later.
;
;               NOTE: You may set es to anything you wish in this
;               routine and it will not get changed by the generic
;               for the duration of the ExtTextOut call.
;
; Arguments:    Display Driver ExtTextOut frame
;               es              CXSel
;               dwBgColor       the bgColor from the DRAWMODE struct
;                               opaque rects should be drawn in this color
;               wOpaqueClipRect opaque rectangles must be clipped to this
;                               rectangle. It is a RECT struct.
;
; Returns:      eax     0       then rest of ExtTextOut call will be punted
;                               It is not possible to support the text
;                               portion of the call unless you also support
;                               the opaqueing rects portion. However you
;                               can just support the opaqueing rects without
;                               handling the text part by failing TextBegin.
;                       non-0   then ExtTextOut continues
; Preserve:
;==============================================================================
DECPROC HW_DrawOpaqueRects,PASCAL,ShareFrameFar16,NEAR
EXTTEXTOUT_FRAME_AND_LOCALS
OPENPROC
        ; Load the board ptr
        mov     ebx,pHWBoardCXOffset_ForExtTextOut

        ; wait until everyone else goes idle, if they are idle now
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE es,ebx,eax

        ; load the push buffer ptr
        mov     edi,es:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Get ready to do opaqueing rects
        sub     esi,esi
        lds     si,lpOpaqueRects

        ; Set the dst base and pitch if need be
        mov     eax,dwDstBitsOffset
        CHECKDSTBASE es,ebx,edi,eax,dwDstBitsDeltaScan
	mov	edx,pHWLogDevCXOffset_ForExtTextOut

        ; Set the clip rect,color and rop
        CHECKDMASPACE es,ebx,edi,2CH
        mov    	eax,es:[edx].HWLOGDEVCX.dwPatternAlpha0
        mov	ecx,es:[edx].HWLOGDEVCX.dwPatternAlpha1
	mov	dword ptr es:[edi + 00H],CHNRUN(ContextPattern.SetMonochromeColor0,2)
	mov	es:[edi + 04H],eax
	mov	es:[edi + 08H],ecx
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        mov     ecx,0CCH
        mov     es:[edi + 0CH],eax
        mov     es:[edi + 10H],ecx
        mov     eax,CHNRUN(RectAndText.SetColorFormat,1)
        mov     ecx,pHWLogDevCXOffset_ForExtTextOut
        mov     ecx,es:[ecx].HWLOGDEVCX.dwRectAndTextColorFormat
        mov     es:[edi + 14H],eax
        mov     es:[edi + 18H],ecx
        mov     eax,CHNRUN(RectAndText.ClipPoint0B,3)
        mov     ecx,dword ptr wOpaqueClipRect.left
        mov     es:[edi + 1CH],eax
        mov     es:[edi + 20H],ecx
        mov     eax,dword ptr wOpaqueClipRect.right
        mov     ecx,dwBgColor
        mov     es:[edi + 24H],eax
        mov     es:[edi + 28H],ecx
        add     edi,2CH

        ; Draw all opaqeuing rects in the list
Loopy:  mov     edx,dword ptr ds:[esi].RECT.left
        mov     ecx,dword ptr ds:[esi].RECT.right
        add     esi,8
        cmp     cx,dx
        jle     Done
        cmp     ecx,edx
        jle     Done
        mov     eax,CHNRUN(RectAndText.ClippedRectangle.point0,2)
        CHECKDMASPACE es,ebx,edi,0CH
        mov     es:[edi + 00H],eax
        mov     es:[edi + 04H],edx
        mov     es:[edi + 08H],ecx
        add     edi,0CH
        jmp     Loopy
Done:
        SETPUTPTR es,ebx,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_TextBegin
;
; Purpose:      This function gets called by the generic code when
;               it is about to start processing glyphs. After you
;               receive this call,you will get some number of
;               HW_BltGlyph calls and finally a HW_EndText call.
;               The es register will not be changed by the generic
;               code between this routine and the call to HW_TextEnd.
;
; Arguments:    Display Driver ExtTextOut frame.
;               es              CXSel
;               dwFgColor       the fgColor from the DRAWMODE struct
;               dwBgColor       the bgColor from the DRAWMODE struct
;               wTextClipRect   opaque rectangles must be clipped to this
;                               rectangle. It is a RECT struct.
;
; Returns:      eax     0       then text portion will be punted
;                       non-0   then you must handle TextBlt and TextEnd
;
; Preserve:     ds,es
;==============================================================================
DECPROC HW_TextBegin,PASCAL,ShareFrameFar16,NEAR
EXTTEXTOUT_FRAME_AND_LOCALS
OPENPROC
        ; Load the board ptr
        mov     ebx,pHWBoardCXOffset_ForExtTextOut

        ; If there were opaqueing rects,some things are already setup
        cmp     lpOpaqueRects,0
        jne     PartialSetup

        ; We did not do opaque rectangles,so need complete setup.
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE es,ebx,eax

        ; load the push buffer ptr
        mov     edi,es:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,dwDstBitsOffset
        CHECKDSTBASE es,ebx,edi,eax,dwDstBitsDeltaScan
	mov	edx,pHWLogDevCXOffset_ForExtTextOut

        ; Set the clip rect,color and rop
        CHECKDMASPACE es,ebx,edi,2CH
        mov    	eax,es:[edx].HWLOGDEVCX.dwPatternAlpha0
        mov	ecx,es:[edx].HWLOGDEVCX.dwPatternAlpha1
	mov	dword ptr es:[edi + 00H],CHNRUN(ContextPattern.SetMonochromeColor0,2)
	mov	es:[edi + 04H],eax
	mov	es:[edi + 08H],ecx
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        mov     edx,0CCH
        mov     es:[edi + 0CH],eax
        mov     es:[edi + 10H],edx
        mov     eax,CHNRUN(RectAndText.SetColorFormat,1)
        mov     edx,pHWLogDevCXOffset_ForExtTextOut
        mov     edx,es:[edx].HWLOGDEVCX.dwRectAndTextColorFormat
        mov     es:[edi + 14H],eax
        mov     es:[edi + 18H],edx
        mov     eax,CHNRUN(RectAndText.ClipPoint0F,3)
        mov     edx,dword ptr wTextClipRect.left
        mov     es:[edi + 1CH],eax
        mov     es:[edi + 20H],edx
        mov     eax,dword ptr wTextClipRect.right
        mov     edx,dwFgColor
        mov     es:[edi + 24H],eax
        mov     es:[edi + 28H],edx
        add     edi,2CH
        jmp     DoneIt

PartialSetup:
        ; Set the clip rect,color and rop
        CHECKDMASPACE es,ebx,NONE,10H
        mov     edi,es:[ebx].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(RectAndText.ClipPoint0F,3)
        mov     edx,dword ptr wTextClipRect.left
        mov     es:[edi + 00H],eax
        mov     es:[edi + 04H],edx
        mov     eax,dword ptr wTextClipRect.right
        mov     edx,dwFgColor
        mov     es:[edi + 08H],eax
        mov     es:[edi + 0CH],edx
        add     edi,10H
DoneIt:
        mov     es:[ebx].HWBOARDCX.pCurrentPushBufferOffset,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_TextBlt
;
; Purpose:      This function is called to blt an individual glyph.
;               The es register has not changed from the value you
;               assigned to it in HW_TextBegin.
;
; Arguments:    Display Driver ExtTextOut frame
;               es      CXSel
;               ds:esi  points to first byte of glyph data
;               ebx     DstYOrg:DstXOrg
;               edx     DstYExtent:DstXExtent
;               ecx     Total number of bits in the glyph
;
; Preserve:     ds,fs,gs
;==============================================================================
DECPROC HW_TextBlt,PASCAL,ShareFrameFar16,NEAR
EXTTEXTOUT_FRAME_AND_LOCALS
OPENPROC
        mov     edi,pHWBoardCXOffset_ForExtTextOut

        ; See if there are more bytes than we can send out in one shot
        add     ecx,31
        shr     ecx,3
        and     cl,NOT 3
        cmp     ecx,200H
        ja      BreakIntoChunks

        lea     eax,[ecx + 0CH]
        CHECKDMASPACE es,edi,NONE,eax
        mov     edi,es:[edi].HWBOARDCX.pCurrentPushBufferOffset
        sub     eax,4
        shr     ecx,2
        shl     eax,10H
        add     edi,0CH
        mov     ax,CHNRUN(RectAndText.dwSizeC,0)
        mov     es:[edi - 0CH],eax
        mov     eax,pHWBoardCXOffset_ForExtTextOut
        mov     es:[edi - 08H],edx
        mov     es:[edi - 04H],ebx
        rep     movs dword ptr es:[edi],ds:[esi]
        mov     es:[eax].HWBOARDCX.pCurrentPushBufferOffset,edi
        ret

BreakIntoChunks:
        ; Set the width,height and position of the character
        CHECKDMASPACE es,edi,NONE,0CH
        mov     edi,es:[edi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(RectAndText.dwSizeC,2)
        mov     es:[edi + 00H],eax
        mov     es:[edi + 04H],edx
        mov     es:[edi + 08H],ebx
        add     edi,0CH
        mov     edx,ecx
        mov     eax,CHNRUN(RectAndText.MonochromeColor1C,80H)
        mov     ebx,pHWBoardCXOffset_ForExtTextOut
Loopy:
        mov     ecx,200H
        sub     edx,ecx
        jae     @F
        add     edx,ecx
        mov     ecx,edx
        shrd    eax,edx,10H
        mov     ax,CHNRUN(RectAndText.MonochromeColor1C,0)
        xor     edx,edx
@@:
        add     ecx,4
        CHECKDMASPACE es,ebx,edi,ecx
        sub     ecx,4
        mov     es:[edi + 00H],eax
        add     edi,4
        shr     ecx,2
        rep     movs dword ptr es:[edi],ds:[esi]
        or      edx,edx
        jg      Loopy
        SETPUTPTR es,ebx,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_TextEnd
;
; Purpose:      This function is called by the generic code after
;               all the individual glyphs have been bltted. You
;               will receive this call only if you received a
;               HW_TextBegin call. Do anything you need to do in
;               here to clean up after doing text.
;
; Arguments:    Display Driver ExtTextOut frame
;               es      CXSel
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_TextEnd,PASCAL,ShareFrameFar16,NEAR
EXTTEXTOUT_FRAME_AND_LOCALS
OPENPROC
        mov     ebx,pHWBoardCXOffset_ForExtTextOut
        mov     edi,es:[ebx].HWBOARDCX.pCurrentPushBufferOffset
        SETPUTPTR es,ebx,edi
CLOSEPROC

CLOSESEG _NVTEXT32
END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\hwstrblt.asm ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwclrblt.asm
;
; Purpose:      This file stretches color bitmaps or DIBs from system
;               memory to video memory. The src color Bitmap can be
;               4, 8, 15, 16, 24, 32 bpp, and, the dst video memory
;               bitmap can be 8, 15, 16, or 32 bpp. There may be
;               a rop and a pattern as well.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include hwgdi.inc
include hwmacs.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     HW_BeginStretchSrcColorDstVram
;
; Purpose:      This function is an easy way to implement color
;               bitmap stretch. This routine gets called to do setup,
;               and then the HW_BlockStretchSrcColorDstVram gets called before
;               each chunk of lines is transferred, and finally the
;               function HW_EndStretchSrcColorDstVram is called when the main
;               routine is done. You need to do the following:
;
;               2) Set the Rop (which is the byte at dwRop3+2)
;
;               3) Set the starting destination coordinates to be:
;                  dwDstTop, dwDstLeft
;
;               4) Set the extents of the transfer which are:
;                  dwExtX, dwExtY
;
;                  Note that the number of pixels sent for each scan
;                  will not necessarily be dwExtX, but will be instead
;                  dwExtXAligned. dwExtXAligned is equal to dwExtX plus
;                  from 0 to 3 extra pixels required to make the byte
;                  length of a transferred scan a multiple of a dword.
;                  dwExtX is simply the dst rectangle width in pixels.
;                  If there are any extra pixels beyond dwExtX, they
;                  should be dropped by the hardware. That may mean
;                  you need to tell the hardware the blt width is
;                  really dwExtXAligned and set a hardware clip rect.
;
;               5) Program the base and pitch of the dst bitmap which are:
;                  dwDstBitsOffset, dwDstPitch
;
;               6) Anything else you need to do to prepare the
;                  hardware for a transfer of the src bitmap.
;
;               7) You must return three important values to the generic
;                  code. One is a pseudo wrap width.  The second is the
;                  maximum number of bytes you can handle in a single
;                  transfer (without waiting or writing new header info,
;                  or whatever the hardware requires.) The third is
;                  your hardware ptr (either MMIO or DMA buffer.)
;
;                  Here is how it works:
;
;                  When you return from this routine, you should have
;                  es set to your hardware selector.
;
;                  The generic code will call HW_BlockStretchSrcColorDstVram
;                  and have it wait for enough fifo slots or DMA buffer
;                  space. HW_BlockStretchSrcColorDstVram will return a ptr to
;                  the generic code telling it where to begin writing
;                  pixels. The generic code starts xlatting and copying
;                  pixels incrementing this ptr as it goes. When the
;                  generic code reaches the end of a scanline, it will
;                  add in the pseudo wrap width you returned to the current
;                  value of the ptr and begin transferring pixels on
;                  the next scanline at this new address. If the
;                  generic code reaches the maximum number of pixels
;                  that can be handled in a single transfer (which was
;                  the second parameter you returned) before transferring
;                  the whole bitmap, it will call the block routine
;                  HW_BlockStretchSrcColorDstVram again to both wait for more
;                  space and get a new dst ptr.
;
;                  So what exactly should these return values be?
;
;                  For a fifo based part like NV3/ZX, the pseudo wrap width
;                  should be -dwExtAligned * (dwDstBpp which is simply the
;                  negative of one of the locals on the predefined frame.
;                  The maximum single transfer size should be 128 bytes
;                  (or whatever the size of the fifo is in bytes.)
;
;                  For a DMA based part like NV4, the pseudo wrap width
;                  should be somewhere near 0 -- what does this mean?
;                  What we would like is for the next scanline's data to
;                  immediately follow the preceeding scanline's data.
;                  You might think that this implies the pseudo wrap
;                  width is 0. However, we will need to play with the
;                  dwExtX and dwExtXAligned to see if this is true.
;                  If dwExtX and dwExtXAligned are equal, the pseudo
;                  wrap width should be 0. If dwExtXAligned is greater
;                  (it can't be less since it is equal to dwExtX
;                  rounded up to the next number of pixels which gives
;                  a dword aligned scanline length), then the pseudo
;                  wrap width should be
;                  (dwExtXAligned - dwExtX) * dwDstBytesPerPixel
;
;                  The maximum single transfer size in bytes for DMAs is
;                  the size of the method to which the color pixels
;                  will be written. (Or the size of the DMA buffer if
;                  it is smaller, but for other driver policy reasons,
;                  the DMA buffer must be more than twice the size of
;                  the largest method so go with the method size.)
;
; Arguments:
;               ds                      Context Sel
;               pHWLogdevCXOffset       HWLOGDEVCX
;               dwDstBitsOffset         offset of dst bitmap in VRAM
;               dwDstPitch              pitch of dst bitmap in VRAM
;               dwDstBpp                bpp of dst bitmap (8,15,16,or 32)
;               dwDstLeft               left edge coord of dst rectangle
;               dwDstTop                top edge coord of dst rectangle
;               dwExtDstX               width of dst rectangle in pixels
;               dwExtDstY               height of dst rectangle in scanlines
;               dwExtSrcX               width of src rectangle in pixels
;               dwExtSrcY               height of dst rectangle in scanlines
;               dwExtSrcXAligned        aligned width of src rectangle in pixels
;               lpBrush                 ptr to DIB_Brush
;               lpDrawMode              ptr to DRAWMODE
;               dwRop3                  rop 3 in Microsoft rop format
;
; Returns:
;       eax     0       need to punt
;               else    Keep going -- everything's fine
;                       In this case, you must also return
;                       ebx  - The pseudo wrap width
;                       ecx  - The max single transfer size in bytes
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_BeginStretchSrcColorDstVram, PASCAL, FRAME, NEAR
PARMD   pHWLogdevCXOffset
PARMD   dwDstBitsOffset
PARMD   dwDstPitch
PARMD   dwDstBpp
PARMD   dwDstLeft
PARMD   dwDstTop
PARMD   dwExtDstX
PARMD   dwExtDstY
PARMD   dwExtSrcX
PARMD   dwExtSrcY
PARMD   dwExtSrcXAligned
PARMD   lpBrush
PARMD   lpDrawMode
PARMD   dwRop3
PARMD   lpClipRect
OPENPROC
        mov     edx,pHWLogdevCXOffset
        mov     esi,ds:[edx].HWLOGDEVCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,esi,eax

        ; Load the push buffer ptr
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset

        ; Set the dst base and pitch if need be
        mov     eax,dwDstBitsOffset
        CHECKDSTBASE ds,esi,edi,eax,dwDstPitch

        ; Prepare for a src transfer
        CHECKDMASPACE ds,esi,edi,48H
        mov     eax,CHNRUN(ContextPattern.SetMonochromeColor0,2)
        mov     ebx,ds:[edx].HWLOGDEVCX.dwPatternAlpha0
        mov     ecx,ds:[edx].HWLOGDEVCX.dwPatternAlpha1
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx
        mov     ds:[edi + 08H],ecx
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        movzx   ebx,byte ptr dwRop3+2
        mov     ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],ebx
        mov     eax,CHNRUN(StretchedImageFromCpuHdr.object,1)
        mov     ebx,OBJ_STRETCHED_IMAGE_FROM_CPU
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ebx

        mov     eax,CHNRUN(StretchedImageFromCpu.SetColorFormat,1)
        mov     ebx,ds:[edx].HWLOGDEVCX.dwImageFromCpuColorFormat
        mov     ds:[edi + 1CH],eax
        mov     ds:[edi + 20H],ebx
        mov     eax,CHNRUN(StretchedImageFromCpu.dwSizeIn,3)
        mov     ds:[edi + 24H],eax
        mov     ebx,dwExtSrcY
        mov     eax,dwExtSrcXAligned
	shl	ebx,10H
	mov	bx,ax
        mov     ds:[edi + 28H],ebx
	mov	eax,dwExtDstX
	mov	ecx,dwExtSrcX
	shl	eax,20
	sub	edx,edx
	idiv	ecx
        mov     ds:[edi + 2CH],eax
	mov	eax,dwExtDstY
	shl	eax,20
	mov	ecx,dwExtSrcY
	sub	edx,edx
	idiv	ecx
        mov     ds:[edi + 30H],eax
        mov     eax,CHNRUN(StretchedImageFromCpu.ClipPoint,2)
	sub	edx,edx
	mov	ebx,-1
	cmp	lpClipRect,edx
	je	@F
	lgs	dx,lpClipRect
        mov	ebx,dword ptr gs:[edx].RECT.right
        mov	edx,dword ptr gs:[edx].RECT.left
	sub	ebx,edx
@@:
        mov     ds:[edi + 34H],eax
        mov     ds:[edi + 38H],edx
        mov     ds:[edi + 3CH],ebx
        mov     eax,CHNRUN(StretchedImageFromCpu.Point12d4,1)
        mov     ds:[edi + 40H],eax
	mov	eax,dwDstTop
	shl	eax,20
	mov	ebx,dwDstLeft
	shl	ebx,4
	mov	ax,bx
	add	eax,80008H
        mov     ds:[edi + 44H],eax
        add     edi,48H

        ; I need to return a few things
        mov     ebx,dwExtSrcXAligned
        sub     ebx,dwExtSrcX
        mov     ecx,dwDstBpp
        inc     ecx
        shr     ecx,3
        imul    ebx,ecx         ; pseudo wrap width
        mov     ecx,1792 * 4    ; size of color transfer method
        mov     ax,ds
        mov     es,ax
        mov     eax,1
Done:
CLOSEPROC


;==============================================================================
;
; Function:     HW_BlockStretchSrcColorDstVram
;
; Purpose:      This function is an easy way to implement color
;               bitmap transfers. It is one of a sequence. For full
;               details, please see HW_BeginStretchSrcColorDstVram eariler
;               in this file.
;
;               Here, wait for eax bytes of space in the DMA buffer or
;               in the fifo. You may adjust es:edi to whatever you wish.
;               Hence, if you need to wrap the DMA buffer, you may do
;               do and then reset es:edi to the start of the buffer.
;               The generic code never touches es and only adjusts edi
;               by incrementing it appropriately for every dst pixel
;               that is transferred.
;
; Arguments:
;               es      Context Seletor
;               eax     bytes to wait for
;               esi     pHWBoardCX
;               edi     push buffer ptr
;
; Returns:      This routine is not failable. If you wish to fail the
;               sequence, you must fail at HW_BeginStretchSrcColorDstVram time.
;               es:edi must point to the location for the generic code
;               to copy the next eax bytes of dst pixels translated from
;               src pixels.
;
; Preserve:     ds,esi,fs,ebx
;==============================================================================
DECPROC HW_BlockStretchSrcColorDstVram, PASCAL, NOFRAME, NEAR
OPENPROC
        SETPUTPTR es,esi,edi
        shrd    ecx,eax,10H
        lea     edx,[eax + 4]
        mov     cx,CHNRUN(StretchedImageFromCpu.Color,0)
        CHECKDMASPACE es,esi,edi,edx
        mov     es:[edi],ecx
        add     edi,4
CLOSEPROC


;==============================================================================
;
; Function:     HW_EndStretchSrcColorDstVram
;
; Purpose:      This function is an easy way to implement color
;               bitmap transfers. It is one of a sequence. For full
;               details, please see HW_BeginStretchSrcColorDstVram eariler
;               in this file.
;
;               You may do anything you wish to here. There is nothing
;               specifically required. Some possibiliites are:
;               1) Bump the DMA ptr if you are DMA based
;               2) Reset the hardware clip rect if that was needed.
;
; Arguments:
;               es      Context Selector
;               esi     pHWBoardCX
;               edi     es has not changed since the last call to
;                       HW_BlockStretchSrcColorDstVram and edi has only
;                       changed by being incremented for each dst
;                       pixel transferred.
;
; Returns:      This routine is not failable. If you wish to fail the
;               sequence, you must fail at HW_BeginStretchSrcColorDstVram time.
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_EndStretchSrcColorDstVram, PASCAL, NOFRAME, NEAR
OPENPROC
        SETPUTPTR es,esi,edi
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWSYSBLT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwsysblt.asm
;
; Purpose:      This file has routines that assist the generic code
;               in doing blts involving a src in video memory and
;               a dst in system memory. There may be a pattern involved
;               with the rop as well, but there may not be.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwcrtc.inc
include hwboard.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     HW_BeginSrcVramDstSystem
;
; Purpose:      This function is an easier way to implement blts from
;               video memory back to system memory. The generic code
;               actually orchestrates the process. First it calls this
;               routine to do setup. The the generic code will make
;               some number of calls to HW_BlockSrcVramDstSystem and
;               HW_WaitSrcVramDstSystem which will DMA a chunk of the
;               src back into system memory and wait for its completion.
;               The generic code assumes you have at least two buffers
;               so that it can overlap the DMAing of one with the
;               processing of the other.
;               The generic code processes each chunk ropping it
;               into place in the dst bitmap. Finally when the entire
;               src has been transferred, the generic code calls the
;               routine HW_EndSrcVramDstSystem so the hardware specific
;               code can do cleanup. You will need to do the following
;               in this routine:
;
;               1) Anything special you need to do to prepare the
;                  hardware for multiple DMA transfers.
;
;               2) Compute and return the following three things needed by
;                  the generic code:
;                  dwTransferBufferPitchInBytes -- this is the byte width
;                       of a single scan of the DMAed bitmap. The generic
;                       code knows the dwExtX and the dwSrcBpp, but the
;                       hardware may wish to pad each line out to a
;                       multiple of a dword or a quadword or whatever.
;                       Since the generic code is doing the actual copy
;                       and ropping of the transferred data with the dst,
;                       it needs to know the transfer area pitch.
;                  dwMaxScanlinesPerTransfer -- just in case there is a
;                       limit on how many this can be. For example, the
;                       hardware may only be able to handle up to a
;                       certain number of lines or bytes in a transfer.
;                       Alternatively, the transfer area may have a
;                       limited size. Based upon the variable computed
;                       above, dwTransferBufferPitchInBytes, only some
;                       certain number of scans may fit in the buffer. e.g.
;                       if each scan is 1K long and the transfer area
;                       is 64K in size, then only 64 scans can be
;                       transferred at a time.
;
; Arguments:
;               ds                      Context Sel
;               pHWLogdevCXOffset       HWLOGDEVCX
;               dwSrcBitsSel    Selector for the src bitmap which is
;                               always the selector for the screen since
;                               the src bitmap is in offscreen memory.
;               dwSrcBitsOffset the offset in video memory of the base of
;                               the bitmap.
;               dwSrcBpp        the pixel depth of the src
;               dwSrcPitch      the pitch of the src bitmap
;               dwSrcLeft       Just in case the hardware cannot DMA back
;                               starting from arbitrary byte alignments,
;                               I have included this argument. You may
;                               need this when computing
;                               dwTransferBufferPitchInBytes
;               dwExtX          The X extent in pixels of the rectangle
;                               that we will be calling the routine
;                               HW_BlockSrcVramDstSystem to DMA back to
;                               system memory. This is also included
;                               here so you can do the appropriate
;                               computations for the return variables.
;
; Returns:
;       eax     0       need to punt
;               else    Keep going -- everything's fine
;                       In this case, you must also return
;                       ebx  -- dwTransferBufferPitchInBytes
;                       ecx  -- dwMaxScanlinesPerTransfer
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_BeginSrcVramDstSystem, PASCAL, FRAME, NEAR
PARMD   pHWLogdevCXOffset
PARMD   dwSrcBitsSel
PARMD   dwSrcBitsOffset
PARMD   dwSrcBpp
PARMD   dwSrcPitch
PARMD   dwSrcLeft
PARMD   dwExtX
OPENPROC
        mov     ebx,pHWLogdevCXOffset
        mov     ebx,ds:[ebx].HWLOGDEVCX.pHWBoardCX
        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,ebx,eax

        ; Load the push buffer ptr
        mov     edi,ds:[ebx].HWBOARDCX.pCurrentPushBufferOffset

        ; Load up sub-channels 6 and 7 to use the MemoryToMemoryFormats
        CHECKDMASPACE ds,ebx,edi,10H
        mov     eax,CHNRUN(MemoryToMemoryFormat0Hdr,1)
        mov     ecx,OBJ_DMA_FROM_VRAM_TO_SYSRAM_0
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ecx
        mov     eax,CHNRUN(MemoryToMemoryFormat1Hdr,1)
        mov     ecx,OBJ_DMA_FROM_VRAM_TO_SYSRAM_1
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ecx
        add     edi,10H
        SETPUTPTR ds,ebx,edi

        ; The transfer pitch in bytes is always a multiple of a dword
        mov     ebx,dwSrcBpp
        inc     ebx
        shr     ebx,3
        imul    ebx,dwExtX
        add     ebx,3
        and     ebx,NOT 3

        ; Since there must be at least 2 target buffers, limit the
        ; number of scanlines that can be transferred to the amount
        ; that will fit in half of the cacheblae buffer area.
        mov     eax,CACHEABLE_BUFFER_SIZE / 2
        sub     edx,edx
        div     ebx
        mov     ecx,eax
CLOSEPROC


;==============================================================================
;
; Function:     HW_BlockSrcVramDstSystem
;
; Purpose:      This function is an easy way to implement Blts where
;               the src is in vram and the dst is in system memory.
;               It is one of a sequence. For full details, please see
;               HW_BeginSrcVramDstSystem eariler in this file.
;
;               This routine must transfer a chunk of the src bitmap
;               back from vram into some system memory area. The base,
;               pitch, bitdepth, rectangle to transfer, and ID as to
;               which transfer buffer to use are all specified here.
;               NOTE: The pitch of a line in the transfer area must
;               be the same as the dwTransferBufferPitchInBytes
;               variable computed and returned to the generic code in
;               HW_BeginSrcVramDstSystem.
;
; Arguments:
;               ds              CXSel
;               ebx             0 or 1 -- which transfer area to use
;               pHWBoardCXOffset   HWBOARDCX
;               dwSrcBase       Offset in VRAM of start of bitmap
;               dwSrcBpp        bits per pixel of src (8, 15, 16, or 32)
;               dwSrcPitch      width of bytes of bitmap
;               dwSrcLeft       left edge coord of rectangle to transfer
;               dwSrcTop        top edge coord of rectangle to transfer
;               dwExtX          width in pixels of rectangle to transfer
;               dwExtY          height in scanlines of rectangle to transfer
;
; Returns:      This routine is not failable. If you wish to fail the
;               sequence, you must fail at HW_BeginSrcVramDstSystem time.
;
;               ecx     CTX offset of where rectangle was transferred
;
; Preserve:     ds,es,ebx
;==============================================================================
DECPROC HW_BlockSrcVramDstSystem, PASCAL, FRAME, NEAR
PARMD   pHWBoardCXOffset
PARMD   dwSrcBase
PARMD   dwSrcBpp
PARMD   dwSrcPitch
PARMD   dwSrcLeft
PARMD   dwSrcTop
PARMD   dwExtX
PARMD   dwExtY
OPENPROC
        ; Load the push buffer ptr
        mov     esi,pHWBoardCXOffset
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset

        CHECKDMASPACE ds,esi,edi,24H
        mov     eax,CHNRUN(MemoryToMemoryFormat0.dwOffsetIn,8)
        sub     edx,edx
        or      ebx,ebx
        je      @F
        mov     eax,CHNRUN(MemoryToMemoryFormat1.dwOffsetIn,8)
        mov     edx,CACHEABLE_BUFFER_SIZE / 2
@@:     mov     ds:[edi + 00H],eax
        mov     ecx,dwSrcTop
        imul    ecx,dwSrcPitch
        mov     eax,dwSrcBpp
        inc     eax
        shr     eax,3
        imul    eax,dwSrcLeft
        add     eax,ecx
        add     eax,dwSrcBase
        mov     ds:[edi + 04H],eax
        mov     ds:[edi + 08H],edx
        mov     eax,dwSrcPitch
        mov     ecx,dwSrcBpp
        inc     ecx
        shr     ecx,3
        imul    ecx,dwExtX
        lea     edx,[ecx + 3]
        and     edx,NOT 3
        mov     ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],edx
        mov     eax,dwExtY
        mov     ds:[edi + 14H],ecx
        mov     ds:[edi + 18H],eax
        mov     eax,101H
        sub     ecx,ecx
        mov     ds:[edi + 1CH],eax
        mov     ds:[edi + 20H],ecx
        add     edi,24H
        lea     eax,ds:[esi].HWBOARDCX.sVramToSysramBufferNotifier0.status
        lea     ecx,[esi].HWBOARDCX.bCacheableDmaBuffer
        or      ebx,ebx
        je      @F
        lea     eax,ds:[esi].HWBOARDCX.sVramToSysramBufferNotifier1.status
        add     ecx,CACHEABLE_BUFFER_SIZE / 2
@@:     SETDMASTATUS <word ptr ds:[eax]>
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     HW_WaitSrcVramDstSystem
;
; Purpose:      This function is an easy way to implement Blts where
;               the src is in vram and the dst is in system memory.
;               It is one of a sequence. For full details, please see
;               HW_BeginSrcVramDstSystem eariler in this file.
;
;               This routine must wait until the DMA transfer on the
;               specified transfer region is complete.
;
; Arguments:
;               ds              CXSel
;               edx             HWBOARDCX
;               ebx             0 or 1 -- which transfer area to wait for
;
; Returns:      This routine is not failable. If you wish to fail the
;               sequence, you must fail at HW_BeginSrcVramDstSystem time.
;
; Preserve:     ds,es,ebx
;==============================================================================
DECPROC HW_WaitSrcVramDstSystem, PASCAL, NOFRAME, NEAR
OPENPROC
        lea     eax,ds:[edx].HWBOARDCX.sVramToSysramBufferNotifier0.status
        or      ebx,ebx
        je      @F
        lea     eax,ds:[edx].HWBOARDCX.sVramToSysramBufferNotifier1.status
@@:     WAITDMASTATUS <word ptr ds:[eax]>
CLOSEPROC


;==============================================================================
;
; Function:     HW_EndSrcVramDstSystem
;
; Purpose:      This function is an easy way to implement Blts where
;               the src is in vram and the dst is in system memory.
;               It is one of a sequence. For full details, please see
;               HW_BeginSrcVramDstSystem eariler in this file.
;
; Arguments:
;               ds              CXSel
;               edx             HWBOARDCX
;
; Returns:      This routine is not failable. If you wish to fail the
;               sequence, you must fail at HW_BeginSrcVramDstSystem time.
;
; Preserve:     Nothing
;==============================================================================
DECPROC HW_EndSrcVramDstSystem, PASCAL, NOFRAME, NEAR
OPENPROC
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\HWVRMBLT.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         hwvrmblt.asm
;
; Purpose:      This file performs BitBlts involving a source when the
;               source and dst are both in video memory. The blt may
;               also involve a pattern but it does not have to.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     HW_BitBltSrcVramDstVram
;
; Purpose:      This function implements Bitblts that involve a source,
;               and both the source and dst are in video memory. There
;               may also be a pattern involved inthe rop, but there may
;               not be.
;
; Arguments:
;               ds                      CXSel
;               pHWLogdevCXOffset       GWLOGDEVCX ptr
;               lpDstDev                ptr to dst device (DIBENGINE format)
;               lpSrcDev                ptr to src device (DIBENGINE format)
;               lpBrush                 ptr to DIB_Brush
;               lpDrawMode              ptr to DRAWMODE
;               wDstX                   dst left edge coord
;               wDstY                   dst top  edge coord
;               wSrcX                   src left edge coord
;               wSrcY                   src top  edge coord
;               wExtX                   width of blt rectangle
;               wExtY                   height of blt rectangle
;               dwRop3                  rop in standard Microsoft format
;               dwRopFlags              one of: NOROP, OND, PAD, SAD, PSD
;                                       which are defined in gngdi.inc
;
; Returns:
;               If you want to
;               report this     then do this
;               Success         eax should be set to a number > 0
;               Failure         eax should be set equal to 0
;               Punt to DIBENG  eax should be set to a number < 0
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC HW_BitBltSrcVramDstVram, PASCAL, FRAME, NEAR
PARMD   pHWLogdevCXOffset
PARMD   lpDstDev
PARMD   lpSrcDev
PARMD   lpBrush
PARMD   lpDrawMode
PARMW   wDstX
PARMW   wDstY
PARMW   wSrcX
PARMW   wSrcY
PARMW   wExtX
PARMW   wExtY
PARMD   dwRop3
OPENPROC
        PUSHR   esi,edi

        ; Load the board ptr
        mov     esi,pHWLogdevCXOffset
        push    ds:[esi].HWLOGDEVCX.dwPatternAlpha1
        push    ds:[esi].HWLOGDEVCX.dwPatternAlpha0

        mov     esi,ds:[esi].HWLOGDEVCX.pHWBoardCX

        WAIT_UNTIL_OTHER_CONTEXTS_IDLE ds,esi,eax

        ; Load the push buffer ptr
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        sub     ecx,ecx

        ; Set the src base and pitch if need be
        sub     edx,edx
        les     dx,lpSrcDev
        mov     eax,es:[edx].DIBENGINEHDR.deBitsOffset
        cmp     eax,ds:[esi].HWBOARDCX.dwContextSurface2dSrcOffset
        je      Skip
        mov     ds:[esi].HWBOARDCX.dwContextSurface2dSrcOffset,eax
        mov     eax,es:[edx].DIBENGINEHDR.deDeltaScan
        mov     word ptr ds:[esi].HWBOARDCX.dwContextSurface2dDstSrcPitch,ax
        mov     ecx,1
Skip:
        ; Set the dst base and pitch if need be
        sub     edx,edx
        les     dx,lpDstDev
        mov     eax,es:[edx].DIBENGINEHDR.deBitsOffset
        cmp     eax,ds:[esi].HWBOARDCX.dwContextSurface2dDstOffset
        je      Skip1
        mov     ds:[esi].HWBOARDCX.dwContextSurface2dDstOffset,eax
        mov     eax,es:[edx].DIBENGINEHDR.deDeltaScan
        mov     word ptr ds:[esi].HWBOARDCX.dwContextSurface2dDstSrcPitch+2,ax
        mov     ecx,1
Skip1:
        or      ecx,ecx
        je      @F
        movzx   eax,word ptr ds:[esi].HWBOARDCX.dwContextSurface2dDstSrcPitch+2
        push    esi
        push    ds:[esi].HWBOARDCX.dwContextSurface2dDstOffset
        push    eax
        call    SetDstBaseAndPitchToDsEdi
@@:
        ; Now fire off the blt
        CHECKDMASPACE ds,esi,edi,24H
        mov     dword ptr ds:[edi + 00H],CHNRUN(ContextPattern.SetMonochromeColor0,2)
        pop     dword ptr ds:[edi + 04H]
        pop     dword ptr ds:[edi + 08H]
        mov     eax,CHNRUN(ContextRop.SetRop5,1)
        movzx   ebx,byte ptr [dwRop3 + 2]
        mov     ds:[edi + 0CH],eax
        mov     ds:[edi + 10H],ebx
        mov     eax,CHNRUN(ImageBlit.ControlPointIn,3)
        mov     ebx,dword ptr wSrcY
        ror     ebx,10H
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ebx
        mov     eax,dword ptr wDstY
        mov     ebx,dword ptr wExtY
        ror     eax,10H
        ror     ebx,10H
        mov     ds:[edi + 1CH],eax
        mov     ds:[edi + 20H],ebx
        add     edi,24H
        SETPUTPTR ds,esi,edi

        mov     eax,1
        POPR    esi,edi
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\MISC.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         misc.asm
;
; Purpose:      This file holds a few miscellaneous run-time functions.
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include nvcm.inc
include nvos.inc
include nvmisc.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc

IFDEF   DEBUG
PLACE_DST_BITMAP_IN_SCREEN_CORNER       TEXTEQU <1>
ELSE
PLACE_DST_BITMAP_IN_SCREEN_CORNER       TEXTEQU <0>
ENDIF

IF  (PLACE_DST_BITMAP_IN_SCREEN_CORNER NE 0)
PANIT   MACRO   dBase,dPitch
        LOCAL   skip

        cmp     cs:[dwAlignOffscreenBitmap],0
        je      skip
        push    edx
        push    ecx
        mov     edx,dBase
        mov     ecx,dPitch
        call    AlignOffscreenBitmap
        pop     ecx
        pop     edx
skip:
ENDM
ELSE
PANIT   MACRO   dBase,dPitch
ENDM
ENDIF

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

IF  (PLACE_DST_BITMAP_IN_SCREEN_CORNER NE 0)
PUBLIC  dwAlignOffscreenBitmap
dwAlignOffscreenBitmap  DD      0
ENDIF

; This is a HACK! Because some of the objects don't use their own
; SetColorFormat field, but instead use what is in the their embedded
; CONTEXT_SURFACES_2D object, we have to reset the ColorFormat for the
; CONTEXT_SURFACES_2D every time! Unh. The color format is dependent
; upon the logical device. If we have to pass all this information
; into the SetSrcBaseAndPitchToXX routines, the caller gets tongue-
; tied with all the parameters and values to pass. The driver loads
; once for each logical device, so we just remember the correct
; ColorFormat Value here in the code segment. This vairable must
; be updated on modesets to this logical device.
PUBLIC  dwContextSurface2DColorFormat
dwContextSurface2DColorFormat   DD      NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8

;==============================================================================
;
; Function:     SetDstBaseAndPitchToDsEdi
;
; Purpose:      This function sets the dst base and pitch in the
;               ContextSurfaces2d object to the values passed in.
;
; Arguments:
;               ds      Context Selector
;               edi     push buffer ptr
;
; Returns:      None
;
; Preserve:     all registers except edi should be adjusted as
;               appropriate to place some commands in the buffer
;==============================================================================
DECPROC SetDstBaseAndPitchToDsEdi, PASCAL, FRAME, NEAR
PARMD   pHWBoardCXOffset
PARMD   dwDstBase
PARMD   dwDstPitch
OPENPROC
        PUSHR   eax,esi
        mov     esi,pHWBoardCXOffset
        CHECKDMASPACE ds,esi,edi,14H
        mov     eax,cs:[dwContextSurface2DColorFormat]
        mov     dword ptr ds:[edi + 00H],CHNRUN(ContextSurfaces2d.SetColorFormat,4)
        mov     ds:[edi + 04H],eax
        mov     eax,dwDstPitch
        shl     eax,10H
        mov     ax,word ptr ds:[esi].HWBOARDCX.dwContextSurface2dDstSrcPitch
        mov     ds:[edi + 08H],eax
        mov     ds:[esi].HWBOARDCX.dwContextSurface2dDstSrcPitch,eax
        mov     eax,ds:[esi].HWBOARDCX.dwContextSurface2dSrcOffset
        mov     ds:[edi + 0CH],eax
        mov     eax,dwDstBase
        mov     ds:[edi + 10H],eax
        mov     ds:[esi].HWBOARDCX.dwContextSurface2dDstOffset,eax
        add     edi,14H
        PANIT   dwDstBase,dwDstPitch
        POPR    eax,esi
CLOSEPROC


;==============================================================================
;
; Function:     SetDstBaseAndPitchToEsEdi
;
; Purpose:      This function sets the dst base and pitch in the
;               ContextSurfaces2d object to the values passed in.
;
; Arguments:
;               es      Context Selector
;               edi     push buffer ptr
;
; Returns:      None
;
; Preserve:     all registers except edi should be adjusted as
;               appropriate to place some commands in the buffer
;==============================================================================
DECPROC SetDstBaseAndPitchToEsEdi, PASCAL, FRAME, NEAR
PARMD   pHWBoardCXOffset
PARMD   dwDstBase
PARMD   dwDstPitch
OPENPROC
        PUSHR   eax,esi
        mov     esi,pHWBoardCXOffset
        CHECKDMASPACE es,esi,edi,14H
        mov     eax,cs:[dwContextSurface2DColorFormat]
        mov     dword ptr es:[edi + 00H],CHNRUN(ContextSurfaces2d.SetColorFormat,4)
        mov     es:[edi + 04H],eax
        mov     eax,dwDstPitch
        shl     eax,10H
        mov     ax,word ptr es:[esi].HWBOARDCX.dwContextSurface2dDstSrcPitch
        mov     es:[edi + 08H],eax
        mov     es:[esi].HWBOARDCX.dwContextSurface2dDstSrcPitch,eax
        mov     eax,es:[esi].HWBOARDCX.dwContextSurface2dSrcOffset
        mov     es:[edi + 0CH],eax
        mov     eax,dwDstBase
        mov     es:[edi + 10H],eax
        mov     es:[esi].HWBOARDCX.dwContextSurface2dDstOffset,eax
        add     edi,14H
        PANIT   dwDstBase,dwDstPitch
        POPR    eax,esi
CLOSEPROC


;==============================================================================
;
; Function:     WaitUntilOtherContextsIdle
;
; Purpose:      This function will wait until any other graphics
;               contexts DMA pushers are idle.
;
; Arguments:
;               None
;
; Returns:      None
;
; Preserve:     All registers
;==============================================================================
NV4_PFIFO_DMA					EQU	00002508H
NV4_PFIFO_CACHE1_PUSH1                          EQU   	00003204H
NV4_PFIFO_CACHE1_DMA_PUSH                       EQU   	00003220H
NV4_PFIFO_CACHE1_DMA_PUSH_BUFFER_EMPTY          EQU   	00000100H
NV_PFIFO_CACHE1_PUSH1_MODE_DMA                  EQU   	00000100H
FIFO_CACHE1_STATUS				EQU	00003214H
CACHE1_STATUS_LOW_MARK_EMPTY			EQU	10H
GRAPHICS_STATUS					EQU	00400700H

EXTERNDEF       wFlatDataSel:WORD

DECPROC WaitUntilOtherContextsIdle, PASCAL, FRAME, NEAR
PARMD   pHWBoardCXOffset
OPENPROC
        PUSHR   eax,esi,edi,ds
        mov     ds,cs:[wFlatDataSel]
        mov     esi,pHWBoardCXOffset
        mov     edi,ds:[esi].HWBOARDCX.pChipRegs

busyp:  mov     eax,ds:[edi + NV4_PFIFO_DMA]
        and     eax,ds:[esi].HWBOARDCX.dwGdiPushBufferMask
        jnz     busyp

        mov     eax,ds:[edi + NV4_PFIFO_CACHE1_PUSH1]
        test    eax,NV_PFIFO_CACHE1_PUSH1_MODE_DMA
        jz      syncd
        and     eax,1FH
        cmp     eax,ds:[esi].HWBOARDCX.dwGdiPushBufferIndex
        je      syncd

emptyp: mov     eax,ds:[edi + NV4_PFIFO_CACHE1_DMA_PUSH]
        and     eax,NV4_PFIFO_CACHE1_DMA_PUSH_BUFFER_EMPTY
        jz      emptyp

syncd:
	;
	mov	eax,ds:[edi + FIFO_CACHE1_STATUS]
	and	eax,CACHE1_STATUS_LOW_MARK_EMPTY
	je	syncd
@@:
	; sync on graphics engine not idle
	mov	eax,ds:[edi + GRAPHICS_STATUS]
	and	eax,1
	jne	@B

        POPR    eax,esi,edi,ds
CLOSEPROC


;==============================================================================
;
; Function:     FlushChipsetCache
;
; Purpose:      This function does some things to help motherboard
;               chipsets get their cache coherency correct.
;
; Arguments:    None
;
; Returns:      None
;
; Preserve:     All registers
;==============================================================================
DECPROC FlushChipsetCache, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   eax,edx
        mov     edx,3D0H
        xor     eax,eax
        out     dx,al
        POPR    eax,edx
CLOSEPROC


;==============================================================================
;
; Function:     WaitForDmaBufferSpace
;
; Purpose:      This function is called when there are not enough
;               bytes left in the DMA buffer to place a command.
;               Note that this does not necessarily mean that you
;               have reached the end of the DMA buffer, although
;               that is one possibility. It might mean that if you
;               write more commands, you will write over data that
;               the DMA has not yet fetched. In either case, though,
;               waiting of some type is required, and this routine
;               can handle it.
;
; Arguments:
;               HWBOARDCX.pCurrentPushBufferOffset must be up to date.
;
; Returns:      The PDEVICE.HWPDevice.dwCurrentPushBufferOffset
;               field has been modified to the new place to put
;               DMA commands. Also the PDEVICE.HWPDevice.dwBytesFree
;               member has been modified to reflect the new amount
;               of space. You are guaranteed that the new DMA
;               offset can hold at least the amount of bytes you
;               requested as the argument to this routine.
;
; Preserve:     All registers should be preserved
;==============================================================================
DECPROC WaitForDmaBufferSpace, PASCAL, FRAME, NEAR
PARMD   pHWBoardCXOffset
PARMD   dwBytesNeeded
OPENPROC
        PUSHR   ds,alld
        mov     ds,cs:[wFlatDataSel]
        mov     esi,pHWBoardCXOffset
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        SETPUTPTR ds,esi,edi

IFDEF   DEBUG
        mov     ds:[esi].HWBOARDCX.dwPushBufferOffsetOnWaitEnter,edi
        mov     eax,dwBytesNeeded
        mov     ds:[esi].HWBOARDCX.dwLastByteRequest,eax
ENDIF

        ; First, regardless of where the GET ptr is, is there enough
        ; space between the PUT ptr and the end of the DMA buffer?
        mov     ecx,dwBytesNeeded
        add     ecx,04H
        mov     ebx,ds:[esi].HWBOARDCX.pPushBufferStartOffset
        add     ebx,ds:[esi].HWBOARDCX.dwPushBufferLength
        sub     ebx,edi
        cmp     ebx,ecx
        jl      WrapPut

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; If we get here, the DMA push buffer looks as follows:
        ;
        ;                          >= dwBytesNeeded + 4
        ;                |--------------------------------------------|
        ;
        ;               PUT
        ;                |
        ;                v
        ; |-----------------------------------------------------------|
        ;
        ; In this case, we need to read the GET ptr and see where it is.
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

WaitWhileGetGTPut:
        mov     eax,ds:[esi].HWBOARDCX.dwDmaGetPtr
        add     eax,ds:[esi].HWBOARDCX.pPushBufferContextStartOffset
        mov     ds:[esi].HWBOARDCX.dwLastGet,eax
        cmp     eax,edi
        jbe     GetLEPut

GetGTPut:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; GET is greater than PUT as shown in the diagram below. We
        ; might need to wait a bit until GET is enough greater than
        ; PUT to allow for the bytes needed plus maybe a JMP command.
        ;
        ;                          >= dwBytesNeeded + 4
        ;                |--------------------------------------------|
        ;
        ;                          ??????
        ;                |-----------------------|
        ;
        ;               PUT                     GET
        ;                |                       |
        ;                v                       v
        ; |-----------------------------------------------------------|
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ; Wait until GET - PUT is at least dwBytesNeeded + 4
        sub     eax,edi
        sub     eax,ecx
        jc      WaitWhileGetGTPut

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; GET is enough greater than PUT as shown in the diagram below
        ; that we can grant the space needed.
        ;
        ;                  >= dwBytesNeeded + 4
        ;                |-----------------------|
        ;
        ;               PUT                     GET
        ;                |                       |
        ;                v                       v
        ; |-----------------------------------------------------------|
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        mov     ds:[esi].HWBOARDCX.dwBytesFree,eax

IFDEF DEBUG
        mov     ds:[esi].HWBOARDCX.dwLastWaitPath,1
        mov     ds:[esi].HWBOARDCX.dwLastBytesFree,eax
        PUSHR   eax,edi
        mov     eax,ds:[esi].HWBOARDCX.dwBytesFree
        add     edi,ecx
        sub     edi,4
        add     eax,edi
        mov     ds:[esi].HWBOARDCX.dwTempEnd,eax
        POPR    eax,edi
ENDIF
        jmp     Done

GetLEPut:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; The GET is less than the PUT which gives the sceanrio shown
        ; below. We already know that there is enough room from PUT
        ; to the end of the DMA buffer, so grant the request.
        ;
        ;                               >= dwBytesNeeded + 4
        ;                        |------------------------------------|
        ;
        ;          GET          PUT
        ;           |            |
        ;           v            v
        ; |-----------------------------------------------------------|
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        mov     eax,ds:[esi].HWBOARDCX.pPushBufferStartOffset
        add     eax,ds:[esi].HWBOARDCX.dwPushBufferLength
        sub     eax,edi
        sub     eax,ecx
        mov     ds:[esi].HWBOARDCX.dwBytesFree,eax

IFDEF DEBUG
        mov     ds:[esi].HWBOARDCX.dwLastWaitPath,2
        mov     ds:[esi].HWBOARDCX.dwLastBytesFree,eax
        PUSHR   eax,edi
        mov     eax,ds:[esi].HWBOARDCX.dwBytesFree
        add     edi,ecx
        sub     edi,4
        add     eax,edi
        mov     ds:[esi].HWBOARDCX.dwTempEnd,eax
        POPR    eax,edi
ENDIF
        jmp     Done

WrapPut:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; If we get here, there are not enough bytes from PUT to the end
        ; of the DMA buffer to hold the number of bytes needed as the
        ; diagram below shows. In this case, we must wait until the GET
        ; ptr goes less than or equal to the PUT ptr.
        ;
        ;                                    < dwBytesRequested + 4
        ;                                |----------------------------|
        ;
        ;                               PUT
        ;                                |
        ;                                v
        ; |-----------------------------------------------------------|
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Loopy:  mov     eax,ds:[esi].HWBOARDCX.dwDmaGetPtr
        add     eax,ds:[esi].HWBOARDCX.pPushBufferContextStartOffset
        mov     ds:[esi].HWBOARDCX.dwLastGet,eax
        cmp     eax,edi
        ja      WaitWithBusFree
        lea     edx,[esi].HWBOARDCX.bDmaPushBuffer
        cmp     eax,edx
        ja      GetLEPutWrapPut

WaitWithBusFree:
        mov     edx,100H
@@:     dec     edx
        jne     @B
        jmp     Loopy


GetLEPutWrapPut:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; Having waited, the situation appears as shown. Now we can place
        ; a JMP command in the DMA buffer at the current PUT ptr to jmp
        ; back to the start of the buffer.
        ;
        ;                            < dwBytesRequested + 4
        ;                        |------------------------------------|
        ;
        ;         GET           PUT
        ;          |             |
        ;  X       v             v
        ; |-----------------------------------------------------------|
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        mov     ebx,edi
        lea     edi,[esi].HWBOARDCX.bDmaPushBuffer
        mov	eax,edi
        sub     eax,ds:[esi].HWBOARDCX.pPushBufferContextStartOffset
        add     eax,JMP_COMMAND
        mov     dword ptr ds:[ebx],eax
        SETPUTPTR ds,esi,edi

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; After the JMP_COMMAND takes effect (it might be a little bit),
        ; eventually the scenario will be as shown. At this point, all
        ; we need to do is wait until either GET = PUT (which may happen
        ; if the GET reaches the JMP_COMMAND and executes it), OR until
        ; GET is at least dwBytesNeeded from the start of the DMA buffer.
        ;
        ;    dwBytesRequested + 4
        ; |-------------------------|
        ;
        ; PUT           GET
        ;  |             |
        ;  v             v
        ; |-----------------------------------------------------------|
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@@:
        mov     eax,ds:[esi].HWBOARDCX.dwDmaGetPtr
        add     eax,ds:[esi].HWBOARDCX.pPushBufferContextStartOffset
        mov     ds:[esi].HWBOARDCX.dwLastGet,eax
        sub     eax,edi
        je      DmaIsIdle
        sub     eax,ecx
        jc      @B

        ; Now there are two things that could happen.
        ; 1) GET will become equal to PUT -- this will happen if the
        ;    GET command reaches the jmp and and takes the jmp. It
        ;    will then stop because it has reached PUT (which is
        ;    set to the beginning of the buffer).
        ; 2) GET - OFFSET dwDmaPushBufferStart > dwBytesRequested + 4
        ;    This will happen if GET is still fetching data, but
        ;    it has now fetched enough from the beginning of the
        ;    buffer that there is room to put the requested command in.

        ; The DMA is not idle, but there is enough room to place
        ; dwBytesNeeded between the buffer start and the GET ptr.
        mov     ds:[esi].HWBOARDCX.dwBytesFree,eax

IFDEF DEBUG
        mov     ds:[esi].HWBOARDCX.dwLastWaitPath,3
        mov     ds:[esi].HWBOARDCX.dwLastBytesFree,eax
        PUSHR   eax,edi
        mov     eax,ds:[esi].HWBOARDCX.dwBytesFree
        add     edi,ecx
        sub     edi,4
        add     eax,edi
        mov     ds:[esi].HWBOARDCX.dwTempEnd,eax
        POPR    eax,edi
ENDIF
        jmp     Done

DmaIsIdle:
        mov     eax,ds:[esi].HWBOARDCX.dwPushBufferLength
        sub     eax,ecx
        mov     ds:[esi].HWBOARDCX.dwBytesFree,eax

IFDEF DEBUG
        mov     ds:[esi].HWBOARDCX.dwLastWaitPath,4
        mov     ds:[esi].HWBOARDCX.dwLastBytesFree,eax
        PUSHR   eax,edi
        mov     eax,ds:[esi].HWBOARDCX.dwBytesFree
        add     edi,ecx
        sub     edi,4
        add     eax,edi
        mov     ds:[esi].HWBOARDCX.dwTempEnd,eax
        POPR    eax,edi
ENDIF

Done:
        POPR    ds,alld
CLOSEPROC


IF  (PLACE_DST_BITMAP_IN_SCREEN_CORNER NE 0)
;==============================================================================
;
; Function:     AlignOffscreenBitmap
;
; Purpose:      This function can be used for debugging. It is usually
;               used by the SetDstBaseAndPitch functions to center the
;               current bitmap in the uppoer left had corner of the
;               screen. The CRT start address and pitch registers are
;               adjusted to make the offscreen bitmap visible and
;               readable.
;
; Arguments:    edx     Base address
;               ecx     pitch
;		esi	HWBOARDCX ptr
;
; Returns:      None.
;
; Preserve:     Everything
;==============================================================================
EXTERNDEF	wFlatDataSel:WORD

PUBLIC  AlignOffscreenBitmap
AlignOffscreenBitmap    PROC    NEAR

        PUSHR   alld,ds
        mov	ds,cs:[wFlatDataSel]

        mov	edi,ds:[esi].HWBOARDCX.pChipRegs
	shr	ecx,3

	; Set the base address
	mov	ds:[edi + 600800H],edx

        ; Unlock the registers
        mov     dx,3D4H
        mov     al,1FH
        out     dx,al
        inc     dx
        in      al,dx
        mov     ah,al
        mov     al,57H
        out     dx,al

        ; The CRT pitch registers are from low to high 13H and
        ; the top 3 bits of 19H.
        mov     dx,3D4H
        mov     al,13H
        out     dx,al
        inc     dx
        mov     al,cl
        out     dx,al

        dec     dx
        mov     al,19H
        out     dx,al
        inc     dx
        in      al,dx
        and     al,1FH
        mov	ah,ch
        and     ah,7H
        shl     ah,5
        or      al,ah
        out     dx,al

        dec     dx
        mov     al,25H
        out     dx,al
        inc     dx
        in      al,dx
        and     al,0DFH
        mov	ah,ch
        and	ah,08H
        shl     ah,5 - 3
        or      al,ah
        out     dx,al

        POPR    alld,ds
        ret

AlignOffscreenBitmap    ENDP
ENDIF

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\OBJECTS.ASM ===
;==============================================================================
;
; Copyright (C) 1998, NVidia Coporation
;
; File:         objects.asm
;
; Purpose:      This file creates and destroys objects that are global
;               to the BOARD.
;
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwboard.inc
include hwcrtc.inc
include ..\..\..\..\..\sdk\nvidia\inc\nvrmarch.inc

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

;==============================================================================
;
; Function:     NV_CreateDmaContexts
;
; Purpose:      This function creates all the DMA contexts we will need
;               for the WIN CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_CreateDmaContexts, PASCAL, NOFRAME, FAR32
OPENPROC
        ; We only create these once -
        ; they are never destroyed untl the driver unloads.
        call    CreatePushBufferNotifier
        call    CreateVramToSysramNotifier0
        call    CreateVramToSysramNotifier1
        call    CreateSysramToVideoNotifier
        call    CreateDmaFromSysram
        call    CreateDmaToSysram
        call    CreateDmaFromVram
        call    CreateDmaInVram
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_CreateObjects
;
; Purpose:      This function creates all the objects we will need
;               for the WIN CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_CreateObjects, PASCAL, NOFRAME, FAR32
OPENPROC
        ; I don't want to have to wait for space anywhere in the
        ; object creation routines. Just wait for 4K bytes. That
        ; will be enough to hold the whole creation process.
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        CHECKDMASPACE ds,esi,edi,1000H

        ; Create all the objects we will need.
        call    CreateContextSurfaces2D
        call    CreateVramToSysramCopy0
        call    CreateVramToSysramCopy1
        call    CreateContextClipRect
        call    CreateContextPattern
        call    CreateContextRop
        call    CreateImageBlit
        call    CreateRectAndText
        call    CreateImageFromCpu
        call    CreateSolidLine
        call    CreateIndexedImageFromCpu
	call	CreateStretchedImageFromCpu

        ; I want to track the byte usage in the DMA buffer accurately,
        ; but I didn't wait for the exact number of dwords needed for
        ; the object creations above. Let's stick a JMP_COMMAND in the
        ; DMA buffer to get back to the beginning and then wait until
        ; the DMA pusher goes idle. Then we can reset all our variables
        ; to indicate the whole buffer is free and start out fresh.
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset

        lea     eax,[esi].HWBOARDCX.bDmaPushBuffer
        mov     ecx,eax
        sub     ecx,ds:[esi].HWBOARDCX.pPushBufferContextStartOffset
        or      ecx,JMP_COMMAND
        mov     ds:[edi],ecx
        xor     ecx,JMP_COMMAND
        SETPUTPTR ds,esi,eax
@@:
        cmp     ds:[esi].HWBOARDCX.dwDmaGetPtr,ecx
        jne     @B

        ; Now set the number of bytes free
        mov     ds:[esi].HWBOARDCX.dwBytesFree,DMA_PUSH_BUFFER_SIZE - WRITE_COMBINE_PAD_SIZE - 10h
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     CreatePushBufferNotifier
;
; Purpose:      This function creates the main push buffer notifier
;               for the WIN CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreatePushBufferNotifier, PASCAL, NOFRAME, NEAR
OPENPROC
        push    esi
        pushd   OBJ_DMA_PUSH_BUFFER_NOTIFIER
        lea     ebx,[esi].HWBOARDCX.sPushBufferNotifier
        push    ebx
        push    ds
        pushd   SIZE NvNotification
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY
        call    NV_AllocContextDma
CLOSEPROC


;==============================================================================
;
; Function:     CreateVramToSysramNotifier0
;
; Purpose:      This function creates a context DMA which is to
;               be used as the notifier for a video memory to
;               system memory MemoryToMemoryFormat copy in
;               the WIN CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateVramToSysramNotifier0, PASCAL, NOFRAME, NEAR
OPENPROC
        push    esi
        pushd   OBJ_VRAM_TO_SYSRAM_NOTIFIER0
        lea     ebx,[esi].HWBOARDCX.sVramToSysramMethodNotifier0
        push    ebx
        push    ds
        pushd   2 * (SIZE NvNotification)
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY
        call    NV_AllocContextDma
CLOSEPROC


;==============================================================================
;
; Function:     CreateVramToSysramNotifier1
;
; Purpose:      This function creates a context DMA which is to
;               be used as the notifier for a video memory to
;               system memory MemoryToMemoryFormat copy in
;               the WIN CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateVramToSysramNotifier1, PASCAL, NOFRAME, NEAR
OPENPROC
        push    esi
        pushd   OBJ_VRAM_TO_SYSRAM_NOTIFIER1
        lea     ebx,[esi].HWBOARDCX.sVramToSysramMethodNotifier1
        push    ebx
        push    ds
        pushd   2 * (SIZE NvNotification)
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY
        call    NV_AllocContextDma
CLOSEPROC


;==============================================================================
;
; Function:     CreateSysramToVideoNotifier
;
; Purpose:      This function creates a context DMA to be used as a
;               notifier for a system memory to video (Color Look Up
;               Table stuff) NV_VIDEO_FROM_MEMORY object in the
;               WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateSysramToVideoNotifier, PASCAL, NOFRAME, NEAR
OPENPROC
        push    esi
        pushd   OBJ_SYSRAM_TO_VIDEO_NOTIFIER
        lea     ebx,[esi].HWBOARDCX.sSysramToVideoBufferNotifier
        push    ebx
        push    ds
        pushd   5 * (SIZE NvNotification)
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY
        call    NV_AllocContextDma
CLOSEPROC


;==============================================================================
;
; Function:     CreateDmaToSysram
;
; Purpose:      This function creates a context DMA for system memory
;               to be used as the destination in a MemoryToMemoryFormat
;               copy in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateDmaToSysram, PASCAL, NOFRAME, NEAR
OPENPROC
        push    esi
        pushd   OBJ_DMA_TO_SYSRAM
        lea     ebx,[esi].HWBOARDCX.bCacheableDmaBuffer
        push    ebx
        push    ds
        pushd   (CACHEABLE_BUFFER_SIZE + 0FFFH) AND 0FFFFF000H
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_WRITE_ONLY
        call    NV_AllocContextDma
CLOSEPROC


;==============================================================================
;
; Function:     CreateDmaFromSysram
;
; Purpose:      This function creates a context DMA for system memory
;               to be used as the source in a MemoryToMemoryFormat
;               copy in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateDmaFromSysram, PASCAL, NOFRAME, NEAR
OPENPROC
        push    esi
        pushd   OBJ_DMA_FROM_SYSRAM
        lea     ebx,[esi].HWBOARDCX.bCacheableDmaBuffer
        push    ebx
        push    ds
        pushd   (CACHEABLE_BUFFER_SIZE + 0FFFH) AND 0FFFFF000H
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY
        call    NV_AllocContextDma
CLOSEPROC


;==============================================================================
;
; Function:     CreateDmaFromVram
;
; Purpose:      This function creates a context DMA for video memory
;               to be used as the source in objects in the WIN_CHANNEL.
;
; Purpose:      This function creates a context DMA from the push buffer.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateDmaFromVram, PASCAL, NOFRAME, NEAR
OPENPROC
        push    esi
        pushd   OBJ_DMA_FROM_VRAM
        pushd   0
        mov     ecx,ds:[esi].HWBOARDCX.dwVideoMemorySel
        push    ecx
        push    ds:[esi].HWBOARDCX.dwVideoMemorySize
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY
        call    NV_AllocContextDma
CLOSEPROC


;==============================================================================
;
; Function:     CreateDmaInVram
;
; Purpose:      This function creates a context DMA for video memory
;               to be used as a field for objects in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateDmaInVram, PASCAL, NOFRAME, NEAR
OPENPROC
        push    esi
        pushd   OBJ_DMA_IN_VRAM
        pushd   0
        mov     ecx,ds:[esi].HWBOARDCX.dwVideoMemorySel
        push    ecx
        push    ds:[esi].HWBOARDCX.dwVideoMemorySize
        pushd   ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR
        call    NV_AllocContextDma
CLOSEPROC


;==============================================================================
;
; Function:     CreateContextSurfaces2D
;
; Purpose:      This function creates a ContextSurfaces2D object
;               to be used in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateContextSurfaces2D, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        mov     eax,NV4_CONTEXT_SURFACES_2D
        cmp     ds:[esi].HWBOARDCX.dwDeviceVersion,NV_DEVICE_VERSION_10
        jl      @F
        mov     eax,NV10_CONTEXT_SURFACES_2D
@@:
        push    esi
        push    eax
        pushd   OBJ_CONTEXT_SURFACES_2D
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(ContextSurfaces2dHdr.object,1)
        mov     ebx,OBJ_CONTEXT_SURFACES_2D
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        mov     eax,CHNRUN(ContextSurfaces2d.SetColorFormat,1)
        mov     ds:[edi + 08H],eax
        mov     dword ptr ds:[edi + 0CH],NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8

        ; Program the non-volatile data
        mov     eax,CHNRUN(ContextSurfaces2d.SetContextDmaImageSource,2)
        mov     ecx,OBJ_DMA_IN_VRAM
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ecx
        mov     ds:[edi + 18H],ecx
        add     edi,1CH
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateVramToSysramCopy0
;
; Purpose:      This function creates a MemoryToMemoryFormat object
;               for copying from video memory to system memory. This
;               is one of the two that we will need.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateVramToSysramCopy0, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        push    esi
        pushd   NV03_MEMORY_TO_MEMORY_FORMAT
        pushd   OBJ_DMA_FROM_VRAM_TO_SYSRAM_0
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(MemoryToMemoryFormat0Hdr.object,1)
        mov     ebx,OBJ_DMA_FROM_VRAM_TO_SYSRAM_0
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(MemoryToMemoryFormat0.SetContextDmaNotifies,3)
        mov     ecx,OBJ_VRAM_TO_SYSRAM_NOTIFIER0
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ecx
        mov     eax,OBJ_DMA_FROM_VRAM
        mov     ecx,OBJ_DMA_TO_SYSRAM
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ecx
        add     edi,18H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateVramToSysramCopy1
;
; Purpose:      This function creates a MemoryToMemoryFormat object
;               for copying from video memory to system memory. This
;               is one of the two that we will need.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateVramToSysramCopy1, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        push    esi
        pushd   NV03_MEMORY_TO_MEMORY_FORMAT
        pushd   OBJ_DMA_FROM_VRAM_TO_SYSRAM_1
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(MemoryToMemoryFormat1Hdr.object,1)
        mov     ebx,OBJ_DMA_FROM_VRAM_TO_SYSRAM_1
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(MemoryToMemoryFormat1.SetContextDmaNotifies,3)
        mov     ecx,OBJ_VRAM_TO_SYSRAM_NOTIFIER1
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ecx
        mov     eax,OBJ_DMA_FROM_VRAM
        mov     ecx,OBJ_DMA_TO_SYSRAM
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ecx
        add     edi,18H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateContextClipRect
;
; Purpose:      This function creates a ContextClipRectangle object
;               for use as a global clip rectangle in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateContextClipRect, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        push    esi
        pushd   NV01_CONTEXT_CLIP_RECTANGLE
        pushd   OBJ_CONTEXT_CLIP_RECT
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(ContextClipRectHdr.object,1)
        mov     ebx,OBJ_CONTEXT_CLIP_RECT
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(ContextClipRect.SetContextDmaNotifies,1)
        mov     ebx,OBJ_DMA_PUSH_BUFFER_NOTIFIER
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx

        ; Default it to the largest possible clip area
        mov     eax,CHNRUN(ContextClipRect.SetPoint,2)
        sub     ebx,ebx
        mov     ecx,7FFF7FFFH
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ebx
        mov     ds:[edi + 18H],ecx
        add     edi,1CH
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateContextPattern
;
; Purpose:      This function creates an ContextPattern object
;               for use as a global pattern in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateContextPattern, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        push    esi
        pushd   NV04_CONTEXT_PATTERN
        pushd   OBJ_CONTEXT_PATTERN
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(ContextPatternHdr.object,1)
        mov     ebx,OBJ_CONTEXT_PATTERN
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        ; Doesn't matter what we set the color format and the
        mov     eax,CHNRUN(ContextPattern.SetColorFormat,6)
        mov     ds:[edi + 08H],eax
        mov     dword ptr ds:[edi + 0CH],NV044_SET_COLOR_FORMAT_LE_A8R8G8B8
        mov     ebx,NV044_SET_MONOCHROME_FORMAT_CGA6_M1
        mov     ds:[edi + 10H],ebx
        mov     eax,NV044_SET_MONOCHROME_SHAPE_8X_8Y
        mov     ebx,NV044_SET_PATTERN_SELECT_MONOCHROME
        mov     ecx,-1
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ebx
        mov     ds:[edi + 1CH],ecx
        mov     ds:[edi + 20H],ecx
        
        add     edi,24H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateContextRop
;
; Purpose:      This function creates a ContextRop object
;               for use as a global rop in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateContextRop, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        push    esi
        pushd   NV03_CONTEXT_ROP
        pushd   OBJ_CONTEXT_ROP
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(ContextRopHdr.object,1)
        mov     ebx,OBJ_CONTEXT_ROP
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx
        add     edi,08H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateImageBlit
;
; Purpose:      This function creates an ImageBlit object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateImageBlit, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        push    esi
        pushd   NV04_IMAGE_BLIT
        pushd   OBJ_IMAGE_BLIT
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(ImageBlitHdr.object,1)
        mov     ebx,OBJ_IMAGE_BLIT
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(ImageBlit.SetContextClipRectangle,3)
        mov     ebx,OBJ_CONTEXT_CLIP_RECT
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx
        mov     eax,OBJ_CONTEXT_PATTERN
        mov     ebx,OBJ_CONTEXT_ROP
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ebx
        mov     eax,CHNRUN(ImageBlit.SetContextSurfaces,1)
        mov     ebx,OBJ_CONTEXT_SURFACES_2D
        mov     ds:[edi + 18H],eax
        mov     ds:[edi + 1CH],ebx
        mov     eax,CHNRUN(ImageBlit.SetOperation,1)
        mov     ebx,NV05F_SET_OPERATION_ROP_AND
        mov     ds:[edi + 20H],eax
        mov     ds:[edi + 24H],ebx
        add     edi,28H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateRectAndText
;
; Purpose:      This function creates a GdiRectangleText object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateRectAndText, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        push    esi
        pushd   NV04_GDI_RECTANGLE_TEXT
        pushd   OBJ_RECT_AND_TEXT
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(RectAndTextHdr.object,1)
        mov     ebx,OBJ_RECT_AND_TEXT
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(RectAndText.SetContextDmaFonts,3)
        mov     ebx,OBJ_DMA_IN_VRAM
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx
        mov     eax,OBJ_CONTEXT_PATTERN
        mov     ebx,OBJ_CONTEXT_ROP
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ebx
        mov     eax,CHNRUN(RectAndText.SetContextSurface,1)
        mov     ebx,OBJ_CONTEXT_SURFACES_2D
        mov     ds:[edi + 18H],eax
        mov     ds:[edi + 1CH],ebx
        mov     eax,CHNRUN(RectAndText.SetOperation,2)
        mov     ebx,NV04A_SET_OPERATION_ROP_AND
        mov     ds:[edi + 20H],eax
        mov     ds:[edi + 24H],ebx
        mov     dword ptr ds:[edi + 28H],NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8
        add     edi,2CH
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateImageFromCpu
;
; Purpose:      This function creates an ImageFromCpu object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateImageFromCpu, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        push    esi
        pushd   NV04_IMAGE_FROM_CPU
        pushd   OBJ_IMAGE_FROM_CPU
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(ImageFromCpuHdr.object,1)
        mov     ebx,OBJ_IMAGE_FROM_CPU
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(ImageFromCpu.SetContextClipRectangle,3)
        mov     ebx,OBJ_CONTEXT_CLIP_RECT
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx
        mov     eax,OBJ_CONTEXT_PATTERN
        mov     ebx,OBJ_CONTEXT_ROP
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ebx
        mov     eax,CHNRUN(ImageFromCpu.SetContextSurface,1)
        mov     ebx,OBJ_CONTEXT_SURFACES_2D
        mov     ds:[edi + 18H],eax
        mov     ds:[edi + 1CH],ebx
        mov     eax,CHNRUN(ImageFromCpu.SetOperation,2)
        mov     ebx,NV061_SET_OPERATION_ROP_AND
        mov     ds:[edi + 20H],eax
        mov     ds:[edi + 24H],ebx
        mov     dword ptr ds:[edi + 28H],NV061_SET_COLOR_FORMAT_LE_X8R8G8B8
        add     edi,2CH
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateSolidLine
;
; Purpose:      This function creates a RenderSolidLin object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateSolidLine, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        push    esi
        pushd   NV04_RENDER_SOLID_LIN
        pushd   OBJ_SOLID_LINE
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(RenderSolidLinHdr.object,1)
        mov     ebx,OBJ_SOLID_LINE
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(RenderSolidLin.SetContextClipRectangle,3)
        mov     ebx,OBJ_CONTEXT_CLIP_RECT
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx
        mov     eax,OBJ_CONTEXT_PATTERN
        mov     ebx,OBJ_CONTEXT_ROP
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ebx
        mov     eax,CHNRUN(RenderSolidLin.SetContextSurface,1)
        mov     ebx,OBJ_CONTEXT_SURFACES_2D
        mov     ds:[edi + 18H],eax
        mov     ds:[edi + 1CH],ebx
        mov     eax,CHNRUN(RenderSolidLin.SetOperation,2)
        mov     ebx,NV05C_SET_OPERATION_ROP_AND
        mov     ds:[edi + 20H],eax
        mov     ds:[edi + 24H],ebx
        mov     dword ptr ds:[edi + 28H],NV05C_SET_COLOR_FORMAT_LE_X8R8G8B8
        add     edi,2CH
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateIndexedImageFromCpu
;
; Purpose:      This function creates an IndexedImageFromCpu object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateIndexedImageFromCpu, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        mov     eax,NV04_INDEXED_IMAGE_FROM_CPU
        cmp     ds:[esi].HWBOARDCX.dwDeviceVersion, NV_DEVICE_VERSION_5
        jl      @F
        mov     eax,NV05_INDEXED_IMAGE_FROM_CPU
@@:
        push    esi
        pushd   eax
        pushd   OBJ_INDEXED_IMAGE_FROM_CPU
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(IndexedImageFromCpuHdr.object,1)
        mov     ebx,OBJ_INDEXED_IMAGE_FROM_CPU
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(IndexedImageFromCpu.SetContextDmaLut,1)
        mov     ebx,OBJ_DMA_FROM_VRAM
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx
        mov     eax,CHNRUN(IndexedImageFromCpu.SetContextClipRectangle,3)
        mov     ebx,OBJ_CONTEXT_CLIP_RECT
        mov     ds:[edi + 10H],eax
        mov     ds:[edi + 14H],ebx
        mov     eax,OBJ_CONTEXT_PATTERN
        mov     ebx,OBJ_CONTEXT_ROP
        mov     ds:[edi + 18H],eax
        mov     ds:[edi + 1CH],ebx
        mov     eax,CHNRUN(IndexedImageFromCpu.SetContextSurface,1)
        mov     ebx,OBJ_CONTEXT_SURFACES_2D
        mov     ds:[edi + 20H],eax
        mov     ds:[edi + 24H],ebx
        mov     eax,CHNRUN(IndexedImageFromCpu.SetColorConversion,3)
        mov     ebx,NV060_SET_COLOR_CONVERSION_TRUNCATE
        mov     ecx,NV060_SET_OPERATION_ROP_AND
        mov     edx,NV060_SET_COLOR_FORMAT_LE_X8R8G8B8
        mov     ds:[edi + 28H],eax
        mov     ds:[edi + 2CH],ebx
        mov     ds:[edi + 30H],ecx
        mov     ds:[edi + 34H],edx
        add     edi,38H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     CreateStretchedImageFromCpu
;
; Purpose:      This function creates an StretchedImageFromCpu object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC CreateStretchedImageFromCpu, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Create the object
        push    esi
        pushd   NV04_STRETCHED_IMAGE_FROM_CPU
        pushd   OBJ_STRETCHED_IMAGE_FROM_CPU
        call    NV_AllocWinChannelObject

        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(StretchedImageFromCpuHdr.object,1)
        mov     ebx,OBJ_STRETCHED_IMAGE_FROM_CPU
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(StretchedImageFromCpu.SetContextPattern,2)
        mov     ebx,OBJ_CONTEXT_PATTERN
        mov     ecx,OBJ_CONTEXT_ROP
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx
        mov     ds:[edi + 10H],ecx
        mov     eax,CHNRUN(StretchedImageFromCpu.SetContextSurface,1)
        mov     ebx,OBJ_CONTEXT_SURFACES_2D
        mov     ds:[edi + 14H],eax
        mov     ds:[edi + 18H],ebx
        mov     eax,CHNRUN(StretchedImageFromCpu.SetOperation,2)
        mov     ebx,NV061_SET_OPERATION_ROP_AND
        mov     ds:[edi + 1CH],eax
        mov     ds:[edi + 20H],ebx
        mov     dword ptr ds:[edi + 24H],NV061_SET_COLOR_FORMAT_LE_X8R8G8B8
        add     edi,28H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocContextDma
;
; Purpose:      This function allocates an NV01_CONTEXT_DMA in the memory
;               range defined by the arguments and gives that instance the
;               object ID provided.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwObjectID      Object ID
;               pBaseAddr       Base
;               dwSelector      selector
;               dwLimit         limit
;               dwFlags         Flags (e.g.
;                               ALLOC_CTX_DMA_FLAGS_ACCESS_READ_ONLY)
;                               The possible flags are defined in the
;                               header file nvrmarch.inc
;
; Returns:      eax     0       failure
;                       non-0   Sucess
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocContextDma, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwObjectID
PARMD   pBaseAddr
PARMD   dwSelector
PARMD   dwLimit
PARMD   dwFlags
LOCALV  ContextDmaParam,ALLOC_CTX_DMA_PARAM
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        PUSHSREG ss
        lea     bx,ContextDmaParam
        push    bx
        mov     eax,ds:[esi].HWBOARDCX.dwRootHandle
        mov     ContextDmaParam.ALLOC_CTX_DMA_hObjectParent,eax
        mov     eax,dwObjectID
        mov     ContextDmaParam.ALLOC_CTX_DMA_hObjectNew,eax
        mov     ContextDmaParam.ALLOC_CTX_DMA_hClass,NV01_CONTEXT_DMA
        mov     eax,dwFlags
        mov     ContextDmaParam.ALLOC_CTX_DMA_flags,eax
        mov     eax,pBaseAddr
        mov     ContextDmaParam.ALLOC_CTX_DMA_pBase,eax
        movzx   eax,word ptr dwSelector
        mov     ContextDmaParam.ALLOC_CTX_DMA_pBase+4,eax
        mov     eax,dwLimit
        dec     eax
        mov     ContextDmaParam.ALLOC_CTX_DMA_limit,eax
        mov     ContextDmaParam.ALLOC_CTX_DMA_limit+4,0
        mov     eax,ALLOC_CTX_DMA_STATUS_SUCCESS
        mov     ContextDmaParam.ALLOC_CTX_DMA_status,eax
        call    FFP16 PTR lpfnArch_Nv01AllocContextDma

        cmp     ContextDmaParam.ALLOC_CTX_DMA_status,ALLOC_CTX_DMA_STATUS_SUCCESS
        sete    al
        movzx   eax,al
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     NV_FreeContextDma
;
; Purpose:      This function frees a Context Dma.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwObjectID              object ID to allocate
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_FreeContextDma, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwObjectID
LOCALV  FreeParam,NV01FREE_PARAM
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        mov	bx,ss
        shl	ebx,10H
        lea     bx,FreeParam
        push    ebx
        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     FreeParam.NV01FREE_hClient,ecx
        mov     FreeParam.NV01FREE_hObjectParent,ecx
        mov     eax,dwObjectID
        mov     FreeParam.NV01FREE_hObjectOld,eax
        mov     FreeParam.NV01FREE_status,NV01FREE_STATUS_SUCCESS
        call    FFP16 PTR lpfnArch_Nv01Free
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     NV_AllocWinChannelObject
;
; Purpose:      This function allocates any type of object whose parent
;               should be NV_WIN_CHANNEL.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwObjectClass           object class to allocate
;               dwObjectID              object ID to allocate
;
; Returns:      eax     0       failure
;                       non-0   Sucess
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_AllocWinChannelObject, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwObjectClass
PARMD   dwObjectID
LOCALV  AllocObjectParam,ALLOC_OBJECT_PARAM
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        PUSHSREG ss
        lea     cx,AllocObjectParam
        push    cx
        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     AllocObjectParam.ALLOC_OBJECT_hClient,ecx
        mov     AllocObjectParam.ALLOC_OBJECT_hObjectParent,NV_WIN_CHANNEL
        mov     eax,dwObjectID
        mov     AllocObjectParam.ALLOC_OBJECT_hObjectNew,eax
        mov     eax,dwObjectClass
        mov     AllocObjectParam.ALLOC_OBJECT_hClass,eax
        mov     AllocObjectParam.ALLOC_OBJECT_status,ALLOC_OBJ_STATUS_SUCCESS
        call    FFP16 PTR lpfnArch_Nv01AllocObject

        cmp     AllocObjectParam.ALLOC_OBJECT_status,ALLOC_OBJ_STATUS_SUCCESS
        sete    al
        movzx   eax,al
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     NV_RMAllocObject
;
; Purpose:      This function allocates any type of object whose parent
;               should be NV_WIN_CHANNEL.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwObjectClass           object class to allocate
;               dwObjectID              object ID to allocate
;
; Returns:      eax     0       failure
;                       non-0   Sucess
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_RMAllocObject, PASCAL, FRAME, FAR32
PARMD   pHWCRTCCXOffset
PARMD   pHWBoardCXOffset
PARMD   dwObjectClass
PARMD   dwObjectID
LOCALV  AllocParam,ALLOC_PARAM
LOCALV  AllocParms,NV07C_ALLOCATION_PARAMETERS
OPENPROC
        PUSHR   esi,edi
        mov     esi,pHWBoardCXOffset
        mov     edi,pHWCRTCCXOffset

;NvRmAlloc(ULONG hClient, ULONG hParent, ULONG hObject, ULONG hClass,
;          PVOID pAllocParms); //  NvRmApi.h

        sub     eax,eax
        mov     ax,ss
        push    eax
        call    GN_GetSelectorBase
        lea     ecx,AllocParms
        add     ecx,eax
        mov     AllocParam.ALLOC_pAllocParms,ecx

        mov     edx,ds:[edi].HWCRTCCX.dwPhysicalCRTCInstance
        mov     AllocParms.logicalHeadId,edx

        PUSHSREG ss
        lea     cx,AllocParam
        push    cx
        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     AllocParam.ALLOC_hRoot,ecx
        mov     AllocParam.ALLOC_hObjectParent,NV_WIN_CHANNEL
        mov     eax,dwObjectID
        mov     AllocParam.ALLOC_hObjectNew,eax
        mov     eax,dwObjectClass
        mov     AllocParam.ALLOC_hClass,eax
        mov     AllocParam.ALLOC_status,NVOS21_STATUS_SUCCESS
        call    FFP16 PTR lpfnArch_Nv04Alloc

        cmp     AllocParam.ALLOC_status,NVOS21_STATUS_SUCCESS
        sete    al
        movzx   eax,al
        POPR    esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     NV_FreeWinChannelObject
;
; Purpose:      This function frees an object whose parent is
;               NV_WIN_CHANNEL.
;
; Arguments:
;               ds                      Context Selector
;               pHWBoardCXOffset        HWBOARDCX ptr
;               dwObjectID              object ID to allocate
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_FreeWinChannelObject, PASCAL, FRAME, FAR32
PARMD   pHWBoardCXOffset
PARMD   dwObjectID
LOCALV  FreeParam,NV01FREE_PARAM
OPENPROC
        PUSHR   esi
        mov     esi,pHWBoardCXOffset

        PUSHSREG ss
        lea     bx,FreeParam
        push    bx
        mov     ecx,ds:[esi].HWBOARDCX.dwRootHandle
        mov     FreeParam.NV01FREE_hClient,ecx
        mov     FreeParam.NV01FREE_hObjectParent,NV_WIN_CHANNEL
        mov     eax,dwObjectID
        mov     FreeParam.NV01FREE_hObjectOld,eax
        mov     FreeParam.NV01FREE_status,NV01FREE_STATUS_SUCCESS
        call    FFP16 PTR lpfnArch_Nv01Free
        POPR    esi
CLOSEPROC


;==============================================================================
;
; Function:     NV_DestroyDmaContexts
;
; Purpose:      This function creates all the DMA contexts we will need
;               for the WIN CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      eax     0       failure
;                       non-0   Success
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_DestroyDmaContexts, PASCAL, NOFRAME, FAR32
OPENPROC
	push	esi
        pushd	OBJ_DMA_PUSH_BUFFER_NOTIFIER
        call    NV_FreeContextDma

	push	esi
	pushd	OBJ_VRAM_TO_SYSRAM_NOTIFIER0
	call	NV_FreeContextDma

	push	esi
	pushd	OBJ_VRAM_TO_SYSRAM_NOTIFIER1
	call	NV_FreeContextDma

	push	esi
	pushd	OBJ_SYSRAM_TO_VIDEO_NOTIFIER
	call	NV_FreeContextDma

	push	esi
	pushd	OBJ_DMA_TO_SYSRAM
	call	NV_FreeContextDma

	push	esi
	pushd	OBJ_DMA_FROM_SYSRAM
	call	NV_FreeContextDma

	push	esi
	pushd	OBJ_DMA_FROM_VRAM
	call	NV_FreeContextDma

	push	esi
	pushd	OBJ_DMA_IN_VRAM
	call	NV_FreeContextDma
        mov     eax,1
CLOSEPROC


;==============================================================================
;
; Function:     NV_DestroyObjects
;
; Purpose:      This function destroys all the objects we will need
;               for the WIN CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC NV_DestroyObjects, PASCAL, NOFRAME, FAR32
OPENPROC

IF 0
        ; Can't do this right now. By the time we get here,
        ; Windows has thrown us into DOS and the push buffer
        ; is disabled at that time. Oh well!

        ; I don't want to have to wait for space anywhere in the
        ; object destruction routines. Just wait for 4K bytes. That
        ; will be enough to hold the whole destruction process.
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        CHECKDMASPACE ds,esi,edi,1000H

        call    DestroyContextSurfaces2D
        call    DestroyVramToSysramCopy0
        call    DestroyVramToSysramCopy1
        call    DestroyContextClipRect
        call    DestroyContextPattern
        call    DestroyContextRop
        call    DestroyImageBlit
        call    DestroyRectAndText
        call    DestroyImageFromCpu
        call    DestroySolidLine
        call    DestroyIndexedImageFromCpu

        ; I want to track the byte usage in the DMA buffer accurately,
        ; but I didn't wait for the exact number of dwords needed for
        ; the object destruction routines above. Sync up here.
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        lea     eax,[esi].HWBOARDCX.bDmaPushBuffer
        mov     ecx,eax
        sub     ecx,ds:[esi].HWBOARDCX.pPushBufferContextStartOffset
        or      ecx,JMP_COMMAND
        mov     ds:[edi],ecx
        xor     ecx,JMP_COMMAND
        SETPUTPTR ds,esi,eax
@@:
        cmp     ds:[esi].HWBOARDCX.dwDmaGetPtr,ecx
        jne     @B
ENDIF

	; Now we can actually free all the objects
	push	esi
        pushd	OBJ_CONTEXT_SURFACES_2D
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_DMA_FROM_VRAM_TO_SYSRAM_0
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_DMA_FROM_VRAM_TO_SYSRAM_1
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_CONTEXT_CLIP_RECT
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_CONTEXT_PATTERN
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_CONTEXT_ROP
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_IMAGE_BLIT
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_RECT_AND_TEXT
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_IMAGE_FROM_CPU
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_SOLID_LINE
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_INDEXED_IMAGE_FROM_CPU
        call    NV_FreeWinChannelObject

	push	esi
        pushd	OBJ_STRETCHED_IMAGE_FROM_CPU
        call    NV_FreeWinChannelObject
CLOSEPROC

IF 0
;==============================================================================
;
; Function:     DestroyContextSurfaces2D
;
; Purpose:      This function Destroys a ContextSurfaces2D object
;               to be used in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroyContextSurfaces2D, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(ContextSurfaces2dHdr.object,1)
        mov     ebx,OBJ_CONTEXT_SURFACES_2D
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Null out the context DMAs
        mov     eax,CHNRUN(ContextSurfaces2d.SetContextDmaImageSource,2)
        sub	ecx,ecx
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ecx
        mov     ds:[edi + 10H],ecx
        add     edi,14H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     DestroyVramToSysramCopy0
;
; Purpose:      This function destroys a MemoryToMemoryFormat object
;               for copying from video memory to system memory.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroyVramToSysramCopy0, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(MemoryToMemoryFormat0Hdr.object,1)
        mov     ebx,OBJ_DMA_FROM_VRAM_TO_SYSRAM_0
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Clear out the context DMA
        mov     eax,CHNRUN(MemoryToMemoryFormat0.SetContextDmaNotifies,3)
        sub	ecx,ecx
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ecx
        mov     ds:[edi + 10H],ecx
        mov     ds:[edi + 14H],ecx
        add     edi,18H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     DestroyVramToSysramCopy1
;
; Purpose:      This function destroys a MemoryToMemoryFormat object
;               for copying from video memory to system memory.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroyVramToSysramCopy1, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(MemoryToMemoryFormat1Hdr.object,1)
        mov     ebx,OBJ_DMA_FROM_VRAM_TO_SYSRAM_1
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Clear out the context DMA
        mov     eax,CHNRUN(MemoryToMemoryFormat1.SetContextDmaNotifies,3)
        sub	ecx,ecx
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ecx
        mov     ds:[edi + 10H],ecx
        mov     ds:[edi + 14H],ecx
        add     edi,18H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     DestroyContextClipRect
;
; Purpose:      This function destroys a ContextClipRectangle object
;               for use as a global clip rectangle in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroyContextClipRect, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(ContextClipRectHdr.object,1)
        mov     ebx,OBJ_CONTEXT_CLIP_RECT
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Clear out the context DMA
        mov     eax,CHNRUN(ContextClipRect.SetContextDmaNotifies,1)
        sub	ebx,ebx
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx
        add     edi,10H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     DestroyContextPattern
;
; Purpose:      This function destroys an ContextPattern object
;               for use as a global pattern in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroyContextPattern, PASCAL, NOFRAME, NEAR
OPENPROC
	; Don't need to do anything special
CLOSEPROC


;==============================================================================
;
; Function:     DestroyContextRop
;
; Purpose:      This function destroys a ContextRop object
;               for use as a global rop in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroyContextRop, PASCAL, NOFRAME, NEAR
OPENPROC
CLOSEPROC


;==============================================================================
;
; Function:     DestroyImageBlit
;
; Purpose:      This function destroys an ImageBlit object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroyImageBlit, PASCAL, NOFRAME, NEAR
OPENPROC
CLOSEPROC


;==============================================================================
;
; Function:     DestroyRectAndText
;
; Purpose:      This function destroys a GdiRectangleText object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroyRectAndText, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(RectAndTextHdr.object,1)
        mov     ebx,OBJ_RECT_AND_TEXT
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(RectAndText.SetContextDmaFonts,1)
        sub	ebx,ebx
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx
        add     edi,10H
        SETPUTPTR ds,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     DestroyImageFromCpu
;
; Purpose:      This function destroys an ImageFromCpu object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroyImageFromCpu, PASCAL, NOFRAME, NEAR
OPENPROC
CLOSEPROC


;==============================================================================
;
; Function:     DestroySolidLine
;
; Purpose:      This function destroys a RenderSolidLin object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroySolidLine, PASCAL, NOFRAME, NEAR
OPENPROC
CLOSEPROC


;==============================================================================
;
; Function:     DestroyIndexedImageFromCpu
;
; Purpose:      This function destroys an IndexedImageFromCpu object
;               for use in the WIN_CHANNEL.
;
; Arguments:    ds:esi  HWBOARDCX
;
; Returns:      None
;
; Preserve:     ds,esi,edi
;==============================================================================
DECPROC DestroyIndexedImageFromCpu, PASCAL, NOFRAME, NEAR
OPENPROC
        ; Set the object in a sub-channel
        mov     edi,ds:[esi].HWBOARDCX.pCurrentPushBufferOffset
        mov     eax,CHNRUN(IndexedImageFromCpuHdr.object,1)
        mov     ebx,OBJ_INDEXED_IMAGE_FROM_CPU
        mov     ds:[edi + 00H],eax
        mov     ds:[edi + 04H],ebx

        ; Program the non-volatile data
        mov     eax,CHNRUN(IndexedImageFromCpu.SetContextDmaLut,1)
        sub	ebx,ebx
        mov     ds:[edi + 08H],eax
        mov     ds:[edi + 0CH],ebx
        add     edi,10H
        SETPUTPTR ds,esi,edi
CLOSEPROC
ENDIF

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\CODE\MVISION.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         mvision.asm
;
; Purpose:      This file holds the macrovision control code.
;==============================================================================
.586
include macros.dat
include gdidefs.inc
include dibeng.inc
include gngdi.inc
include hwgdi.inc
include hwmacs.inc
include nvcm.inc
include nvos.inc
include nvmisc.inc
include sysdata.inc
include nv32.inc
include hwlogdev.inc
include hwcrtc.inc
include hwboard.inc


OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT16, USE16, CODE

;==============================================================================
;
; Function:     HW_SetMacrovisionMode
;
; Purpose:      Sets the current Macrovision capable TV Out device to
;               the requested Macrovision copy protection mode.
;
; Arguments:    Mode		new macrovision copy protection mode to set
;               ds		Context Selector
;		pHWCrtcCXOffset	HWCRTCCX ptr
;               resX		PhysicalXRes
;               resY		PhysicalYRes
;
; Returns:      eax     0 then fail
;                       non-0 then success
;
; Preserve:     ds:esi,es,edi
;==============================================================================

DECPROC HW_SetMacrovisionMode, PASCAL, FRAME, NEAR
PARMD	Mode
PARMD	resX
PARMD	resY
PARMD	pHWCrtcCXOffset
LOCALV  Params, NV_CFGEX_SET_MACROVISION_MODE_PARAMS
OPENPROC

        PUSHR   ds,es,esi

	mov	eax,Mode
	mov     Params.mode,eax

        mov     esi,pHWCrtcCXOffset
        mov     eax,ds:[esi].HWCRTCCX.dwPhysicalCRTCInstance
        mov     Params.head,eax

        mov     eax,resX
        mov     Params.resx,eax
        mov     eax,resY
        mov     Params.resy,eax
        mov     ax,ss
        shl     eax,10H
        lea     ax,Params
        mov     ebx,SIZE NV_CFGEX_SET_MACROVISION_MODE_PARAMS
        mov     ecx,NV_CFGEX_SET_MACROVISION_MODE
        mov     esi,ds:[esi].HWCRTCCX.pHWBoardCX
        call    NV_ConfigExSetCall

	cmp	eax,NVOS_CGE_STATUS_SUCCESS
	mov	eax,1
	je	SMM_Ok
	sub	eax,eax

SMM_Ok:
        POPR    ds,es,esi
CLOSEPROC

CLOSESEG _NVTEXT16

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\INCLUDE\HWBOARD.H ===
/*=======================================================================

    Copyright (C), 1998 Nvidia Coporation

    File:       hwboard.h

    Purpose:    This file holds the HWBOARDCX structure and other
                board related data.

=========================================================================*/

typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;

// Other NV specific defines
#define NV_DEVICE_VERSION_4     0x0004
#define NV_DEVICE_VERSION_5     0x0005
#define NV_DEVICE_VERSION_10    0x0010
#define NV_DEVICE_VERSION_20    0x0020

// NV Architecture IDs -- NV05 is NV_04_ARCHITECTURE, REVISION 1
#define NV_03_ARCHITECTURE      0x03
#define NV_04_ARCHITECTURE      0x04
#define NV_10_ARCHITECTURE      0x10
#define NV_20_ARCHITECTURE      0x20

// This wasn't defined in the nvidia\sdk header files
#define NV1_MEMORY_SYSTEM       0x3E

// These are for the dwBusType field in the HWBOARDCX
#define NV_BUS_TYPE_PCI         0x01
#define NV_BUS_TYPE_AGP         0x04

// Our push buffer size
#define DMA_PUSH_BUFFER_SIZE    0x400000

// Hey, hope this is correct ...
#define WRITE_COMBINE_PAD_SIZE  0x20

// Normal Heap allocations that are purged on modesets or if we
// need more memory use this ID.
#define GDI2D_HEAP_OWNER        'NV2D'

// Allocations of the primary surface use this ID
#define GDI2D_DESKTOP_OWNER     'NVPS'

// Allocations for the board for things that must never disappear
// use this ID.
#define GDI2D_BOARD_OWNER       'NVBD'

// DDRAW heap ID that are purged on modesets if we need more memory.
#define DX_HEAP_ID      'NVDX'


// The first 100H bytes of each channel is NvControl stuff
typedef volatile struct
{
    V032    object;             // 0000-0003    current object register
    V032    reserved01[0x003];  // 0004-000C
    U016    free;               // 0010-0011    free count
    U016    reserved02[0x001];
    U032    reserved03[0x003];
    struct  tagNvPassword
    {
        V032    token[4];       // 0020-002F    Any write unlocks the chip
    }
    password;
    V032 dwPush;                // 0030-0033    Any write saves channel state
    V032 dwPop;                 // 0034-0037    Any write restores channel state
    V032 SetMethodCtxDma;       // 0038-003B    NV_CONTEXT_DMA_FROM_MEMORY
    V032 SetMethodNotifyCtxDma; // 003C-003F    NV_CONTEXT_DMA_TO_MEMORY
    V032 SetMethodStart;        // 0040-0043    offset within ctxdma in bytes
    V032 SetMethodLength;       // 0044-0047    Context DMA length in bytes
    V032 SetMethodNotify;       // 0048-004B    notification style
    V032 reserved04[0x02d];
}   NvControl;


// This structure is the layout of the GDI display driver's channel.
typedef volatile struct tagGDICHAN
{
    union
    {
        NvControl                   StartOfChannelHdr;
        NvControl                   ContextRopHdr;
    };

    Nv03ContextRop                  ContextRop;
    NvControl                       ContextSurfaces2dHdr;
    Nv04ContextSurfaces2d           ContextSurfaces2d;
    NvControl                       ContextPatternHdr;
    Nv04ImagePattern                ContextPattern;
    NvControl                       ContextClipRectHdr;
    Nv01ImageBlackRectangle         ContextClipRect;
    NvControl                       RectAndTextHdr;
    Nv04GdiRectangleText            RectAndText;
    NvControl                       ImageBlitHdr;
    Nv04ImageBlit                   ImageBlit;
    union
    {
        NvControl                   ImageFromCpuHdr;
        NvControl                   IndexedImageFromCpuHdr;
        NvControl                   StretchedImageFromCpuHdr;
        NvControl                   MemoryToMemoryFormat0Hdr;
        NvControl                   RenderSolidLinHdr;
        NvControl                   VideoSinkHdr;
        NvControl                   VideoFromMemoryHdr;
        NvControl                   VideoColorMapHdr;
        NvControl                   VideoLutCursorDacHdr;
    };
    union
    {
        Nv04ImageFromCpu            ImageFromCpu;
        Nv04IndexedImageFromCpu     IndexedImageFromCpu;
        Nv04StretchedImageFromCpu   StretchedImageFromCpu;
        Nv03MemoryToMemoryFormat    MemoryToMemoryFormat0;
        Nv04RenderSolidLin          RenderSolidLin;
        NvVideoSink                 VideoSink;
        NvVideoFromMemory           VideoFromMemory;
        NvVideoColormap             VideoColorMap;
        Nv04VideoLutCursorDac       VideoLutCursorDac;
    };
    union
    {
        NvControl                   MemoryToMemoryFormat1Hdr;
    };
    union
    {
        Nv03MemoryToMemoryFormat    MemoryToMemoryFormat1;
    };
}   GDICHAN;

typedef GDICHAN *LPGDICHAN;


// These are the objects which we will be using
#define OBJ_DMA_PUSH_BUFFER                     0x00009000
#define OBJ_DMA_PUSH_BUFFER_NOTIFIER            0x00009001
#define OBJ_VRAM_TO_SYSRAM_NOTIFIER0            0x00009002
#define OBJ_VRAM_TO_SYSRAM_NOTIFIER1            0x00009003
#define OBJ_SYSRAM_TO_VIDEO_NOTIFIER            0x00009004
#define OBJ_DMA_TO_SYSRAM                       0x00009006
#define OBJ_DMA_FROM_SYSRAM                     0x00009007
#define OBJ_DMA_FROM_VRAM                       0x00009008
#define OBJ_DMA_IN_VRAM                         0x00009009

#define OBJ_CONTEXT_SURFACES_2D                 0x0000900A
#define OBJ_DMA_FROM_VRAM_TO_SYSRAM_0           0x0000900B
#define OBJ_DMA_FROM_VRAM_TO_SYSRAM_1           0x0000900C
#define OBJ_CONTEXT_CLIP_RECT                   0x0000900D
#define OBJ_CONTEXT_PATTERN                     0x0000900E
#define OBJ_CONTEXT_ROP                         0x0000900F
#define OBJ_IMAGE_BLIT                          0x00009010
#define OBJ_RECT_AND_TEXT                       0x00009011
#define OBJ_IMAGE_FROM_CPU                      0x00009012
#define OBJ_SOLID_LINE                          0x00009013
#define OBJ_INDEXED_IMAGE_FROM_CPU              0x00009014
#define OBJ_STRETCHED_IMAGE_FROM_CPU		0x00009015

#define OBJ_DMA_PUSH_MEMORY                     0x00009999

// Note that there might be multiple VideoLutCursorDac objects
// This ID is for the first one. There is one for each additional
// CRTC on the board and the object IDs are sequential numbers
// starting with this first one.
#define OBJ_VIDEO_LUT_CURSOR_DAC                0x00009020

// Similar to above. Seems like 0x10 CRTCs is enough ...
#define OBJ_VIDEO_LUT_CURSOR_DAC_NOTIFIER       0x00009030

// Similar to above but for the Palette
#define OBJ_DMA_IN_SYSRAM_FOR_PALETTE           0x00009040

// Similar to above but for the Gamma
#define OBJ_DMA_IN_SYSRAM_FOR_GAMMA             0x00009050

#define	INTERLACED_STEREO						0x00000001

typedef struct  _HWBOARDCX
{
    ////////////////////////////////////////////////////////////////
    // The pages which contain the first part of this structure
    // should be marked as CACHEABLE.

    // These "constants" describe the DMA push buffer
    ULONG    pPushBufferStartOffset;                        // 0000-0003
    ULONG    pPushBufferContextStartOffset;                 // 0004-0007
    ULONG    dwPushBufferLength;                            // 0008-000B

    // Use IO to flush processor and chipset cache if true
    ULONG    dwFlushCacheWithIO;                            // 000C-000F

    // These "variables" are used to manage the push buffer
    ULONG    pCurrentPushBufferOffset;                      // 0010-0013
    ULONG    dwBytesFree;                                   // 0014-0017

    // Keep these variables accessible
    ULONG    dwContextSurface2dDstSrcPitch;                 // 0018-001B
    ULONG    dwContextSurface2dSrcOffset;                   // 001C-001F
    ULONG    dwContextSurface2dDstOffset;                   // 0020-0023
    ULONG    dwMinContextSurface2dPitch;                    // 0024-0027
    ULONG    dwMaxContextSurface2dPitch;                    // 0028-002B

    // I need a variable that reminds me to restore the alpha when
    // I have temporarily set a TRANSPARENT hatch pattern in output.
    ULONG    dwGetOffsetAtLastBeginAccess;                  // 002C-002F

    ULONG    dwTemp[4];                                     // 0030-003F

    // The start of this context will be the PUSHER notifier
    NvNotification  sPushBufferNotifier;                    // 0040-004F

    // I need some notifiers for the MemoryToMemoryFormat objects.
    // The standard MemoryToMemoryFormat object has an array of
    // two notifiers. They are the following:
    // MethodNotifer    -- When certain methods of the object are written
    // BufferNotifier   -- When the MemoryToMemory transfer is completed
    NvNotification  sVramToSysramMethodNotifier0;           // 0050-005F
    NvNotification  sVramToSysramBufferNotifier0;           // 0060-006F
    NvNotification  sVramToSysramMethodNotifier1;           // 0070-007F
    NvNotification  sVramToSysramBufferNotifier1;           // 0080-008F

    // I need some notifiers for the VideoFromMemory object.
    // The standard VideoFromMemory object has an array of
    // two notifiers. They are the following:
    // BufferNotifier   -- When the VideoFromMemory transfer is completed
    // Flip0Notifer     -- Indicates page 0 has been flipped to
    // Flip1Notifier    -- Indicates page 1 has been flipped to
    // Buffer 0 Scan    -- Data field of notifier contains current scanline
    //                     being displayed in buffer 0
    // Buffer 1 Scan    -- Data field of notifier contains current scanline
    //                     being displayed in buffer 1
    NvNotification  sSysramToVideoBufferNotifier;           // 0090-009F
    NvNotification  sSysramToVideoFlip0Notifier;            // 00A0-00AF
    NvNotification  sSysramToVideoFlip1Notifier;            // 00B0-00BF
    NvNotification  sSysramToVideoScan0Notifier;            // 00C0-00CF
    NvNotification  sSysramToVideoScan1Notifier;            // 00D0-00DF

    // These are offscreen video memory addresses of where the cursor
    // cache is located for each CRTC.
    ULONG   dwCursorCacheSize;                              // 00E0-00E4
    ULONG   adwCursorCacheVramOffset[MAX_ATTACHED_CRTCS];   // 00E4-???
    ULONG   adwReservedPrimarySurfaceOffsets[MAX_ATTACHED_CRTCS]; // ????

    // A little slack space ...
    ULONG   tmp[35 - 2 * MAX_ATTACHED_CRTCS];               // ????-016F

    /////////////////////////////////////////////////////////////////
    // Set to non-0 if we are initting. Cleared on first modeset
    ULONG   dwInitting;                                     // 0170-0173

    // The specific Nvidia board number from the RM  (1 based.)
    ULONG   dwDeviceNum;                                    // 0174-0177

    // Root handle
    ULONG   dwRootHandle;                                   // 0178-017B

    // The ResMan device handle returned from allocating the device
    ULONG   dwhDevice;                                      // 017C-017F

    // Information about the frame buffer
    ULONG   dwRamFlags;                                     // 0180-0183
    ULONG   dwVideoMemorySize;                              // 0184-0187
    ULONG   pVideoMemory;                                   // 0188-018B
    ULONG   dwVideoMemorySel;                               // 018C-018F

    // Information about the device
    ULONG   pChipRegs;                                      // 0190-0193

    // Deevice version like NV_DEVICE_VERSION_5 (or _4 or _10, etc.)
    ULONG   dwDeviceVersion;                                // 0194-0197

    // PCI or AGP?
    ULONG   dwBusType;                                      // 0198-019B

    // This field tells how many CRTCs are on the board. The next one
    // field has a one bit set for each CRTC that has been allocated.
    ULONG   dwNumCRTCsOnBoard;                              // 019C-019F
    ULONG   dwCRTCsAllocatedFlags;                          // 01A0-01A3

    // This is information about the push buffer and channel
    // Freed by FreeRoot if Allocated via NV_AllocMemory.
    // If allocated with SysAllocPages, we must free it by
    // calling lpfnNvSysFreePages with dwRealPushBufferPageHandle.
    ULONG   dwRealPushBufferPageHandle;                     // 01A4-01A7
    ULONG   pRealPushBuffer;                                // 01A8-01AB

    // Freed by FreeRoot
    ULONG   pDmaChannel;                                    // 01AC-01AF

    // This is the real ptr that was allocated for the HWBOARDCX.
    // It is not what you return to the generic code as the
    // HWBOARDCX ptr though, so we must save this so that we can
    // free it later. NOTE: We return conctext sekector relative
    // ptr version of pAliasedHWBoardCX. This is different
    // linear address space that maps to the same memory as
    // pHWBoardCXReal.                                      
    ULONG   pHWBoardCXReal;                                 // 01B0-01B3

    // We have aliased the push buffer so we can remap some of the pages
    // to point to other things. As a result, we can reference everything
    // off of the context selector that is passed around.
    ULONG   pAliasedHWBoardCX;                              // 01B4-01B7

    // Non-0 when DirectX is active
    ULONG   dwDirectXActive;                                // 01B8-01BB

    // This is where the table of LUT values is stored
    ULONG   dwIndexedLUTOffset;                             // 01BC-01BF

    // This is used by OpenGL to track the mode switches. The variable
    // is incremented by one when a mode switch begins and by another
    // one when the mode switch is finished. An even number indicates the
    // mode is stable. An odd number indicates a mode set is in progress.
    ULONG   dwModeSwitchCount;                              // 01C0-01C3

    // This is the channel number used by the display driver.
    ULONG   dwGdiDriverChannelID;                           // 01C4-01C7

    // I haven't yet decided if I want the current channel ID variable
    // to be in the PDEVICE or in the HARDWARESEGMENT. It depends on
    // which I have a ptr to more often when I need to access the
    // current channel ID variable. If I decide that I want it in the
    // PDEVICE, then this will be it.
    ULONG   dwCurrentChannelID;                             // 01C8-01CB

    // The pCurrentChannelID is a ptr to a dword variable thats holds
    // the channel ID (0-15) of the most recent channel to trigger
    // their DMA pusher. Every channel should check this variable to
    // see if it matches the channel ID of their channel and, if it
    // does not, the channel should sync to the other channels before
    // triggering its own DMA. Each channel should write their channel
    // ID into the dword pointed to by pCurrentChannelID when triggering
    // their DMA. This variable is used by all the different drivers
    // that can have channels to the hardware (e.g. DirectX, OpenGL).
    ULONG   pCurrentChannelID;                              // 01CC-01CF

    // To sync between the different DMA channels, these are needed
    ULONG   dwGdiPushBufferIndex;                           // 01D0-01D3
    ULONG   dwGdiPushBufferMask;                            // 01D4-01D7


    // Used for debugging
    ULONG    dwTempEnd;                                     // 01D8-01DB
    ULONG    dwLastGet;                                     // 01DC-01DF
    ULONG    dwLastWaitPath;                                // 01E0-01E3
    ULONG    dwPushBufferOffsetOnWaitEnter;                 // 01E4-01E7
    ULONG    dwLastBytesFree;                               // 01E8-01EB
    ULONG    dwLastByteRequest;                             // 01EC-01EF

    // This holds the chip revision
    ULONG   dwDeviceRevision;                               // 01F0-01F3

    ULONG   dwDisplayChangeCount;                           // 01F4-01F7

	// Misc stereo related properties
    ULONG   dwStereoConnectionType;                         // 01F8-01FB
    ULONG   dwReserved;										// 01FC-01FF

    // Next we need a cacheable buffer that MemoryToMemoryFormat can use
    // to transfer chunks of VRAM back into. This should be the remainder
    // of this 4K page plus some whole number of additional 4K pages.
#define CACHEABLE_BUFFER_SIZE   (0x8000 - 0x0200)
    UCHAR   bCacheableDmaBuffer[CACHEABLE_BUFFER_SIZE];

    // End of the CACHEABLE area.
    ////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////
    // The page that maps the following should be marked as
    // NON_CACHEABLE and NON-WRITECOMBINE -- it is mapping hardware.
    UCHAR   bHWPageStart[0x0040];
    ULONG   dwDmaPutPtr;
    ULONG   dwDmaGetPtr;
    UCHAR   bHWPageEnd[0x1000 - 0x0048];
    // End NON_CACHEABLE, NON WRITE-COMBINE page
    ///////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////
    // The rest of the structure is the Dma Pusher Buffer. It can be
    // marked NON-CACHEABLE, WRITE-COMBINE but may also run as CACHED
    // memory. We cannot actually put
    // the entire DMA PUSH BUFFER in here as an array if it is larger
    // than 64K because in 16bit land, structures are limited to 64K.
    // But this file will be converted to an assembly include file,
    // and as long as we have a label for the start of the buffer,
    // the assembly code will be able to access the whole push buffer
    // correctly.
    //
    // To force a flush of the CPU's internal Write-Combine (WC) buffer,
    // a write is required to a region of WC memory which is not in the
    // same 32byte window as the last write to a WC memory area. We want
    // the first dword of the first page to provide this mechanism.
    //
    // One more thing. Make the push buffer 0x20 bytes less than a
    // multiple of 4K. Why? Because then the buffer will end just on
    // a page boundary and there won't be any wasted bytes on the end
    // of a 4K page (the OS does page allocation).

    // The start of this context will be the PUSHER notifier
    UCHAR   bScrapSpace[WRITE_COMBINE_PAD_SIZE];

    // I'd like to do what the next line does, but this is 16bit land
    // so I'll just use the line after to provide a label.
//  UCHAR   bDmaPushBuffer[DMA_PUSH_BUFFER_SIZE];
    UCHAR   bDmaPushBuffer;
    ///////////////////////////////////////////////////////////////////

}   HWBOARDCX;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\INCLUDE\GDIDEFS.INC ===
;/*
;****************************************************************************
;                                                                           *
; THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
; KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
; IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
; PURPOSE.                                                                  *
;                                                                           *
; Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
;                                                                           *
;****************************************************************************

;       GDI Definitions for Device Drivers
;
;       Since most of the routines only need a portion of these definitions,
;       conditional assembly flags have been defined in the various files
;       to only include portions as needed (as opposed to having a lot of
;       include files to mess with).  The flags are as follows:
;
;       incFont         include font definitions
;       incDevice       include device definitions
;       incLogical      include logical object definitions
;       incDrawmode     include DrawMode structure definition
;       incOutput       include Output definitions
;       incControl      include Control definitions
;       incPolyScanline include Scan definition

page
;       General definitions that almost everyone will use.



;       Physical Bitmap Structure
;
;       Bitmap data structure passed to OEM routines.  Defines the location and
;       size of a main memory bitmap.



BITMAP          struc                                                       ;*/ typedef struct {                 /*

  bmType            dw  0       ; 0 means main memory bitmap.  Non-zero     ;*/ short int bmType;                /*
                                ; is number of physical display and format
                                ; of the rest of the structure known only
                                ; to device driver
  bmWidth           dw  0       ; Width of bitmap in pixels                 ;*/ unsigned short int bmWidth;      /*
  bmHeight          dw  0       ; Height of bitmap in pixels                ;*/ unsigned short int bmHeight;     /*
  bmWidthBytes      dw  0       ; #bytes per scan line                      ;*/ unsigned short int bmWidthBytes; /*
  bmPlanes          db  0       ; # of planes in bitmap                     ;*/ BYTE               bmPlanes;     /*
  bmBitsPixel       db  0       ; # of bits per pixel                       ;*/ BYTE               bmBitsPixel;  /*
  bmBits            dd  0       ; Far pointer to bits of main memory bitmap ;*/ BYTE FAR          *bmBits;       /*
  bmWidthPlanes     dd  0       ; Product of bmWidthBytes and bmHeight      ;*/ unsigned long int  bmWidthPlanes;/*
  bmlpPDevice       dd  0       ; Pointer to associated PDevice             ;*/ BYTE FAR          *bmlpPDevice;  /*
  bmSegmentIndex    dw  0       ; Index to plaens next segment if non-zero  ;*/ unsigned short int bmSegmentIndex; /*
  bmScanSegment     dw  0       ; Number of scans per segment               ;*/ unsigned short int bmScanSegment; /*
  bmFillBytes       dw  0       ; Number of unused bytes per segment        ;*/ unsigned short int bmFillBytes;   /*
                    dw  0                                                   ;*/ unsigned short int futureUse4;    /*
                    dw  0                                                   ;*/ unsigned short int futureUse5;    /*
BITMAP              ends                                                    ;*/ } BITMAP;                         /*

; structures used for Device Independent Bitmap (DIB) processing.
; all taken out of Presentation Manager's documentation
;  Tuesday 25-October-1988 15:04   -by-   Ron Gery [rong]

; C definitions are provided below (separately).

; triple used in PM1.1 (BitmapCoreInfo) format color table
RGBTriple           struc
  rgbtBlue          db  0
  rgbtGreen         db  0
  rgbtRed           db  0
RGBTriple           ends

; RGB DWORD used in PM2.0 format color table
RGBQuad             struc
  rgbBlue           db  0
  rgbGreen          db  0
  rgbRed            db  0
  rgbReserved       db  0
RGBQuad             ends

BitmapCoreHeader    struc
  bcSize            dd  0
  bcWidth           dw  0
  bcHeight          dw  0
  bcPlanes          dw  0
  bcBitCount        dw  0
BitmapCoreHeader    ends

; new format bitmap structure based on PM2.0 format DCR.
;  Tuesday 23-May-1989 16:05   -by-   Ron Gery [rong]

BitmapInfoHeader    struc
  biSize            dd  0
  biWidth           dd  0
  biHeight          dd  0
  biPlanes          dw  0
  biBitCount        dw  0

  biCompression     dd  0
  biSizeImage       dd  0
  biXPelsPerMeter   dd  0
  biYPelsPerMeter   dd  0
  biClrUsed         dd  0
  biClrImportant    dd  0
BitmapInfoHeader    ends

BitmapInfo          struc
  bmiHeader     db (size BitmapInfoHeader) DUP (?)
  bmiColors     db ?                    ; array of RGBQUADS
BitmapInfo          ends

BitmapCoreInfo      struc
  bmciHeader    db (size BitmapCoreHeader) DUP (?)
  bmciColors    db ?                    ; array of RGBTRIPLES
BitmapCoreInfo      ends

BI_RGB          equ    0h
BI_RLE8         equ    1h
BI_RLE4         equ    2h
BI_BITFIELDS    equ    3h

BitmapV4Header  struc
  bV4Size           dd  0
  bV4Width          dd  0
  bV4Height         dd  0
  bV4Planes         dw  0
  bV4BitCount       dw  0
  bV4Compression    dd  0
  bV4SizeImage      dd  0
  bV4XPelsPerMeter  dd  0
  bV4YPelsPerMeter  dd  0
  bV4ClrUsed        dd  0
  bV4ClrImportant   dd  0
  bV4RedMask        dd  0
  bV4GreenMask      dd  0
  bV4BlueMask       dd  0
  bV4AlphaMask      dd  0
  bV4CSType         dd  0
  bV4Endpoints      db  36 dup (0)
  bV4GammaRed       dd  0
  bV4GammaGreen     dd  0
  bV4GammaBlue      dd  0
BitmapV4Header    ends


        if      0

*/
/* C definitions for DIBs, as defined in windows.h */

typedef struct {
        DWORD   bcSize;
        WORD    bcWidth;
        WORD    bcHeight;
        WORD    bcPlanes;
        WORD    bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR *LPBITMAPCOREHEADER;
typedef BITMAPCOREHEADER *PBITMAPCOREHEADER;

typedef struct {
        DWORD      biSize;
        DWORD      biWidth;
        DWORD      biHeight;
        WORD       biPlanes;
        WORD       biBitCount;

        DWORD      biCompression;
        DWORD      biSizeImage;
        DWORD      biXPelsPerMeter;
        DWORD      biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} BITMAPINFOHEADER;

typedef BITMAPINFOHEADER FAR *LPBITMAPINFOHEADER;
typedef BITMAPINFOHEADER *PBITMAPINFOHEADER;

typedef struct {
        BYTE    rgbtBlue;
        BYTE    rgbtGreen;
        BYTE    rgbtRed;
} RGBTRIPLE;

typedef struct {
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
} RGBQUAD;

/* ICM Color Definitions */
// The following two structures are used for defining RGB's in terms of
// CIEXYZ. The values are fixed point 16.16.

typedef long            FXPT16DOT16, FAR *LPFXPT16DOT16;
typedef long            FXPT2DOT30, FAR *LPFXPT2DOT30;

typedef struct tagCIEXYZ
{
        FXPT2DOT30 ciexyzX;
        FXPT2DOT30 ciexyzY;
        FXPT2DOT30 ciexyzZ;
} CIEXYZ;
typedef CIEXYZ  FAR *LPCIEXYZ;

typedef struct tagICEXYZTRIPLE
{
        CIEXYZ  ciexyzRed;
        CIEXYZ  ciexyzGreen;
        CIEXYZ  ciexyzBlue;
} CIEXYZTRIPLE;
typedef CIEXYZTRIPLE    FAR *LPCIEXYZTRIPLE;

typedef struct {
    BITMAPCOREHEADER    bmciHeader;
    RGBQUAD             bmciColors[1];
} BITMAPCOREINFO;

typedef BITMAPCOREINFO FAR *LPBITMAPCOREINFO;
typedef BITMAPCOREINFO *PBITMAPCOREINFO;

typedef struct {
    BITMAPINFOHEADER    bmiHeader;
    RGBQUAD             bmiColors[1];
} BITMAPINFO;

typedef BITMAPINFO FAR *LPBITMAPINFO;
typedef BITMAPINFO *PBITMAPINFO;

typedef struct {
        DWORD        bV4Size;
        LONG         bV4Width;
        LONG         bV4Height;
        WORD         bV4Planes;
        WORD         bV4BitCount;
        DWORD        bV4V4Compression;
        DWORD        bV4SizeImage;
        LONG         bV4XPelsPerMeter;
        LONG         bV4YPelsPerMeter;
        DWORD        bV4ClrUsed;
        DWORD        bV4ClrImportant;
        DWORD        bV4RedMask;
        DWORD        bV4GreenMask;
        DWORD        bV4BlueMask;
        DWORD        bV4AlphaMask;
        DWORD        bV4CSType;
        CIEXYZTRIPLE bV4Endpoints;
        DWORD        bV4GammaRed;
        DWORD        bV4GammaGreen;
        DWORD        bV4GammaBlue;
} BITMAPV4HEADER, FAR *LPBITMAPV4HEADER, *PBITMAPV4HEADER;

typedef struct {
    BITMAPV4HEADER      bmv4Header;
    RGBQUAD             bmv4Colors[1];
} BITMAPV4INFO;

typedef BITMAPV4INFO FAR *LPBITMAPV4INFO;
typedef BITMAPV4INFO *PBITMAPV4INFO;

/* currently, if the low byte of biCompression is non zero,
 * it must be one of following */

#define BI_RGB              0x00
#define BI_RLE8             0x01
#define BI_RLE4             0x02
#define BI_BITFIELDS        0x03

#define BITMAP_SELECTED     0x01
#define BITMAP_64K          0x01

#define DIBSIGNATURE        0x4944
/*
        endif

    if      0
*/
#ifndef NOPTRC
/*
    endif


PTTYPE          struc                                                       ;*/ typedef     struct {        /*

  xcoord        dw      0               ;x coordinate of point              ;*/ short int xcoord;           /*
  ycoord        dw      0               ;y coordinate of point              ;*/ short int ycoord;           /*

PTTYPE          ends                                                        ;*/ } PTTYPE;                   /*
                                                                            ;*/ typedef PTTYPE *PPOINT;     /*
                                                                            ;*/ typedef PTTYPE FAR *LPPOINT; /*
    if      0
*/
#define     POINT   PTTYPE
/*
    endif



RECT            struc                                                       ;*/ typedef struct {            /*

  left          dw      0                                                   ;*/ short int left,             /*
  top           dw      0                                                   ;*/           top,              /*
  right         dw      0                                                   ;*/           right,            /*
  bottom        dw      0                                                   ;*/           bottom;           /*

RECT            ends                                                        ;*/ } RECT;                     /*
                                                                            ;*/ typedef RECT  *PRECT;       /*

    if      0
*/
#endif
/*
    endif


BOXTYPE         struc                                                       ;*/ typedef     struct {        /*

  min           db      SIZE PTTYPE dup (?)   ;x,y starting coord           ;*/ PTTYPE min;                 /*
  ext           db      SIZE PTTYPE dup (?)   ;x,y extents                  ;*/ PTTYPE ext;                 /*

BOXTYPE         ends                                                        ;*/ } BOXTYPE;                  /*


                                                                            ;*/ typedef RECT  FAR * LPRECT; /*

page
;       Logical Object Definitions  - incLogical
                ifdef   incLogical
                if      incLogical



OBJ_PEN         equ     1
OBJ_BRUSH       equ     2
OBJ_FONT        equ     3

    if  0
*/
/* Object definitions used by GDI support routines written in C */

#define OBJ_PEN         1
#define OBJ_BRUSH       2
#define OBJ_FONT        3
/*
    endif


LogBrush        struc                                                       ;*/ typedef struct {            /*
  lbStyle       dw      0               ;Style of logical BRUSH             ;*/ unsigned short int lbStyle; /*
  lbColor       dd      0               ;RGB color                          ;*/ unsigned long int  lbColor; /*
  lbHatch       dw      0               ;Hatching style                     ;*/ unsigned short int lbHatch; /*
  lbBkColor     dd      0               ;Background color for hatched brush ;*/ unsigned long int lbBkColor;/*
  lbhcmXform    dd      0               ;transform for image color matching ;*/ unsigned long int lbhcmXform;/*
LogBrush        ends                                                        ;*/ } LOGBRUSH;                 /*

;lbPattern      =       lbColor          ; pointer to physical pattern

    if  0
*/
#define lbPattern       lbColor
/*
    endif



;       Brush styles defined by GDI

BS_SOLID        equ     0
BS_HOLLOW       equ     1
BS_HATCHED      equ     2
BS_PATTERN      equ     3

MaxBrushStyle   equ     3



;       Hatched Brush hatching styles defined by GDI

HS_HORIZONTAL   equ     0               ; Horizontal             -----
HS_VERTICAL     equ     1               ; Vertical               |||||
HS_FDIAGONAL    equ     2               ; Foreward Diagonal      /////
HS_BDIAGONAL    equ     3               ; Backward Diagonal      \\\\\
HS_CROSS        equ     4               ; Cross                  +++++
HS_DIAGCROSS    equ     5               ; Diagonal Cross         XXXXX

MaxHatchStyle   equ     5

    if  0
*/
/* Brush Style definitions used by GDI support routines written in C */

#define     BS_SOLID            0
#define     BS_HOLLOW           1
#define     BS_HATCHED          2
#define     BS_PATTERN          3

#define     MaxBrushStyle       3


/* Hatch Style definitions used by GDI support routines written in C */

#define     HS_HORIZONTAL       0       /* ----- */
#define     HS_VERTICAL         1       /* ||||| */
#define     HS_FDIAGONAL        2       /* ///// */
#define     HS_BDIAGONAL        3       /* \\\\\ */
#define     HS_CROSS            4       /* +++++ */
#define     HS_DIAGCROSS        5       /* xxxxx */

#define     MaxHatchStyle       5
/*
    endif




;       Logical Pen Structure

LogPen          struc                                                       ;*/ typedef struct {            /*
  lopnStyle     dw      0               ;(solid, hollow, dashed..)          ;*/ unsigned short int lopnStyle;/*
  lopnWidth     dw      0               ;This is really a point type        ;*/ PTTYPE             lopnWidth;/*
                dw      0
  lopnColor     dd      0                                                   ;*/ unsigned long int  lopnColor;/*
  lopnStyle2    dw      0               ;end caps and joins                 ;*/ unsigned short int lopnStyle2;/*
  lopnhcmXform  dd      0               ;transform for image color matching ;*/ unsigned long int  lopnhcmXform;/*
LogPen          ends                                                        ;*/ } LOGPEN;                   /*

;                errnz   <(SIZE PTTYPE) -4>



;       Line Style definitions for lopnStyle

LS_SOLID        equ       0
LS_DASHED       equ       1
LS_DOTTED       equ       2
LS_DOTDASHED    equ       3
LS_DASHDOTDOT   equ       4
LS_NOLINE       equ       5
LS_INSIDEFRAME  equ       6
MaxLineStyle    equ     LS_NOLINE

;       Line Style definitions for lopnStyle2

LS_ENDCAP_FLAT  equ     01h
LS_ENDCAP_ROUND equ     02h
LS_ENDCAP_SQUARE equ    04h
LS_JOIN_BEVEL   equ     08h
LS_JOIN_MITER   equ     10h
LS_JOIN_ROUND   equ     20h

    if  0
*/
/* Line Style definitions used by GDI support routines written in C */

#define     LS_SOLID            0
#define     LS_DASHED           1
#define     LS_DOTTED           2
#define     LS_DOTDASHED        3
#define     LS_DASHDOTDOT       4
#define     LS_NOLINE           5
#define     LS_INSIDEFRAME      6
#define     MaxLineStyle        LS_NOLINE

#define     LS_ENDCAP_FLAT      0x01
#define     LS_ENDCAP_ROUND     0x02
#define     LS_ENDCAP_SQUARE    0x04
#define     LS_JOIN_BEVEL       0x08
#define     LS_JOIN_MITER       0x10
#define     LS_JOIN_ROUND       0x20

/*
    endif



; Various constants for defining a logical font.
LF_FACESIZE             equ     32
OUT_DEFAULT_PRECIS      equ     0
OUT_STRING_PRECIS       equ     1
OUT_CHARACTER_PRECIS    equ     2
OUT_STROKE_PRECIS       equ     3
OUT_TT_PRECIS           equ     4
OUT_DEVICE_PRECIS       equ     5
OUT_RASTER_PRECIS       equ     6
OUT_TT_ONLY_PRECIS      equ     7

CLIP_DEFAULT_PRECIS     equ     0
CLIP_CHARACTER_PRECIS   equ     1
CLIP_STROKE_PRECIS      equ     2
CLIP_MASK               equ     00Fh
CLIP_LH_ANGLES          equ     010h
CLIP_TT_ALWAYS          equ     020h
CLIP_EMBEDDED           equ     080h

DEFAULT_QUALITY         equ     0
DRAFT_QUALITY           equ     1
PROOF_QUALITY           equ     2

DEFAULT_PITCH           equ     0
FIXED_PITCH             equ     1
VARIABLE_PITCH          equ     2

ANSI_CHARSET            equ     0
DEFAULT_CHARSET         equ     1
SYMBOL_CHARSET          equ     2
MAC_CHARSET             equ     77
SHIFTJIS_CHARSET        equ     128
HANGEUL_CHARSET         equ     129
CHINESEBIG5_CHARSET     equ     136
OEM_CHARSET             equ     255



;       GDI font families.
FF_DONTCARE             equ 00000000b   ; Don't care or don't know.
FF_ROMAN                equ 00010000b   ; Variable stroke width, serifed.
                                        ; Times Roman, Century Schoolbook, etc.
FF_SWISS                equ 00100000b   ; Variable stroke width, sans-serifed.
                                        ; Helvetica, Swiss, etc.
FF_MODERN               equ 00110000b   ; Constant stroke width, serifed or sans-serifed.
                                        ; Pica, Elite, Courier, etc.
FF_SCRIPT               equ 01000000b   ; Cursive, etc.
FF_DECORATIVE           equ 01010000b   ; Old English, etc.


;       Font weights lightest to darkest.
FW_DONTCARE             equ     0d
FW_THIN                 equ     100d
FW_EXTRALIGHT           equ     200d
FW_LIGHT                equ     300d
FW_NORMAL               equ     400d
FW_MEDIUM               equ     500d
FW_SEMIBOLD             equ     600d
FW_BOLD                 equ     700d
FW_EXTRABOLD            equ     800d
FW_HEAVY                equ     900d

FW_ULTRALIGHT           equ     FW_EXTRALIGHT
FW_REGULAR              equ     FW_NORMAL
FW_DEMIBOLD             equ     FW_SEMIBOLD
FW_ULTRABOLD            equ     FW_EXTRABOLD
FW_BLACK                equ     FW_HEAVY


; Enumeration font types.
RASTER_FONTTYPE         equ     1
DEVICE_FONTTYPE         equ     2

    if  0
*/

/* The size to allocate for the lfFaceName field in the logical font. */
#ifndef     LF_FACESIZE
#define     LF_FACESIZE     32
#endif

/* Various constants for defining a logical font. */
#define     OUT_DEFAULT_PRECIS      0
#define     OUT_STRING_PRECIS       1
#define     OUT_CHARACTER_PRECIS    2
#define     OUT_STROKE_PRECIS       3
#define     OUT_TT_PRECIS           4
#define     OUT_DEVICE_PRECIS       5
#define     OUT_RASTER_PRECIS       6
#define     OUT_TT_ONLY_PRECIS      7

#define     CLIP_DEFAULT_PRECIS     0
#define     CLIP_CHARACTER_PRECIS   1
#define     CLIP_STROKE_PRECIS      2
#define     CLIP_MASK               0x0F
#define     CLIP_LH_ANGLES          0x10
#define     CLIP_TT_ALWAYS          0x20
#define     CLIP_EMBEDDED           0x80

#define     DEFAULT_QUALITY         0
#define     DRAFT_QUALITY           1
#define     PROOF_QUALITY           2

#define     DEFAULT_PITCH           0
#define     FIXED_PITCH             1
#define     VARIABLE_PITCH          2

#define     ANSI_CHARSET            0
#define     DEFAULT_CHARSET         1
#define     SYMBOL_CHARSET          2
#define     MAC_CHARSET             77
#define     SHIFTJIS_CHARSET        128
#define     HANGEUL_CHARSET         129
#define     CHINESEBIG5_CHARSET     136
#define     OEM_CHARSET             255


/*      GDI font families.                                              */
#define FF_DONTCARE     (0<<4)  /* Don't care or don't know.            */
#define FF_ROMAN        (1<<4)  /* Variable stroke width, serifed.      */
                                /* Times Roman, Century Schoolbook, etc.*/
#define FF_SWISS        (2<<4)  /* Variable stroke width, sans-serifed. */
                                /* Helvetica, Swiss, etc.               */
#define FF_MODERN       (3<<4)  /* Constant stroke width, serifed or sans-serifed. */
                                /* Pica, Elite, Courier, etc.           */
#define FF_SCRIPT       (4<<4)  /* Cursive, etc.                        */
#define FF_DECORATIVE   (5<<4)  /* Old English, etc.                    */


/*      Font weights lightest to darkest.                               */
#define FW_DONTCARE             0
#define FW_THIN                 100
#define FW_EXTRALIGHT           200
#define FW_LIGHT                300
#define FW_NORMAL               400
#define FW_MEDIUM               500
#define FW_SEMIBOLD             600
#define FW_BOLD                 700
#define FW_EXTRABOLD            800
#define FW_HEAVY                900

#define FW_ULTRALIGHT           FW_EXTRALIGHT
#define FW_REGULAR              FW_NORMAL
#define FW_DEMIBOLD             FW_SEMIBOLD
#define FW_ULTRABOLD            FW_EXTRABOLD
#define FW_BLACK                FW_HEAVY

/* Enumeration font types. */
#define     RASTER_FONTTYPE         1
#define     DEVICE_FONTTYPE         2

/*
    endif


LogFont         struc                                                       ;*/ typedef     struct  {          /*

  lfHeight            dw      0                                             ;*/ short int lfHeight;            /*
  lfWidth             dw      0                                             ;*/ short int lfWidth;             /*
  lfEscapement        dw      0                                             ;*/ short int lfEscapement;        /*
  lfOrientation       dw      0                                             ;*/ short int lfOrientation;       /*
  lfWeight            dw      0                                             ;*/ short int lfWeight;            /*
  lfItalic            db      0                                             ;*/ BYTE lfItalic;                 /*
  lfUnderline         db      0                                             ;*/ BYTE lfUnderline;              /*
  lfStrikeOut         db      0                                             ;*/ BYTE lfStrikeOut;              /*
  lfCharSet           db      0                                             ;*/ BYTE lfCharSet;                /*
  lfOutPrecision      db      0                                             ;*/ BYTE lfOutPrecision;           /*
  lfClipPrecision     db      0                                             ;*/ BYTE lfClipPrecision;          /*
  lfQuality           db      0                                             ;*/ BYTE lfQuality;                /*
  lfPitchAndFamily    db      0                                             ;*/ BYTE lfPitchAndFamily;         /*
  lfFaceName          db LF_FACESIZE dup(0) ; A variable length field for the face name.;*/ BYTE lfFaceName[LF_FACESIZE];  /*

LogFont         ends                                                        ;*/ } LOGFONT;                     /*


                endif
                endif
page
;               Device Definitions - incDevice


                ifdef   incDevice
                if      incDevice


InquireInfo     =       00000001b       ;Inquire Device GDI Info
EnableDevice    =       00000000b       ;Enable Device
InfoContext     =           8000h       ;Inquire/Enable for information context


;               Device Technologies

DT_PLOTTER      equ     0               ; Vector plotter
DT_RASDISPLAY   equ     1               ; Raster display
DT_RASPRINTER   equ     2               ; Raster printer
DT_RASCAMERA    equ     3               ; Raster camera
DT_CHARSTREAM   equ     4               ; Character-stream, PLP
DT_METAFILE     equ     5               ; Metafile, VDM
DT_DISPFILE     equ     6               ; Display-file
DT_JUMBO        equ     11              ; SPAG LJ cool thing

;               Curve Capabilities

CC_NONE         equ 0000000000000000B   ; Curves not supported
CC_CIRCLES      equ 0000000000000001B   ; Can do circles
CC_PIE          equ 0000000000000010B   ; Can do pie wedges
CC_CHORD        equ 0000000000000100B   ; Can do chord arcs
CC_ELLIPSES     equ 0000000000001000B   ; Can do ellipses (full arcs)
CC_WIDE         equ 0000000000010000B   ; Can do wide lines
CC_STYLED       equ 0000000000100000B   ; Can do styled lines
CC_WIDESTYLED   equ 0000000001000000B   ; Can do wide styled lines
CC_INTERIORS    equ 0000000010000000B   ; Can do interiors
CC_ROUNDRECT    equ 0000000100000000B   ; Can do round rectangles
CC_POLYBEZIER   equ 0000001000000000B   ; Can do beziers


;               Line Capabilities

LC_NONE         equ     00000000B       ; Lines not supported
LC_POLYSCANLINE equ     00000001B       ; Poly Scanlines supported
LC_POLYLINE     equ     00000010B       ; Can do polylines
LC_MARKER       equ     00000100B       ; Can do markers
LC_POLYMARKER   equ     00001000B       ; Can do polymarkers
LC_WIDE         equ     00010000B       ; Can do wide lines
LC_STYLED       equ     00100000B       ; Can do styled lines
LC_WIDESTYLED   equ     01000000B       ; Can do wide styled lines
LC_INTERIORS    equ     10000000B       ; Can do interiors


;               Polygonal Capabilities

PC_NONE         equ 0000000000000000B   ; Polygonals not supported
PC_ALTPOLYGON   equ 0000000000000001B   ; Can do alternate polygons
PC_POLYGON      equ 0000000000000001B   ; an old name for ALTPOLYGON
PC_RECTANGLE    equ 0000000000000010B   ; Can do rectangles
PC_WINDPOLYGON  equ 0000000000000100B   ; Can do winding polygons
PC_TRAPEZOID    equ 0000000000000100B   ; an old name for WINDPOLYGON
PC_SCANLINE     equ 0000000000001000B   ; Can do scanlines
PC_WIDE         equ 0000000000010000B   ; Can do wide borders
PC_STYLED       equ 0000000000100000B   ; Can do styled borders
PC_WIDESTYLED   equ 0000000001000000B   ; Can do wide styled borders
PC_INTERIORS    equ 0000000010000000B   ; Can do interiors
PC_POLYPOLYGON  equ 0000000100000000B   ; Can do PolyPolygons
PC_PATHS        equ 0000001000000000B   ; Can do Paths

;               Clipping Capabilities

CP_NONE         equ     00000000B       ; No clipping at device level
CP_RECTANGLE    equ     00000001B       ; Device Output clips to rectangles
CP_REGION       equ     00000010B       ; Not supported.
CP_REGION32     equ     00000100B       ; Device Output clips to regions

;               Text Capabilities

TC_OP_CHARACTER equ 0000000000000001B   ; Can do OutputPrecision   CHARACTER
TC_OP_STROKE    equ 0000000000000010B   ; Can do OutputPrecision   STROKE
TC_CP_STROKE    equ 0000000000000100B   ; Can do ClipPrecision     STROKE
TC_CR_90        equ 0000000000001000B   ; Can do CharRotAbility    90
TC_CR_ANY       equ 0000000000010000B   ; Can do CharRotAbility    ANY
TC_SF_X_YINDEP  equ 0000000000100000B   ; Can do ScaleFreedom      X_YINDEPENDENT
TC_SA_DOUBLE    equ 0000000001000000B   ; Can do ScaleAbility      DOUBLE
TC_SA_INTEGER   equ 0000000010000000B   ; Can do ScaleAbility      INTEGER
TC_SA_CONTIN    equ 0000000100000000B   ; Can do ScaleAbility      CONTINUOUS
TC_EA_DOUBLE    equ 0000001000000000B   ; Can do EmboldenAbility   DOUBLE
TC_IA_ABLE      equ 0000010000000000B   ; Can do ItalisizeAbility  ABLE
TC_UA_ABLE      equ 0000100000000000B   ; Can do UnderlineAbility  ABLE
TC_SO_ABLE      equ 0001000000000000B   ; Can do StrikeOutAbility  ABLE
TC_RA_ABLE      equ 0010000000000000B   ; Can do RasterFontAble    ABLE
TC_VA_ABLE      equ 0100000000000000B   ; Can do VectorFontAble    ABLE
TC_RESERVED     equ 1000000000000000B   ; Reserved. Must be returned zero.

;               Raster Capabilities

RC_NONE         equ 0000000000000000b   ; No Raster Capabilities
RC_BITBLT       equ 0000000000000001b   ; Can do bitblt
RC_BANDING      equ 0000000000000010b   ; Requires banding support
RC_SCALING      equ 0000000000000100b   ; does scaling while banding
RC_BITMAP64     equ 0000000000001000b   ; supports >64k bitmaps
RC_GDI20_OUTPUT equ 0000000000010000b   ; has 2.0 output calls
RC_GDI20_STATE  equ 0000000000100000b   ; dc has a state block
RC_SAVEBITMAP   equ 0000000001000000b   ; can save bitmaps locally
RC_DI_BITMAP    equ 0000000010000000b   ; can do device independent bitmaps
RC_PALETTE      equ 0000000100000000b   ; can do color palette management
RC_DIBTODEV     equ 0000001000000000b   ; can do SetDIBitsToDevice
RC_BIGFONT      equ 0000010000000000b   ; does BIGFONTs
RC_STRETCHBLT   equ 0000100000000000b   ; can do StretchBlt
RC_FLOODFILL    equ 0001000000000000b   ; can do FloodFill
RC_STRETCHDIB   equ 0010000000000000b   ; can do StretchDIBits
RC_OP_DX_OUTPUT equ 0100000000000000b   ;dev opaque and dx array capable
RC_DEVBITS      equ 1000000000000000b   ; supports device bitmaps

;       DC Management Flags

DC_SPDevice   equ 00000001b     ;Seperate PDevice required per device/filename
DC_1PDevice   equ 00000010b     ;Only 1 PDevice allowed per device/filename
DC_IgnoreDFNP equ 00000100b     ;Ignore device/filename pairs when matching

;               dpCaps1 capability bits

C1_TRANSPARENT  equ 0000000000000001b   ; supports transparency
TC_TT_ABLE      equ 0000000000000010b   ; can do TT fonts through DDI or brute
C1_TT_CR_ANY    equ 0000000000000100b   ; can do rotated TT fonts
C1_EMF_COMPLIANT equ 0000000000001000b  ; Win95 - supports metafile spooling
C1_DIBENGINE    equ 0000000000010000b   ; DIB Engine compliant driver
C1_GAMMA_RAMP   equ 0000000000100000b   ; supports gamma ramp setting
C1_ICM          equ 0000000001000000b   ; does some form of ICM support
C1_REINIT_ABLE  equ 0000000010000000b   ; driver supports ReEnable call
C1_GLYPH_INDEX  equ 0000000100000000b   ; Driver supports glyph index fonts
C1_BIT_PACKED   equ 0000001000000000b   ; Supports bit-packed glyphs
C1_BYTE_PACKED  equ 0000010000000000b   ; Supports byte-packed glyphs
C1_COLORCURSOR  equ 0000100000000000b   ; Supports color-cursors and async SetCursor
C1_CMYK_ABLE    equ 0001000000000000b   ; Supports CMYK ColorRefs
C1_SLOW_CARD    equ 0010000000000000b   ; Little or no acceleration (VGA, etc.)


;               dpCapsFE capability bits

FEC_TT_DBCS     equ 0000000000100000b   ; can output DBCS TT fonts correctly
FEC_WIFE_ABLE   equ 0000000010000000b   ; can handle WIFE font as Engine font

        if      0
*/

#define     InquireInfo     0x01        /* Inquire Device GDI Info         */
#define     EnableDevice    0x00        /* Enable Device                   */
#define     InfoContext     0x8000      /* Inquire/Enable for info context */

/*              Device Technologies                                */

#define     DT_PLOTTER          0       /* Vector plotter          */
#define     DT_RASDISPLAY       1       /* Raster display          */
#define     DT_RASPRINTER       2       /* Raster printer          */
#define     DT_RASCAMERA        3       /* Raster camera           */
#define     DT_CHARSTREAM       4       /* Character-stream, PLP   */
#define     DT_METAFILE         5       /* Metafile, VDM           */
#define     DT_DISPFILE         6       /* Display-file            */
#define     DT_JUMBO            11      /* SPAG LJ cool thing      */

/*              Curve Capabilities                                 */

#define     CC_NONE         0x0000      /* Curves not supported    */
#define     CC_CIRCLES      0x0001      /* Can do circles          */
#define     CC_PIE          0x0002      /* Can do pie wedges       */
#define     CC_CHORD        0x0004      /* Can do chord arcs       */
#define     CC_ELLIPSES     0x0008      /* Can do ellipese         */
#define     CC_WIDE         0x0010      /* Can do wide lines       */
#define     CC_STYLED       0x0020      /* Can do styled lines     */
#define     CC_WIDESTYLED   0x0040      /* Can do wide styled lines*/
#define     CC_INTERIORS    0x0080      /* Can do interiors        */
#define     CC_ROUNDRECT    0x0100      /* Can do round rectangles */
#define     CC_POLYBEZIER   0x0200      /* Can do polybeziers      */

/*               Line Capabilities                                 */

#define     LC_NONE         0x0000      /* Lines not supported     */
#define     LC_POLYSCANLINE 0x0001      /* Poly Scanlines supported*/
#define     LC_POLYLINE     0x0002      /* Can do polylines        */
#define     LC_MARKER       0x0004      /* Can do markers          */
#define     LC_POLYMARKER   0x0008      /* Can do polymarkers      */
#define     LC_WIDE         0x0010      /* Can do wide lines       */
#define     LC_STYLED       0x0020      /* Can do styled lines     */
#define     LC_WIDESTYLED   0x0040      /* Can do wide styled lines*/
#define     LC_INTERIORS    0x0080      /* Can do interiors        */

/*               Polygonal Capabilities                            */

#define     PC_NONE         0x0000      /* Polygonals not supported*/
#define     PC_ALTPOLYGON   0x0001      /* Can do even odd polygons*/
#define     PC_POLYGON      0x0001      /* old name for ALTPOLYGON */
#define     PC_RECTANGLE    0x0002      /* Can do rectangles       */
#define     PC_WINDPOLYGON  0x0004      /* Can do winding polygons */
#define     PC_TRAPEZOID    0x0004      /* old name for WINDPOLYGON*/
#define     PC_SCANLINE     0x0008      /* Can do scanlines        */
#define     PC_WIDE         0x0010      /* Can do wide borders     */
#define     PC_STYLED       0x0020      /* Can do styled borders   */
#define     PC_WIDESTYLED   0x0040      /* Can do wide styled borders*/
#define     PC_INTERIORS    0x0080      /* Can do interiors        */
#define     PC_POLYPOLYGON  0x0100      /* Can do PolyPolygons     */

/*               Clipping Capabilities                             */

#define     CP_NONE         0x0000      /* no clipping of Output   */
#define     CP_RECTANGLE    0x0001      /* Output clipped to Rects */
#define     CP_REGION       0x0002      /* not supported           */
#define     CP_REGION32     0x0004      /* Output clipped to regions */

/*               Text Capabilities                                             */

#define TC_OP_CHARACTER 0x0001     /* Can do OutputPrecision    CHARACTER      */
#define TC_OP_STROKE    0x0002     /* Can do OutputPrecision    STROKE         */
#define TC_CP_STROKE    0x0004     /* Can do ClipPrecision      STROKE         */
#define TC_CR_90        0x0008     /* Can do CharRotAbility     90             */
#define TC_CR_ANY       0x0010     /* Can do CharRotAbility     ANY            */
#define TC_SF_X_YINDEP  0x0020     /* Can do ScaleFreedom       X_YINDEPENDENT */
#define TC_SA_DOUBLE    0x0040     /* Can do ScaleAbility       DOUBLE         */
#define TC_SA_INTEGER   0x0080     /* Can do ScaleAbility       INTEGER        */
#define TC_SA_CONTIN    0x0100     /* Can do ScaleAbility       CONTINUOUS     */
#define TC_EA_DOUBLE    0x0200     /* Can do EmboldenAbility    DOUBLE         */
#define TC_IA_ABLE      0x0400     /* Can do ItalisizeAbility   ABLE           */
#define TC_UA_ABLE      0x0800     /* Can do UnderlineAbility   ABLE           */
#define TC_SO_ABLE      0x1000     /* Can do StrikeOutAbility   ABLE           */
#define TC_RA_ABLE      0x2000     /* Can do RasterFontAble     ABLE           */
#define TC_VA_ABLE      0x4000     /* Can do VectorFontAble     ABLE           */
#define TC_RESERVED     0x8000     /* Reserved. Must be returned zero.        */

/*               Raster Capabilities                               */

#define RC_NONE         0x0000          /* No Raster Capabilities       */
#define RC_BITBLT       0x0001          /* Can do bitblt                */
#define RC_BANDING      0x0002          /* Requires banding support     */
#define RC_SCALING      0x0004          /* does scaling while banding   */
#define RC_BITMAP64     0x0008          /* supports >64k bitmaps        */
#define RC_GDI20_OUTPUT 0x0010          /* has 2.0 output calls         */
#define RC_GDI20_STATE  0x0020          /* dc has a state block         */
#define RC_SAVEBITMAP   0x0040          /* can save bitmaps locally     */
#define RC_DI_BITMAP    0x0080          /* can do DIBs                  */
#define RC_PALETTE      0x0100          /* can do color pal management  */
#define RC_DIBTODEV     0x0200          /* can do SetDIBitsToDevice     */
#define RC_BIGFONT      0x0400          /* can do BIGFONTs              */
#define RC_STRETCHBLT   0x0800          /* can do StretchBlt            */
#define RC_FLOODFILL    0x1000          /* can do FloodFill             */
#define RC_STRETCHDIB   0x2000          /* can do StretchDIBits         */
#define RC_OP_DX_OUTPUT 0x4000          /* can do smart ExtTextOut w/dx */
#define RC_DEVBITS      0x8000          /* supports device bitmaps      */

/*      DC Management Flags                                        */

#define DC_SPDevice     0000001     /* Seperate PDevice required per device/filename */
#define DC_1PDevice     0000002     /* Only 1 PDevice allowed per device/filename    */
#define DC_IgnoreDFNP   0000004     /* Ignore device/filename pairs when matching    */

/*      dpCaps1 capability bits                                             */

#define C1_TRANSPARENT  0x0001      /* supports transparency                */
#define TC_TT_ABLE      0x0002      /* can do TT through DDI or brute       */
#define C1_TT_CR_ANY    0x0004      /* can do rotated TT fonts              */
#define C1_EMF_COMPLIANT 0x0008     /* Win95 - supports metafile spooling   */
#define C1_DIBENGINE    0x0010      /* DIB Engine compliant driver          */
#define C1_GAMMA_RAMP   0x0020      /* supports gamma ramp setting          */
#define C1_ICM          0x0040      /* does some form of ICM support        */
#define C1_REINIT_ABLE  0x0080      /* Driver supports ReEnable             */
#define C1_GLYPH_INDEX  0x0100      /* Driver supports glyph index fonts    */
#define C1_BIT_PACKED   0x0200      /* Supports bit-packed glyphs           */
#define C1_BYTE_PACKED  0x0400      /* Supports byte-packed glyphs          */
#define C1_COLORCURSOR  0x0800      /* Driver supports color_cursors and async SetCursor */
#define C1_CMYK_ABLE    0x1000      /* Driver supports CMYK ColorRefs       */

/*      dpCapsFE capability bits                                            */

#define FEC_TT_DBCS     0x0020      /* can output DBCS TT fonts correctly   */
#define FEC_WIFE_ABLE   0x0080      /* can handle WIFE font as Engine font  */

/*
        endif

GDIINFO         struc                                                       ;*/ typedef struct {           /*

  dpVersion     dw      0       ; Version = 0100h for now                   ;*/ short int dpVersion;       /*
  dpTechnology  dw      0       ; Device classification                     ;*/ short int dpTechnology;    /*
  dpHorzSize    dw      0       ; Horizontal size in millimeters            ;*/ short int dpHorzSize;      /*
  dpVertSize    dw      0       ; Vertical   size in millimeters            ;*/ short int dpVertSize;      /*
  dpHorzRes     dw      0       ; Horizontal width in pixels                ;*/ short int dpHorzRes;       /*
  dpVertRes     dw      0       ; Vertical   width in pixels                ;*/ short int dpVertRes;       /*
  dpBitsPixel   dw      0       ; Number of bits per pixel                  ;*/ short int dpBitsPixel;     /*
  dpPlanes      dw      0       ; Number of planes                          ;*/ short int dpPlanes;        /*
  dpNumBrushes  dw      0       ; Number of brushes the device has          ;*/ short int dpNumBrushes;    /*
  dpNumPens     dw      0       ; Number of pens the device has             ;*/ short int dpNumPens;       /*
  dpCapsFE      dw      0       ; capability bits for Far East              ;*/ short int dpCapsFE;        /*
  dpNumFonts    dw      0       ; Number of fonts the device has            ;*/ short int dpNumFonts;      /*
  dpNumColors   dw      0       ; Number of colors in color table           ;*/ short int dpNumColors;     /*
  dpDEVICEsize  dw      0       ; Size required for the device descriptor   ;*/ short int dpDEVICEsize;    /*
  dpCurves      dw      0       ; Curves    capabilities                    ;*/ unsigned short int         /*
                                                                            ;*/              dpCurves;     /*
  dpLines       dw      0       ; Line      capabilities                    ;*/ unsigned short int         /*
                                                                            ;*/              dpLines;      /*
  dpPolygonals  dw      0       ; Polygonal capabilities                    ;*/ unsigned short int         /*
                                                                            ;*/              dpPolygonals; /*
  dpText        dw      0       ; Text      capabilities                    ;*/ unsigned short int         /*
                                                                            ;*/              dpText;       /*
  dpClip        dw      0       ; Clipping  capabilities                    ;*/ unsigned short int         /*
                                                                            ;*/              dpClip;       /*
  dpRaster      dw      0       ; Bitblt    capabilities                    ;*/ unsigned short int         /*
                                                                            ;*/              dpRaster;     /*
  dpAspectX     dw      0       ; Length of X leg                           ;*/ short int dpAspectX;       /*
  dpAspectY     dw      0       ; Length of Y leg                           ;*/ short int dpAspectY;       /*
  dpAspectXY    dw      0       ; Length of hypotenuse                      ;*/ short int dpAspectXY;      /*
  dpStyleLen    dw      0       ; Length of segment for line styles         ;*/ short int dpStyleLen;      /*
  dpMLoWin      dw      0       ; Metric  Lo res WinX,WinY  (PTTYPE)        ;*/ PTTYPE    dpMLoWin;        /*
                dw      0
  dpMLoVpt      dw      0       ; Metric  Lo res VptX,VptY  (PTTYPE)        ;*/ PTTYPE    dpMLoVpt;        /*
                dw      0
  dpMHiWin      dw      0       ; Metric  Hi res WinX,WinY  (PTTYPE)        ;*/ PTTYPE    dpMHiWin;        /*
                dw      0
  dpMHiVpt      dw      0       ; Metric  Hi res VptX,VptY  (PTTYPE)        ;*/ PTTYPE    dpMHiVpt;        /*
                dw      0
  dpELoWin      dw      0       ; English Lo res WinX,WinY  (PTTYPE)        ;*/ PTTYPE    dpELoWin;        /*
                dw      0
  dpELoVpt      dw      0       ; English Lo res VptX,VptY  (PTTYPE)        ;*/ PTTYPE    dpELoVpt;        /*
                dw      0
  dpEHiWin      dw      0       ; English Hi res WinX,WinY  (PTTYPE)        ;*/ PTTYPE    dpEHiWin;        /*
                dw      0
  dpEHiVpt      dw      0       ; English Hi res VptX,VptY  (PTTYPE)        ;*/ PTTYPE    dpEHiVpt;        /*
                dw      0
  dpTwpWin      dw      0       ; Twips          WinX,WinY  (PTTYPE)        ;*/ PTTYPE    dpTwpWin;        /*
                dw      0
  dpTwpVpt      dw      0       ; Twips          VptX,VptY  (PTTYPE)        ;*/ PTTYPE    dpTwpVpt;        /*
                dw      0
  dpLogPixelsX  dw      0       ;Logical pixels/inch in X                   ;*/ short int dpLogPixelsX;    /*
  dpLogPixelsY  dw      0       ;Logical pixels/inch in Y                   ;*/ short int dpLogPixelsY;    /*
  dpDCManage    dw      0       ;DC Management flags                        ;*/ short int dpDCManage;      /*
  dpCaps1       dw      0       ; more capability bits                      ;*/ unsigned short int dpCaps1;     /*
  dpSpotSizeX   dw      0                                                   ;*/ short int futureuse4;           /*
                dw      0                                                   ;*/ short int futureuse5;           /*
  dpSpotSizeY   dw      0                                                   ;*/ short int futureuse6;           /*
                dw      0                                                   ;*/ short int futureuse7;           /*

; start of entries in version 3.0 of this structure

  dpNumPalReg   dw      0       ; Number of entries in device's palette     ;*/ WORD dpNumPalReg;          /*
  dpPalReserved dw      0       ; Number of reserved entries palette        ;*/ WORD dpPalReserved;        /*
  dpColorRes    dw      0       ; bits of color resolution (total)          ;*/ WORD dpColorRes;           /*
GDIINFO         ends                                                        ;*/ } GDIINFO;                 /*

                endif
                endif


page
;       Font Definitions
                ifdef   incFont
                if      incFont

; flags for extended textout

ETO_GRAYED      equ     0001h
ETO_OPAQUE      equ     0002h
ETO_CLIPPED     equ     0004h
ETO_GLYPH_INDEX equ     0010h
ETO_RTL         equ     0080h
ETO_BYTE_PACKED equ     0100h
ETO_BIT_PACKED  equ     0200h
ETO_LEVEL_MODE  equ     1000h

PF_BITS_IS_ADDRESS  equ     4
PF_DEVICE_REALIZED  equ     10000000B
PF_RASTER_TYPE      equ     0
PF_VECTOR_TYPE      equ     1
PF_OTHER1_TYPE      equ     2
PF_OTHER2_TYPE      equ     3
PF_GLYPH_INDEX      equ    20h
PF_WIFE_TYPE        equ    08h


; Glyph types for EngineGetGlyphBmp
EGB_BITMAP          equ     1
EGB_OUTLINE         equ     2
EGB_GRAY2_BITMAP    equ     8
EGB_GRAY4_BITMAP    equ     9
EGB_GRAY8_BITMAP    equ    10


    if  0
*/

/* This bit in the dfType field signals that the dfBitsOffset field is an
   absolute memory address and should not be altered. */
#define PF_BITS_IS_ADDRESS  4

/* This bit in the dfType field signals that the font is device realized. */
#define PF_DEVICE_REALIZED  0x80

/* These bits in the dfType give the fonttype -
       raster, vector, other1, other2. */
#define PF_RASTER_TYPE      0
#define PF_VECTOR_TYPE      1
#define PF_OTHER1_TYPE      2
#define PF_OTHER2_TYPE      3
#define PF_GLYPH_INDEX   0x20
#define PF_WIFE_TYPE     0x08

/* Glyph types for EngineGetGlyphBmp */
#define EGB_BITMAP          1
#define EGB_OUTLINE         2
#define EGB_GRAY2_BITMAP    8
#define EGB_GRAY4_BITMAP    9
#define EGB_GRAY8_BITMAP   10


/* The size to allocate for the dfMaps field in the physical font. */
#ifndef     DF_MAPSIZE
#define     DF_MAPSIZE      1
#endif

/*
    endif


;       Font data structure passed to OEM routines.  Refer to chapters 12 and
;       13 of the OEM adaptation guide for a complete description.


FONTINFO        struc                                                       ;*/ typedef     struct  {          /*

  dfType            dw      0   ; Type field for the font.                  ;*/ short int   dfType;            /*
  dfPoints          dw      0   ; Point size of font.                       ;*/ short int   dfPoints;          /*
  dfVertRes         dw      0   ; Vertical digitization.                    ;*/ short int   dfVertRes;         /*
  dfHorizRes        dw      0   ; Horizontal digitization.                  ;*/ short int   dfHorizRes;        /*
  dfAscent          dw      0   ; Baseline offset from char cell top.       ;*/ short int   dfAscent;          /*
  dfInternalLeading dw      0   ; Internal leading included in font         ;*/ short int   dfInternalLeading; /*
  dfExternalLeading dw      0   ; Prefered extra space between lines        ;*/ short int   dfExternalLeading; /*
  dfItalic          db      0   ; Flag specifying if italic.                ;*/ BYTE        dfItalic;          /*
  dfUnderline       db      0   ; Flag specifying if underlined.            ;*/ BYTE        dfUnderline;       /*
  dfStrikeOut       db      0   ; Flag specifying if struck out.            ;*/ BYTE        dfStrikeOut;       /*
  dfWeight          dw      0   ; Weight of font.                           ;*/ short int   dfWeight;          /*
  dfCharSet         db      0   ; Character set of font.                    ;*/ BYTE        dfCharSet;         /*
  dfPixWidth        dw      0   ; Width field for the font.                 ;*/ short int   dfPixWidth;        /*
  dfPixHeight       dw      0   ; Height field for the font.                ;*/ short int   dfPixHeight;       /*
  dfPitchAndFamily  db      0   ; Flag specifying variable pitch, family.   ;*/ BYTE        dfPitchAndFamily;  /*
  dfAvgWidth        dw      0   ; Average character width.                  ;*/ short int   dfAvgWidth;        /*
  dfMaxWidth        dw      0   ; Maximum character width.                  ;*/ short int   dfMaxWidth;        /*
  dfFirstChar       db      0   ; First character in the font.              ;*/ BYTE        dfFirstChar;       /*
  dfLastChar        db      0   ; Last character in the font.               ;*/ BYTE        dfLastChar;        /*
  dfDefaultChar     db      0   ; Default character for out of range.       ;*/ BYTE        dfDefaultChar;     /*
  dfBreakChar       db      0   ; Character to define wordbreaks.           ;*/ BYTE        dfBreakChar;       /*
  dfWidthBytes      dw      0   ; Number of bytes in each row.              ;*/ short int   dfWidthBytes;      /*
  dfDevice          dd      0   ; Offset to device name.                    ;*/ unsigned long int   dfDevice;  /*
  dfFace            dd      0   ; Offset to face name.                      ;*/ unsigned long int   dfFace;    /*
  dfBitsPointer     dd      0   ; Bits pointer.                             ;*/ unsigned long int   dfBitsPointer;/*
  dfBitsOffset      dd      0   ; Offset to the begining of the bitmap.     ;*/ unsigned long int   dfBitsOffset;/*
                                ; On the disk, this is relative to the
                                ; begining of the file. In memory this is
                                ; relative to the begining of this structure.
  dfReservedByte    db      0   ; filler byte to WORD-align charoffset      ;*/ BYTE dfReservedByte;            /*
  dfCharOffset      dw      0   ; Area for storing the character offsets,   ;*/ unsigned short dfMaps[DF_MAPSIZE];/*
                                ; facename, device name (opt), and bitmap.

FONTINFO        ends                                                        ;*/ } FONTINFO;                    /*

SCALABLEFONTINFO    struc                                                   ;*/ typedef     struct  {          /*
  erType            dw      0   ; Type field for the font.                  ;*/ short int   erType;            /*
  erPoints          dw      0   ; Point size of font.                       ;*/ short int   erPoints;          /*
  erVertRes         dw      0   ; Vertical digitization.                    ;*/ short int   erVertRes;         /*
  erHorizRes        dw      0   ; Horizontal digitization.                  ;*/ short int   erHorizRes;        /*
  erAscent          dw      0   ; Baseline offset from char cell top.       ;*/ short int   erAscent;          /*
  erInternalLeading dw      0   ; Internal leading included in font         ;*/ short int   erInternalLeading; /*
  erExternalLeading dw      0   ; Prefered extra space between lines        ;*/ short int   erExternalLeading; /*
  erItalic          db      0   ; Flag specifying if italic.                ;*/ BYTE        erItalic;          /*
  erUnderline       db      0   ; Flag specifying if underlined.            ;*/ BYTE        erUnderline;       /*
  erStrikeOut       db      0   ; Flag specifying if struck out.            ;*/ BYTE        erStrikeOut;       /*
  erWeight          dw      0   ; Weight of font.                           ;*/ short int   erWeight;          /*
  erCharSet         db      0   ; Character set of font.                    ;*/ BYTE        erCharSet;         /*
  erPixWidth        dw      0   ; Width field for the font.                 ;*/ short int   erPixWidth;        /*
  erPixHeight       dw      0   ; Height field for the font.                ;*/ short int   erPixHeight;       /*
  erPitchAndFamily  db      0   ; Flag specifying pitch and family.         ;*/ BYTE        erPitchAndFamily;  /*
  erAvgWidth        dw      0   ; Average character width.                  ;*/ short int   erAvgWidth;        /*
  erMaxWidth        dw      0   ; Maximum character width.                  ;*/ short int   erMaxWidth;        /*
  erFirstChar       db      0   ; First character in the font.              ;*/ BYTE        erFirstChar;       /*
  erLastChar        db      0   ; Last character in the font.               ;*/ BYTE        erLastChar;        /*
  erDefaultChar     db      0   ; Default character for out of range.       ;*/ BYTE        erDefaultChar;     /*
  erBreakChar       db      0   ; Character to define wordbreaks.           ;*/ BYTE        erBreakChar;       /*
  erWidthBytes      dw      0   ; Number of bytes in each row.              ;*/ short int   erWidthBytes;      /*
  erDevice          dd      0   ; Offset to device name.                    ;*/ unsigned long int   erDevice;  /*
  erFace            dd      0   ; Offset to face name.                      ;*/ unsigned long int   erFace;    /*
  erBitsPointer     dd      0   ; Bits pointer.                             ;*/ unsigned long int   erBitsPointer;/*
  erBitsOffset      dd      0   ; Offset to the begining of the bitmap.     ;*/ unsigned long int   erBitsOffset;/*
  erFlags           db      0   ; flags, and word align the stuff to come   ;*/ BYTE erReservedByte;            /*
  erUnderlinePos    dw      0   ; underline position relative to cell origin    ;*/ short int   erUnderlinePos;  /*
  erUnderlineThick  dw      0   ; underline thickness                           ;*/ short int   erUnderlineThick;/*
  erStrikeoutPos    dw      0   ; Strikeout position relative to cell origin    ;*/ short int   erStrikeoutPos;  /*
  erStrikeoutThick  dw      0   ; strikeout thickness                           ;*/ short int   erStrikeoutThick;/*
SCALABLEFONTINFO    ends                                                    ;*/ } SCALABLEFONTINFO;            /*


;------------------------------------------------------------------------------
;--------------------------  4.0 font structures  -----------------------------
;------------------------------------------------------------------------------
; This font format has a simple font header. It contains a version field
; followed by a glyph format field, the total number of glyphs in the
; entire font, and the dword offset to the array of glyph offsets.
;------------------------------------------------------------------------------

;------------------------------------------------------------------------------
; The NF_LARGE flag indicates that the glyph offset table is
;  array of DWORDs instead of WORD offsets AND that the glyphs
;  have LARGExxxGLYPH headers instead of SMALLxxxGLYPH headers.
;------------------------------------------------------------------------------
NF_BYTE_PACKED  equ     0001h           ; Byte aligned row format
NF_BIT_PACKED   equ     0002h           ; Bit packed row format
NF_FROM_BMP     equ     0040h           ; Derived from bitmap font
NF_LARGE        equ     0080h           ; Large offsets and glyph headers

NewFontSeg      struct
 nfVersion      dw      0               ; Font version (0x0400)
 nfFormat       dw      0               ; Font format flags
 nfNumGlyphs    dw      0               ; Number of glyphs in font
 nfGlyphOffset  dd      0               ; Offset to glyph offset table
 nfAWTable      dd      0               ; Offset to advance width table

 nfHeight       dw      0               ; Height of font in pixels
 nfAscent       dw      0               ; Distance from baseline to top
 nfUniqueID     dd      0               ; Unique identifier for this PFont
NewFontSeg      ends


;----------------------  Byte-packed glyph structures  ------------------------
;
; This structure is the header for a glyph stored in byte-packed
; row-oriented format. The glyph bitmap is stored immediately after
; the ROWGLYPH structure.
;------------------------------------------------------------------------------
SMALLROWGLYPH   struc
 srgOrgX        db      0               ; Vector to glyph origin in bitmap
 srgOrgY        db      0               ;  from upper left corner
 srgWidth       db      0               ; Width and height of glyph bmp in
 srgHeight      db      0               ;  pixels
SMALLROWGLYPH   ends

LARGEROWGLYPH   struc
 lrgOrgX        dw      0               ; Vector to glyph origin in bitmap
 lrgOrgY        dw      0               ;  from upper left corner
 lrgWidth       dw      0               ; Width and height of glyph bmp in
 lrgHeight      dw      0               ;  pixels
LARGEROWGLYPH   ends

;----------------------  Bit-packed glyph structures  -------------------------
;
; This structure is the header for a glyph stored in bit-packed row-oriented
; format. The glyph bitmap is stored immediately after the BITGLYPH structure.
;
; Bit-packed format means that the glyph rows are packed together end-to-end.
; There is no padding out to byte boundaries at the end of a row. This
; format results in the highest performance on some accelerated cards and
; the smallest memory footprint.
;------------------------------------------------------------------------------
SMALLBITGLYPH   struc
 sbgOrgX        db      0               ; Vector to glyph origin in bitmap
 sbgOrgY        db      0               ;  from upper left corner
 sbgWidth       db      0               ; Width and height of glyph bmp in
 sbgHeight      db      0               ;  pixels
 sbgPixels      dw      0               ; Total # of pixels in the glyph
SMALLBITGLYPH   ends

LARGEBITGLYPH   struc
 lbgOrgX        dw      0               ; Vector to glyph origin in bitmap
 lbgOrgY        dw      0               ;  from upper left corner
 lbgWidth       dw      0               ; Width and height of glyph bmp in
 lbgHeight      dw      0               ;  pixels
 lbgPixels      dd      0               ; Total # of pixels in the glyph
LARGEBITGLYPH   ends


TEXTXFORM       struc                                                       ;*/ typedef     struct  {          /*

  ftHeight            dw  0                                                 ;*/ short int ftHeight;            /*
  ftWidth             dw  0                                                 ;*/ short int ftWidth;             /*
  ftEscapement        dw  0                                                 ;*/ short int ftEscapement;        /*
  ftOrientation       dw  0                                                 ;*/ short int ftOrientation;       /*
  ftWeight            dw  0                                                 ;*/ short int ftWeight;            /*
  ftItalic            db  0                                                 ;*/ BYTE ftItalic;                 /*
  ftUnderline         db  0                                                 ;*/ BYTE ftUnderline;              /*
  ftStrikeOut         db  0                                                 ;*/ BYTE ftStrikeOut;              /*
  ftOutPrecision      db  0                                                 ;*/ BYTE ftOutPrecision;           /*
  ftClipPrecision     db  0                                                 ;*/ BYTE ftClipPrecision;          /*
  ftAccelerator       dw  0                                                 ;*/ unsigned short int             /*
                                                                            ;*/                 ftAccelerator; /*
  ftOverhang          dw  0                                                 ;*/ short int ftOverhang;          /*

TEXTXFORM       ends                                                        ;*/ } TEXTXFORM;                   /*



TEXTMETRIC      struc                                                       ;*/ typedef struct {               /*

  tmHeight              dw  0     ; Ascent+Descent                          ;*/ short int tmHeight;            /*
  tmAscent              dw  0     ; Pixels above the baseline               ;*/ short int tmAscent;            /*
  tmDescent             dw  0     ; Pixels below the baseline               ;*/ short int tmDescent;           /*
  tmInternalLeading     dw  0     ; Internal leading included in font       ;*/ short int tmInternalLeading;   /*
  tmExternalLeading     dw  0     ; Prefered extra space between lines      ;*/ short int tmExternalLeading;   /*
  tmAveCharWidth        dw  0     ; Of the letter 'X'                       ;*/ short int tmAveCharWidth;      /*
  tmMaxCharWidth        dw  0                                               ;*/ short int tmMaxCharWidth;      /*
  tmWeight              dw  0                                               ;*/ short int tmWeight;            /*
  tmItalic              db  0                                               ;*/ BYTE      tmItalic;            /*
  tmUnderlined          db  0                                               ;*/ BYTE      tmUnderlined;        /*
  tmStruckOut           db  0                                               ;*/ BYTE      tmStruckOut;         /*
  tmFirstChar           db  0                                               ;*/ BYTE      tmFirstChar;         /*
  tmLastChar            db  0                                               ;*/ BYTE      tmLastChar;          /*
  tmDefaultChar         db  0     ; dfDefaultChar+dfFirstChar               ;*/ BYTE      tmDefaultChar;       /*
  tmBreakChar           db  0     ; dfBreakChar+dfFirstChar                 ;*/ BYTE      tmBreakChar;         /*
  tmPitchAndFamily      db  0     ; Low bit zero if fixed pitch, one if     ;*/ BYTE      tmPitchAndFamily;    /*
                                  ; variable. Family in high nibble.
  tmCharSet             db  0                                               ;*/ BYTE      tmCharSet;           /*
  tmOverhang            dw  0                                               ;*/ short int tmOverhang;          /*
  tmDigitizedAspectX    dw  0     ; Digitization aspect ratio               ;*/ short int tmDigitizedAspectX;  /*
  tmDigitizedAspectY    dw  0     ; in X and Y.                             ;*/ short int tmDigitizedAspectY;  /*

TEXTMETRIC     ends                                                         ;*/ } TEXTMETRIC;                  /*



                endif
                endif
page
;       Drawing mode definitions - incDrawMode


                ifdef   incDrawMode
                if      incDrawMode


DRAWMODE        struc                                                       ;*/ typedef     struct {         /*

  Rop2          dw      0       ;The 16-bit encoded Logical op              ;*/ short int         Rop2;       /*
  bkMode        dw      0       ;Background Mode (for text only)            ;*/ short int         bkMode;     /*
  bkColor       dd      0       ;Physical background Color                  ;*/ unsigned long int bkColor;    /*
  TextColor     dd      0       ;Physical text (forground) color            ;*/ unsigned long int TextColor;  /*
  TBreakExtra   dw      0       ; total pixles to stuff into a line         ;*/ short int         TBreakExtra;/*
  BreakExtra    dw      0       ; div(TBreakExtra, BreakCount)              ;*/ short int         BreakExtra; /*
  BreakErr      dw      0       ; running error term                        ;*/ short int         BreakErr;   /*
  BreakRem      dw      0       ; mod(TBreakExtra, BreakCount)              ;*/ short int         BreakRem;   /*
  BreakCount    dw      0       ; count of breaks in the line               ;*/ short int         BreakCount; /*
  CharExtra     dw      0       ; extra pixles to stuff after each char     ;*/ short int         CharExtra;  /*
                                ;   (used to space out a font)
  LbkColor      dd      0       ;Logical background color                   ;*/ unsigned long int LbkColor;   /*
  LTextColor    dd      0       ;Logical Text (forground) color             ;*/ unsigned long int LTextColor; /*
  ICMCXform     dd      0       ;Transform for DIC image color matcher      ;*/ DWORD             ICMCXform;  /*
  StretchBltMode dw     0       ;Stretch Blt mode                           ;*/ short         StretchBltMode; /*
  eMiterLimit   dd      0       ;Miter Limit (single precision IEEE float)  ;*/ DWORD             eMiterLimit;/*

DRAWMODE        ends                                                        ;*/ } DRAWMODE;                   /*



;       Background Mode definitions

TRANSPARENT     equ     1
OPAQUE          equ     2

BKMODE_TRANSPARENT      equ     1
BKMODE_OPAQUE           equ     2
BKMODE_LEVEL1           equ     3
BKMODE_LEVEL2           equ     4
BKMODE_LEVEL3           equ     5
BKMODE_TRANSLATE        equ     6


;       StretchBlt Mode definitions

STRETCH_ANDSCANS        equ     1
STRETCH_ORSCANS         equ     2
STRETCH_DELETESCANS     equ     3
STRETCH_HALFTONE        equ     4

SBM_BLACKONWHITE        equ     STRETCH_ANDSCANS
SBM_WHITEONBLACK        equ     STRETCH_ORSCANS
SBM_COLORONCOLOR        equ     STRETCH_DELETESCANS
SBM_HALFTONE            equ     STRETCH_HALFTONE

    if  0
*/
/* Background Mode definitions used by GDI support routines written in C */

#define     TRANSPARENT         1
#define     OPAQUE              2

#define BKMODE_TRANSPARENT      1
#define BKMODE_OPAQUE           2
#define BKMODE_LEVEL1           3
#define BKMODE_LEVEL2           4
#define BKMODE_LEVEL3           5
#define BKMODE_TRANSLATE        6

/* StretchBlt Mode definitions used by GDI support routines written in C */

#define STRETCH_ANDSCANS        1
#define STRETCH_ORSCANS         2
#define STRETCH_DELETESCANS     3
#define STRETCH_HALFTONE        4

#define SBM_BLACKONWHITE        STRETCH_ANDSCANS
#define SBM_WHITEONBLACK        STRETCH_ORSCANS
#define SBM_COLORONCOLOR        STRETCH_DELETESCANS
#define SBM_HALFTONE            STRETCH_HALFTONE

/*
    endif



                endif
                endif
page

;       The SCAN structure used by OS_POLYSCANLINE and DRAWESCAPE.
;       The DRAWESCAPE structure is used by the DrawEcape DDI.

                ifdef   incPolyScanline
                if      incPolyScanline

SCAN            struc                                                   ;*/  typedef struct {           /*
  scnPntCnt     dw      ?               ;Count of X coords (not pairs)  ;*/  short int scnPntCnt;       /*
  scnPntTop     dw      ?               ;Top of scan (inclusive)        ;*/  short int scnPntTop;       /*
  scnPntBottom  dw      ?               ;Bottom of scan (exclusive)     ;*/  short int scnPntBottom;    /*
  scnPntX       dw      2 dup (?)       ;Var. length array of X pairs   ;*/  short int scnPntX[2];      /*
  scnPntCntToo  dw      ?               ;=scnPntCnt                     ;*/  short int scnPntCntToo;    /*
SCAN            ends                                                    ;*/  } SCAN, FAR* LPSCAN;       /*

DRAWESCAPE      struc                                                   ;*/  typedef struct {           /*
  de_cbSize     dd      ?               ;sizeof(DRAWESCAPE)             ;*/  DWORD      cbSize;         /*
  de_lpDestDev  dd      ?               ;PDEVICE or PBITMAP             ;*/  LPVOID     lpDestDev;      /*
  de_nEscape    dd      ?               ;API parameter                  ;*/  DWORD      nEscape;        /*
  de_cbInput    dd      ?               ;API parameter                  ;*/  DWORD      cbInput;        /*
  de_lpszInput  dd      ?               ;API parameter                  ;*/  LPVOID     lpInput;        /*
  de_ptOrigin   dd      ?               ;origin of window               ;*/  POINT      ptOrigin;       /*
  de_dwUniq     dd      ?               ;region uniqueness value        ;*/  DWORD      dwUniq;         /*
  de_rcBBox     dw      4 dup (?)       ;bounding box of region         ;*/  RECT       rcBBox;         /*
  de_cScans     dd      ?               ;count of scans in region       ;*/  DWORD      cScans;         /*
  de_lpScan     dd      ?               ;ptr to first scan in region    ;*/  LPSCAN     lpScan;         /*
DRAWESCAPE      ends                                                    ;*/  } DRAWESCAPE, FAR* LPDRAWESCAPE; /*

REGION          struc                                                   ;*/  typedef struct {           /*
  rgn_id        dw      ?               ;if LPREGION 0x8000 else LPRECT ;*/  WORD       id;             /*
  rgn_cbSize    dw      ?               ;sizeof(REGION)                 ;*/  WORD       cbSize;         /*
  rgn_lprcClip  dd      ?               ;NULL or region walking opt.    ;*/  LPRECT     lprcClip;       /*
  rgn_dwUniq    dd      ?               ;region uniqueness value        ;*/  DWORD      dwUniq;         /*
  rgn_rcBBox    dw      4 dup (?)       ;bounding box of region         ;*/  RECT       rcBBox;         /*
  rgn_cScans    dd      ?               ;count of scans in region       ;*/  DWORD      cScans;         /*
  rgn_lpScan    dd      ?               ;ptr to first scan in region    ;*/  LPSCAN     lpScan;         /*
REGION          ends                                                    ;*/  } REGION, FAR* LPREGION;   /*

                endif   ;incPolyScanline
                endif   ;incPolyScanline

;       Output Definitions - incOutput

                ifdef   incOutput
                if      incOutput


;       Output Style definitions used by GDI


OS_POLYBEZIER   equ     1
OS_ARC          equ     3
OS_SCANLINES    equ     4
OS_POLYSCANLINE equ     5
OS_RECTANGLE    equ     6
OS_ELLIPSE      equ     7
OS_MARKER       equ     8
OS_POLYLINE     equ     18
OS_WINDPOLYGON  equ     20
OS_TRAPEZOID    equ     20      ; replaced with WINDPOLYGON
OS_ALTPOLYGON   equ     22
OS_POLYGON      equ     22      ; replaced with ALTPOLYGON
OS_PIE          equ     23
OS_POLYMARKER   equ     24
OS_CHORD        equ     39
OS_CIRCLE       equ     55

OS_POLYPOLYGON  equ     4000h   ; this bit is ORd with OS_WIND/ALTPOLYGON

OS_BEGINNSCAN   equ     80
OS_ENDNSCAN     equ     81
    if  0
*/

/* Output Style definitions used by GDI support routines written in C */

#define     OS_POLYBEZIER       1
#define     OS_ARC              3
#define     OS_SCANLINES        4
#define     OS_POLYSCANLINE     5
#define     OS_RECTANGLE        6
#define     OS_ELLIPSE          7
#define     OS_MARKER           8
#define     OS_POLYLINE         18
#define     OS_TRAPEZOID        20      /* should really be WINDPOLYGON */
#define     OS_WINDPOLYGON      OS_TRAPEZOID
#define     OS_POLYGON          22      /* should really be ALTPOLYGON */
#define     OS_ALTPOLYGON       OS_POLYGON
#define     OS_PIE              23
#define     OS_POLYMARKER       24
#define     OS_CHORD            39
#define     OS_CIRCLE           55

#define     OS_POLYPOLYGON      0x4000  /* this bit is ORd with OS_WIND/ALTPOLYGON */

#define     OS_BEGINNSCAN       80
#define     OS_ENDNSCAN         81
/*
    endif


                endif
                endif


                ifdef   incControl
                if      incControl

OEM_FAILED      equ     8000000

;       GDI escape constants

NEWFRAME          equ     1
ABORTDOC          equ     2
NEXTBAND          equ     3
SETCOLORTABLE     equ     4
GETCOLORTABLE     equ     5
FLUSHOUTPUT       equ     6
DRAFTMODE         equ     7
QUERYESCSUPPORT   equ     8
SETPRINTERDC      equ     9
SETABORTPROC      equ     9
STARTDOC          equ     10
ENDDOC            equ     11
GETPHYSPAGESIZE   equ     12
GETPRINTINGOFFSET equ     13
GETSCALINGFACTOR  equ     14
MFCOMMENT         equ     15
GETPENWIDTH       equ     16
SETCOPYCOUNT      equ     17
SELECTPAPERSOURCE equ     18
DEVICEDATA        equ     19
PASSTHROUGH       equ     19
GETTECHNOLGY      equ     20
GETTECHNOLOGY     equ     20
SETLINECAP        equ     21
SETLINEJOIN        equ    22
SETMITERLIMIT      equ    23
BANDINFO           equ    24
DRAWPATTERNRECT    equ    25
GETVECTORPENSIZE   equ    26
GETVECTORBRUSHSIZE equ    27
ENABLEDUPLEX       equ    28
GETSETPAPERBINS    equ    29
GETSETPRINTORIENT  equ    30
ENUMPAPERBINS      equ    31
SETDIBSCALING      equ    32
EPSPRINTING        equ    33
ENUMPAPERMETRICS   equ    34
GETSETPAPERMETRICS equ    35
GETVERSION         equ    36
POSTSCRIPT_DATA    equ    37
POSTSCRIPT_IGNORE  equ    38
MOUSETRAILS        equ    39
QUERYROPSUPPORT    equ    40
GETDEVICEUNITS     equ    42
RESETDEVICE        equ    128
GETEXTENDEDTEXTMETRICS equ 256
GETEXTENTTABLE         equ 257
GETPAIRKERNTABLE       equ 258
GETTRACKKERNTABLE      equ 259
EXTTEXTOUT             equ 512
GETFACENAME            equ 513
DOWNLOADFACE           equ 514
ENABLERELATIVEWIDTHS   equ 768
ENABLEPAIRKERNING      equ 769
SETKERNTRACK           equ 770
SETALLJUSTVALUES       equ 771
SETCHARSET             equ 772

STRETCHBLT             equ 2048
QUERYDIBSUPPORT        equ 3073
QDI_SETDIBITS          equ 1h
QDI_GETDIBITS          equ 2h
QDI_DIBTOSCREEN        equ 4h
QDI_STRETCHDIB         equ 8h
DCICOMMAND             equ 3075
BEGIN_PATH             equ 4096
CLIP_TO_PATH           equ 4097
END_PATH               equ 4098
EXT_DEVICE_CAPS        equ 4099
RESTORE_CTM            equ 4100
SAVE_CTM               equ 4101
SET_ARC_DIRECTION      equ 4102
SET_BACKGROUND_COLOR   equ 4103
SET_POLY_MODE          equ 4104
SET_SCREEN_ANGLE       equ 4105
SET_SPREAD             equ 4106
TRANSFORM_CTM          equ 4107
SET_CLIP_BOX           equ 4108
SET_BOUNDS             equ 4109
OPENCHANNEL            equ 4110
DOWNLOADHEADER         equ 4111
CLOSECHANNEL           equ 4112
SETGDIXFORM            equ 4113
RESETPAGE              equ 4114
POSTSCRIPT_PASSTHROUGH equ 4115

ENCAPSULATED_POSTSCRIPT equ 4116



    if 0
*/
#define OEM_FAILED          0x80000000L

#define NEWFRAME                     1
#define ABORTDOC                     2
#define NEXTBAND                     3
#define SETCOLORTABLE                4
#define GETCOLORTABLE                5
#define FLUSHOUTPUT                  6
#define DRAFTMODE                    7
#define QUERYESCSUPPORT              8
#define SETPRINTERDC                 9          // DDK - between GDI and Driver
#define SETABORTPROC                 9          // SDK - between APP and GDI
#define STARTDOC                     10
#define ENDDOC                       11
#define GETPHYSPAGESIZE              12
#define GETPRINTINGOFFSET            13
#define GETSCALINGFACTOR             14
#define MFCOMMENT                    15
#define GETPENWIDTH                  16
#define SETCOPYCOUNT                 17
#define SELECTPAPERSOURCE            18
#define DEVICEDATA                   19
#define PASSTHROUGH                  19
#define GETTECHNOLGY                 20
#define GETTECHNOLOGY                20
#define SETLINECAP                   21
#define SETLINEJOIN                  22
#define SETMITERLIMIT                23
#define BANDINFO                     24
#define DRAWPATTERNRECT              25
#define GETVECTORPENSIZE             26
#define GETVECTORBRUSHSIZE           27
#define ENABLEDUPLEX                 28
#define GETSETPAPERBINS              29
#define GETSETPRINTORIENT            30
#define ENUMPAPERBINS                31
#define SETDIBSCALING                32
#define EPSPRINTING                  33
#define ENUMPAPERMETRICS             34
#define GETSETPAPERMETRICS           35
#define GETVERSION                   36         /* ADOBE_11_1_88 */
#define POSTSCRIPT_DATA              37
#define POSTSCRIPT_IGNORE            38
#define QUERYROPSUPPORT              40
#define GETDEVICEUNITS               42
#define RESETDEVICE                  128
#define GETEXTENDEDTEXTMETRICS       256
#define GETEXTENTTABLE               257
#define GETPAIRKERNTABLE             258
#define GETTRACKKERNTABLE            259
#define EXTTEXTOUT                   512
#define GETFACENAME                  513
#define DOWNLOADFACE                 514       /* ADOBE_11_1_88 */
#define ENABLERELATIVEWIDTHS         768
#define ENABLEPAIRKERNING            769
#define SETKERNTRACK                 770
#define SETALLJUSTVALUES             771
#define SETCHARSET                   772
#define STRETCHBLT                   2048
#define QUERYDIBSUPPORT              3073
#define QDI_SETDIBITS                0x0001
#define QDI_GETDIBITS                0x0002
#define QDI_DIBTOSCREEN              0x0004
#define QDI_STRETCHDIB               0x0008
#define DCICOMMAND                   3075
#define BEGIN_PATH                   4096
#define CLIP_TO_PATH                 4097
#define END_PATH                     4098
#define EXT_DEVICE_CAPS              4099
#define RESTORE_CTM                  4100
#define SAVE_CTM                     4101
#define SET_ARC_DIRECTION            4102
#define SET_BACKGROUND_COLOR         4103
#define SET_POLY_MODE                4104
#define SET_SCREEN_ANGLE             4105
#define SET_SPREAD                   4106
#define TRANSFORM_CTM                4107
#define SET_CLIP_BOX                 4108
#define SET_BOUNDS                   4109
#define OPENCHANNEL                  4110
#define DOWNLOADHEADER               4111
#define CLOSECHANNEL                 4112
#define SETGDIXFORM                  4113
#define RESETPAGE                    4114
#define POSTSCRIPT_PASSTHROUGH       4115
#define ENCAPSULATED_POSTSCRIPT      4116


typedef FONTINFO    FAR *LPFONTINFO;
typedef DRAWMODE    FAR *LPDRAWMODE;
typedef TEXTXFORM   FAR *LPTEXTXFORM;
typedef TEXTMETRIC  FAR *LPTEXTMETRIC;
typedef LOGFONT     FAR *LPLOGFONT;
typedef LOGPEN      FAR *LPLOGPEN;
typedef LOGBRUSH    FAR *LPLOGBRUSH;
typedef BITMAP      FAR *LPBITMAP;
typedef FARPROC     FAR *LPFARPROC;
typedef GDIINFO     FAR *LPGDIINFO;
typedef SCALABLEFONTINFO FAR * LPSCALABLEFONTINFO;


/*
    endif



                endif
                endif
;*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\INCLUDE\GNGDI.INC ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Copyright (C) 1998-1999, Nvidia Corporation
;
; File:         gngdi.inc
;
; Purpose:      This file holds the interface to the generic
;               service routines.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE

; gnblt.asm
EXTERNDEF       GN_BitBltPunt:NEAR
EXTERNDEF       GN_BitBltFail:NEAR
EXTERNDEF       GN_BitBltSuccess:NEAR

; gnclrblt.asm
EXTERNDEF       GN_BitBltSrcColorDstVram:NEAR
EXTERNDEF       GN_StretchBltSrcColorDstVram:NEAR

; gninit.asm
EXTERNDEF       wNVTEXT32_Alias_In_NVTEXT32:WORD
EXTERNDEF       wNVTEXT16_Alias_In_NVTEXT32:WORD
EXTERNDEF       wFlatDataSel:WORD
EXTERNDEF	GN_LoadDllAndGetExports:FAR16
CLOSESEG _NVTEXT32
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPENSEG  _NVTEXT16, USE16, CODE
; gninit.asm
EXTERNDEF       wNVTEXT32_Alias_In_NVTEXT16:WORD
EXTERNDEF       wNVTEXT16_Alias_In_NVTEXT16:WORD
EXTERNDEF       wFlatDataSel_In_NVTEXT16:WORD

; gnthk16.asm
EXTERNDEF       wBreak16:WORD
EXTERNDEF       GENERIC_OutputDebugString:FAR16

; gnutil.asm
EXTERNDEF       GN_GetDeviceLocalBasePath:FAR16
EXTERNDEF       GN_AllocSelectorAndMapIt:FAR16
EXTERNDEF       GN_UnmapAndFreeSelector:FAR16
EXTERNDEF       GN_GetSelectorBase:FAR16
EXTERNDEF       GN_MemoryAlloc:FAR16
EXTERNDEF       GN_MemoryFree:FAR16
EXTERNDEF       GN_GetSelectorBase:FAR16
EXTERNDEF       GN_AllocSelectorAndNullIt:FAR16
EXTERNDEF       GN_AllocSelectorAndMapIt:FAR16
EXTERNDEF       GN_UnmapAndFreeSelector:FAR16
EXTERNDEF       GN_CheckInterlacedStereoConnection:FAR16
CLOSESEG _NVTEXT16
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Now the Kernel exports
EXTERNDEF       AllocCSToDSAlias:FAR16
EXTERNDEF       GetSelectorBase:FAR16
EXTERNDEF       SetSelectorBase:FAR16
EXTERNDEF       SetSelectorLimit:FAR16
EXTERNDEF       SetLastError:FAR16
EXTERNDEF       SelectorAccessRights:FAR16
EXTERNDEF       FreeSelector:FAR16
EXTERNDEF       GetModuleHandle:FAR16
EXTERNDEF       GetProcAddress:FAR16
EXTERNDEF       GlobalAlloc:FAR16
EXTERNDEF       GlobalFree:FAR16
EXTERNDEF       GlobalHandle:FAR16
EXTERNDEF       GlobalLock:FAR16
EXTERNDEF       GlobalUnlock:FAR16
EXTERNDEF       LoadLibrary:FAR16
EXTERNDEF       FreeLibrary:FAR16
EXTERNDEF       RegOpenKey:FAR16
EXTERNDEF       RegCloseKey:FAR16
EXTERNDEF       RegEnumKey:FAR16
EXTERNDEF       RegQueryValueEx:FAR16
EXTERNDEF       RegCreateKey:FAR16
EXTERNDEF       RegSetValueEx:FAR16
EXTERNDEF       RegDeleteValue:FAR16
EXTERNDEF       OutputDebugString:FAR16
EXTERNDEF       GetVersionEx:FAR16
EXTERNDEF       IsBadReadPtr:FAR16
EXTERNDEF       IsBadWritePtr:FAR16

; A few things for the Registry functions so I don't have to include
; all the windows header files.
MAX_KEY_LEN             TEXTEQU <80H>

HKEY_CLASSES_ROOT       TEXTEQU <80000000H>
HKEY_CURRENT_USER       TEXTEQU <80000001H>
HKEY_LOCAL_MACHINE      TEXTEQU <80000002H>
HKEY_USERS              TEXTEQU <80000003H>
HKEY_PERFORMANCE_DATA   TEXTEQU <80000004H>
HKEY_CURRENT_CONFIG     TEXTEQU <80000005H>
HKEY_DYN_DATA           TEXTEQU <80000006H>
ERROR_SUCCESS           TEXTEQU <00H>

REG_NONE                TEXTEQU <000000000h>
REG_SZ                  TEXTEQU <000000001h>
REG_EXPAND_SZ           TEXTEQU <000000002h>
REG_BINARY              TEXTEQU <000000003h>
REG_DWORD               TEXTEQU <000000004h>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
MSG_PREMODESET          	TEXTEQU <00000000H>
MSG_POSTMODESET         	TEXTEQU <00000001H>
MSG_DIRECTX_ENUM		TEXTEQU	<00000002H>
MSG_DIRECTXON           	TEXTEQU <00000003H>
MSG_DIRECTXOFF          	TEXTEQU <00000004H>
MSG_DOSON               	TEXTEQU <00000005H>
MSG_DOSOFF              	TEXTEQU <00000006H>
MSG_DISABLE             	TEXTEQU <00000007H>
MSG_LOGDEVMOVED         	TEXTEQU <00000008H>
MSG_DEVICESREMAPPED		TEXTEQU	<00000009H>
MSG_DISPLAY_DRIVER_UNLOADING	TEXTEQU	<0000000AH>
MSG_POWERON             	TEXTEQU <0000000BH>
MSG_POWEROFF            	TEXTEQU <0000000CH>

; MSG_PREMODESET, MSG_POSTMODESET
; These two are given in the order shown above. The mode is set after
; the PREMODESET message returns and before the POSTMODESET message
; is sent. These messages are when the logical mode changes only!
; If the CRTC is being set to a different mode, but the desktop size
; is not changing, then these messages will not be sent.
; No one processing these messages should screw up the screen,
; change the pitch, etc in any way. They are just information to
; allow the various objects to set some internal state variables
; alloc and free resources. All calls that change state affecting
; the screens appearance will be outside of the message stuff,
; thus allowing for better control and serialization.

; MSG_PREMODESET
; dwData1 is a context ptr to a DIBENGINE structure which reflects the
; current logical mode - not the new mode being set. This gives everyone
; a chance to shutdown anything in the old mode before the modeset.
; dwData2 is the 16:16 ptr to the same thing.

; MSG_POSTMODESET
; dwData1 is a context ptr to a DIBENGINE structure which reflects the
; new logical mode that is being set.
; dwData2 is the 16:16 ptr to the same thing.

; MSG_DIRECTX_ENUM, MSG_DIRECTX_ON, MSG_DIRECTX_OFF
; MSG_DIRECTX_ENUM means that the system is at the very least enumerating
; all the DirectX devices and that includes issuing an escape to all the
; display drivers that power the 2D side of the device.
; MSG_DIRECTXON means that the first app has attached to the DirectX
; Context. This is when offscreen video memory should be releaseed
; for use by DirectX.
; MSG_DIRECTXOFF means that the last app has released the DirectX Context.
; Thi is when the 2D driver can reclaim offscreen video memory.
; dwData1 and dwData2 are unused.

; MSG_DOSON, MSG_DOSOFF, MSG_POWERON, MSG_POWEROFF
; dwData1 is a context ptr to a DIBENGINE structure which reflects the
; new logical mode that is being set.
; dwData2 is the 16:16 ptr to the same thing.

; MSG_DISABLE
; The device is being disabled. In general, the action here should
; be similar to a DOSON msg. In both cases, it probably means that
; the driver is temporarily losing control of the screen and the
; hardware.
; dwData1 and dwData2 are unused.

; MSG_LOGDEVMOVED
; dwData1 is the new pGNLogdevCX.
; dwData2 is the old pGNLogdevCX.

; MSG_DEVICESREMAPPED
; This message says that the hardware has remapped the device
; to head assignments. Although the generic code may not know
; exactly what this means, the idea is that things relating to
; head DAC speeds, etc, may be different.
; dwData1 is ignored
; dwData2 is ignored

; MSG_PRE_RESETTING_VIDEO_MEMORY_HEAP
; MSG_POST_RESETTING_VIDEO_MEMORY_HEAP
; This message is only sent down in catastrophic cases where we were
; unable to allocate even a 640x480x8 primary surface for one of the
; displays ona modeset. Since the code in the display driver should
; always allow us to get at least this surface size, it must be that
; somehow the heap is corrupted. In that case, we reset it so that
; it is completely clean and inform everyone so they can do any clean
; up. The pre message is sent just before the heap is purged. The post
; message is sent after a new one has been allocated. These messages
; may well be sent nested inside a MSG_PREMODESET and MSG_POSTMODESET
; pair, because it is on a modeset that we discover we can't get the
; primary surface.
; dwData1 is a ptr to the DIBENGINEHDR structure describing the
;	  current mode. Since we are probably inside a PREMODESET/
;	  POSTMODESET pair, dwData1 will describe the mode that
;	  exists BEFORE the mode change.
; dwData2 is not used

PLABEL	MACRO	name
	public	&name&
&name&	proc	near
&name&	endp
	ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\INCLUDE\HWCRTC.H ===
/*=======================================================================

    Copyright (C), 1998 Nvidia Coporation

    File:       hwcrtc.h

    Purpose:    This file holds the HWCRTCCX structure and other
                CRTC related data.

=========================================================================*/

typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;

// This structure holds dynamic data that is unique for each
// given instance of a CRTC on a given board.
typedef struct  _HWCRTCCX
{
    // Set to non-0 if we are initting. Cleared on first modeset
    ULONG   dwInitting;

    // The HWBOARDCX is needed sometimes so store it here.
    ULONG   pHWBoardCX;

    // This is the HWLOGDEVCX that this HWCRTCCX is a child of
    ULONG   pHWLogdevCX;

    // 0 based number telling us which CRTC we are using with
    // respect to the board device.
    ULONG   dwPhysicalCRTCInstance;

    // This is the offset in vram where the cursor patterns are stored
    // Also the cursor alpha to be applied to color cursors. Also we
    // keep around how many cursors we may have to cache.
    ULONG   dwMaxCachedCursors;
    ULONG   dwCursorCacheVramOffset;
    ULONG   dwCursorAlpha;

    // The TV ID and Addr are sometimes needed so store them both here.
    ULONG   dwTVOutDeviceID;
    ULONG   dwTVOutDeviceAddr;

    // This holds the current CRTC pitch.
    ULONG   dwPanPitch;

    // Each one is set to TRUE if the object is created.
    UCHAR   bNotifierCreated;
    UCHAR   bPaletteContextDmaCreated;
    UCHAR   bGammaContextDmaCreated;
    UCHAR   bVidLutCursorDacObjectCreated;

    NvNotification  sVideoLutCursorDacNotifier0;
    NvNotification  sVideoLutCursorDacNotifier1;
    NvNotification  sVideoLutCursorDacNotifier2;
    NvNotification  sVideoLutCursorDacNotifier3;
    NvNotification  sVideoLutCursorDacNotifier4;
    NvNotification  sVideoLutCursorDacNotifier5;
    NvNotification  sVideoLutCursorDacNotifier6;
    NvNotification  sVideoLutCursorDacNotifier7;
    NvNotification  sVideoLutCursorDacNotifier8;

    // The palette and gamma table are placed here for updating and
    // then a VideoFromMemory transfer is initiated.
    ULONG   dwPaletteTable[256];
    ULONG   dwGammaTable[256];
}   HWCRTCCX;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\INCLUDE\HWGDI.INC ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Copyright (C) 1998-1999, Nvidia Corporation
;
; File:         hwgdi.inc
;
; Purpose:      This file holds the interface to the harware specific
;               service routines.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; I put these equates inside things that I think are wrong or not necessary
; but they break verdict so I made the changes.
MAKE_VERDICT_WORK       TEXTEQU <1>

IF      (MAKE_VERDICT_WORK NE 0)
INTERSECT_TEXTXFORM_WITH_CLIP   TEXTEQU <1>
CHIP_SORTS_RECT_AND_TEXT_COORDS TEXTEQU <1>
ELSE

; The DIBENG intersects the rectangle specified by the lpTextXForm
; argument to ExtTextOut with the rectangle specified by lpClipRect
; to generate the real clip rect. I think that this is wrong.
; lpClipRect gives the clip rectangle period.
INTERSECT_TEXTXFORM_WITH_CLIP   TEXTEQU <0>
ENDIF

; This enables font cache.  It is off by default for now because font cache
; is actually slower on a very fast machine like Camino 700 Mhz.  On a slower
; machine like PIII-500 it is slightly faster than the traditional text.
RENDER_TEXT_WITH_FONT_CACHE     TEXTEQU <0>

; Enables support for A8R8G8B8 color cursors with alpha
USE_ALPHA_CURSOR        TEXTEQU <1>

; Enables cursor shadows.  Down and right are the number of pixels the
; shadow is displaced.
CURSOR_SHADOW           TEXTEQU <0>
CURSOR_SHADOW_DOWN      TEXTEQU <3>
CURSOR_SHADOW_RIGHT     TEXTEQU <3>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPENSEG  _NVTEXT16, USE16, CODE
; hwaccess.asm
EXTERNDEF       HW_GetGraphicsTimeStamp:NEAR

; hwcntrl.asm
EXTERNDEF       HW_ControlQuery:NEAR
EXTERNDEF       HW_ControlAction:NEAR

; hwinit.asm
EXTERNDEF       HW_CreateConstants:FAR16
EXTERNDEF       HW_DestroyConstants:FAR16
EXTERNDEF       HW_AllocFlatMemory:FAR16
EXTERNDEF       HW_FreeFlatMemory:FAR16
EXTERNDEF       HW_GetLogdevToBoardPtr:FAR16

; hwlogdev.asm
EXTERNDEF       HW_CreateLogdevContext:FAR16
EXTERNDEF       HW_DestroyLogdevContext:FAR16
EXTERNDEF       HW_LogdevAttachCrtc:FAR16
EXTERNDEF       HW_LogdevDetachCrtc:FAR16
EXTERNDEF       HW_Get16BppPixelFormat:FAR16
EXTERNDEF       HW_GetTextFormat:FAR16

; hwlogdev2.asm
EXTERNDEF       HW_LogdevMessage:FAR16
EXTERNDEF       HW_DriverTwinviewStateChanging:FAR16
EXTERNDEF       HW_AllocLogicalSurface:FAR16
EXTERNDEF       HW_FreeLogicalSurface:FAR16
EXTERNDEF       HW_GetDirectXRuntimeVersion:FAR16
EXTERNDEF       HW_GetDirectXDllNameAndEntryPoint:FAR16
EXTERNDEF       HW_SetNewDirxCallbacks:FAR16
EXTERNDEF       HW_GetDirectXInstance:FAR16
EXTERNDEF       HW_GetOpenGLRegistryName:FAR16
EXTERNDEF       HW_TellResManSpanningState:FAR16

; mvision
EXTERNDEF       HW_SetMacrovisionMode:NEAR
CLOSESEG _NVTEXT16


OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
; hwaccess.asm
EXTERNDEF       HW_BeginAccess:NEAR
EXTERNDEF       HW_BeginAccess_Far32:FAR32
EXTERNDEF       HW_EndAccess:NEAR
EXTERNDEF       HW_CreateOffscreenBitmap:NEAR
EXTERNDEF       HW_DeleteOffscreenBitmap:NEAR

; hwboard.asm
EXTERNDEF       HW_CreateBoardContext:FAR32
EXTERNDEF       HW_DestroyBoardContext:FAR32
EXTERNDEF       HW_SetDesktopState:FAR32
EXTERNDEF       NV_SetInterlacedStereoMode:FAR32
DESKTOP_STATE_NORMAL    TEXTEQU <0>
DESKTOP_STATE_MULTIMON  TEXTEQU <1>
DESKTOP_STATE_CLONE     TEXTEQU <2>

; hwboard2.asm
EXTERNDEF       HW_BoardMessage:FAR32
EXTERNDEF       HW_GetLargestOffscreenBlock:FAR32
EXTERNDEF       HW_GetLargestOffscreenSpace:FAR32
EXTERNDEF       HW_AllocOffscreenBlock:FAR32
EXTERNDEF       HW_FreeOffscreenBlock:FAR32
EXTERNDEF       HW_OffscreenHeapPurge:FAR32
EXTERNDEF       HW_DxHeapPurge:FAR32
EXTERNDEF       HW_HeapPurgeAllExceptPrimarySurface:FAR32
EXTERNDEF       HW_AllocPrimarySurface:FAR32
EXTERNDEF       HW_FreePrimarySurface:FAR32
EXTERNDEF       HW_PrimarySurfaceHeapPurge:FAR32
EXTERNDEF       HW_GetPciDeviceID:FAR32
EXTERNDEF       HW_GetFrameBufferSelector:FAR32
EXTERNDEF       HW_GetModeDimensions:FAR32
EXTERNDEF       HW_GetNumCRTCs:FAR32
EXTERNDEF       HW_GetAllAttachedDevices:FAR32
EXTERNDEF       HW_IsDeviceAttached:FAR32
EXTERNDEF       HW_CanDevicesBeMapped:FAR32
EXTERNDEF       HW_MapDevices:FAR32
EXTERNDEF       HW_BeginDisplayChange:FAR32
EXTERNDEF       HW_EndDisplayChange:FAR32
EXTERNDEF       Enable_VGA:FAR32

; hwclrblt.asm
EXTERNDEF       HW_BitBltSrcColorDstVram:NEAR
EXTERNDEF       HW_BeginSrcColorDstVram:NEAR
EXTERNDEF       HW_BlockSrcColorDstVram:NEAR
EXTERNDEF       HW_EndSrcColorDstVram:NEAR

; hwcrtc.asm
EXTERNDEF       HW_CreateCrtcContext:FAR32
EXTERNDEF       HW_DestroyCrtcContext:FAR32
EXTERNDEF       HW_GetDacLimits:FAR32
EXTERNDEF       HW_BitsPerColorGun:FAR32
EXTERNDEF       HW_SizeCursorCache:FAR32
EXTERNDEF       HW_IsCRTConnected:FAR32
EXTERNDEF       HW_IsDFPConnected:FAR32
EXTERNDEF       HW_IsTVConnected:FAR32
EXTERNDEF       HW_GetMaxDfpScaledXRes:FAR32
EXTERNDEF       HW_IsMacroVisionEncoderAttached:FAR32
EXTERNDEF       HW_ReadEdid:FAR32
EXTERNDEF       HW_ReadEdidForDevice:FAR32
EXTERNDEF       HW_GetPhysicalCrtcIndex:FAR32
EXTERNDEF       HW_GetBootDevice:FAR32
EXTERNDEF       HW_GetResManTvFormat:FAR32
EXTERNDEF       HW_SetResManTvFormat:FAR32
EXTERNDEF       HW_GetMaxTVOutResolution:FAR32

; hwcrtc2.asm
EXTERNDEF       HW_CrtcMessage:FAR32
EXTERNDEF       HW_SetCrtcMode:FAR32
EXTERNDEF       HW_SetStopImage:FAR32
EXTERNDEF       HW_SetPanOffset:FAR32
EXTERNDEF       HW_SetGamma:FAR32
EXTERNDEF       HW_SetPalette:FAR32
EXTERNDEF       HW_MapHWDeviceTypeToGNDeviceType:FAR32
EXTERNDEF       HW_MapGNDeviceTypeToHWDeviceType:FAR32
EXTERNDEF       HW_MapHWTvFormatToGNTvFormat:FAR32
EXTERNDEF       HW_MapGNTvFormatToHWTvFormat:FAR32
EXTERNDEF       HW_IsBandwidthOK:FAR32

; hwcursor.asm
EXTERNDEF       HW_CursorEnable_FAR32:FAR32
EXTERNDEF       HW_CursorEnable:NEAR
EXTERNDEF       HW_CursorSet:NEAR
EXTERNDEF       HW_CursorSelect:NEAR
EXTERNDEF       HW_CursorMove:NEAR

; hwldpat.asm
EXTERNDEF       HW_LoadSolidPattern:NEAR
EXTERNDEF       HW_LoadMonoPattern:NEAR
EXTERNDEF       HW_LoadColorPattern:NEAR

; hwline.asm
EXTERNDEF       HW_Polyline:NEAR
EXTERNDEF       HW_PolyStyledLine:NEAR
EXTERNDEF       SETUPPATTERNHWFORSTYLELINE:NEAR

; hwmonblt.asm
EXTERNDEF       HW_BeginSrcMonoDstVram:NEAR
EXTERNDEF       HW_BlockSrcMonoDstVram:NEAR
EXTERNDEF       HW_EndSrcMonoDstVram:NEAR

; hwpatblt.asm
EXTERNDEF       HW_BitBltSolidPatDstRop:NEAR
EXTERNDEF       HW_BitBltColorPatDstRop:NEAR
EXTERNDEF       HW_BitBltMonoPatDstRop:NEAR

; hwrect.asm
EXTERNDEF       HW_DrawRectAndBorder:NEAR
EXTERNDEF       HW_BeginRect:NEAR
EXTERNDEF       HW_BlockRect:NEAR
EXTERNDEF       HW_BorderRect:NEAR
EXTERNDEF       HW_EndRect:NEAR
EXTERNDEF       HW_SolidColorRectangle:NEAR

; hwstrblt.asm
EXTERNDEF       HW_BeginStretchSrcColorDstVram:NEAR
EXTERNDEF       HW_BlockStretchSrcColorDstVram:NEAR
EXTERNDEF       HW_EndStretchSrcColorDstVram:NEAR

; hwsysblt.asm
EXTERNDEF       HW_BeginSrcVramDstSystem:NEAR
EXTERNDEF       HW_BlockSrcVramDstSystem:NEAR
EXTERNDEF       HW_WaitSrcVramDstSystem:NEAR
EXTERNDEF       HW_EndSrcVramDstSystem:NEAR

; hwtext.asm
EXTERNDEF       HW_DrawOpaqueRects:NEAR
EXTERNDEF       HW_TextBegin:NEAR
EXTERNDEF       HW_TextBlt:NEAR
EXTERNDEF       HW_TextEnd:NEAR

; hwvrmblt.asm
EXTERNDEF       HW_BitBltSrcVramDstVram:NEAR
CLOSESEG _NVTEXT32
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; BITBLT

; This will be the frame for BitBlt that is shared between the generic
; code and SOME of the hardware specific bitblt routines. You may add
; locals as you need them.
BITBLT_FRAME_AND_LOCALS MACRO
PARMD   lpDstDev
PARMW   wDstX
PARMW   wDstY
PARMD   lpSrcDev
PARMW   wSrcX
PARMW   wSrcY
PARMW   wExtX
PARMW   wExtY
PARMD   dwRop3
PARMD   lpBrush
PARMD   lpDrawMode

; Generic code needs these
LOCALD  dwSrcBitsOffset
LOCALD  dwScansPerSeg

; Add hardware specific ones here.
ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; EXTTEXTOUT

; This will be the frame for ExtTextOut that is shared between the generic
; code and the hardware specific code. You may add locals as you need them.
EXTTEXTOUT_FRAME_AND_LOCALS     MACRO
PARMD   lpDstDev
PARMW   wDstX
PARMW   wDstY
PARMD   lpClipRect
PARMD   lpString
PARMW   wCount
PARMD   lpFontInfo
PARMD   lpDrawMode
PARMD   lpTextXForm
PARMD   lpKerning
PARMD   lpOpaqueRects
PARMW   wOptions

; Generic code needs these
LOCALD  dwDstBitsOffset
LOCALD  dwDstBitsDeltaScan
LOCALD  dwFgColor
LOCALD  dwBgColor
LOCALD  dwStringOffset
LOCALD  dwGlyphWidth
LOCALD  dwKerningOffset
LOCALD  dwDstYDstX
LOCALD  dwClipRight
LOCALD  dwGlyphCount
LOCALD  pHWLogDevCXOffset_ForExtTextOut
LOCALD  pHWBoardCXOffset_ForExtTextOut
LOCALV  wOpaqueClipRect,RECT
LOCALV  wTextClipRect,RECT
ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This macro allows you to call through function ptrs in other segments.
; I was using this alot in both the HWSPEC and GENERIC code so I put a
; macro in here to make it simple.
CALLFAR16IND    MACRO   lpfnFunc,sreg,reg
        mov     reg,SEG lpfnFunc
        mov     sreg,reg
        call    FFP16 PTR sreg:[lpfnFunc]
ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\INCLUDE\HWLOGDEV.H ===
/*=======================================================================

    Copyright (C), 1998 Nvidia Coporation

    File:       hwlogdev.h

    Purpose:    This file holds the HWLOGDEV structure and related data.
=========================================================================*/

typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;

// This structure holds dynamic data that is unique for each
// given instance of a PDEVICE (a logical device actually).
typedef struct  _HWLOGDEVCX
{
    // Set to non-0 if we are initting. Cleared on first modeset
    ULONG   dwInitting;

    // The HWBOARDCX attached to this HWLOGDEV
    ULONG   pHWBoardCX;

    // Keep the HWCRTCCX's around
    ULONG   pHWCrtcCX[MAX_ATTACHED_CRTCS];

    // These variables color depth dependent values for objects and
    // objet methods on this logical device.
    ULONG   dwRectAndTextColorFormat;
    ULONG   dwIndexedImageColorFormat;
    ULONG   dwImageFromCpuColorFormat;
    ULONG   dwSolidLinColorFormat;
    ULONG   dwColorAlphaMask;
    ULONG   dwPatternColorFormat;
    ULONG   dwColorPatternAndHeaderSize;
    ULONG   dwColorPatternMethodOffset;
    ULONG   dwPatternAlpha0;
    ULONG   dwPatternAlpha1;

    // Intel Diagnostic's stuff
    USHORT  wDiagInterfaceOpen;
    USHORT  wLastDiagError;

    // This holds the current offset of the logical desktop surface
    ULONG   dwLogicalSurfaceOffset;

    // DIRECTX STUFF
    // If DirectX is active then this variable is non-0; else it is 0.
    ULONG   dwDirectXActive;

    // This is to hold the callbacks into the internals of Direct Draw
    MYDDHALDDRAWFNS sDDHalDDrawFns;

    // Anybody can use this but it was created for the DirectX driver.
    // DirectX should really call every time there is a mode change to
    // get the available mode list, but some of the old DX apps need
    // the mode list before the 32bit driver has initted, so we need
    // something to give them. Note that this sounds CRTC specific
    // since it has to do with modes. It kinda is, but since it was
    // created for DirectX, it is really PDEVICE specific.
    ULONG   pMasterModeList;
    ULONG   lpMasterModeList;       // 16:16 ptr

    // pFlatDirectXSharedData is a flat ptr to the shared data.
    // pDirectXSharedData is a CXSel relative ptr to the shared data.
    ULONG   pDirectXSharedData;
    ULONG   lpDirectXSharedData;    // 16:16 ptr
}   HWLOGDEVCX;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\INCLUDE\SYSDATA.H ===
/*=============================================================================

    Copyright (C) 1997, NVidia Coporation

    File:       sysdata.h

    Purpose:    This file holds structures and equates dealing with the
                pdevice.

=============================================================================*/

typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;

// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
typedef struct _tagDIBHEADER
{
    ULONG       biSize;
    ULONG       biWidth;
    ULONG       biHeight;
    USHORT      biPlanes;
    USHORT      biBitCount;
    ULONG       biCompression;
    ULONG       biSizeImage;
    ULONG       biXPelsPerMeter;
    ULONG       biYPelsPerMeter;
    ULONG       biClrUsed;
    ULONG       biClrImportant;
}   DIBHEADER;
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// This structure is similar to what is defined in dibeng.inc.
// The differences are we use the reserved field for a few things.
// Hence this is essentially the DIBENGINE structure with
// different names for the modified fields.
typedef struct  _tagDIBENGINEHDR
{
    USHORT      deType;
    USHORT      deWidth;
    USHORT      deHeight;
    USHORT      deWidthBytes;
    UCHAR       dePlanes;
    UCHAR       deBitsPixel;
    ULONG       deReserved1;            // cannot be used. (bug #32933)
    ULONG       deDeltaScan;
    ULONG       delpPDevice;
    ULONG       deBitsOffset;
    USHORT      deBitsSelector;
    USHORT      deFlags;
    USHORT      deVersion;
    ULONG       deBitmapInfo;
    ULONG       deBeginAccess;
    ULONG       deEndAccess;

    // We're using this field to store the three fields that follow. In
    // multi-mon mode, we do not get the opportunity to create the bitmap
    // header so we can not increase the size.
//    ULONG       deDriverReserved;

    // This field should be filled in with the same value as is in the
    // deBitsPixel field except when the display driver is running
    // 15bpp. In this case, the deBitsPixel field will have 16 in it
    // and the bRealBpp field will have 15 in it.
    UCHAR       bRealBpp;

    // Reserved fields
    UCHAR       bTemp1;
    USHORT      wTemp2;
}   DIBENGINEHDR;
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// This structure is passed into ValidateMode
typedef struct  _tagMYDISPVALMODE
{
    USHORT  dvmSize;
    USHORT  dvmBpp;
    USHORT  dvmXRes;
    USHORT  dvmYRes;
}   MYDISPVALMODE;

#define MYVALMODE_YES           0
#define MYVALMODE_NO_WRONGDRV   1
#define MYVALMODE_NO_NOMEM      2
#define MYVALMODE_NO_NODAC      3
#define MYVALMODE_NO_UNKNOWN    4
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// This structure is returned by a call to VddGetDisplayInfo
typedef struct _tagDISPLAYINFO
{
    USHORT  diHdrSize;
    USHORT  diInfoFlags;

    ULONG   diDevNodeHandle;
    UCHAR   diDriverName[16];
    USHORT  diXRes;
    USHORT  diYRes;
    USHORT  diDPI;
    UCHAR   diPlanes;
    UCHAR   diBpp;
    USHORT  diRefreshRateMax;
    USHORT  diRefreshRateMin;
    USHORT  diLowHorz;
    USHORT  diHighHorz;
    USHORT  diLowVert;
    USHORT  diHighVert;
    ULONG   diMonitorDevNodeHandle;
    UCHAR   diHorzSyncPolarity;
    UCHAR   diVertSyncPolarity;

    // Only for Windows 98
    ULONG   diUnitNumber;             // device unit number
    ULONG   diDisplayFlags;           // mode specific flags
    ULONG   diXDesktopPos;            // position of desktop
    ULONG   diYDesktopPos;            // ...
    ULONG   diXDesktopSize;           // size of desktop (for panning)
    ULONG   diYDesktopSize;           // ...

    USHORT  wJimKellerRoundToDwordSize; // Solely to make the structure
                                        // size a multiple of a dword.
}   MYDISPLAYINFO;
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// These are some DirectDraw Init structures that get passed into the
// display driver.
typedef struct  _tagMYDDHALDDRAWFNS
{
    ULONG       dwSize;
    ULONG       lpSetInfo;
    ULONG       lpVidMemAlloc;
    ULONG       lpVidMemFree;
}   MYDDHALDDRAWFNS;

typedef struct _MYDCICMD
{
    ULONG   dwCommand;
    ULONG   dwParam1;
    ULONG   dwParam2;
    ULONG   dwVersion;
    ULONG   dwReserved;
} MYDCICMD;

typedef struct
{
    UCHAR   szName[260];            // 32-bit driver name
    UCHAR   szEntryPoint[64];       // entry point
    ULONG   dwContext;              // context to pass to entry point
} MYDD32BITDRIVERDATA;

typedef struct
{
    ULONG   dwHALVersion;           // Version of DirectDraw for which the
                                    //   HAL was created
    ULONG   dwReserved1;            // Reserved for future use
    ULONG   dwReserved2;            // Reserved for future use
} MYDDVERSIONDATA;

#define DDNVCREATEDRIVEROBJECT  98
#define DDNVDESTROYDRIVEROBJECT 99
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
// A few others things
typedef struct  _MYRECTL
{
    ULONG       dwLeft;
    ULONG       dwTop;
    ULONG       dwRight;
    ULONG       dwBottom;
}   MYRECTL;
// ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


///////////////////////////////////////////////////////////////////////
// Cursor information
#define CURSOR_SIZE     0x20        // 32x32 cursors
#define CURSOR_WIDTH    CURSOR_SIZE
#define CURSOR_HEIGHT   CURSOR_SIZE
#define AND_MASK_SIZE   ((CURSOR_WIDTH * CURSOR_HEIGHT) / 8)

// Not a true structure since bCursorXorMask is actually a variable
// length array, but this is good enough.
typedef struct  _tagCURSORDESC
{
    USHORT      wHotX;
    USHORT      wHotY;
    USHORT      wWidth;
    USHORT      wHeight;
    USHORT      wWidthBytes;
    UCHAR       bPlanes;
    UCHAR       bBitsPerPixel;
    UCHAR       bCursorAndMask[AND_MASK_SIZE];
    UCHAR       bCursorXorMask;
}   CURSORDESC;
///////////////////////////////////////////////////////////////////////

// Not a true structure since bCursorXorMask is actually a variable
// length array, but this is good enough.
typedef struct  _tagCURSORHEADER
{
    USHORT      wHotX;
    USHORT      wHotY;
    USHORT      wWidth;
    USHORT      wHeight;
    USHORT      wWidthBytes;
    UCHAR       bPlanes;
    UCHAR       bBitsPerPixel;
}   CURSORHEADER;
///////////////////////////////////////////////////////////////////////

typedef struct  _tagMODULELINK
{
    ULONG       lpfnFunc;
    USHORT      wOrdinal;
}   MODULELINK;
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
// Since we don't know whether we will be running on a wide OS or not,
// we will need to define both.
typedef struct _OSVERSIONINFOW
{
    ULONG   dwOSVersionInfoSize;
    ULONG   dwMajorVersion;
    ULONG   dwMinorVersion;
    ULONG   dwBuildNumber;
    ULONG   dwPlatformId;
    USHORT  szCSDVersion[128];
}   OSVERSIONINFOW;

typedef struct _OSVERSIONINFOA
{
    ULONG   dwOSVersionInfoSize;
    ULONG   dwMajorVersion;
    ULONG   dwMinorVersion;
    ULONG   dwBuildNumber;
    ULONG   dwPlatformId;
    UCHAR   szCSDVersion[128];
}   OSVERSIONINFOA;
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
#define MAX_ATTACHED_CRTCS      2
///////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\INCLUDE\MINIVDD.INC ===
ifndef _MINIVDD_H_
_MINIVDD_H_     EQU     1
ifndef Not_VxD
ifdef MINIVDD
ifdef NEC_98
Begin_Service_Table VDD
VDD_Service      VDD_Get_Version
VDD_Service      VDD_PIF_State
VDD_Service      VDD_Get_GrabRtn
VDD_Service      VDD_Hide_Cursor
VDD_Service      VDD_Set_VMType
VDD_Service      VDD_Get_ModTime
VDD_Service      VDD_Set_HCurTrk
VDD_Service      VDD_Msg_ClrScrn
VDD_Service      VDD_Msg_ForColor
VDD_Service      VDD_Msg_BakColor
VDD_Service      VDD_Msg_TextOut
VDD_Service      VDD_Msg_SetCursPos
VDD_Service      VDD_Query_Access
VDD_Service      VDD_Check_Update_Soon
VDD_Service      VDD_Get_Mini_Dispatch_Table
VDD_Service      VDD_Register_Virtual_Port
VDD_Service      VDD_Get_VM_Info
VDD_Service      VDD_Get_Special_VM_IDs
VDD_Service      VDD_Register_Extra_Screen_Selector
VDD_Service      VDD_Takeover_VGA_Port
VDD_Service      VDD_Get_DISPLAYINFO
VDD_Service      VDD_Do_Physical_IO
VDD_Service      VDD_Register_Mini_VDD
VDD_Service      VDD_Install_IO_Handler
VDD_Service      VDD_Install_Mult_IO_Handlers
VDD_Service      VDD_Enable_Local_Trapping
VDD_Service      VDD_Disable_Local_Trapping
VDD_Service      VDD_Trap_Suspend
VDD_Service      Test_Vid_VM_Handle
VDD_Service      VDD_Set_Core_Graphics
VDD_Service      VDD_Load_AccBIOS
VDD_Service      VDD_Map_AccBIOS
VDD_Service      VDD_Map_VRAM
VDD_Service      VDD_EnableDevice
End_Service_Table VDD
else
Begin_Service_Table VDD
VDD_Service      VDD_Get_Version
VDD_Service      VDD_PIF_State
VDD_Service      VDD_Get_GrabRtn
VDD_Service      VDD_Hide_Cursor
VDD_Service      VDD_Set_VMType
VDD_Service      VDD_Get_ModTime
VDD_Service      VDD_Set_HCurTrk
VDD_Service      VDD_Msg_ClrScrn
VDD_Service      VDD_Msg_ForColor
VDD_Service      VDD_Msg_BakColor
VDD_Service      VDD_Msg_TextOut
VDD_Service      VDD_Msg_SetCursPos
VDD_Service      VDD_Query_Access
VDD_Service      VDD_Check_Update_Soon
VDD_Service      VDD_Get_Mini_Dispatch_Table
VDD_Service      VDD_Register_Virtual_Port
VDD_Service      VDD_Get_VM_Info
VDD_Service      VDD_Get_Special_VM_IDs
VDD_Service      VDD_Register_Extra_Screen_Selector
VDD_Service      VDD_Takeover_VGA_Port
VDD_Service      VDD_Get_DISPLAYINFO
VDD_Service      VDD_Do_Physical_IO
VDD_Service      VDD_Set_Sleep_Flag_Addr
VDD_Service      VDD_EnableDevice
End_Service_Table VDD
endif
endif
VDD_VerNum                      EQU     0400H
VDD_MinVerNum                   EQU     030AH
ifdef NEC_98
bVidTextMd                      EQU     4
fVidTextMd                      EQU     (1 SHL 4)
bVidNTModeFF                    EQU     0
fVidNTModeFF                    EQU     (1 SHL 0)
bVidNTModeFFC16                 EQU     1
fVidNTModeFFC16                 EQU     (1 SHL 1)
bVidNTDispRW                    EQU     2
fVidNTDispRW                    EQU     (1 SHL 2)
bVidNTPal                       EQU     3
fVidNTPal                       EQU     (1 SHL 3)
bVidNTGDC                       EQU     5
fVidNTGDC                       EQU     (1 SHL 5)
bVidNTGDCTON                    EQU     6
fVidNTGDCTON                    EQU     (1 SHL 6)
bVidNTGDCGON                    EQU     7
fVidNTGDCGON                    EQU     (1 SHL 7)
bVidNTFont                      EQU     8
fVidNTFont                      EQU     (1 SHL 8)
bVidCRTC                        EQU     9
fVidCRTC                        EQU     (1 SHL 9)
bVidDispDataXfer                EQU     10
fVidDispDataXfer                EQU     (1 SHL 10)
bVidXFERPlane0                  EQU     11
fVidXFERPlane0                  EQU     (1 SHL 11)
bVidXFERPlane1                  EQU     12
fVidXFERPlane1                  EQU     (1 SHL 12)
bVidXFERPlane2                  EQU     13
fVidXFERPlane2                  EQU     (1 SHL 13)
bVidXFERPlane3                  EQU     14
fVidXFERPlane3                  EQU     (1 SHL 14)
mVidXFERPlane                   EQU     (fVidXFERPlane0+fVidXFERPlane1+fVidXFERPlane2+fVidXFERPlane3)
mVidNTH98                       EQU     (fVidNTModeFF+fVidNTModeFFC16+fVidNTDispRW+fVidNTPal+fVidNTGDC+fVidNTGDCTON+fVidNTGDCGON)
else
fVidTxtEmulate                  EQU     0001H
fVidNoTrpTxt                    EQU     0002H
fVidNoTrpLRGrfx                 EQU     0004H
fVidNoTrpHRGrfx                 EQU     0008H
fVidTextMd                      EQU     0010H
fVidLowRsGrfxMd                 EQU     0020H
fVidHghRsGrfxMd                 EQU     0040H
fVidRetainAllo                  EQU     0080H
endif

ifdef NEC_98
REGISTER_DISPLAY_DRIVER         EQU     0
PRE_HIRES_TO_VGA                EQU     1
SAVE_REGISTERS                  EQU     2
RESTORE_REGISTERS               EQU     3
ENABLE_TRAPS                    EQU     4
DISABLE_TRAPS                   EQU     5
DISPLAY_DRIVER_DISABLING        EQU     6
ENABLE_ACCELERATER              EQU     7
DISABLE_ACCELERATER             EQU     8
CHECK_UPDATE                    EQU     9
CHECK_WINDOWED                  EQU     10
ACC_VBE_PM                      EQU     11
ACC_VBE_DDC                     EQU     12
ACC_INT_10                      EQU     13
ACC_GET_CAPABILITIES            EQU     14
ACC_GET_EXT_MODE_INFO           EQU     15
ACC_GET_FLAT_SELECTOR           EQU     16
ACC_ENABLE_BIOS                 EQU     17
ACC_DISABLE_BIOS                EQU     18
ACC_SET_PALETTE                 EQU     19
ACC_GET_PALETTE                 EQU     20
ACC_SET_CURSOR                  EQU     21
ACC_SHOW_CURSOR                 EQU     22
ACC_HIDE_CURSOR                 EQU     23
ACC_SET_CURSOR_POS              EQU     24
ACC_GET_CURSOR_POS              EQU     25
NBR_MINI_VDD_FUNCTIONS_40       EQU     26
GET_NUM_UNITS                   EQU     26
SET_ADAPTER_POWER_STATE         EQU     27
GET_ADAPTER_POWER_STATE_CAPS    EQU     28
SET_MONITOR_POWER_STATE         EQU     29
GET_MONITOR_POWER_STATE_CAPS    EQU     30
GET_MONITOR_INFO                EQU     31
I2C_OPEN                        EQU     32
I2C_ACCESS                      EQU     33
GPIO_OPEN                       EQU     34
GPIO_ACCESS                     EQU     35
COPYPROTECTION_ACCESS           EQU     36
NBR_MINI_VDD_FUNCTIONS_41       EQU     37
ifdef MAINVDD
NBR_MINI_VDD_FUNCTIONS          EQU     NBR_MINI_VDD_FUNCTIONS_41
else
NBR_MINI_VDD_FUNCTIONS          EQU     NBR_MINI_VDD_FUNCTIONS_40
endif
else
REGISTER_DISPLAY_DRIVER         EQU     0
GET_VDD_BANK                    EQU     1
SET_VDD_BANK                    EQU     2
RESET_BANK                      EQU     3
PRE_HIRES_TO_VGA                EQU     4
POST_HIRES_TO_VGA               EQU     5
PRE_VGA_TO_HIRES                EQU     6
POST_VGA_TO_HIRES               EQU     7
SAVE_REGISTERS                  EQU     8
RESTORE_REGISTERS               EQU     9
MODIFY_REGISTER_STATE           EQU     10
ACCESS_VGA_MEMORY_MODE          EQU     11
ACCESS_LINEAR_MEMORY_MODE       EQU     12
ENABLE_TRAPS                    EQU     13
DISABLE_TRAPS                   EQU     14
MAKE_HARDWARE_NOT_BUSY          EQU     15
VIRTUALIZE_CRTC_IN              EQU     16
VIRTUALIZE_CRTC_OUT             EQU     17
VIRTUALIZE_SEQUENCER_IN         EQU     18
VIRTUALIZE_SEQUENCER_OUT        EQU     19
VIRTUALIZE_GCR_IN               EQU     20
VIRTUALIZE_GCR_OUT              EQU     21
SET_LATCH_BANK                  EQU     22
RESET_LATCH_BANK                EQU     23
SAVE_LATCHES                    EQU     24
RESTORE_LATCHES                 EQU     25
DISPLAY_DRIVER_DISABLING        EQU     26
SELECT_PLANE                    EQU     27
PRE_CRTC_MODE_CHANGE            EQU     28
POST_CRTC_MODE_CHANGE           EQU     29
VIRTUALIZE_DAC_OUT              EQU     30
VIRTUALIZE_DAC_IN               EQU     31
GET_CURRENT_BANK_WRITE          EQU     32
GET_CURRENT_BANK_READ           EQU     33
SET_BANK                        EQU     34
CHECK_HIRES_MODE                EQU     35
GET_TOTAL_VRAM_SIZE             EQU     36
GET_BANK_SIZE                   EQU     37
SET_HIRES_MODE                  EQU     38
PRE_HIRES_SAVE_RESTORE          EQU     39
POST_HIRES_SAVE_RESTORE         EQU     40
VESA_SUPPORT                    EQU     41
GET_CHIP_ID                     EQU     42
CHECK_SCREEN_SWITCH_OK          EQU     43
VIRTUALIZE_BLTER_IO             EQU     44
SAVE_MESSAGE_MODE_STATE         EQU     45
SAVE_FORCED_PLANAR_STATE        EQU     46
VESA_CALL_POST_PROCESSING       EQU     47
PRE_INT_10_MODE_SET             EQU     48
NBR_MINI_VDD_FUNCTIONS_40       EQU     49
GET_NUM_UNITS                   EQU     49
TURN_VGA_OFF                    EQU     50
TURN_VGA_ON                     EQU     51
SET_ADAPTER_POWER_STATE         EQU     52
GET_ADAPTER_POWER_STATE_CAPS    EQU     53
SET_MONITOR_POWER_STATE         EQU     54
GET_MONITOR_POWER_STATE_CAPS    EQU     55
GET_MONITOR_INFO                EQU     56
I2C_OPEN                        EQU     57
I2C_ACCESS                      EQU     58
GPIO_OPEN                       EQU     59
GPIO_ACCESS                     EQU     60
COPYPROTECTION_ACCESS           EQU     61
NBR_MINI_VDD_FUNCTIONS_41       EQU     62
ifdef MAINVDD
NBR_MINI_VDD_FUNCTIONS          EQU     NBR_MINI_VDD_FUNCTIONS_41
else
NBR_MINI_VDD_FUNCTIONS          EQU     NBR_MINI_VDD_FUNCTIONS_40
endif
endif
endif
VDD_QUERY_VERSION               EQU     0
MINIVDD_SVC_BASE_OFFSET         EQU     80H
VDD_DRIVER_REGISTER             EQU     (0+MINIVDD_SVC_BASE_OFFSET)
VDD_DRIVER_UNREGISTER           EQU     (1+MINIVDD_SVC_BASE_OFFSET)
VDD_SAVE_DRIVER_STATE           EQU     (2+MINIVDD_SVC_BASE_OFFSET)
VDD_REGISTER_DISPLAY_DRIVER_INFO EQU    (3+MINIVDD_SVC_BASE_OFFSET)
VDD_REGISTER_SSB_FLAGS          EQU     (4+MINIVDD_SVC_BASE_OFFSET)
VDD_GET_DISPLAY_CONFIG          EQU     (5+MINIVDD_SVC_BASE_OFFSET)
VDD_PRE_MODE_CHANGE             EQU     (6+MINIVDD_SVC_BASE_OFFSET)
VDD_POST_MODE_CHANGE            EQU     (7+MINIVDD_SVC_BASE_OFFSET)
VDD_SET_USER_FLAGS              EQU     (8+MINIVDD_SVC_BASE_OFFSET)
VDD_SET_BUSY_FLAG_ADDR          EQU     (9+MINIVDD_SVC_BASE_OFFSET)
VDD_PC98_RESERVED               EQU     (10+MINIVDD_SVC_BASE_OFFSET)
VDD_VBE_PM                      EQU     (10+MINIVDD_SVC_BASE_OFFSET)
VDD_ENABLE                      EQU     (11+MINIVDD_SVC_BASE_OFFSET)
VDD_GETMEMBASE                  EQU     (12+MINIVDD_SVC_BASE_OFFSET)
VDD_OPEN                        EQU     (13+MINIVDD_SVC_BASE_OFFSET)
VDD_CLOSE                       EQU     (14+MINIVDD_SVC_BASE_OFFSET)
VDD_OPEN_KEY                    EQU     (15+MINIVDD_SVC_BASE_OFFSET)
VDD_SET_POWER_STATE             EQU     (16+MINIVDD_SVC_BASE_OFFSET)
VDD_GET_POWER_STATE_CAPS        EQU     (17+MINIVDD_SVC_BASE_OFFSET)
VDD_GET_DISPLAY_CONFIG2         EQU     8085H
ENABLE_IO                       EQU     00000001H
ENABLE_MEM                      EQU     00000002H
ENABLE_VGA                      EQU     00000030H
ENABLE_ROM                      EQU     00000080H
ENABLE_ALL                      EQU     000000FFH
ENABLE_NONE                     EQU     00000000H
ENABLE_VALID                    EQU     000000FFH
ENABLE_ERROR                    EQU     0FFFFFFFFH
VDD_OPEN_EXIST                  EQU     00000001H
VDD_OPEN_ENUM                   EQU     00000002H
VDD_OPEN_LOCK                   EQU     00000000H
VDD_OPEN_TEST                   EQU     VDD_OPEN_EXIST
VDD_OPEN_KEY_WRITE              EQU     00000001H
VDD_OPEN_KEY_READ               EQU     00000002H
VDD_OPEN_KEY_USER               EQU     00000010H
VDD_OPEN_KEY_GLOBAL             EQU     00000020H
VDD_IOCTL_SET_NOTIFY            EQU     10000001H
VDD_IOCTL_GET_DDHAL             EQU     10000002H
VDD_IOCTL_COPY_PROTECTION       EQU     10000003H
VDD_IOCTL_I2C_OPEN              EQU     10000004H
VDD_IOCTL_I2C_ACCESS            EQU     10000005H

tagVDD_IOCTL_SET_NOTIFY_INPUT   STRUC
        NotifyMask      DD      ?
        NotifyType      DD      ?
        NotifyProc      DD      ?
        NotifyData      DD      ?
tagVDD_IOCTL_SET_NOTIFY_INPUT   ENDS

VDD_NOTIFY_START_MODE_CHANGE    EQU     00000001H
VDD_NOTIFY_END_MODE_CHANGE      EQU     00000002H
VDD_NOTIFY_ENABLE               EQU     00000004H
VDD_NOTIFY_DISABLE              EQU     00000008H
VDD_NOTIFY_TYPE_CALLBACK        EQU     1
BYTE_LENGTHED                   EQU     1
WORD_LENGTHED                   EQU     2
GOING_TO_WINDOWS_MODE           EQU     1
GOING_TO_VGA_MODE               EQU     2
DISPLAY_DRIVER_DISABLED         EQU     4
IN_WINDOWS_HIRES_MODE           EQU     8

DISPLAYINFO     STRUC
        diHdrSize               DW      ?
        diInfoFlags             DW      ?
        diDevNodeHandle         DD      ?
        diDriverName            DB      16 DUP (?)
        diXRes                  DW      ?
        diYRes                  DW      ?
        diDPI                   DW      ?
        diPlanes                DB      ?
        diBpp                   DB      ?
        diRefreshRateMax        DW      ?
        diRefreshRateMin        DW      ?
        diLowHorz               DW      ?
        diHighHorz              DW      ?
        diLowVert               DW      ?
        diHighVert              DW      ?
        diMonitorDevNodeHandle  DD      ?
        diHorzSyncPolarity      DB      ?
        diVertSyncPolarity      DB      ?
        diUnitNumber            DD      ?
        diDisplayFlags          DD      ?
        diXDesktopPos           DD      ?
        diYDesktopPos           DD      ?
        diXDesktopSize          DD      ?
        diYDesktopSize          DD      ?
DISPLAYINFO     ENDS

DISPLAYINFO_SIZE                equ     diRefreshRateMax+2-diHdrSize
DISPLAYINFO_SIZE1               equ     diBpp+1-diHdrSize
DISPLAYINFO_SIZE2               equ     diVertSyncPolarity+1-diHdrSize
DISPLAYINFO_SIZE3               equ     diMemorySize+4-diHdrSize

RETURNED_DATA_IS_STALE          EQU     0001H
MINIVDD_FAILED_TO_LOAD          EQU     0002H
MINIVDD_CHIP_ID_DIDNT_MATCH     EQU     0004H
REGISTRY_BPP_NOT_VALID          EQU     0008H
REGISTRY_RESOLUTION_NOT_VALID   EQU     0010H
REGISTRY_DPI_NOT_VALID          EQU     0020H
MONITOR_DEVNODE_NOT_ACTIVE      EQU     0040H
MONITOR_INFO_NOT_VALID          EQU     0080H
MONITOR_INFO_DISABLED_BY_USER   EQU     0100H
REFRESH_RATE_MAX_ONLY           EQU     0200H
CARD_VDD_LOADED_OK              EQU     0400H
DEVICE_IS_NOT_VGA               EQU     0800H
NoTrace_VIRTUALIZE_CRTC_IN      EQU     1
NoTrace_VIRTUALIZE_CRTC_OUT     EQU     1
NoTrace_VIRTUALIZE_SEQUENCER_IN EQU     1
NoTrace_VIRTUALIZE_SEQUENCER_OUT EQU    1
NoTrace_VIRTUALIZE_GCR_IN       EQU     1
NoTrace_VIRTUALIZE_GCR_OUT      EQU     1
NoTrace_VIRTUALIZE_DAC_OUT      EQU     1
NoTrace_VIRTUALIZE_DAC_IN       EQU     1
NoTrace_CHECK_HIRES_MODE        EQU     1

ifdef NEC_98

                            
vFlg_Machine_Std                equ                     00000001b
vFlg_Machine_Multi              equ                     00000010b
vFlg_Machine_Mate               equ                     00000100b
vFlg_Machine_H98                equ                     00001000b
vFlg_CRT_New                    equ                     00010000b
vFlg_CRT_NonInter               equ                     00100000b
vFlg_GDC_5MHz                   equ                     01000000b
vFlg_GDC_Emulate                equ                     10000000b
vFlg_Acc_Internal               equ             0000000100000000b
vFlg_Acc_External               equ             0000001000000000b
vFlg_Acc_PCI                    equ             0000010000000000b
vFlg_Acc_ML                     equ             0000100000000000b
vFlg_Acc_PVD                    equ             0001000000000000b
vFlg_Mode_NH                    equ             0010000000000000b
vFlg_Mode_H                     equ             0100000000000000b
vFlg_Initialized                equ             1000000000000000b
vFlg_Opt_MFR                    equ     000000010000000000000000b
vFlg_Opt_NewMFR                 equ     000000100000000000000000b
vFlg_Opt_VDP                    equ     000001000000000000000000b
vFlg_Opt_NewVDP                 equ     000010000000000000000000b

vFlg_Local                      equ     000000000100000010000000b


MaxMiniVDD                      equ     16
MaxMiniTrap                     equ     32
MaxMultiTrap                    equ     3
MaxMultiFunc                    equ     MaxMiniVDD





LT_Enable                       equ     00000001b
LT_Enable_bit                   equ     0
LT_Initialized                  equ     10000000b
LT_Initialized_bit              equ     7



Vids_struct struc



        Vids_SFlags             dd      ?
        Vids_CB_Offset          dd      ?
        Vids_Msg_Pseudo_VM      dd      ?




        VDD_TGDC_Draw_Off       dd      ?
        VDD_TGDC_Sync_Off       dd      ?
        VDD_TGDC_Sync_On        dd      ?
        VDD_TGDC_FIFO_Empty     dd      ?
        VDD_GGDC_Draw_Off       dd      ?
        VDD_GGDC_Sync_Off       dd      ?
        VDD_GGDC_Sync_On        dd      ?
        VDD_GGDC_FIFO_Empty     dd      ?
        VDD_GGDC_MOD_Emulate    dd      ?




        H98_FLORA_Change        dd      ?
        H98_Clear_Text          dd      ?
        H98_Rest_GCs            dd      ?
        H98_Rest_etc            dd      ?
        H98_Save_ModeFF         dd      ?

Vids_struct ends


Vid_SFlags                      equ     <Vids.Vids_SFlags>
VDD_CB_Offset                   equ     <Vids.Vids_CB_Offset>
VDD_Msg_Pseudo_VM               equ     <Vids.Vids_Msg_Pseudo_VM>

TGDC_Draw_Off                   equ     <Vids.VDD_TGDC_Draw_Off>
GGDC_Draw_Off                   equ     <Vids.VDD_GGDC_Draw_Off>
TGDC_Sync_On                    equ     <Vids.VDD_TGDC_Sync_On>
TGDC_Sync_Off                   equ     <Vids.VDD_TGDC_Sync_Off>
TGDC_FIFO_Empty                 equ     <Vids.VDD_TGDC_FIFO_Empty>
GGDC_FIFO_Empty                 equ     <Vids.VDD_GGDC_FIFO_Empty>





MiniFuncStruct  STRUC
        MF_ProcAddr             dd      ?
MiniFuncStruct  ENDS


MiniVDD_Proc_Struct     STRUC
        Proc_Address            dd      ?
        Proc_Order              dw      ?
        Proc_MiniID             db      ?
        Proc_Flags              db      ?
MiniVDD_Proc_Struct     ENDS

.errnz  (size MiniVDD_Proc_Struct) mod 4





MiniVDD_GTrap_Struct    STRUC
        GTrap_ProcAddr          dd      ?
        GTrap_PortAddr          dw      ?
        GTrap_NumMini           dw      ?
        GTrap_ProcTable         db      ((size MiniVDD_Proc_Struct) * MaxMultiTrap) dup (?)
MiniVDD_GTrap_Struct    ENDS

MiniVDD_LTrap_Struct    STRUC
        LTrap_ProcAddr          dd      ?
        LTrap_Status            db      ?
        LTrap_Flags             db      MaxMultiTrap dup (?)
MiniVDD_LTrap_Struct    ENDS




EndMiniFunc_    MACRO   n
ifdef   MiniFunc&n
        dd      OFFSET32 MiniFunc&n
else
        dd      0
endif
                ENDM

MiniFunc_       MACRO   FuncID, FuncName
                MiniFunc&FuncID equ <FuncName>
                ENDM

BeginMiniFunc   MACRO   TableName
public  TableName
TableName       label   near
                ENDM

if 1
EndMiniFunc     MACRO   TableName
                x = 0
                REPT    NBR_MINI_VDD_FUNCTIONS_41
                EndMiniFunc_    %x
                x = x + 1
                ENDM
                ENDM
else
EndMiniFunc     MACRO   TableName
                x = 0
                REPT    NBR_MINI_VDD_FUNCTIONS
                EndMiniFunc_    %x
                x = x + 1
                ENDM
                ENDM
endif

MiniFunc        MACRO   FuncID, FuncName
                MiniFunc_ %(FuncID), <FuncName>
                ENDM




MiniVDDCall     MACRO   FuncID, SetCarry
                local   MiniCall_Loop
                local   MiniCall_Exit

                push    ecx
                push    esi
                lea     esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
                mov     ecx, [MiniVDD_NumMini]
MiniCall_Loop:
                cmp     dword ptr [esi.Proc_Address], 0
                jz      MiniCall_Exit
                pushad
ifnb <SetCarry>
                stc
endif
                call    dword ptr [esi.Proc_Address]
                popad
                jc      MiniCall_Exit
                add     esi, size MiniVDD_Proc_Struct
                loop    MiniCall_Loop
MiniCall_Exit:
                pop     esi
                pop     ecx
                ENDM



MiniVDDCall2    MACRO   FuncID, SetCarry
                local   MiniCall_Exit
                local   MiniCall_Proc

                push    ecx
                push    esi
                lea     esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
MiniCall_Proc:
                cmp     dword ptr [esi.Proc_Address], 0
                jz      MiniCall_Exit
                pushad
ifnb <SetCarry>
                stc
endif
                call    dword ptr [esi.Proc_Address]
                popad
MiniCall_Exit:
                pop     esi
                pop     ecx
                ENDM



MiniVDDCall3    MACRO   FuncID, MiniID, SetCarry
                local   MiniCall_Exit
                local   MiniCall_Loop
                local   MiniCall_Proc

                push    ecx
                push    esi
                lea     esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
                movzx   ecx, MiniID
MiniCall_Loop:
                cmp     ecx, 0
                jz      MiniCall_Proc
                add     esi, size MiniVDD_Proc_Struct
                dec     ecx
                jmp     MiniCall_Loop
MiniCall_Proc:
                cmp     dword ptr [esi.Proc_Address], 0
                jz      MiniCall_Exit
                pushad
ifnb <SetCarry>
                stc
endif
                call    dword ptr [esi.Proc_Address]
                popad
MiniCall_Exit:
                pop     esi
                pop     ecx
                ENDM




MiniVDDFunc     MACRO   TmpReg, FuncID
                mov     TmpReg, [MiniVDD_Func_Table.Proc_Address][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
                ENDM











ExecModeLL      macro   Num
ExecMode_L&Num:
                endm

ExecModeLE      macro   Num
ExecMode_E&Num:
                endm

ExecModeJE      macro   Num
        jmp     ExecMode_E&Num
                endm

ExecModeJZ      macro   Num
        jz      ExecMode_L&Num
                endm

ExecModeJNZ     macro   Num
        jnz     ExecMode_L&Num
                endm

ExecModeJEZ     macro   Num
        jz      ExecMode_E&Num
                endm

ExecModeJENZ    macro   Num
        jnz     ExecMode_E&Num
                endm


ExecModeTest    macro   ModeFlag, CB_Reg
if      ModeFlag and vFlg_Local
ifidni  <CB_Reg>, <Vid>
        push    ebx
        mov     ebx, [Vid_VM_Handle]
        add     ebx, [VDD_CB_Offset]
        test    [ebx.VDD_SFlags], ModeFlag
        pop     ebx
else
ifidni  <CB_Reg>, <Cur>
        push    ebx
        VMMCall Get_Cur_VM_Handle
        add     ebx, [VDD_CB_Offset]
        test    [ebx.VDD_SFlags], ModeFlag
        pop     ebx
else
ifb     <CB_Reg>
        push    ebx
        add     ebx, [VDD_CB_Offset]
        test    [ebx.VDD_SFlags], ModeFlag
        pop     ebx
else
        test    [CB_Reg.VDD_SFlags], ModeFlag
endif
endif
endif
else
        test    [Vid_SFlags], ModeFlag
endif
        endm


ExecModeChk     macro   HdrFlag, JmpFlag, JmpLabel, ModeFlag, CB_Reg
ifidni  <HdrFlag>, <Jmp>
.erre   FlgExecMode
        ExecModeJE      %EndExecMode
endif
ExecModeLL      %NumExecMode
NumExecMode = NumExecMode + 1
FlgExecMode = 1
ifnb    <ModeFlag>
        ExecModeTest    <ModeFlag>, <CB_Reg>
ifidni  <JmpLabel>, <End>
ifidni  <JmpFlag>, <Not>
        ExecModeJENZ    %EndExecMode
else
        ExecModeJEZ     %EndExecMode
endif
else
ifidni  <JmpFlag>, <Not>
        ExecModeJNZ     %NumExecMode
else
        ExecModeJZ      %NumExecMode
endif
endif
endif
                endm

ExecModeEnd     macro
ExecModeLL      %NumExecMode
ExecModeLE      %EndExecMode
NumExecMode = NumExecMode + 1
EndExecMode = EndExecMode + 1
FlgExecMode = 0
                endm





ExecModeJmp     macro   JmpLabel, ModeFlag, CB_Reg
        ExecModeTest    %ModeFlag, <CB_Reg>
        jnz     JmpLabel
                endm

ExecModeJmpNot  macro   JmpLabel, ModeFlag, CB_Reg
        ExecModeTest    %ModeFlag, <CB_Reg>
        jz      JmpLabel
                endm

ExecMode        macro   ModeFlag, CB_Reg
        ExecModeChk Top, Equ, Next, %ModeFlag, CB_Reg
                endm

ExecModeNot     macro   ModeFlag, CB_Reg
        ExecModeChk Top, Not, Next, %ModeFlag, CB_Reg
                endm

ExecModeOnly    macro   ModeFlag, CB_Reg
        ExecModeChk Top, Equ, End, %ModeFlag, CB_Reg
                endm

ExecModeOnlyNot macro   ModeFlag, CB_Reg
        ExecModeChk Top, Not, End, %ModeFlag, CB_Reg
                endm

ExecModeElse    macro   ModeFlag, CB_Reg
        ExecModeChk Jmp, Equ, Next, %ModeFlag, CB_Reg
                endm

ExecModeElseNot macro   ModeFlag, CB_Reg
        ExecModeChk Jmp, Not, Next, %ModeFlag, CB_Reg
                endm

ExecModeThru    macro   ModeFlag, CB_Reg
        ExecModeChk Thru, Equ, Next, %ModeFlag, CB_Reg
                endm

ExecModeThruNot macro   ModeFlag, CB_Reg
        ExecModeChk Thru, Not, Next, %ModeFlag, CB_Reg
                endm

NumExecMode = 1
EndExecMode = 1
FlgExecMode = 0

else




ifdef MAINVDD
externdef       MiniVDDDispatchTable:dword
endif


MiniVDDDispatch         macro   FunctionCode, HandlerAddr
        mov     [edi+(FunctionCode*4)],OFFSET32 MiniVDD_&HandlerAddr
endm


CardVDDDispatch         macro   FunctionCode, HandlerAddr
        mov     [edi+(FunctionCode*4)],OFFSET32 CardVDD_&HandlerAddr
endm


MiniVDDCall             macro   FunctionCode, SaveFlags
local   MiniVDDCallExit, MiniVDDCallLeave

ifdef MAXDEBUG
  ifndef NoTrace_&FunctionCode&
        Trace_Out "MiniVDDCall: &FunctionCode&"
  endif
endif
        push    edi
ifnb    <SaveFlags>
        pushfd
endif
        mov     edi,OFFSET32 MiniVDDDispatchTable
        cmp     dword ptr [edi+(FunctionCode*4)],0
        je      MiniVDDCallLeave
ifnb    <SaveFlags>
        popfd
endif
        call    dword ptr [edi+(FunctionCode*4)]
ifnb    <SaveFlags>
        jmp     MiniVDDCallExit
endif

MiniVDDCallLeave:
ifnb    <SaveFlags>
        popfd
endif

MiniVDDCallExit:
        pop     edi
endm
endif

endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\win9x.mhd\HWSPEC\INCLUDE\HWMACS.INC ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Copyright (C) 1998-1999, Nvidia Corporation
;
; File:         hwmacs.inc
;
; Purpose:      This file holds some macros that thehardware specific
;               code uses.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; A build option
DOIOTOFLUSHCACHE                TEXTEQU <1>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IDEBUG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;USE_ALPHA_CURSOR                TEXTEQU <0>
USE_ALPHA_CURSOR                TEXTEQU <1>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
HW_WAIT                         TEXTEQU <0>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
JMP_COMMAND                     TEXTEQU <20000000H>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CHNOFF          MACRO   HwSegMember
        EXITM   <(OFFSET GDICHAN.&HwSegMember - OFFSET GDICHAN.StartOfChannelHdr)>
ENDM

CHNRUN          MACRO   HwSegMember,runlen
        EXITM   <(CHNOFF(HwSegMember) + ((runlen) SHL 18))>
ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
WAIT_UNTIL_OTHER_CONTEXTS_IDLE  MACRO   sreg,hwcxreg,tempreg,mylabel
        LOCAL   skip,dskip

IF      (HW_WAIT NE 0)
        mov     tempreg,sreg:[hwcxreg].HWBOARDCX.dwGdiDriverChannelID
        cmp     tempreg,sreg:[hwcxreg].HWBOARDCX.dwCurrentChannelID
        jne     dskip
        push    hwcxreg
        call    WaitUntilGdiContextIdle
dskip:
ENDIF
        ; This macro should test a bit to see if any other contexts
        ; are active. If there are, then it should call the function
        ; WaitUntilOtherContextsIdle. The sreg:reg should point to
        ; the PDEVICE. tempreg will be trashed.
        mov     tempreg,sreg:[hwcxreg].HWBOARDCX.dwGdiDriverChannelID
        cmp     tempreg,sreg:[hwcxreg].HWBOARDCX.dwCurrentChannelID
        je      skip
        mov     sreg:[hwcxreg].HWBOARDCX.dwCurrentChannelID,tempreg
        push    hwcxreg
        call    WaitUntilOtherContextsIdle

        IFNB    <mylabel>
                jmp     mylabel
        ENDIF
skip:
ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CHECKDMASPACE   MACRO   sreg,hwcxreg,pushbufferreg,bytes
        LOCAL   skip, skip2

IFDIFI  <pushbufferreg>,<edi>
        IFDIFI  <pushbufferreg>,<NONE>
                echo  pushbufferreg_ argument must either be edi or NONE in CHECKDMASPACE
                .err
        ENDIF
ENDIF
        sub     sreg:[hwcxreg].HWBOARDCX.dwBytesFree,bytes
        jge     skip
IFDIFI  <pushbufferreg>,<NONE>
        mov     sreg:[hwcxreg].HWBOARDCX.pCurrentPushBufferOffset,pushbufferreg
ENDIF
        push    hwcxreg
        pushd   bytes
        call    WaitForDmaBufferSpace

IFDIFI  <pushbufferreg>,<NONE>
        mov     pushbufferreg,sreg:[hwcxreg].HWBOARDCX.pCurrentPushBufferOffset
ENDIF


skip:
ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SETDMASTATUS    MACRO   stataddr
        mov     stataddr,-1
ENDM

WAITDMASTATUS   MACRO   stataddr
        LOCAL   back

back:   cmp     stataddr,-1
        je      back
ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
STARTTIME	MACRO	
IFDEF	DEBUG
	PUSHR	es,eax,edx
	mov	ax,_DATA
	mov	es,ax
	rdtsc
	mov	es:[qwStartTime],eax
	mov	es:[qwStartTime+4],edx
	POPR	es,eax,edx
ENDIF
ENDM

STOPTIME	MACRO	qwThisTime
IFDEF	DEBUG
	PUSHR	es,eax,edx
	mov	ax,_DATA
	mov	es,ax
	rdtsc
	sub	eax,es:[qwStartTime]
	sbb	edx,es:[qwStartTime+4]
	add	es:[qwThisTime],eax
	adc	es:[qwThisTime+4],edx
	POPR	es,eax,edx
ENDIF
ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SETPUTPTR       MACRO   sreg,hwcxreg,pushbufferreg
        LOCAL   DoneFlush

        or      byte ptr sreg:[pushbufferreg - 40H],0
        mov     sreg:[hwcxreg].HWBOARDCX.pCurrentPushBufferOffset,pushbufferreg
        sub     pushbufferreg,sreg:[hwcxreg].HWBOARDCX.pPushBufferContextStartOffset

IF (DOIOTOFLUSHCACHE NE 0)
        push    OFFSET DoneFlush
        cmp     sreg:[hwcxreg].HWBOARDCX.dwFlushCacheWithIO,0
        jne     FlushChipsetCache
        add     sp,4
DoneFlush:
ENDIF
        mov     sreg:[hwcxreg].HWBOARDCX.dwDmaPutPtr,pushbufferreg
        mov     pushbufferreg,sreg:[hwcxreg].HWBOARDCX.pCurrentPushBufferOffset
ENDM


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
INTERNAL_BEGINACCESS    MACRO   sreg,tempreg
        LOCAL   skip
        mov     tempreg,HWSEGDATA(sreg,dwGetOffsetAtLastBeginAccess)
        cmp     tempreg,HWSEGDATA(sreg,dwCurrentPushBufferOffset)
        je      skip
        call    HW_InternalBeginAccess
skip:
ENDM


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CHECKDSTBASE    MACRO   CXSel,hwcxreg,DmaOff,DstBase,DstPitch
        LOCAL   skip

IFDIFI  <DmaOff>,<edi>
        echo The DmaOffargument to the CHECKDSTBASE macro is not edi
        echo The macro will need modification.
        .err
ENDIF
        cmp     DstBase,CXSel:[hwcxreg].HWBOARDCX.dwContextSurface2dDstOffset
        je      skip
        push    hwcxreg
        pushd   DstBase
        pushd   DstPitch
IFIDNI          <CXSel>,<ds>
        call    SetDstBaseAndPitchToDsEdi
ELSEIFIDN       <CXSel>,<es>
        call    SetDstBaseAndPitchToEsEdi
ELSE
        echo Unknown CXSel arg to macro CHECKDSTBASE
        .err
ENDIF
skip:
ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; NV10 requires 4K byte alignment. NV4/NV5 only require 2K but
; since 4K works for everyone, that is what we use.
HW_CURSOR_WIDTH         TEXTEQU  <CURSOR_WIDTH>
HW_CURSOR_HEIGHT        TEXTEQU  <CURSOR_HEIGHT>
HW_CURSOR_ALIGN         TEXTEQU  <4096>

NV_CURSOR_SET_PARAM     TEXTEQU <1>     ; Indicates that the rest of the
                                        ;   cursor image parameters are valid
                                        ;   and they should be programmed
                                        ;   into the hardware.
NV_CURSOR_SET_ENABLE    TEXTEQU <2>     ; Indicates that the cursor's enable
                                        ;   disable state should be changed.
NV_CURSOR_ENABLE        TEXTEQU <4>     ; Used in conjunction with
                                        ;   NV_CURSOR_SET_ENABLE.
NV_CURSOR_DISABLE       TEXTEQU <0>     ; Used in conjunction with
                                        ;   NV_CURSOR_SET_ENABLE.

; 16 bpp color cursor
; 32 bpp color cursor w/ alpha
HW_CURSOR_16_SIZE       TEXTEQU  <(HW_CURSOR_WIDTH * HW_CURSOR_HEIGHT * 2)>
HW_CURSOR_32_SIZE       TEXTEQU  <(HW_CURSOR_WIDTH * HW_CURSOR_HEIGHT * 4)>

IF      USE_ALPHA_CURSOR
HW_CURSOR_SIZE  TEXTEQU <((HW_CURSOR_32_SIZE + HW_CURSOR_ALIGN - 1) AND (NOT (HW_CURSOR_ALIGN - 1)))>
ELSE
HW_CURSOR_SIZE  TEXTEQU <((HW_CURSOR_16_SIZE + HW_CURSOR_ALIGN - 1) AND (NOT (HW_CURSOR_ALIGN - 1)))>
ENDIF   ; USE_ALPHA_CURSOR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPENSEG  _NVTEXT32, %DEF_CODE_SIZE, CODE
; hwaccess
EXTERNDEF       WaitUntilGdiContextIdle:NEAR

; hwboard.asm
EXTERNDEF       NV_GetDeviceNumber:NEAR
EXTERNDEF       NV_AllocRoot:NEAR
EXTERNDEF       NV_FreeRoot:NEAR
EXTERNDEF       NV_AllocDevice:NEAR
EXTERNDEF       NV_GetMemoryInfo:NEAR
EXTERNDEF       NV_GetDeviceInfo:NEAR
EXTERNDEF       NV_GetDeviceVersion:NEAR
EXTERNDEF       NV_GetBusType:NEAR
EXTERNDEF       NV_GetNumCRTCs:NEAR
EXTERNDEF       NV_AllocPushBuffer:NEAR
EXTERNDEF       NV_AllocChannelDma:NEAR
EXTERNDEF       NV_AllocPages:NEAR
EXTERNDEF       NV_AllocMemory:FAR32
EXTERNDEF       NV_FreeMemory:FAR32
EXTERNDEF       NV_AllocLinearAddressSpace:NEAR
EXTERNDEF       NV_FreeLinearAddressSpace:NEAR
EXTERNDEF       NV_CopyPTEsForLinearRange:NEAR
EXTERNDEF       NV_GetGdiChannelMask:NEAR
EXTERNDEF       NV_AllocRequiredMemory:NEAR
EXTERNDEF       NV_GetCursorCacheInfo:NEAR
EXTERNDEF       NV_BoardSetDXSharedData:FAR32

; hwboard2.asm
EXTERNDEF       Enable_HiRes:FAR32
EXTERNDEF       NV_ConfigExCall:FAR32
EXTERNDEF       NV_ConfigExSetCall:FAR32
EXTERNDEF       NV_OffscreenHeapAlloc:FAR32
EXTERNDEF       NV_OffscreenHeapFree:FAR32
EXTERNDEF       NV_OffscreenHeapPurge:FAR32

; hwcrtc.asm
EXTERNDEF       NV_CrtcSetLogdev:FAR32
EXTERNDEF       HW_GetPhysicalCrtcIndex:FAR32
EXTERNDEF       NV_GetEncoderInfo:NEAR
EXTERNDEF       CreateVideoLutCursorDac:NEAR
EXTERNDEF       DestroyVideoLutCursorDac:NEAR
EXTERNDEF       NV_AllocHeadRelatedInfo:NEAR
EXTERNDEF       NV_FreeHeadRelatedInfo:NEAR

; hwcrtc2.asm
EXTERNDEF       NV_SetColorMap:FAR32

; Functions in hwinit.asm
EXTERNDEF       NvSysTable:WORD
EXTERNDEF       hNvSysDll:WORD
EXTERNDEF       wHWCSAlias:WORD
EXTERNDEF       lpfnNvSysMoveCursor:DWORD
EXTERNDEF       lpfnNvSysUpdateImageOffsetFormat:DWORD
EXTERNDEF       lpfnNvSysGetRamInfo:DWORD
EXTERNDEF       lpfnNvSysAllocPages:DWORD
EXTERNDEF       lpfnNvSysFreePages:DWORD
EXTERNDEF       lpfnNvConfigGet:DWORD
EXTERNDEF       lpfnNvConfigSet:DWORD
EXTERNDEF       lpfnNvConfigUpdate:DWORD
EXTERNDEF       lpfnNvConfigVga:DWORD
EXTERNDEF       lpfnNvSysSetCursorImage:DWORD
EXTERNDEF       lpfnNvSysGetHardwarePointers:DWORD
EXTERNDEF       lpfnNvDeviceBaseGet:DWORD
EXTERNDEF       lpfnNvDeviceLimitGet:DWORD
EXTERNDEF       lpfnNvSysDriverConnect:DWORD
EXTERNDEF       lpfnNvSysDriverDisConnect:DWORD
EXTERNDEF       lpfnNvSysRegisterDisplayDriver:DWORD
EXTERNDEF       lpfnNvIoControl:DWORD
EXTERNDEF       lpfnArch_Nv01Free:DWORD
EXTERNDEF       lpfnArch_Nv01AllocRoot:DWORD
EXTERNDEF       lpfnArch_Nv01AllocMemory:DWORD
EXTERNDEF       lpfnArch_Nv01AllocContextDma:DWORD
EXTERNDEF       lpfnArch_Nv01AllocChannelPio:DWORD
EXTERNDEF       lpfnArch_Nv01AllocObject:DWORD
EXTERNDEF       lpfnArch_Nv01AllocDevice:DWORD
EXTERNDEF       lpfnArch_Nv03AllocChannelDma:DWORD
EXTERNDEF       lpfnArch_Nv03DmaFlowControl:DWORD
EXTERNDEF       lpfnArch_Nv01Interrupt:DWORD
EXTERNDEF       lpfnArch_Nv01AllocEvent:DWORD
EXTERNDEF       lpfnArch_NvI2CAccess:DWORD
EXTERNDEF       lpfnArch_Nv04ConfigGetEx:DWORD
EXTERNDEF       lpfnArch_Nv04ConfigSetEx:DWORD
EXTERNDEF       lpfnArch_Nv04Alloc:DWORD

; hwcur32.asm
IF  (USE_ALPHA_CURSOR NE 0)
EXTERNDEF       HW_CursorSet8888:NEAR
EXTERNDEF       SetCursor_1Bpp_8888:NEAR
EXTERNDEF       SetCursor_4Bpp_8888:NEAR
EXTERNDEF       SetCursor_8Bpp_8888:NEAR
EXTERNDEF       SetCursor_15Bpp_8888:NEAR
EXTERNDEF       SetCursor_16Bpp_8888:NEAR
EXTERNDEF       SetCursor_24Bpp_8888:NEAR
EXTERNDEF       SetCursor_32Bpp_8888:NEAR
EXTERNDEF       SetCursor_3XBpp_8888:NEAR
ENDIF

; hwcursor.asm
EXTERNDEF       SetCursor_1Bpp_1555:NEAR
EXTERNDEF       SetCursor_4Bpp_1555:NEAR
EXTERNDEF       SetCursor_8Bpp_1555:NEAR
EXTERNDEF       SetCursor_15Bpp_1555:NEAR
EXTERNDEF       SetCursor_16Bpp_1555:NEAR
EXTERNDEF       SetCursor_24Bpp_1555:NEAR
EXTERNDEF       SetCursor_32Bpp_1555:NEAR
EXTERNDEF       SetCursor_3XBpp_1555:NEAR

; in hwpatblt.asm
EXTERNDEF       bConvertPatDstToSrcDstRop:BYTE

; hwrect.asm
EXTERNDEF       bConvertRop2ToRop3:BYTE

; Functions in misc.asm
EXTERNDEF       dwContextSurface2DColorFormat:DWORD
EXTERNDEF       SetDstBaseAndPitchToDsEdi:NEAR
EXTERNDEF       SetDstBaseAndPitchToEsEdi:NEAR
EXTERNDEF       WaitUntilOtherContextsIdle:NEAR
EXTERNDEF       FlushChipsetCache:NEAR
EXTERNDEF       WaitForDmaBufferSpace:NEAR

; misc.asm
EXTERNDEF       SetDstBaseAndPitchToDsEdi:NEAR
EXTERNDEF       SetDstBaseAndPitchToEsEdi:NEAR
EXTERNDEF       WaitUntilOtherContextsIdle:NEAR
EXTERNDEF       FlushChipsetCache:NEAR
EXTERNDEF       WaitForDmaBufferSpace:NEAR

; objects.asm
EXTERNDEF       NV_CreateDmaContexts:FAR32
EXTERNDEF       NV_DestroyDmaContexts:FAR32
EXTERNDEF       NV_CreateObjects:FAR32
EXTERNDEF       NV_DestroyObjects:FAR32
EXTERNDEF       NV_AllocContextDma:FAR32
EXTERNDEF       NV_FreeContextDma:FAR32
EXTERNDEF       NV_AllocWinChannelObject:FAR32
EXTERNDEF       NV_FreeWinChannelObject:FAR32
EXTERNDEF       NV_RMAllocObject:FAR32
CLOSESEG _NVTEXT32


OPENSEG  _NVTEXT16, USE16, CODE
; hwcntrl.asm
EXTERNDEF       NV_GetFlatModeSwitchPtrCount:NEAR
EXTERNDEF       NV_GetFlatActiveChannelPtr:NEAR
EXTERNDEF       NV_GetEscapeID:NEAR
EXTERNDEF       NV_IsNvidiaBasedBoardAndDiver:NEAR
EXTERNDEF       NV_GetHardwarePointers:NEAR
EXTERNDEF       NV_GetFlatDirectXSharedData:NEAR
EXTERNDEF       NV_IncModeSitchCounter:NEAR
EXTERNDEF       NV_IntelDiags:NEAR

; hwidiag
EXTERNDEF       NV_IntelDiagnostics:FAR16

; hwlogdev2.asm
EXTERNDEF       NV_PostModeset:FAR16
EXTERNDEF       NV_CreateDrvObj:FAR16
EXTERNDEF       DirectCallToFlatland:FAR16
EXTERNDEF       NV_DirectXServiceNoFrame:FAR32
EXTERNDEF       NV_DirectXService:NEAR
CLOSESEG _NVTEXT16
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\blt16.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995,1997 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       Nv4Blt16.c
 *  Content:    Windows95 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"
#include "nvalpha.h"
#include "ddminint.h"
#include "nv32.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "nvsubch.h"

#ifdef NVD3D
    VOID nvTexBLT16BPP(int, int, int, int, int, int, int, int, int, int, int, int, int);
#endif

#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free


/*
 * Nv4Blt16
 *
 * NV4 Blt function for 16bpp surfaces.
 */
DWORD __stdcall Nv4Blt16( PDD_BLTDATA pbd )
    {
    DWORD dwStatus;
    FAST Nv3ChannelPio *npDev;
    FAST USHORT freeCount;
    DWORD       dwFlags;
    DWORD       dwDstCaps;
    DWORD       dwSrcCaps;
    DWORD       dwDDFX = 0;
    DWORD       dwRop;
    NVCOORD     wXYext;
    NVCOORD     wDestXY;
    NVCOORD     wSrcXY;
    BYTE        wStretch = 0;
    BYTE        doMirrorUpDown = 0;
    BYTE        isVideo = 0;
//    BYTE        doAlpha = 0;

    DWORD       dwFillColor;
    DWORD       dwColorKey;

    DWORD       dwDstOffset;
    DWORD       dwDstPitch;
    DWORD       dwDstWidth;
    DWORD       dwDstHeight;

    DWORD       dwSrcOffset;
    DWORD       dwSrcPitch;
    DWORD       dwSrcWidth;
    DWORD       dwSrcHeight;

    PDD_SURFACE_LOCAL  srcx;
    PDD_SURFACE_LOCAL  dstx;
    PDD_SURFACE_GLOBAL  src;
    PDD_SURFACE_GLOBAL  dst;
    PDEV    *ppdev;

    dstx = pbd->lpDDDestSurface;
    dst = dstx->lpGbl;
    ppdev = (PDEV*) pbd->lpDD->dhpdev;

    /*
     * NOTES:
     *
     * Everything you need is in pdb->bltFX .
     * Look at pdb->dwFlags to determine what kind of blt you are doing,
     * DDBLT_xxxx are the flags.
     *
     * ALPHA NOTES:
     *
     * Alpha ALWAYS comes in BLTFX.   You don't need to go looking for
     * the attached surface. If DDBLT_ALPHA is specified, then either a
     * constant alpha or alpha surface has been specified. Just look for
     * DDBLT_ALPHASURFACEOVERRIDE or DDBLT_ALPHACONSTANTOVERRIDE
     *
     * Look for DDBLT_ALPHASURFACEDESTRECT to use the destination rectangle
     * for choosing the rectangle in the alpha surface.   Otherwise use the
     * source rectangle.
     *
     * Z BUFFER NOTES:
     *
     * ZBuffer ALWAYS comes in BLTFX.   You don't need to go looking for
     * the attached surface. If DDBLT_ZBUFFER is specified, then either a
     * constant z or z buffer surface has been specified for the source and
     * destination. Just look for the DDBLT_ZBUFFERDESTOVERRIDE,
     * DDBLT_ZBUFFERSRCOVERRIDE, DDBLT_ZBUFFERCONSTANTDESTOVERRIDE, or
     * DDBLT_ZBUFFERCONSTANTSRCOVERRIDE.
     *
     * COLORKEY NOTES:
     *
     * ColorKey ALWAY comes in BLTFX.   You don't have to look it up in
     * the surface.
     */

    dwFlags   = pbd->dwFlags;
    dwDstCaps = dstx->ddsCaps.dwCaps;

#ifndef NVD3D
    if (dwDstCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_TEXTURE | DDSCAPS_NONLOCALVIDMEM))
        return DDHAL_DRIVER_NOTHANDLED;
#else   // NVD3D
    /*
     * Check for a 16 Bpp texture blit right ways.
     */
    if ((dwDstCaps & DDSCAPS_TEXTURE) && (dwDstCaps & DDSCAPS_VIDEOMEMORY))
        {
        /*
         * Call the special D3D Texture blit code to handle this blit.
         */
        if (srcx = pbd->lpDDSrcSurface)
        {
            src  = srcx->lpGbl;
            nvTexBLT16BPP(pbd->rSrc.left,
              pbd->rSrc.top,
              pbd->rSrc.right,
              pbd->rSrc.bottom,
              src->wWidth,
              src->wHeight,
              src->fpVidMem,
              src->lPitch,
              pbd->rDest.left,
              pbd->rDest.top,
              dst->wWidth,
              dst->wHeight,
              dst->fpVidMem + (DWORD)ppdev->pjFrameBufbase);
        }
        /*
         * Return successfully.
         */
        pbd->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
        }

    /*
     * Check for any non video memory blits and reject them right away.
     */
    if (dwDstCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM))
        return DDHAL_DRIVER_NOTHANDLED;
#endif  // NVD3D

    if (dwFlags & DDBLT_DDFX)
        dwDDFX = pbd->bltFX.dwDDFX;

//    if (dwFlags & DDOVER_ANYALPHA) {
//        DPF("Overlay Alpha failed");
//        pbd->ddRVal = DDERR_NOOVERLAYHW;
//        return DDHAL_DRIVER_HANDLED;
//    }

//    if (dwFlags & DDBLT_ANYALPHA) {
//        DPF("Alpha requested");
//        if ((dwFlags & DDBLT_ALPHASRCCONSTOVERRIDE) == 0) {
//            pbd->ddRVal = DDERR_NOALPHAHW;
//            return DDHAL_DRIVER_HANDLED;
//        } else
//            doAlpha = 1;
//    }

    if (dwFlags & (DDBLT_KEYDEST | DDBLT_KEYDESTOVERRIDE))
        {
        DPF("Dest color key failed");
        pbd->ddRVal = DDERR_NOCOLORKEYHW;
        return DDHAL_DRIVER_HANDLED;
        }

    /*
     * get offset, width, and height for destination
     */
    dwDstOffset = dst->fpVidMem;
    dwDstPitch  = dst->lPitch;
    dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
    dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;
    wXYext.wh16.w = (unsigned short)dwDstWidth;
    wXYext.wh16.h = (unsigned short)dwDstHeight;

    wDestXY.xy16.x = (short)pbd->rDest.left;
    wDestXY.xy16.y = (short)pbd->rDest.top;

    npDev = (Nv3ChannelPio *)ppdev->ddChannelPtr;

    if (npDev == NULL)
        {
        pbd->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
        }

    freeCount = ppdev->NVFreeCount;

    /*
     * If async, then only work if bltter isn't busy
     * This should probably be a little more specific to each call, but
     * waiting for 32 is pretty close
     */
    if ( dwFlags & DDBLT_ASYNC )
        {
        if (freeCount < 32)
            freeCount = NvGetFreeCount(npDev, 0);

        if ( freeCount < 32 )
            {
            DPF("Asynchronous blit failed");
            pbd->ddRVal = DDERR_WASSTILLDRAWING;
            ppdev->NVFreeCount = freeCount;
            return DDHAL_DRIVER_HANDLED;
            }
        }

    if (dwFlags & DDBLT_ROP)
        {
        dwRop = pbd->bltFX.dwROP >> 16;

        if ((dwRop == BLACKNESSINDEX) || (dwRop == WHITENESSINDEX))
            {

            DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);

            while (freeCount < 4*4)
                freeCount = NvGetFreeCount(npDev, 0);
            freeCount -= 4*4;

            npDev->subchannel[NV_DD_ROP].Nv03ContextRop.SetRop5 = dwRop;

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.Color1A =
            0;

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].point =
            asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].size =
            asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            }
        else if ((dwRop == PATCOPYINDEX) || (dwRop == PATINVERTINDEX))
            {

            dwFillColor = (pbd->bltFX.dwFillColor & ppdev->physicalColorMask) | ppdev->AlphaEnableValue;
            DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
            while (freeCount < 16)
                freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
            freeCount -= 16;

            if (dwRop == PATCOPYINDEX)
                dwRop = SRCCOPYINDEX;
            else if (dwRop == PATINVERTINDEX)
                dwRop = SRCINVERTINDEX;

            npDev->dDrawRop.SetRop5 = dwRop;

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.Color1A = dwFillColor;

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].point =
            asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].size =
            asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            }
        else if ((dwRop == SRCCOPYINDEX) || (dwRop == SRCPAINTINDEX) ||
                 (dwRop == SRCANDINDEX) || (dwRop == NOTSRCCOPYINDEX) ||
                 (dwRop == SRCINVERTINDEX) || (dwRop == MERGEPAINTINDEX) ||
                 (dwRop == SRCERASEINDEX) || (dwRop == NOTSRCERASEINDEX))
            {
            srcx = pbd->lpDDSrcSurface;
            src = srcx->lpGbl;

            dwSrcCaps = srcx->ddsCaps.dwCaps;

            /* We must treat AGP source memory as system memory */
            if (dwSrcCaps & DDSCAPS_NONLOCALVIDMEM)
                {
                dwSrcCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
                }

            dwSrcOffset = src->fpVidMem;
            dwSrcPitch  = src->lPitch;
            dwSrcWidth  = pbd->rSrc.right  - pbd->rSrc.left;
            dwSrcHeight = pbd->rSrc.bottom - pbd->rSrc.top;
            dwColorKey  = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

            wSrcXY.xy16.x = (short)pbd->rSrc.left;
            wSrcXY.xy16.y = (short)pbd->rSrc.top;

            // if ((srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
            if (src->ddpfSurface.dwFlags & DDPF_FOURCC)
                {

                if (src->ddpfSurface.dwFourCC == FOURCC_RGB0)
                    {
                    if ((src->ddpfSurface.dwRBitMask == 0x00007C00) &&
                        (src->ddpfSurface.dwGBitMask == 0x000003E0) &&
                        (src->ddpfSurface.dwBBitMask == 0x0000001F))
                        {
                        if (dwSrcCaps & DDSCAPS_SYSTEMMEMORY)
                            isVideo = 1;
                        goto srcRGB;
                        }
                    else
                        {
                        pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }
                    }
                DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
                while (freeCount < 4 )
                    freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                freeCount -= 4;

                npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;

                switch (src->ddpfSurface.dwFourCC)
                    {
                    case FOURCC_UYVY:
                    case FOURCC_YUY2:
//                     if (dwSrcWidth & 1) {  NEC MPEG CODEC DOESN'T RESPOND TO THIS ERROR
//                           pbd->ddRVal = DDERR_INVALIDRECT;
//                           return DDHAL_DRIVER_HANDLED;
//                       }

                        if (wSrcXY.xy16.x & 1)
                            {
                            pbd->ddRVal = DDERR_INVALIDRECT;
                            ppdev->NVFreeCount = freeCount;
                            return DDHAL_DRIVER_HANDLED;
                            }

                        if (src->ddpfSurface.dwFourCC == FOURCC_UYVY)
                            {
                            isVideo = 2;
                            // Is this surface DMAable ?
                            if ((ppdev->fNvActiveFloatingContexts &
                                 NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                (ppdev->NvFloating0UYVYSurfaceMem == (ULONG) src->fpVidMem))
                                isVideo = 4;
                            else if ((ppdev->fNvActiveFloatingContexts &
                                      NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                     (ppdev->NvFloating1UYVYSurfaceMem == (ULONG) src->fpVidMem))
                                isVideo = 5;
                            }
                        else
                            { // YUY2
                            isVideo = 3;
                            // Is this surface DMAable ?
                            if ((ppdev->fNvActiveFloatingContexts &
                                 NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                (ppdev->NvFloating0YUYVSurfaceMem == (ULONG) src->fpVidMem))
                                isVideo = 6;
                            else if ((ppdev->fNvActiveFloatingContexts &
                                      NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                     (ppdev->NvFloating1YUYVSurfaceMem == (ULONG) src->fpVidMem))
                                isVideo = 7;
                            }
                        goto srcRGB;
                        break;
#ifdef YV12_SUPPORT
                    case FOURCC_YV12:
                        // Size has to be always * 4, to use VU subsampling
                        if ((dwSrcWidth & 3) || (dwSrcHeight & 3))
                            {
                            pbd->ddRVal = DDERR_INVALIDRECT;
                            ppdev->NVFreeCount = freeCount;
                            return DDHAL_DRIVER_HANDLED;
                            }

//                     pbd->ddRVal = nvStretchYVU12ToDev (pbd, src->ddpfSurface.dwFourCC);
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        break;
#endif
                    }
                pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                ppdev->NVFreeCount = freeCount;
                return DDHAL_DRIVER_HANDLED;
                }

            srcRGB:     if (dwDDFX & DDBLTFX_MIRRORUPDOWN)
                doMirrorUpDown = 1;

            if ((dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight))
                wStretch = 1;

            if (isVideo > 1) /* YUV video */
                wStretch = 1;

            if (dwFlags & DDBLT_KEYSRCOVERRIDE)
                {

                dwColorKey = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

                while (freeCount < 2*4)
                    freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);

                // load and enable chroma key
                freeCount -= 2*4;
                if (ppdev->dDrawSpareSubchannelObject != NV_DD_IMAGE_SOLID)
                    {
                    npDev->dDrawSpare.SetObject = NV_DD_IMAGE_SOLID;
                    ppdev->dDrawSpareSubchannelObject = NV_DD_IMAGE_SOLID;
                    }
                npDev->dDrawTransColor.SetColor =
                (dwColorKey & ppdev->physicalColorMask) | NV_ALPHA_1_565;

                }

            // screen to screen bitblt
            if (wStretch == 0)
                {

                if ((dwDstCaps & DDSCAPS_VIDEOMEMORY) &&
                    (dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                    ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                    (doMirrorUpDown == 0) &&
                    (isVideo == 0))
                    {
                    DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
                    DDRAW_SET_SOURCE(ppdev, dwSrcOffset, dwSrcPitch);

                    while (freeCount < 4*4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                    freeCount -= 4*4;

                    npDev->dDrawRop.SetRop5 = dwRop;

                    npDev->dDrawBlit.ControlPointIn = wSrcXY.xy;
                    npDev->dDrawBlit.ControlPointOut = wDestXY.xy;
                    npDev->dDrawBlit.Size = wXYext.wh;

                    }
                else
                    {
                    // memory to screen blt (src may be in system memory or in video memory)
                    unsigned long temp;
                    long srcScanLength;
                    long nxtSrcScan;
                    short n = wXYext.wh16.h;
                    FAST short pxlCount;
                    unsigned long srcOffset;
                    unsigned char *pSrcInitBits;

                    pSrcInitBits = (unsigned char *) src->fpVidMem;
                    if (dwSrcCaps & DDSCAPS_VIDEOMEMORY)
                        pSrcInitBits += (ULONG) ppdev->pjFrameBufbase;

                    srcScanLength = src->lPitch;

                    if (doMirrorUpDown)
                        wSrcXY.xy16.y += (short)(n - 1);

                    pSrcInitBits += (wSrcXY.xy16.y * srcScanLength);

                    srcOffset = wSrcXY.xy16.x & 1;

                    temp = ((wXYext.wh16.w + 1 + srcOffset) & 0xFFFE);

                    nxtSrcScan = (srcScanLength >> 1) - temp;

                    if (doMirrorUpDown)
                        nxtSrcScan = -(srcScanLength >> 1) - temp;

                    pSrcInitBits += ((wSrcXY.xy16.x & 0xFFFE) << 1);
                    DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
                    while (freeCount < 6*4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                    freeCount -= 6*4;

                    // changing canvas clip avoids manually aligning 16-bit source /
                    npDev->subchannel[NV_DD_CLIP].Nv01ContextClipRectangle.SetPoint =
                    wDestXY.xy;
                    npDev->subchannel[NV_DD_CLIP].Nv01ContextClipRectangle.SetSize =
                    wXYext.wh;
                    ppdev->DdClipResetFlag = TRUE;

                    npDev->dDrawRop.SetRop5 = dwRop;

                    npDev->dDrawImageFromCpu.Point =
                    asmMergeCoords((wDestXY.xy16.x - srcOffset), wDestXY.xy16.y);
                    npDev->dDrawImageFromCpu.SizeOut =
                    asmMergeCoords(wXYext.wh16.w + srcOffset, wXYext.wh16.h);

                    npDev->dDrawImageFromCpu.SizeIn =
                    asmMergeCoords(temp, wXYext.wh16.h);

                    {
                        FAST unsigned short *pSrcBits = (unsigned short *)pSrcInitBits;
                        FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                        while (--n >= 0)
                            {
                            pxlCount = (short)temp;

                            while (pxlCount >= 16)
                                {
                                pxlCount -= 16;

                                while (freeCount < 32)
                                    freeCount = NvGetFreeCount(npDev, NV_DD_IMAGE);
                                freeCount -= 32;

                                tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                tmpPxls1 = *(unsigned long *)&pSrcBits[2];
                                npDev->dDrawImageFromCpu.Color[0] = tmpPxls0;
                                tmpPxls2 = *(unsigned long *)&pSrcBits[4];
                                npDev->dDrawImageFromCpu.Color[1] = tmpPxls1;
                                tmpPxls0 = *(unsigned long *)&pSrcBits[6];
                                tmpPxls1 = *(unsigned long *)&pSrcBits[8];
                                npDev->dDrawImageFromCpu.Color[2] = tmpPxls2;
                                npDev->dDrawImageFromCpu.Color[3] = tmpPxls0;
                                tmpPxls2 = *(unsigned long *)&pSrcBits[10];
                                tmpPxls0 = *(unsigned long *)&pSrcBits[12];
                                npDev->dDrawImageFromCpu.Color[4] = tmpPxls1;
                                npDev->dDrawImageFromCpu.Color[5] = tmpPxls2;
                                tmpPxls1 = *(unsigned long *)&pSrcBits[14];
                                npDev->dDrawImageFromCpu.Color[6] = tmpPxls0;
                                pSrcBits += 16;
                                npDev->dDrawImageFromCpu.Color[7] = tmpPxls1;
                                }

                            if (pxlCount > 0)
                                {
                                while (freeCount < 32)
                                    freeCount = NvGetFreeCount(npDev, NV_DD_IMAGE);

                                while (pxlCount >= 4)
                                    {
                                    tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                    tmpPxls1 = *(unsigned long *)&pSrcBits[2];
                                    pxlCount -= 4;
                                    freeCount -= 8;
                                    npDev->dDrawImageFromCpu.Color[0] = tmpPxls0;
                                    npDev->dDrawImageFromCpu.Color[1] = tmpPxls1;
                                    pSrcBits += 4;
                                    }

                                if (pxlCount > 0)
                                    {
                                    tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                    freeCount -= 4;
                                    pSrcBits += 2;
                                    npDev->dDrawImageFromCpu.Color[0] = tmpPxls0;
                                    }
                                }
                            pSrcBits += nxtSrcScan;
                            }
                    }

                    while (freeCount < 8)
                        freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                    freeCount -= 8;

                    // restore canvas clip
                    if (ppdev->DdClipResetFlag)
                        {
                        npDev->subchannel[NV_DD_CLIP].Nv01ContextClipRectangle.SetPoint =
                            0;
                        npDev->subchannel[NV_DD_CLIP].Nv01ContextClipRectangle.SetSize =
                            asmMergeCoords(ppdev->cBitsPerPel,
                                       ppdev->cyMemory);
                        ppdev->DdClipResetFlag = FALSE;
                        }
                    }
                }
            else
                {
                // stretch
                RECTL rDummy;
                BOOL isOverlappingVmem = FALSE;
                ULONG lpSurfTemp = 0;
                DWORD dwSrcBitsPP = 16;
                // if the source and destination overlap, then we must do this in 2 passes, first copy the source
                // image somewhere else, and then so the stretch from there.
                if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) && dwSrcOffset == dwDstOffset && bIntersect((RECTL *)(&pbd->rSrc), (RECTL *)(&pbd->rDest), &rDummy))
                    {
                    ULONG tmpBmpPitch = (((dwSrcWidth * (ppdev->cBitsPerPel / 8)) + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign);
                    NVHEAP_ALLOC(dwStatus,lpSurfTemp, (DWORD)dwSrcHeight * tmpBmpPitch,  TYPE_IMAGE);
                    if (dwStatus!=0)
                    {
                        bMoveAllDfbsFromOffscreenToDibs(ppdev);
                        NVHEAP_ALLOC(dwStatus, lpSurfTemp, (DWORD)dwSrcHeight * tmpBmpPitch,  TYPE_IMAGE);
                    }

                    if (dwStatus==0) {
                        isOverlappingVmem = TRUE;
                        DDRAW_SET_PRIMARY(ppdev, lpSurfTemp, tmpBmpPitch);
                        DDRAW_SET_SOURCE(ppdev, dwSrcOffset, dwSrcPitch);

                        while (freeCount < 6*4)
                            freeCount = NvGetFreeCount(npDev, 0);
                        freeCount -= 6*4;

						{
							NVCOORD     srcSize;

							srcSize.wh16.w = (unsigned short)dwSrcWidth;
							srcSize.wh16.h = (unsigned short)dwSrcHeight;

							npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;
							npDev->dDrawBlit.ControlPointIn = wSrcXY.xy;
							npDev->dDrawBlit.ControlPointOut = 0;
							npDev->dDrawBlit.Size = srcSize.wh;
						}

                        dwSrcOffset = lpSurfTemp;
                        dwSrcPitch = tmpBmpPitch;
                        wSrcXY.xy = 0;
                        wSrcXY.xy16.x = 0;
                        wSrcXY.xy16.y = 0;
                    } else {
                        // FIXME: vmem heap alloc failed, must do system mem alloc and copy there
                    }
                }
                // WARNING: carefully consider each use of src->fpVidMem and src->lPitch beyond this point
                //          it could screw up overlapping stretchblits

                // stretch
                if (dwFlags & DDBLT_KEYSRCOVERRIDE)
                    { // If color key then MUST use STRETCHED IMAGE instead of SCALED IMAGE
                    NvNotification *pDmaToMemNotifier;
                    unsigned char *pScanlineBuffer;
                    long srcScanLength;
                    long nxtSrcScan;
                    long n;
                    short m;
                    FAST short pxlCount;
                    unsigned char *pSrcInitBits;
                    unsigned char *pSaveSrcBits;
                    unsigned char *pSrcCurScan;
                    long deltaX;
                    long deltaY;
                    long deltaDstY;
                    long curDstY;
                    long lastDstY;
                    long skipSrcBytes = 0;
                    NVCOORD wSrcExt;
                    NVCOORD wDstPoint;
                    unsigned long srcStrtX;
                    BYTE srcInVideoMemory = 0;
                    BYTE bufState = 0;
                    short skipV = 0;

                    pSrcInitBits = (unsigned char *) dwSrcOffset;
                    if (dwSrcCaps & DDSCAPS_VIDEOMEMORY)
                        pSrcInitBits += (ULONG) ppdev->pjFrameBufbase;

                    srcScanLength = dwSrcPitch;

                    if (dwSrcPitch <= 800)
                        m = 16;
                    else if (dwSrcPitch <= 1600)
                        m = 8;
                    else
                        m = 4;

                    DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);

                    while (freeCount < 4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                    freeCount -= 4;

                    npDev->dDrawRop.SetRop5 = dwRop;

                    /* calculate deltas in 12.20 format */
                    n = (dwDstWidth << 20) / dwSrcWidth;

                    if ((n & 0xFFFFF) == 0)
                        n = 0;
                    else
                        {
                        n >>= 20;
                        n += 1;
                        }

                    deltaX = (dwDstWidth + n) << 20;
                    deltaX /= dwSrcWidth;

                    n = (dwDstHeight << 20) / dwSrcHeight;

                    if ((n & 0xFFFFF) == 0)
                        n = 0;
                    else
                        {
                        n >>= 20;
                        n += 1;
                        }

                    deltaY = (dwDstHeight + n) << 20;
                    deltaY /= dwSrcHeight;

                    deltaDstY = (dwDstHeight << 20);
                    deltaDstY /= dwSrcHeight;

                    wSrcExt.wh16.w = (unsigned short)((dwSrcWidth + 1) & ~1);
                    wSrcExt.wh16.h = (unsigned short)dwSrcHeight;

                    n = (short)dwSrcHeight;

                    if (wSrcXY.xy16.y + (ULONG) n > src->wHeight)
                        n = src->wHeight - wSrcXY.xy16.y;

                    nxtSrcScan = srcScanLength;

                    if (doMirrorUpDown)
                        {
                        wSrcXY.xy16.y += (short)(n - 1);
                        nxtSrcScan = -nxtSrcScan;
                        skipSrcBytes = -skipSrcBytes;
                        }

                    if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                        ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) || isOverlappingVmem)
                        {
                        srcInVideoMemory = 1;
                        }
                    else
                        {
                        pSaveSrcBits = (unsigned char *)(pSrcInitBits +
                                                         (wSrcXY.xy16.y * srcScanLength));
                        pSaveSrcBits += (wSrcXY.xy16.x << 1);
                        pSrcCurScan = pSaveSrcBits;
                        }

                    if (srcInVideoMemory)
                        {
                        pDmaToMemNotifier = (NvNotification *)ppdev->Notifiers->DmaToMem;
                        pScanlineBuffer = (unsigned char *)ppdev->NvScanlineBufferFlat;

                        wSrcExt.wh16.w = (unsigned short)((dwSrcWidth + 1) & ~1);
                        wSrcExt.wh16.h = m;

                        srcStrtX = wSrcXY.xy16.x;

                        while (freeCount < 4)
                            freeCount = NvGetFreeCount(npDev, NV_DD_IMAGE);
                        freeCount -= 4;

                        if (ppdev->dDrawSpareSubchannelObject != NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT)
                            {
                            npDev->subchannel[NV_DD_SPARE].SetObject =
                                NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
                            }
                                                // wait for any pending notification operation to finish
                        while ((volatile)pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV_IN_PROGRESS);

                        pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV_IN_PROGRESS;

                        while (freeCount < 32)
                            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                        freeCount -= 32;

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
                        dwSrcOffset +
                        ((dwSrcPitch + skipSrcBytes) * (unsigned long)wSrcXY.xy16.y) +
                        ((unsigned long)wSrcXY.xy16.x << 1);

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
                        (srcStrtX << 1);

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
                        (dwSrcPitch + skipSrcBytes);

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
                        dwSrcPitch;

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
                        (unsigned long)(wSrcExt.wh16.w << 1);

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
                        m;

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
                        1 | (1 << 8);
                        //NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1;

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify =
                        0;

                        // wait for Dma operation to finish
                        while ((volatile)pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV_IN_PROGRESS);

                        if (doMirrorUpDown)
                            wSrcXY.xy16.y -= (m + skipV);
                        else
                            wSrcXY.xy16.y += (m + skipV);
                        }

                    /* Convert to 12.4 format */
                    wDstPoint.xy16.x = (wDestXY.xy16.x << 4);
                    wDstPoint.xy16.y = (wDestXY.xy16.y << 4);

                    /* convert to 16.16 */
                    lastDstY = (wDestXY.xy16.y + wXYext.wh16.h) << 16;

                    /* convert to 16.16 */
                    curDstY = (wDestXY.xy16.y << 16);

                    while (freeCount < 7*4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                    freeCount -= 7*4;

                    npDev->dDrawStretch.SetObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;
                    ppdev->dDrawSpareSubchannelObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;

                    npDev->dDrawStretch.Nv04StretchedImageFromCpu.ClipPoint =
                    wDestXY.xy;

                    npDev->dDrawStretch.Nv04StretchedImageFromCpu.ClipSize =
                    wXYext.wh;

                    npDev->dDrawStretch.Nv04StretchedImageFromCpu.SizeIn = wSrcExt.wh;

                    npDev->dDrawStretch.Nv04StretchedImageFromCpu.DeltaDxDu = deltaX;

                    npDev->dDrawStretch.Nv04StretchedImageFromCpu.DeltaDyDv = deltaY;

                    npDev->dDrawStretch.Nv04StretchedImageFromCpu.Point12d4 = wDstPoint.xy;

                    while ((n > 0) && (curDstY < lastDstY))
                        {
                        FAST unsigned long *pSrcBits;
                        FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                        if (srcInVideoMemory)
                            {
                            if (bufState == 0)
                                pSrcBits = (unsigned long *)(pScanlineBuffer +
                                                             (srcStrtX << 1));
                            else
                                pSrcBits = (unsigned long *)(pScanlineBuffer +
                                                             (NV_DMA_SCANLINE_BUF_SIZE >> 1) +
                                                             (srcStrtX << 1));

                            pSrcCurScan = (unsigned char *)pSrcBits;

                            if (m > 0)
                                {
                                pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV_IN_PROGRESS;

                                while (freeCount < 9*4)
                                    freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                                freeCount -= 9*4;
                                npDev->subchannel[NV_DD_SPARE].SetObject =
                                    NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
                                ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
                                dwSrcOffset +
                                ((dwSrcPitch + skipSrcBytes) * (unsigned long)wSrcXY.xy16.y) +
                                ((unsigned long)wSrcXY.xy16.x << 1);

                                if (bufState == 0)
                                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
                                    (NV_DMA_SCANLINE_BUF_SIZE >> 1) +
                                    (srcStrtX << 1);
                                else
                                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
                                    (srcStrtX << 1);

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
                                (dwSrcPitch + skipSrcBytes);

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
                                dwSrcPitch;

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
                                (unsigned long)(wSrcExt.wh16.w << 1);

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
                                m;

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
                                    1 | (1 << 8);
                                // NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1;

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify =
                                0;

                                bufState ^= 1;

                                if (doMirrorUpDown)
                                    wSrcXY.xy16.y -= (m + skipV);
                                else
                                    wSrcXY.xy16.y += (m + skipV);

                                while (freeCount < 7*4)
                                    freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                                freeCount -= 7*4;

                                npDev->dDrawStretch.SetObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;
                                ppdev->dDrawSpareSubchannelObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;

                                npDev->dDrawStretch.Nv04StretchedImageFromCpu.ClipPoint =
                                wDestXY.xy;
                                npDev->dDrawStretch.Nv04StretchedImageFromCpu.ClipSize =
                                wXYext.wh;
                                npDev->dDrawStretch.Nv04StretchedImageFromCpu.SizeIn =
                                wSrcExt.wh;
                                npDev->dDrawStretch.Nv04StretchedImageFromCpu.DeltaDxDu =
                                deltaX;
                                npDev->dDrawStretch.Nv04StretchedImageFromCpu.DeltaDyDv =
                                deltaY;
                                npDev->dDrawStretch.Nv04StretchedImageFromCpu.Point12d4 =
                                wDstPoint.xy;
                                }
                            }
                        else
                            { // source in system memory
                            pSrcBits = (unsigned long *)pSrcCurScan;
                            pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                            n--;
                            }

                        doNxtSrcScan:          pxlCount = (short)((dwSrcWidth + 1) & ~1);

                        while (pxlCount >= 32)
                            {

                            pxlCount -= 32;

                            while (freeCount < 64)
                                freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                            freeCount -= 64;

                            tmpPxls0 = pSrcBits[0];
                            tmpPxls1 = pSrcBits[1];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[0] = tmpPxls0;
                            tmpPxls2 = pSrcBits[2];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[1] = tmpPxls1;
                            tmpPxls0 = pSrcBits[3];
                            tmpPxls1 = pSrcBits[4];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[2] = tmpPxls2;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[3] = tmpPxls0;
                            tmpPxls2 = pSrcBits[5];
                            tmpPxls0 = pSrcBits[6];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[4] = tmpPxls1;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[5] = tmpPxls2;
                            tmpPxls1 = pSrcBits[7];
                            tmpPxls2 = pSrcBits[8];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[6] = tmpPxls0;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[7] = tmpPxls1;
                            tmpPxls0 = pSrcBits[9];
                            tmpPxls1 = pSrcBits[10];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[8] = tmpPxls2;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[9] = tmpPxls0;
                            tmpPxls2 = pSrcBits[11];
                            tmpPxls0 = pSrcBits[12];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[10] = tmpPxls1;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[11] = tmpPxls2;
                            tmpPxls1 = pSrcBits[13];
                            tmpPxls2 = pSrcBits[14];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[12] = tmpPxls0;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[13] = tmpPxls1;
                            tmpPxls0 = pSrcBits[15];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[14] = tmpPxls2;
                            pSrcBits += 16;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[15] = tmpPxls0;
                            }

                        while (pxlCount >= 16)
                            {

                            pxlCount -= 16;

                            while (freeCount < 32)
                                freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                            freeCount -= 32;

                            tmpPxls0 = pSrcBits[0];
                            tmpPxls1 = pSrcBits[1];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[0] = tmpPxls0;
                            tmpPxls2 = pSrcBits[2];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[1] = tmpPxls1;
                            tmpPxls0 = pSrcBits[3];
                            tmpPxls1 = pSrcBits[4];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[2] = tmpPxls2;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[3] = tmpPxls0;
                            tmpPxls2 = pSrcBits[5];
                            tmpPxls0 = pSrcBits[6];
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[4] = tmpPxls1;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[5] = tmpPxls2;
                            tmpPxls1 = pSrcBits[7];
                            pSrcBits += 8;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[6] = tmpPxls0;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[7] = tmpPxls1;
                            }

                        while (freeCount < 32)
                            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                        freeCount -= 32;

                        while (pxlCount >= 2)
                            {
                            tmpPxls0 = pSrcBits[0];
                            pxlCount -= 2;
                            npDev->dDrawStretch.Nv04StretchedImageFromCpu.Color[0] = tmpPxls0;
                            pSrcBits += 1;
                            }

                        if (srcInVideoMemory)
                            {
                            if (--m > 0)
                                {
                                pSrcCurScan += dwSrcPitch;

                                pSrcBits = (unsigned long *)pSrcCurScan;

                                goto doNxtSrcScan;
                                }
                            else
                                {
                                if (dwSrcPitch <= 800)
                                    {
                                    m = 16;
                                    curDstY += deltaDstY;
                                    }
                                else if (dwSrcPitch <= 1600)
                                    {
                                    m = 8;
                                    curDstY += (deltaDstY >> 1);
                                    }
                                else
                                    {
                                    m = 4;
                                    curDstY += (deltaDstY >> 2);
                                    }
                                /* convert 16.16 to 12.4 */
                                wDstPoint.xy16.y = (short)(curDstY >> 12);

                                // wait for DMA operation to finish
                                while ((volatile)pDmaToMemNotifier[NV039_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);
                                }
                            }
                        }

                    if (srcInVideoMemory)
                        {
                        while (freeCount < 4)
                            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                        freeCount -= 4;
                        if (ppdev->dDrawSpareSubchannelObject != NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT)
                            {
                            npDev->subchannel[NV_DD_SPARE].SetObject =
                                NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
                            }
                        }

                    }
                else
                    { // OK to use SCALED IMAGE
                    NvNotification *pDmaToMemNotifier;
                    unsigned char *pScanlineBuffer;
                    unsigned char *npPixelBuf;
                    long srcScanLength;
                    long nxtSrcScan;
                    unsigned long n;
                    unsigned char *pSrcInitBits;
                    unsigned char *pSaveSrcInitBits;
                    unsigned short *pSaveSrcBits;
                    unsigned short *pSrcCurScan;
                    long srcDeltaX;
                    long srcDeltaY;
                    unsigned long dstDeltaScans;
                    unsigned long dstDeltaX;
                    unsigned long dstDeltaY;
                    long srcInitFract;
                    long srcStartFract;
                    long srcCurFract;
                    long srcDeltaFract;
                    long srcDeltaScans;
                    long srcCurDeltaScans;
                    long xStretch;
                    long yStretch;
                    long srcBufferPitch;
                    long skipSrcBytes = 0;
                    long dstStartY;
                    long dstCurY;
                    long curV;
                    long skipV = 0;
                    long m;
                    long srcFinalHeight;
                    NVCOORD wSrcPoint;
                    NVCOORD wSrcExt;
                    NVCOORD wDstPoint;
                    NVCOORD wDstExt;
                    BYTE srcInVideoMemory = 0;
                    BYTE srcTooWide = 0;
                    short curBuffer;

//                   pPusherSyncNotifier = (NvNotification *)ppdev->NvPusherSyncNotifierFlat;

                    /* Avoid using shared buffer memory until it becomes available */
//                   while ((volatile)pPusherSyncNotifier->status == NV_IN_PROGRESS);

                    pSrcInitBits = (unsigned char *) dwSrcOffset;
                    if (dwSrcCaps & DDSCAPS_VIDEOMEMORY)
                         pSrcInitBits += (ULONG) ppdev->pjFrameBufbase;

                    srcScanLength = dwSrcPitch;

                    DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);

                    while (freeCount < 4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                    freeCount -= 4;

                    npDev->dDrawRop.SetRop5 = dwRop;


                    srcBufferPitch = ((dwSrcWidth << 1) + 3) & ~3L;

                    srcDeltaScans = (NV_DMA_SCANLINE_BUF_SIZE >> 1) -   /* allow for 2 extra src scanlines */
                                    (srcBufferPitch << 1); /* buffer contains 4 separate notifiers */

                    srcDeltaScans /= srcBufferPitch;

                    /* limiting source scans per DMA increases parallelism */
                    if (srcDeltaScans > 32)
                        srcDeltaScans = 32;
                    else if (srcDeltaScans > 16)
                        srcDeltaScans = 16;
                    else if (srcDeltaScans > 8)
                        srcDeltaScans = 8;
                    else if (srcDeltaScans > 4)
                        srcDeltaScans = 4;
                    else
                        srcDeltaScans = 2;

                    /* check for divide by 0 */
                    if ((dwDstWidth < 1) || (dwDstHeight < 1))
                        {
                        pbd->ddRVal = DDERR_INVALIDRECT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }

                    n = (dwSrcWidth << 20) / dwDstWidth;

                    if (n == 0x100000)
                        n = 0;
                    else
                        {
                        n >>= 20;
                        n += 1;
                        }

                    srcDeltaX = dwSrcWidth << 20;
                    srcDeltaX /= (dwDstWidth + n);

                    n = (dwSrcHeight << 20) / dwDstHeight;

                    if (n == 0x100000)
                        n = 0;
                    else
                        {
                        n >>= 20;
                        n += 1;
                        }

                    srcDeltaY = dwSrcHeight << 20;
                    srcDeltaY /= (dwDstHeight + n);

                    /* Algorithm can't handle a scale factor that is too large */
                    if (srcDeltaY > 0x40000000)
                        {
                        pbd->ddRVal = DDERR_INVALIDRECT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }

                    /* If shrinking in vertical direction then adjust to skip src scanlines */
                    if (srcDeltaY >= (srcDeltaScans << 20))
                        { /* limit Y delta range to acceptable range */
                        skipSrcBytes = srcScanLength;
                        skipV = 1;
                        while (srcDeltaY >= (srcDeltaScans << 20))
                            {
                            srcDeltaY >>= 1;
                            skipSrcBytes <<= 1;
                            skipV <<= 1;
                            }
                        skipSrcBytes -= srcScanLength;
                        skipV -= 1;
                        }

                    /* Algorithm can't handle scale factor that is too small */
                    if ((srcDeltaY & 0xFFFFFC00) == 0)
                        {
                        pbd->ddRVal = DDERR_INVALIDRECT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }

                    yStretch = 0x40000000 / ((srcDeltaY + 0x00000200) >> 10);

                    dstDeltaY = srcDeltaScans * yStretch;  // how many dst scanlines will srcDeltaScans scanlines generate

                    dstDeltaScans = dstDeltaY >> 20;

                    if (dstDeltaScans == 0)
                        { /* if shrinking too much then can't handle */
                        pbd->ddRVal = DDERR_INVALIDRECT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }

                    if (wSrcXY.xy16.y + dwSrcHeight > src->wHeight)
                        dwSrcHeight = src->wHeight - wSrcXY.xy16.y;

                    nxtSrcScan = (srcScanLength >> 1);

                    if (doMirrorUpDown)
                        {
                        wSrcXY.xy16.y += (short)(dwSrcHeight - 1);
                        srcDeltaY =- srcDeltaY;
                        nxtSrcScan = -nxtSrcScan;
                        skipSrcBytes = -skipSrcBytes;
                        }

                    pDmaToMemNotifier = (NvNotification *)ppdev->Notifiers->DmaToMem;
                    pScanlineBuffer = (unsigned char *)ppdev->NvScanlineBufferFlat;

                    srcDeltaFract = (dstDeltaScans << 20) / srcDeltaScans;

                    srcDeltaFract &= 0xFFFFF;

                    wSrcPoint.xy = 0;

                    /* Calculate initial source fractional X */
                    if ((srcDeltaX > 0x40000000) || ((srcDeltaX & 0xFFFFFC00) == 0))
                        {
                        pbd->ddRVal = DDERR_INVALIDRECT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }

                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    dstDeltaX = ((long)wSrcXY.xy16.x << 16) / (srcDeltaX >> 4);

                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    srcInitFract = dstDeltaX * (srcDeltaX >> 4);

                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    while (srcInitFract >> 16 < wSrcXY.xy16.x)
                        srcInitFract += (srcDeltaX >> 4);

                    /* Convert to 12.4 format */
                    wSrcPoint.xy16.x = (short)(srcInitFract & 0xFFFF) >> 12;

                    // DMAable ?
                    if ((isVideo > 3) || ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                                          ((dwSrcCaps & DDSCAPS_TEXTURE) == 0)) || isOverlappingVmem)
                        {

                        /* Calculate initial source fractional Y */
                        /* Do this math in 16.16 precision to avoid 12. overflow */
                        dstDeltaY = ((long)wSrcXY.xy16.y << 16) / (srcDeltaY  >> 4);

                        /* Do this math in 16.16 precision to avoid 12. overflow */
                        srcInitFract = dstDeltaY * (srcDeltaY >> 4);

                        /* Do this math in 16.16 precision to avoid 12. overflow */
                        while (srcInitFract >> 16 < wSrcXY.xy16.y)
                            srcInitFract += (srcDeltaY >> 4);

                        /* Convert result back to 12.20 precision */
                        srcInitFract <<= 4;

                        srcInitFract &= 0xFFFFF;

                        srcCurFract = srcInitFract;

                        if (isVideo < 4)
                            {
                            srcInVideoMemory = 1;

                            wSrcPoint.xy16.y += (short)srcCurFract >> 16;

                            if (doMirrorUpDown)
                                {
                                pSaveSrcBits = (unsigned short *)
                                               (pSrcInitBits - ppdev->pjFrameBufbase);
                                wSrcPoint.xy16.y += ((short)(dwSrcHeight - 1) << 4);
                                }
                            else
                                {
                                pSaveSrcBits = (unsigned short *)
                                               ((pSrcInitBits - ppdev->pjFrameBufbase) +
                                                (wSrcXY.xy16.y * srcScanLength));
                                }

                            }
                        else
                            { // source is in DMAable system memory

                            wSrcPoint.xy16.y += (short)srcCurFract >> 16;

                            if (doMirrorUpDown)
                                {
                                pSaveSrcBits = 0;
                                wSrcPoint.xy16.y += ((short)(dwSrcHeight - 1) << 4);
                                }
                            else
                                {
                                pSaveSrcBits = (unsigned short *)
                                               (wSrcXY.xy16.y * srcScanLength);
                                }
                            }

                        pSaveSrcBits += wSrcXY.xy16.x;

                        while (freeCount < 20)
                            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                        freeCount -= 20;

                        if (isVideo < 2)
                            {
                            if (ppdev->dDrawSpareSubchannelObject != NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY)
                                {
                                npDev->dDrawStretch.SetObject =
                                    NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
                                ppdev->dDrawSpareSubchannelObject = NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
                                }
                            }
                        else if (isVideo == 2)
                            {
                            if (ppdev->dDrawSpareSubchannelObject != NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY)
                                {
                                npDev->dDrawStretch.SetObject =
                                    NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
                                ppdev->dDrawSpareSubchannelObject =
                                    NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
                                }
                            }
                        else if (isVideo == 3)
                            {
                            if (ppdev->dDrawSpareSubchannelObject != NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY)
                                {
                                npDev->dDrawStretch.SetObject =
                                    NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
                                ppdev->dDrawSpareSubchannelObject =
                                    NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
                                }
                            }
                        else if (isVideo == 4)
                            {
                            if (ppdev->dDrawSpareSubchannelObject != NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY)
                                {
                                npDev->dDrawStretch.SetObject =
                                    NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                                ppdev->dDrawSpareSubchannelObject =
                                    NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                                }
                            }
                        else if (isVideo == 5)
                            {
                            if (ppdev->dDrawSpareSubchannelObject != NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY)
                                {
                                npDev->dDrawStretch.SetObject =
                                    NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                                ppdev->dDrawSpareSubchannelObject =
                                    NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                                }
                            }
                        else if (isVideo == 6)
                            {
                            if (ppdev->dDrawSpareSubchannelObject != NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY)
                                {
                                npDev->dDrawStretch.SetObject =
                                    NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                                ppdev->dDrawSpareSubchannelObject =
                                    NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                                }
                            }
                        else if (isVideo == 7)
                            {
                            if (ppdev->dDrawSpareSubchannelObject != NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY)
                                {
                                npDev->dDrawStretch.SetObject =
                                    NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                                ppdev->dDrawSpareSubchannelObject =
                                    NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                                }
                            }

                        }
                    else
                        {
                        pSaveSrcBits = (unsigned short *)(pSrcInitBits +
                                                          (wSrcXY.xy16.y * srcScanLength));
                        pSaveSrcBits += wSrcXY.xy16.x;
                        pSrcCurScan = pSaveSrcBits;

                        while (freeCount < 20)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 20;

                        if (isVideo == 2)
                            {
                             if (ppdev->dDrawSpareSubchannelObject != NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY)
                                {
                                npDev->subchannel[NV_DD_STRETCH].SetObject =
                                    NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                                ppdev->dDrawSpareSubchannelObject = NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                                }
                            }
                        else if (isVideo == 3)
                            {
                            if (ppdev->dDrawSpareSubchannelObject != NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY)
                                {
                                npDev->subchannel[NV_DD_STRETCH].SetObject =
                                    NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                                ppdev->dDrawSpareSubchannelObject = NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                                }
                            }
                        }

                    pSaveSrcInitBits = (unsigned char *)pSaveSrcBits;

                    npDev->dDrawStretch.nv4ScaledImageFromMemory.ClipPoint =
                    wDestXY.xy;

                    npDev->dDrawStretch.nv4ScaledImageFromMemory.ClipSize =
                    wXYext.wh;

                    npDev->dDrawStretch.nv4ScaledImageFromMemory.DeltaDuDx = srcDeltaX;
                    npDev->dDrawStretch.nv4ScaledImageFromMemory.DeltaDvDy = srcDeltaY;

                    wDstExt.wh = wXYext.wh;

                    /* NV3 hardware can only handle a maximum source width of 1024 */
                    if (dwSrcWidth > 1024)
                        {
                        srcTooWide = 1;
                        xStretch = 0x40000000 / (srcDeltaX >> 10);
                        dstDeltaX = (xStretch * 1024) >> 20;
                        wDstExt.wh16.w = (unsigned short)dstDeltaX;
                        srcBufferPitch = 2048;
                        }

                    // wait for any pending notification operation to finish
                    while ((volatile)pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);

                    // Let the world know we are doing DMA operations
                    ppdev->NvDmaFromMemSurfaceMem = dwSrcOffset;
                    if (dwSrcCaps & DDSCAPS_VIDEOMEMORY)
                        ppdev->NvDmaFromMemSurfaceMem += (ULONG) ppdev->pjFrameBufbase;

                    oneMorePass:       n = dwDstHeight;

                    /* Calculate initial source fractional Y */
                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    dstDeltaY = ((long)wSrcXY.xy16.y << 16) / (srcDeltaY >> 4);

                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    srcInitFract = dstDeltaY * (srcDeltaY >> 4);

                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    while (srcInitFract >> 16 < wSrcXY.xy16.y)
                        srcInitFract += (srcDeltaY >> 4);

                    /* Convert result back to 12.20 precision */
                    srcInitFract <<= 4;

                    srcInitFract &= 0xFFFFF;

                    srcCurFract = srcInitFract;

                    curV = 0;

                    wDstPoint.xy = wDestXY.xy;

                    dstStartY = dstCurY = wDestXY.xy16.y;

                    curBuffer = 0;

                    if ((srcInVideoMemory) || (isVideo > 3))
                        { // DMAable ?

                        // wait for any pending notification operation to finish
                        while ((volatile)pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);

                        pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status = NV_IN_PROGRESS;

                        while (freeCount < 28)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 28;

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutPoint =
                        wDstPoint.xy;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutSize =
                        wDstExt.wh;

                        if (dwSrcWidth < 16)
                            { // workaround for NV5 hardware bug
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                            asmMergeCoords((unsigned short) ((dwSrcPitch + 1) & ~1), dwSrcHeight);
                            }
                        else
                            {
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                            asmMergeCoords((unsigned short) ((dwSrcWidth + 1) & ~ 1), dwSrcHeight);
                            }

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInFormat =
                            (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                            (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                            dwSrcPitch;

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInOffset =
                        (unsigned long)pSaveSrcBits;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.Notify =
                        0;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInPoint =
                        wSrcPoint.xy;

                        n = 0;
                        }

                    while (n >= dstDeltaScans)
                        {
                        FAST unsigned long *pSrcBits;

                        n -= dstDeltaScans;
                        srcStartFract = srcCurFract;
                        srcCurFract += srcDeltaFract;
                        if (curBuffer == 0)
                            npPixelBuf = (unsigned char *)pScanlineBuffer;
                        else
                            npPixelBuf = (unsigned char *)(pScanlineBuffer +
                                                           (NV_DMA_SCANLINE_BUF_SIZE >> 1));

                        /* Must recalculate on each pass since src scanlines may be used more than once */
                        pSrcBits = (unsigned long *)(pSaveSrcInitBits +
                                                     (curV * (nxtSrcScan << 1)));
                        pSrcCurScan = (unsigned short *)pSrcBits;

                        m = srcDeltaScans + (srcCurFract >> 20) + 1;

                        if (skipV)
                            {
                            if ((long)dwSrcHeight - curV < (m * (skipV + 1)))
                                m = ((long)dwSrcHeight - curV) / (skipV + 1);
                            }
                        else
                            {
                            if ((long)dwSrcHeight - curV < m)
                                m = (long)dwSrcHeight - curV;
                            }

                        srcCurDeltaScans = 0;

                        /* Copy and convert a block of source pixels to transfer buffer */
                        while (--m >= 0)
                            {

                            if (pSrcBits >= (unsigned long *)pSrcInitBits)
                                {
                                //                           asmCopyScan(pSrcBits, npPixelBuf, srcBufferPitch);
                                _asm
                                {
#ifdef P6
                                    mov ecx, dword ptr srcBufferPitch
                                    mov esi, dword ptr pSrcBits
                                    shr ecx, 5
                                    nxtCacheLine2: mov eax, [esi]
                                    add esi, 32
                                    dec ecx
                                    jg nxtCacheLine2
#endif /* P6 */
                                    mov ecx, dword ptr srcBufferPitch
                                    mov esi, dword ptr pSrcBits
                                    shr ecx, 2
                                    mov edi, dword ptr npPixelBuf
                                    test ecx, 1
                                    jz doQwords2
                                    mov eax, [esi]
                                    add esi, 4
                                    mov [edi], eax
                                    add edi, 4
                                    doQwords2: shr ecx, 1
                                    jz copyDone2
#ifdef MMX
                                    nxtQword2: movq mm1, qword ptr [esi]
                                    add esi, 8
                                    movq qword ptr [edi], mm1
                                    add edi, 8
                                    dec ecx
#else /* MMX */
                                    nxtQword2: mov eax, [esi]
                                    mov edx, [esi+4]
                                    add edi, 8
                                    add esi, 8
                                    dec ecx
                                    mov [edi-8], eax
                                    mov [edi-4], edx
#endif /* MMX */
                                    copyDone2: jg nxtQword2
                                }
                                }
                            npPixelBuf += srcBufferPitch;
                            pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                            pSrcBits = (unsigned long *)pSrcCurScan;
                            srcCurDeltaScans++;
                            curV += skipV;
                            }

                        /* wait for Dma operation to finish */
                        while (pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);

                        pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status = NV_IN_PROGRESS;

                        wDstPoint.xy16.y = (short)dstCurY;
                        wDstExt.wh16.h = (unsigned short)dstDeltaScans;
                        wSrcPoint.xy16.y = (short)srcStartFract >> 16; /* convert V to 12.4 */
                        wSrcExt.wh = srcCurDeltaScans; //+ (srcCurFract >> 20) + 1;
                        wSrcExt.wh <<= 16;    /* shift V extent into place */
                        wSrcExt.wh |= (unsigned short)((dwSrcWidth + 1) & ~1);

                        while (freeCount < 28)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 28;

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutPoint =
                        wDstPoint.xy;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutSize =
                        wDstExt.wh;
                                                // NV5 hw bug workaround
                        if (dwSrcWidth < 16)
                            {
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                                (wSrcExt.wh & 0xffff0000) | dwSrcPitch;
                            }
                        else
                            {
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                                wSrcExt.wh;
                            }

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInFormat =
                            (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                           (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                            srcBufferPitch;

                        if (curBuffer == 0)
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInOffset =
                            0;
                        else
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInOffset =
                            (NV_DMA_SCANLINE_BUF_SIZE >> 1);

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.Notify =
                        0;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInPoint =
                        wSrcPoint.xy;

                        curBuffer ^= 1;
                        dstCurY += dstDeltaScans;

                        srcCurFract = ((dstCurY - dstStartY) * srcDeltaY) + srcInitFract;

                        curV = srcCurFract >> 20;
                        srcCurFract &= 0xFFFFF;

                        curV += (curV - 1) * skipV;
                        if (curV > (long)dwSrcHeight - 1)
                            curV = (long)dwSrcHeight - 1;
                        }

                    if (n > 0)
                        {
                        FAST unsigned long *pSrcBits;

                        srcStartFract = srcCurFract;
                        srcCurFract += srcDeltaFract;
                        if (curBuffer == 0)
                            npPixelBuf = (unsigned char *)pScanlineBuffer;
                        else
                            npPixelBuf = (unsigned char *)(pScanlineBuffer +
                                                           (NV_DMA_SCANLINE_BUF_SIZE >> 1));

                        /* Must recalculate since src scanlines may be used more than once */
                        pSrcBits = (unsigned long *)(pSaveSrcInitBits +
                                                     (curV * (nxtSrcScan << 1)));
                        pSrcCurScan = (unsigned short *)pSrcBits;

                        m = srcDeltaScans + (srcCurFract >> 20) + 1;

                        srcFinalHeight = m;

                        if (skipV)
                            {
                            if ((long)dwSrcHeight - curV < (m * (skipV + 1)))
                                srcFinalHeight = ((long)dwSrcHeight - curV) / (skipV + 1);
                            }
                        else
                            {
                            if ((long)dwSrcHeight - curV < m)
                                srcFinalHeight = (long)dwSrcHeight - curV;
                            }

                        srcCurDeltaScans = 0;

                        /* Copy and convert a block of source pixels to transfer buffer */
                        while (--m >= 0)
                            {
                            if (pSrcBits >= (unsigned long *)pSrcInitBits)
                                {
                                //                           asmCopyScan(pSrcBits, npPixelBuf, srcBufferPitch);
                                _asm
                                {
#ifdef P6
                                    mov ecx, dword ptr srcBufferPitch
                                    mov esi, dword ptr pSrcBits
                                    shr ecx, 5
                                    nxtCacheLine: mov eax, [esi]
                                    add esi, 32
                                    dec ecx
                                    jg nxtCacheLine
#endif /* P6 */
                                    mov ecx, dword ptr srcBufferPitch
                                    mov esi, dword ptr pSrcBits
                                    shr ecx, 2
                                    mov edi, dword ptr npPixelBuf
                                    test ecx, 1
                                    jz doQwords
                                    mov eax, [esi]
                                    add esi, 4
                                    mov [edi], eax
                                    add edi, 4
                                    doQwords: shr ecx, 1
                                    jz copyDone
#ifdef MMX
                                    nxtQword: movq mm1, qword ptr [esi]
                                    add esi, 8
                                    movq qword ptr [edi], mm1
                                    add edi, 8
                                    dec ecx
#else /* MMX */
                                    nxtQword: mov eax, [esi]
                                    mov edx, [esi+4]
                                    add edi, 8
                                    add esi, 8
                                    dec ecx
                                    mov [edi-8], eax
                                    mov [edi-4], edx
#endif /* MMX */
                                    copyDone: jg nxtQword
                                }
                                }
                            npPixelBuf += srcBufferPitch;
                            if (--srcFinalHeight > 0)
                                pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                            pSrcBits = (unsigned long *)pSrcCurScan;
                            srcCurDeltaScans++;
                            curV += skipV;
                            }

                        /* wait for Dma operation to finish */
                        while (pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);

                        pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status = NV_IN_PROGRESS;

                        wDstPoint.xy16.y = (short)dstCurY;
                        wDstExt.wh16.h = (unsigned short)n;
                        wSrcPoint.xy16.y = (short)srcStartFract >> 16; /* convert V to 12.4 */
                        wSrcExt.wh = srcCurDeltaScans; //+ (srcCurFract >> 20) + 1;
                        wSrcExt.wh <<= 16;    /* shift V extent into place */
                        wSrcExt.wh |= (unsigned short)((dwSrcWidth + 1) & ~1);

                        while (freeCount < 28)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 28;

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutPoint =
                        wDstPoint.xy;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutSize =
                        wDstExt.wh;

                        // NV5 hw bug workaround
                        if (dwSrcWidth < 16)
                            {
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                                (wSrcExt.wh & 0xffff0000) | dwSrcPitch;
                            }
                        else
                            {
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                                wSrcExt.wh;
                            }

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInFormat =
                            (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                            (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                            srcBufferPitch;

                        if (curBuffer == 0)
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInOffset =
                            0;
                            //(sizeof(NvNotification) << 3); /* there are 4 notifiers in the buffer */
                        else
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInOffset =
                            (NV_DMA_SCANLINE_BUF_SIZE >> 1);
                            //(sizeof(NvNotification) << 3) + (NV_DMA_SCANLINE_BUF_SIZE >> 1);

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.Notify =
                        0;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInPoint =
                        wSrcPoint.xy;
                        }

                    if (srcTooWide)
                        {
                        srcTooWide = 0;
                        wDestXY.xy16.x += (short)dstDeltaX;
                        wDstExt.wh16.w = wXYext.wh16.w - wDstExt.wh16.w;
                        if ((srcInVideoMemory) || (isVideo > 3))
                            wSrcPoint.xy16.x += (1024 << 4);
                        srcBufferPitch = ((dwSrcWidth << 1) + 3) & ~3L;
                        srcBufferPitch -= 2048;
                        pSaveSrcInitBits += 2048;
                        pSaveSrcBits = (unsigned short *)pSaveSrcInitBits;
                        pSrcCurScan = pSaveSrcBits;
                        goto oneMorePass;
                        }
#ifdef  MMX
                    if (curV != 0)
                        {
                        _asm emms;
                        }
#endif /* MMX */

                    }
                    if (isOverlappingVmem && lpSurfTemp)
                        {
                        NVHEAP_FREE(lpSurfTemp);
                        }
                }

            if (dwFlags & DDBLT_KEYSRCOVERRIDE)
                {
                // disable chroma key
                while (freeCount < 2*4)
                    freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                freeCount -= 2*4;
                if (ppdev->dDrawSpareSubchannelObject != NV_DD_IMAGE_SOLID)
                    {
                    npDev->dDrawSpare.SetObject = NV_DD_IMAGE_SOLID;
                    ppdev->dDrawSpareSubchannelObject = NV_DD_IMAGE_SOLID;
                    }
                npDev->dDrawTransColor.SetColor = 0;
                }

            }
        else
            {
            DPF("BLT     blt not handled by driver");
            ppdev->NVFreeCount = freeCount;
            return DDHAL_DRIVER_NOTHANDLED;
            }
        }
    else if (dwFlags & DDBLT_COLORFILL)
        {
        dwFillColor = (pbd->bltFX.dwFillColor & ppdev->physicalColorMask) | ppdev->AlphaEnableValue;
        DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);

        while (freeCount < 16)
            freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
        freeCount -= 16;

        npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;

        npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.Color1A = dwFillColor;

        npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].point =
        asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);

        npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].size =
        asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);
        }
#ifdef NVD3D
//*********************************************************************************
// BUGBUG - z clear rectangle has not been implemented.
//*********************************************************************************
    else if (dwFlags & DDBLT_DEPTHFILL)
        {
        unsigned long dwFillDepth = pbd->bltFX.dwFillDepth;

        if (!(dwDstCaps & DDSCAPS_ZBUFFER))
            {
            pbd->ddRVal = DDERR_INVALIDSURFACETYPE;
            ppdev->NVFreeCount = freeCount;
            return DDHAL_DRIVER_HANDLED;
            }
        ppdev->NVFreeCount = freeCount;
        // BUGBUG NV3_SetZBufferBase(ppdev, dwDstOffset, dwDstPitch);
        freeCount = ppdev->NVFreeCount;

        while (freeCount < 6*4)
            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
        freeCount -= 6*4;

        /* Temporarily replace BLIT object */
        npDev->subchannel[NV_DD_BLIT].SetObject =
        NV_DD_RENDER_SOLID_ZETA_RECTANGLE;

        npDev->subchannel[NV_DD_BLIT].nvRenderSolidRectangle.Color =
        dwFillDepth;

        npDev->subchannel[NV_DD_BLIT].nvRenderSolidRectangle.Rectangle[0].y_x =
        asmMergeCoords(wDestXY.xy16.x, wDestXY.xy16.y);

        npDev->subchannel[NV_DD_BLIT].nvRenderSolidRectangle.Rectangle[0].height_width =
        asmMergeCoords(wXYext.wh16.w, wXYext.wh16.h);

        npDev->subchannel[NV_DD_BLIT].SetObject =
        NV_DD_IMAGE_BLIT;

        npDev->subchannel[NV_DD_SPARE].SetObject =
        NV_DD_DST_IMAGE_IN_MEMORY;
        ppdev->dDrawSpareSubchannelObject = NV_DD_DST_IMAGE_IN_MEMORY;
        }
#endif // #ifdef NVD3D
    else
        {
        /* We don't handle any other type of BLT operation */
        ppdev->NVFreeCount = freeCount;
        return DDHAL_DRIVER_NOTHANDLED;
        }

    ppdev->NVFreeCount = (short)freeCount;

    pbd->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;

    } /* Nv4Blt16 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\dd.cpp ===
// **************************************************************************
//
//       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: dd.cpp
//      nVidia routines to support the DirectDraw interface on NT4
//
// **************************************************************************
//
// Environment: kernel mode only
//
//******************************************************************************
#include "nvprecomp.h"
#include "nvalpha.h"
#include "ddminint.h"
#include "nv32.h"
#include "nvcm.h"
#include "nvUtil.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "nvsubch.h"

#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free

extern ULONG NV4_ChannelIsGdi(PDEV *ppdev);
extern VOID NV4_DdPioSync(PDEV *ppdev);
    
extern GLOBALDATA           DriverData;     // in ddmini16.c

static OLD_FLIPRECORD       flipPrimaryRecord;
static OLD_FLIPRECORD       flipOverlayRecord;

/*
 * IN_VBLANK should be replaced by a test to see if the hardware is currently
 * in the vertical blank
 */
#define IN_VBLANK               FALSE
#define IN_DISPLAY              TRUE

/*
 * CURRENT_VLINE should be replaced by a macro to retrieve the current
 * scanline
 */
#define CURRENT_VLINE   (ppdev->pfnGetScanline(ppdev))

// Defines we'll use in the surface's 'dwReserved1' field:

#define DD_RESERVED_DIFFERENTPIXELFORMAT    0x0001


// Worst-case possible number of FIFO entries we'll have to wait for in
// DdBlt for any operation:

#define DDBLT_FIFO_COUNT    9

// NT is kind enough to pre-calculate the 2-d surface offset as a 'hint' so
// that we don't have to do the following, which would be 6 DIVs per blt:
//
//    y += (offset / pitch)
//    x += (offset % pitch) / bytes_per_pixel

#define convertToGlobalCord(x, y, surf) \
{                                       \
    y += surf->yHint;                   \
    x += surf->xHint;                   \
}


#define MAGIC_DELAY         1000000

#define WAIT_OVERLAY_NOTIFIER(buf)                                                                  \
{   NvNotification *pFlipOverlayNotifier =    (NvNotification *)ppdev->Notifiers->FlipOverlay;      \
    ULONG i = 0;                                                                                    \
    while (pFlipOverlayNotifier[NV07A_NOTIFIERS_SET_OVERLAY(buf)].status == NV_IN_PROGRESS)         \
        if(i++ > MAGIC_DELAY) break;                                                                \
}                                                                                                   \


/*
 * Nv4UpdateFlipStatus
 *
 * checks and sees if the most recent flip has occurred
 */
unsigned long Nv4UpdateFlipStatus( PDEV *ppdev, FLATPTR fpVidMem )
    {

	ULONG ulIndex;

    /*
     * see if a flip has happened recently
     */
    if (flipPrimaryRecord.bFlipFlag &&
        ((fpVidMem == 0) || (fpVidMem == flipPrimaryRecord.fpFlipFrom)) )
        {
        if(((NvNotification *) (&(ppdev->Notifiers->FlipPrimary[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status == NV_IN_PROGRESS)
        {
            return DDERR_WASSTILLDRAWING;
        }
	    else
        {
    	    ppdev->CurrentVisibleSurfaceAddress = flipPrimaryRecord.fpFlipTo;
            flipPrimaryRecord.bFlipFlag = FALSE;
        	return DD_OK;
        }

        /*
         * if we aren't in the vertical blank, we can use the scanline
         * to help decide on what to do
         */
//        if(!(IN_VBLANK)) {
//            if( (CURRENT_VLINE >= flipPrimaryRecord.wFlipScanLine) ) {
//                QueryPerformanceCounter((LARGE_INTEGER*)&ttime);
//                if( (DWORD)(ttime-flipPrimaryRecord.liFlipTime) <= flipPrimaryRecord.dwFlipDuration ) {
//                    return DDERR_WASSTILLDRAWING;
//                }
//            }
//        }
        /*
         * in the vertical blank, scanline is useless
         */
//        else {
//            QueryPerformanceCounter((LARGE_INTEGER*)&ttime);
//            if( ((DWORD)(ttime-flipPrimaryRecord.liFlipTime) <= flipPrimaryRecord.dwFlipDuration) ) {
//                return DDERR_WASSTILLDRAWING;
//            }
//        }
//        flipPrimaryRecord.bFlipFlag = FALSE;
        }

    if (flipOverlayRecord.bFlipFlag &&
        ((fpVidMem == 0) ||
         (fpVidMem == flipOverlayRecord.fpFlipFrom) ||
         (fpVidMem == flipOverlayRecord.fpPreviousFlipFrom)) ) {
        NvNotification *pPioFlipOverlayNotifier =
            (NvNotification *)ppdev->Notifiers->FlipOverlay;

        if (ppdev->CurrentClass.VideoOverlay == NV04_VIDEO_OVERLAY) {

            if (fpVidMem == flipOverlayRecord.fpPreviousFlipFrom) {
                // only need for one to flush out
                if (pPioFlipOverlayNotifier[ppdev->OverlayBufferIndex + 1].status == NV_IN_PROGRESS)
                    return (DDERR_WASSTILLDRAWING);
            } else {
                // need to wait for both flips to flush out
                if ((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) ||
                    (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) {
                    return (DDERR_WASSTILLDRAWING);
                } else {
                    flipOverlayRecord.bFlipFlag = FALSE;
                }
            }
        } else {
            if (fpVidMem == flipOverlayRecord.fpPreviousFlipFrom) {
/* The WHQL flip status test doesn't like this conservatism.  Comment out for now.
                LONGLONG timeNow;
                // only need for one to flush out, no way to really determine this on NV10,
                // but if we wait at least one CRTC refresh since it was issued, we can
                // guarantee it has been flushed through
                if ((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) &&
                    (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) {
                    EngQueryPerformanceCounter((LONGLONG *) &timeNow);
                    if ((timeNow - flipOverlayRecord.llPreviousFlipTime) < flipPrimaryRecord.dwFlipDuration) {
                        return (DDERR_WASSTILLDRAWING);
                    }
                }
*/
            } else {
                if (fpVidMem == flipOverlayRecord.fpFlipFrom) {
                    // need to wait for both flips to flush out
                    if ((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) &&
                        (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) {
                        return (DDERR_WASSTILLDRAWING);
                    } else {
                        flipOverlayRecord.bFlipFlag = FALSE;
                    }
                }
            }
        }
        return (DD_OK);
    }

    return DD_OK;
}

//******************************Public*Routine**********************************
//
// Function: Nv4Blt()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************
DWORD Nv4Blt(PDD_BLTDATA pbd)
    {
    HRESULT     ddrval;
    PDEV        *ppdev;
    Nv3ChannelPio   *npDev;
    USHORT  freeCount;
    ULONG   DdReturncode;
    BOOL    releaseOpenglSemaphore = FALSE;
    NvNotification *pSyncNotifier;

    ppdev = (PDEV *)pbd->lpDD->dhpdev;
    npDev = (Nv3ChannelPio *) ppdev->ddChannelPtr;

    if (npDev == NULL)
        {
        pbd->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
        }

    /*
     * is a flip in progress?
     */
    ddrval = Nv4UpdateFlipStatus(ppdev, pbd->lpDDDestSurface->lpGbl->fpVidMem);
    if ( ddrval != DD_OK )
        {
        if (pbd->dwFlags & DDBLT_WAIT)
            {
            while (ddrval != DD_OK)
                ddrval = Nv4UpdateFlipStatus(ppdev, pbd->lpDDDestSurface->lpGbl->fpVidMem);
            }
        else
            {
            pbd->ddRVal = ddrval;
            return DDHAL_DRIVER_HANDLED;
            }
        }

        ENTER_DMA_PUSH_SYNC();
        NV_DD_DMA_PUSHER_SYNC();

        if (ppdev->DdClipResetFlag)
            {
            freeCount = ppdev->NVFreeCount;
            while (freeCount < 2*4)
                freeCount = NvGetFreeCount(npDev, NV_DD_CLIP);
            freeCount -= 2*4;
            npDev->subchannel[NV_DD_CLIP].Nv01ContextClipRectangle.SetPoint = 0;
            npDev->subchannel[NV_DD_CLIP].Nv01ContextClipRectangle.SetSize =
            asmMergeCoords(ppdev->cxMemory, ppdev->cyMemory);
            ppdev->DdClipResetFlag = 0;       // Clipping rectangle has been reset
            ppdev->NVFreeCount = freeCount;
            }


    if (ppdev->cBitsPerPel == 8)
        {
        DdReturncode = Nv4Blt8(pbd);
        }
    else if (ppdev->cBitsPerPel == 16)
        {
        DdReturncode = Nv4Blt16(pbd);
        }
    else if (ppdev->cBitsPerPel == 32)
        {
        DdReturncode = Nv4Blt32(pbd);
        }
    else
        {
        pbd->ddRVal = DDERR_INVALIDPIXELFORMAT;
        DdReturncode = DDHAL_DRIVER_NOTHANDLED;
        }
    ppdev->NVFreeCount = 0;
    EXIT_DMA_PUSH_SYNC(DdReturncode);
    }

//******************************Public*Routine**********************************
//
// Function: Nv4Flip()
//
//  Note that lpSurfCurr may not necessarily be valid.
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

DWORD __stdcall Nv4Flip(PDD_FLIPDATA pfd)
    {
    FAST short freeCount;
    HRESULT     ddrval;
    PDD_SURFACE_GLOBAL   pSurfTarg_gbl;
    BOOL    releaseOpenglSemaphore = FALSE;

    PDEV *ppdev = (PDEV *) pfd->lpDD->dhpdev;
    FAST Nv3ChannelPio *npDev = (Nv3ChannelPio *)ppdev->ddChannelPtr;

    NvNotification *pFlipOverlayNotifier =
    (NvNotification *)ppdev->Notifiers->FlipOverlay;
    NvNotification *pDmaToMemNotifier =
    (NvNotification *)ppdev->Notifiers->DmaToMem;

    /*
     * NOTES:
     *
     * This callback is invoked whenever we are about to flip to from
     * one surface to another.   pfd->lpSurfCurr is the surface we were at,
     * pfd->lpSurfTarg is the one we are flipping to.
     *
     * You should point the hardware registers at the new surface, and
     * also keep track of the surface that was flipped away from, so
     * that if the user tries to lock it, you can be sure that it is done
     * being displayed
     */

    DPF( "Flip32: curr=%08lx, targ=%08lx", pfd->lpSurfCurr, pfd->lpSurfTarg );
    DPF( "        vidmem ptrs change: %08lx->%08lx",
         pfd->lpSurfCurr->lpGbl->fpVidMem,
         pfd->lpSurfTarg->lpGbl->fpVidMem );


    ddrval = Nv4UpdateFlipStatus(ppdev, 0);

    if (ddrval != DD_OK)
        {
        if (pfd->dwFlags & DDFLIP_WAIT)
            {
            while (ddrval != DD_OK)
                {
                ddrval = Nv4UpdateFlipStatus(ppdev, 0);
                }
            }
        else
            {
            pfd->ddRVal = ddrval;
            return DDHAL_DRIVER_HANDLED;
            }
        }

    if (npDev == NULL)
        {
        pfd->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
        }

    if ((pfd->dwFlags & DDFLIP_WAIT) &&
        ppdev->pfnGraphicsEngineBusy(ppdev))
        {
        ppdev->NVFreeCount = 0;
        pfd->ddRVal = DDERR_WASSTILLDRAWING;
        EXIT_DMA_PUSH_SYNC(DDHAL_DRIVER_HANDLED);
        }

    ENTER_DMA_PUSH_SYNC();
    NV_DD_DMA_PUSHER_SYNC();
    NV4_DdPioSync(ppdev);

    freeCount = NvGetFreeCount(npDev, 7);

    /*
     * everything is OK, do the flip here
     */

    pSurfTarg_gbl = pfd->lpSurfTarg->lpGbl;

    /* Is this an overlay surface ? */
    if (!(pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_OVERLAY))
        {
        /* No - assume it is the primary surface */

        ULONG i, ulHead;

        flipPrimaryRecord.fpFlipFrom = pfd->lpSurfCurr->lpGbl->fpVidMem;
        flipPrimaryRecord.bHaveEverCrossedVBlank = FALSE;
        flipPrimaryRecord.fpFlipTo = pSurfTarg_gbl->fpVidMem;

        flipPrimaryRecord.bFlipFlag = TRUE;

        ((NvNotification *) (&(ppdev->Notifiers->FlipPrimary[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status = NV_IN_PROGRESS;
    	for(i = 0; i < ppdev->ulNumberDacsActive; i++)
	    {
            NV_CREATE_OBJECT_SETUP();

            ulHead = ppdev->ulDeviceDisplay[i];

            while (freeCount < 4 * 6)
                freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
            freeCount -= 4 * 6;


            npDev->subchannel[NV_DD_SPARE].SetObject = NV_DD_VIDEO_LUT_CURSOR_DAC+ulHead;
            ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_LUT_CURSOR_DAC+ulHead;
            
            npDev->dDrawSpare.SetObject = NV_DD_VIDEO_LUT_CURSOR_DAC+ulHead;
            npDev->dDrawSpare.Nv04VideoLutCursorDac.SetImage[0].offset = 
                pSurfTarg_gbl->fpVidMem + i * ppdev->ulHeadDisplayOffset[ulHead];
            npDev->dDrawSpare.Nv04VideoLutCursorDac.SetImage[0].format = ppdev->lDelta | 
                NV046_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 31;

            ppdev->ulFlipBase = pSurfTarg_gbl->fpVidMem;

        }
        // Syn. with both heads
        if(ppdev->ulNumberDacsActive > 1)
            while(((NvNotification *) (&(ppdev->Notifiers->FlipPrimary[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status == NV_IN_PROGRESS);

        if (IN_VBLANK)
            {
            flipPrimaryRecord.dwFlipScanLine = 0;
            flipPrimaryRecord.bWasEverInDisplay = FALSE;
            }
        else
            {
            flipPrimaryRecord.dwFlipScanLine = CURRENT_VLINE;
            flipPrimaryRecord.bWasEverInDisplay = TRUE;
            }
        }
    else if (pfd->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
        { /* overlay */
        DWORD dwOffset;
        DWORD dwPitch;
        DWORD index;

        flipOverlayRecord.liPreviousFlipTime = flipOverlayRecord.liFlipTime;
        EngQueryPerformanceCounter((LONGLONG *) &flipOverlayRecord.liFlipTime);
        flipOverlayRecord.fpPreviousFlipFrom = flipOverlayRecord.fpFlipFrom;
        flipOverlayRecord.fpFlipFrom = pfd->lpSurfCurr->lpGbl->fpVidMem;
        flipOverlayRecord.fpFlipTo = pSurfTarg_gbl->fpVidMem;
        flipOverlayRecord.bHaveEverCrossedVBlank = FALSE;

        flipOverlayRecord.bFlipFlag = TRUE;

        /* Alternate buffer indexes to keep the hardware happy */

   	    ppdev->OverlayBufferIndex ^= 1;
    	index = ppdev->OverlayBufferIndex;

        /* Make sure we flip to the correct starting offset in new overlay surface */
        dwOffset = pSurfTarg_gbl->fpVidMem;

        if ((pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_IF09) ||
            (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_YVU9) ||
            (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_IV32) ||
            (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_IV31))
            {
            /* Skip over Indeo portion of surface */
            dwPitch = (DWORD)pSurfTarg_gbl->wWidth;
            dwOffset += ((dwPitch * ((DWORD)pSurfTarg_gbl->wHeight * 10L)) >> 3);
            /* Force block to be properly aligned */
            dwOffset = (dwOffset + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
            dwPitch = ((pSurfTarg_gbl->wWidth + 1) & 0xFFFFFFFE) << 1;
            dwPitch = (dwPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
            }
        else if ((pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_YV12) ||
                 (pSurfTarg_gbl->ddpfSurface.dwFourCC == FOURCC_420i))
            {
            /* Assumes a separate overlay YUY2 surface in video memory */
            if (pSurfTarg_gbl->fpVidMem == ppdev->NvFloatingMem2MemFormatBaseAddress)
                dwOffset = ppdev->NvYUY2Surface0Mem;
            else if (pSurfTarg_gbl->fpVidMem == ppdev->NvFloatingMem2MemFormatNextAddress)
                dwOffset = ppdev->NvYUY2Surface1Mem;
            else
                dwOffset = ppdev->NvYUY2Surface2Mem;

            dwPitch = ((pSurfTarg_gbl->wWidth + 1) & 0xFFFFFFFE) << 1;
            dwPitch = (dwPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
            }
        else
            dwPitch = (DWORD)pSurfTarg_gbl->lPitch;

        dwOffset += (ppdev->OverlaySrcY * dwPitch);
        dwOffset += (ppdev->OverlaySrcX << 1);



        while (freeCount < 10*4)
            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
        freeCount -= 10*4;

        if (ppdev->dDrawSpareSubchannelObject != NV_DD_VIDEO_OVERLAY)
        {
            npDev->subchannel[NV_DD_SPARE].SetObject = NV_DD_VIDEO_OVERLAY;
            ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_OVERLAY;
        }

        npDev->dDrawSpare.SetObject = NV_DD_VIDEO_OVERLAY;

        npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].colorKey = ppdev->dwVideoColorKey;
        npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].offset =  dwOffset;
        npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].sizeIn = ppdev->OverlaySrcSize;
        npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].pointIn = 0;
        npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].dsDx = ppdev->dwOverlayDeltaX;
        npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].dtDy = ppdev->dwOverlayDeltaY;
        npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].pointOut = asmMergeCoords(ppdev->dwOverlayDstX, ppdev->dwOverlayDstY);
        npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].sizeOut = asmMergeCoords(ppdev->dwOverlayDstWidth, ppdev->dwOverlayDstHeight);
        npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].format = ppdev->dwOverlayFormat | dwPitch;
        ppdev->OverlaySrcOffset = dwOffset;
        }
    else
        { /* video port flips handled by FlipVideoPort32 */
        ppdev->NVFreeCount = freeCount;
        pfd->ddRVal = DDERR_INVALIDSURFACETYPE;
        EXIT_DMA_PUSH_SYNC(DDHAL_DRIVER_HANDLED);
        }

    if (pfd->dwFlags & DDFLIP_WAIT)
        {
        ddrval = Nv4UpdateFlipStatus(ppdev, 0);

        while (ddrval != DD_OK)
            ddrval = Nv4UpdateFlipStatus(ppdev, 0);
        }

    ppdev->NVFreeCount = freeCount;

    pfd->ddRVal = DD_OK;
    EXIT_DMA_PUSH_SYNC(DDHAL_DRIVER_HANDLED);

    } /* Flip32 */

//******************************Public*Routine**********************************
//
// Function: Nv4Lock()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************
DWORD Nv4Lock(
            PDD_LOCKDATA lpLockData)
    {
    HRESULT                     ddrval;
    DWORD                       dwOffset;
    DWORD                       caps;
    PDD_SURFACE_GLOBAL          psurf_gbl;
    BOOL    releaseOpenglSemaphore = FALSE;

    PDEV    *ppdev = (PDEV *) lpLockData->lpDD->dhpdev;
    FAST Nv3ChannelPio              *npDev = (Nv3ChannelPio *)ppdev->ddChannelPtr;
    NvNotification *pPioFlipOverlayNotifier = (NvNotification *)ppdev->Notifiers->FlipOverlay;

    NvNotification              *pDmaToMemNotifier =
    (NvNotification *)ppdev->Notifiers->DmaToMem;
    NvNotification              *pDmaFromMemNotifier =
    (NvNotification *)ppdev->Notifiers->DmaFromMem;
    NvNotification              *pSyncNotifier =
      (NvNotification *)ppdev->Notifiers->Sync;


    psurf_gbl = lpLockData->lpDDSurface->lpGbl;

    if (lpLockData->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
        {
        //*****************************************************************
        // For surfaces in system memory, just return the user-mode address
        //*****************************************************************
        lpLockData->lpSurfData = (VOID*) psurf_gbl->fpVidMem;
        lpLockData->ddRVal = DD_OK;

        //*****************************************************************
        // When a driver returns DD_OK and DDHAL_DRIVER_HANDLED from DdLock,
        // DirectDraw expects it to have adjusted the resulting pointer
        // to point to the upper left corner of the specified rectangle, if
        // any:
        //*****************************************************************
        if (lpLockData->bHasRect)
            {
            lpLockData->lpSurfData = (VOID*) ((BYTE*) lpLockData->lpSurfData
                                              + lpLockData->rArea.top * psurf_gbl->lPitch
                                              + lpLockData->rArea.left
                                              * (psurf_gbl->ddpfSurface.dwYUVBitCount >> 3));
            }

        return (DDHAL_DRIVER_HANDLED);
        }

    /*
     * NOTES:
     *
     * This callback is invoked whenever a surface is about to be directly
     * accessed by the user.   This is where you need to make sure that
     * a surface can be safely accessed by the user.
     *
     * If your memory cannot be accessed while in accelerator mode, you
     * should either take the card out of accelerator mode or else
     * return DDERR_SURFACEBUSY
     *
     * If someone is accessing a surface that was just flipped away from,
     * make sure that the old surface (what was the primary) has finished
     * being displayed.
     */

    caps = lpLockData->lpDDSurface->ddsCaps.dwCaps;

    if ((npDev == NULL) && (caps & DDSCAPS_VIDEOMEMORY))
        {  /* Mode switches might occur without warning */
        lpLockData->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
        }

    psurf_gbl = lpLockData->lpDDSurface->lpGbl;

    /*
     * check to see if any pending physical flip has occurred
     */

    ddrval = Nv4UpdateFlipStatus(ppdev, psurf_gbl->fpVidMem);
    if ( ddrval != DD_OK )
        {
        if (lpLockData->dwFlags & DDLOCK_WAIT)
            {
            while (ddrval != DD_OK)
                {
                long countDown = 500000;  // sometimes we can loose a Flip notification
                ddrval = Nv4UpdateFlipStatus(ppdev, psurf_gbl->fpVidMem);
                if (--countDown <= 0)
                    {
                    ((NvNotification *) (&(ppdev->Notifiers->FlipPrimary[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status = 0;
                    pPioFlipOverlayNotifier[1].status = 0;
                    pPioFlipOverlayNotifier[2].status = 0;
                    }
                }
            }
        else
            {
            lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
            return DDHAL_DRIVER_HANDLED;
            }
        }

    if (caps & (DDSCAPS_VIDEOMEMORY | DDSCAPS_PRIMARYSURFACE))
        {
        if (((caps & DDSCAPS_TEXTURE) == 0) && ((lpLockData->dwFlags & DDLOCK_READONLY) == 0))
            {

            if (!OglIsEnabled(ppdev))
                {
                //***********************************************************************
                // Ensure graphics engine has completed all processing in Ddraw
                // channel. We know the GDI channel is idle at this point.
                //***********************************************************************
                NV_DD_DMA_PUSHER_SYNC();
                NV4_DdPioSync(ppdev);
                }
            else
                {
                //************************************************************************
                // If OpenGL ICD is running, the fifo sync routine will ensure the fifo is
                // empty and the graphics engine has completed its processing.
                //*************************************************************************
                START_DMA_PUSH_SYNC();
                NV_DD_DMA_PUSHER_SYNC();
                ppdev->NVFreeCount = 0;
                END_DMA_PUSH_SYNC();
                }
            }
        else
            {
            return(DDHAL_DRIVER_NOTHANDLED);
            }
        }
    return(DDHAL_DRIVER_NOTHANDLED);
    }

//******************************Public*Routine**********************************
//
// Function: Nv4Unlock()
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

DWORD __stdcall Nv4Unlock( PDD_UNLOCKDATA lpUnlockData )
    {
    FAST Nv3ChannelPio          *npDev;
    PDD_SURFACE_GLOBAL   pSurf_gbl;
    DWORD                       caps;
    PDEV*   ppdev;

    caps = lpUnlockData->lpDDSurface->ddsCaps.dwCaps;
    ppdev = (PDEV *) lpUnlockData->lpDD->dhpdev;
    npDev = (Nv3ChannelPio *) ppdev->ddChannelPtr;

    if ((npDev == NULL) && (caps & DDSCAPS_VIDEOMEMORY))
        {  /* Mode switches might occur without warning */
        lpUnlockData->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
        }

    pSurf_gbl = lpUnlockData->lpDDSurface->lpGbl;

    if (caps & DDSCAPS_OVERLAY)
        Nv4UnlockOverlay(lpUnlockData);

    lpUnlockData->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;

    } /* Unlock32 */


//******************************Public*Routine**********************************
//
// Function: Nv4GetBltStatus()
//
//      Doesn't currently really care what surface is specified, just checks
//      and goes.
//
// Routine Description:
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

DWORD Nv4GetBltStatus(
                    PDD_GETBLTSTATUSDATA lpGetBltStatus)

    {
    PDEV*   ppdev;
    BYTE*   pjMmBase;
    HRESULT ddRVal;
    FNGRAPHICSENGINEBUSY*  pfnGraphicsEngineBusy;
    FNFIFOISBUSY*         pfnFifoIsBusy;
    Nv3ChannelPio *npDev;

    ppdev    = (PDEV*) lpGetBltStatus->lpDD->dhpdev;

    //**************************************************************************
    // Init chip specific function pointers
    //**************************************************************************

    pfnGraphicsEngineBusy = ppdev->pfnGraphicsEngineBusy;
    pfnFifoIsBusy         = ppdev->pfnFifoIsBusy;

    ddRVal = DD_OK;
    if (lpGetBltStatus->dwFlags == DDGBS_CANBLT)
        {
        //**********************************************************************
        // DDGBS_CANBLT case: can we add a blt?
        //**********************************************************************

        ddRVal = Nv4UpdateFlipStatus(ppdev,
                                        lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem);

         }

    else

        {
        //**********************************************************************
        // DDGBS_ISBLTDONE case: is a blt in progress?
        //**********************************************************************
        npDev = (Nv3ChannelPio *) ppdev->ddChannelPtr;
        NV_DD_DMA_PUSHER_SYNC();
        NV4_DdPioSync(ppdev);
        ddRVal = DD_OK;
        }

    lpGetBltStatus->ddRVal = ddRVal;
    return (DDHAL_DRIVER_HANDLED);
    }

//******************************Public*Routine**********************************
//
// Function: Nv4DestroySurface
//
// Routine Description:
//
//      Note that if DirectDraw did the allocation, DDHAL_DRIVER_NOTHANDLED
//      should be returned.
//
// Arguments:
//
//     ppdev - Pointer to the physical device structure
//
// Return Value:
//
//     None.
//
//******************************************************************************

DWORD __stdcall Nv4DestroySurface( PDD_DESTROYSURFACEDATA lpDestroySurface )
    {
    PDD_DIRECTDRAW_GLOBAL pdrv;
    PDD_SURFACE_LOCAL   psurf;
    PDD_SURFACE_GLOBAL  psurf_gbl;
    BOOL    releaseOpenglSemaphore = FALSE;

    DWORD                       index = 0;
    PDEV *ppdev = (PDEV *) lpDestroySurface->lpDD->dhpdev;
    Nv3ChannelPio  *npDev = (Nv3ChannelPio *)ppdev->ddChannelPtr;
    USHORT     freeCount = ppdev->NVFreeCount;
    NvNotification *pFlipOverlayNotifier = (NvNotification *)ppdev->Notifiers->FlipOverlay;

    pdrv = lpDestroySurface->lpDD;
    DPF( "in DestroySurface, lpDestroySurface->lpDD=%08lx, lpDestroySurface->lpDDSurface = %08lx",
         pdrv, lpDestroySurface->lpDDSurface );

    psurf = lpDestroySurface->lpDDSurface;
    psurf_gbl = psurf->lpGbl;

    if (psurf_gbl->fpVidMem == 0)
        {
        lpDestroySurface->ddRVal = DD_OK;
        goto DESTROY_HANDLED;
        }

    /*
       Should check if YUV surface is an active VPE surface and make sure
       to stop VPE hardware before destroying VPE surface somewhere YUV
       surface code in this function.
    */

    if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
        (psurf->ddsCaps.dwCaps & (DDSCAPS_VISIBLE | DDSCAPS_FRONTBUFFER)))
        {
        //**************************************************************
        // Ensure GDI channel has completed processing.
        //**************************************************************
        ENTER_DMA_PUSH_SYNC();
        NV_DD_DMA_PUSHER_SYNC();


        freeCount = ppdev->NVFreeCount;
        ppdev->HALInfo.ddCaps.dwCurrVisibleOverlays = 0;

        WAIT_OVERLAY_NOTIFIER(0);
        WAIT_OVERLAY_NOTIFIER(1);

        while (freeCount < 3*4)
            freeCount = NvGetFreeCount(npDev, BLIT_SUBCHANNEL);
        freeCount -= 3*4;

        npDev->dDrawSpare.SetObject = NV_DD_VIDEO_OVERLAY;
        npDev->dDrawSpare.Nv04VideoOverlay.StopOverlay[0] = NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE;
        npDev->dDrawSpare.Nv04VideoOverlay.StopOverlay[1] = NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE;

        ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_OVERLAY;

        ppdev->NVFreeCount = (short)freeCount;
        END_DMA_PUSH_SYNC();
        }

    if (
       // (psurf->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
       (psurf_gbl->ddpfSurface.dwFlags & DDPF_FOURCC) )
        {
        DPF( "  FOURCC surface" );

        switch ( psurf->lpGbl->ddpfSurface.dwFourCC )
            {
            case FOURCC_RGB0:
                if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
                    {
                    if (psurf_gbl->fpVidMem > 0)
                        {
                        NVHEAP_FREE( psurf_gbl->fpVidMem);
                        psurf_gbl->fpVidMem = 0;
                        if (ppdev->DDrawVideoSurfaceCount > 0)
                            ppdev->DDrawVideoSurfaceCount--;
                        }
                    }
                else
                    {
                    lpDestroySurface->ddRVal = DD_OK;
                    return DDHAL_DRIVER_NOTHANDLED;
                    }
                lpDestroySurface->ddRVal = DD_OK;
                goto DESTROY_HANDLED;
                break;
            case FOURCC_IF09:
            case FOURCC_YVU9:
            case FOURCC_IV32:
            case FOURCC_IV31:
            case FOURCC_YUY2:
            case FOURCC_UYVY:
                if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
                    {
                    while (index < NV_MAX_OVERLAY_SURFACES)
                        {
                        if ((DWORD)psurf == ppdev->dwOverlaySurfaceLCL[index])
                            {
                            ppdev->dwOverlaySurfaceLCL[index] = 0;
                            if (ppdev->dwOverlaySurfaces > 0)
                                ppdev->dwOverlaySurfaces--;
                            if (ppdev->dwOverlaySurfaces == 0)
                                {
                                ppdev->dwOverlayOwner = 0;
                                }
                            }
                        index++;
                        }
                    }

                if ((psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
                    ((psurf->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) == 0))
                    {
                    if (psurf_gbl->fpVidMem > 0)
                        {
                        NVHEAP_FREE(psurf_gbl->fpVidMem);
                        psurf_gbl->fpVidMem = 0;
                        if (ppdev->DDrawVideoSurfaceCount > 0)
                            ppdev->DDrawVideoSurfaceCount--;
                        }
                    }
                else
                    {
                    if ((ppdev->fNvActiveFloatingContexts) &&
                        ((psurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_UYVY) ||
                         (psurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_YUY2)))
                        {
                        if (psurf->lpGbl->ddpfSurface.dwFourCC == FOURCC_UYVY)
                            {
                            if ((ppdev->fNvActiveFloatingContexts &
                                 NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                (ppdev->NvFloating0UYVYSurfaceMem == psurf_gbl->fpVidMem))
                                {

                                if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_DD_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                                    {
                                    /* Mode switches might occur without warning */
                                    lpDestroySurface->ddRVal = DDERR_SURFACELOST;
                                    goto DESTROY_HANDLED;
                                    }

                                ppdev->fNvActiveFloatingContexts &=
                                ~NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

                                }
                            else if ((ppdev->fNvActiveFloatingContexts &
                                      NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                     (ppdev->NvFloating1UYVYSurfaceMem == psurf_gbl->fpVidMem))
                                {
                                /* Trash spare subchannel */
                                if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_DD_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                                    {
                                    /* Mode switches might occur without warning */
                                    lpDestroySurface->ddRVal = DDERR_SURFACELOST;
                                    goto DESTROY_HANDLED;
                                    }

                                ppdev->fNvActiveFloatingContexts &=
                                ~NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
                                }
                            }
                        else
                            {
                            if ((ppdev->fNvActiveFloatingContexts &
                                 NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                (ppdev->NvFloating0YUYVSurfaceMem == psurf_gbl->fpVidMem))
                                {
                                if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_DD_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                                    {
                                    /* Mode switches might occur without warning */
                                    lpDestroySurface->ddRVal = DDERR_SURFACELOST;
                                    goto DESTROY_HANDLED;
                                    }

                                ppdev->fNvActiveFloatingContexts &=
                                ~NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

                                }
                            else if ((ppdev->fNvActiveFloatingContexts &
                                      NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                     (ppdev->NvFloating1YUYVSurfaceMem == psurf_gbl->fpVidMem))
                                {
                                if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_DD_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                                    {
                                    /* Mode switches might occur without warning */
                                    lpDestroySurface->ddRVal = DDERR_SURFACELOST;
                                    goto DESTROY_HANDLED;
                                    }

                                ppdev->fNvActiveFloatingContexts &=
                                ~NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

                                }
                            }
                        }

                    return(DDHAL_DRIVER_NOTHANDLED);
                    }
                lpDestroySurface->ddRVal = DD_OK;
                goto DESTROY_HANDLED;
                break;

            case FOURCC_YV12:
            case FOURCC_420i:
                if (psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
                    {
                    while (index < NV_MAX_OVERLAY_SURFACES)
                        {
                        if ((DWORD)psurf == ppdev->dwOverlaySurfaceLCL[index])
                            {
                            ppdev->dwOverlaySurfaceLCL[index] = 0;
                            if (ppdev->dwOverlaySurfaces > 0)
                                ppdev->dwOverlaySurfaces--;
                            if (ppdev->dwOverlaySurfaces == 0)
                                {
                                ppdev->dwOverlayOwner = 0;
                                }
                            }
                        index++;
                        }
                    }

                if ((psurf->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
                    (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
                    {
                    if (psurf_gbl->fpVidMem == ppdev->NvFloatingMem2MemFormatBaseAddress)
                        {

                        if (ppdev->NvYUY2Surface0Mem > 0)
                            {
                            NVHEAP_FREE(ppdev->NvYUY2Surface0Mem);
                            ppdev->NvYUY2Surface0Mem = 0;
                            if (ppdev->DDrawVideoSurfaceCount > 0)
                                ppdev->DDrawVideoSurfaceCount--;
                            }

                        if (npDev == NULL)
                            {  /* Mode switches might occur without warning */
                            lpDestroySurface->ddRVal = DDERR_SURFACELOST;
                            goto DESTROY_HANDLED;
                            }
#ifdef SYSMEM_FALLBACK
                        if ((ppdev->NvFloatingMem2MemFormatBaseAddress < (ULONG) ppdev->pjFrameBufbase) || /* If system memory */
                            (ppdev->NvFloatingMem2MemFormatBaseAddress > (ULONG) ppdev->pjFrameBufbase + 0x1000000))
                            {
                            if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_DD_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY) != NVOS00_STATUS_SUCCESS)
                                {
                                /* Mode switches might occur without warning */
                                lpDestroySurface->ddRVal = DDERR_SURFACELOST;
                                goto DESTROY_HANDLED;
                                }
                            }
                        else
#endif // #ifdef SYSMEM_FALLBACK
                            {
                            NVHEAP_FREE(psurf_gbl->fpVidMem);
                            if (ppdev->DDrawVideoSurfaceCount > 0)
                                ppdev->DDrawVideoSurfaceCount--;
                            }

                        ppdev->NvFloatingMem2MemFormatBaseAddress = 0;
                        ppdev->NvFloatingMem2MemFormatNextAddress = 0;

                        }
                    else
                        {
                        if (psurf_gbl->fpVidMem == ppdev->NvFloatingMem2MemFormatNextAddress)
                            {
                            ppdev->NvFloatingMem2MemFormatNextAddress = 0;
                            if (ppdev->NvYUY2Surface1Mem > 0)
                                {
                                NVHEAP_FREE(ppdev->NvYUY2Surface1Mem);
                                ppdev->NvYUY2Surface1Mem = 0;
                                if (ppdev->DDrawVideoSurfaceCount > 0)
                                    ppdev->DDrawVideoSurfaceCount--;
                                }
                            }
                        else
                            {
                            if (ppdev->NvYUY2Surface2Mem > 0)
                                {
                                NVHEAP_FREE(ppdev->NvYUY2Surface2Mem);
                                ppdev->NvYUY2Surface2Mem = 0;
                                if (ppdev->DDrawVideoSurfaceCount > 0)
                                    ppdev->DDrawVideoSurfaceCount--;
                                }
                            }
                        }
                    psurf_gbl->fpVidMem = 0;
                    }
                else if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
                    {
                    if (psurf_gbl->fpVidMem > 0)
                        {
                        NVHEAP_FREE(psurf_gbl->fpVidMem);
                        psurf_gbl->fpVidMem = 0;
                        if (ppdev->DDrawVideoSurfaceCount > 0)
                            ppdev->DDrawVideoSurfaceCount--;
                        }
                    }
                else
                    {
                    return(DDHAL_DRIVER_NOTHANDLED);
                    }
                lpDestroySurface->ddRVal = DD_OK;
                goto DESTROY_HANDLED;
                break;
            }
        }
    else if ((psurf->ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN) &&
             (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
        {
        if (psurf_gbl->fpVidMem > 0)
            {
            NVHEAP_FREE(psurf_gbl->fpVidMem);
            if (ppdev->DDrawVideoSurfaceCount > 0)
                ppdev->DDrawVideoSurfaceCount--;
            psurf_gbl->fpVidMem = 0;
            }
        DPF( "    Offscreen deallocated" );
        lpDestroySurface->ddRVal = DD_OK;
        goto DESTROY_HANDLED;
        }
    else if (psurf->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
        {
        if (psurf_gbl->fpVidMem > 0)
            {
            NVHEAP_FREE(psurf_gbl->fpVidMem);
            if (ppdev->DDrawVideoSurfaceCount > 0)
                ppdev->DDrawVideoSurfaceCount--;
            psurf_gbl->fpVidMem = 0;
            }
        else
            {
            DPF( "    Unspecified Video Memory deallocation not handled");
            return DDHAL_DRIVER_NOTHANDLED;
            }
        DPF( "    Offscreen deallocated" );
        lpDestroySurface->ddRVal = DD_OK;
        goto DESTROY_HANDLED;
        }
    else if (psurf->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
        {
        DPF( "    System memory deallocated" );
        return DDHAL_DRIVER_NOTHANDLED;
        }

    return DDHAL_DRIVER_NOTHANDLED;

DESTROY_HANDLED:
    return DDHAL_DRIVER_HANDLED;

    }

//
// From nv_ref.h - RM guys may some day give a better way to read this
//
#define NV_PBUS_PCI_NV_18                                0x00001848 /* RW-4R */
#define NV_PBUS_PCI_NV_19                                0x0000184C /* RW-4R */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE                8:8 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_FW_ENABLE                 4:4 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE                9:9 /* RWIVF */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_FW                         4:4 /* R--VF */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_SBA                        9:9 /* R--VF */

// search for a particular class in a list of classes
// return TRUE if found, FALSE if not
// (right now this is just a dumb linear search. it could be better...)

static __inline BOOL nvClassListCheck
(
    NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS params,
    DWORD dwClass
)
{
    NvU32 i=0;
    while (i < params.numClasses) {
        if (params.classBuffer[i] == dwClass) {
            return (TRUE);
        }
        i++;
    }
    return (FALSE);
}

//
// nvDeterminePerformanceStrategy
//
// detects HW and use this info together with the CPU info to figure out the best
//  performance strategy. pDriverData->dwDeviceIDNum must be initialized
//
// Note: This was copied and modified from a routine of similar name in nvProf.
//       That routine is highly non-portable.
EXTERN_C BOOL __stdcall nvDeterminePerformanceStrategy_NT4(GLOBALDATA *pDriverData, NV_SystemInfo_t *pSysInfo)
{
    DWORD dwRoot, dwDevID;
    BOOL  bOverride = FALSE;
    DWORD dwWidth;
    DWORD dwNVCLK;
    DWORD dwMCLK;
    DWORD dwGPUMemory;
    DWORD dwCpuClock;
    DWORD dwCpuType;
    DWORD dwFullspeedFW;
    DWORD dwFastWrite;
    DWORD dwBusCaps;
    DWORD dwStrapCaps;
    DWORD dwBase;
    DWORD dwBusType;
    DWORD dwPCIID;
    HANDLE hDriver;
    NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS params;
    DWORD dwSuccess;
    DWORD dwPSOr;
    DWORD dwPSAnd;
    DWORD dwPBSize;
    DWORD dwSBSize;
    DWORD dwCaps;
    DWORD res;
    union
    {
            ULONG osName;
            char devName[NV_DEVICE_NAME_LENGTH_MAX+1];
    } nameBuffer;

    pSysInfo->dwNVClasses      = 0;
    pSysInfo->dwCPUFeatureSet  = 0;
    pSysInfo->dwProcessorSpeed = 0;

    hDriver = (HANDLE) pDriverData->ppdev->hDriver;

    //
    // determine amount of memory present
    //
    // roughly the number of MB of system memory on the machine

//    pSysInfo->dwSystemMemory = (DWORD)((pDriverData->ppdev->SysMemInfo.SystemMemorySize) >> 20);
    // No way to query true amount of system memory on NT4 from disp driver (yet anyway) @mjl@
    pSysInfo->dwSystemMemory = 16;

    // round to the ceiling 8 MB
    pSysInfo->dwSystemMemory = (pSysInfo->dwSystemMemory + 7) & ~7;

    /*
     * determine installed HW
     *
     * at this point ddraw has not been initialized yet so this code is
     *  opening a RM channel for itself to do the detection and then
     *  close it.
     */

    /*
    * Under WINNT, must id the correct device in a  multimon
    * system.
    */

    nameBuffer.osName = pDriverData->ppdev->ulDeviceReference;

    dwDevID = 0xDEAD0001;

    NvOpen(hDriver);

    res = NvAllocRoot(hDriver,NV01_ROOT,&dwRoot);
    if (res != NVOS01_STATUS_SUCCESS) return FALSE;

    res = NvAllocDevice(hDriver, dwRoot, dwDevID, NV01_DEVICE_0, (BYTE*)nameBuffer.devName);
    if (res != NVOS06_STATUS_SUCCESS) return FALSE;

    // get general HW info
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_DAC_INPUT_WIDTH,   &dwWidth);
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_DAC_GRAPHICS_CLOCK,&dwNVCLK);
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_DAC_MEMORY_CLOCK,  &dwMCLK);
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_RAM_SIZE_MB,       &dwGPUMemory);
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_PROCESSOR_SPEED,   &dwCpuClock);
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_PROCESSOR_TYPE,    &dwCpuType);
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_ADDRESS_NVADDR,    &dwBase);
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_AGP_FULLSPEED_FW,  &dwFullspeedFW);
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_AGP_FW_ENABLE,     &dwFastWrite);
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_BUS_TYPE,          &dwBusType);
    NvConfigGet(hDriver, dwRoot, dwDevID, NV_CFG_PCI_ID,            &dwPCIID);

    // get the list of classes this HW supports

    params.numClasses  = 0;
    params.classBuffer = NULL;

    // call to get the number of supported classes
    dwSuccess = NvConfigGetEx (hDriver, dwRoot, dwDevID, NV_CFGEX_GET_SUPPORTED_CLASSES, &params, sizeof(params));
    nvAssert (dwSuccess == NVOS_CGE_STATUS_SUCCESS);

    // allocate and call again to actually get the class list itself
    params.classBuffer   = (NvU32 *)  EngAllocMem( HEAP_ZERO_MEMORY, params.numClasses * sizeof(NvU32), ALLOC_TAG);

    dwSuccess = NvConfigGetEx (hDriver, dwRoot, dwDevID, NV_CFGEX_GET_SUPPORTED_CLASSES, &params, sizeof(params));
    nvAssert (dwSuccess == NVOS_CGE_STATUS_SUCCESS);

    // parse the class list
    if (nvClassListCheck (params, 0x0055))  pSysInfo->dwNVClasses |= NVCLASS_0055_DX6TRI;
    if (nvClassListCheck (params, 0x0095))  pSysInfo->dwNVClasses |= NVCLASS_0095_DX6TRI;

    if (nvClassListCheck (params, 0x0054))  pSysInfo->dwNVClasses |= NVCLASS_0054_DX5TRI;
    if (nvClassListCheck (params, 0x0094))  pSysInfo->dwNVClasses |= NVCLASS_0094_DX5TRI;

    if (nvClassListCheck (params, 0x0056))  pSysInfo->dwNVClasses |= NVCLASS_0056_CELSIUS;
    if (nvClassListCheck (params, 0x0096))  pSysInfo->dwNVClasses |= NVCLASS_0096_CELSIUS;
    if (nvClassListCheck (params, 0x1196))  pSysInfo->dwNVClasses |= NVCLASS_1196_CELSIUS;

    if (nvClassListCheck (params, 0x0097))  pSysInfo->dwNVClasses |= NVCLASS_0097_KELVIN;

    if (nvClassListCheck (params, 0x0046))  pSysInfo->dwNVClasses |= NVCLASS_0046_DAC;
    if (nvClassListCheck (params, 0x0049))  pSysInfo->dwNVClasses |= NVCLASS_0049_DAC;
    if (nvClassListCheck (params, 0x0067))  pSysInfo->dwNVClasses |= NVCLASS_0067_DAC;
    if (nvClassListCheck (params, 0x007C))  pSysInfo->dwNVClasses |= NVCLASS_007C_DAC;

    if (nvClassListCheck (params, 0x0042))  pSysInfo->dwNVClasses |= NVCLASS_0042_CTXSURF2D;
    if (nvClassListCheck (params, 0x0062))  pSysInfo->dwNVClasses |= NVCLASS_0062_CTXSURF2D;

    if (nvClassListCheck (params, 0x0060))  pSysInfo->dwNVClasses |= NVCLASS_0060_IDXIMAGE;
    if (nvClassListCheck (params, 0x0064))  pSysInfo->dwNVClasses |= NVCLASS_0064_IDXIMAGE;

    if (nvClassListCheck (params, 0x0077))  pSysInfo->dwNVClasses |= NVCLASS_0077_SCALEDIMG;
    if (nvClassListCheck (params, 0x0063))  pSysInfo->dwNVClasses |= NVCLASS_0063_SCALEDIMG;
    if (nvClassListCheck (params, 0x0089))  pSysInfo->dwNVClasses |= NVCLASS_0089_SCALEDIMG;

    if (nvClassListCheck (params, 0x0038))  pSysInfo->dwNVClasses |= NVCLASS_0038_DVDPICT;
    if (nvClassListCheck (params, 0x0088))  pSysInfo->dwNVClasses |= NVCLASS_0088_DVDPICT;

    if (nvClassListCheck (params, 0x007A))  pSysInfo->dwNVClasses |= NVCLASS_007A_OVERLAY;

    if (nvClassListCheck (params, 0x0053))  pSysInfo->dwNVClasses |= NVCLASS_0053_CTXSURF3D;
    if (nvClassListCheck (params, 0x0093))  pSysInfo->dwNVClasses |= NVCLASS_0093_CTXSURF3D;

    if (nvClassListCheck (params, 0x004A))  pSysInfo->dwNVClasses |= NVCLASS_004A_GDIRECT;
    if (nvClassListCheck (params, 0x005E))  pSysInfo->dwNVClasses |= NVCLASS_005E_SOLIDRECT;

    if (nvClassListCheck (params, 0x0052))  pSysInfo->dwNVClasses |= NVCLASS_0052_CTXSURFSWZ;
    if (nvClassListCheck (params, 0x009E))  pSysInfo->dwNVClasses |= NVCLASS_009E_CTXSURFSWZ;

    if (nvClassListCheck (params, 0x0004))  pSysInfo->dwNVClasses |= NVCLASS_0004_TIMER;

    if (nvClassListCheck (params, 0x006C))  pSysInfo->dwNVClasses1 |= NVCLASS1_006C_CHANNELDMA;
    if (nvClassListCheck (params, 0x006E))  pSysInfo->dwNVClasses1 |= NVCLASS1_006E_CHANNELDMA;
    if (nvClassListCheck (params, 0x206E))  pSysInfo->dwNVClasses1 |= NVCLASS1_206E_CHANNELDMA;

    // free the dynamically allocated list
    EngFreeMem(params.classBuffer);

    dwNVCLK = (dwNVCLK + 500000) / 1000000;
    dwMCLK  = (dwMCLK  + 500000) / 1000000;

    // disconnect
    {
        DWORD res;
        res = NvFree (hDriver, dwRoot, NV01_NULL_OBJECT, dwRoot);
        if (res != NVOS00_STATUS_SUCCESS) return FALSE;
    }
    NvClose(hDriver);

    dwStrapCaps = *(DWORD*)(dwBase + NV_PBUS_PCI_NV_18);
    dwBusCaps   = *(DWORD*)(dwBase + NV_PBUS_PCI_NV_19);

    //
    // override
    //
#ifdef FORCE_NV10_AS_NV5
    pSysInfo->dwNVClasses &= ~(NVCLASS_0056_CELSIUS |
                                                NVCLASS_0096_CELSIUS |
                                                NVCLASS_1196_CELSIUS);
#endif

#ifdef SPOOF_KELVIN
    pSysInfo->dwNVClasses |= NVCLASS_0097_KELVIN;
#endif

    //
    // map cpu onto feature flags
    //
    pSysInfo->dwProcessorSpeed = dwCpuClock;
    if (dwCpuType & NV_CPU_FUNC_MMX)     pSysInfo->dwCPUFeatureSet |= FS_MMX;
    if (dwCpuType & NV_CPU_FUNC_SSE)     pSysInfo->dwCPUFeatureSet |= FS_KATMAI;
    if (dwCpuType & NV_CPU_FUNC_SSE2)    pSysInfo->dwCPUFeatureSet |= FS_WILLAMETTE;
    if (dwCpuType & NV_CPU_FUNC_3DNOW)   pSysInfo->dwCPUFeatureSet |= FS_3DNOW;
    if (dwCpuType & NV_CPU_FUNC_SFENCE)  pSysInfo->dwCPUFeatureSet |= FS_SFENCE;
    if ((dwCpuType & 0xff) == NV_CPU_K7) pSysInfo->dwCPUFeatureSet |= FS_ATHLON;

    if ((pSysInfo->dwCPUFeatureSet & FS_KATMAI) ||
        (pSysInfo->dwCPUFeatureSet & FS_WILLAMETTE) ||
        (pSysInfo->dwCPUFeatureSet & FS_ATHLON))
    {
        pSysInfo->dwCPUFeatureSet |= FS_PREFETCH;
    }

    // See if this is a PCI bus interface
    if (dwBusType == 1)
    {
        pSysInfo->dwCPUFeatureSet |= FS_PCIBUS;
    }

    //
    // map misc flags
    //
    // fast writes
    if (dwFastWrite && dwFullspeedFW)   pSysInfo->dwCPUFeatureSet |= FS_FULLFASTWRITE;
    if (dwFastWrite && !dwFullspeedFW)  pSysInfo->dwCPUFeatureSet |= FS_HALFFASTWRITE;
    // detect low back end bus
    if (dwWidth == 64)                  pSysInfo->dwCPUFeatureSet |= FS_64BIT;

    //
    // determine strategy...
    //
    dwPSOr  =  0;
    dwPSAnd = ~0;
    {
        BOOL bFastMachine      = pSysInfo->dwProcessorSpeed >= 390;
        BOOL bRealFastMachine  = pSysInfo->dwProcessorSpeed >= 650; //650
        BOOL bSuperFastBackEnd = dwMCLK >= 300;
        // bFastBackEnd should only be FALSE on VANTA
        BOOL bFastBackEnd      = !(pSysInfo->dwCPUFeatureSet & FS_64BIT)
                               || (dwMCLK > 200);
        BOOL bHalfFastWrites   = pSysInfo->dwCPUFeatureSet & FS_HALFFASTWRITE;
        BOOL bFullFastWrites   = pSysInfo->dwCPUFeatureSet & FS_FULLFASTWRITE;
        BOOL bHasAGP           = dwBusCaps & (1 << (0 ? NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE));

        //
        // slow back end
        //
        if (!bFastBackEnd)
        {
            if (bFastMachine) pSysInfo->dwPerformanceStrategy = PS_CONTROL_TRAFFIC_16 |
                                                                                 PS_CONTROL_TRAFFIC_32 |
                                                                                 PS_TEXTURE_RENAME     |
                                                                                 PS_TEXTURE_PREFER_AGP;
                         else pSysInfo->dwPerformanceStrategy = PS_CONTROL_TRAFFIC_16 |
                                                                                 PS_CONTROL_TRAFFIC_32 |
                                                                                 PS_TEXTURE_USEHW;
        }
#if 0 // (NVARCH >= 0x020)
        else if (pSysInfo->dwNVClasses & NVCLASS_FAMILY_KELVIN)
        {
            // put stuff here
        }
#endif
        else if (pSysInfo->dwNVClasses & NVCLASS_FAMILY_CELSIUS)
        {
            // decide who does what
            pSysInfo->dwPerformanceStrategy = PS_TEXTURE_RENAME | PS_TEXTURE_USEHW;
            // decide where to put stuff
            switch ((bFullFastWrites   ? 4 : 0)
                  | (bHalfFastWrites   ? 2 : 0)
                  | (bSuperFastBackEnd ? 1 : 0))
            {
                case 0: // !FW, !SF   - bx, SDR
                        pSysInfo->dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pSysInfo->dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
                case 1: // !FW,  SF   - bx, DDR
                        pSysInfo->dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pSysInfo->dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
                case 2: //  1/2 FW, !SF   - camino, SDR
                        pSysInfo->dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pSysInfo->dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
                case 3: //  1/2 FW,  SF   - camino, DDR
                        pSysInfo->dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pSysInfo->dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
                case 6: //  FW, !SF   - camino, SDR
                        pSysInfo->dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pSysInfo->dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
                case 7: //  FW,  SF   - camino, DDR (we have not experimentd with this one yet - be conservative)
                        pSysInfo->dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pSysInfo->dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
            }

            if (pSysInfo->dwCPUFeatureSet & FS_PCIBUS)
            {
                // PCI bus interface -- don't prefer AGP!
                pSysInfo->dwPerformanceStrategy &=  ~PS_VB_PREFER_AGP;
            }

            // should we use auto-palettes?
            if (pSysInfo->dwNVClasses & NVCLASS_FAMILY_CELSIUS)
            {
                pSysInfo->dwPerformanceStrategy |= PS_AUTOPALETTE;
            }

            //camino (i.e. FW's) do 32 bit perf strategy.
            if ((pSysInfo->dwNVClasses & NVCLASS_1196_CELSIUS)
             || (pSysInfo->dwNVClasses & NVCLASS_0096_CELSIUS)) {
                pSysInfo->dwPerformanceStrategy |= PS_CONTROL_TRAFFIC_32;
                pSysInfo->dwPerformanceStrategy |= PS_CONTROL_TRAFFIC_16;
            }

            if (pSysInfo->dwNVClasses & NVCLASS_FAMILY_KELVIN)
            {
                // No CT for Kelvin
                pSysInfo->dwPerformanceStrategy &= ~(PS_CONTROL_TRAFFIC_16 | PS_CONTROL_TRAFFIC_32);
            }

            // should we do super triangles?
#ifdef SUPERTRI
           if (bRealFastMachine
              && ((pSysInfo->dwCPUFeatureSet & FS_KATMAI)
                    || (pSysInfo->dwCPUFeatureSet & FS_WILLAMETTE)
                    || (pSysInfo->dwCPUFeatureSet & FS_ATHLON)))
            {
                pSysInfo->dwPerformanceStrategy |= (PS_SUPERTRI | PS_ST_XFORMCLIP | PS_ST_MODEL);

                // TODO: Add transformation and clip code for Athlon
                if (pSysInfo->dwCPUFeatureSet & FS_ATHLON)
                    pSysInfo->dwPerformanceStrategy &= ~PS_ST_XFORMCLIP;
            }
#endif
        }
        // ben BUGBUG
        // this is ugly. we infer nv4 vs. nv5 based on the DAC object. philosophically, this is illegal.
        else if (pSysInfo->dwNVClasses & NVCLASS_0049_DAC)
        {
            if (bFastMachine) pSysInfo->dwPerformanceStrategy = PS_CONTROL_TRAFFIC_32 | PS_TEXTURE_RENAME;
                         else pSysInfo->dwPerformanceStrategy = PS_CONTROL_TRAFFIC_32 | PS_TEXTURE_USEHW;
        }
        else
        {
            if (bFastMachine) pSysInfo->dwPerformanceStrategy = PS_CONTROL_TRAFFIC_16 |
                                                                                 PS_CONTROL_TRAFFIC_32 |
                                                                                 PS_TEXTURE_RENAME     |
                                                                                 PS_TEXTURE_PREFER_AGP;
                         else pSysInfo->dwPerformanceStrategy = PS_CONTROL_TRAFFIC_16 |
                                                                                 PS_CONTROL_TRAFFIC_32 |
                                                                                 PS_TEXTURE_USEHW;
        }

#ifdef FORCE_CT
#if FORCE_CT
    pSysInfo->dwPerformanceStrategy |= PS_CONTROL_TRAFFIC_32;
    pSysInfo->dwPerformanceStrategy |= PS_CONTROL_TRAFFIC_16;
#else
    pSysInfo->dwPerformanceStrategy &= ~PS_CONTROL_TRAFFIC_32;
    pSysInfo->dwPerformanceStrategy &= ~PS_CONTROL_TRAFFIC_16;
#endif
#endif 

    }

/*
    pSysInfo->dwPerformanceStrategy = (1 ? PS_TEXTURE_RENAME     : 0)
                                 | (0 ? PS_TEXTURE_USEHW      : 0)
                                 | (1 ? PS_TEXTURE_PREFER_AGP : 0)
                                 | (1 ? PS_CONTROL_TRAFFIC_16 : 0)
                                 | (1 ? PS_CONTROL_TRAFFIC_32 : 0);
//*/

#define SIZE_VIDMEM_PUSH_BUFFER         (1.0f /  32.0f)     // of total vid mem
#define SIZE_VIDMEM_STAGE_BUFFER        (2.0f /  32.0f)     // of total vid mem

#define SIZE_SYSMEM_PUSH_BUFFER         (2.0f / 128.0f)     // of total sys mem (buffer lives in PCI or AGP)
#define SIZE_SYSMEM_STAGE_BUFFER        (4.0f / 128.0f)     // of total sys mem (buffer lives in PCI or AGP)


    if (pSysInfo->dwPerformanceStrategy & PS_PUSH_VID) // buffers in video memory
    {
        dwPBSize = (DWORD)(1024.0f * 1024.0f * dwGPUMemory * SIZE_VIDMEM_PUSH_BUFFER);
        dwSBSize = (DWORD)(1024.0f * 1024.0f * dwGPUMemory * SIZE_VIDMEM_STAGE_BUFFER);
    }
    else // buffers in AGP or PCI memory
    {
        // base AGP buffer sizes on aperture or memory size, depending on their relative sizes
        DWORD dwMem = pSysInfo->dwSystemMemory;
        dwPBSize = (DWORD)(1024.0f * 1024.0f * dwMem * SIZE_SYSMEM_PUSH_BUFFER);
    }

    dwPBSize = max(dwPBSize, 128 * 1024); // must be at least 128K

    dwPBSize = (dwPBSize + 4095) & ~4095; // 4K align

    // limit maximum size of push buffer
    dwPBSize = min(dwPBSize, 8 * 1024 * 1024); // 8MB max

    pSysInfo->dwRecommendedPushBufferSize  = dwPBSize;

#define PRINT
#if defined(DEBUG) || defined(PRINT)
    {
        static BOOL bPrintedThisBefore = FALSE;

        if (!bPrintedThisBefore)
        {
            char szString[128];

            PF (" NV: classes=%08x %d/%d RAM=%dMB bus=%d", pSysInfo->dwNVClasses,dwNVCLK,dwMCLK,dwGPUMemory,dwWidth);
            PF ("CPU: FS=%08x %dMHz", pSysInfo->dwCPUFeatureSet, pSysInfo->dwProcessorSpeed);

            {
                BOOL  bAGP   = dwBusCaps & (1 << (0 ? NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE));
                DWORD dwRate = dwBusCaps ? (dwBusCaps & 7) : 0;
                BOOL  bSBA   = dwBusCaps & (1 << (0 ? NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE));
                BOOL  bFW    = dwBusCaps & (1 << (0 ? NV_PBUS_PCI_NV_19_AGP_COMMAND_FW_ENABLE));

                PF (" BC: AGP=%dx, SBA=%d, HFW=%d, SSFW=%d, SFFW=%d",
                     bAGP ? dwRate : 0,
                     bSBA ? 1 : 0,
                     bFW ? 1 : 0,
                     (pSysInfo->dwCPUFeatureSet & FS_HALFFASTWRITE) ? 1 : 0,
                     (pSysInfo->dwCPUFeatureSet & FS_FULLFASTWRITE) ? 1 : 0);
            }
            {
                DWORD dwRate = dwStrapCaps ? (dwStrapCaps & 7) : 0;
                BOOL  bSBA   = dwStrapCaps & (1 << (0 ? NV_PBUS_PCI_NV_18_AGP_STATUS_SBA));
                BOOL  bFW    = dwStrapCaps & (1 << (0 ? NV_PBUS_PCI_NV_18_AGP_STATUS_FW));

                PF (" SC: AGP=%s%s%s%s, SBA=%d, FW=%d",
                     (dwRate & 4) ? "4" : "",
                     (dwRate & 2) ? "2" : "",
                     (dwRate & 1) ? "1" : "",
                     (dwRate & 7) ? "x" : "n/a",
                     bSBA ? 1 : 0,
                     bFW ? 1 : 0);
            }

            PF (" PS: %08x", pSysInfo->dwPerformanceStrategy);

            nvStrCpy (szString, "     ");
            if (pSysInfo->dwPerformanceStrategy & PS_TEXTURE_RENAME)     nvStrCat (szString, "texRn ");
            if (pSysInfo->dwPerformanceStrategy & PS_TEXTURE_USEHW)      nvStrCat (szString, "texHW ");
            if (pSysInfo->dwPerformanceStrategy & PS_TEXTURE_PREFER_AGP) nvStrCat (szString, "texAGP ");
            if (pSysInfo->dwPerformanceStrategy & PS_CONTROL_TRAFFIC_16) nvStrCat (szString, "ct16 ");
            if (pSysInfo->dwPerformanceStrategy & PS_CONTROL_TRAFFIC_32) nvStrCat (szString, "ct32 ");
            if (pSysInfo->dwPerformanceStrategy & PS_VB_RENAME)          nvStrCat (szString, "vbRn ");
            if (pSysInfo->dwPerformanceStrategy & PS_VB_PREFER_AGP)      nvStrCat (szString, "vbAGP ");
            if (pSysInfo->dwPerformanceStrategy & PS_PUSH_VID)           nvStrCat (szString, "pushVID ");
            if (pSysInfo->dwPerformanceStrategy & PS_SUPERTRI)           nvStrCat (szString, "supTri ");
            PF (szString);

            if (bOverride) {
                PF ("     * PS set from registry");
            }

            bPrintedThisBefore = TRUE;
        }
    }
#endif

    // calibrate delay loop
   //    assume cpuid capable
    __asm
    {
        push    eax
        push    ebx
        push    ecx
        push    edx
        mov eax,1

        _emit 0x0f //    __asm cpuid - not known to compiler used for NT4 build
        _emit 0xa2 

        mov [dwCaps],edx
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }
    if (dwCaps & 0x10) // rdtsc capable
    {
        __int64 qwStart;
        __int64 qwStop;

        nvSpin(10000);
        nvSpin(10000);

        __asm
        {
            push    eax
            push    edx

            _emit 0x0f //    __asm rdtsc - not known to compiler used for NT4 build
            _emit 0x31 

            mov DWORD PTR [qwStart + 0],eax
            mov DWORD PTR [qwStart + 4],edx

            pop     edx
            pop     eax
        }
        nvSpin(10000);
        __asm
        {
            push    eax
            push    edx

            _emit 0x0f //    __asm rdtsc - not known to compiler used for NT4 build
            _emit 0x31 

            mov DWORD PTR [qwStop + 0],eax
            mov DWORD PTR [qwStop + 4],edx

            pop     edx
            pop     eax

            // 3DMark 2000 leaves the floating point stack full of garbage
            // which causes the 3rd FILD below to fail resulting in a global.dwDelayCount of 0 and
            // ultimately causing the driver to hang
            // (perhaps they use MMX instructions)
            // clearing the MMX state here solves the problem
        }

        // this used to cause a fault on non-MMX machines.  Have to check for MMX before using
        // EMMS
        if (pSysInfo->dwCPUFeatureSet & FS_MMX)
        {
            __asm emms
        }

        // set delay to 10us
        double time = (double)(qwStop - qwStart) / 10000.0;
        time /= (double) pSysInfo->dwProcessorSpeed;
        pSysInfo->dwSpinLoopCount = (unsigned long) (10.0 / time);
    }
    else
    {
        // for non tsc machines we just assign a hard value for the delay loop
        pSysInfo->dwSpinLoopCount = pSysInfo->dwProcessorSpeed * 4;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\blt8.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995,1997 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       Nv4Blt8.c
 *  Content:    Windows95 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"
#include "nvalpha.h"

#include "ddminint.h"
#include "nv32.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "nvsubch.h"

#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free

/*
 * Nv4Blt8
 *
 * Blt function for 8bpp surfaces.
 */
DWORD __stdcall Nv4Blt8( PDD_BLTDATA pbd )
    {
    FAST Nv3ChannelPio *npDev;
    FAST USHORT freeCount;
    DWORD       dwFlags;
    DWORD       dwDDFX = 0;
    DWORD       dwDstCaps;
    DWORD       dwSrcCaps;
    DWORD       dwRop;
    NVCOORD     wXYext;
    NVCOORD     wDestXY;
    NVCOORD     wSrcXY;
    BYTE        wStretch = 0;
    BYTE        doMirrorUpDown = 0;
    BYTE        isVideo = 0;

    DWORD       dwFillColor;
    DWORD       dwColorKey;

    DWORD       dwDstOffset;
    DWORD       dwDstPitch;
    DWORD       dwDstWidth;
    DWORD       dwDstHeight;

    DWORD       dwSrcOffset;
    DWORD       dwSrcPitch;
    DWORD       dwSrcWidth;
    DWORD       dwSrcHeight;

    PDD_SURFACE_LOCAL  srcx;
    PDD_SURFACE_LOCAL  dstx;
    PDD_SURFACE_GLOBAL  src;
    PDD_SURFACE_GLOBAL  dst;

    PDEV   *ppdev;

    ppdev = (PDEV *) pbd->lpDD->dhpdev;
    dstx = pbd->lpDDDestSurface;
    dst = dstx->lpGbl;
    /*
     * NOTES:
     *
     * Everything you need is in pdb->bltFX .
     * Look at pdb->dwFlags to determine what kind of blt you are doing,
     * DDBLT_xxxx are the flags.
     *
     * ALPHA NOTES:
     *
     * Alpha ALWAYS comes in BLTFX.   You don't need to go looking for
     * the attached surface. If DDBLT_ALPHA is specified, then either a
     * constant alpha or alpha surface has been specified. Just look for
     * DDBLT_ALPHASURFACEOVERRIDE or DDBLT_ALPHACONSTANTOVERRIDE
     *
     * Look for DDBLT_ALPHASURFACEDESTRECT to use the destination rectangle
     * for choosing the rectangle in the alpha surface.   Otherwise use the
     * source rectangle.
     *
     * Z BUFFER NOTES:
     *
     * ZBuffer ALWAYS comes in BLTFX.   You don't need to go looking for
     * the attached surface. If DDBLT_ZBUFFER is specified, then either a
     * constant z or z buffer surface has been specified for the source and
     * destination. Just look for the DDBLT_ZBUFFERDESTOVERRIDE,
     * DDBLT_ZBUFFERSRCOVERRIDE, DDBLT_ZBUFFERCONSTANTDESTOVERRIDE, or
     * DDBLT_ZBUFFERCONSTANTSRCOVERRIDE.
     *
     * COLORKEY NOTES:
     *
     * ColorKey ALWAYS comes in BLTFX.   You don't have to look it up in
     * the surface.
     */

    dwFlags   = pbd->dwFlags;
    dwDstCaps = dstx->ddsCaps.dwCaps;

    if (dwFlags & DDBLT_DDFX)
        dwDDFX = pbd->bltFX.dwDDFX;

//    if (dwFlags & DDOVER_ANYALPHA) {
//        DPF("OVERLAY ALPHA FAILED");
//        pbd->ddRVal = DDERR_NOOVERLAYHW;
//        return DDHAL_DRIVER_HANDLED;
//    }

//    if (dwFlags & DDBLT_ANYALPHA) {
//        DPF("ALPHA ON 8BPP SURFACE FAILED");
//        pbd->ddRVal = DDERR_NOALPHAHW;
//        return DDHAL_DRIVER_HANDLED;
//    }

    if (dwFlags & (DDBLT_KEYDEST | DDBLT_KEYDESTOVERRIDE))
        {
        DPF("DEST COLOR KEY FAILED");
        pbd->ddRVal = DDERR_NOCOLORKEYHW;
        return DDHAL_DRIVER_HANDLED;
        }

    /*
     * get offset, width, and height for destination
     */
    dwDstOffset = dst->fpVidMem;
    dwDstPitch  = dst->lPitch;
    dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
    dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;
    wXYext.wh16.w = (unsigned short)dwDstWidth;
    wXYext.wh16.h = (unsigned short)dwDstHeight;

    wDestXY.xy16.x = (short)pbd->rDest.left;
    wDestXY.xy16.y = (short)pbd->rDest.top;

    if (dwDstCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_TEXTURE | DDSCAPS_NONLOCALVIDMEM))
        return DDHAL_DRIVER_NOTHANDLED;

    npDev = (Nv3ChannelPio *) ppdev->pjMmBase;

    if (npDev == NULL)
        {
        pbd->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
        }

    freeCount = ppdev->NVFreeCount;

    /*
     * If async, then only work if bltter isn't busy
     * This should probably be a little more specific to each call, but
     * waiting for 32 is pretty close
     */
    if (dwFlags & DDBLT_ASYNC )
        {
        if (freeCount < 32)
            freeCount = NvGetFreeCount(npDev, NV_DD_ROP);

        if ( freeCount < 32 )
            {
            DPF("ASYNC FAILED");
            pbd->ddRVal = DDERR_WASSTILLDRAWING;
            ppdev->NVFreeCount = freeCount;
            return DDHAL_DRIVER_HANDLED;
            }
        }

    if (dwFlags & DDBLT_ROP)
        {
        dwRop = pbd->bltFX.dwROP >> 16;

        if ((dwRop == BLACKNESSINDEX) || (dwRop == WHITENESSINDEX))
            {

            while (freeCount < 7*4)
                freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
            freeCount -= 7*4;

            npDev->dDrawRop.SetRop5 = dwRop;
            npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetSource =
                dwDstOffset;

            npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetDestin =
                dwDstOffset;

            npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetPitch = dwDstPitch;

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.Color1A = 0;

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].point =
            asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].size =
            asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            }
        else if ((dwRop == PATCOPYINDEX) || (dwRop == PATINVERTINDEX))
            {

            dwFillColor = (pbd->bltFX.dwFillColor & ppdev->physicalColorMask) | ppdev->AlphaEnableValue;

            if (dwRop == PATCOPYINDEX)
                dwRop = SRCCOPYINDEX;
            else if (dwRop == PATINVERTINDEX)
                dwRop = SRCINVERTINDEX;

            ppdev->NVFreeCount = freeCount;
            DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
            freeCount = ppdev->NVFreeCount;

            while (freeCount < 4*4)
                freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
            freeCount -= 4*4;

            npDev->dDrawRop.SetRop5 = dwRop;

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.Color1A = dwFillColor;

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].point =
            asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].size =
            asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            }
        else if ((dwRop == SRCCOPYINDEX) || (dwRop == SRCPAINTINDEX) ||
                 (dwRop == SRCANDINDEX) || (dwRop == NOTSRCCOPYINDEX) ||
                 (dwRop == SRCINVERTINDEX) || (dwRop == MERGEPAINTINDEX) ||
                 (dwRop == SRCERASEINDEX) || (dwRop == NOTSRCERASEINDEX))
            {

            srcx = pbd->lpDDSrcSurface;
            src = srcx->lpGbl;

            dwSrcCaps = srcx->ddsCaps.dwCaps;

            /* We must treat AGP source memory as system memory */
            if (dwSrcCaps & DDSCAPS_NONLOCALVIDMEM)
                {
                dwSrcCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
                }

            dwSrcOffset = src->fpVidMem;
            dwSrcPitch  = src->lPitch;
            dwSrcWidth  = pbd->rSrc.right  - pbd->rSrc.left;
            dwSrcHeight = pbd->rSrc.bottom - pbd->rSrc.top;
            dwColorKey  = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

            wSrcXY.xy16.x = (short)pbd->rSrc.left;
            wSrcXY.xy16.y = (short)pbd->rSrc.top;

            /* We don't handle FOURCC_RGB0 format in 8bpp mode */
            if (//(srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                (src->ddpfSurface.dwFlags & DDPF_FOURCC))
                {

                if (src->ddpfSurface.dwFourCC == FOURCC_RGB0)
                    {
                    if ((src->ddpfSurface.dwRBitMask == 0) &&
                        (src->ddpfSurface.dwGBitMask == 0) &&
                        (src->ddpfSurface.dwBBitMask == 0))
                        {
                        if (dwSrcCaps & DDSCAPS_SYSTEMMEMORY)
                            isVideo = 1;
                        goto srcRGB;
                        }
                    else
                        {
                        pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }
                    }
                pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                ppdev->NVFreeCount = freeCount;
                return DDHAL_DRIVER_HANDLED;
                }

            srcRGB:     if (dwDDFX & DDBLTFX_MIRRORUPDOWN)
                doMirrorUpDown = 1;

            if ((dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight))
                {
                wStretch = 1;
                }

            if (dwFlags & DDBLT_KEYSRCOVERRIDE)
                {

                dwColorKey = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

                while (freeCount < 2*4)
                    freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                freeCount -= 2*4;

                if (ppdev->dDrawSpareSubchannelObject != NV_DD_IMAGE_SOLID)
                    {
                    ppdev->dDrawSpareSubchannelObject = NV_DD_IMAGE_SOLID;
                    npDev->dDrawSpare.SetObject = NV_DD_IMAGE_SOLID;
                    }

                // load and enable chroma key
                npDev->dDrawTransColor.SetColor =
                (dwColorKey & ppdev->physicalColorMask) | NV_ALPHA_1_08;
                }

            // screen to screen bitblt
            if (wStretch == 0)
                {

                if ((dwDstCaps & DDSCAPS_VIDEOMEMORY) &&
                    (dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                    ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                    (doMirrorUpDown == 0) &&
                    (isVideo == 0))
                    {


                    ppdev->NVFreeCount = freeCount;
                    DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
                    DDRAW_SET_SOURCE(ppdev, dwSrcOffset, dwSrcPitch);

                    freeCount = ppdev->NVFreeCount;
                    while (freeCount < 4*4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                    freeCount -= 4*4;

                    npDev->dDrawRop.SetRop5 = dwRop;

                    npDev->dDrawBlit.ControlPointIn = wSrcXY.xy;
                    npDev->dDrawBlit.ControlPointOut = wDestXY.xy;
                    npDev->dDrawBlit.Size = wXYext.wh;

                    }
                else
                    {
                    // memory to screen blt (src may be in system memory or in video memory)
                    unsigned long temp;
                    long srcScanLength;
                    long nxtSrcScan;
                    short n = wXYext.wh16.h;
                    FAST short pxlCount;
                    unsigned short srcOffset;
                    unsigned char *pSrcInitBits;

                    pSrcInitBits = (unsigned char *) src->fpVidMem;
                    if (dwSrcCaps & DDSCAPS_VIDEOMEMORY)
                        pSrcInitBits += (ULONG) ppdev->pjFrameBufbase;

                    srcScanLength = src->lPitch;

                    if (doMirrorUpDown)
                        wSrcXY.xy16.y += (short)(n - 1);

                    pSrcInitBits += (wSrcXY.xy16.y * srcScanLength);

                    srcOffset = wSrcXY.xy16.x & 3;

                    temp = ((wXYext.wh16.w + srcOffset + 3) & 0xFFFC);

                    nxtSrcScan = srcScanLength - temp;

                    if (doMirrorUpDown)
                        nxtSrcScan = -srcScanLength - temp;

                    pSrcInitBits += (wSrcXY.xy16.x & 0xFFFC);

                    ppdev->NVFreeCount = freeCount;
                    DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
                    freeCount = ppdev->NVFreeCount;

                    while (freeCount < 24)
                        freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                    freeCount -= 24;

                    // changing canvas clip avoids manually aligning 8-bit source
                    npDev->subchannel[NV_DD_CLIP].Nv01ContextClipRectangle.SetPoint =
                    wDestXY.xy;
                    npDev->subchannel[NV_DD_CLIP].Nv01ContextClipRectangle.SetSize =
                    wXYext.wh;

                    npDev->dDrawRop.SetRop5 = dwRop;

                    /* compiler screws up this expression when it goes negative in following macro */
                    temp = wDestXY.xy16.x - srcOffset;

                    npDev->dDrawImageFromCpu.Point =
                    asmMergeCoords(temp, wDestXY.xy16.y);
                    npDev->dDrawImageFromCpu.SizeOut =
                    asmMergeCoords(wXYext.wh16.w + srcOffset, wXYext.wh16.h);

                    temp = ((wXYext.wh16.w + srcOffset + 3) & 0xFFFC);

                    npDev->dDrawImageFromCpu.SizeIn =
                    asmMergeCoords(temp, wXYext.wh16.h);

                    {
                        FAST unsigned char *pSrcBits = pSrcInitBits;
                        FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                        while (--n >= 0)
                            {
                            pxlCount = (short)temp;

                            while (pxlCount >= 32)
                                {
                                pxlCount -= 32;

                                while (freeCount < 32)
                                    freeCount = NvGetFreeCount(npDev, NV_DD_IMAGE);
                                freeCount -= 32;

                                tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                tmpPxls1 = *(unsigned long *)&pSrcBits[4];
                                npDev->dDrawImageFromCpu.Color[0] = tmpPxls0;
                                tmpPxls2 = *(unsigned long *)&pSrcBits[8];
                                npDev->dDrawImageFromCpu.Color[1] = tmpPxls1;
                                tmpPxls0 = *(unsigned long *)&pSrcBits[12];
                                tmpPxls1 = *(unsigned long *)&pSrcBits[16];
                                npDev->dDrawImageFromCpu.Color[2] = tmpPxls2;
                                npDev->dDrawImageFromCpu.Color[3] = tmpPxls0;
                                tmpPxls2 = *(unsigned long *)&pSrcBits[20];
                                tmpPxls0 = *(unsigned long *)&pSrcBits[24];
                                npDev->dDrawImageFromCpu.Color[4] = tmpPxls1;
                                npDev->dDrawImageFromCpu.Color[5] = tmpPxls2;
                                tmpPxls1 = *(unsigned long *)&pSrcBits[28];
                                npDev->dDrawImageFromCpu.Color[6] = tmpPxls0;
                                pSrcBits += 32;
                                npDev->dDrawImageFromCpu.Color[7] = tmpPxls1;
                                }

                            if (pxlCount > 0)
                                {
                                while (freeCount < 32)
                                    freeCount = NvGetFreeCount(npDev, NV_DD_IMAGE);

                                while (pxlCount >= 8)
                                    {
                                    tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                    tmpPxls1 = *(unsigned long *)&pSrcBits[4];
                                    pxlCount -= 8;
                                    freeCount -= 8;
                                    npDev->dDrawImageFromCpu.Color[0] = tmpPxls0;
                                    npDev->dDrawImageFromCpu.Color[1] = tmpPxls1;
                                    pSrcBits += 8;
                                    }

                                if (pxlCount > 0)
                                    {
                                    tmpPxls0 = *(unsigned long *)&pSrcBits[0];
                                    freeCount -= 4;
                                    pxlCount -= 4;
                                    pSrcBits += 4;
                                    npDev->dDrawImageFromCpu.Color[0] = tmpPxls0;
                                    if (pxlCount > 0)
                                        {
                                        tmpPxls1 = *(unsigned long *)&pSrcBits[0];
                                        npDev->dDrawImageFromCpu.Color[0] = tmpPxls1;
                                        pSrcBits += 4;
                                        freeCount -= 4;
                                        }
                                    }
                                }
                            pSrcBits += nxtSrcScan;
                            }
                    }

                    while (freeCount < 8)
                        freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                    freeCount -= 8;

                    // restore canvas clip to something not likely to interfere with rendering
                    npDev->subchannel[NV_DD_CLIP].Nv01ContextClipRectangle.SetPoint =
                    0;
                    npDev->subchannel[NV_DD_CLIP].Nv01ContextClipRectangle.SetSize =
                    asmMergeCoords(ppdev->cxScreen,
                                   ppdev->cyScreen);
                    }
                }
            else
                { // stretch
                DWORD dwStatus;
                NvNotification *pDmaToMemNotifier;
                unsigned char *pScanlineBuffer;
                long srcScanLength;
                long nxtSrcScan;
                long n;
                short m;
                FAST short pxlCount;
                unsigned char *pSrcInitBits;
                unsigned char *pSaveSrcBits;
                unsigned char *pSrcCurScan;
                long deltaX;
                long deltaY;
                long deltaDstY;
                long curDstY;
                long lastDstY;
                long skipSrcBytes = 0;
                NVCOORD wSrcExt;
                NVCOORD wDstPoint;
                unsigned long srcStrtX;
                BYTE srcInVideoMemory = 0;
                BYTE bufState = 0;
                short skipV = 0;
                RECTL rDummy;
                BOOL isOverlappingVmem = FALSE;
                ULONG lpSurfTemp = 0;

                // if the source and destination overlap, then we must do this in 2 passes, first copy the source
                // image somewhere else, and then so the stretch from there.
                if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                    dwSrcOffset == dwDstOffset &&
                    bIntersect((RECTL *)(&pbd->rSrc), (RECTL *)(&pbd->rDest), &rDummy))
                    {
                    ULONG tmpBmpPitch = (((dwSrcWidth * (ppdev->cBitsPerPel / 8)) + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign);
                    NVHEAP_ALLOC(dwStatus,lpSurfTemp, (DWORD)dwSrcHeight * tmpBmpPitch,  TYPE_IMAGE);
                    if (dwStatus!=0)
                    {
                        bMoveAllDfbsFromOffscreenToDibs(ppdev);
                        NVHEAP_ALLOC(dwStatus,lpSurfTemp, (DWORD)dwSrcHeight * tmpBmpPitch,  TYPE_IMAGE);
                    }

                    if (dwStatus==0)
                        {
                        isOverlappingVmem = TRUE;
                        DDRAW_SET_PRIMARY(ppdev, lpSurfTemp, tmpBmpPitch);
                        DDRAW_SET_SOURCE(ppdev, dwSrcOffset, dwSrcPitch);

                        while (freeCount < 6*4)
                            freeCount = NvGetFreeCount(npDev, 0);
                        freeCount -= 6*4;

						{
							NVCOORD     srcSize;

							srcSize.wh16.w = (unsigned short)dwSrcWidth;
							srcSize.wh16.h = (unsigned short)dwSrcHeight;

							npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;
							npDev->dDrawBlit.ControlPointIn = wSrcXY.xy;
							npDev->dDrawBlit.ControlPointOut = 0;
							npDev->dDrawBlit.Size = srcSize.wh;
						}

                        dwSrcOffset = lpSurfTemp;
                        dwSrcPitch = tmpBmpPitch;
                        wSrcXY.xy = 0;
                        wSrcXY.xy16.x = 0;
                        wSrcXY.xy16.y = 0;
                        }
                    else
                        {
                        // FIXME: vmem heap alloc failed, must do system mem alloc and copy there
                        }
                        // WARNING: carefully consider each use of src->fpVidMem and src->lPitch beyond this point
                        //          it could screw up overlapping stretchblits
                    }

                pSrcInitBits = (unsigned char *) dwSrcOffset;
                if (dwSrcCaps & DDSCAPS_VIDEOMEMORY)
                    pSrcInitBits += (ULONG) ppdev->pjFrameBufbase;

                srcScanLength = dwSrcPitch;

                if (dwSrcPitch <= 800)
                    m = 16;
                else
                    m = 8;

                while (freeCount < 4)
                    freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                freeCount -= 4;

                npDev->dDrawRop.SetRop5 = dwRop;

                ppdev->NVFreeCount = freeCount;
                DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
                freeCount = ppdev->NVFreeCount;

                /* calculate deltas in 12.20 format */
                n = (dwDstWidth << 20) / dwSrcWidth;

                if ((n & 0xFFFFF) == 0)
                    n = 0;
                else
                    {
                    n >>= 20;
                    n += 1;
                    }

                deltaX = (dwDstWidth + n) << 20;
                deltaX /= dwSrcWidth;

                n = (dwDstHeight << 20) / dwSrcHeight;

                if ((n & 0xFFFFF) == 0)
                    n = 0;
                else
                    {
                    n >>= 20;
                    n += 1;
                    }

                deltaY = (dwDstHeight + n) << 20;
                deltaY /= dwSrcHeight;

                deltaDstY = (dwDstHeight << 20);
                deltaDstY /= dwSrcHeight;

                wSrcExt.wh16.w = (unsigned short)((dwSrcWidth + 3) & ~3L);
                wSrcExt.wh16.h = (unsigned short)dwSrcHeight;

                n = (short)dwSrcHeight;

                if ((ULONG) (wSrcXY.xy16.y + n) > src->wHeight)
                    n = src->wHeight - wSrcXY.xy16.y;

                nxtSrcScan = srcScanLength;

                if (doMirrorUpDown)
                    {
                    wSrcXY.xy16.y += (short)(n - 1);
                    nxtSrcScan = -nxtSrcScan;
                    skipSrcBytes = -skipSrcBytes;
                    }

                if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                    ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) ||
                    isOverlappingVmem)
                    {
                    srcInVideoMemory = 1;
                    }
                else
                    {
                    pSaveSrcBits = (unsigned char *)(pSrcInitBits +
                                                     (wSrcXY.xy16.y * srcScanLength));
                    pSaveSrcBits += wSrcXY.xy16.x;
                    pSrcCurScan = pSaveSrcBits;
                    }

                if (srcInVideoMemory)
                    {
                    pDmaToMemNotifier = (NvNotification *)ppdev->Notifiers->DmaToMem;
                    pScanlineBuffer = (unsigned char *)ppdev->NvScanlineBufferFlat;

                    wSrcExt.wh16.w = (unsigned short)((dwSrcWidth + 3) & ~3);
                    wSrcExt.wh16.h = m;

                    srcStrtX = wSrcXY.xy16.x;

                    while (freeCount < 4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_IMAGE);
                    freeCount -= 4;

                    npDev->subchannel[NV_DD_SPARE].SetObject =
                        NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
                    ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;

                    // wait for any pending notification operation to finish
                    while ((volatile)pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV_IN_PROGRESS);

                    pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV_IN_PROGRESS;

                    while (freeCount < 32)
                        freeCount = NvGetFreeCount(npDev, NV_DD_IMAGE);
                    freeCount -= 32;

                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
                    dwSrcOffset +
                    ((dwSrcPitch + skipSrcBytes) * (unsigned long)wSrcXY.xy16.y) +
                    ((unsigned long)wSrcXY.xy16.x);

                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
                    srcStrtX;

                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
                    (dwSrcPitch + skipSrcBytes);

                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
                    dwSrcPitch;

                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
                    (unsigned long)(wSrcExt.wh16.w);

                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
                    m;

                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
                        1 | (1 << 8);
                    //NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1;

                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify =
                    0;

                    // wait for Dma operation to finish
                    while ((volatile)pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV_IN_PROGRESS);

                    if (doMirrorUpDown)
                        wSrcXY.xy16.y -= (m + skipV);
                    else
                        wSrcXY.xy16.y += (m + skipV);
                    }

                /* Convert to 12.4 format */
                wDstPoint.xy16.x = (wDestXY.xy16.x << 4);
                wDstPoint.xy16.y = (wDestXY.xy16.y << 4);

                /* convert to 16.16 */
                lastDstY = (wDestXY.xy16.y + wXYext.wh16.h) << 16;

                /* convert to 16.16 */
                curDstY = (wDestXY.xy16.y << 16);

                while (freeCount < 28)
                    freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                freeCount -= 28;

                npDev->subchannel[NV_DD_SPARE].SetObject =
                NV_DD_STRETCHED_IMAGE_FROM_CPU;
                ppdev->dDrawSpareSubchannelObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;

                npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipPoint =
                wDestXY.xy;

                npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipSize =
                wXYext.wh;

                npDev->dDrawStretch.nv4StretchedImageFromCpu.SizeIn = wSrcExt.wh;

                npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDxDu = deltaX;

                npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDyDv = deltaY;

                npDev->dDrawStretch.nv4StretchedImageFromCpu.Point12d4 = wDstPoint.xy;

                while ((n > 0) && (curDstY < lastDstY))
                    {
                    FAST unsigned long *pSrcBits;
                    FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                    if (srcInVideoMemory)
                        {
                        if (bufState == 0)
                            pSrcBits = (unsigned long *)(pScanlineBuffer + srcStrtX);
                        else
                            pSrcBits = (unsigned long *)(pScanlineBuffer +
                                                         (NV_DMA_SCANLINE_BUF_SIZE >> 1) + srcStrtX);

                        pSrcCurScan = (unsigned char *)pSrcBits;

                        if (m > 0)
                            {
                            pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV_IN_PROGRESS;

                            while (freeCount < 36)
                                freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                            freeCount -= 36;

                            npDev->subchannel[NV_DD_SPARE].SetObject = NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;

                            npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
                            dwSrcOffset +
                            ((dwSrcPitch + skipSrcBytes) * (unsigned long)wSrcXY.xy16.y) +
                            ((unsigned long)wSrcXY.xy16.x);

                            if (bufState == 0)
                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
                                (NV_DMA_SCANLINE_BUF_SIZE >> 1) +
                                srcStrtX;
                            else
                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
                                srcStrtX;

                            npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
                            (dwSrcPitch + skipSrcBytes);

                            npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
                            dwSrcPitch;

                            npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
                            (unsigned long)(wSrcExt.wh16.w);

                            npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
                            m;

                            npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
                                1 | (1 << 8);
                            //NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1;

                            npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify =
                            0;

                            bufState ^= 1;

                            if (doMirrorUpDown)
                                wSrcXY.xy16.y -= (m + skipV);
                            else
                                wSrcXY.xy16.y += (m + skipV);

                            while (freeCount < 28)
                                freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                            freeCount -= 28;

                            npDev->subchannel[NV_DD_SPARE].SetObject =
                            NV_DD_STRETCHED_IMAGE_FROM_CPU;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;


                            npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipPoint =
                            wDestXY.xy;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipSize =
                            wXYext.wh;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.SizeIn =
                            wSrcExt.wh;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDxDu =
                            deltaX;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDyDv =
                            deltaY;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Point12d4 =
                            wDstPoint.xy;
                            }
                        }
                    else
                        { // source in system memory
                        pSrcBits = (unsigned long *)pSrcCurScan;
                        pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                        n--;
                        }


                    doNxtSrcScan:      pxlCount = (short)((dwSrcWidth + 3) & ~3);

                    while (pxlCount >= 64)
                        {

                        pxlCount -= 64;

                        while (freeCount < 64)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 64;

                        tmpPxls0 = pSrcBits[0];
                        tmpPxls1 = pSrcBits[1];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[0] = tmpPxls0;
                        tmpPxls2 = pSrcBits[2];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[1] = tmpPxls1;
                        tmpPxls0 = pSrcBits[3];
                        tmpPxls1 = pSrcBits[4];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[2] = tmpPxls2;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[3] = tmpPxls0;
                        tmpPxls2 = pSrcBits[5];
                        tmpPxls0 = pSrcBits[6];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[4] = tmpPxls1;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[5] = tmpPxls2;
                        tmpPxls1 = pSrcBits[7];
                        tmpPxls2 = pSrcBits[8];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[6] = tmpPxls0;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[7] = tmpPxls1;
                        tmpPxls0 = pSrcBits[9];
                        tmpPxls1 = pSrcBits[10];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[8] = tmpPxls2;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[9] = tmpPxls0;
                        tmpPxls2 = pSrcBits[11];
                        tmpPxls0 = pSrcBits[12];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[10] = tmpPxls1;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[11] = tmpPxls2;
                        tmpPxls1 = pSrcBits[13];
                        tmpPxls2 = pSrcBits[14];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[12] = tmpPxls0;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[13] = tmpPxls1;
                        tmpPxls0 = pSrcBits[15];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[14] = tmpPxls2;
                        pSrcBits += 16;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[15] = tmpPxls0;
                        }

                    while (pxlCount >= 32)
                        {

                        pxlCount -= 32;

                        while (freeCount < 32)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 32;

                        tmpPxls0 = pSrcBits[0];
                        tmpPxls1 = pSrcBits[1];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[0] = tmpPxls0;
                        tmpPxls2 = pSrcBits[2];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[1] = tmpPxls1;
                        tmpPxls0 = pSrcBits[3];
                        tmpPxls1 = pSrcBits[4];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[2] = tmpPxls2;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[3] = tmpPxls0;
                        tmpPxls2 = pSrcBits[5];
                        tmpPxls0 = pSrcBits[6];
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[4] = tmpPxls1;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[5] = tmpPxls2;
                        tmpPxls1 = pSrcBits[7];
                        pSrcBits += 8;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[6] = tmpPxls0;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[7] = tmpPxls1;
                        }

                    while (freeCount < 32)
                        freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                    freeCount -= 32;

                    while (pxlCount >= 4)
                        {
                        tmpPxls0 = pSrcBits[0];
                        pxlCount -= 4;
                        npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[0] = tmpPxls0;
                        pSrcBits += 1;
                        }

                    if (srcInVideoMemory)
                        {
                        if (--m > 0)
                            {
                            pSrcCurScan += dwSrcPitch;

                            pSrcBits = (unsigned long *)pSrcCurScan;

                            goto doNxtSrcScan;
                            }
                        else
                            {
                            if (dwSrcPitch <= 800)
                                {
                                m = 16;
                                curDstY += deltaDstY;
                                }
                            else
                                {
                                m = 8;
                                curDstY += (deltaDstY >> 1);
                                }
                            /* convert 16.16 to 12.4 */
                            wDstPoint.xy16.y = (short)(curDstY >> 12);

                            // wait for DMA operation to finish
                            while ((volatile)pDmaToMemNotifier[NV076_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);
                            }
                        }
                    }
                    if (isOverlappingVmem && lpSurfTemp)
                        {
                        NVHEAP_FREE(lpSurfTemp);
                        }
                }

            if (dwFlags & DDBLT_KEYSRCOVERRIDE)
                {
                while (freeCount < 2*4)
                    freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                freeCount -= 2*4;
                if (ppdev->dDrawSpareSubchannelObject != NV_DD_IMAGE_SOLID)
                    {
                    npDev->subchannel[NV_DD_SPARE].SetObject = NV_DD_IMAGE_SOLID;
                    ppdev->dDrawSpareSubchannelObject = NV_DD_IMAGE_SOLID;
                    }
                    // disable chroma key
                    npDev->dDrawTransColor.SetColor = 0;

                }
            }
        else
            {
            DPF("BLT     blt not handled by driver");
            ppdev->NVFreeCount = freeCount;
            return DDHAL_DRIVER_NOTHANDLED;
            }
        }
    else if (dwFlags & DDBLT_COLORFILL)
        {
        dwFillColor = (pbd->bltFX.dwFillColor & ppdev->physicalColorMask) | ppdev->AlphaEnableValue;

        ppdev->NVFreeCount = freeCount;
        DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
        freeCount = ppdev->NVFreeCount;

        while (freeCount < 16)
            freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
        freeCount -= 16;

        npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;

        npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.Color1A = dwFillColor;

        npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].point =
        asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);

        npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].size =
        asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

        }
    else if (dwFlags & DDBLT_ZBUFFER)
        {
        /* Hardware Z buffer fills not currently supported when in 8bpp mode */
        DPF("HARDWARE Z BUFFER BLT FAILED");
        ppdev->NVFreeCount = freeCount;
        return DDHAL_DRIVER_NOTHANDLED;
        }
    else
        {
        DPF("BLT     blt not handled by driver");
        /* We don't handle any other type of BLT operation */
        ppdev->NVFreeCount = freeCount;
        return DDHAL_DRIVER_NOTHANDLED;
        }

    pbd->ddRVal = DD_OK;
    ppdev->NVFreeCount = freeCount;
    return DDHAL_DRIVER_HANDLED;

    } /* Nv4Blt8 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\blt32.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995,1997 NVidia Corporation.  All Rights Reserved.
 *
 *  File:       Nv4Blt32.c
 *  Content:    Windows95 DirectDraw 32 bit driver
 *
 ***************************************************************************/
#include "nvprecomp.h"
#include "nvalpha.h"
#include "ddminint.h"
#include "nv32.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "nvsubch.h"

#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free
/*
 * Nv4Blt32
 *
 * NV4 Blt function for 32bpp surfaces.
 */
DWORD __stdcall Nv4Blt32( PDD_BLTDATA pbd )
    {
    FAST Nv3ChannelPio *npDev;
    FAST USHORT freeCount;
    DWORD       dwFlags;
    DWORD       dwDDFX = 0;
    DWORD       dwDstCaps;
    DWORD       dwSrcCaps;
    DWORD       dwRop;
    NVCOORD     wXYext;
    NVCOORD     wDestXY;
    NVCOORD     wSrcXY;
    BYTE        wStretch = 0;
    BYTE        doMirrorUpDown = 0;
    BYTE        isVideo = 0;
//    BYTE        doAlpha = 0;

    DWORD       dwFillColor;
    DWORD       dwColorKey;

    DWORD       dwDstOffset;
    DWORD       dwDstPitch;
    DWORD       dwDstWidth;
    DWORD       dwDstHeight;

    DWORD       dwSrcOffset;
    DWORD       dwSrcPitch;
    DWORD       dwSrcWidth;
    DWORD       dwSrcHeight;

    PDD_SURFACE_LOCAL  srcx;
    PDD_SURFACE_LOCAL  dstx;
    PDD_SURFACE_GLOBAL  src;
    PDD_SURFACE_GLOBAL  dst;
    PDEV    *ppdev;

    dstx = pbd->lpDDDestSurface;
    dst = dstx->lpGbl;
    ppdev = (PDEV *) pbd->lpDD->dhpdev;

    /*
     * NOTES:
     *
     * Everything you need is in pdb->bltFX .
     * Look at pdb->dwFlags to determine what kind of blt you are doing,
     * DDBLT_xxxx are the flags.
     *
     * ALPHA NOTES:
     *
     * Alpha ALWAYS comes in BLTFX.   You don't need to go looking for
     * the attached surface. If DDBLT_ALPHA is specified, then either a
     * constant alpha or alpha surface has been specified. Just look for
     * DDBLT_ALPHASURFACEOVERRIDE or DDBLT_ALPHACONSTANTOVERRIDE
     *
     * Look for DDBLT_ALPHASURFACEDESTRECT to use the destination rectangle
     * for choosing the rectangle in the alpha surface.   Otherwise use the
     * source rectangle.
     *
     * Z BUFFER NOTES:
     *
     * ZBuffer ALWAYS comes in BLTFX.   You don't need to go looking for
     * the attached surface. If DDBLT_ZBUFFER is specified, then either a
     * constant z or z buffer surface has been specified for the source and
     * destination. Just look for the DDBLT_ZBUFFERDESTOVERRIDE,
     * DDBLT_ZBUFFERSRCOVERRIDE, DDBLT_ZBUFFERCONSTANTDESTOVERRIDE, or
     * DDBLT_ZBUFFERCONSTANTSRCOVERRIDE.
     *
     * COLORKEY NOTES:
     *
     * ColorKey ALWAY comes in BLTFX.   You don't have to look it up in
     * the surface.
     */


    dwFlags   = pbd->dwFlags;
    dwDstCaps = dstx->ddsCaps.dwCaps;

    if (dwFlags & DDBLT_DDFX)
        dwDDFX = pbd->bltFX.dwDDFX;

//    if (dwFlags & DDOVER_ANYALPHA) {
//        DPF("Overlay Alpha failed");
//        pbd->ddRVal = DDERR_NOOVERLAYHW;
//        return DDHAL_DRIVER_HANDLED;
//    }

//    if (dwFlags & DDBLT_ANYALPHA) {
//        DPF("Alpha requested");
//        if ((dwFlags & DDBLT_ALPHASRCCONSTOVERRIDE) == 0) {
//            pbd->ddRVal = DDERR_NOALPHAHW;
//            return DDHAL_DRIVER_HANDLED;
//        } else
//            doAlpha = 1;
//    }

    if (dwFlags & (DDBLT_KEYDEST | DDBLT_KEYDESTOVERRIDE))
        {
        DPF("Dest color key failed");
        pbd->ddRVal = DDERR_NOCOLORKEYHW;
        return DDHAL_DRIVER_HANDLED;
        }


    /*
     * get offset, width, and height for destination
     */
    dwDstOffset = dst->fpVidMem;
    dwDstPitch  = dst->lPitch;
    dwDstWidth  = pbd->rDest.right  - pbd->rDest.left;
    dwDstHeight = pbd->rDest.bottom - pbd->rDest.top;
    wXYext.wh16.w = (unsigned short)dwDstWidth;
    wXYext.wh16.h = (unsigned short)dwDstHeight;

    wDestXY.xy16.x = (short)pbd->rDest.left;
    wDestXY.xy16.y = (short)pbd->rDest.top;

    if (dwDstCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_TEXTURE | DDSCAPS_NONLOCALVIDMEM))
        return DDHAL_DRIVER_NOTHANDLED;

    npDev = (Nv3ChannelPio*)ppdev->pjMmBase;

    if (npDev == NULL)
        {
        pbd->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
        }

    freeCount = ppdev->NVFreeCount;

    /*
     * If async, then only work if bltter isn't busy
     * This should probably be a little more specific to each call, but
     * waiting for 32 is pretty close
     */
    if ( dwFlags & DDBLT_ASYNC )
        {
        if (freeCount < 32)
            freeCount = NvGetFreeCount(npDev, NV_DD_ROP);

        if ( freeCount < 32 )
            {
            DPF("ASYNC FAILED");
            pbd->ddRVal = DDERR_WASSTILLDRAWING;
            ppdev->NVFreeCount = freeCount;
            return DDHAL_DRIVER_HANDLED;
            }
        }

    if (dwFlags & DDBLT_ROP)
        {

        dwRop = pbd->bltFX.dwROP >> 16;

        if ((dwRop == BLACKNESSINDEX) || (dwRop == WHITENESSINDEX))
            {
            ppdev->NVFreeCount = freeCount;
            DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
            freeCount = ppdev->NVFreeCount;

            while (freeCount < 4*4)
                freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
            freeCount -= 4*4;

            npDev->dDrawRop.SetRop5 = dwRop;
            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.Color1A = 0;

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].point =
            asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].size =
            asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);
            }
        else if ((dwRop == PATCOPYINDEX) || (dwRop == PATINVERTINDEX))
            {

            dwFillColor = (pbd->bltFX.dwFillColor & ppdev->physicalColorMask) | ppdev->AlphaEnableValue;

            if (dwRop == PATCOPYINDEX)
                dwRop = SRCCOPYINDEX;
            else if (dwRop == PATINVERTINDEX)
                dwRop = SRCINVERTINDEX;


            ppdev->NVFreeCount = freeCount;
            DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
            freeCount = ppdev->NVFreeCount;

            while (freeCount < 4*4)
                freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
            freeCount -= 4*4;

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.Color1A = dwFillColor;
            npDev->dDrawRop.SetRop5 = dwRop;
            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].point =
            asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);

            npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].size =
            asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

            }
        else if ((dwRop == SRCCOPYINDEX) || (dwRop == SRCPAINTINDEX) ||
                 (dwRop == SRCANDINDEX) || (dwRop == NOTSRCCOPYINDEX) ||
                 (dwRop == SRCINVERTINDEX) || (dwRop == MERGEPAINTINDEX) ||
                 (dwRop == SRCERASEINDEX) || (dwRop == NOTSRCERASEINDEX))
            {

            srcx = pbd->lpDDSrcSurface;
            src = srcx->lpGbl;

            dwSrcCaps = srcx->ddsCaps.dwCaps;

            /* We must treat AGP source memory as system memory */
            if (dwSrcCaps & DDSCAPS_NONLOCALVIDMEM)
                {
                dwSrcCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
                }

            dwSrcOffset = src->fpVidMem;
            dwSrcPitch  = src->lPitch;
            dwSrcWidth  = pbd->rSrc.right  - pbd->rSrc.left;
            dwSrcHeight = pbd->rSrc.bottom - pbd->rSrc.top;
            dwColorKey  = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

            wSrcXY.xy16.x = (short)pbd->rSrc.left;
            wSrcXY.xy16.y = (short)pbd->rSrc.top;

            if (//(srcx->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
                (src->ddpfSurface.dwFlags & DDPF_FOURCC))
                {

                if (src->ddpfSurface.dwFourCC == FOURCC_RGB0)
                    {
                    if ((src->ddpfSurface.dwRBitMask == 0x00FF0000) &&
                        (src->ddpfSurface.dwGBitMask == 0x0000FF00) &&
                        (src->ddpfSurface.dwBBitMask == 0x000000FF))
                        {
                        if (dwSrcCaps & DDSCAPS_SYSTEMMEMORY)
                            isVideo = 1;
                        goto srcRGB;
                        }
                    else
                        {
                        pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }
                    }

                while (freeCount < 4 )
                    freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                freeCount -= 4;

                npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;

                ppdev->NVFreeCount = freeCount;

                DDRAW_SET_SOURCE(ppdev, dwSrcOffset, dwSrcPitch);
                DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);

                freeCount = ppdev->NVFreeCount;

                switch (src->ddpfSurface.dwFourCC)
                    {
                    case FOURCC_YUY2:
                    case FOURCC_UYVY:

//                     if (dwSrcWidth & 1) {  NEC MPEG CODEC DOESN'T RESPOND TO THIS ERROR
//                           pbd->ddRVal = DDERR_INVALIDRECT;
//                           return DDHAL_DRIVER_HANDLED;
//                       }

                        if (wSrcXY.xy16.x & 1)
                            {
                            pbd->ddRVal = DDERR_INVALIDRECT;
                            ppdev->NVFreeCount = freeCount;
                            return DDHAL_DRIVER_HANDLED;
                            }

                        if (src->ddpfSurface.dwFourCC == FOURCC_UYVY)
                            {
                            isVideo = 2;
                            // Is this surface DMAable ?
                            if ((ppdev->fNvActiveFloatingContexts &
                                 NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                (ppdev->NvFloating0UYVYSurfaceMem == src->fpVidMem))
                                isVideo = 4;
                            else if ((ppdev->fNvActiveFloatingContexts &
                                      NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                     (ppdev->NvFloating1UYVYSurfaceMem == src->fpVidMem))
                                isVideo = 5;
                            }
                        else
                            { // YUY2
                            isVideo = 3;
                            // Is this surface DMAable ?
                            if ((ppdev->fNvActiveFloatingContexts &
                                 NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                (ppdev->NvFloating0YUYVSurfaceMem == src->fpVidMem))
                                isVideo = 6;
                            else if ((ppdev->fNvActiveFloatingContexts &
                                      NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY) &&
                                     (ppdev->NvFloating1YUYVSurfaceMem == src->fpVidMem))
                                isVideo = 7;
                            }
                        goto srcRGB;
                        break;
#ifdef YV12_SUPPORT
                    case FOURCC_YV12:
                        // Size has to be always * 4, to use VU subsampling
                        if ((dwSrcWidth & 3) || (dwSrcHeight & 3))
                            {
                            pbd->ddRVal = DDERR_INVALIDRECT;
                            ppdev->NVFreeCount = freeCount;
                            return DDHAL_DRIVER_HANDLED;
                            }

//                     pbd->ddRVal = nvStretchYVU12ToDev (pbd, src->ddpfSurface.dwFourCC);
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        break;
#endif // #ifdef YV12_SUPPORT
                    }
                pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
                ppdev->NVFreeCount = freeCount;
                return DDHAL_DRIVER_HANDLED;
                }

            srcRGB:     if (dwDDFX & DDBLTFX_MIRRORUPDOWN)
                doMirrorUpDown = 1;

            if ((dwSrcWidth != dwDstWidth) || (dwSrcHeight != dwDstHeight))
                wStretch = 1;

            if (isVideo > 1) /* YUV video */
                wStretch = 1;

            if (dwFlags & DDBLT_KEYSRCOVERRIDE)
                {

                dwColorKey = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

                while (freeCount < 2*4)
                    freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);

                // load and enable chroma key
                freeCount -= 2*4;
                if (ppdev->dDrawSpareSubchannelObject != NV_DD_IMAGE_SOLID)
                    {
                    npDev->dDrawSpare.SetObject = NV_DD_IMAGE_SOLID;
                    ppdev->dDrawSpareSubchannelObject = NV_DD_IMAGE_SOLID;
                    }
                npDev->dDrawTransColor.SetColor =
                (dwColorKey & ppdev->physicalColorMask) | NV_ALPHA_1_32;

                }

            // screen to screen bitblt
            if (wStretch == 0)
                {
                if ((dwDstCaps & DDSCAPS_VIDEOMEMORY) &&
                    (dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                    ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) &&
                    (doMirrorUpDown == 0) &&
                    (isVideo == 0))
                    {
                    ppdev->NVFreeCount = freeCount;
                    DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
                    DDRAW_SET_SOURCE(ppdev, dwSrcOffset, dwSrcPitch);
                    freeCount = ppdev->NVFreeCount;

                    while (freeCount < 16)
                        freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                    freeCount -= 16;

                    npDev->dDrawRop.SetRop5 = dwRop;
                    npDev->dDrawBlit.ControlPointIn = wSrcXY.xy;
                    npDev->dDrawBlit.ControlPointOut = wDestXY.xy;
                    npDev->dDrawBlit.Size = wXYext.wh;

                    }
                else
                    {
                    // memory to screen blt (src may be in system memory or in video memory)
                    unsigned long temp;
                    long srcScanLength;
                    long nxtSrcScan;
                    short n = wXYext.wh16.h;
                    FAST short pxlCount;
                    unsigned long *pSrcInitBits;

                    pSrcInitBits = (unsigned long *)src->fpVidMem;
                    if (dwSrcCaps & DDSCAPS_VIDEOMEMORY)
                        pSrcInitBits += (ULONG) ppdev->pjFrameBufbase;

                    srcScanLength = src->lPitch >> 2;

                    if (doMirrorUpDown)
                        wSrcXY.xy16.y += (short)(n - 1);

                    pSrcInitBits += (wSrcXY.xy16.y * srcScanLength);

                    temp = wXYext.wh16.w;

                    nxtSrcScan = srcScanLength - temp;

                    if (doMirrorUpDown)
                        nxtSrcScan = -srcScanLength - temp;

                    pSrcInitBits += wSrcXY.xy16.x;

                    ppdev->NVFreeCount = freeCount;
                    DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
                    freeCount = ppdev->NVFreeCount;

                    while (freeCount < 4*4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                    freeCount -= 4*4;

                    npDev->dDrawRop.SetRop5 = dwRop;

                    npDev->dDrawImageFromCpu.Point = wDestXY.xy;
                    npDev->dDrawImageFromCpu.SizeOut = wXYext.wh;
                    npDev->dDrawImageFromCpu.SizeIn = wXYext.wh;

                    {
                        FAST unsigned long *pSrcBits = (unsigned long *)pSrcInitBits;
                        FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                        while (--n >= 0)
                            {
                            pxlCount = (short)temp;

                            while (pxlCount >= 16)
                                {
                                pxlCount -= 16;

                                while (freeCount < 64)
                                    freeCount = NvGetFreeCount(npDev, NV_DD_IMAGE);
                                freeCount -= 64;

                                tmpPxls0 = pSrcBits[0];
                                tmpPxls1 = pSrcBits[1];
                                npDev->dDrawImageFromCpu.Color[0] = tmpPxls0;
                                tmpPxls2 = pSrcBits[2];
                                npDev->dDrawImageFromCpu.Color[1] = tmpPxls1;
                                tmpPxls0 = pSrcBits[3];
                                tmpPxls1 = pSrcBits[4];
                                npDev->dDrawImageFromCpu.Color[2] = tmpPxls2;
                                npDev->dDrawImageFromCpu.Color[3] = tmpPxls0;
                                tmpPxls2 = pSrcBits[5];
                                tmpPxls0 = pSrcBits[6];
                                npDev->dDrawImageFromCpu.Color[4] = tmpPxls1;
                                npDev->dDrawImageFromCpu.Color[5] = tmpPxls2;
                                tmpPxls1 = pSrcBits[7];
                                tmpPxls2 = pSrcBits[8];
                                npDev->dDrawImageFromCpu.Color[6] = tmpPxls0;
                                npDev->dDrawImageFromCpu.Color[7] = tmpPxls1;
                                tmpPxls0 = pSrcBits[9];
                                tmpPxls1 = pSrcBits[10];
                                npDev->dDrawImageFromCpu.Color[8] = tmpPxls2;
                                npDev->dDrawImageFromCpu.Color[9] = tmpPxls0;
                                tmpPxls2 = pSrcBits[11];
                                tmpPxls0 = pSrcBits[12];
                                npDev->dDrawImageFromCpu.Color[10] = tmpPxls1;
                                npDev->dDrawImageFromCpu.Color[11] = tmpPxls2;
                                tmpPxls1 = pSrcBits[13];
                                tmpPxls2 = pSrcBits[14];
                                npDev->dDrawImageFromCpu.Color[12] = tmpPxls0;
                                npDev->dDrawImageFromCpu.Color[13] = tmpPxls1;
                                tmpPxls0 = pSrcBits[15];
                                npDev->dDrawImageFromCpu.Color[14] = tmpPxls2;
                                pSrcBits += 16;
                                npDev->dDrawImageFromCpu.Color[15] = tmpPxls0;
                                }

                            if (pxlCount > 0)
                                {
                                while (freeCount < 64)
                                    freeCount = NvGetFreeCount(npDev, NV_DD_IMAGE);

                                while (--pxlCount >= 0)
                                    {
                                    tmpPxls0 = pSrcBits[0];
                                    freeCount -= 4;
                                    pSrcBits += 1;
                                    npDev->dDrawImageFromCpu.Color[0] = tmpPxls0;
                                    }
                                }

                            pSrcBits += nxtSrcScan;
                            }
                    }
                    }
                }
            else
                { // stretch
                DWORD dwStatus;
                RECTL rDummy;
                BOOL isOverlappingVmem = FALSE;
                ULONG lpSurfTemp = 0;
                // if the source and destination overlap, then we must do this in 2 passes, first copy the source
                // image somewhere else, and then so the stretch from there.
                if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                    dwSrcOffset == dwDstOffset &&
                    bIntersect((RECTL *)(&pbd->rSrc), (RECTL *)(&pbd->rDest), &rDummy))
                    {
                    ULONG tmpBmpPitch = (((dwSrcWidth * (ppdev->cBitsPerPel / 8)) + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign);
                    NVHEAP_ALLOC(dwStatus,lpSurfTemp, (DWORD)dwSrcHeight * tmpBmpPitch,  TYPE_IMAGE);
                    if (dwStatus!=0)
                    {
                        bMoveAllDfbsFromOffscreenToDibs(ppdev);
                        NVHEAP_ALLOC(dwStatus,lpSurfTemp, (DWORD)dwSrcHeight * tmpBmpPitch,  TYPE_IMAGE);
                    }

                    if (dwStatus==0)
                        {
                        isOverlappingVmem = TRUE;
                        DDRAW_SET_PRIMARY(ppdev, lpSurfTemp, tmpBmpPitch);
                        DDRAW_SET_SOURCE(ppdev, dwSrcOffset, dwSrcPitch);

                        while (freeCount < 6*4)
                            freeCount = NvGetFreeCount(npDev, 0);
                        freeCount -= 6*4;

						{
							NVCOORD     srcSize;

							srcSize.wh16.w = (unsigned short)dwSrcWidth;
							srcSize.wh16.h = (unsigned short)dwSrcHeight;

							npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;
							npDev->dDrawBlit.ControlPointIn = wSrcXY.xy;
							npDev->dDrawBlit.ControlPointOut = 0;
							npDev->dDrawBlit.Size = srcSize.wh;
						}

                        dwSrcOffset = lpSurfTemp;
                        dwSrcPitch = tmpBmpPitch;
                        wSrcXY.xy = 0;
                        wSrcXY.xy16.x = 0;
                        wSrcXY.xy16.y = 0;
                        }
                    else
                        {
                        // FIXME: vmem heap alloc failed, must do system mem alloc and copy there
                        }
                        // WARNING: carefully consider each use of src->fpVidMem and src->lPitch beyond this point
                        //          it could screw up overlapping stretchblits
                    }
                if (dwFlags & DDBLT_KEYSRCOVERRIDE)
                    { // If color key then MUST use STRETCHED IMAGE instead of SCALED IMAGE
                    NvNotification *pDmaToMemNotifier;
                    unsigned char *pScanlineBuffer;
                    long srcScanLength;
                    long nxtSrcScan;
                    long n;
                    short m;
                    FAST short pxlCount;
                    unsigned char *pSrcInitBits;
                    unsigned char *pSaveSrcBits;
                    unsigned char *pSrcCurScan;
                    long deltaX;
                    long deltaY;
                    long deltaDstY;
                    long curDstY;
                    long lastDstY;
                    long skipSrcBytes = 0;
                    NVCOORD wSrcExt;
                    NVCOORD wDstPoint;
                    unsigned long srcStrtX;
                    BYTE srcInVideoMemory = 0;
                    BYTE bufState = 0;
                    short skipV = 0;

                    pSrcInitBits = (unsigned char *) dwSrcOffset;
                    if (dwSrcCaps & DDSCAPS_VIDEOMEMORY)
                        pSrcInitBits += (ULONG) ppdev->pjFrameBufbase;

                    srcScanLength = dwSrcPitch;

                    if (dwSrcPitch <= 1600)
                        m = 8;
                    else if (dwSrcPitch <= 3200)
                        m = 4;
                    else
                        m = 2;

                    ppdev->NVFreeCount = freeCount;
                    DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
                    freeCount = ppdev->NVFreeCount;

                    while (freeCount < 4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                    freeCount -= 4;

                    npDev->dDrawRop.SetRop5 = dwRop;

                    /* calculate deltas in 12.20 format */
                    n = (dwDstWidth << 20) / dwSrcWidth;

                    if ((n & 0xFFFFF) == 0)
                        n = 0;
                    else
                        {
                        n >>= 20;
                        n += 1;
                        }

                    deltaX = (dwDstWidth + n) << 20;
                    deltaX /= dwSrcWidth;

                    n = (dwDstHeight << 20) / dwSrcHeight;

                    if ((n & 0xFFFFF) == 0)
                        n = 0;
                    else
                        {
                        n >>= 20;
                        n += 1;
                        }

                    deltaY = (dwDstHeight + n) << 20;
                    deltaY /= dwSrcHeight;

                    deltaDstY = (dwDstHeight << 20);
                    deltaDstY /= dwSrcHeight;

                    wSrcExt.wh16.w = (unsigned short)dwSrcWidth;
                    wSrcExt.wh16.h = (unsigned short)dwSrcHeight;

                    n = (short)dwSrcHeight;

                    if ((ULONG) (wSrcXY.xy16.y + n) > src->wHeight)
                        n = src->wHeight - wSrcXY.xy16.y;

                    nxtSrcScan = srcScanLength;

                    if (doMirrorUpDown)
                        {
                        wSrcXY.xy16.y += (short)(n - 1);
                        nxtSrcScan = -nxtSrcScan;
                        skipSrcBytes = -skipSrcBytes;
                        }

                    if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                        ((dwSrcCaps & DDSCAPS_TEXTURE) == 0)
                        || isOverlappingVmem)
                        {
                        srcInVideoMemory = 1;
                        }
                    else
                        {
                        pSaveSrcBits = (unsigned char *)(pSrcInitBits +
                                                         (wSrcXY.xy16.y * srcScanLength));
                        pSaveSrcBits += (wSrcXY.xy16.x << 2);
                        pSrcCurScan = pSaveSrcBits;
                        }

                    if (srcInVideoMemory)
                        {
                        pDmaToMemNotifier = (NvNotification *)ppdev->Notifiers->DmaToMem;
                        pScanlineBuffer = (unsigned char *)ppdev->NvScanlineBufferFlat;

                        wSrcExt.wh16.w = (unsigned short)dwSrcWidth;
                        wSrcExt.wh16.h = m;

                        srcStrtX = wSrcXY.xy16.x;

                        while (freeCount < 4)
                            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                        freeCount -= 4;

                        npDev->subchannel[NV_DD_SPARE].SetObject =
                        NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
                        ppdev->dDrawSpareSubchannelObject =
                        NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;

                        // wait for any pending notification operation to finish
                        while ((volatile)pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV_IN_PROGRESS);

                        pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV_IN_PROGRESS;

                        while (freeCount < 32)
                            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                        freeCount -= 32;

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
                        dwSrcOffset +
                        ((dwSrcPitch + skipSrcBytes) * (unsigned long)wSrcXY.xy16.y) +
                        ((unsigned long)wSrcXY.xy16.x << 2);

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
                        (srcStrtX << 2);

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
                        (dwSrcPitch + skipSrcBytes);

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
                        dwSrcPitch;

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
                        (unsigned long)(wSrcExt.wh16.w << 2);

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
                        m;

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
                        1 | (1 << 8);
                        //NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1;

                        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify =
                        0;

                        // wait for Dma operation to finish
                        while ((volatile)pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV_IN_PROGRESS);

                        if (doMirrorUpDown)
                            wSrcXY.xy16.y -= (m + skipV);
                        else
                            wSrcXY.xy16.y += (m + skipV);
                        }

                    /* Convert to 12.4 format */
                    wDstPoint.xy16.x = (wDestXY.xy16.x << 4);
                    wDstPoint.xy16.y = (wDestXY.xy16.y << 4);

                    /* convert to 16.16 */
                    lastDstY = (wDestXY.xy16.y + wXYext.wh16.h) << 16;

                    /* convert to 16.16 */
                    curDstY = (wDestXY.xy16.y << 16);

                    while (freeCount < 7*4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                    freeCount -= 7*4;

                    npDev->dDrawStretch.SetObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;
                    ppdev->dDrawSpareSubchannelObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;

                    npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipPoint =
                    wDestXY.xy;

                    npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipSize =
                    wXYext.wh;

                    npDev->dDrawStretch.nv4StretchedImageFromCpu.SizeIn = wSrcExt.wh;

                    npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDxDu = deltaX;

                    npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDyDv = deltaY;

                    npDev->dDrawStretch.nv4StretchedImageFromCpu.Point12d4 = wDstPoint.xy;

                    while ((n > 0) && (curDstY < lastDstY))
                        {
                        FAST unsigned long *pSrcBits;
                        FAST unsigned long tmpPxls0, tmpPxls1, tmpPxls2;

                        if (srcInVideoMemory)
                            {
                            if (bufState == 0)
                                pSrcBits = (unsigned long *)(pScanlineBuffer +
                                                             (srcStrtX << 2));
                            else
                                pSrcBits = (unsigned long *)(pScanlineBuffer +
                                                             (NV_DMA_SCANLINE_BUF_SIZE >> 1) +
                                                             (srcStrtX << 2));

                            pSrcCurScan = (unsigned char *)pSrcBits;

                            if (m > 0)
                                {
                                pDmaToMemNotifier[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV_IN_PROGRESS;

                                while (freeCount < 9*4)
                                    freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                                freeCount -= 9*4;
                                npDev->subchannel[NV_DD_SPARE].SetObject = NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
                                ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
                                dwSrcOffset +
                                ((dwSrcPitch + skipSrcBytes) * (unsigned long)wSrcXY.xy16.y) +
                                ((unsigned long)wSrcXY.xy16.x << 2);

                                if (bufState == 0)
                                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
                                    (NV_DMA_SCANLINE_BUF_SIZE >> 1) +
                                    (srcStrtX << 2);
                                else
                                    npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
                                    (srcStrtX << 2);

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
                                (dwSrcPitch + skipSrcBytes);

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
                                dwSrcPitch;

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
                                (unsigned long)(wSrcExt.wh16.w << 2);

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
                                m;

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
                                1 | (1 << 8);
                                //NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_1;

                                npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify =                                0;

                                bufState ^= 1;

                                if (doMirrorUpDown)
                                    wSrcXY.xy16.y -= (m + skipV);
                                else
                                    wSrcXY.xy16.y += (m + skipV);

                                while (freeCount < 7*4)
                                    freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                                freeCount -= 7*4;
                                npDev->dDrawStretch.SetObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;
                                ppdev->dDrawSpareSubchannelObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;

                                npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipPoint =
                                wDestXY.xy;
                                npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipSize =
                                wXYext.wh;
                                npDev->dDrawStretch.nv4StretchedImageFromCpu.SizeIn =
                                wSrcExt.wh;
                                npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDxDu =
                                deltaX;
                                npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDyDv =
                                deltaY;
                                npDev->dDrawStretch.nv4StretchedImageFromCpu.Point12d4 =
                                wDstPoint.xy;
                                }
                            }
                        else
                            { // source in system memory
                            pSrcBits = (unsigned long *)pSrcCurScan;
                            pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                            n--;
                            }

                        doNxtSrcScan:          pxlCount = (short)dwSrcWidth;

                        while (pxlCount >= 16)
                            {

                            pxlCount -= 16;

                            while (freeCount < 64)
                                freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                            freeCount -= 64;

                            tmpPxls0 = pSrcBits[0];
                            tmpPxls1 = pSrcBits[1];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[0] = tmpPxls0;
                            tmpPxls2 = pSrcBits[2];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[1] = tmpPxls1;
                            tmpPxls0 = pSrcBits[3];
                            tmpPxls1 = pSrcBits[4];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[2] = tmpPxls2;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[3] = tmpPxls0;
                            tmpPxls2 = pSrcBits[5];
                            tmpPxls0 = pSrcBits[6];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[4] = tmpPxls1;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[5] = tmpPxls2;
                            tmpPxls1 = pSrcBits[7];
                            tmpPxls2 = pSrcBits[8];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[6] = tmpPxls0;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[7] = tmpPxls1;
                            tmpPxls0 = pSrcBits[9];
                            tmpPxls1 = pSrcBits[10];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[8] = tmpPxls2;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[9] = tmpPxls0;
                            tmpPxls2 = pSrcBits[11];
                            tmpPxls0 = pSrcBits[12];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[10] = tmpPxls1;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[11] = tmpPxls2;
                            tmpPxls1 = pSrcBits[13];
                            tmpPxls2 = pSrcBits[14];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[12] = tmpPxls0;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[13] = tmpPxls1;
                            tmpPxls0 = pSrcBits[15];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[14] = tmpPxls2;
                            pSrcBits += 16;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[15] = tmpPxls0;
                            }

                        while (pxlCount >= 8)
                            {

                            pxlCount -= 8;

                            while (freeCount < 32)
                                freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                            freeCount -= 32;

                            tmpPxls0 = pSrcBits[0];
                            tmpPxls1 = pSrcBits[1];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[0] = tmpPxls0;
                            tmpPxls2 = pSrcBits[2];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[1] = tmpPxls1;
                            tmpPxls0 = pSrcBits[3];
                            tmpPxls1 = pSrcBits[4];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[2] = tmpPxls2;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[3] = tmpPxls0;
                            tmpPxls2 = pSrcBits[5];
                            tmpPxls0 = pSrcBits[6];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[4] = tmpPxls1;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[5] = tmpPxls2;
                            tmpPxls1 = pSrcBits[7];
                            pSrcBits += 8;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[6] = tmpPxls0;
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[7] = tmpPxls1;
                            }

                        while (freeCount < 32)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 32;

                        while (--pxlCount >= 0)
                            {
                            tmpPxls0 = pSrcBits[0];
                            npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[0] = tmpPxls0;
                            pSrcBits += 1;
                            }

                        if (srcInVideoMemory)
                            {
                            if (--m > 0)
                                {
                                pSrcCurScan += dwSrcPitch;

                                pSrcBits = (unsigned long *)pSrcCurScan;

                                goto doNxtSrcScan;
                                }
                            else
                                {
                                if (dwSrcPitch <= 1600)
                                    {
                                    m = 8;
                                    curDstY += (deltaDstY >> 1);
                                    }
                                else if (dwSrcPitch <= 3200)
                                    {
                                    m = 4;
                                    curDstY += (deltaDstY >> 2);
                                    }
                                else
                                    {
                                    m = 2;
                                    curDstY += (deltaDstY >> 3);
                                    }
                                /* convert 16.16 to 12.4 */
                                wDstPoint.xy16.y = (short)(curDstY >> 12);

                                // wait for DMA operation to finish
                                while ((volatile)pDmaToMemNotifier[NV076_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);
                                }
                            }
                        }
                    /* restore default object */
                    while (freeCount < 4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                    freeCount -= 4;

                    npDev->dDrawStretch.SetObject = NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
                    ppdev->dDrawSpareSubchannelObject = NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;

                    }
                else
                    { // OK to use SCALED IMAGE
                    NvNotification *pDmaToMemNotifier;
                    unsigned char *pScanlineBuffer;
                    unsigned char *npPixelBuf;
                    long srcScanLength;
                    long nxtSrcScan;
                    unsigned long n;
                    unsigned char *pSrcInitBits;
                    unsigned char *pSaveSrcInitBits;
                    unsigned long *pSaveSrcBits;
                    unsigned long *pSrcCurScan;
                    long srcDeltaX;
                    long srcDeltaY;
                    unsigned long dstDeltaScans;
                    unsigned long dstDeltaX;
                    unsigned long dstDeltaY;
                    long srcInitFract;
                    long srcStartFract;
                    long srcCurFract;
                    long srcDeltaFract;
                    long srcDeltaScans;
                    long xStretch;
                    long yStretch;
                    long srcBufferPitch;
                    long skipSrcBytes = 0;
                    long dstStartY;
                    long dstCurY;
                    long curV;
                    long skipV = 0;
                    long m;
                    long srcFinalHeight;
                    NVCOORD wSrcPoint;
                    NVCOORD wSrcExt;
                    NVCOORD wDstPoint;
                    NVCOORD wDstExt;
                    BYTE srcInVideoMemory = 0;
                    BYTE srcTooWide = 0;
                    short curBuffer;

                    pSrcInitBits = (unsigned char *) dwSrcOffset;
                    if (dwSrcCaps & DDSCAPS_VIDEOMEMORY)
                        pSrcInitBits += (ULONG) ppdev->pjFrameBufbase;

                    if (isVideo < 2)
                        srcScanLength = dwSrcPitch;
                    else
                        srcScanLength = dwSrcPitch >> 1;

                    ppdev->NVFreeCount = freeCount;
                    DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
                    freeCount = ppdev->NVFreeCount;

                    while (freeCount < 4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
                    freeCount -= 4;

                    npDev->dDrawRop.SetRop5 = dwRop;

                    if (isVideo < 2)
                        srcBufferPitch = dwSrcWidth << 2;
                    else
                        srcBufferPitch = dwSrcWidth << 1;

                    srcDeltaScans = (NV_DMA_SCANLINE_BUF_SIZE >> 1) -   /* allow for 2 extra src scanlines */
                                    - (srcBufferPitch << 1);
                    srcDeltaScans /= srcBufferPitch;

                    /* limiting source scans per DMA increases parallelism */
                    if (srcDeltaScans > 32)
                        srcDeltaScans = 32;
                    else if (srcDeltaScans > 16)
                        srcDeltaScans = 16;
                    else if (srcDeltaScans > 8)
                        srcDeltaScans = 8;
                    else if (srcDeltaScans > 4)
                        srcDeltaScans = 4;
                    else
                        srcDeltaScans = 2;

                    /* check for divide by 0 */
                    if ((dwDstWidth < 1) || (dwDstHeight < 1))
                        {
                        pbd->ddRVal = DDERR_INVALIDRECT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }

                    n = (dwSrcWidth << 20) / dwDstWidth;

                    if (n == 0x100000)
                        n = 0;
                    else
                        {
                        n >>= 20;
                        n += 1;
                        }

                    srcDeltaX = dwSrcWidth << 20;
                    srcDeltaX /= (dwDstWidth + n);

                    n = (dwSrcHeight << 20) / dwDstHeight;

                    if (n == 0x100000)
                        n = 0;
                    else
                        {
                        n >>= 20;
                        n += 1;
                        }

                    srcDeltaY = dwSrcHeight << 20;
                    srcDeltaY /= (dwDstHeight + n);

                    /* Algorithm can't handle a scale factor that is too large */
                    if (srcDeltaY > 0x40000000)
                        {
                        pbd->ddRVal = DDERR_INVALIDRECT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }

                    /* If shrinking in vertical direction then adjust to skip src scanlines */
                    if (srcDeltaY >= (srcDeltaScans << 20))
                        { /* limit Y delta range to acceptable range */
                        skipSrcBytes = srcScanLength;
                        skipV = 1;
                        while (srcDeltaY >= (srcDeltaScans << 20))
                            {
                            srcDeltaY >>= 1;
                            skipSrcBytes <<= 1;
                            skipV <<= 1;
                            }
                        skipSrcBytes -= srcScanLength;
                        skipV -= 1;
                        }

                    /* Algorithm can't handle scale factor that is too small */
                    if ((srcDeltaY & 0xFFFFFC00) == 0)
                        {
                        pbd->ddRVal = DDERR_INVALIDRECT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }

                    yStretch = 0x40000000 / ((srcDeltaY + 0x00000200) >> 10);

                    dstDeltaY = srcDeltaScans * yStretch;  // how many dst scanlines will srcDeltaScans scanlines generate

                    dstDeltaScans = dstDeltaY >> 20;

                    if (dstDeltaScans == 0)
                        { /* if shrinking too much then can't handle */
                        pbd->ddRVal = DDERR_INVALIDRECT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }

                    if (wSrcXY.xy16.y + dwSrcHeight > src->wHeight)
                        dwSrcHeight = src->wHeight - wSrcXY.xy16.y;

                    if (isVideo < 2)
                        nxtSrcScan = (srcScanLength >> 2);
                    else
                        nxtSrcScan = (srcScanLength >> 1);

                    if (doMirrorUpDown)
                        {
                        wSrcXY.xy16.y += (short)(dwSrcHeight - 1);
                        srcDeltaY =- srcDeltaY;
                        nxtSrcScan = -nxtSrcScan;
                        skipSrcBytes = -skipSrcBytes;
                        }

                    pDmaToMemNotifier = (NvNotification *)ppdev->Notifiers->DmaToMem;
                    pScanlineBuffer = (unsigned char *)ppdev->NvScanlineBufferFlat;

                    srcDeltaFract = (dstDeltaScans << 20) / srcDeltaScans;

                    srcDeltaFract &= 0xFFFFF;

                    wSrcPoint.xy = 0;

                    /* Calculate initial source fractional X */
                    if ((srcDeltaX > 0x40000000) || ((srcDeltaX & 0xFFFFFC00) == 0))
                        {
                        pbd->ddRVal = DDERR_INVALIDRECT;
                        ppdev->NVFreeCount = freeCount;
                        return DDHAL_DRIVER_HANDLED;
                        }

                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    dstDeltaX = ((long)wSrcXY.xy16.x << 16) / (srcDeltaX >> 4);

                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    srcInitFract = dstDeltaX * (srcDeltaX >> 4);

                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    while (srcInitFract >> 16 < wSrcXY.xy16.x)
                        srcInitFract += (srcDeltaX >> 4);

                    /* Convert to 12.4 format */
                    wSrcPoint.xy16.x = (short)(srcInitFract & 0xFFFF) >> 12;

                    // DMAable ?
                    if ((isVideo > 3) || ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                                          ((dwSrcCaps & DDSCAPS_TEXTURE) == 0) ||
                                          isOverlappingVmem))
                        {

                        /* Calculate initial source fractional Y */
                        /* Do this math in 16.16 precision to avoid 12. overflow */
                        dstDeltaY = ((long)wSrcXY.xy16.y << 16) / (srcDeltaY >> 4);

                        /* Do this math in 16.16 precision to avoid 12. overflow */
                        srcInitFract = dstDeltaY * (srcDeltaY >> 4);

                        /* Do this math in 16.16 precision to avoid 12. overflow */
                        while (srcInitFract >> 16 < wSrcXY.xy16.y)
                            srcInitFract += (srcDeltaY >> 4);

                        /* Convert result back to 12.20 precision */
                        srcInitFract <<= 4;

                        srcInitFract &= 0xFFFFF;

                        srcCurFract = srcInitFract;

                        if (isVideo < 4)
                            {
                            srcInVideoMemory = 1;

                            wSrcPoint.xy16.y += (short)srcCurFract >> 16;

                            if (doMirrorUpDown)
                                {
                                pSaveSrcBits = (unsigned long *)
                                               (pSrcInitBits - ppdev->pjFrameBufbase);
                                wSrcPoint.xy16.y += ((short)(dwSrcHeight - 1) << 4);
                                }
                            else
                                {
                                if (isVideo < 2)
                                    pSaveSrcBits = (unsigned long *)
                                                   ((pSrcInitBits - ppdev->pjFrameBufbase) +
                                                    (wSrcXY.xy16.y * srcScanLength));
                                else
                                    pSaveSrcBits = (unsigned long *)
                                                   ((pSrcInitBits - ppdev->pjFrameBufbase) +
                                                    (wSrcXY.xy16.y * (srcScanLength << 1)));
                                }
                            }
                        else
                            {

                            wSrcPoint.xy16.y += (short)srcCurFract >> 16;

                            if (doMirrorUpDown)
                                {
                                pSaveSrcBits = 0;
                                wSrcPoint.xy16.y += ((short)(dwSrcHeight - 1) << 4);
                                }
                            else
                                {
                                pSaveSrcBits = (unsigned long *)
                                               (wSrcXY.xy16.y * (srcScanLength << 1));
                                }
                            }

                        if (isVideo < 2)
                            pSaveSrcBits += wSrcXY.xy16.x;
                        else
                            pSaveSrcBits += (wSrcXY.xy16.x >> 1);

                        while (freeCount < 4)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 4;

                        if (isVideo < 2)
                            {
                            npDev->subchannel[NV_DD_STRETCH].SetObject =
                            NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
                            }
                        else if (isVideo == 2)
                            {
                            npDev->subchannel[NV_DD_STRETCH].SetObject =
                            NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
                            }
                        else if (isVideo == 3)
                            {
                            npDev->subchannel[NV_DD_STRETCH].SetObject =
                            NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
                            }
                        else if (isVideo == 4)
                            {
                            npDev->subchannel[NV_DD_STRETCH].SetObject =
                            NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                            }
                        else if (isVideo == 5)
                            {
                            npDev->subchannel[NV_DD_STRETCH].SetObject =
                            NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                            }
                        else if (isVideo == 6)
                            {
                            npDev->subchannel[NV_DD_STRETCH].SetObject =
                            NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                            }
                        else if (isVideo == 7)
                            {
                            npDev->subchannel[NV_DD_STRETCH].SetObject =
                            NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                            }

                        }
                    else
                        {
                        if (isVideo < 2)
                            {
                            pSaveSrcBits = (unsigned long *)(pSrcInitBits +
                                                             (wSrcXY.xy16.y * srcScanLength));
                            pSaveSrcBits += wSrcXY.xy16.x;
                            }
                        else
                            {
                            pSaveSrcBits = (unsigned long *)(pSrcInitBits +
                                                             (wSrcXY.xy16.y * (srcScanLength << 1)));
                            pSaveSrcBits += (wSrcXY.xy16.x >> 1);
                            }

                        pSrcCurScan = pSaveSrcBits;

                        while (freeCount < 1*4)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 1*4;

                        if (isVideo == 2)
                            {
                            npDev->subchannel[NV_DD_STRETCH].SetObject =
                            NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
                            }
                        else if (isVideo == 3)
                            {
                            npDev->subchannel[NV_DD_STRETCH].SetObject =
                            NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                            ppdev->dDrawSpareSubchannelObject = NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
                            }
                        }

                    while (freeCount < 4*4)
                        freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                    freeCount -= 4*4;

                    pSaveSrcInitBits = (unsigned char *)pSaveSrcBits;

                    npDev->dDrawStretch.nv4ScaledImageFromMemory.ClipPoint =
                    wDestXY.xy;

                    npDev->dDrawStretch.nv4ScaledImageFromMemory.ClipSize =
                    wXYext.wh;

                    npDev->dDrawStretch.nv4ScaledImageFromMemory.DeltaDuDx = srcDeltaX;
                    npDev->dDrawStretch.nv4ScaledImageFromMemory.DeltaDvDy = srcDeltaY;


                    wDstExt.wh = wXYext.wh;

                    /* NV3 hardware can only handle a maximum source width of 1024 */
                    if (dwSrcWidth > 1024)
                        {
                        srcTooWide = 1;
                        xStretch = 0x40000000 / (srcDeltaX >> 10);
                        dstDeltaX = (xStretch * 1024) >> 20;
                        wDstExt.wh16.w = (unsigned short)dstDeltaX;
                        srcBufferPitch = 4096;
                        }

                    // wait for any pending notification operation to finish
                    while ((volatile)pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);

                    // Let the world know we are doing DMA operations
                    ppdev->NvDmaFromMemSurfaceMem = dwSrcOffset;
                    if (dwSrcCaps & DDSCAPS_VIDEOMEMORY)
                        ppdev->NvDmaFromMemSurfaceMem += (ULONG) ppdev->pjFrameBufbase;


                    oneMorePass:       n = dwDstHeight;

                    /* Calculate initial source fractional Y */
                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    dstDeltaY = ((long)wSrcXY.xy16.y << 16) / (srcDeltaY >> 4);

                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    srcInitFract = dstDeltaY * (srcDeltaY >> 4);

                    /* Do this math in 16.16 precision to avoid 12. overflow */
                    while (srcInitFract >> 16 < wSrcXY.xy16.y)
                        srcInitFract += (srcDeltaY >> 4);

                    /* Convert result back to 12.20 precision */
                    srcInitFract <<= 4;

                    srcInitFract &= 0xFFFFF;

                    srcCurFract = srcInitFract;

                    curV = 0;

                    wDstPoint.xy = wDestXY.xy;

                    dstStartY = dstCurY = wDestXY.xy16.y;

                    curBuffer = 0;

                    if ((srcInVideoMemory) || (isVideo > 3))
                        { // DMAable ?

                        // wait for any pending notification operation to finish
                        while ((volatile)pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);

                        pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status = NV_IN_PROGRESS;

                        while (freeCount < 28)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 28;

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutPoint =
                        wDstPoint.xy;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutSize =
                        wDstExt.wh;

                        if ((dwSrcWidth < 16))
                            { // workaround for NV5 hardware bug
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                            asmMergeCoords((unsigned short)((dwSrcPitch + 1) & ~1), dwSrcHeight);
                            }
                        else
                            {
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                            asmMergeCoords((unsigned short) ((dwSrcWidth + 1) & ~1), dwSrcHeight);
                            }

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInFormat =
                            (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                            (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                            dwSrcPitch;


                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInOffset =
                        (unsigned long)pSaveSrcBits;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.Notify =
                        0;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInPoint =
                        wSrcPoint.xy;

                        n = 0;
                        }

                    while (n >= dstDeltaScans)
                        {
                        FAST unsigned long *pSrcBits;

                        n -= dstDeltaScans;
                        srcStartFract = srcCurFract;
                        srcCurFract += srcDeltaFract;
                        if (curBuffer == 0)
                            npPixelBuf = (unsigned char *)pScanlineBuffer;
                        else
                            npPixelBuf = (unsigned char *)(pScanlineBuffer +
                                                           (NV_DMA_SCANLINE_BUF_SIZE >> 1));

                        /* Must recalculate on each pass since src scanlines may be used more than once */
                        pSrcBits = (unsigned long *)(pSaveSrcInitBits +
                                                     (curV * (nxtSrcScan << 2)));

                        pSrcCurScan = pSrcBits;

                        m = srcDeltaScans + (srcCurFract >> 20) + 1;

                        if (skipV)
                            {
                            if ((long)dwSrcHeight - curV < (m * (skipV + 1)))
                                m = ((long)dwSrcHeight - curV) / (skipV + 1);
                            }
                        else
                            {
                            if ((long)dwSrcHeight - curV < m)
                                m = (long)dwSrcHeight - curV;
                            }

                        /* Copy and convert a block of source pixels to transfer buffer */
                        while (--m >= 0)
                            {
                            if (pSrcBits >= (unsigned long *)pSrcInitBits)
                                {
                                //                           asmCopyScan(pSrcBits, npPixelBuf, srcBufferPitch);
                                _asm
                                {
#ifdef P6
                                    mov ecx, dword ptr srcBufferPitch
                                    mov esi, dword ptr pSrcBits
                                    shr ecx, 5
                                    nxtCacheLine: mov eax, [esi]
                                    add esi, 32
                                    dec ecx
                                    jg nxtCacheLine
#endif /* P6 */
                                    mov ecx, dword ptr srcBufferPitch
                                    mov esi, dword ptr pSrcBits
                                    shr ecx, 2
                                    mov edi, dword ptr npPixelBuf
                                    test ecx, 1
                                    jz doQwords
                                    mov eax, [esi]
                                    add esi, 4
                                    mov [edi], eax
                                    add edi, 4
                                    doQwords: shr ecx, 1
                                    jz copyDone
                                    nxtQword: mov eax, [esi]
                                    mov edx, [esi+4]
                                    add edi, 8
                                    add esi, 8
                                    dec ecx
                                    mov [edi-8], eax
                                    mov [edi-4], edx
                                    copyDone: jg nxtQword
                                }
                                }
                            npPixelBuf += srcBufferPitch;
                            pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                            pSrcBits = (unsigned long *)pSrcCurScan;
                            curV += skipV;
                            }

                        /* wait for Dma operation to finish */
                        while (pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);

                        pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status = NV_IN_PROGRESS;

                        wDstPoint.xy16.y = (short)dstCurY;
                        wDstExt.wh16.h = (unsigned short)dstDeltaScans;
                        wSrcPoint.xy16.y = (short)srcStartFract >> 16; /* convert V to 12.4 */
                        wSrcExt.wh = srcDeltaScans + (srcCurFract >> 20) + 1;
                        wSrcExt.wh <<= 16;    /* shift V extent into place */
                        wSrcExt.wh |= (unsigned short) ((dwSrcWidth + 1) & ~1);

                        while (freeCount < 28)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 28;

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutPoint =
                        wDstPoint.xy;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutSize =
                        wDstExt.wh;
                        if (dwSrcWidth < 16)
                            {
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                                (wSrcExt.wh & 0xffff0000) | dwSrcPitch;
                            }
                        else
                            {
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                            wSrcExt.wh;
                            }

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInFormat =
                            (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                            (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                            srcBufferPitch;

                        if (curBuffer == 0)
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInOffset =
                            0;
                        else
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInOffset =
                            (NV_DMA_SCANLINE_BUF_SIZE >> 1);

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.Notify =
                        0;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInPoint =
                        wSrcPoint.xy;

                        curBuffer ^= 1;
                        dstCurY += dstDeltaScans;

                        srcCurFract = ((dstCurY - dstStartY) * srcDeltaY) + srcInitFract;

                        curV = srcCurFract >> 20;
                        srcCurFract &= 0xFFFFF;

                        curV += (curV - 1) * skipV;
                        if (curV > (long)dwSrcHeight - 1)
                            curV = (long)dwSrcHeight - 1;
                        }

                    if (n > 0)
                        {
                        FAST unsigned long *pSrcBits;

                        srcStartFract = srcCurFract;
                        srcCurFract += srcDeltaFract;
                        if (curBuffer == 0)
                            npPixelBuf = (unsigned char *)pScanlineBuffer;
                        else
                            npPixelBuf = (unsigned char *)(pScanlineBuffer +
                                                           (NV_DMA_SCANLINE_BUF_SIZE >> 1));

                        /* Must recalculate since src scanlines may be used more than once */
                        pSrcBits = (unsigned long *)(pSaveSrcInitBits +
                                                     (curV * (nxtSrcScan << 2)));

                        pSrcCurScan = pSrcBits;

                        m = srcDeltaScans + (srcCurFract >> 20) + 1;

                        srcFinalHeight = m;

                        if (skipV)
                            {
                            if ((long)dwSrcHeight - curV < (m * (skipV + 1)))
                                srcFinalHeight = ((long)dwSrcHeight - curV) / (skipV + 1);
                            }
                        else
                            {
                            if ((long)dwSrcHeight - curV < m)
                                srcFinalHeight = (long)dwSrcHeight - curV;
                            }

                        /* Copy and convert a block of source pixels to transfer buffer */
                        while (--m >= 0)
                            {
                            if (pSrcBits >= (unsigned long *)pSrcInitBits)
                                {
                                //                           asmCopyScan(pSrcBits, npPixelBuf, srcBufferPitch);
                                _asm
                                {
#ifdef P6
                                    mov ecx, dword ptr srcBufferPitch
                                    mov esi, dword ptr pSrcBits
                                    shr ecx, 5
                                    nxtCacheLine2: mov eax, [esi]
                                    add esi, 32
                                    dec ecx
                                    jg nxtCacheLine2
#endif /* P6 */
                                    mov ecx, dword ptr srcBufferPitch
                                    mov esi, dword ptr pSrcBits
                                    shr ecx, 2
                                    mov edi, dword ptr npPixelBuf
                                    test ecx, 1
                                    jz doQwords2
                                    mov eax, [esi]
                                    add esi, 4
                                    mov [edi], eax
                                    add edi, 4
                                    doQwords2: shr ecx, 1
                                    jz copyDone2
                                    nxtQword2: mov eax, [esi]
                                    mov edx, [esi+4]
                                    add edi, 8
                                    add esi, 8
                                    dec ecx
                                    mov [edi-8], eax
                                    mov [edi-4], edx
                                    copyDone2: jg nxtQword2
                                }
                                }
                            npPixelBuf += srcBufferPitch;
                            if (--srcFinalHeight > 0)
                                pSrcCurScan += (nxtSrcScan + skipSrcBytes);
                            pSrcBits = (unsigned long *)pSrcCurScan;
                            curV += skipV;
                            }

                        /* wait for Dma operation to finish */
                        while (pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status == NV_IN_PROGRESS);

                        pDmaToMemNotifier[NV077_NOTIFIERS_NOTIFY].status = NV_IN_PROGRESS;

                        wDstPoint.xy16.y = (short)dstCurY;
                        wDstExt.wh16.h = (unsigned short)n;
                        wSrcPoint.xy16.y = (short)srcStartFract >> 16; /* convert V to 12.4 */
                        wSrcExt.wh = srcDeltaScans + (srcCurFract >> 20) + 1;
                        wSrcExt.wh <<= 16;    /* shift V extent into place */
                        wSrcExt.wh |= (unsigned short)((dwSrcWidth + 1) & ~1);

                        while (freeCount < 28)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 28;

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutPoint =
                        wDstPoint.xy;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageOutSize =
                        wDstExt.wh;

                        // NV5 hw bug workaround
                        if (dwSrcWidth < 16)
                            {
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                                (wSrcExt.wh & 0xffff0000) | dwSrcPitch;
                            }
                        else
                            {
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInSize =
                            wSrcExt.wh;
                            }

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInFormat =
                            (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |
                            (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                            srcBufferPitch;

                        if (curBuffer == 0)
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInOffset =
                            0;
                        else
                            npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInOffset =
                            (NV_DMA_SCANLINE_BUF_SIZE >> 1);

                        npDev->dDrawStretch.nv4ScaledImageFromMemory.Notify =
                        0;
                        npDev->dDrawStretch.nv4ScaledImageFromMemory.ImageInPoint =
                        wSrcPoint.xy;
                        }

                    if (srcTooWide)
                        {
                        srcTooWide = 0;
                        wDestXY.xy16.x += (short)dstDeltaX;
                        wDstExt.wh16.w = wXYext.wh16.w - wDstExt.wh16.w;
                        if ((srcInVideoMemory) || (isVideo > 3))
                            wSrcPoint.xy16.x += (1024 << 4);
                        srcBufferPitch = dwSrcWidth << 2;
                        srcBufferPitch -= 4096;
                        pSaveSrcInitBits += 1024;
                        pSaveSrcBits = (unsigned long *)pSaveSrcInitBits;
                        pSrcCurScan = pSaveSrcBits;
                        goto oneMorePass;
                        }

                    if ((srcInVideoMemory) || (isVideo > 1))
                        {

                        while (freeCount < 4)
                            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                        freeCount -= 4;

                        npDev->subchannel[NV_DD_STRETCH].SetObject =
                        NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
                        ppdev->dDrawSpareSubchannelObject = NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
                        }
                    }
                    if (isOverlappingVmem && lpSurfTemp)
                        {
                        NVHEAP_FREE(lpSurfTemp);
                        }
                }

            if (dwFlags & DDBLT_KEYSRCOVERRIDE)
                {
                /* disable chroma key */
                while (freeCount < 2*4)
                    freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
                freeCount -= 2*4;
                if (ppdev->dDrawSpareSubchannelObject != NV_DD_IMAGE_SOLID)
                    {
                    npDev->dDrawSpare.SetObject = NV_DD_IMAGE_SOLID;
                    ppdev->dDrawSpareSubchannelObject = NV_DD_IMAGE_SOLID;
                    }
                npDev->dDrawTransColor.SetColor = 0;
                }
            }
        else
            {
            DPF("BLT     blt not handled by driver");
            ppdev->NVFreeCount = freeCount;
            return DDHAL_DRIVER_NOTHANDLED;
            }
        }
    else if (dwFlags & DDBLT_COLORFILL)
        {
        dwFillColor = (pbd->bltFX.dwFillColor & ppdev->physicalColorMask) | ppdev->AlphaEnableValue;

        ppdev->NVFreeCount = freeCount;
        DDRAW_SET_PRIMARY(ppdev, dwDstOffset, dwDstPitch);
        freeCount = ppdev->NVFreeCount;

        while (freeCount < 16)
            freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
        freeCount -= 16;

        npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;
        npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.Color1A = dwFillColor;

        npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].point =
        asmMergeCoords(wDestXY.xy16.y, wDestXY.xy16.x);

        npDev->subchannel[NV_DD_RECT_AND_TEXT].Nv04GdiRectangleText.UnclippedRectangle[0].size =
        asmMergeCoords(wXYext.wh16.h, wXYext.wh16.w);

        }
    else if (dwFlags & DDBLT_ZBUFFER)
        {
        /* Hardware Z buffer fills not currently supported when in 32bpp mode */
        DPF("HARDWARE Z BUFFER BLT FAILED");
        ppdev->NVFreeCount = freeCount;
        return DDHAL_DRIVER_NOTHANDLED;
        }
    else
        {
        /* We don't handle any other type of BLT operation */
        ppdev->NVFreeCount = freeCount;
        return DDHAL_DRIVER_NOTHANDLED;
        }

    ppdev->NVFreeCount = freeCount;
    pbd->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;

    } /* Nv4Blt32 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\nvdbg_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvDbg_link.cpp
//      a pointer to a shared file
//
// **************************************************************************

#include "..\..\..\..\common\src\nvDbg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\nv4subch.h ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     nv4subch.h
//
// Abstract:
//
//     This module contains the object subchannel definitions
//
// Environment:
//
//     Kernel mode
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
// ddraw SubChannel assignments for objects
//******************************************************************************
#define NV_DD_ROP                      0
#define NV_DD_BLIT                     1
#define NV_DD_RECT_AND_TEXT            2
#define NV_DD_PRIMARY                  3
#define NV_DD_IMAGE                    4
#define NV_DD_PATTERN                  5
#define NV_DD_CLIP                     6
#define NV_DD_STRETCH                  7
#define NV_DD_SPARE                    7

/* Default cached objects in Windows 95 Direct Draw patch */
#define dDrawRop                       subchannel[NV_DD_ROP].nv3ContextRop
#define dDrawImageInMemory             subchannel[NV_DD_SPARE].nvImageInMemory
#define dDrawRopRectAndText            subchannel[NV_DD_RECT_AND_TEXT].nvRenderGdi0RectangleAndText
#define dDrawBlit                      subchannel[NV_DD_BLIT].nv4ImageBlit
#define dDrawImageFromCpu              subchannel[NV_DD_IMAGE].nv4ImageFromCpu
#define dDrawStretch                   subchannel[NV_DD_STRETCH]
#define dDrawTransColor                subchannel[NV_DD_SPARE].nv4ContextColorKey
#define dDrawSpare                     subchannel[NV_DD_SPARE]

#define DD_CHANNEL      1                   // DDRAW always in channel 1
#define GDI_CHANNEL     0                   // GDI always in channel 0
#define DD_CHANNEL_MASK (1 << DD_CHANNEL)   // Mask out ddraw channel

//********************************************************************
// #defines for NV4 fifo sync registers.
//********************************************************************
#define OFFSET_NV_PFIFO_BASE            0x2000
#define NV4_PFIFO_DMA                   0x2508-OFFSET_NV_PFIFO_BASE
#define NV4_PFIFO_CACHE1_PUSH1          0x3204-OFFSET_NV_PFIFO_BASE
#define NV4_PFIFO_CACHE1_DMA_PUSH       0x3220-OFFSET_NV_PFIFO_BASE
#define NV_PFIFO_CACHE1_PUSH1_MODE_DMA_BIT  0x00000100
#define CACHE1_DMA_PUSH_BUFFER_EMPTY    0x100L

//********************************************************************
// This macro is used to ensure that all DMA channel processing has
// completed prior to performing PIO writes.
//********************************************************************
#define NV_DD_DMA_PUSHER_SYNC()                                 \
{                                                               \
if (!ppdev->bDDChannelActive)                                   \
    {                                                           \
    volatile DWORD *npNvBase = (DWORD *)ppdev->PFIFORegs;       \
    volatile DWORD  regValue;                                   \
    DWORD chid;                                                 \
                                                                \
    while ((npNvBase[(NV4_PFIFO_DMA >> 2)] &                    \
            (~DD_CHANNEL_MASK)) != 0);                          \
    if ((npNvBase[NV4_PFIFO_CACHE1_PUSH1 >> 2] & NV_PFIFO_CACHE1_PUSH1_MODE_DMA_BIT) &&         \
        ((chid = (npNvBase[NV4_PFIFO_CACHE1_PUSH1 >> 2] & 0x1F)) !=      \
            (WORD)DD_CHANNEL))                                  \
        {                                                       \
            regValue = npNvBase[(NV4_PFIFO_CACHE1_DMA_PUSH >> 2)]; \
            while ((regValue & CACHE1_DMA_PUSH_BUFFER_EMPTY) == 0) { \
                regValue = npNvBase[(NV4_PFIFO_CACHE1_DMA_PUSH >> 2)]; \
            }                                                   \
            if (chid == GDI_CHANNEL)                            \
                ppdev->pfnWaitEngineBusy(ppdev);                \
        }                                                       \
        ppdev->bDDChannelActive = TRUE;                         \
        ppdev->oglLastChannel = DD_CHANNEL;                     \
    }                                                           \
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\nvpriv_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPriv_link.cpp
//      a pointer to a shared file
//
// **************************************************************************
#define PDEV_PTR() pDriverData->ppdev

#include "..\..\..\..\common\src\nvPriv.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\init.cpp ===
//******************************************************************************
//
// Copyright (c) 1995-1996 Microsoft Corporation
//
// Module Name:
//
//     NV4INIT.C
//
// Abstract:
//
//     Initialize DX driver callbacks for NV4.
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//
//******************************************************************************

#include "nvprecomp.h"
#include "nvalpha.h"
#include "ddminint.h"
#include "nv32.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "nvsubch.h"

#include "nvVPP.h"

///////////////////////////////////////////////////////////////////////////
// Local Function Declarations
///////////////////////////////////////////////////////////////////////////
static NvU8 destroyExtendedDDPatch( PDEV *ppdev );
static NvU8 createExtendedDDPatch( PDEV *ppdev );

#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free

extern void NV4_DdPioSync(PDEV*);

VOID NvDDEnable(PDEV *ppdev)
{
    ppdev->ddCallBacks.WaitForVerticalBlank = DdWaitForVerticalBlank;
    ppdev->ddCallBacks.MapMemory            = DdMapMemory;
    ppdev->ddCallBacks.GetScanLine          = GetScanLine32;
    ppdev->ddCallBacks.dwFlags              = DDHAL_CB32_WAITFORVERTICALBLANK
                                    | DDHAL_CB32_MAPMEMORY
                                    | DDHAL_CB32_GETSCANLINE;

    ppdev->ddSurfaceCallBacks.Blt           = Nv4Blt;
    ppdev->ddSurfaceCallBacks.Flip          = Nv4Flip;
    ppdev->ddSurfaceCallBacks.Lock          = Nv4Lock;
    ppdev->ddSurfaceCallBacks.Unlock        = Nv4Unlock;
    ppdev->ddSurfaceCallBacks.GetBltStatus  = Nv4GetBltStatus;
    ppdev->ddSurfaceCallBacks.GetFlipStatus = DdGetFlipStatus;
    ppdev->ddSurfaceCallBacks.DestroySurface= Nv4DestroySurface;
    ppdev->ddSurfaceCallBacks.dwFlags       = DDHAL_SURFCB32_BLT
                                       | DDHAL_SURFCB32_FLIP
                                       | DDHAL_SURFCB32_UNLOCK
                                       | DDHAL_SURFCB32_LOCK
                                       | DDHAL_SURFCB32_GETBLTSTATUS
                                       | DDHAL_SURFCB32_GETFLIPSTATUS
                                       | DDHAL_SURFCB32_DESTROYSURFACE;

    ppdev->ddCallBacks.CreateSurface             = DdCreateSurface;
    ppdev->ddCallBacks.CanCreateSurface          = DdCanCreateSurface;
    ppdev->ddCallBacks.dwFlags                   |= DDHAL_CB32_CREATESURFACE
                                             | DDHAL_CB32_CANCREATESURFACE;

    ppdev->ddSurfaceCallBacks.SetColorKey        = DdSetColorKey;
    ppdev->ddSurfaceCallBacks.UpdateOverlay      = Nv4UpdateOverlay;
    ppdev->ddSurfaceCallBacks.SetOverlayPosition = Nv4SetOverlayPosition;
    ppdev->ddSurfaceCallBacks.dwFlags           |= DDHAL_SURFCB32_SETCOLORKEY
                                            | DDHAL_SURFCB32_UPDATEOVERLAY
                                            | DDHAL_SURFCB32_SETOVERLAYPOSITION;

    ppdev->pfnUpdateFlipStatus = Nv4UpdateFlipStatus;
}

//
// create the best NV_DD_VIDEO_LUT_CURSOR_DAC object we can
//
static NvU8 createLutCursorDacObj(PPDEV ppdev,NV_SystemInfo_t *pSysInfo)
{
	NvU32 retval;
    NV07C_ALLOCATION_PARAMETERS nv07cAllocParms;

    if (pSysInfo->dwNVClasses & NVCLASS_007C_DAC)
	{
        for (nv07cAllocParms.logicalHeadId=0; 
		     nv07cAllocParms.logicalHeadId < ppdev->pDriverData->dwHeads; 
			 nv07cAllocParms.logicalHeadId++)
		{
			retval = NvAlloc(
				ppdev->hDriver,ppdev->hClient,
				NV_VPP_CHANNEL_IID,
				NV_VPP_LUT_CURSOR_DAC_IID + nv07cAllocParms.logicalHeadId,
				NV15_VIDEO_LUT_CURSOR_DAC,
				&nv07cAllocParms);
            if (retval != NVOS21_STATUS_SUCCESS)
			{
				dbgError("alloc of class 7c should have succeeded, but did not!");
                return FALSE;
            }
        }
    }
    else if (pSysInfo->dwNVClasses & NVCLASS_0067_DAC)
	{
		retval = NvAllocObject(
			ppdev->hDriver,ppdev->hClient,
			NV_VPP_CHANNEL_IID,
			NV_VPP_LUT_CURSOR_DAC_IID,
			NV10_VIDEO_LUT_CURSOR_DAC);
        if (retval != NVOS21_STATUS_SUCCESS)
		{
			dbgError("alloc of class 67 should have succeeded, but did not!");
            return FALSE;
        }
    }
    else if (pSysInfo->dwNVClasses & NVCLASS_0049_DAC)
	{
		retval = NvAllocObject(
			ppdev->hDriver,ppdev->hClient,
			NV_VPP_CHANNEL_IID,
			NV_VPP_LUT_CURSOR_DAC_IID,
			NV05_VIDEO_LUT_CURSOR_DAC);
        if (retval != NVOS21_STATUS_SUCCESS)
		{
			dbgError("alloc of class 49 should have succeeded, but did not!");
            return FALSE;
        }
    }
    else if (pSysInfo->dwNVClasses & NVCLASS_0046_DAC)
	{
		retval = NvAllocObject(
			ppdev->hDriver,ppdev->hClient,
			NV_VPP_CHANNEL_IID,
			NV_VPP_LUT_CURSOR_DAC_IID,
			NV04_VIDEO_LUT_CURSOR_DAC);
        if (retval != NVOS21_STATUS_SUCCESS)
		{
			dbgError("alloc of class 46 should have succeeded, but did not!");
            return FALSE;
        }
    }
    else
	{
        dbgError("hardware doesn't seem to support any flavor of the VIDEO_LUT_CURSOR_DAC class!");
        return FALSE;
    }

#if 0
	    for (DWORD dwHead = 0; dwHead < pDriverData->dwHeads; dwHead ++) {
        // initialize LUT-cursor-DAC object
        nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) | 0x40000);
        nvPushData (1,NV_DD_VIDEO_LUT_CURSOR_DAC + dwHead);
        nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP) + NV067_SET_CONTEXT_DMA_NOTIFIES | 0x1C0000);
        nvPushData (3,NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
        nvPushData (4,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // image a
        nvPushData (5,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // image b
        nvPushData (6,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // LUT a
        nvPushData (7,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // LUT b
        nvPushData (8,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // cursor a
        nvPushData (9,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // cursor b
        nvPushData (10,dDrawSubchannelOffset(NV_DD_ROP) + NV067_SET_DAC(0) | 0x40000);
        nvPushData (11,asmMergeCoords(GET_MODE_WIDTH(), GET_MODE_HEIGHT()));
        nvPusherAdjust (12);
    }

#endif

	return TRUE;
}

//
// Try to create a 3D object (okay if we do not get one though)
//
static NvU8 create3Dobject(PPDEV ppdev, NV_SystemInfo_t *pSysInfo)
{
	NvU32 retval;
	NvU8 bHave3DClass = FALSE;

    if (pSysInfo->dwNVClasses & NVCLASS_0097_KELVIN)
    {
        retval = NvAllocObject(ppdev->hDriver,ppdev->hClient,NV_VPP_CHANNEL_IID,NV_VPP_3D_OBJECT_IID,NV20_KELVIN_PRIMITIVE);
        if (retval != NVOS05_STATUS_SUCCESS)
        {
            dbgError("Failed to get expected class: 0x0097 kelvin");
        }
        else
        {
            bHave3DClass = TRUE;
            DPF_LEVEL(NVDBG_LEVEL_INFO, "VPP using NV20 Kelvin class");
        }
    }
    else if (pSysInfo->dwNVClasses & NVCLASS_1196_CELSIUS)
    {
        retval = NvAllocObject(ppdev->hDriver,ppdev->hClient,NV_VPP_CHANNEL_IID,NV_VPP_3D_OBJECT_IID, NV11_CELSIUS_PRIMITIVE);
        if (retval != NVOS05_STATUS_SUCCESS)
        {
            dbgError("Failed to get expected class: 1196 CELSIUS");
        }
        else
        {
            bHave3DClass = TRUE;
            DPF_LEVEL(NVDBG_LEVEL_INFO, "VPP using NV11 Celsius class");
        }
    }
    else if (pSysInfo->dwNVClasses & NVCLASS_0096_CELSIUS)
    {
        retval = NvAllocObject(ppdev->hDriver,ppdev->hClient,NV_VPP_CHANNEL_IID, NV_VPP_3D_OBJECT_IID, NV15_CELSIUS_PRIMITIVE);
        if (retval != NVOS05_STATUS_SUCCESS)
        {
            dbgError("Failed to get expected class: 0096 CELSIUS");
        }
        else
        {
            bHave3DClass = TRUE;
            DPF_LEVEL(NVDBG_LEVEL_INFO, "VPP using NV15 Celsius class");
        }
    }
    else if (pSysInfo->dwNVClasses & NVCLASS_0056_CELSIUS)
    {
        retval = NvAllocObject(ppdev->hDriver,ppdev->hClient,NV_VPP_CHANNEL_IID, NV_VPP_3D_OBJECT_IID, NV10_CELSIUS_PRIMITIVE);
        if (retval != NVOS05_STATUS_SUCCESS)
        {
            dbgError("Failed to get expected class: 0056 CELSIUS");
        }
        else
        {
            bHave3DClass = TRUE;
            DPF_LEVEL(NVDBG_LEVEL_INFO, "VPP using NV10 Celsius class");
        }
    }
    else
    {
        bHave3DClass = FALSE;
        DPF_LEVEL(NVDBG_LEVEL_INFO, "No 3D super class is available.  Vpp proceeding without one.");
    }
	return bHave3DClass;
}

//**************************************************************************
// Allocate a DMA context which points to all of video memory. The limit
// must be page aligned: i.e. limit = (size in bytes of video mem rounded to the
// closest page boundary) - 1.
//
// TBD: not sure if we can share these.  They do appear to be channel independant.
//
//**************************************************************************
static NvU8 createContextDmas(PPDEV ppdev)
{
	NvU32 retval;

    retval = NvAllocContextDma(ppdev->hDriver,ppdev->hClient,
                        NV_VPP_DMA_WITHIN_VMEM_IID,
                        NV01_CONTEXT_DMA,
                        DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                        DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                        (PVOID) VIDMEM_ADDR(ppdev->pDriverData->BaseAddress),
                        ppdev->pDriverData->TotalVRAM - 1);
    if (retval != NVOS01_STATUS_SUCCESS)
    {
        dbgError("DMA Context <within vmem>: allocation failed");
		return FALSE;
    }

    retval = NvAllocContextDma(ppdev->hDriver,ppdev->hClient,
                        NV_VPP_DMA_FROM_VMEM_IID,
                        NV01_CONTEXT_DMA,
                        DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_ONLY) |
                        DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                        (PVOID) VIDMEM_ADDR(ppdev->pDriverData->BaseAddress),
                        ppdev->pDriverData->TotalVRAM - 1);
    if (retval != NVOS01_STATUS_SUCCESS)
    {
        dbgError("DMA Context <from vmem>: allocation failed");
		return FALSE;
    }

    retval = NvAllocContextDma(ppdev->hDriver,ppdev->hClient,
                        NV_VPP_DMA_TO_VMEM_IID,
                        NV01_CONTEXT_DMA,
                        DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY) |
                        DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                        (PVOID) VIDMEM_ADDR(ppdev->pDriverData->BaseAddress),
                        ppdev->pDriverData->TotalVRAM - 1);
    if (retval != NVOS01_STATUS_SUCCESS)
    {
        dbgError("DMA Context <to vmem>: allocation failed");
		return FALSE;
    }

	// Alloc 3 notifier slots for the OVERLAY notifier
    retval = NvAllocContextDma(ppdev->hDriver,ppdev->hClient,
                        NV_VPP_OVERLAY_NOTIFIER_IID,
                        NV01_CONTEXT_DMA,
                        DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY),
                        ppdev->pDriverData->pCommonNotifierBuffer,
                        3*sizeof(NvNotification) - 1);
    if (retval != NVOS01_STATUS_SUCCESS)
    {
        dbgError("DMA Context for overlay notifier: allocation failed");
		return FALSE;
    }

	return TRUE;
}
static NvU8 allocateCommonNotifierBuffer( PPDEV ppdev )
{
    NvU32   commonBufferSize;

    dbgTracePush("allocateCommonNotifierBuffer");

    commonBufferSize = 0
		+ 3*sizeof(NvNotification)	// for NV_VPP_OVERLAY_NOTIFIER_IID & NV_VPP_OVERLAY_IID
		- 1;

    // Allocate memory for a bunch of notifiers and the scanline buffer.
    // We must allocate the memory for this structure out of SHARED or
    // SYSTEM space -- not out of App space so don't use GlobalAlloc.

	nvAssert(ppdev->pDriverData->pCommonNotifierBuffer == NULL);

    ppdev->pDriverData->pCommonNotifierBuffer = (NvV32 *)EngAllocMem(FL_ZERO_MEMORY, commonBufferSize, ALLOC_TAG);
    if (ppdev->pDriverData->pCommonNotifierBuffer == NULL)
	{
        return FALSE;
    }
	return TRUE;
}

static NvU8 createExtendedDDPatch( PDEV *ppdev )
{
    NvU32 retval;
    NvU8  bHave3DSuperClass;
    CPushBuffer &nvPusher = ppdev->pDriverData->nvPusher;

    dbgTracePush("createExtendedDDPatch");

    nvAssert(ppdev);
    nvAssert(ppdev->pDriverData);

    // Set by VPP code, but otherwise ignored on NT4
    ppdev->pDriverData->dDrawSpareSubchannelObject = 0;
    ppdev->pDriverData->ddClipUpdate               = 0;
    ppdev->pDriverData->TwoDRenderingOccurred      = 0;
    ppdev->pDriverData->blitCalled                 = FALSE;
    ppdev->pDriverData->dwDXVAFlags                = 0;  // Not really used (though VPP sets them)
    ppdev->pDriverData->dwSharedClipChangeCount    = 0;
    ppdev->pDriverData->lpProcessInfoHead          = NULL;

    // allocate a push buffer
    nvPusher.setPdev(ppdev);
    if (!nvPusher.allocate(NV_VPP_CHANNEL_IID))
    {
        dbgError("VPP: failed to allocate push buffer");
		goto fail_extended_patch;
    }
    ppdev->vppChannelNdx = 2; // TBD: compute this as in nvEnable line 1570 @mjl@

	bHave3DSuperClass = create3Dobject(ppdev,&ppdev->pDriverData->sysInfo);

	if (!(    allocateCommonNotifierBuffer(ppdev)
		   && createLutCursorDacObj(ppdev,&ppdev->pDriverData->sysInfo)
	       && createContextDmas(ppdev)
	   ))
	{
		goto fail_extended_patch;
	}

    ppdev->pDriverData->dwMostRecent3dUser = MODULE_ID_NONE;

    if (bHave3DSuperClass)
    {
        nvPusher.setObject(NV_VPP_3D_OBJECT_SUBCH, NV_VPP_3D_OBJECT_IID);
    }
    // Now set DMA context
//    nvPusher.setObject(NV_VPP_3D_OBJECT_SUBCH, NV_VPP_3D_OBJECT_IID);
//    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        // some bare bones initialization: put the thing in its channel and set up for notifers
//        nvglSetObject (NV_DD_KELVIN, D3D_KELVIN_PRIMITIVE);
//        nvglSetNv20KelvinNotifierContextDMA (NV_DD_KELVIN, NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
//    }

    if (0 && !VppEnable(
        &ppdev->pDriverData->vpp,
        ppdev,
        &ppdev->pDriverData->nvPusher,
        NV_VPP_CHANNEL_IID,
        NV_VPP_3D_OBJECT_IID,
        NV_VPP_3D_OBJECT_SUBCH,         // permanent subchannel assignment for 3d object
        &(ppdev->pDriverData->dwMostRecent3dUser),
        NV_VPP_DMA_WITHIN_VMEM_IID,     // In VideoMem DMA (all of VM)
        NV_VPP_DMA_FROM_VMEM_IID,      // From VideoMem DMA (all of VM)
        NV_VPP_DMA_TO_VMEM_IID,        // To VideoMem DMA (all of VM)
        NV_VPP_LUT_CURSOR_DAC_IID ,

        0, /* misceventnotifier (dma) -- used to be: NV_DD_DMA_COLOUR_CONTROL_EVENT_NOTIFIER */
        0, /* contextSurfaceSwizzled -- was: D3D_CONTEXT_SURFACE_SWIZZLED */
        0, //   NV_DD_CONTEXT_BETA4,
        0, //   NV_DD_SURFACES_2D,
        0, // subchannel for SURFACES_2D object
        0, // hVideoMemUtoVideoMemFormat,    // U-conversion object
        0, // hVideoMemVtoVideoMemFormat,    // V-conversion object
        0, // hVideoMemUVtoVideoMemFormat,    // UV-conversion object

        0, // NV_DD_DVD_SUBPICTURE hDvdSubpicture,
        0, // NV_DD_CONTEXT_PATTERN
        0, // NV_CONTEXT_ROP
        0, //  NV_DD_CONTEXT_COLOR_KEY,
        0, //hFloatingContextDmaInOverlayShadow NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW

        0, //(NvNotification  *)pDriverData->DMA version !pFlipPrimaryNotifier,  May be an equivalent to this - @mjl@
        0, //(NvNotification  *)pDriverData->NvDmaPusherSyncNotifierFlat,  May be an equivalent to this - @mjl@
        0, //(NvNotification  *)pDriverData->NvPioColourControlEventNotifierFlat,

        0, // D3D_CONTEXT_SURFACES_ARGB_ZS,
        0, // D3D_DX6_MULTI_TEXTURE_TRIANGLE,
        0, // NV_DD_IMAGE_BLACK_RECTANGLE -- IID

        0, // NV_DD_ROP_RECT_AND_TEXT subchannel
        0, // NV_DD_ROP subchannel
        0 /* spare sub channel */
        ))
    {
        goto fail_extended_patch;
    }

    dbgTracePop();      // Success!
    return TRUE;

fail_extended_patch:    // Failure!  

    dbgTracePop();
    destroyExtendedDDPatch(ppdev);  // Destroy any objects we may have created
    return FALSE;
}

// TBD: release all objects allocated in createExtendedDDPatch @mjl@
static NvU8 destroyExtendedDDPatch( PDEV *ppdev )
{
    NvU32 retval;
    CPushBuffer &pushBuffer = ppdev->pDriverData->nvPusher;

    // flush the push buffer before we start destroying stuff
    if (pushBuffer.isValid())
    {
        pushBuffer.flush(TRUE, CPushBuffer::FLUSH_HEAVY_POLLING);
    }

    // We may or may not have any one or more of these... so it's okay if freeing it fails
	//   (eg: if we fail part way though initial alloc)
    retval = NvFree(ppdev->hDriver,ppdev->hClient,NV_VPP_CHANNEL_IID, NV_VPP_3D_OBJECT_IID);
    retval = NvFree(ppdev->hDriver,ppdev->hClient,NV_VPP_CHANNEL_IID, NV_VPP_LUT_CURSOR_DAC_IID);
    retval = NvFree(ppdev->hDriver,ppdev->hClient,ppdev->hDevice, NV_VPP_DMA_WITHIN_VMEM_IID);
    retval = NvFree(ppdev->hDriver,ppdev->hClient,ppdev->hDevice, NV_VPP_DMA_FROM_VMEM_IID);
    retval = NvFree(ppdev->hDriver,ppdev->hClient,ppdev->hDevice, NV_VPP_DMA_TO_VMEM_IID);

    if (ppdev->pDriverData->pCommonNotifierBuffer) EngFreeMem(ppdev->pDriverData->pCommonNotifierBuffer);
    ppdev->pDriverData->pCommonNotifierBuffer = NULL;

    retval = NvFree(ppdev->hDriver,ppdev->hClient,ppdev->hDevice, NV_VPP_OVERLAY_NOTIFIER_IID);

    if (pushBuffer.isValid())
    {
        pushBuffer.free();
        pushBuffer.setPdev(NULL);
    }

    return TRUE;
}

NvU8 bCreateNVDDPatch(PDEV    *ppdev)
{
    V032    videoFmt, color0, color1;
    LONG   i;
    Nv3ChannelPio   *nv;
    NvNotification *pSyncNotifier = (NvNotification *)ppdev->Notifiers->Sync;
    ULONG   ulScaledImageClass;
    NV07A_ALLOCATION_PARAMETERS nv07aAllocParms;
    PVOID parms;
    ULONG ulHead;
    NV_CREATE_OBJECT_SETUP();

    if(!NvGetSupportedClasses(ppdev))
	{
        return FALSE;
    }

    //**********************************************************************************
    // Open a new channel for ddraw.
    //**********************************************************************************
    ppdev->hDdChannel = ppdev->hPioChannel = NV_DD_DDRAW_PIO_CHANNEL_OBJECT_HANDLE;
    if (NvAllocChannelPio(  ppdev->hDriver,
                            ppdev->hClient,
                            ppdev->hDevice,
                            ppdev->hDdChannel,
                            NV03_CHANNEL_PIO,
                            0,
                            (PVOID *) &(ppdev->ddChannelPtr),
                            0
                            ) != NVOS04_STATUS_SUCCESS)
        {
        DPF("NVDD: Cannot get NV Ddraw PIO channel");
        NvFree(ppdev->hDriver, ppdev->hClient, NV01_NULL_OBJECT, ppdev->hClient);
        NvClose(ppdev->hDriver);
        return FALSE;
        }

    //********************************************************************************
    // Ensure the 2d channel ptr is valid. We need to do this even if 2d is running in
    // DMA PUSH mode, since our waitenginebusy fcts reference the 2d channel ptr.
    //********************************************************************************
    if (ppdev->pjMmBase == NULL)
        {
        ppdev->pjMmBase = ppdev->ddChannelPtr;
        }
    nv = (Nv3ChannelPio *) ppdev->ddChannelPtr;

    //**************************************************************************
    // Allocate a DMA context which points to all of video memory. The limit
    // must be page aligned: i.e. limit = (size in bytes of video mem rounded to the
    // closest page boundary) - 1.
    //**************************************************************************

    if (NvAllocContextDma(  ppdev->hDriver,
                        ppdev->hClient,
                        NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM,
                        NV01_CONTEXT_DMA,
                        NVOS03_FLAGS_ACCESS_READ_WRITE,
                        (PVOID)(ppdev->pjFrameBufbase),
                        ppdev->cbFrameBuf - 1
                        ) != NVOS03_STATUS_SUCCESS )
    {
    DPF("NVDD: Cannot allocate dma in memory context");
    return FALSE;
    }

    if (NvAllocContextDma(  ppdev->hDriver,
                            ppdev->hClient,
                            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
                            (PVOID)(ppdev->Notifiers->DmaToMem),
                            5 * sizeof(NvNotification)
                            ) != NVOS03_STATUS_SUCCESS)
        {
        DPF("NVDD: Cannot allocate notifier context");
        return FALSE;
        }

    if (NvAllocContextDma(  ppdev->hDriver,
                            ppdev->hClient,
                            DD_FIFO_SYNC_NOTIFIER,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
                            (PVOID)(ppdev->Notifiers->Sync),
                            5 * sizeof(NvNotification)
                            ) != NVOS03_STATUS_SUCCESS)
        {
        DPF("NVDD: Cannot allocate notifier context");
        return FALSE;
        }

    //**************************************************************************
    // Determine black and white colors
    //**************************************************************************

    switch (ppdev->iBitmapFormat)
    {
        case BMF_32BPP:
            color0 =    NV_ALPHA_1_32 | 0x00000000;         // BLACK
            color1 =    NV_ALPHA_1_32 | 0x00ffffff;         // WHITE
            videoFmt = NV_VFM_FORMAT_COLOR_LE_X8R8G8B8;
            break;
        case BMF_16BPP:

            if (ppdev->flGreen == 0x03e0)
                {
                //**************************************************************
                // 5:5:5 format
                //**************************************************************
                videoFmt = NV_VFM_FORMAT_COLOR_LE_X1R5G5B5_P2;
                color0 =    NV_ALPHA_1_16 | 0x00000000;     // BLACK
                color1 =    NV_ALPHA_1_16 | 0x00007fff;     // WHITE
                }
            else
                {

                //**************************************************************
                // 5:6:5 format
                //**************************************************************

                color0 =   (NV_ALPHA_1_565 | 0x00000000);       // BLACK
                color1 =   (NV_ALPHA_1_565 | 0x0000ffff);       // WHITE
                videoFmt = NV_VFM_FORMAT_COLOR_LE_R5G6B5_P2;
                }

            break;
        case BMF_8BPP:
            color0 =    NV_ALPHA_1_08 | 0x00000000;         // BLACK
            color1 =    NV_ALPHA_1_08 | 0x000000ff;         // WHITE
            videoFmt = NV_VFM_FORMAT_COLOR_LE_Y8_P4;

            //*************************************************************************
            // Setup palette for indexed color mode.
            // allocate the colormap context (from system memory)
            //*************************************************************************
            if (NvAllocContextDma(  ppdev->hDriver,
                        ppdev->hClient,
                        NV_DD_WIN_COLORMAP_CONTEXT,
                        NV01_CONTEXT_DMA,
                        NVOS03_FLAGS_ACCESS_READ_ONLY,
                        (PVOID)(ppdev->ajClutData),
                        (256 * sizeof(VIDEO_CLUTDATA)) - 1
                        ) != NVOS03_STATUS_SUCCESS)
                {
                DPF("NVDD: Cannot allocate buffer context");
                return FALSE;
                }
            break;
        default:
            return(FALSE);
    }

    //*************************************************************************
    // allocate the dma notifier context for flip surface
    //*************************************************************************
    if (NvAllocContextDma(  ppdev->hDriver,
                            ppdev->hClient,
                            NV_DD_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
                            (PVOID)(ppdev->Notifiers->FlipPrimary),
                            9 * sizeof(NvNotification)
                            ) != NVOS03_STATUS_SUCCESS)
        {
        DPF("NVDD: Cannot allocate context dma notifier for flip surface");
        return FALSE;
        }
    ((NvNotification *) (&(ppdev->Notifiers->FlipPrimary[NV046_NOTIFIERS_SET_IMAGE(0)*sizeof(NvNotification)])))->status = 0;


    //*************************************************************************
    // allocate the dma notifier context for video overlay flip
    //*************************************************************************
    if (NvAllocContextDma(  ppdev->hDriver,
                        ppdev->hClient,
                        NV_DD_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                        NV01_CONTEXT_DMA,
                        NVOS03_FLAGS_ACCESS_WRITE_ONLY,
                        (PVOID)(ppdev->Notifiers->FlipOverlay),
                        5 * sizeof(NvNotification)
                        ) != NVOS03_STATUS_SUCCESS)
        {
        DPF("NVDD: Cannot allocate notifier context");
        return FALSE;
        }
    ((NvNotification *) (ppdev->Notifiers->FlipOverlay))->status = 0;


    //***********************************************************************************
    // Allocate a buffer for scanlines.
    //***********************************************************************************
    if ((ppdev->NvDmaBufferFlat = EngAllocMem(0, 0x8000, ALLOC_TAG)) != NULL)
        {
        ppdev->NvScanlineBufferFlat = ppdev->NvDmaBufferFlat;
        if (NvAllocContextDma(  ppdev->hDriver,
                        ppdev->hClient,
                        NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
                        NV01_CONTEXT_DMA,
                        NVOS03_FLAGS_ACCESS_READ_WRITE,
                        ppdev->NvDmaBufferFlat,
                        0x8000 - 1
                        ) != NVOS03_STATUS_SUCCESS)
            return(FALSE);
        }


    //******************************************************************************************
    // Create the NV Objects. The video back end objects are identical to NV3.
    //******************************************************************************************
    NV_CREATE_OBJECT_INIT();
    NV_CREATE_OBJECT_PIO2(NV10_CONTEXT_SURFACES_2D, NV04_CONTEXT_SURFACES_2D,
                          NV_DD_PRIMARY_SURFACE);
    if (NV_CREATE_OBJECT_FAIL()) {
        return FALSE;
    } else {
        if (NV_CREATE_OBJECT_CLASS() == NV10_CONTEXT_SURFACES_2D) {
            ulScaledImageClass = NV10_SCALED_IMAGE_FROM_MEMORY;
        } else {
            ulScaledImageClass = NV04_SCALED_IMAGE_FROM_MEMORY;
        }
    }
    
    NV_CREATE_OBJECT_INIT();
    NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_FLOATING0_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_FLOATING1_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY);
    NV_CREATE_OBJECT_PIO1(NV3_CONTEXT_ROP, NV_DD_ROP5_SOLID);
    NV_CREATE_OBJECT_PIO1(NV1_IMAGE_BLACK_RECTANGLE, NV_DD_IMAGE_BLACK_RECTANGLE);
    NV_CREATE_OBJECT_PIO1(NV4_CONTEXT_PATTERN, NV_DD_IMAGE_PATTERN);
    NV_CREATE_OBJECT_PIO1(NV4_CONTEXT_COLOR_KEY, NV_DD_IMAGE_SOLID);
    NV_CREATE_OBJECT_PIO1(NV4_IMAGE_FROM_CPU, NV_DD_IMAGE_FROM_CPU);
    NV_CREATE_OBJECT_PIO1(NV4_IMAGE_BLIT, NV_DD_IMAGE_BLIT);
    NV_CREATE_OBJECT_PIO1(NV4_GDI_RECTANGLE_TEXT, NV_DD_RENDER_RECT_AND_TEXT);
    // video overlay class
    {
        NV_CREATE_OBJECT_SETUP();
        ulHead = ppdev->ulDeviceDisplay[0];
        if (ulHead > 0) {
            nv07aAllocParms.logicalHeadId = ulHead;
            parms = &nv07aAllocParms;
        } else {
            parms = NULL;
        }

        NV_CREATE_OBJECT_INIT();

        NV_CREATE_OBJECT_PARM_PIO2(parms,  NV_DD_VIDEO_OVERLAY, 
                   NV10_VIDEO_OVERLAY, NV04_VIDEO_OVERLAY);

        if (NV_CREATE_OBJECT_FAIL()) {
            return FALSE;
        } else {
            ppdev->CurrentClass.VideoOverlay = NV_CREATE_OBJECT_CLASS();
        }
    }
    
    // if 8bpp, create colormap
    NV_CREATE_OBJECT_INIT();
    if (ppdev->iBitmapFormat == BMF_8BPP) {
        NV_CREATE_OBJECT_PIO1(NV_VIDEO_COLORMAP, NV_DD_SHARED_VIDEO_COLORMAP);
        NV_CREATE_OBJECT_PIO1(NV_PATCHCORD_VIDEO, NV_DD_P_V_SHARED_VIDEO_COLORMAP);
    }

    NV_CREATE_OBJECT_PIO1(NV3_MEMORY_TO_MEMORY_FORMAT, NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT);
    NV_CREATE_OBJECT_PIO1(NV3_MEMORY_TO_MEMORY_FORMAT, NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT);
    NV_CREATE_OBJECT_PIO1(NV4_STRETCHED_IMAGE_FROM_CPU, NV_DD_STRETCHED_UV_IMAGE_FROM_CPU);
    NV_CREATE_OBJECT_PIO1(NV4_STRETCHED_IMAGE_FROM_CPU, NV_DD_STRETCHED_IMAGE_FROM_CPU);
    if (NV_CREATE_OBJECT_FAIL()) {
        return FALSE;
    }    

    //*******************************************************************************
    // Create video overlay objects.
    //*******************************************************************************
    if (ppdev->cBitsPerPel > 8) {
        NV_CREATE_OBJECT_INIT();
        NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY);
        NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY);
        NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY);
        NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY);
        NV_CREATE_OBJECT_PIO1(ulScaledImageClass, NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY);
        if (NV_CREATE_OBJECT_FAIL()) {
            return FALSE;
        }    
    }


    {
    ULONG i, ulHead;
    PVOID parms;
    NV07C_ALLOCATION_PARAMETERS nv07cAllocParms;


    	for(i = 0; i < ppdev->ulNumberDacsActive; i++)
	    {
            NV_CREATE_OBJECT_SETUP();

            ulHead = ppdev->ulDeviceDisplay[i];

            if (ulHead > 0) {
                nv07cAllocParms.logicalHeadId = ulHead;
                parms = &nv07cAllocParms;
            } else {
                parms = NULL;
            }
            // NV5 will use NV04_VIDEO_LUT_CURSOR_DAC class because the method offset of NV05_VIDEO_LUT_CURSOR_DAC 
            // is different from other NV??_VIDEO_LUT_CURSOR_DAC classes.
            NV_CREATE_OBJECT_INIT();

            NV_CREATE_OBJECT_PARM_PIO3(parms,NV_DD_VIDEO_LUT_CURSOR_DAC+ulHead, 
                       NV15_VIDEO_LUT_CURSOR_DAC,NV10_VIDEO_LUT_CURSOR_DAC,
                       NV04_VIDEO_LUT_CURSOR_DAC);
            if (NV_CREATE_OBJECT_FAIL()) 
            {
                return (FALSE);
            } 
            else 
            {
                while (NvGetFreeCount(nv, 0) < 3*4);
            
                nv->subchannel[NV_DD_PRIMARY].SetObject = NV_DD_VIDEO_LUT_CURSOR_DAC+ulHead;
                nv->subchannel[NV_DD_PRIMARY].Nv04VideoLutCursorDac.SetContextDmaImage[0] = NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
                nv->subchannel[NV_DD_PRIMARY].Nv04VideoLutCursorDac.SetContextDmaNotifies = NV_DD_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
                
            }
        }
    }

    while (NvGetFreeCount(nv, 0) < 8*4);
    nv->subchannel[NV_DD_PRIMARY].SetObject       = NV_DD_PRIMARY_SURFACE;
    nv->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetContextDmaNotifies = NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetContextDmaImageSource    = NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
    nv->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetContextDmaImageDestin    = NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;

    // Determine the color format
    switch (ppdev->iBitmapFormat)
        {
        case BMF_32BPP:
            nv->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetColorFormat = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
            break;
        case BMF_16BPP:
            nv->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetColorFormat =
                NV042_SET_COLOR_FORMAT_LE_R5G6B5;
            break;
        case BMF_8BPP:
            nv->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetColorFormat = NV042_SET_COLOR_FORMAT_LE_Y8;
            break;
        default:
            return(FALSE);
        }

    nv->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetPitch  =
        ppdev->lDelta << 16 | (ppdev->lDelta);
    nv->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetSource =  ppdev->ulPrimarySurfaceOffset;
    nv->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetDestin =  ppdev->ulPrimarySurfaceOffset;

    //**********************************************************************
    // Make sure to reset pitches and offsets across modesets!
    //**********************************************************************

    ppdev->DdCurrentSourceOffset = ppdev->DdCurrentDestOffset = ppdev->ulPrimarySurfaceOffset;
    ppdev->DdCurrentSourcePitch  = ppdev->DdCurrentDestPitch = ppdev->lDelta;

    //**************************************************************************
    // Setup ROP5 SOLID
    //**************************************************************************


    while (NvGetFreeCount(nv, 0) < 3*4);
    nv->subchannel[NV_DD_ROP].SetObject      = NV_DD_ROP5_SOLID;
    nv->subchannel[NV_DD_ROP].nv3ContextRop.SetContextDmaNotifies = NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[NV_DD_ROP].nv3ContextRop.SetRop5 = 0xcccc;

    //**************************************************************************
    // Setup clip rectangle
    //**************************************************************************

    while (NvGetFreeCount(nv, 0) < 4*4);
    nv->subchannel[NV_DD_CLIP].SetObject       = NV_DD_IMAGE_BLACK_RECTANGLE;
    nv->subchannel[NV_DD_CLIP].nv1ImageBlackRectangle.SetContextDmaNotifies = DD_FIFO_SYNC_NOTIFIER;
    nv->subchannel[NV_DD_CLIP].nv1ImageBlackRectangle.SetPoint = 0;
    nv->subchannel[NV_DD_CLIP].nv1ImageBlackRectangle.SetSize  = ((0x7fff<<16) | 0x7fff);
    ppdev->DdClipResetFlag = 0;

    //**********************************************************************
    // Setup CONTEXT PATTERN
    //**********************************************************************

    while (NvGetFreeCount(nv, 0) < 10*4);
    nv->subchannel[NV_DD_PATTERN].SetObject      = NV_DD_IMAGE_PATTERN;
    nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetContextDmaNotifies = NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

    // Determine the color format
    switch (ppdev->iBitmapFormat)
        {
        case BMF_32BPP:
            nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetColorFormat = NV044_SET_COLOR_FORMAT_LE_A8R8G8B8;
            break;
        case BMF_16BPP:
            nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetColorFormat = NV044_SET_COLOR_FORMAT_LE_A16R5G6B5;
            break;
        case BMF_8BPP:
            // Must be set to a legal value but hardware ignores it otherwise
            nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetColorFormat = NV044_SET_COLOR_FORMAT_LE_A8R8G8B8;
            break;
        default:
            return(FALSE);
        }

    nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeFormat   = NV044_SET_MONOCHROME_FORMAT_CGA6_M1;
    nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeShape    = NV044_SET_MONOCHROME_SHAPE_64X_1Y ;
    nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternSelect      = NV044_SET_PATTERN_SELECT_MONOCHROME;
    nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeColor0   = color0;
    nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeColor1   = color1;
    nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromePattern0 = 0xffffffff;
    nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromePattern1 = 0x50505050;

    //**********************************************************************
    // Y8 default pattern values
    //**********************************************************************

    while (NvGetFreeCount(nv, 0) < 16*4);
    for (i=0;i<16;i++)
        nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternY8[i] = 0xffffffff;

    //**********************************************************************
    // R5G6B5 default pattern values
    //**********************************************************************

    while (NvGetFreeCount(nv, 0) < 16*4);
    for (i=0;i<16;i++)
        nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternR5G6B5[i] = 0xffffffff;

    while (NvGetFreeCount(nv, 0) < 16*4);
    for (i=16;i<32;i++)
        nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternR5G6B5[i] = 0xffffffff;

    //**********************************************************************
    // X1R5G5B5 default pattern values
    //**********************************************************************

    while (NvGetFreeCount(nv, 0) < 16*4);
    for (i=0;i<16;i++)
        nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternX1R5G5B5[i] = 0xffffffff;

    while (NvGetFreeCount(nv, 0) < 16*4);
    for (i=16;i<32;i++)
        nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternX1R5G5B5[i] = 0xffffffff;

    //**********************************************************************
    // X8R8G8B8 default pattern values
    //**********************************************************************

    while (NvGetFreeCount(nv, 0) < 16*4);
    for (i=0;i<16;i++)
        nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternX8R8G8B8[i] = 0xffffffff;

    while (NvGetFreeCount(nv, 0) < 16*4);
    for (i=16;i<32;i++)
        nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternX8R8G8B8[i] = 0xffffffff;

    while (NvGetFreeCount(nv, 0) < 16*4);
    for (i=32;i<48;i++)
        nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternX8R8G8B8[i] = 0xffffffff;

    while (NvGetFreeCount(nv, 0) < 16*4);
    for (i=48;i<64;i++)
        nv->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternX8R8G8B8[i] = 0xffffffff;

    //**********************************************************************
    // Setup IMAGE SOLID (CONTEXT COLOR KEY for NV4)
    //**********************************************************************

    while (NvGetFreeCount(nv, 0) < 4*4);
    nv->subchannel[NV_DD_SPARE].SetObject = NV_DD_IMAGE_SOLID;
    nv->subchannel[NV_DD_SPARE].nv4ContextColorKey.SetContextDmaNotifies = NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

    // Determine the color format
    switch (ppdev->iBitmapFormat)
        {
        case BMF_32BPP:
            nv->subchannel[NV_DD_SPARE].nv4ContextColorKey.SetColorFormat = NV057_SET_COLOR_FORMAT_LE_A8R8G8B8;
            break;
        case BMF_16BPP:
            nv->subchannel[NV_DD_SPARE].nv4ContextColorKey.SetColorFormat = NV057_SET_COLOR_FORMAT_LE_A16R5G6B5;
            break;
        case BMF_8BPP:
            // Does hardware ignore this value???
            nv->subchannel[NV_DD_SPARE].nv4ContextColorKey.SetColorFormat = NV057_SET_COLOR_FORMAT_LE_A8R8G8B8;
            break;
        default:
            return(FALSE);
        }

    nv->subchannel[NV_DD_SPARE].nv4ContextColorKey.SetColor = 0L; // Disabled

    //**********************************************************************
    // Setup Image From CPU (565 format)
    //
    // NOTE:  We CAN NOT use the COLOR_KEY (IMAGE_SOLID)
    //        if ROP_OPERATION = ROP_AND
    //**********************************************************************

    while (NvGetFreeCount(nv, 0) < 8*4);
    nv->subchannel[NV_DD_SPARE].SetObject         = NV_DD_IMAGE_FROM_CPU;
    nv->subchannel[NV_DD_SPARE].nv4ImageFromCpu.SetContextDmaNotifies = NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[NV_DD_SPARE].nv4ImageFromCpu.SetContextClipRectangle = NV_DD_IMAGE_BLACK_RECTANGLE;
    nv->subchannel[NV_DD_SPARE].nv4ImageFromCpu.SetContextPattern     = NV_DD_IMAGE_PATTERN;
    nv->subchannel[NV_DD_SPARE].nv4ImageFromCpu.SetContextRop         = NV_DD_ROP5_SOLID;
    nv->subchannel[NV_DD_SPARE].nv4ImageFromCpu.SetContextSurface     = NV_DD_PRIMARY_SURFACE;
    nv->subchannel[NV_DD_SPARE].nv4ImageFromCpu.SetOperation          = NV061_SET_OPERATION_ROP_AND;

    // Determine the color format
    switch (ppdev->iBitmapFormat)
        {
        case BMF_32BPP:
            nv->subchannel[NV_DD_SPARE].nv4ImageFromCpu.SetColorFormat = NV061_SET_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        case BMF_16BPP:
            nv->subchannel[NV_DD_SPARE].nv4ImageFromCpu.SetColorFormat = NV061_SET_COLOR_FORMAT_LE_R5G6B5;
            break;
        case BMF_8BPP:
            // Does hardware ignore this value???
            nv->subchannel[NV_DD_SPARE].nv4ImageFromCpu.SetColorFormat = NV061_SET_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        default:
            return(FALSE);
        }

    //**************************************************************************
    // Setup Image Blit
    //**************************************************************************

    while (NvGetFreeCount(nv, 0) < 8*4);
    nv->subchannel[NV_DD_BLIT].SetObject                               = NV_DD_IMAGE_BLIT;
    nv->subchannel[NV_DD_BLIT].nv4ImageBlit.SetContextDmaNotifies      = NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[NV_DD_BLIT].nv4ImageBlit.SetContextClipRectangle    = NV_DD_IMAGE_BLACK_RECTANGLE;
    nv->subchannel[NV_DD_BLIT].nv4ImageBlit.SetContextPattern          = NV_DD_IMAGE_PATTERN;
    nv->subchannel[NV_DD_BLIT].nv4ImageBlit.SetContextRop              = NV_DD_ROP5_SOLID;
    nv->subchannel[NV_DD_BLIT].nv4ImageBlit.SetContextSurfaces         = NV_DD_PRIMARY_SURFACE;
    nv->subchannel[NV_DD_BLIT].nv4ImageBlit.SetOperation               = NV05F_SET_OPERATION_ROP_AND;
    nv->subchannel[NV_DD_BLIT].nv4ImageBlit.SetContextColorKey         = NV_DD_IMAGE_SOLID;

    //**********************************************************************
    // Setup RECT and TEXT  (565 format)
    //**********************************************************************

    while (NvGetFreeCount(nv, 0) < 8*4);
    nv->subchannel[NV_DD_RECT_AND_TEXT].SetObject      = NV_DD_RENDER_RECT_AND_TEXT;
    nv->subchannel[NV_DD_RECT_AND_TEXT].nv4GdiRectangleText.SetContextDmaNotifies = NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[NV_DD_RECT_AND_TEXT].nv4GdiRectangleText.SetContextPattern = NV_DD_IMAGE_PATTERN;
    nv->subchannel[NV_DD_RECT_AND_TEXT].nv4GdiRectangleText.SetContextRop     = NV_DD_ROP5_SOLID;
    nv->subchannel[NV_DD_RECT_AND_TEXT].nv4GdiRectangleText.SetContextSurface = NV_DD_PRIMARY_SURFACE;
    nv->subchannel[NV_DD_RECT_AND_TEXT].nv4GdiRectangleText.SetOperation      = NV04A_SET_OPERATION_ROP_AND;

    // Determine the color format
    switch (ppdev->iBitmapFormat)
        {
        case BMF_32BPP:
            nv->subchannel[NV_DD_RECT_AND_TEXT].nv4GdiRectangleText.SetColorFormat = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        case BMF_16BPP:
            nv->subchannel[NV_DD_RECT_AND_TEXT].nv4GdiRectangleText.SetColorFormat = NV04A_SET_COLOR_FORMAT_LE_X16R5G6B5;
            break;
        case BMF_8BPP:
            // Does hardware ignore this value???
            nv->subchannel[NV_DD_RECT_AND_TEXT].nv4GdiRectangleText.SetColorFormat = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        default:
            return(FALSE);
        }

    nv->subchannel[NV_DD_RECT_AND_TEXT].nv4GdiRectangleText.SetMonochromeFormat = NV04A_SET_MONOCHROME_FORMAT_CGA6_M1;

    // if 8bpp, create colormap
    if (ppdev->iBitmapFormat == BMF_8BPP)
        {
        while (NvGetFreeCount(nv, 0) < 9*4);
        nv->subchannel[NV_DD_SPARE].SetObject = NV_DD_SHARED_VIDEO_COLORMAP;
        nv->subchannel[NV_DD_SPARE].NvVideoColormap.SetVideoOutput =
            NV_DD_P_V_SHARED_VIDEO_COLORMAP;
        nv->subchannel[NV_DD_SPARE].NvVideoColormap.SetVideoInput =
            DD_PATCHCORD_VIDEO;
        nv->subchannel[NV_DD_SPARE].NvVideoColormap.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[NV_DD_SPARE].NvVideoColormap.SetContextDmaColormap =
            NV_DD_WIN_COLORMAP_CONTEXT;
        nv->subchannel[NV_DD_SPARE].NvVideoColormap.SetColormapStart = 0;
        nv->subchannel[NV_DD_SPARE].NvVideoColormap.Notify = 0;
        nv->subchannel[NV_DD_SPARE].NvVideoColormap.SetColormapLength =
            256 * sizeof(VIDEO_CLUTDATA);

        }

    //************************************************************************
    // Create the video memory to system memory format object.
    //************************************************************************

    while (NvGetFreeCount(nv, 0) < 4*4);
    nv->subchannel[NV_DD_SPARE].SetObject = NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT;
    nv->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.SetContextDmaNotifies =
        NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.SetContextDmaBufferIn =
        NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
    nv->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.SetContextDmaBufferOut =
        NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

    //**************************************************************************
    // create memory to memory format object used to reformat overlay surfaces
    //**************************************************************************

    while (NvGetFreeCount(nv, 0) < 4*4);
    nv->subchannel[NV_DD_SPARE].SetObject =
       NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
    nv->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.SetContextDmaNotifies =
       NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.SetContextDmaBufferIn =
       NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
    nv->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.SetContextDmaBufferOut =
       NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;

    // video overlay class
    while (NvGetFreeCount(nv, NV_DD_SPARE) < 4*4);

    nv->subchannel[NV_DD_SPARE].SetObject = NV_DD_VIDEO_OVERLAY;
    nv->subchannel[NV_DD_SPARE].Nv04VideoOverlay.SetContextDmaNotifies =
        NV_DD_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[NV_DD_SPARE].Nv04VideoOverlay.SetContextDmaOverlay[0] =
        NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
    nv->subchannel[NV_DD_SPARE].Nv04VideoOverlay.SetContextDmaOverlay[1] =
        NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;

    if (ppdev->cBitsPerPel > 8)
        {
        //*****************************************************************************
        // Hook up scaled image from mem objects.
        //*****************************************************************************
        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextSurface =
            NV_DD_PRIMARY_SURFACE;
        if (ppdev->cBitsPerPel == 16)
            nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
                NV077_SET_COLOR_FORMAT_LE_R5G6B5;
        else
            nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
                NV077_SET_COLOR_FORMAT_LE_X8R8G8B8;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaImage =
            NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextSurface =
            NV_DD_PRIMARY_SURFACE;
        if (ppdev->cBitsPerPel == 16)
            nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
                NV077_SET_COLOR_FORMAT_LE_R5G6B5;
        else
            nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
                NV077_SET_COLOR_FORMAT_LE_X8R8G8B8;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaImage =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextSurface =
            NV_DD_PRIMARY_SURFACE;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
            NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;

        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaImage =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextSurface =
            NV_DD_PRIMARY_SURFACE;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
            NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaImage =
            NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextSurface =
            NV_DD_PRIMARY_SURFACE;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
            NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaImage =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 7*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;

        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextSurface =
            NV_DD_PRIMARY_SURFACE;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
            NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaImage =
            NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
            NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetOperation =
            NV077_SET_OPERATION_SRCCOPY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextSurface =
            NV_DD_PRIMARY_SURFACE;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
            NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaImage =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextSurface =
            NV_DD_PRIMARY_SURFACE;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
            NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaImage =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextSurface =
            NV_DD_PRIMARY_SURFACE;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
            NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaImage =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 5*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaNotifies =
            NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextSurface =
            NV_DD_PRIMARY_SURFACE;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetColorFormat =
            NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8;
        nv->subchannel[NV_DD_SPARE].nv4ScaledImageFromMemory.SetContextDmaImage =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
#if 0
    // BUGBUG I don't think YUV420 object is needed. BUGBUG
        while (NvGetFreeCount(nv, 0) < 4*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_FLOATING0_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nvScaledYuv420FromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nvScaledYuv420FromMemory.SetImageOutput =
            NV_DD_P_I_FLOATING0_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nvScaledYuv420FromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;

        while (NvGetFreeCount(nv, 0) < 4*4);

        nv->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_FLOATING1_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nvScaledYuv420FromMemory.SetNotifyCtxDma =
            NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
        nv->subchannel[NV_DD_SPARE].nvScaledYuv420FromMemory.SetImageOutput =
            NV_DD_P_I_FLOATING1_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY;
        nv->subchannel[NV_DD_SPARE].nvScaledYuv420FromMemory.SetImageCtxDma =
            NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY;
#endif
        }

    while (NvGetFreeCount(nv, 0) < 8*4);
    nv->subchannel[NV_DD_STRETCH].SetObject = NV_DD_STRETCHED_IMAGE_FROM_CPU;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetContextDmaNotifies = NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetContextColorKey = NV_DD_IMAGE_SOLID;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetContextPattern = NV_DD_IMAGE_PATTERN;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetContextRop     = NV_DD_ROP5_SOLID;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetOperation =
        NV076_SET_OPERATION_ROP_AND;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetContextSurface =
        NV_DD_PRIMARY_SURFACE;

    switch (ppdev->cBitsPerPel)
        {
        case 8:
            /* A8Y8 color format assumed by hardware when destination surface in 8bpp mode */
            /* Must be set to a legal value but hardware ignores it otherwise */
            nv->subchannel[NV_DD_SPARE].nv4StretchedImageFromCpu.SetColorFormat =
               NV076_SET_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        case 16:

            if (ppdev->flGreen == 0x03e0)
                nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetColorFormat =
                    NV076_SET_COLOR_FORMAT_LE_A1R5G5B5;
            else
                nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetColorFormat =
                    NV076_SET_COLOR_FORMAT_LE_R5G6B5;       // 5:6:5 format

            break;
        case 32:
            nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetColorFormat =
                NV076_SET_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        }
    ppdev->dDrawSpareSubchannelObject = 0;

    while (NvGetFreeCount(nv, 0) < 8*4);
    nv->subchannel[NV_DD_STRETCH].SetObject = NV_DD_STRETCHED_UV_IMAGE_FROM_CPU;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetContextPattern = NV_DD_IMAGE_PATTERN;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetContextRop     = NV_DD_ROP5_SOLID;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetOperation =
        NV076_SET_OPERATION_ROP_AND;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetContextSurface =
        NV_DD_PRIMARY_SURFACE;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetContextDmaNotifies = NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetContextColorKey = NV_DD_IMAGE_SOLID;
    /* A8Y8 color format assumed by hardware when destination surface in 8bpp mode */
    /* Must be set to a legal value but hardware ignores it otherwise */
    nv->subchannel[NV_DD_STRETCH].nv4StretchedImageFromCpu.SetColorFormat =
        NV076_SET_COLOR_FORMAT_LE_X8R8G8B8;

#ifdef MJL_USE_VPP
    if (!createExtendedDDPatch(ppdev))
    {
        return (FALSE);
    }
#endif

    //******************************************************************************************
    // End of video object creation.
    //******************************************************************************************
    ppdev->bDDChannelActive = TRUE;

    pSyncNotifier[NV04A_NOTIFIERS_NOTIFY].status = 0;

    return(TRUE);
}


NvU8 bDestroyNVDDPatch(PDEV    *ppdev)
{
    ULONG status;

    //*********************************************************************************
    // Ensure DD channel processing has completed prior to destroying objects
    // and DMA contexts.
    //*********************************************************************************
    NV4_DdPioSync(ppdev);

    //*********************************************************************************
    // Ensure all processing has completed prior to destroying objects.
    //*********************************************************************************
    ppdev->pfnWaitForChannelSwitch(ppdev);
    ppdev->pfnWaitEngineBusy(ppdev);

    //**********************************************************************************
    // Close ddraw channel.
    //**********************************************************************************
    status = NvFree(ppdev->hDriver,
                ppdev->hClient,
                ppdev->hDevice,
                ppdev->hDdChannel);

    if (status != NVOS00_STATUS_SUCCESS)
        {
        DPF("NVDD: Cannot free NV ddraw PIO channel");
        NvClose(ppdev->hDriver);
        return FALSE;
        }

    //********************************************************************************
    // If the pjMmBase ptr was alloc'd by ddraw, clear it.
    //********************************************************************************
    if (ppdev->pjMmBase == ppdev->ddChannelPtr)
        {
        ppdev->pjMmBase = NULL;
        }

    ppdev->ddChannelPtr = NULL;

    //**************************************************************************
    // Free DMA context which points to all of video memory.
    //**************************************************************************
    if (NvFree(  ppdev->hDriver,ppdev->hClient, ppdev->hDevice, NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM) !=
            NVOS00_STATUS_SUCCESS )
        {
        DPF("NVDD: Cannot free dma in memory context");
        return FALSE;
        }

    //******************************************************************************
    // Free ddraw notifier context
    //******************************************************************************
    if (NvFree(  ppdev->hDriver,
                            ppdev->hClient, ppdev->hDevice, NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY) != NVOS00_STATUS_SUCCESS )
        {
        DPF("NVDD: Cannot free notifier context");
        return FALSE;
        }

    //******************************************************************************
    // Free flip notifier context
    //******************************************************************************
    if (NvFree(  ppdev->hDriver,
                            ppdev->hClient, ppdev->hDevice, NV_DD_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY) != NVOS00_STATUS_SUCCESS )
        {
        DPF("NVDD: Cannot free notifier context");
        return FALSE;
        }

    //******************************************************************************
    // Free flip overlay notifier context
    //******************************************************************************
    if (NvFree(  ppdev->hDriver,
                            ppdev->hClient, ppdev->hDevice, NV_DD_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY) != NVOS00_STATUS_SUCCESS )
        {
        DPF("NVDD: Cannot free notifier context");
        return FALSE;
        }

    //******************************************************************************
    // Free sync notifier context
    //******************************************************************************
    if (NvFree(  ppdev->hDriver,
                            ppdev->hClient, ppdev->hDevice, DD_FIFO_SYNC_NOTIFIER) != NVOS00_STATUS_SUCCESS )
        {
        DPF("NVDD: Cannot free notifier context");
        return FALSE;
        }



    //***********************************************************************************
    // Free scanline buffer.
    //***********************************************************************************
    if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY))
        DPF("NVDD: Cannot free scanline buffer context");
    EngFreeMem(ppdev->NvDmaBufferFlat);
    ppdev->NvScanlineBufferFlat = ppdev->NvDmaBufferFlat = 0;

    //***********************************************************************************
    // Free palette DMA context.
    //***********************************************************************************
    if (ppdev->cBitsPerPel == 8)
        {
        if (NvFree(ppdev->hDriver, ppdev->hClient, ppdev->hDevice, NV_DD_WIN_COLORMAP_CONTEXT))
            DPF("NVDD: Cannot free palette context");
        }

#ifdef MJL_USE_VPP
    destroyExtendedDDPatch(ppdev);
#endif

    ppdev->bDDChannelActive = FALSE;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\nvprocman_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvProcMan_link.cpp
//      a pointer to a shared file
//
// **************************************************************************

#include "..\..\..\..\common\src\nvProcMan.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\nvprecomp.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#include <math.h>   // For sin/cos
#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>
#include <winerror.h>
#include <wingdi.h>
#include <winbase.h>
extern "C" {
#include <winddi.h>
};
#include <ntddvdeo.h>

#include "nvTypes.h"
#include "CompileControl.h"

#include "memstruc.h"

// These constants were taken from nvDD.h.  They should come from a shared directory. @mjl@
#define NV_PRESCALE_OVERLAY_X           1
#define NV_PRESCALE_OVERLAY_Y           2
#define NV_PRESCALE_OVERLAY_FIELD       4
#define NV_ALPHA_1_032          ((U032)0xFF000000)
#if (NVARCH >= 0x04)
#define NV_ALPHA_1_016          ((U032)0xFFFF0000)
#else
#define NV_ALPHA_1_016          ((U032)0x00008000)
#endif
#define NV_ALPHA_1_008          ((U032)0x0000FF00)
#define NV_MAX_Y_CLIP                   0x00000FFF
#define NV_MAX_X_CLIP                   0x00000FFF
#define NV_PFIFO_DMA                                     0x00002508 // @mjl@ make sure we map these objects!
#define NV_PFIFO_CACHE1_PUSH1                            0x00003204
#define NV_PFIFO_CACHE1_PUSH1_MODE_DMA_BIT               0x00000100
#define NV_PFIFO_CACHE1_DMA_PUSH                         0x00003220
#define NV_PFIFO_CACHE1_DMA_PUSH_BUFFER_EMPTY_BIT        0x00000100

#include "nvPusher.h"

#include "nv32.h"

// Note: ddminint.h defines GLOBALDATA (and much else) but shared code (anything including this file)
//   will get GLOBALDATA from a different place (win9x/inc/DDMINI.H)
//
#include "ddminint.h"
#include "driver.h" // This is an NT4 specific header despite the name... - @mjl@

#include "nvDbg.h"
#include "nvUtil.h"
#include "nv4subch.h"

#define AllocIPM(size) EngAllocMem(FL_ZERO_MEMORY,size,ALLOC_TAG)
#define FreeIPM(ptr) EngFreeMem(ptr)

#define VIDMEM_ADDR(fpVidMem)    ((fpVidMem) + (ULONG) PDEV_PTR()->pjFrameBufbase)
#define AGPMEM_ADDR(fpVidMem)    ((ULONG) fpVidMem + (ULONG) PDEV_PTR()->pDriverData->GARTLinearBase)
#define VIDMEM_OFFSET(fpVidMem)  (fpVidMem)

// These came from dx95types.h which is not in the dx path being used for NT4
typedef PDD_SURFACE_LOCAL LPDDRAWI_DDRAWSURFACE_LCL;
typedef PDD_SURFACE_GLOBAL LPDDRAWI_DDRAWSURFACE_GBL;
typedef PDD_SURFACE_GLOBAL LPDDRAWI_DDRAWSURFACE_GBL;
typedef PDD_SURFACE_GLOBAL LPDDRAWI_DDRAWSURFACE_GBL;
typedef PDD_DIRECTDRAW_GLOBAL LPDDRAWI_DIRECTDRAW_GBL;

// From win9x/inc32/winnt & winbase headers
// Needed for nvVPP and nvPriv
#define STATUS_WAIT_0       ((DWORD   )0x00000000L)    
#define WAIT_OBJECT_0       ((STATUS_WAIT_0 ) + 0 )

#include "Nvcm.h" // Configuration Manager

#define NvRmConfigGetEx(hCli, hDevice, index, pParams, paramSize) \
        NvConfigGetEx(PDEV_PTR()->hDriver, hCli, hDevice, index, pParams, paramSize)
#define NvRmConfigGet(hClient, hDevice, index, pValue) \
        NvConfigGet(PDEV_PTR()->hDriver, hClient, hDevice, index, pValue)
#define NvRmAllocObject(hCli, hChan, hObj, hCls) \
        NvAllocObject(PDEV_PTR()->hDriver, hCli, hChan, hObj, hCls)
#define NvRmAlloc(hCli, hChan, hObj, hCls, parms) \
        NvAlloc(PDEV_PTR()->hDriver, hCli, hChan, hObj, hCls, parms)
#define NvRmFree(hClient, hParent, hObj) \
        NvFree(PDEV_PTR()->hDriver, hClient, hParent, hObj)
#define NvRmAllocContextDma(hClient, hDma, hClass, flags, base, limit) \
        NvAllocContextDma(PDEV_PTR()->hDriver, hClient, hDma, hClass, flags, base, limit)
#define NvRmAllocChannelDma(hClient, hDev, hChan, hClass, hErrorCtx, hDataCtx, offset, ppChan) \
        NvAllocChannelDma(PDEV_PTR()->hDriver, (hClient), hDev, (hChan), (hClass), (hErrorCtx), (hDataCtx), (offset), (ppChan))

#include "nvapi.h" // For NvConfigGetEx (and possibly other stuff)

#include "winioctl.h"
#include "nvntioctl.h"

#include "nvos.h"
#include "nvReg.h"

// This comes from DDPRIV and is needed by VPP -> resolve later -@mjl@
#define NVS2VF_SP_SUBRECT       0x00000002

#define DXVA_OVERLAY_WAS_BOBBED     0x00000010 // Yet another thing to move from ddmini.h -@mjl@

#define NV_TEXTURE_OFFSET_ALIGN            255

#define AGP_HEAP 1
#define ERR_DXALLOC_FAILED 1
FLATPTR DDHAL32_VidMemAlloc (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, DWORD dwXDim, DWORD dwYDim);
void DDHAL32_VidMemFree (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, FLATPTR ptr);


#define NVDBG_LEVEL_ERROR               0x80000000 // Temp -- until dbg flags are placed properly @mjl@
#define NVDBG_LEVEL_INFO                0x40000000
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\nvOverlaySurf_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvOverlaySurf_link.cpp
//      a pointer to a shared file
//
// **************************************************************************

#define PDEV_PTR() vpp.pDriverData->ppdev

#include "..\..\..\..\common\src\nvOverlaySurf.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\nvpusher_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPusher_link.cpp
//      a pointer to a shared file
//
// **************************************************************************

#define PDEV_PTR() m_ppdev

// redefine pusher aliases to local environment (NT4)

//#define _pdwHWGet      These reference internal pusher vars and are therefore okay
//#define _pdwHWPut      
//#define _pdwHWRef
#define _pbHWBusy       (*(volatile DWORD *)(m_ppdev->pDriverData->NvBaseFlat + 0x400700))
#define _ffCache1Push1  (*(volatile DWORD *)(m_ppdev->pDriverData->NvBaseFlat + 0x003204))
#define _ffCache1Status (*(volatile DWORD *)(m_ppdev->pDriverData->NvBaseFlat + 0x003214))
#define _hasKNI         (m_ppdev->pDriverData->sysInfo.dwCPUFeatureSet & FS_KATMAI)
#define _has3DNOW       (m_ppdev->pDriverData->sysInfo.dwCPUFeatureSet & FS_3DNOW)
#define _hasSFENCE      (m_ppdev->pDriverData->sysInfo.dwCPUFeatureSet & FS_SFENCE)
#define _hasFullScreenDosOccurred (m_ppdev->pDriverData->fFullScreenDosOccurred)
#define _systemInfo (m_ppdev->pDriverData->sysInfo)
#define _dmaPusherChannelIndex (m_ppdev->vppChannelNdx)
#define _dwRootHandle (m_ppdev->pDriverData->dwRootHandle)
#define _nvBaseFlat ((volatile DWORD*)m_ppdev->pDriverData->NvBaseFlat)
#define _pCurrentChannelID ((DWORD*)(m_ppdev->pDriverData->pCurrentChannelID))
#define _pDriverData (m_ppdev->pDriverData)
#define _hDevice (m_ppdev->hDevice)

// By redefining this class to nothing, and copying these consts, we effectively rewrite some code in
// the pusher class that depends on the CSimpleSurface class which I'm not ready to port. @mjl@
#define CSimpleSurface
enum
{
    // used to specify where we want to allocate a surface (or'ed together)
    // or where it's currently allocated
    HEAP_LOCATION_MASK      = 0x0000001f,   // surface location - preserve order
    HEAP_VID                = 0x01,
    HEAP_AGP                = 0x02,
    HEAP_PCI                = 0x04,
    HEAP_SYS                = 0x08,
    HEAP_DYNSYS             = 0x18,
    HEAP_DYNSYSBIT          = 0x10,
    HEAP_ANYWHERE           = HEAP_VID | HEAP_AGP | HEAP_PCI | HEAP_SYS | HEAP_DYNSYS,
    HEAP_NOWHERE            = 0x0
};

#define HEAP_SHARED                 0x04000000UL    // put heap in shared memory

#include "..\..\..\..\common\src\nvPusher.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\nvRegTool_link.cpp ===
// **************************************************************************
//
//       Copyright 2001-2001 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvRegTool_link.cpp
//      a pointer to a shared file
//
// **************************************************************************

#include "..\..\..\..\common\src\nvRegTool.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\nvVPP_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvVPP_link.cpp
//      a pointer to a shared file
//
// **************************************************************************

// It would be best to move this head to a common header directory
// since it is in fact shared.  All we need is NV_ESC_SETGET_TWINVIEW_DATA.
#include "..\win9x\inc\escape.h"


#define PDEV_PTR() vpp.pDriverData->ppdev

#undef VPP_USE_EVENT_NOTIFIERS    // use event notifiers if this is defined, else use polling
// On NT4 the Ke*Event() routines are not available to the display driver.

#include "..\..\..\..\common\src\nvVPP.cpp"

// This function is only called to get AGP memory -- we don't have AGP on NT4, so we always fail
FLATPTR DDHAL32_VidMemAlloc (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, DWORD dwXDim, DWORD dwYDim)
{
    nvAssert(heap == AGP_HEAP);
    return ERR_DXALLOC_FAILED;
}

void DDHAL32_VidMemFree (LPDDRAWI_DIRECTDRAW_GBL pdrv, int heap, FLATPTR ptr)
{
    nvAssert(heap == AGP_HEAP);
    nvAssert(FALSE); // Never called -- since we always fail AGP alloc
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\bank.c ===
//******************************Module*Header***********************************
//
// Module Name: bank.c
//
// Contains all the banking code for the display driver.
//
// It's helpful not to have to implement all the DDI drawing functionality
// in a driver (who wants to write the code to support true ROP4's with
// arbitrary sized patterns?).  Fortunately, we can punt to GDI for any
// drawing we don't want to do.  And if GDI can write directly on the frame
// buffer bits, performance won't even be toooo bad.
//
// NT's GDI can draw on any standard format frame buffer.  When the entire
// frame buffer can be mapped into main memory, it's very simple to set up:
// the display driver tells GDI the frame buffer format and location, and
// GDI can then just draw directly.
//
// When only one bank of the frame buffer can be mapped into main memory
// at one time (e.g., there is a moveable 64k aperture) things are not
// nearly so easy.  For every bank spanned by a drawing operation, we have
// to set the hardware to the bank, and call back to GDI.  We tell GDI
// to draw only on the mapped-in bank by mucking with the drawing call's
// CLIPOBJ.
//
// This module contains the code for doing all banking support.
//
// This code supports 8, 16 and 32bpp colour depths, arbitrary bank
// sizes, and handles 'broken rasters' (which happens when the bank size
// is not a multiple of the scan length; some scans will end up being
// split over two separate banks).
//
// Note:  If you mess with this code and break it, you can expect to get
//        random access violations on call-backs in internal GDI routines
//        that are very hard to debug.
//
// Copyright (c) 1993-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"


//******************************************************************************
// Extern declearations
//******************************************************************************

VOID NV3ScreenToMemoryDMA(PDEV*,BYTE** ,LONG ,BYTE** ,LONG ,LONG ,LONG ,BOOL );

//******************************Public*Routine**********************************
//
// Function: vAlignedCopy
//
// Routine Description:
//
//      Copies the given portion of a bitmap, using dword alignment for the
//      screen.  Note that this routine has no notion of banking.
//
//      Updates ppjDst and ppjSrc to point to the beginning of the next scan.
//
// Arguments:
//
//      ppdev - Pointer to the physical device structure
//
// Return Value:
//
//******************************************************************************


VOID vAlignedCopy(
PDEV*   ppdev,
BYTE**  ppjDst,
LONG    lDstDelta,
BYTE**  ppjSrc,
LONG    lSrcDelta,
LONG    cjScan,
LONG    cyScan,
BOOL    bDstIsScreen)

    {
    BYTE* pjDst;
    BYTE* pjSrc;
    LONG  cjMiddle;
    LONG  culMiddle;
    LONG  cjStartPhase;
    LONG  cjEndPhase;
    LONG i;

    //**************************************************************************
    // Get source and destination pointers
    //**************************************************************************

    pjSrc = *ppjSrc;
    pjDst = *ppjDst;

    //**************************************************************************
    // If Screen is the SOURCE, then align the copy according to the SOURCE.
    // If Screen is the DEST,   then align the copy according to the DEST.
    //
    // Careful:  Phase is 0 if on a byte 0 boundary.
    //           Phase is 3 if on a byte 1 boundary.
    //           Phase is 2 if on a byte 2 boundary.
    //           Phase is 1 if on a byte 3 boundary.
    //
    // cjStartPhase is the number of bytes we need to output first, before
    // we can start outputting the rest of the bytes.
    //**************************************************************************

    // Be aware of IA64 when doing ptr arithmetic !!
    cjStartPhase = (0 - ((bDstIsScreen) ? (LONG)(ULONG_PTR)pjDst : (LONG)(ULONG_PTR)pjSrc)) & 3;

    //**************************************************************************
    // Calculate Number of bytes remaing after outputting the 'starting' phase bytes.
    // We'll later calculate the final culMiddle and cjEndPhase from cjMiddle.
    //**************************************************************************

    cjMiddle     = cjScan - cjStartPhase;

    //**************************************************************************
    // For cases where cjMiddle is positive:
    //                                                  cjEndPhase      culMiddle
    //   cjScan     cjStartPhase    cjMiddle          (cjMiddle & 3)  (cjMiddle >> 2)
    //   ------     ------------    --------          --------------  ---------------
    //      1           0              1                    1            0
    //      1           1              0                    0            0
    //      1           2             neg                   -            -
    //      1           3             neg                   -            -
    //
    //      2           0              2                    2            0
    //      2           1              1                    1            0
    //      2           2              0                    0            0
    //      2           3             neg                   -            -
    //
    //      3           0              3                    3            0
    //      3           1              2                    2            0
    //      3           2              1                    1            0
    //      3           3              0                    0            0
    //
    //      4           0              4                    0            1
    //      4           1              3                    3            0
    //      4           2              2                    2            0
    //      4           3              1                    1            0
    //
    // The following condition always holds true in the above table.
    //
    //      cjStartPhase + (culMiddle * 4) +cjEndPhase  ==  cjScan
    //
    // EXCEPT for the cases where cjMiddle < 0.  So we must special case them.
    // Here, we'll just get rid of the starting phase.  The end result is that
    // for these case, bytes will only be output in the 'cjEndPhase'.
    //
    //**************************************************************************

    if (cjMiddle < 0)
        {
        cjStartPhase = 0;
        cjMiddle     = cjScan;
        }

    //**************************************************************************
    // Update the number of bytes we need to add to get to the next scanline,
    // after copying 'cjScan' bytes.
    //**************************************************************************

    lSrcDelta -= cjScan;
    lDstDelta -= cjScan;

    //**************************************************************************
    // EndPhase will be copied in bytes.
    // MiddlePhase will always be copied in DWORDS.
    // See description up above.
    //**************************************************************************

    cjEndPhase = cjMiddle & 3;
    culMiddle  = cjMiddle >> 2;

    //**************************************************************************
    // Ensure that graphics engine is idle before touching the framebuffer.
    //**************************************************************************
    ppdev->pfnWaitEngineBusy(ppdev);
    if (bDstIsScreen)

        {
        //**********************************************************************
        // Align to the destination (implying that the source may be
        // unaligned):  Occurs when copying MEMORY to SCREEN (Dest is aligned).
        // Copy scanlines at a time.
        //**********************************************************************

        for (; cyScan > 0; cyScan--)

            {
            //******************************************************************
            // Copy Bytes at a time
            //******************************************************************

            for (i = cjStartPhase; i > 0; i--)
                {
                *pjDst++ = *pjSrc++;
                }

            //******************************************************************
            // Copy Dwords at a time
            //******************************************************************

            for (i = culMiddle; i > 0; i--)
                {
                *((ULONG*) pjDst) = *((ULONG UNALIGNED *) pjSrc);
                pjSrc += sizeof(ULONG);
                pjDst += sizeof(ULONG);
                }

            //******************************************************************
            // Copy Bytes at a time
            //******************************************************************

            for (i = cjEndPhase; i > 0; i--)
                {
                *pjDst++ = *pjSrc++;
                }

            pjSrc += lSrcDelta;
            pjDst += lDstDelta;
            }
        }

    else

        {

        //**********************************************************************
        // Align to the source (implying that the destination may be
        // unaligned):  Occurs when copying SCREEN (Source is aligned) to MEMORY.
        // Copy scanlines at a time.
        //**********************************************************************

        for (; cyScan > 0; cyScan--)

            {
            //******************************************************************
            // Copy Bytes at a time
            //******************************************************************

            for (i = cjStartPhase; i > 0; i--)
                {
                *pjDst++ = *pjSrc++;
                }

            //******************************************************************
            // Copy Dwords at a time
            //******************************************************************

            for (i = culMiddle; i > 0; i--)
                {
                *((ULONG UNALIGNED *) pjDst) = *((ULONG*) (pjSrc));
                pjSrc += sizeof(ULONG);
                pjDst += sizeof(ULONG);
                }

           //*******************************************************************
           // Copy Bytes at a time
           //*******************************************************************

            for (i = cjEndPhase; i > 0; i--)
                {
                *pjDst++ = *pjSrc++;
                }

            pjSrc += lSrcDelta;
            pjDst += lDstDelta;
            }

        }

    //**************************************************************************
    // Save the updated pointers
    //**************************************************************************

    *ppjSrc = pjSrc;
    *ppjDst = pjDst;

    }

//******************************Public*Routine**********************************
//
// Function: vPutBits
//
// Routine Description:
//
//      Copies the bits from the given surface to the screen
//      Must be pre-clipped.  (Implement Memory to Screen blit here for
//      better performance???)
//
// Arguments:
//
//       ppdev - Pointer to the physical device structure
//
// Return Value:
//
//******************************************************************************

VOID vPutBits(
PDEV*       ppdev,
DSURF*      pdsurf,
SURFOBJ*    psoSrc,
RECTL*      prclDst)            // Absolute coordinates!

    {
    RECTL   rclDraw;
    LONG    iBank;
    LONG    cjOffset;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;
    LONG    iNewBank;
    LONG    cjRemainder;

    //**************************************************************************
    // We need a local copy of 'rclDraw' because we'll be iteratively
    // modifying 'top' and passing the modified rectangle back into
    // bBankComputeNonPower2:
    //**************************************************************************

    rclDraw = *prclDst;

    //**************************************************************************
    // Calculate the pointer to the upper-left corner of Destination rectangle (DFB)
    //**************************************************************************

    lDstDelta = pdsurf->LinearStride;
    pjDst     = pdsurf->LinearPtr;

    //**************************************************************************
    // Calculate the pointer to the upper-left corner of Source rectangle (DIB)
    //**************************************************************************

    lSrcDelta = psoSrc->lDelta;
    pjSrc     = (BYTE*) psoSrc->pvScan0;

    //**************************************************************************
    // Calculate number of scanlines to copy (cyScan), and
    // Calculate number of bytes to copy for each scanline (cjScan)
    //**************************************************************************

    cjScan = CONVERT_TO_BYTES((rclDraw.right  - rclDraw.left), ppdev);
    cyScan = (rclDraw.bottom - rclDraw.top);

    //**************************************************************************
    // Copy bytes. DIB (Memory) is source. DFB (Framebuffer) is destination
    //**************************************************************************

    vAlignedCopy(ppdev, &pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                     TRUE);             // Screen is the destination
    return;
    }

//******************************Public*Routine**********************************
//
// Function: vGetBits
//
// Routine Description:
//
//       Copies the bits to the given surface from the screen.
//       Currently, just uses straighforward software copy.  (later use DMA?)
//       Must be pre-clipped.
//
// Arguments:
//
//       ppdev - Pointer to the physical device structure
//
// Return Value:
//
//******************************************************************************


VOID vGetBits(
PDEV*       ppdev,
DSURF*      pdsurf,
SURFOBJ*    psoDst,
RECTL*      prclDst)        // Absolute coordinates!

    {
    LONG    iBank;
    LONG    cjOffset;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;
    LONG    iNewBank;
    LONG    cjRemainder;
    LONG    width,height;

    //**************************************************************************
    // Get source rectangle (Offscreen DFB rectangle)
    //**************************************************************************

    width  = (prclDst->right  - prclDst->left);
    height = (prclDst->bottom - prclDst->top);

    //**************************************************************************
    // Calculate the pointer to the upper-left corner of Source rectangle (DFB)
    //**************************************************************************

    lSrcDelta = pdsurf->LinearStride;
    pjSrc     = pdsurf->LinearPtr;

    //**************************************************************************
    // Calculate the pointer to the upper-left corner of Destination rectangle (DIB)
    //**************************************************************************

    lDstDelta = psoDst->lDelta;
    pjDst     = (BYTE*) psoDst->pvScan0;

    //**************************************************************************
    // Calculate number of scanlines to copy (cyScan), and
    // Calculate number of bytes to copy for each scanline (cjScan)
    //**************************************************************************

    cjScan = CONVERT_TO_BYTES(width, ppdev);
    cyScan = height;

    //**************************************************************************
    // Copy bytes. DFB (Framebuffer) is source. DIB (memory) is destination
    //**************************************************************************

    vAlignedCopy(ppdev, &pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan, FALSE);

    return;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\nvUtil_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvUtil_link.cpp
//      a pointer to a shared file
//
// **************************************************************************

#include "..\..\..\..\common\src\nvUtil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\ddraw\nv4\vid.cpp ===
//******************************************************************************
//
// Copyright (c) 1995-1996 Microsoft Corporation
//
// Module Name:
//
//     DVIDEO.C
//
// Abstract:
//
//     Implements all the low level NV4 specific DirectVideo components for the driver.
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//
//******************************************************************************

#include "nvprecomp.h"
#include "nvalpha.h"
#include "ddminint.h"
#include "nv32.h"

#include "nvos.h"
#include "nvntioctl.h"
#include "nvntddctl.h"
#include "nvapi.h"
#include "nvsubch.h"

#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free


#define MAGIC_DELAY         1000000

#define WAIT_OVERLAY_NOTIFIER(buf)                                                                  \
{   NvNotification *pFlipOverlayNotifier =    (NvNotification *)ppdev->Notifiers->FlipOverlay;      \
    ULONG i = 0;                                                                                    \
    while (pFlipOverlayNotifier[NV07A_NOTIFIERS_SET_OVERLAY(buf)].status == NV_IN_PROGRESS)         \
        if(i++ > MAGIC_DELAY) break;                                                                \
}                                                                                                   \
    

/******************************Public*Routine**********************************\
* DWORD Nv4UpdateOverlay
*
\******************************************************************************/

DWORD __stdcall Nv4UpdateOverlay( PDD_UPDATEOVERLAYDATA lpUOData )
    {
    long srcDeltaX;
    long srcDeltaY;                                                        
    long dwSrcOffset;
    long dwSrcWidth;
    long dwSrcHeight;
    long dwDstWidth;
    long dwDstHeight;
    long dwSrcPitch;
    ULONG   dwVideoColorKey;
    DWORD index = 0;
    DWORD dwBackBufferCount = 0;
    DWORD match = 0;
    BOOL    releaseOpenglSemaphore = FALSE;
    DWORD dwOverlayFormat;

    PDEV *ppdev = (PDEV *) lpUOData->lpDD->dhpdev;
    FAST Nv3ChannelPio  *npDev = (Nv3ChannelPio *)ppdev->ddChannelPtr;
    FAST USHORT     freeCount = ppdev->NVFreeCount;
    NvNotification *pFlipOverlayNotifier =
    (NvNotification *)ppdev->Notifiers->FlipOverlay;

    PDD_SURFACE_LOCAL  srcx = lpUOData->lpDDSrcSurface;
    PDD_SURFACE_GLOBAL  src = srcx->lpGbl;
    PDD_SURFACE_LOCAL  pOriginalSrcx = lpUOData->lpDDSrcSurface;
    PDD_SURFACE_GLOBAL  pOriginalSrc  = lpUOData->lpDDSrcSurface->lpGbl;

    if ((src->ddpfSurface.dwFourCC != FOURCC_UYVY) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YUY2) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YV12) &&
        (src->ddpfSurface.dwFourCC != FOURCC_420i) &&
        (src->ddpfSurface.dwFourCC != FOURCC_IF09) &&
        (src->ddpfSurface.dwFourCC != FOURCC_YVU9) &&
        (src->ddpfSurface.dwFourCC != FOURCC_IV32) &&
        (src->ddpfSurface.dwFourCC != FOURCC_IV31))
        {
        lpUOData->ddRVal = DDERR_INVALIDSURFACETYPE;
        return DDHAL_DRIVER_HANDLED;
        }

    if (!(srcx->ddsCaps.dwCaps & DDSCAPS_OVERLAY))
        {
        lpUOData->ddRVal = DDERR_NOTAOVERLAYSURFACE;
        return DDHAL_DRIVER_HANDLED;
        }

    while ((index < NV_MAX_OVERLAY_SURFACES) && (!match))
        if ((DWORD)srcx == ppdev->dwOverlaySurfaceLCL[index++])
            match = 1;

    if (!match)
        {
        lpUOData->ddRVal = DDERR_OUTOFCAPS;
        return DDHAL_DRIVER_HANDLED;
        }

    if (npDev == NULL)
        {  /* Mode switches might occur without warning */
        lpUOData->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
        }

    /*
     * NOTES:
     *
     * This callback is invoked to update an overlay surface.
     * This is where the src/destination is specified, any effects, and
     * it is shown or hidden
     */

    /* Alternate buffer indexes to keep the hardware happy */
	ppdev->OverlayBufferIndex ^= 1;
    index = ppdev->OverlayBufferIndex;

    ENTER_DMA_PUSH_SYNC();
    NV_DD_DMA_PUSHER_SYNC();
    freeCount = ppdev->NVFreeCount;

    // if Overlay is enabled, disabled it before updating new size and position.
    if ((lpUOData->dwFlags & DDOVER_HIDE ) || ppdev->dwOverlayEnabled)
        {
        DPF("UPDATE OVERLAY - DDOVER_HIDE");

        WAIT_OVERLAY_NOTIFIER(0);
        WAIT_OVERLAY_NOTIFIER(1);

        while (freeCount < 3*4)
            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
        freeCount -= 3*4;

        npDev->dDrawSpare.SetObject = NV_DD_VIDEO_OVERLAY;
        npDev->dDrawSpare.Nv04VideoOverlay.StopOverlay[0] = NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE;
        npDev->dDrawSpare.Nv04VideoOverlay.StopOverlay[1] = NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE;

        ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_OVERLAY;

        /* Let DDraw know how many visible overlays are active */
        ppdev->HALInfo.ddCaps.dwCurrVisibleOverlays = 0;
        ppdev->dwOverlaySrcHeight = 0;
        ppdev->dwOverlayDstHeight = 0;

        WAIT_OVERLAY_NOTIFIER(0);
        WAIT_OVERLAY_NOTIFIER(1);

        ppdev->dwOverlayEnabled = FALSE;
        }

    if (lpUOData->dwFlags & DDOVER_HIDE )
        {
            // already disabled
        }
    else
        {

        ppdev->dwOverlayEnabled = TRUE;
        DPF("UPDATE OVERLAY - DDOVER_SHOW OR MOVE/RESIZE ");
        DPF( "Source Rect = (%ld,%ld), (%ld,%ld)",
             lpUOData->rSrc.left, lpUOData->rSrc.top,
             lpUOData->rSrc.right, lpUOData->rSrc.bottom );

        DPF( "Dest Rect = (%ld,%ld), (%ld,%ld)",
             lpUOData->rDest.left, lpUOData->rDest.top,
             lpUOData->rDest.right, lpUOData->rDest.bottom );

        if ( lpUOData->dwFlags & (DDOVER_KEYSRCOVERRIDE | DDOVER_KEYSRC) )
            {
            ppdev->NVFreeCount = freeCount;
            lpUOData->ddRVal = DDERR_NOCOLORKEYHW;
            EXIT_DMA_PUSH_SYNC(DDHAL_DRIVER_HANDLED);
            }
        if ((lpUOData->rDest.left < 0) || (lpUOData->rDest.top < 0))
            {
            lpUOData->ddRVal = DDERR_INVALIDPOSITION;
            ppdev->NVFreeCount = freeCount;
            EXIT_DMA_PUSH_SYNC(DDHAL_DRIVER_HANDLED);
            }

        dwSrcWidth = lpUOData->rSrc.right - lpUOData->rSrc.left;
        dwSrcHeight = lpUOData->rSrc.bottom - lpUOData->rSrc.top;
        dwDstWidth = lpUOData->rDest.right - lpUOData->rDest.left;
        dwDstHeight = lpUOData->rDest.bottom - lpUOData->rDest.top;

        /* Remember heights so Flip32 knows what to do */
        ppdev->dwOverlaySrcHeight = dwSrcHeight;
        ppdev->dwOverlayDstHeight = dwDstHeight;

        if (dwSrcHeight > dwDstHeight)
            {
            dwSrcHeight >>= 1; /* We only support vertical shrinking and it can't be by more than .5 */
            if (dwSrcHeight > dwDstHeight)
                {
                lpUOData->ddRVal = DDERR_UNSUPPORTED;
                ppdev->NVFreeCount = freeCount;
                EXIT_DMA_PUSH_SYNC(DDHAL_DRIVER_HANDLED);
                }
            }

        /* Align to 2 pixel boundary + 1 for video scaler */
        dwDstWidth = (dwDstWidth + 2) & ~1L;
        dwDstHeight = (dwDstHeight + 2) & ~1L;

        srcDeltaX = (dwSrcWidth - 1) << 16;
        srcDeltaX /= dwDstWidth - 1;
        srcDeltaX <<= 4;
        srcDeltaY = (dwSrcHeight - 1) << 16;
        srcDeltaY /= dwDstHeight - 1;
        srcDeltaY <<= 4;

            // color key?
        if (lpUOData->dwFlags & DDOVER_KEYDESTOVERRIDE) {
            dwVideoColorKey = lpUOData->overlayFX.dckDestColorkey.dwColorSpaceLowValue;
            dwOverlayFormat = (NV07A_SET_OVERLAY_FORMAT_COLOR_KEY_MISMATCH_SHOW_IMAGE << 20);
        } else if (lpUOData->dwFlags & DDOVER_KEYDEST) {
            dwVideoColorKey = lpUOData->lpDDDestSurface->ddckCKDestOverlay.dwColorSpaceLowValue;
            dwOverlayFormat = (NV07A_SET_OVERLAY_FORMAT_COLOR_KEY_MISMATCH_SHOW_IMAGE << 20);
        } else {    // disable color key
            dwOverlayFormat = (NV07A_SET_OVERLAY_FORMAT_COLOR_KEY_MISMATCH_SHOW_OVERLAY << 20);
        }
        if (src->ddpfSurface.dwFourCC == FOURCC_UYVY) {
            dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_COLOR_LE_YB8CR8YA8CB8 << 16);
        } else {
            dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_COLOR_LE_CR8YB8CB8YA8 << 16);
        }

        while (srcx != NULL)
            {
            dwSrcOffset = src->fpVidMem;

            if ((src->ddpfSurface.dwFourCC == FOURCC_IF09) ||
                (src->ddpfSurface.dwFourCC == FOURCC_YVU9) ||
                (src->ddpfSurface.dwFourCC == FOURCC_IV32) ||
                (src->ddpfSurface.dwFourCC == FOURCC_IV31))
                {
                /* Skip over Indeo portion of surface */
                dwSrcPitch = (DWORD)src->wWidth;
                dwSrcOffset += ((dwSrcPitch * ((DWORD)src->wHeight * 10L)) >> 3);
                /* Force block to be properly aligned */
                dwSrcOffset = (dwSrcOffset + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
                dwSrcPitch = ((src->wWidth + 1) & 0xFFFFFFFE) << 1;
                dwSrcPitch = (dwSrcPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
                }
            else if ((src->ddpfSurface.dwFourCC == FOURCC_YV12) ||
                     (src->ddpfSurface.dwFourCC == FOURCC_420i))
                {
                /* Assumes a separate overlay YUY2 surface in video memory */
                if (src->fpVidMem == ppdev->NvFloatingMem2MemFormatBaseAddress)
                    dwSrcOffset = ppdev->NvYUY2Surface0Mem;

                else if (src->fpVidMem == ppdev->NvFloatingMem2MemFormatNextAddress)
                    dwSrcOffset = ppdev->NvYUY2Surface1Mem;
                else
                    dwSrcOffset = ppdev->NvYUY2Surface2Mem;

                dwSrcPitch = ((src->wWidth + 1) & 0xFFFFFFFE) << 1;
                dwSrcPitch = (dwSrcPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
                }
            else
                dwSrcPitch = (DWORD)src->lPitch;

            dwSrcOffset += (lpUOData->rSrc.top * dwSrcPitch);
            dwSrcOffset += (lpUOData->rSrc.left << 1);

            /* Let the world know what the current overlay src offset is */
            ppdev->OverlaySrcX = (short)lpUOData->rSrc.left;
            ppdev->OverlaySrcY = (short)lpUOData->rSrc.top;

            /* We shrink vertically by skipping scanlines then stretching up */
            if (ppdev->dwOverlaySrcHeight > (DWORD)dwDstHeight)
                dwSrcPitch <<= 1;

// temp defines b4 becoming a class standard
#define NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_0 (0x04000000)
#define NV_VFM_FORMAT_CONTROL_FLIP_BY_MEDIAPORT_1 (0x02000000)

            /* Let the world know what the overlay src info is */
            ppdev->OverlaySrcOffset = dwSrcOffset;
            ppdev->OverlaySrcPitch = dwSrcPitch;
            ppdev->OverlaySrcSize = asmMergeCoords(dwSrcWidth, dwSrcHeight);

            dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_MATRIX_ITURBT601 << 24);
            dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_NOTIFY_WRITE_ONLY << 31);

            ppdev->dwVideoColorKey = dwVideoColorKey;
            ppdev->OverlaySrcOffset = dwSrcOffset;
            ppdev->OverlaySrcSize = asmMergeCoords((dwSrcWidth & ~1), (dwSrcHeight & ~1));
            ppdev->dwOverlayDeltaX = srcDeltaX;
            ppdev->dwOverlayDeltaY = srcDeltaY;
            ppdev->dwOverlayDstX = lpUOData->rDest.left;
            ppdev->dwOverlayDstY = lpUOData->rDest.top;
            ppdev->dwOverlayDstWidth = dwDstWidth;
            ppdev->dwOverlayDstHeight = dwDstHeight;
            ppdev->dwOverlayFormat = dwOverlayFormat;
            ppdev->OverlaySrcPitch = dwSrcPitch;

            dwOverlayFormat |= dwSrcPitch;

            WAIT_OVERLAY_NOTIFIER(index);

            while (freeCount < 10*4)
                freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
            freeCount -= 10*4;

            // notifiers do not seem to be working...
            pFlipOverlayNotifier[NV07A_NOTIFIERS_SET_OVERLAY(index)].status = NV_IN_PROGRESS;

            npDev->dDrawSpare.SetObject = NV_DD_VIDEO_OVERLAY;
            npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].colorKey = dwVideoColorKey;
            npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].offset = dwSrcOffset;
            npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].sizeIn = asmMergeCoords((dwSrcWidth & ~1), (dwSrcHeight & ~1));
            npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].pointIn = 0;
            npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].dsDx = srcDeltaX;
            npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].dtDy = srcDeltaY;
            npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].pointOut = asmMergeCoords(lpUOData->rDest.left, lpUOData->rDest.top);
            npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].sizeOut = asmMergeCoords(dwDstWidth, dwDstHeight);
            npDev->dDrawSpare.Nv04VideoOverlay.SetOverlay[index].format = dwOverlayFormat;

            ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_OVERLAY;
            

            srcx = NULL;
            src  = NULL;
            }

        ppdev->dDrawSpareSubchannelObject = 0;

        /* Let DDraw know how many visible overlays are active */
        if (ppdev->HALInfo.ddCaps.dwCurrVisibleOverlays == 0)
            {
            ppdev->HALInfo.ddCaps.dwCurrVisibleOverlays = 1;
            }
        }
    ppdev->NVFreeCount = (short)freeCount;
    lpUOData->ddRVal = DD_OK;
    EXIT_DMA_PUSH_SYNC(DDHAL_DRIVER_HANDLED);

    } /* Nv4UpdateOverlay */


/******************************Public*Routine**********************************\
* DWORD DdSetOverlayPosition
*
\******************************************************************************/
DWORD __stdcall Nv4SetOverlayPosition( PDD_SETOVERLAYPOSITIONDATA lpSOPData )
    {
    DWORD           index = 0;
    DWORD           match = 0;
    PDEV *ppdev = (PDEV *) lpSOPData->lpDD->dhpdev;
    FAST Nv3ChannelPio  *npDev = (Nv3ChannelPio *)ppdev->ddChannelPtr;
    FAST USHORT     freeCount = ppdev->NVFreeCount;
    BOOL    releaseOpenglSemaphore = FALSE;

    PDD_SURFACE_LOCAL  srcx = lpSOPData->lpDDSrcSurface;

    if (!(srcx->ddsCaps.dwCaps & DDSCAPS_OVERLAY))
        {
        lpSOPData->ddRVal = DDERR_NOTAOVERLAYSURFACE;
        return DDHAL_DRIVER_HANDLED;
        }

    if ((lpSOPData->lXPos < 0) || (lpSOPData->lYPos < 0))
        {
        lpSOPData->ddRVal = DDERR_INVALIDPOSITION;
        return DDHAL_DRIVER_HANDLED;
        }

    while ((index < NV_MAX_OVERLAY_SURFACES) && (!match))
        if ((DWORD)srcx == ppdev->dwOverlaySurfaceLCL[index++])
            match = 1;

    if (!match)
        {
        lpSOPData->ddRVal = DDERR_OUTOFCAPS;
        return DDHAL_DRIVER_HANDLED;
        }

    if (npDev == NULL)
        {  /* Mode switches might occur without warning */
        lpSOPData->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
        }
        
    /* Alternate buffer indexes to keep the hardware happy */
	ppdev->OverlayBufferIndex ^= 1;
    index = ppdev->OverlayBufferIndex;

    ENTER_DMA_PUSH_SYNC();
    NV_DD_DMA_PUSHER_SYNC();
    freeCount = ppdev->NVFreeCount;

    /*
     * NOTES:
     *
     * This callback is invoked to set an overlay position
     */
    DPF( "SET OVERLAY POSITION" );
    DPF( "Overlay surface = %08lx", lpSOPData->lpDDSrcSurface );
    DPF( "(%ld,%ld)", lpSOPData->lXPos, lpSOPData->lYPos );

    while (freeCount < 2*4)
        freeCount = NvGetFreeCount(npDev, BLIT_SUBCHANNEL);
    freeCount -= 2*4;

    npDev->dDrawSpare.SetObject = NV_DD_VIDEO_OVERLAY;
    npDev->dDrawSpare.Nv04VideoOverlay.SetOverlayPointOutA = asmMergeCoords(lpSOPData->lXPos, lpSOPData->lYPos);
    ppdev->dwOverlayDstX = lpSOPData->lXPos;
    ppdev->dwOverlayDstY = lpSOPData->lYPos;

    ppdev->dDrawSpareSubchannelObject = 0;

    ppdev->NVFreeCount = (short)freeCount;

    lpSOPData->ddRVal = DD_OK;
    EXIT_DMA_PUSH_SYNC(DDHAL_DRIVER_HANDLED);

    } /* DdSetOverlayPosition */

/*
 * Nv4UnlockOverlay
 */
DWORD __stdcall Nv4UnlockOverlay( PDD_UNLOCKDATA lpUnlockData )
    {
    PDEV*   ppdev;
    FAST Nv3ChannelPio          *npDev;
    FAST USHORT                 freeCount;
    PDD_SURFACE_GLOBAL        pSurf_gbl;
    DWORD                       caps;
    DWORD                       dwSrcYOffset;
    DWORD                       dwSrcVOffset;
    DWORD                       dwSrcUOffset;
    long                        dwSrcYPitch;
    long                        dwSrcUVPitch;
    long                        dwSrcUVHeight;
    DWORD                       dwDstYOffset;
    long                        dwDstYPitch;
    unsigned char               *fpSrcYMem;
    unsigned char               *fpSrcUMem;
    unsigned char               *fpSrcVMem;
    long                        dwSrcPitch;
    long                        dwSrcWidth;
    long                        dwSrcHeight;
    BOOL    releaseOpenglSemaphore = FALSE;

    pSurf_gbl = lpUnlockData->lpDDSurface->lpGbl;
    ppdev = (PDEV *) lpUnlockData->lpDD->dhpdev;
    npDev = (Nv3ChannelPio *)ppdev->ddChannelPtr;

    caps = lpUnlockData->lpDDSurface->ddsCaps.dwCaps;


    //*************************************************************
    // Ensure GDI DMA Push channel processing has completed prior
    // to copying a large block of bitmap data into the fifo.
    //*************************************************************
    ENTER_DMA_PUSH_SYNC();
    NV_DD_DMA_PUSHER_SYNC();

    ppdev->pfnWaitEngineBusy(ppdev);

    /* If surface is IF09 format then must reformat data before
       video scaler can be used to display it */
    if ((pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_IF09) ||
        (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_YVU9) ||
        (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_IV32) ||
        (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_IV31))
        {

        dwSrcYOffset = pSurf_gbl->fpVidMem;
        dwSrcYPitch = (DWORD)pSurf_gbl->wWidth;
        dwSrcYPitch = (dwSrcYPitch + 3) & ~3L;
        dwDstYOffset = dwSrcYOffset + ((dwSrcYPitch * ((DWORD)pSurf_gbl->wHeight * 10L)) >> 3);
        dwDstYOffset = (dwDstYOffset + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;
        dwDstYPitch = ((pSurf_gbl->wWidth + 1) & 0xFFFE) << 1;
        dwDstYPitch = (dwDstYPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;

        fpSrcYMem = (unsigned char *)(ULONG)ppdev->pjFrameBufbase + pSurf_gbl->fpVidMem;
        dwSrcHeight = (DWORD)pSurf_gbl->wHeight;
        dwSrcHeight = (dwSrcHeight + 3) & ~3L;
        fpSrcVMem = fpSrcYMem + (dwSrcYPitch * dwSrcHeight);
        dwSrcHeight >>= 2;
        fpSrcUMem = fpSrcVMem + ((dwSrcYPitch >> 2) * dwSrcHeight);

        dwSrcUVHeight = (DWORD)pSurf_gbl->wHeight;
        dwSrcUVHeight = (dwSrcUVHeight + 3) & ~3L;
        dwSrcUVHeight >>= 2;

        dwSrcUVPitch = (DWORD)pSurf_gbl->wWidth;
        dwSrcUVPitch = (dwSrcUVPitch + 3) & ~3L;
        dwSrcUVPitch >>= 2;


        freeCount = ppdev->NVFreeCount;

        while (freeCount < 3*4)
            freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
        freeCount -= 3*4;

        npDev->dDrawRop.SetRop5 = 0xC0; /* MERGECOPY PSa */

        /* Temporarily change destination surface color format */
        npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetColorFormat =
            NV042_SET_COLOR_FORMAT_LE_Y8;

        DDRAW_SET_PRIMARY(ppdev, dwDstYOffset, dwDstYPitch);
        DDRAW_SET_SOURCE(ppdev, dwSrcYOffset, dwDstYPitch);
        while (freeCount < 16*4)
            freeCount = NvGetFreeCount(npDev, NV_DD_ROP);
        freeCount -= 16*4;

//        npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetOffsetDestin = dwDstYOffset;
//        npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetPitch =
//            (dwDstYPitch << 16) | dwDstYPitch;

        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternSelect =
        NV044_SET_PATTERN_SELECT_MONOCHROME;

        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeShape =
        NV044_SET_MONOCHROME_SHAPE_64X_1Y;

        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeColor1 = 0xFFFFFFFF;

        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeColor0 = 0;

        /* First enable only V values to be written */
        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromePattern0 =
        0x11111111;

        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromePattern1 =
        0x11111111;

        npDev->dDrawStretch.SetObject =
            NV_DD_STRETCHED_UV_IMAGE_FROM_CPU;

        npDev->dDrawStretch.nv4StretchedImageFromCpu.SizeIn =
            asmMergeCoords(dwSrcUVPitch, dwSrcUVHeight);

        npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipPoint = 0;

        npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipSize =
            asmMergeCoords((dwSrcYPitch << 1), (DWORD)pSurf_gbl->wHeight);

        npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDxDu =
            8 << 20;

        npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDyDv =
            4 << 20;

        npDev->dDrawStretch.nv4StretchedImageFromCpu.Point12d4 = 0;

        dwSrcHeight = dwSrcUVHeight;

        while (--dwSrcHeight >= 0)
            {
            FAST DWORD vPxls0;
            FAST DWORD vPxls1;

            dwSrcPitch = dwSrcUVPitch;
            
            dwSrcPitch = (dwSrcPitch + 3) & ~3;

            while (dwSrcPitch >= 16)
                {
                dwSrcPitch -= 16;

                while (freeCount < 16)
                    freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                freeCount -= 16;

                vPxls0 = *(unsigned long *)fpSrcVMem;
                vPxls1 = *(unsigned long *)&fpSrcVMem[4];
                npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[0] =
                vPxls0;
                vPxls0 = *(unsigned long *)&fpSrcVMem[8];
                npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[1] =
                vPxls1;
                vPxls1 = *(unsigned long *)&fpSrcVMem[12];
                npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[2] =
                vPxls0;
                fpSrcVMem += 16;
                npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[3] =
                vPxls1;
                }

            while (freeCount < 16)
                freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);

            while (dwSrcPitch >= 4)
                {
                dwSrcPitch -= 4;
                freeCount -= 4;
                vPxls0 = *(unsigned long *)fpSrcVMem;
                fpSrcVMem += 4;
                npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[0] =
                vPxls0;
                }
            }

        while (freeCount < 56)
            freeCount = NvGetFreeCount(npDev, NV_DD_PATTERN);
        freeCount -= 56;

        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetPatternSelect =
        NV044_SET_PATTERN_SELECT_MONOCHROME;

        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeShape =
        NV044_SET_MONOCHROME_SHAPE_64X_1Y;

        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeColor1 = 0xFFFFFFFF;

        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeColor0 = 0;

        /* Now enable only U values to be written */
        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromePattern0 =
        0x44444444;

        npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromePattern1 =
        0x44444444;

        npDev->dDrawStretch.SetObject = NV_DD_STRETCHED_UV_IMAGE_FROM_CPU;

        npDev->dDrawStretch.nv4StretchedImageFromCpu.SizeIn =
        asmMergeCoords(dwSrcUVPitch, dwSrcUVHeight);

        npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipPoint = 0;

        npDev->dDrawStretch.nv4StretchedImageFromCpu.ClipSize =
        asmMergeCoords((dwSrcYPitch << 1), (DWORD)pSurf_gbl->wHeight);

        npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDxDu = 8 << 20;

        npDev->dDrawStretch.nv4StretchedImageFromCpu.DeltaDyDv = 4 << 20;

        npDev->dDrawStretch.nv4StretchedImageFromCpu.Point12d4 = 0;
        dwSrcHeight = dwSrcUVHeight;

        while (--dwSrcHeight >= 0)
            {
            FAST DWORD uPxls0;
            FAST DWORD uPxls1;

            dwSrcPitch = dwSrcUVPitch;

            dwSrcPitch = (dwSrcPitch + 3) & ~3;
            
            while (dwSrcPitch >= 16)
                {
                dwSrcPitch -= 16;

                while (freeCount < 16)
                    freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
                freeCount -= 16;

                uPxls0 = *(unsigned long *)fpSrcUMem;
                uPxls1 = *(unsigned long *)&fpSrcUMem[4];
                npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[0] =
                uPxls0;
                uPxls0 = *(unsigned long *)&fpSrcUMem[8];
                npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[1] =
                uPxls1;
                uPxls1 = *(unsigned long *)&fpSrcUMem[12];
                npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[2] =
                uPxls0;
                fpSrcUMem += 16;
                npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[3] =
                uPxls1;
                }

            while (freeCount < 16)
                freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);

            while (dwSrcPitch >= 4)
                {
                dwSrcPitch -= 4;
                freeCount -= 4;
                uPxls0 = *(unsigned long *)fpSrcUMem;
                fpSrcUMem += 4;
                npDev->dDrawStretch.nv4StretchedImageFromCpu.Color[0] =
                uPxls0;
                }
            }

        while (freeCount < 54)
            freeCount = NvGetFreeCount(npDev, NV_DD_STRETCH);
        freeCount -= 54;


        /* reenable pattern object alpha */
       npDev->subchannel[NV_DD_PATTERN].nv4ImagePattern.SetMonochromeColor0 =
            0 | ppdev->AlphaEnableValue;

        /* restore destination surface color format */
        if (ppdev->cBitsPerPel == 8)
            npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetColorFormat =
                NV042_SET_COLOR_FORMAT_LE_Y8;
        else if (ppdev->cBitsPerPel == 16)
            npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetColorFormat =
                NV042_SET_COLOR_FORMAT_LE_R5G6B5;
        else
            npDev->subchannel[NV_DD_PRIMARY].nv4ContextSurfaces2D.SetColorFormat =
                NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_O8R8G8B8;

        /* Update all Y values */
        npDev->subchannel[NV_DD_SPARE].SetObject =
        NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
            dwSrcYOffset;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
            dwDstYOffset;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
            dwSrcYPitch;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
            dwDstYPitch;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
            dwSrcYPitch;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
            (DWORD)pSurf_gbl->wHeight;
            //NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_2;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
            1 | (2 << 8);

        //((NvNotification *)(&(ppdev->Notifiers->DmaToMem)))[1].status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;
        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify = NV039_NOTIFY_WRITE_ONLY;

        //while (((NvNotification *)(&ppdev->Notifiers->DmaToMem))[1].status == NV039_NOTIFICATION_STATUS_IN_PROGRESS);

        ppdev->dDrawSpareSubchannelObject = 0;
        ppdev->NVFreeCount = (short)freeCount;
        }
    else if ((pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_YV12)||
             (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_420i))
        {
        /* YV12/420i surfaces also need reformated before the video scaler can display them */
        DWORD srcMemType = 0;

        freeCount = ppdev->NVFreeCount;

        /* First determine which source buffer is being used */
        dwSrcYOffset = pSurf_gbl->fpVidMem; // - ppdev->NvFloatingMem2MemFormatBaseAddress;

        dwSrcYPitch = (DWORD)pSurf_gbl->wWidth;
        dwSrcYPitch = (dwSrcYPitch + 3) & ~3L;

        dwSrcWidth = dwSrcYPitch;

        if (dwSrcYOffset == ppdev->NvFloatingMem2MemFormatBaseAddress)
            dwDstYOffset = ppdev->NvYUY2Surface0Mem;
        else if (pSurf_gbl->fpVidMem == ppdev->NvFloatingMem2MemFormatNextAddress)
            dwDstYOffset = ppdev->NvYUY2Surface1Mem;
        else
            dwDstYOffset = ppdev->NvYUY2Surface2Mem;
#ifdef SYSMEM_FALLBACK
        /* Now correct source offset if it is really in video memory */
        if ((ppdev->NvFloatingMem2MemFormatBaseAddress >= pDriverData->BaseAddress) && /* If video memory */
            (pDriverData->NvFloatingMem2MemFormatBaseAddress < pDriverData->BaseAddress + 0x1000000))
            {
            dwSrcYOffset = pSurf_gbl->fpVidMem - pDriverData->BaseAddress;
            srcMemType = DDSCAPS_LOCALVIDMEM;
            }
#endif
        srcMemType = DDSCAPS_LOCALVIDMEM;
        dwDstYPitch = ((pSurf_gbl->wWidth + 1) & 0xFFFE) << 1;
        dwDstYPitch = (dwDstYPitch + ppdev->ulSurfaceAlign) & ~ppdev->ulSurfaceAlign;

        dwSrcHeight = (DWORD)pSurf_gbl->wHeight;
        dwSrcHeight = (dwSrcHeight + 1) & ~1L;

        if (pSurf_gbl->ddpfSurface.dwFourCC == FOURCC_YV12)
            {
            dwSrcVOffset = dwSrcYOffset + (dwSrcYPitch * dwSrcHeight);
            dwSrcUOffset = dwSrcVOffset + ((dwSrcYPitch * dwSrcHeight) >> 2);

            dwSrcUVPitch = (DWORD)pSurf_gbl->wWidth;
            dwSrcUVPitch = (dwSrcUVPitch + 3) & ~3L;
            dwSrcUVPitch >>= 1;

            }
        else
            { /* FOURCC_420i */
            dwSrcVOffset = dwSrcYOffset + dwSrcYPitch;
            dwSrcYPitch += (dwSrcYPitch >> 1);
            dwSrcUOffset = dwSrcVOffset + dwSrcYPitch;

            dwSrcUVPitch = dwSrcYPitch << 1;
            }

        dwSrcUVHeight = (DWORD)pSurf_gbl->wHeight;
        dwSrcUVHeight = (dwSrcUVHeight + 1) & ~1L;
        dwSrcUVHeight >>= 1;

        while (freeCount < 72)
            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
        freeCount -= 72;

        if (srcMemType == 0) /* If system memory */
            npDev->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT;
        else
            npDev->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
        dwSrcVOffset;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
        (dwDstYOffset + 3);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
        dwSrcUVPitch;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
        (dwDstYPitch << 1);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
        (dwSrcWidth >> 1);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
        dwSrcUVHeight;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
        1 | (4 << 8);
        //NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_4;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify = 0;

        if (srcMemType == 0) /* If system memory */
            npDev->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT;
        else
            npDev->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
        dwSrcUOffset;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
        (dwDstYOffset + 1);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
        dwSrcUVPitch;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
        (dwDstYPitch << 1);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
        (dwSrcWidth >> 1);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
        dwSrcUVHeight;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
        1 | (4 << 8);
        //NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_4;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify = 0;

        while (freeCount < 72)
            freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
        freeCount -= 72;

        if (srcMemType == 0) /* If system memory */
            npDev->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;
        else
            npDev->subchannel[NV_DD_SPARE].SetObject =
            NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
        dwSrcYOffset;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
        dwDstYOffset;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
        dwSrcYPitch;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
        dwDstYPitch;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
        dwSrcWidth;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
        (DWORD)pSurf_gbl->wHeight;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
        1 | (2 << 8);
        //NV_MTMF_FORMAT_INPUT_INC_1 | NV_MTMF_FORMAT_OUTPUT_INC_2;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify = 0;

        npDev->subchannel[NV_DD_SPARE].SetObject =
        NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetIn =
        (dwDstYOffset + 1);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.OffsetOut =
        (dwDstYOffset + 1 + dwDstYPitch);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchIn =
        (dwDstYPitch << 1);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.PitchOut =
        (dwDstYPitch << 1);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineLengthIn =
        (dwDstYPitch >> 1);

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.LineCount =
        (DWORD)pSurf_gbl->wHeight >> 1;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.Format =
        (2 << 8) | 2;
        //NV_MTMF_FORMAT_INPUT_INC_2 | NV_MTMF_FORMAT_OUTPUT_INC_2;

        npDev->subchannel[NV_DD_SPARE].nv3MemoryToMemoryFormat.BufferNotify = 0;

        ppdev->dDrawSpareSubchannelObject = 0;
        ppdev->NVFreeCount = (short)freeCount;
        }

    lpUnlockData->ddRVal = DD_OK;

    ppdev->pfnWaitEngineBusy(ppdev);
    EXIT_DMA_PUSH_SYNC(DDHAL_DRIVER_HANDLED);

    } /* Nv4UnlockOverlay */

extern "C" VOID __cdecl NvTurnOffVideoOverlay(PDEV *ppdev)
{
    FAST Nv3ChannelPio  *npDev = (Nv3ChannelPio *)ppdev->ddChannelPtr;
    FAST USHORT     freeCount = ppdev->NVFreeCount;

    WAIT_OVERLAY_NOTIFIER(0);
    WAIT_OVERLAY_NOTIFIER(1);

    while (freeCount < 3*4)
        freeCount = NvGetFreeCount(npDev, NV_DD_SPARE);
    freeCount -= 3*4;

    npDev->dDrawSpare.SetObject = NV_DD_VIDEO_OVERLAY;
    npDev->dDrawSpare.Nv04VideoOverlay.StopOverlay[0] = NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE;
    npDev->dDrawSpare.Nv04VideoOverlay.StopOverlay[1] = NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE;

    ppdev->dDrawSpareSubchannelObject = NV_DD_VIDEO_OVERLAY;

    WAIT_OVERLAY_NOTIFIER(0);
    WAIT_OVERLAY_NOTIFIER(1);

    ppdev->NVFreeCount = (short)freeCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\cliplist.c ===
//******************************Module*Header***********************************
// Module Name: cliplist.c
//
// management functions for CLIPLIST
//
// Copyright (c) 2000, NVIDIA, Corporation.  All rights reserved.
//
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
//
//******************************************************************************
#include "precomp.h"
#include "driver.h"
#include "RectUtils.h"

#include "cliplist.h"


//*************************************************************************
// bClipListAlloc
//
// allocates a CLIPLIST that can store cMax clip rects.
// All members are initilized to 0 if we don't fail.
//
// return: TRUE  - Success, cMax and array set to new values
//         FALSE - Failure, pClip isn't touched
//
// FNicklis 24.11.98: New
//*************************************************************************
BOOL bClipListAlloc(
  IN OUT CLIPLIST *pClip, // structure to fill out
  IN     LONG      cMax)  // number of rects to allocate
{
  BOOL   bRet = FALSE;
  RECTL *prcl = NULL;

  DBG_TRACE_IN(DBG_LVL_SUBENTRY, bClipListAlloc);

  ASSERTDD(bClipListCheck(pClip),"function isn't used correctly!");
  ASSERTDD(NULL==pClip->prcl,    "cliplist not empty!");
  ASSERTDD(0==pClip->cMax,       "cliplist not empty!");

  prcl = EngAllocMem(FL_ZERO_MEMORY, cMax*sizeof(RECTL), ALLOC_TAG);

  if (NULL == prcl)
  {
    // don't touch structure and exit
    DBG_ERROR("EngAllocMem failed for clip list");
    goto Exit;
  }

  // clear all members as we start a new clip list
  RtlZeroMemory(pClip, sizeof(CLIPLIST));

  pClip->cMax = cMax;
  pClip->prcl = prcl;

  bRet = TRUE;

Exit:
  DBG_TRACE_OUT(DBG_LVL_SUBENTRY, bRet);

  return (bRet);
}


//*************************************************************************
// bClipListFree
//
// Free a cliplist 
//
// return: TRUE=OK, FALSE=error.
//
// FNicklis 01.11.98: New from bFreeNegativeClipList
//*************************************************************************
BOOL bClipListFree(
  IN OUT CLIPLIST *pClip)
{
  BOOL      bRet = FALSE;

  DBG_TRACE_IN(DBG_LVL_SUBENTRY, bClipListFree);

  ASSERTDD(bClipListCheck(pClip),"function isn't used correctly!");

  // is there a cliplist to free?
  if ( (pClip->prcl != NULL) )
  {
    DISPDBG((10,"free %d rects in %d sized buffer",pClip->c,pClip->cMax));
    // all rects should have been counted too then
    // free and invalidate list
    EngFreeMem(pClip->prcl);

    // clear entire structure
    RtlZeroMemory(pClip, sizeof(CLIPLIST));
  }
  else
  {
    DISPDBG((10,"nothing to do"));
  }
  bRet = TRUE;

  DBG_TRACE_OUT(DBG_LVL_SUBENTRY, bRet);

  return (bRet);
}


#define CLIPLIST_GRANULARITY 8

//*************************************************************************
// bClipListReAlloc
//
// Realloc on clip list. Either shrink or grow a cliplist, keeping
// existing data.
//
// return: TRUE  - Success, cMax and array set to new values
//         FALSE - Failure, pClip isn't touched
//
// FNicklis 24.11.98: New
//*************************************************************************
BOOL bClipListReAlloc(
  IN OUT CLIPLIST *pClip,  // structure to fill out
  IN     LONG      cNew)   // number of rects to allocate
{
    BOOL      bRet = FALSE;
    RECTL    *prcl = NULL;
    LONG      cNewMax;
    LONG      c;
    CLIPLIST  NewClip = {0};

    ASSERTDD(bClipListCheck(pClip),"function isn't used correctly!");
    ASSERTDD(NULL!=pClip->prcl,    "cliplist empty!");
    ASSERTDD(0!=pClip->cMax,       "cliplist empty!");

    cNewMax = max(CLIPLIST_GRANULARITY, ((cNew + CLIPLIST_GRANULARITY - 1) / CLIPLIST_GRANULARITY) * CLIPLIST_GRANULARITY);

    if (cNewMax != pClip->cMax)
    {
        if (!bClipListAlloc(&NewClip, cNewMax))
          goto Exit;

        c = min(pClip->c, cNew);

        // copy current rects (if available) to new array
        if (c > 0)
        {
            RtlCopyMemory(NewClip.prcl, pClip->prcl, (c * sizeof(RECTL)) );
            NewClip.c = c;
        }

        bClipListFree(pClip);

        *pClip = NewClip;
    }
    // else nothing to do

    bRet = TRUE;

Exit:
    ASSERTDD(bClipListCheck(pClip),"clip list is now destroyed!");
    return (bRet);
}


//*************************************************************************
// bClipListCopy
//
// Copy max of cOutMax rects out of CLIPLIST to prclOut
//
// return: count of rects copied to prclOut
//
// FNicklis 01.11.98: New
//*************************************************************************
LONG lClipListCopy(
  OUT       RECTL    *prclOut,
  IN        LONG      cOutMax,
  IN  const CLIPLIST *pClip)
{
  LONG lRects = 0; // default is "nothing done"

  DBG_TRACE_IN(DBG_LVL_SUBENTRY, lClipListCopy);
  
  ASSERTDD(bClipListCheck(pClip),"function isn't used correctly!");
  ASSERTDD(cOutMax>0,               "function isn't used correctly!");
  ASSERTDD(NULL!=prclOut,           "function isn't used correctly!");
  
  if (pClip->c > 0)
  {
    ASSERTDD(NULL!=prclOut, "");

    // cannot copy more than room in output buffer!
    lRects = min(pClip->c,cOutMax);

    RtlCopyMemory(
      prclOut,              // dst
      pClip->prcl,          // src
      lRects*sizeof(RECTL));// count
  }

  // check if outputbuffer was to small
  DISPDBGCOND(lRects!=pClip->c, (1, "WARNING in lClipListCopy: cOutMax:%d for pClip->c:%d to small?",cOutMax, pClip->c));

  DBG_TRACE_OUT(DBG_LVL_SUBENTRY, lRects);
  return (lRects);
}

LONG lClipListPixelCount(CLIPLIST *pClip)
{
  LONG      lRects;

  pClip->cPixel = 0;
  for (lRects = 0; lRects <pClip->c; lRects++)
  {
    pClip->cPixel += lRclPixelCount(&pClip->prcl[lRects]);
  }
  return (pClip->cPixel);
}


BOOL bClipListCheck(
  IN  const CLIPLIST *pClip)
{
  BOOL bRet = FALSE;

  if (NULL==pClip)
    bRet = FALSE; // invalid pointer
  else
  {
    if ( (pClip->prcl!=NULL) &&          // if allocated
         (pClip->cMax   >  0) &&         // we need a max amount of rects
         (pClip->cMax   >= pClip->c) &&  // cannot store more than max
         (pClip->c      >= 0) &&         // rects should be stored, or 0 -> reason to free a buffer!
         (pClip->cPixel >= 0) )          // pixels should be counted
    {
     bRet = TRUE;
    }
    else if ( (pClip->prcl   == NULL) && // not allocated
              (pClip->cMax   == 0) &&    // max must be null
              (pClip->c      == 0) &&    // nothing stored
              (pClip->cPixel == 0) )     // no pixels
    {
     bRet = TRUE;
    }
    else
    {
      bRet = FALSE;                     // error
    }
  }
  return (bRet);
}


// End of cliplist.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\brush.c ===
//******************************Module*Header***********************************
//
// Module Name: Brush.c
//
// Handles all brush/pattern initialization and realization.
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/


#include "precomp.h"
#include "driver.h"

/******************************Public*Routine**********************************\
* VOID vRealizeDitherPattern
*
* Generates an 8x8 dither pattern, in our internal realization format, for
* the colour ulRGBToDither.  Note that the high byte of ulRGBToDither does
* not need to be set to zero, because vComputeSubspaces ignores it.
\******************************************************************************/

VOID vRealizeDitherPattern(
RBRUSH*     prb,
ULONG       ulRGBToDither)
{
    ULONG           ulNumVertices;
    VERTEX_DATA     vVertexData[4];
    VERTEX_DATA*    pvVertexData;
    LONG            i;

    // Calculate what colour subspaces are involved in the dither:

    pvVertexData = vComputeSubspaces(ulRGBToDither, vVertexData);

    // Now that we have found the bounding vertices and the number of
    // pixels to dither for each vertex, we can create the dither pattern

    ulNumVertices = (ULONG)(pvVertexData - vVertexData);
                      // # of vertices with more than zero pixels in the dither

    // Do the actual dithering:

    vDitherColor(&prb->aulPattern[0], vVertexData, pvVertexData, ulNumVertices);

    // Initialize the fields we need:

    prb->ptlBrushOrg.x = LONG_MIN;
    prb->fl            = 0;

    for (i = 0; i < MAX_BOARDS; i++)
    {
        prb->apbe[i] = NULL;
    }
}

//******************************************************************************
//
//  Function:   DrvRealizeBrush()
//
//  Routine Description:
//
//     This function allows us to convert GDI brushes into an internal form
//     we can use.  It may be called directly by GDI at SelectObject time, or
//     it may be called by GDI as a result of us calling BRUSHOBJ_pvGetRbrush
//     to create a realized brush in a function like DrvBitBlt.
//
//     Note that we have no way of determining what the current Rop or brush
//     alignment are at this point.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL DrvRealizeBrush(
BRUSHOBJ*   pbo,
SURFOBJ*    psoDst,
SURFOBJ*    psoPattern,
SURFOBJ*    psoMask,
XLATEOBJ*   pxlo,
ULONG       iHatch)

    {
    PDEV*       ppdev;
    ULONG       iPatternFormat;
    BYTE*       pjSrc;
    BYTE*       pjDst;
    LONG        lSrcDelta;
    LONG        cj;
    LONG        i;
    LONG        j;
    RBRUSH*     prb;
    ULONG*      pulXlate;
    SURFOBJ*    psoPunt;
    RECTL       rclDst;
    BOOL        b;

    ppdev = (PDEV*) psoDst->dhpdev;


    //**************************************************************************
    // We only handle brushes if we have an off-screen brush cache
    // available.  If there isn't one, we can simply fail the realization,
    // and eventually GDI will do the drawing for us (although a lot
    // slower than we could have done it):
    //
    // NOTE: Currently, BRUSH_CACHE is always disabled in Enable.c
    //       For now, we're just going to get the pattern straight from
    //       the brush structure and not cache it....eventually
    //       we'll store it in offscreen memory...but for now...we just
    //       want to get brush functionality working. (without caching)
    //**************************************************************************

    //**************************************************************************
    //    if (!(ppdev->flStatus & STAT_BRUSH_CACHE))
    //        goto ReturnFalse;
    //**************************************************************************

    //**************************************************************************
    // We have a fast path for dithers when we set GCAPS_DITHERONREALIZE:
    // For now, just return false.
    //**************************************************************************

    if (iHatch & RB_DITHERCOLOR)
        {
        //**********************************************************************
        // Implementing DITHERONREALIZE increased our score on a certain
        // unmentionable benchmark by 0.4 million 'megapixels'.  Too bad
        // this didn't work in the first version of NT.
        //**********************************************************************

        //**********************************************************************
        // NV: This case doesn't seem to buy us that much of an improvement.
        //     Leaving out for now...
        //
        //        prb = BRUSHOBJ_pvAllocRbrush(pbo,
        //               sizeof(RBRUSH) + CONVERT_TO_BYTES(TOTAL_BRUSH_SIZE, ppdev));
        //        if (prb == NULL)
        //            goto ReturnFalse;
        //
        //        vRealizeDitherPattern(prb, iHatch);
        //        goto ReturnTrue;
        //**********************************************************************

        goto ReturnFalse;

        }

    //**************************************************************************
    // We only accelerate 8x8 patterns.  Since Win3.1 and Chicago don't
    // support patterns of any other size, it's a safe bet that 99.9%
    // of the patterns we'll ever get will be 8x8:
    //**************************************************************************

    if ((psoPattern->sizlBitmap.cx != 8) ||
        (psoPattern->sizlBitmap.cy != 8))
        goto ReturnFalse;

    iPatternFormat = psoPattern->iBitmapFormat;

    //**************************************************************************
    // Allocate memory for our RBRUSH structure.  The actual
    // pattern bits are stored at the end of this structure.
    //**************************************************************************

    prb = BRUSHOBJ_pvAllocRbrush(pbo,
          sizeof(RBRUSH) + CONVERT_TO_BYTES(TOTAL_BRUSH_SIZE, ppdev));
    if (prb == NULL)
        goto ReturnFalse;

    //**************************************************************************
    // Initialize the fields we need:
    // BrushOrg.X will be initialized to the smallest value possible.
    // Flags will be init to NULL.
    //**************************************************************************

    prb->ptlBrushOrg.x = LONG_MIN;
    prb->fl            = 0;

    //**************************************************************************
    // For now, multi board functionality isn't important to us.
    // MAX_BOARDS should be 1.
    //**************************************************************************

    for (i = 0; i < MAX_BOARDS; i++)
        {
        prb->apbe[i] = NULL;
        }

    //**************************************************************************
    // Now let's take a look at the pattern bitmap.
    // Get the pitch and ptr to the pattern bitmap
    // Also get a ptr to the aulpattern array where we'll store the pattern bits.
    //**************************************************************************

    lSrcDelta = psoPattern->lDelta;
    pjSrc     = (BYTE*) psoPattern->pvScan0;
    pjDst     = (BYTE*) &prb->aulPattern[0];

    //**************************************************************************
    // Handle simple case where pattern bitmap format is same
    // as current screen bitmap format, and palette translation is not required.
    //**************************************************************************

    if ((ppdev->iBitmapFormat == iPatternFormat) &&
        ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
        {
        DISPDBG((2, "Realizing un-translated brush"));

        //**********************************************************************
        // The pattern is the same colour depth as the screen, and
        // there's no translation to be done:
        //**********************************************************************

        cj = CONVERT_TO_BYTES(8, ppdev);  // Every pattern is 8 pels wide

        //**********************************************************************
        // RtlCopyMemory is a RunTime library routine (Destination,Src,Length in bytes)
        //**********************************************************************

        for (i = 8; i != 0; i--)
            {
            RtlCopyMemory(pjDst, pjSrc, cj);

            pjSrc += lSrcDelta;
            pjDst += cj;
            }

        }

    //**************************************************************************
    // Don't do monochrome expansion on 24 bpp due to s3 968 feature.
    // For NV, we currently don't support 24bpp anyway.
    // All monochrome expansion will get done here.
    //**************************************************************************

    else if ((iPatternFormat == BMF_1BPP) && (ppdev->iBitmapFormat != BMF_24BPP))

        {
        DISPDBG((2, "Realizing 1bpp brush"));

        //**********************************************************************
        // We word align the monochrome bitmap so that every row starts
        // on a new word (so that we can do word writes later to transfer
        // the bitmap):
        //
        // NV: For NV, we'll just set the pattern object to be an 8x8 pattern.
        //     2 patterns registers (2 dwords) need to be set as follows:
        //                               -------------------------------------
        //          Pattern register 0  | byte 3 |  byte 2 |  byte 1 | byte 0 |
        //                               -------------------------------------
        //                               -------------------------------------
        //          Pattern register 1  | byte 7 |  byte 6 |  byte 5 | byte 4 |
        //                               -------------------------------------
        //
        //     This defines a total of 64 bits (8x8 monochrome pattern)
        //
        //**********************************************************************

        for (i = 8; i != 0; i--)
            {
            *pjDst = *pjSrc;
            pjDst ++;                           // Store NV monochrome pattern bytes
            pjSrc += lSrcDelta;                 // Usually src pattern is dword aligned
            }

        pulXlate         = pxlo->pulXlate;
        prb->fl         |= RBRUSH_2COLOR;
        prb->ulForeColor = pulXlate[1];
        prb->ulBackColor = pulXlate[0];

        }

    //**************************************************************************
    // Pattern is 4bpp, device is currently at 8bpp
    //**************************************************************************

    else if ((iPatternFormat == BMF_4BPP) && (ppdev->iBitmapFormat == BMF_8BPP))

        {
        //**********************************************************************
        // NV: This case doesn't have a signficant impact on performance
        //     so we'll skip it for now.
        //**********************************************************************

        //**********************************************************************
        //        DISPDBG((2, "Realizing 4bpp brush"));
        //
        //        //************************************************************
        //        // The screen is 8bpp and the pattern is 4bpp:
        //        //************************************************************
        //
        //        ASSERTDD((ppdev->iBitmapFormat == BMF_8BPP) &&
        //                 (iPatternFormat == BMF_4BPP),
        //                 "Messed up brush logic");
        //
        //        pulXlate = pxlo->pulXlate;
        //
        //        for (i = 8; i != 0; i--)
        //            {
        //            //********************************************************
        //            // Inner loop is repeated only 4 times because each loop
        //            // handles 2 pixels:
        //            //********************************************************
        //
        //            for (j = 4; j != 0; j--)
        //                {
        //                *pjDst++ = (BYTE) pulXlate[*pjSrc >> 4];
        //                *pjDst++ = (BYTE) pulXlate[*pjSrc & 15];
        //                pjSrc++;
        //                }
        //
        //            pjSrc += lSrcDelta - 4;
        //            }
        //
        //**********************************************************************

        goto ReturnFalse;

        }


    //**************************************************************************
    // NV: Unrecognized/ brush format.  Just punt back to GDI
    //**************************************************************************

    else

        {
        //**********************************************************************
        // We've got a brush whose format we haven't special cased.  No
        // problem, we can have GDI convert it to our device's format.
        // We simply use a temporary surface object that was created with
        // the same format as the display, and point it to our brush
        // realization:
        //**********************************************************************

        DISPDBG((5, "Realizing funky brush"));

        psoPunt          = ppdev->psoPunt3;
        psoPunt->pvBits  = pjDst;
        psoPunt->pvScan0 = pjDst;
        psoPunt->lDelta  = CONVERT_TO_BYTES(8, ppdev);

        rclDst.left      = 0;
        rclDst.top       = 0;
        rclDst.right     = 8;
        rclDst.bottom    = 8;

        ppdev->pfnWaitEngineBusy(ppdev);
        b = ppdev->pfnEngCopyBits(psoPunt, psoPattern, NULL, pxlo,
                                  &rclDst, (POINTL*) &rclDst);

        if (!b)
            {
            goto ReturnFalse;
            }

        }

//**************************************************************************
// ReturnTrue:
//**************************************************************************

    //**************************************************************************
    // NV: Skip following code for now... (we currently don't store
    //     patterns in offscreen memory
    //**************************************************************************

    //**************************************************************************
    //    if (!(ppdev->flCaps & CAPS_HW_PATTERNS))
    //    {
    //        // The last time I checked, GDI took some 500 odd instructions to
    //        // get from here back to whereever we called 'BRUSHOBJ_pvGetRbrush'.
    //        // We can at least use this time to get some overlap between the
    //        // CPU and the display hardware: we'll initialize the 72x72 off-
    //        // screen cache entry now, which will keep the accelerator busy for
    //        // a while.
    //        //
    //        // We don't do this if we have hardware patterns because:
    //        //
    //        //   a) S3 hardware patterns require that the off-screen cached
    //        //      brush be correctly aligned, and at this point we don't have
    //        //      access to the 'pptlBrush' brush origin (although we could
    //        //      have copied it into the PDEV before calling
    //        //      BRUSHOBJ_pvGetRbrush).
    //        //
    //        //   b) S3 hardware patterns require only an 8x8 copy of the
    //        //      pattern; it is not expanded to 72x72, so there isn't even
    //        //      any opportunity for CPU/accelerator processing overlap.
    //
    //        vIoSlowPatRealize(ppdev, prb, FALSE);
    //    }
    //**************************************************************************

    return(TRUE);

ReturnFalse:


    //**************************************************************************
    // NV: Failed call, let GDI handle it
    //**************************************************************************

    if (psoPattern != NULL)
        {
        DISPDBG((2, "Failed realization -- Type: %li Format: %li cx: %li cy: %li",
                    psoPattern->iType, psoPattern->iBitmapFormat,
                    psoPattern->sizlBitmap.cx, psoPattern->sizlBitmap.cy));
        }

    return(FALSE);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\bitblt.c ===
//**************************** Module Header ***********************************
//
// Module Name: bitblt.c
//
// Contains the high-level DrvBitBlt and DrvCopyBits functions.  The low-
// level stuff lives in the 'blt??.c' files.
//
// Note: Since we've implemented device-bitmaps, any surface that GDI passes
//       to us can have 3 values for its 'iType': STYPE_BITMAP, STYPE_DEVICE
//       or STYPE_DEVBITMAP.  We filter device-bitmaps that we've stored
//       as DIBs fairly high in the code, so after we adjust its 'pptlSrc',
//       we can treat STYPE_DEVBITMAP surfaces the same as STYPE_DEVICE
//       surfaces (e.g., a blt from an off-screen device bitmap to the screen
//       gets treated as a normal screen-to-screen blt).
//
//       Unfortunately, if we've created our primary surface as a device-
//       managed surface, it has an 'iType' of STYPE_BITMAP and not
//       STYPE_DEVICE.  So throughout this code, we will determine if a
//       surface is one of ours by checking 'dhsurf' -- a NULL value means
//       that it's a GDI-created DIB, otherwise it's one of our surfaces and
//       'dhsurf' points to our DSURF structure.
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"
#include "nvapi.h"
#include "oglDD.h"
#include "oglOverlay.h"
#include "oglsync.h"

VOID CopyDIBBitmaps (DSURF*, BYTE*, BYTE*, ULONG, ULONG); // forward declaration

typedef enum {
    NONE=0,
    COPYBLIT,
    IMAGEFROMCPU
} ALPHA_SAVE;


extern VOID NV4DmaPushAlphaPreserve(PPDEV, BOOL, BOOL);
#if _WIN32_WINNT >= 0x0500
extern VOID NV4DmaPushSetColorKey(PPDEV, ULONG, ULONG);
extern BOOL NV4CheckAlphaBlendOK(PPDEV);
extern BOOL NV4DmaPushCopyAlphaBlt(PPDEV, LONG, RECTL*, ULONG, POINTL*, RECTL*, BLENDOBJ*);
#endif _WIN32_WINNT >= 0x0500
    
//******************************************************************************
//
//  Function:   PrepareSurfacesForPunt
//
//  Routine Description:
//
//      GDI only knows how to write to standard DIB surfaces.
//      That means, if the SOURCE or DEST is a DFB, we need to create a standard
//      DIB SurfObj in place of the device managed surface (DFB) object in order
//      to let GDI do the blit.
//
//      Essentially, there are 4 types of SURFOBJS we'll encounter.
//
//              1) System Memory SurfObj (Standard DIB)
//                  We can pass this surfobj to GDI as is.
//
//              2) DFB - exists in offscreen VRAM memory
//                  Need to create a standard DIB SurfObj to let GDI draw to this surface
//
//              3) DFB - exists in system memory
//                  Need to create a standard DIB surfObj to let GDI draw to this surface
//
//              4) Primary Surface VRAM (Standard DIB format)
//                  We can pass this surfobj to GDI as is.
//
//              CONDITION                                           SURFOBJ TYPE
//              ---------                                           ------------
//
//      (pdsurf != NULL)  &&  (pdsurf->dt == DT_DIB)         --> This is a DFB in system memory
//      (pdsurf != NULL)  &&  (pdsurf->dt == DT_SCREEN)      --> This is a DFB in offscreen VRAM memory
//
//      (pdsurf == NULL)  &&  (pvBits != ppdev->pjScreen)    --> Standard DIB
//      (pdsurf == NULL)  &&  (pvBits == ppdev->pjScreen)    --> Primary Screen Surface
//
//  Arguments:
//
//      Src, Dst SURFOBJ pointers
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID PrepareSurfacesForPunt(
    SURFOBJ*    psoSrc,
    SURFOBJ*    psoDst,
    SURFOBJ**   pTempSrcSurfObjPtr,
    SURFOBJ**   pTempDstSurfObjPtr,
    PDEV*       ppdev
)
{
    DSURF*          pdsurfDst;
    DSURF*          pdsurfSrc;
    SURFOBJ*        SrcPuntPtr;
    SURFOBJ*        DstPuntPtr;

    //**************************************************************************
    // Default to Standard DIB, and get handles to surfaces if they exist
    //**************************************************************************

    (VOID *)pdsurfSrc = NULL;
    (VOID *)pdsurfDst = NULL;

    if ((VOID *)psoSrc != NULL)
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    if ((VOID *)psoDst != NULL)
        pdsurfDst = (DSURF*) psoDst->dhsurf;

    //**************************************************************************
    // Default to using the original, un-modified SURFOBJ's that were passed to us.
    //**************************************************************************

    *pTempSrcSurfObjPtr = psoSrc;
    *pTempDstSurfObjPtr = psoDst;

    //**************************************************************************
    // Get pointers to the 'wrapper' surfaces that we use to draw to the
    // screen surface if necessary.  These surfaces are locked.
    // (The surfaces that we pass to GDI MUST be locked).
    // See EnableOffscreenHeap for more information.
    //**************************************************************************

    SrcPuntPtr = ppdev->psoPunt;
    DstPuntPtr = ppdev->psoPunt2;

    //**************************************************************************
    // Check if source bitmap is a DFB.  If so, create a temporary surfobj
    // (mapped to the screen) that GDI can read from
    //**************************************************************************

    if (pdsurfSrc !=0 )
        {
        SrcPuntPtr->dhsurf      = 0;                    // Behave like a standard DIB
        if (pdsurfSrc->dt == DT_SCREEN)
            {
            SrcPuntPtr->sizlBitmap  = pdsurfSrc->sizl;
            SrcPuntPtr->cjBits  = pdsurfSrc->LinearStride * pdsurfSrc->sizl.cy;
            SrcPuntPtr->pvBits  = pdsurfSrc->LinearPtr;
            SrcPuntPtr->pvScan0 = pdsurfSrc->LinearPtr;
            SrcPuntPtr->lDelta  = pdsurfSrc->LinearStride;
            // adi we cannot use the ppdev->iBitmapFormat because we may have to do
            // with a surface wrapped around a DD surface by DrvDeriveSurface
            SrcPuntPtr->iBitmapFormat = psoSrc->iBitmapFormat;
            }
        else
            {
            //**********************************************************************
            // This is a DFB which is stored in main memory as a DIB
            //**********************************************************************
            SrcPuntPtr->sizlBitmap  = pdsurfSrc->pso->sizlBitmap;
            SrcPuntPtr->cjBits      = pdsurfSrc->pso->lDelta * pdsurfSrc->pso->sizlBitmap.cy;
            SrcPuntPtr->pvBits  = pdsurfSrc->pso->pvBits;
            SrcPuntPtr->pvScan0 = pdsurfSrc->pso->pvScan0;
            SrcPuntPtr->lDelta  = pdsurfSrc->pso->lDelta;
            SrcPuntPtr->iBitmapFormat = pdsurfSrc->pso->iBitmapFormat;
            }

        //**********************************************************************
        // Use the 'wrapper' surface, instead of the original DFB surfobj for GDI
        //**********************************************************************

        *pTempSrcSurfObjPtr       = SrcPuntPtr;
        }


    //**************************************************************************
    // Check if destination bitmap is a DFB.  If so, create a temporary surfobj
    // (mapped to the screen) that GDI can write on
    //**************************************************************************

    if (pdsurfDst !=0 )
        {
        DstPuntPtr->dhsurf      = 0;                    // Behave like a standard DIB
        if (pdsurfDst->dt == DT_SCREEN)
            {
            DstPuntPtr->sizlBitmap  = pdsurfDst->sizl;
            DstPuntPtr->cjBits  = pdsurfDst->LinearStride * pdsurfDst->sizl.cy;
            DstPuntPtr->pvBits  = pdsurfDst->LinearPtr;
            DstPuntPtr->pvScan0 = pdsurfDst->LinearPtr;
            DstPuntPtr->lDelta  = pdsurfDst->LinearStride;
            // adi we cannot use the ppdev->iBitmapFormat because we may have to do
            // with a surface wrapped around a DD surface by DrvDeriveSurface
            DstPuntPtr->iBitmapFormat = psoDst->iBitmapFormat;
            }
        else
            {
            //**********************************************************************
            // This is a DFB which is stored in main memory as a DIB
            //**********************************************************************
            DstPuntPtr->sizlBitmap  = pdsurfDst->pso->sizlBitmap;
            DstPuntPtr->cjBits      = pdsurfDst->pso->lDelta * pdsurfDst->pso->sizlBitmap.cy;
            DstPuntPtr->pvBits  = pdsurfDst->pso->pvBits;
            DstPuntPtr->pvScan0 = pdsurfDst->pso->pvScan0;
            DstPuntPtr->lDelta  = pdsurfDst->pso->lDelta;
            DstPuntPtr->iBitmapFormat = pdsurfDst->pso->iBitmapFormat;
            }

        //**********************************************************************
        // Use the 'wrapper' surface, instead of the original DFB surfobj for GDI
        //**********************************************************************

        *pTempDstSurfObjPtr       = DstPuntPtr;
        }
}


//******************************************************************************
//
//  Macro:   TRY_MOVE_SRC_TO_OFFSCREEN_MEM
//
//  Macro Description:
//
//      check and see if we can move system memory DFB's back into                  
//      offscreen VRAM for better performance. That is, at some point, we put a DFB 
//      in system memory. Now we determine that if this DFB is getting              
//      used a lot, put it back in offscreen VRAM so we can regain performance.     
//
//*****************************************************************************
#define TRY_MOVE_SRC_TO_OFFSCREEN_MEM(psoSrc, pdsurfSrc, pxlo, ppdev)                           \
{                                                                                               \
    if ( (pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_DIB) )                                     \
        {                                                                                       \
        /***********************************************************************/               \
        /* Here we consider putting a DIB DFB back into off-screen             */               \
        /* memory.  If there's a translate, it's probably not worth            */               \
        /* moving it since we won't be able to use the hardware to do          */               \
        /* the blt (a similar argument could be made for weird rops            */               \
        /* and stuff that we'll only end up having GDI simulate, but           */               \
        /* those should happen infrequently enough that I don't care).         */               \
        /***********************************************************************/               \
        if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))                                     \
            {                                                                                   \
            ASSERTDD(pdsurfSrc->pso->iBitmapFormat == ppdev->iBitmapFormat, "oops");            \
                                                                                                \
            if (pdsurfSrc->iUniq == ppdev->iHeapUniq)                                           \
                {                                                                               \
                /*****************************************************************/             \
                /* Attempt to move DIB back to offscreen VRAM.                   */             \
                /* This won't necessarily succeed.                               */             \
                /*                                                               */             \
                /* NOTE: If space doesn't get freed up for a while (heapUniq     */             \
                /*       remains the same), and this call fails, then cBlt will  */             \
                /*       wrap around to 0xffffffff, meaning we won't consider    */             \
                /*       putting this DFB DIB back into offscreen VRAM for a     */             \
                /*       LONG time, until someone frees up some offscreen memory,*/             \
                /*       and causes cBlt to be reset to HEAP_COUNT_DOWN.         */             \
                /*****************************************************************/             \
                if (--pdsurfSrc->cBlt == 0)                                                     \
                    if (bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfSrc))                         \
                        {                                                                       \
                            /* Now in offscreen, ptrs OK as is so return */                     \
                            goto MoveComplete;                                                  \
                        }                                                                       \
                }                                                                               \
                else                                                                            \
                {                                                                               \
                /***************************************************************/               \
                /* Some space was freed up in off-screen memory,               */               \
                /* so reset the counter for this DFB:                          */               \
                /***************************************************************/               \
                pdsurfSrc->iUniq = ppdev->iHeapUniq;                                            \
                pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;                                             \
                }                                                                               \
            }                                                                                   \
                                                                                                \
        psoSrc = pdsurfSrc->pso;                                                                \
        pdsurfSrc = (DSURF *) psoSrc->dhsurf;                                                   \
                                                                                                \
        }                                                                                       \
MoveComplete: ;                                                                                 \
}


//******************************************************************************
//
//  Function:   GenericBitBltAlpha
//
//  Routine Description:
//
//      Implements the workhorse routine of a display driver.
//      Called by DrvBitBlt and DrvAlphaBlend to do bit block transfers
//      Called by DrvCopyBits in some cases.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL GenericBitBltAlpha(
    SURFOBJ*    psoDst,
    SURFOBJ*    psoSrc,
    SURFOBJ*    psoMsk,
    CLIPOBJ*    pco,
    XLATEOBJ*   pxlo,
    RECTL*      prclDst,
    RECTL*      prclSrc,
    POINTL*     pptlSrc,
    POINTL*     pptlMsk,
    BRUSHOBJ*   pbo,
    POINTL*     pptlBrush,
    ROP4        rop4,
    BLENDOBJ*   pBlendObj,
    PDEV*       ppdev
)

    {
    DSURF*          pdsurfDst;
    DSURF*          pdsurfSrc;
    POINTL          ptlSrc;
    BYTE            jClip;
    BOOL            bMore;
    CLIPENUM        ce;
    LONG            c;
    RECTL           rcl;
    BYTE            rop3;
    FNFILL*         pfnFill;
    RBRUSH_COLOR    rbc;        // Realized brush or solid colour
    FNXFER*         pfnXfer;
    FNSCRNTOMEM*    pfnStoM;
    ULONG           iSrcBitmapFormat;
    ULONG           iDstBitmapFormat;
    ULONG           iDir;
    BOOL            bRet;
    ULONG*          CheckSurfPtr;
    ULONG*          CheckPdevPtr;
    ULONG*          ScreenBitmap;
    ULONG*          DstBits;
    ULONG*          SrcBits;
    ULONG           PatternColor;

    SURFOBJ*        SrcPuntPtr;
    SURFOBJ*        DstPuntPtr;
    SURFOBJ*        TempDstSurfObjPtr;
    SURFOBJ*        TempSrcSurfObjPtr;

    ULONG           SrcOffset;
    ULONG           DstOffset;
    ULONG           SrcStride;
    ULONG           DstStride;

    ALPHA_SAVE      alphaPreserve=NONE;

    //**************************************************************************
    // Assume successful blit
    //**************************************************************************

    bRet = TRUE;

    // Alpha only supported on Win2k
#if _WIN32_WINNT >= 0x0500

    if (pBlendObj)
        {
        // Trivially reject AlphaBlends we can't do
        if ((pxlo && pxlo->flXlate && !(pxlo->flXlate & XO_TRIVIAL) ) ||
            ((ppdev->iBitmapFormat != BMF_32BPP) && (ppdev->iBitmapFormat != BMF_16BPP)))
            {
            // Can't do translations with blends
            // Can't hw accelerate anything except 16,32 bpp desktop
            goto EngFallBack;
            }
        }    
    //**************************************************************************
    //  Fixes case where driver is called in full screen DOS during STRESS tests.
    //  In this case, GDI is allowed to call us to update DFBs that are stored in
    //  system memory, or offscreen memory. We need to wrap the surface and call
    //  EngBitBlt.
    //**************************************************************************

    if(!ppdev->bEnabled)
        goto EngFallBack;

#endif

    //**************************************************************************
    // Trivially reject calls we don't handle. We don't blt between host memory bitmaps.
    //**************************************************************************

    if (!IS_DEV_SURF(psoDst))
        {
        if (psoSrc == NULL)
            goto EngFallBack;
        else if (!IS_DEV_SURF(psoSrc))
            goto EngFallBack;
        }

    //**************************************************************************
    // This is a good place to examine offscreen memory visually for debugging.
    // purposes.  That's because there are difficulties when trying to output
    // DWORD values in the WinDbg debugger to NV hardware registers.
    // Apparently, when using WinDbg, it doesn't output dwords as dwords.
    // It seems to output them as 4 bytes. This can cause problems
    // with NV hardware since NV architecture expects all operations to be done
    // as dwords. As a result, in order to flip the buffer, we need to do it in
    // real 32-bit code, instead of manually in the debugger.
    //
    //
    //**************************************************************************

    //**************************************************************************
    // GDI will never give us a Rop4 with the bits in the high-word set
    // (so that we can check if it's actually a Rop3 via the expression
    // (rop4 >> 8) == (rop4 & 0xff)):
    //**************************************************************************

    ASSERTDD((rop4 >> 16) == 0, "Didn't expect a rop4 with high bits set");

    //**************************************************************************
    // For NV, our primary screen surface is a GDI-Managed bitmap, instead of a
    // DEVICE MANAGED surface.  This allows us to punt any call back to GDI
    // if necessary.  Therefore, pdsurfDst will be NULL when the destination
    // is the SCREEN.  pdsurfDst will be Non-NULL when the destination is a DFB.
    // As a result, we determine if the SURFOBJ is the primary surface by taking
    // a look at the 'pvBits' value.  If pvBits == ppdev->pjScreen, then the
    // surfobj is the primary surface.
    //**************************************************************************

    pdsurfDst = (DSURF*) psoDst->dhsurf;    // May be NULL since we created the
                                            // primary surface as a GDI Managed bitmap

    //**************************************************************************
    // Check to see if the dest is a device bitmap which has been moved to main
    // memory
    //**************************************************************************
    if ((pdsurfDst != NULL) && (pdsurfDst->dt == DT_DIB))
        {
        psoDst = pdsurfDst->pso;
        pdsurfDst = (DSURF *) psoDst->dhsurf;
        }

    //**************************************************************************
    // Check if this blit only involves a destination
    //**************************************************************************

    if (psoSrc == NULL)
        {
        //**********************************************************************
        // Since there is no source bitmap, the destination can be either a
        // DIB , DFB (DT_SCREEN), DFB(DT_DIB) or SCREEN surface.  Since we don't
        // handle blits to DIBs or system memory, we'll only handle blits
        // to the primary screen surface (SCREEN), or blits to DFB (DT_SCREEN).
        //
        //  1) DESTINATION = SCREEN
        //
        //        (pdsurfDst    == 0)               &&
        //        (DstBits      == ScreenBitmap)
        //
        //  2) DESTINATION = DFB (DT_SCREEN)
        //
        //        (pdsurfDst     != 0)              &&
        //        (pdsurfDst->dt == DT_SCREEN)      &&
        //        (DstBits       != ScreenBitmap)
        //
        //**********************************************************************

        //**********************************************************************
        // AlphaBlends need a source so assert if we don't have one. -paul
        //**********************************************************************
        ASSERTDD(!pBlendObj ,"AlphaBlend with no source bitmap!");

        //**********************************************************************
        // Fills are this function's "raison d'etre", so we handle them
        // as quickly as possible:
        //**********************************************************************

        //**********************************************************************
        // There will always be a destination so we don't have to check
        // for psoDst == NULL.
        //**********************************************************************

        DstBits         = (ULONG *)(psoDst->pvBits);
        ScreenBitmap    = (ULONG *)(ppdev->pjScreen);

        //**********************************************************************
        // Only handle blits to VRAM.  Send blits to system memory back to GDI.
        //**********************************************************************

        if (  ((pdsurfDst == 0) && (DstBits == ScreenBitmap))   ||
              ((pdsurfDst != 0) && (pdsurfDst->dt == DT_SCREEN))  )
            {
            //******************************************************************
            // Make sure it doesn't involve a mask (i.e., it's really a
            // Rop3):
            //******************************************************************

            rop3 = (BYTE) rop4;

            if ((BYTE) (rop4 >> 8) == rop3)

                {
                //**************************************************************
                // Since 'psoSrc' is NULL, the rop3 had better not indicate
                // that we need a source.
                //
                // Truth table for a Rop 3.           R
                //                                    O
                //                        (SD)        P
                //                  11  10  01  00    3
                //                  --------------
                //          (P) 1  | x   x   x   x    High nibble
                //              0  | x   x   x   x    Low nibble
                //
                //**************************************************************

                ASSERTDD((((rop4 >> 2) ^ (rop4)) & 0x33) == 0,
                             "Need source but GDI gave us a NULL 'psoSrc'");

                //**************************************************************
                // Default to solid fill
                //**************************************************************

                pfnFill = ppdev->pfnFillSolid;

                //**************************************************************
                // This will be a SOLID fill (No Source, No Pattern
                // unless the ROP says a pattern is required).
                // So check if Pattern is needed.  See truth table up above.
                //**************************************************************

                if(pbo == NULL)  // Black and White Rops do not need color
                    rbc.iSolidColor = (ULONG)-1;
                else
                    rbc.iSolidColor = pbo->iSolidColor;

                if ((((rop3 >> 4) ^ (rop3)) & 0xf) != 0)

                    {
                    //**********************************************************
                    // The rop says that a pattern is truly required
                    // (blackness, for instance, doesn't need one):
                    //**********************************************************

                    if (rbc.iSolidColor == -1)

                        {
                        //******************************************************
                        // Try and realize the pattern brush; by doing
                        // this call-back, GDI will eventually call us
                        // again through DrvRealizeBrush:
                        //******************************************************

                        rbc.prb = pbo->pvRbrush;
                        if (rbc.prb == NULL)

                            {
                            rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                            if (rbc.prb == NULL)

                                {
                                //**********************************************
                                // If we couldn't realize the brush, let GDI handle
                                // the call (it may have been a non 8x8
                                // brush or something, which we can't be
                                // bothered to handle, so let GDI do the
                                // drawing):
                                //**********************************************

                                goto EngFallBack;
                                }
                            }

                        //******************************************************
                        // We've now determined that this a Pattern blit.
                        // Pattern will come from the Pattern brush.
                        //******************************************************

                        pfnFill = ppdev->pfnFillPat;

                        }

                    }


                //**************************************************************
                // Linear memory management
                // Set linear offset and stride for destination buffer
                //**************************************************************

                if (pdsurfDst != 0)
                    {
                    DstOffset = (ULONG)((BYTE *)(pdsurfDst->LinearPtr) - ppdev->pjFrameBufbase);
                    DstStride = pdsurfDst->LinearStride;
                    }

                else

                    {
                    //**********************************************************
                    // Use pitch settings of visible screen
                    //**********************************************************

                    DstOffset = ppdev->ulPrimarySurfaceOffset;
                    DstStride = ppdev->lDelta;
                    }

                ppdev->pfnSetDestBase(ppdev, DstOffset , DstStride);


                //**************************************************************
                // Solid and Pattern fills
                //**************************************************************

                //**************************************************************
                // Note that these 2 'if's are more efficient than
                // a switch statement:
                //**************************************************************

                if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))

                    {
                    //**********************************************************
                    // No clipping required
                    //**********************************************************
                    pfnFill(ppdev, 1, prclDst, rop4, rbc, pptlBrush);
                    goto All_Done;
                    }

                else if (pco->iDComplexity == DC_RECT)

                    {
                    //**********************************************************
                    // Clip to a single rectangle
                    //**********************************************************
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                        {
                        pfnFill(ppdev, 1, &rcl, rop4, rbc, pptlBrush);
                        }

                    goto All_Done;
                    }

                else

                    {
                    //**********************************************************
                    // Clip region must be enumerated
                    // For NV, do we need to worry about direction???
                    //**********************************************************
                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                    do  {
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                        c = cIntersect(prclDst, ce.arcl, ce.c);

                        if (c != 0)
                            {
                            pfnFill(ppdev, c, ce.arcl, rop4, rbc, pptlBrush);
                            }

                        } while (bMore);
                    goto All_Done;
                    }

                } // if (BYTE) Rop4 >> 8) ...
                else
                    //*****************************************************
                    // This is a true Rop4, pass this call to GDI.
                    //*****************************************************
                    goto EngFallBack;

            }  // if (destination == VRAM)

        else

            {

            //******************************************************************
            // At this point, we know that there was no source, and that the
            // destination was a standard DIB or a DFB that was moved from
            // offscreen VRAM to system memory.  We won't handle these so just pass
            // them on to EngBitBlt
            //
            // We will also get to this point if the blit involved a MASK.
            //******************************************************************

            goto EngFallBack;
            }

        } // if (psoSrc == NULL)...

    //**************************************************************************
    // Before we handle blits which involve a source and destination,
    // check and see if we can move system memory DFB's back into
    // offscreen VRAM for better performance. That is, at some point, we put a DFB
    // in system memory. Now we determine that if this DFB is getting
    // used a lot, put it back in offscreen VRAM so we can regain performance.
    //
    // We know that at this point, psoSrc and psoDst will not be null.
    //**************************************************************************

    //**************************************************************************
    // Here we know psoSrc != NULL and psoDst should NOT be NULL !
    //**************************************************************************

    ASSERTDD(((VOID *)psoSrc != NULL), "Didn't expect a NULL source");
    ASSERTDD(((VOID *)psoDst != NULL), "Didn't expect a NULL destination");

    pdsurfDst = (DSURF*) psoDst->dhsurf;
    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    if ( (pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_DIB) )

        {
        //**********************************************************************
        // Here we consider putting a DIB DFB back into off-screen
        // memory.  If there's a translate, it's probably not worth
        // moving it since we won't be able to use the hardware to do
        // the blt (a similar argument could be made for weird rops
        // and stuff that we'll only end up having GDI simulate, but
        // those should happen infrequently enough that I don't care).
        //**********************************************************************

        if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)) {
            ASSERTDD(pdsurfSrc->pso->iBitmapFormat == ppdev->iBitmapFormat, "oops");
            //******************************************************************
            // See 'DrvCopyBits' for some more comments on how this
            // moving-it-back-into-off-screen-memory thing works:
            //******************************************************************

            if (pdsurfSrc->iUniq == ppdev->iHeapUniq) {
                //**************************************************************
                // Attempt to move DIB back to offscreen VRAM.
                // This won't necessarily succeed.
                //
                // NOTE: If space doesn't get freed up for a while (heapUniq
                //       remains the same), and this call fails, then cBlt will
                //       wrap around to 0xffffffff, meaning we won't consider
                //       putting this DFB DIB back into offscreen VRAM for a
                //       LONG time, until someone frees up some offscreen memory,
                //       and causes cBlt to be reset to HEAP_COUNT_DOWN.
                //**************************************************************

                if (--pdsurfSrc->cBlt == 0)
                    if (bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfSrc))
                              goto BltDstDevBmp;
            } else {
                
                //**************************************************************
                // Some space was freed up in off-screen memory,
                // so reset the counter for this DFB:
                //**************************************************************
                ASSERTDD(pdsurfSrc->pso->iBitmapFormat == ppdev->iBitmapFormat, "oops");

                pdsurfSrc->iUniq = ppdev->iHeapUniq;
                pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
            }

        }
        
        psoSrc = pdsurfSrc->pso;
        pdsurfSrc = (DSURF *) psoSrc->dhsurf;

    }

BltDstDevBmp:
    //**************************************************************************
    // Get pointers to the Destination and Source 'Bitmaps'
    // We'll use these to determine if the bitmap is ONSCREEN or not.
    //**************************************************************************

    DstBits = (ULONG *)(psoDst->pvBits);
    SrcBits = (ULONG *)(psoSrc->pvBits);
    ScreenBitmap = (ULONG *)(ppdev->pjScreen);

    //**************************************************************************
    // Bitmaps can be one of 4 types, resulting in 16 ways to do blits as follows
    //
    //
    // 1) DIB,  2) DFB (OFFSCREEN),  3) DFB (SYS MEMORY),   4) SCREEN
    //
    //
    //    DIB               to DIB                -> Will not handle - Punt to GDI
    //    DFB (OFFSCREEN)   to DIB                -> Will not handle - Punt to GDI
    //    DFB (SYS MEMORY)  to DIB                -> Will not handle - Punt to GDI
    // SCREEN               to DIB                -> Will not handle - Punt to GDI
    //
    //    DIB               to DFB (OFFSCREEN)    -> Handled
    //    DFB (OFFSCREEN)   to DFB (OFFSCREEN)    -> Handled (rare?)
    //    DFB (SYS MEMORY)  to DFB (OFFSCREEN)    -> Handled (rare?)
    // SCREEN               to DFB (OFFSCREEN)    -> Handled
    //
    //    DIB               to DFB (SYS MEMORY)   -> Will not handle - Punt to GDI
    //    DFB (OFFSCREEN)   to DFB (SYS MEMORY)   -> Will not handle - Punt to GDI ??
    //    DFB (SYS MEMORY)  to DFB (SYS MEMORY)   -> Will not handle - Punt to GDI ??
    // SCREEN               to DFB (SYS MEMORY)   -> Will not handle - Punt to GDI
    //
    //    DIB               to SCREEN             -> Handled
    //    DFB (OFFSCREEN)   to SCREEN             -> Handled
    //    DFB (SYS MEMORY)  to SCREEN             -> Handled
    // SCREEN               to SCREEN             -> Handled
    //
    //
    //      We'll only need to handle the following cases:  (Punt the rest to GDI)
    //      The reason we need to check against ScreenBitmap is that
    //      we've mapped the primary surface using EngCreateBitmap,
    //      so that we can let GDI draw directly to it.  Because of this,
    //      the primary surface is NOT a device managed surface, but rather
    //      a GDI-managed surface.  This means that pdsurf for the
    //      primary surface will be NULL.  So in order to determine
    //      if a surface corresponds to the primary screen surface,
    //      we simply check it's pointer against the ScreenBitmap pointer
    //
    //      Optional:  Since we started with a Dumb Frame Buffer driver using
    //                 EngCreateBitmap (primary surface is GDI-managed, not device
    //                 managed), we check if a standard DIB is the primary surface
    //                 by checking if pvBits == ScreenBitmap.  We can avoid
    //                 this by converting the primary surface to be device managed.
    //                 (EngCreateDeviceSurface). This would result in a more consistent
    //                 driver. (This is the original way it was done in the S3 driver).
    //                 However, we started with a Dumb Frame buffer driver, so
    //                 just leave it for now. It doesn't seem to make that much
    //                 of a difference except for a couple of extra 'if' statements.
    //
    //
    //      We only handle blits where the destination is VRAM, as follows:
    //
    //
    //  1) SCREEN to SCREEN             (CopyBlit)
    //
    //        pdsurfSrc == 0 && SrcBits == ScreenBitmap
    //        pdsurfDst == 0 && DstBits == ScreenBitmap
    //
    //  2) DFB (SYS MEMORY) to SCREEN   (Memory to Screen)
    //
    //        pdsurfSrc != 0 && pdsurfSrc->dt == DT_DIB     && SrcBits != ScreenBitmap;
    //        pdsurfDst == 0 && DstBits == ScreenBitmap
    //
    //  3) DFB (OFFSCREEN) to SCREEN    (CopyBlit)
    //
    //        pdsurfSrc != 0 && pdsurfSrc->dt == DT_SCREEN  &&  SrcBits != ScreenBitmap
    //        pdsurfDst == 0 && DstBits == ScreenBitmap
    //
    //  4) DIB to SCREEN                (Memory to Screen)
    //
    //        pdsurfSrc == 0 && SrcBits != ScreenBitmap;
    //        pdsurfDst == 0 && DstBits == ScreenBitmap
    //
    //  5) SCREEN to DFB (OFFSCREEN)    (CopyBlit)
    //
    //        pdsurfSrc == 0 && SrcBits == ScreenBitmap
    //        pdsurfDst != 0 && pdsurfDst->dt == DT_SCREEN  && DstBits != ScreenBitmap
    //
    //  6) DFB (SYS MEMORY) to DFB (OFFSCREEN)   (Memory to Screen)
    //
    //        pdsurfSrc != 0 && pdsurfSrc->dt == DT_DIB     && SrcBits != ScreenBitmap
    //        pdsurfDst != 0 && pdsurfDst->dt == DT_SCREEN  && DstBits != ScreenBitmap
    //
    //  7) DFB (OFFSCREEN) to DFB (OFFSCREEN)    (CopyBlit)
    //
    //        pdsurfSrc != 0 && pdsurfSrc->dt == DT_SCREEN  && SrcBits != ScreenBitmap
    //        pdsurfDst != 0 && pdsurfDst->dt == DT_SCREEN  && DstBits != ScreenBitmap
    //
    //  8) DIB to DFB (OFFSCREEN)       (Memory to Screen)
    //
    //        pdsurfSrc == 0 && SrcBits != ScreenBitmap
    //        pdsurfDst != 0 && pdsurfDst->dt == DT_SCREEN  DstBits != ScreenBitmap
    //
    //
    //      If the destination is system memory, then we send it back to GDI
    //
    //**************************************************************************

    //**************************************************************************
    // Determine the clipping type
    //**************************************************************************

    if (pco == NULL)
        jClip = DC_TRIVIAL;             // Don't have to worry about clipping
    else
        jClip = pco->iDComplexity;      // Use the CLIPOBJ-provided clipping


    //**************************************************************************
    // Check if DEST is to VRAM or SYSTEM MEMORY
    //**************************************************************************

    if ((DstBits == ScreenBitmap) ||
        ((pdsurfDst !=NULL) && (pdsurfDst->dt == DT_SCREEN)))

        {

        //**********************************************************************
        // Set linear offset and stride for destination buffer
        //**********************************************************************

        if (pdsurfDst != 0)
            {
            DstOffset = (ULONG)((BYTE *)(pdsurfDst->LinearPtr) - ppdev->pjFrameBufbase);
            DstStride = pdsurfDst->LinearStride;
            }
        else
            {
            DstOffset = ppdev->ulPrimarySurfaceOffset;
            DstStride = ppdev->lDelta;
            }

        //**********************************************************************
        // Check to see if this is an 8BPP VRAM to 8BPP VRAM with translation
        // If so, kick out the bitmap to system memory.
        //**********************************************************************
        
        if (ppdev->iBitmapFormat  == BMF_8BPP &&
            psoSrc->iBitmapFormat == BMF_8BPP &&
            pxlo != NULL                      && 
            (pxlo->flXlate & XO_TABLE)        &&
            pdsurfSrc != NULL                 && 
            (pdsurfSrc->dt == DT_SCREEN))

            {
                //
                // We can not flush the primary screen
                //
                if (psoSrc->iType != STYPE_DEVICE)
                { 
                    DISPDBG((3,"Kick out to system memory"));
                    pohMoveOffscreenDfbToDib(ppdev,pdsurfSrc->poh);
                }
            }

        //**********************************************************************
        // Set pitch and stride of destination buffer
        //**********************************************************************

        ppdev->pfnSetDestBase(ppdev, DstOffset , DstStride);

        //**********************************************************************
        // DEST is VRAM
        // Check if the ROP4 is really a ROP3
        //**********************************************************************


        if (((rop4 >> 8) & 0xff) == (rop4 & 0xff))
            {
            //******************************************************************
            // Since we've already handled the cases where the ROP4 is really
            // a ROP3 and no source is required, we can assert...
            //******************************************************************

            ASSERTDD((psoSrc != NULL) && (pptlSrc != NULL),
                   "Expected no-source case to already have been handled");

            //******************************************************************
            // Since the foreground and background ROPs are the same, we
            // don't have to worry about no stinking masks (it's a simple
            // Rop3).
            //******************************************************************

            rop3 = (BYTE) rop4;     // Make it into a Rop3 (we keep the rop4
                                    //  around in case we decide to punt)

            //******************************************************************
            // Check if a pattern is required
            //******************************************************************

            if ((rop3 >> 4) == (rop3 & 0xf))
                {
                //**************************************************************
                // The ROP3 doesn't require a pattern:
                // Check if the source is from VRAM or SYSTEM MEMORY
                //**************************************************************

                if ((SrcBits == ScreenBitmap)   ||
                    ((pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_SCREEN)))

                    {
#if (_WIN32_WINNT >= 0x0500)
                    if ( ((rop3 == 0xcc) || pBlendObj) && 
                         (ppdev->iBitmapFormat == BMF_32BPP) )
                        {
                        alphaPreserve = COPYBLIT;
                        NV4DmaPushAlphaPreserve(ppdev, TRUE, FALSE); // Start=TRUE, FromCpu=FALSE
                        }
#endif // NT5
                    //**********************************************************
                    // Linear memory management
                    // Set linear offset and stride for source buffer
                    //**********************************************************

                    if (pdsurfSrc != 0)
                        {
                        SrcOffset = (ULONG)((BYTE *)(pdsurfSrc->LinearPtr) - ppdev->pjFrameBufbase);
                        SrcStride = pdsurfSrc->LinearStride;
                        }
                    else
                        {
                        SrcOffset = ppdev->ulPrimarySurfaceOffset;
                        SrcStride = ppdev->lDelta;
                        }

                    ppdev->pfnSetSourceBase(ppdev,SrcOffset,SrcStride);

                    //**********************************************************
                    // DEST is VRAM
                    // SOURCE is VRAM  (on-screen or off-screen)
                    //
                    // SCREEN TO SCREEN blt with no color translate
                    //**********************************************************

                    if ((pxlo == NULL) || (pBlendObj && !pxlo->flXlate) || (pxlo->flXlate & XO_TRIVIAL))
                        {
                        
                        if (jClip == DC_TRIVIAL)

                            {
                            //**************************************************
                            // No clipping required
                            //**************************************************
#if _WIN32_WINNT >= 0x0500
                            if (pBlendObj)
                                {
                                if (!NV4DmaPushCopyAlphaBlt(ppdev, 1, prclDst, rop4, pptlSrc, prclDst, pBlendObj))
                                    {
                                    goto EngFallBack; // Routine returned failure - must punt
                                    }
                                goto All_Done;
                                }
#endif _WIN32_WINNT >= 0x0500

                            ppdev->pfnCopyBlt(ppdev, 1, prclDst, rop4, pptlSrc, prclDst, pBlendObj);
                            goto All_Done;
                            }

                        else if (jClip == DC_RECT)

                            {
                            //**************************************************
                            // Clip to a single rectangle
                            //**************************************************

                            if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                                {
#if _WIN32_WINNT >= 0x0500
                                if (pBlendObj)
                                    {
                                    if (!NV4DmaPushCopyAlphaBlt(ppdev, 1, &rcl, rop4, pptlSrc, prclDst, pBlendObj))
                                        {
                                        goto EngFallBack; // Routine returned failure - must punt
                                        }
                                    goto All_Done;
                                    }
#endif _WIN32_WINNT >= 0x0500
                                ppdev->pfnCopyBlt(ppdev, 1, &rcl, rop4, pptlSrc, prclDst, pBlendObj);
                                }

                            goto All_Done;
                            }

                        else

                            {
                            //**************************************************
                            // Clip region must be enumerated
                            //**************************************************

                            if (pptlSrc->y >= (prclDst->top))
                                {
                                if (pptlSrc->x >= (prclDst->left))
                                    iDir = CD_RIGHTDOWN;
                                else
                                    iDir = CD_LEFTDOWN;
                                }
                            else
                                {
                                if (pptlSrc->x >= (prclDst->left))
                                    iDir = CD_RIGHTUP;
                                else
                                    iDir = CD_LEFTUP;
                                }

                            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                                 iDir, 0);

                            do  {
                                bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                                        (ULONG*) &ce);

                                c = cIntersect(prclDst, ce.arcl, ce.c);

                                if (c != 0)
                                    {
#if _WIN32_WINNT >= 0x0500
                                    if (pBlendObj)
                                        {
                                        if (!NV4DmaPushCopyAlphaBlt(ppdev, c, ce.arcl, rop4, pptlSrc, prclDst, pBlendObj))
                                            {
                                            goto EngFallBack; // Routine returned failure - must punt
                                            }
                                        }
                                        else
                                        {
#endif _WIN32_WINNT >= 0x0500
                                        ppdev->pfnCopyBlt(ppdev, c, ce.arcl, rop4, pptlSrc, prclDst, pBlendObj);
#if _WIN32_WINNT >= 0x0500
                                        }
#endif _WIN32_WINNT >= 0x0500


                                    }

                                } while (bMore);
                             goto All_Done;

                            }

                        } // if (pxlo == NULL)...

                    } // if (psoSrc !=NULL) ....

                else

                    {

                    //**********************************************************
                    // DEST is VRAM
                    // SOURCE is SYSTEM MEMORY
                    //**********************************************************

                    iSrcBitmapFormat = psoSrc->iBitmapFormat;
                    iDstBitmapFormat = ppdev->iBitmapFormat;

                    if (iSrcBitmapFormat == BMF_1BPP)

                        {
                        //******************************************************
                        // Transfer from a 1bpp bitmap
                        //******************************************************
                        pfnXfer = ppdev->pfnXfer1bpp;
                        goto Xfer_It;
                        }

                    else if (((iSrcBitmapFormat == iDstBitmapFormat) ||
                              (pBlendObj && (iDstBitmapFormat == BMF_16BPP) && (iSrcBitmapFormat == BMF_32BPP)) )
                             &&
                             ((pxlo == NULL) || (pBlendObj && !pxlo->flXlate) || (pxlo->flXlate & XO_TRIVIAL)))
                        {

                        //******************************************************
                        // Transfer from bitmap with SAME pixel depth
                        //******************************************************

#if (_WIN32_WINNT >= 0x0500)
                        // effectively an RGB bitmap, so preserve alpha
                        if ( ((rop3 == 0xcc) || pBlendObj) && 
                             (ppdev->iBitmapFormat == BMF_32BPP) )
                            {
                            alphaPreserve = IMAGEFROMCPU;
                            NV4DmaPushAlphaPreserve(ppdev, TRUE, TRUE); // Start=TRUE, FromCpu=TRUE
                            }
#endif // NT5

                        pfnXfer = ppdev->pfnXferNative;
                        goto Xfer_It;

                        }

                    else if ((iSrcBitmapFormat == BMF_4BPP) &&
                             (iDstBitmapFormat == BMF_8BPP))

                        {
                        //******************************************************
                        // Transfer from 4bpp Source Bitmap
                        // to 8bpp Destination Bitmap
                        //******************************************************

                        pfnXfer = ppdev->pfnXfer4bpp;
                        goto Xfer_It;
                        }

                    else if (((iSrcBitmapFormat == BMF_8BPP) ||
                              (iSrcBitmapFormat == BMF_4BPP)) &&
                             ((iDstBitmapFormat == BMF_32BPP) ||
                              (iDstBitmapFormat == BMF_16BPP)) &&
                              (pxlo!=NULL) &&
                              (pxlo->flXlate & XO_TABLE))
                        {

                        //******************************************************
                        // Use hardware Indexed Image to transfer from 4bpp or 8bpp
                        // source bitmap to 16bpp or 32bpp destination bitmap
                        //******************************************************

                        pfnXfer = ppdev->pfnIndexedImage;

                        if (pfnXfer != NULL)
                            goto Xfer_It;
                        }

                    } // DEST is VRAM, SRC is SYSTEM MEMORY

                } // ...if (pattern NOT required)

            else

                {
                //**************************************************************
                // Blit is to VRAM, we have a source bitmap in system memory,
                // AND a pattern is required
                //**************************************************************

                ASSERTDD(!pBlendObj ,"No AlphaBlends with patterns");

                if (  ((pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_DIB)) ||
                       (pdsurfSrc == NULL) && (SrcBits !=ScreenBitmap))
                    {

                    //**********************************************************
                    // Need to check clipping here too !!!  We'll only handle simple clipping for now...
                    //**********************************************************

                    //**********************************************************
                    // If iSolidColor == 0xffffffff and pvRbrush == NULL, that means
                    // the brush has not yet been realized.  This is our cue to call
                    // BRUSHOBJ_pvGetRBrush which will call our DrvRealizeBrush function
                    //**********************************************************

                    rbc.iSolidColor = pbo->iSolidColor;

                    //**********************************************************
                    // Prepare to use solid pattern color
                    //**********************************************************

                    PatternColor = rbc.iSolidColor;

                    if (rbc.iSolidColor == -1)

                        {
                        //******************************************************
                        // Try and realize the pattern brush; by doing
                        // this call-back, GDI will eventually call us
                        // again through DrvRealizeBrush:
                        //******************************************************

                        //******************************************************
                        // TODO:  ... Implement ROP3 Pattern,Source,Destination
                        //            blits for non-solid brushes for better
                        //            performance.  We currently don't support
                        //            Colored Brushes.  We only support
                        //            monochrome brushes right now...
                        //******************************************************

                        goto EngFallBack;

                        //******************************************************
                        // Need to test if this works...
                        //******************************************************

                        rbc.prb = pbo->pvRbrush;
                        if (rbc.prb == NULL)

                            {
                            rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                            if (rbc.prb == NULL)

                                {
                                //**********************************************
                                // If we couldn't realize the brush, punt
                                // the call (it may have been a non 8x8
                                // brush or something, which we can't be
                                // bothered to handle, so let GDI do the
                                // drawing):
                                //**********************************************

                                goto EngFallBack;
                                }
                            }

                        }

                    //**********************************************************
                    // At this point, let's check if it's a monochrome bitmap that's being passed
                    // to us.  If so, we can do it using IMAGE_MONO_FROM_CPU.
                    //**********************************************************

                    iSrcBitmapFormat = psoSrc->iBitmapFormat;
                    if (iSrcBitmapFormat == BMF_1BPP)

                        {
                        //******************************************************
                        // Transfer from a 1bpp bitmap
                        //******************************************************

                        pfnXfer = ppdev->pfnXfer1bpp;
                        goto Xfer_It;
                        }

                    //**********************************************************
                    // Be careful!  When swithing modes with the display applet,
                    // GDI will NOT update the SrcBitmap formats to agree with the
                    // new resolution.  If you started NT at 16bpp, the source bitmap format
                    // will be 16bpp.  But if you mode switch to 8bpp, the source bitmap
                    // format will remain at 16bpp. Beware....performance tests will run
                    // better if you do NOT do mode switches!
                    //**********************************************************

                    if (iSrcBitmapFormat == ppdev->iBitmapFormat)
                        {

                        //******************************************************
                        // DEST is SCREEN
                        // SOURCE is MEMORY
                        // PATTERN is required as well
                        //******************************************************

#if _WIN32_WINNT >= 0x0500
                        if(iSrcBitmapFormat == BMF_16BPP)
                        {
                            // On WIN2K Multi-Monitors support,  the GDI passed the
                            // 15BPP format source bitmap to us.  Make additional call
                            // to check whether it is 15BPP format bitmap
                        
                            ULONG   RGBFields[3] = { 0, 1, 2};
                            ULONG   ulXret;
                        
                            ulXret = XLATEOBJ_cGetPalette(pxlo, XO_SRCBITFIELDS, 3, RGBFields);
                            
                            if(ulXret && RGBFields[1] == 0x03E0)
                            {
                                // It is 15BPP format bitmap; our driver only handle 16Bpp bitmap
                                // punt back to GDI.
                                DISPDBG((5, "XLATEOBJ_cGetPalette returned %ld and { %x, %x, %x }",
                                    ulXret, RGBFields[0], RGBFields[1], RGBFields[2]));
                            
                                goto EngFallBack;
                            
                            }
                            
                        }
#endif                        
                        rop3 = (BYTE) rop4;

                        if (jClip == DC_TRIVIAL)
                        {
                            ppdev->pfnMemToScreenPatternBlt(ppdev,
                                                          psoSrc,
                                                          pptlSrc,
                                                          prclDst,
                                                          (ULONG)rop3,
                                                          &rbc,
                                                          NULL);
                        }
                        else if (jClip == DC_RECT)
                        {
                            if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                            {
                                    ppdev->pfnMemToScreenPatternBlt(ppdev,
                                                          psoSrc,
                                                          pptlSrc,
                                                          prclDst,
                                                          (ULONG)rop3,
                                                          &rbc,
                                                          &rcl);
                            }
                        }
                        else
                        {
                                //**********************************************************************
                                // Clip region must be enumerated
                                //**********************************************************************

                                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                                do  {
                                    bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                        (ULONG*) &ce);

                                    c = cIntersect(prclDst, ce.arcl, ce.c);

                                    if (c != 0)
                                    {
                                        ppdev->pfnMemToScreenPatternBlt(ppdev,
                                                          psoSrc,
                                                          pptlSrc,
                                                          prclDst,
                                                          (ULONG)rop3,
                                                          &rbc,
                                                          ce.arcl);
                                    }
                                } while (bMore);
                        }

                        goto All_Done;
                        }

                    } // Make sure source is from system memory
                 
                

                else  // else (Source is from VRAM)    ( dest is to vram and we need a pattern )
                    {
                        // VRAM->VRAM + PATTERN BLITS

                        // Check if brush is needed ( StoS + Non-Solid Pat. )
    
                        if (pbo->iSolidColor == 0xFFFFFFFF )
                        {
                            //******************************************************
                            // Realize the pattern brush if it's ptr is NULL
                            //******************************************************
    
                            if (pbo->pvRbrush == NULL)
                            {
                                pbo->pvRbrush = BRUSHOBJ_pvGetRbrush(pbo);
                                if (pbo->pvRbrush == NULL)
                                {
                                    //**********************************************
                                    // If we couldn't realize the brush, let GDI handle
                                    // the call (it may have been a non 8x8
                                    // brush or something, which we can't be
                                    // bothered to handle, so let GDI do the
                                    // drawing):
                                    //**********************************************
                                    goto EngFallBack;
                                }
                            }
                        }
                        
                        //**********************************************************************
                        // Linear memory management
                        // Set linear offset and stride for source buffer
                        //**********************************************************************
            
                        if (pdsurfSrc != 0)
                            {
                            SrcOffset = (ULONG)( (BYTE *)(pdsurfSrc->LinearPtr) - ppdev->pjFrameBufbase);
                            SrcStride = pdsurfSrc->LinearStride;
                            }
                        else           
                            {
                            SrcOffset = ppdev->ulPrimarySurfaceOffset;
                            SrcStride = ppdev->lDelta;
                            }
            
                        (ppdev->pfnSetSourceBase)(ppdev,SrcOffset,SrcStride);
            
                        // pfnSetDestBase was already called at that point
            
                        if( 
                            (ppdev->pfnScreenToScreenWithPatBlt != NULL )             &&  // function exist
                            ( (pxlo==NULL) || (pxlo->flXlate & XO_TRIVIAL) )          &&  // no translation
                            ( jClip == DC_TRIVIAL )                                       // trivial clipping
                            
                          ) 
                        {
            
                            (ppdev->pfnScreenToScreenWithPatBlt)(      ppdev, 
                                                                           1, 
                                                                     prclDst, 
                                                                     pptlSrc, 
                                                                     prclDst,
                                                                         pbo,
                                                                   pptlBrush,
                                                                        rop4  );
            
                            goto All_Done;
            
            
                        }
                    
                    } // ...else (Source is from VRAM)    ( dest is to vram and we need a pattern )

                } // ...else( pattern IS required)

            } // ...if (not a Rop4)

        } // ...if (DstBits == ScreenBitmap)

    else

        {

        //**********************************************************************
        // DEST is SYSTEM MEMORY
        //**********************************************************************

        //**********************************************************************
        // Can't support AlphaBlend to system memory
        // Only supported on Win2k
        //**********************************************************************

#if _WIN32_WINNT >= 0x0500
        
        if (pBlendObj)
            {
            goto EngFallBack;
            }

#endif //_WIN32_WINNT >= 0x0500
         
            

            if ((SrcBits == ScreenBitmap) ||
                ((pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_SCREEN)))
            {
                //******************************************************************
                // DEST is SYSTEM MEMORY
                // SOURCE is VRAM
                //******************************************************************
                
                // Check to see if we have trivial clipping and source copy rop...
                //
                
                if (
                     ( jClip == DC_TRIVIAL )                               &&
                     ( ( (rop4 >> 8) & 0xff  ) == (rop4 & 0xff) )          &&
                     ( (rop4 & 0xff) == 0xcc   )                                
                   )
                {
    
                    //******************************************************************
                    // Check if this is a color to monochrome bitmap conversion
                    //******************************************************************
        
                    if ( (psoDst->iBitmapFormat == BMF_1BPP)                    &&
                         (ppdev->iBitmapFormat != BMF_24BPP)                    &&
                         ( (pxlo!=NULL) && (pxlo->flXlate & XO_TO_MONO)  )
                       )
                    {
                       //**************************************************************
                       // ScreenTo1Bpp will return TRUE is successful.
                       // Otherwise, the call will be punted (this probably means
                       // the temporary buffer wasn't large enough to handle the blit)
                       //**************************************************************
        
                       if (ppdev->pfnScreenTo1BppMemBlt != NULL)
                       {
                           if ( (ppdev->pfnScreenTo1BppMemBlt)(ppdev, 1, prclDst, psoSrc, psoDst, pptlSrc, prclDst, pxlo ) == TRUE)
                               goto All_Done;
                       }
                       
                    } //... if ScreenTo1Bpp (Screen->SysMem)
    
                    //
                    // Else check to see if formats are equal...
                    //
                    else if(
                               ( psoDst->iBitmapFormat == ppdev->iBitmapFormat )     && // if
                               ( (pxlo==NULL) || (pxlo->flXlate & XO_TRIVIAL) )         // no translation
                           )
                    {
                        // Formats are equal, we don't need to do any xlate,
                        // so use the general ScreenToMemBlt
    
                        if (ppdev->pfnScreenToMemBlt != NULL )
                        {
                    
                           if ( (ppdev->pfnScreenToMemBlt)(   ppdev, 
                                                                  1, 
                                                            prclDst, 
                                                             psoSrc, 
                                                             psoDst, 
                                                            pptlSrc, 
                                                            prclDst, 
                                                               pxlo  ) == TRUE )
                               goto All_Done;
                        }
                    }
                    
                    else // else color translation is needed.
                    {
    
                        // Formats are not equal, handle 32,16 -> 4 or 8 bpp blits
                        // 
                        switch(ppdev->cjPelSize)  // All the frame buffer is the same format at this time so
                        {                         // we use cjPelSize in ppdev to see what's the dest format
                        case 4: 
                            switch(psoDst->iBitmapFormat)
                            {
                            case BMF_4BPP:
                                pfnStoM = ppdev->pfnScreenToMem32to4bppBlt;
                                break;
                      
                            case BMF_8BPP:
                                pfnStoM = ppdev->pfnScreenToMem32to8bppBlt;
                                break;
                      
                            default:
                                goto EngFallBack;
                            }
                      
                            break; // if SRC == 32 bit/pixel
                      
                        case 2:
                      
                            //goto EngFallBack; // UNTESTED !! (the code is there tough)
                      
                            switch(psoDst->iBitmapFormat)
                            {
                            case BMF_4BPP:
                      
                                pfnStoM = ppdev->pfnScreenToMem16to4bppBlt;
                                break;
                      
                            case BMF_8BPP:
                      
                                pfnStoM = ppdev->pfnScreenToMem16to8bppBlt;
                                break;
                      
                            default:
                                goto EngFallBack;
                            }
                      
                            break; // if SRC == 16 bit/pixel
                      
                        default:

                            // Source is indexed, don't need the fancy nonindexed to indexed
                            // color translate blit routines.  Translation is more
                            // simple in that case, and we could do 2 other ScreenToMem*to*
                            // (just need a slight modification in the core macros of CpuXfers,
                            //  see nv4bltc.c)  This is not added because "who sets their UI
                            // in 8bpp anyway ? "
                        case 1:
                            goto EngFallBack;
                        
                        } // ...swith( ppdev->cjPelSize ) ( type of source)
                        
                        //
                        // Now that the proper function is chosen, do the blt
                        //
                        
                        if (pfnStoM != NULL )
                        {
                    
                           if ( (pfnStoM)(   ppdev, 
                                                 1, 
                                           prclDst, 
                                            psoSrc, 
                                            psoDst, 
                                           pptlSrc, 
                                           prclDst, 
                                              pxlo  ) == TRUE )
                               goto All_Done;
                        }
                      
    
                    } // ...else color translation is needed.
                
                } // ...if (without clipping and with source copy rop)  (in ScreenToMem)
                             
                
            } // ...if (Src is screen)  (Dest is system mem)

        else
            {
            //******************************************************************
            // DEST is SYSTEM MEMORY
            // SOURCE is SYSTEM MEMORY
            //******************************************************************

            }


        }


    //**************************************************************************
    // Let GDI handle all other blits for now....
    //
    // Destination = System Memory
    // True ROP 4's com here (masks required)
    //**************************************************************************

    goto EngFallBack;


    //**************************************************************************
    // Common bitmap transfer
    //**************************************************************************

Xfer_It:


#if _WIN32_WINNT >= 0x0500
    if (pBlendObj &&
        ((pfnXfer != ppdev->pfnXferNative) || !NV4CheckAlphaBlendOK(ppdev)))
        {
        //**************************************************************************
        // Only native xfer routines can handle an alpha blend.  If we get here with 
        // anything but a native xfer we are likely blending between different depths.
        // Call hw specific routine to check if hw capable of blending in current state
        //**************************************************************************

        goto EngFallBack;
        }

#endif _WIN32_WINNT >= 0x0500

    if (jClip == DC_TRIVIAL)

        {
        //**********************************************************************
        // No clipping required
        //**********************************************************************

        pfnXfer(ppdev, 1, prclDst, rop4, psoSrc, pptlSrc, prclDst, pxlo,PatternColor,pBlendObj);

        goto All_Done;
        }

    else if (jClip == DC_RECT)

        {

        //**********************************************************************
        // Clip to a single rectangle
        //**********************************************************************
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
            pfnXfer(ppdev, 1, &rcl, rop4, psoSrc, pptlSrc, prclDst, pxlo,PatternColor,pBlendObj);

        goto All_Done;
        }

    else

        {

        //**********************************************************************
        // Clip region must be enumerated
        //**********************************************************************

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do  {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                    (ULONG*) &ce);

            c = cIntersect(prclDst, ce.arcl, ce.c);

            if (c != 0)
                {
                pfnXfer(ppdev, c, ce.arcl, rop4, psoSrc,
                        pptlSrc, prclDst, pxlo,PatternColor,pBlendObj);
                }

            } while (bMore);
        goto All_Done;
        }



EngFallBack:

    //**************************************************************************
    // GDI only knows how to write to standard DIB surfaces.
    // That means, if the SOURCE or DEST is a DFB, we need to create a standard
    // DIB SurfObj in place of the device managed surface (DFB) object in order
    // to let GDI do the blit.
    //
    // Essentially, there are 4 types of SURFOBJS we'll encounter.
    //
    //      1) System Memory SurfObj (Standard DIB)
    //          We can pass this surfobj to GDI as is.
    //
    //      2) DFB - exists in offscreen VRAM memory
    //          Need to create a standard DIB SurfObj to let GDI draw to this surface
    //
    //      3) DFB - exists in system memory
    //          Need to create a standard DIB surfObj to let GDI draw to this surface
    //
    //      4) Primary Surface VRAM (Standard DIB format)
    //          We can pass this surfobj to GDI as is.
    //
    //          CONDITION                                           SURFOBJ TYPE
    //          ---------                                           ------------
    //
    // (pdsurf != NULL)  &&  (pdsurf->dt == DT_DIB)         --> This is a DFB in system memory
    // (pdsurf != NULL)  &&  (pdsurf->dt == DT_SCREEN)      --> This is a DFB in offscreen VRAM memory
    //
    // (pdsurf == NULL)  &&  (pvBits != ppdev->pjScreen)    --> Standard DIB
    // (pdsurf == NULL)  &&  (pvBits == ppdev->pjScreen)    --> Primary Screen Surface
    //**************************************************************************


    //**************************************************************************
    // Default to Standard DIB, and get handles to surfaces if they exist
    //**************************************************************************

    (VOID *)pdsurfSrc = NULL;
    (VOID *)pdsurfDst = NULL;

    if ((VOID *)psoSrc != NULL)
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    if ((VOID *)psoDst != NULL)
        pdsurfDst = (DSURF*) psoDst->dhsurf;

    //**************************************************************************
    // Default to using the original, un-modified SURFOBJ's that were passed to us.
    //**************************************************************************

    TempSrcSurfObjPtr = psoSrc;
    TempDstSurfObjPtr = psoDst;

    //**************************************************************************
    // Get pointers to the 'wrapper' surfaces that we use to draw to the
    // screen surface if necessary.  These surfaces are locked.
    // (The surfaces that we pass to GDI MUST be locked).
    // See EnableOffscreenHeap for more information.
    //**************************************************************************

    SrcPuntPtr = ppdev->psoPunt;
    DstPuntPtr = ppdev->psoPunt2;

    //**************************************************************************
    // Check if source bitmap is a DFB.  If so, create a temporary surfobj
    // (mapped to the screen) that GDI can read from
    //**************************************************************************

    if (pdsurfSrc !=0 )
        {
        SrcPuntPtr->dhsurf      = 0;                    // Behave like a standard DIB
        if (pdsurfSrc->dt == DT_SCREEN)
            {
            SrcPuntPtr->sizlBitmap  = pdsurfSrc->sizl;
            SrcPuntPtr->cjBits  = pdsurfSrc->LinearStride * pdsurfSrc->sizl.cy;
            SrcPuntPtr->pvBits  = pdsurfSrc->LinearPtr;
            SrcPuntPtr->pvScan0 = pdsurfSrc->LinearPtr;
            SrcPuntPtr->lDelta  = pdsurfSrc->LinearStride;
            SrcPuntPtr->iBitmapFormat = ppdev->iBitmapFormat;
            }
        else
            {
            //**********************************************************************
            // This is a DFB which is stored in main memory as a DIB
            //**********************************************************************
            SrcPuntPtr->sizlBitmap  = pdsurfSrc->pso->sizlBitmap;
            SrcPuntPtr->cjBits      = pdsurfSrc->pso->lDelta * pdsurfSrc->pso->sizlBitmap.cy;
            SrcPuntPtr->pvBits  = pdsurfSrc->pso->pvBits;
            SrcPuntPtr->pvScan0 = pdsurfSrc->pso->pvScan0;
            SrcPuntPtr->lDelta  = pdsurfSrc->pso->lDelta;
            SrcPuntPtr->iBitmapFormat = pdsurfSrc->pso->iBitmapFormat;
            }

        //**********************************************************************
        // Use the 'wrapper' surface, instead of the original DFB surfobj for GDI
        //**********************************************************************

        TempSrcSurfObjPtr       = SrcPuntPtr;
        }


    //**************************************************************************
    // Check if destination bitmap is a DFB.  If so, create a temporary surfobj
    // (mapped to the screen) that GDI can write on
    //**************************************************************************

    if (pdsurfDst !=0 )
        {
        DstPuntPtr->dhsurf      = 0;                    // Behave like a standard DIB
        if (pdsurfDst->dt == DT_SCREEN)
            {
            DstPuntPtr->sizlBitmap  = pdsurfDst->sizl;
            DstPuntPtr->cjBits  = pdsurfDst->LinearStride * pdsurfDst->sizl.cy;
            DstPuntPtr->pvBits  = pdsurfDst->LinearPtr;
            DstPuntPtr->pvScan0 = pdsurfDst->LinearPtr;
            DstPuntPtr->lDelta  = pdsurfDst->LinearStride;
            DstPuntPtr->iBitmapFormat = ppdev->iBitmapFormat;
            }
        else
            {
            //**********************************************************************
            // This is a DFB which is stored in main memory as a DIB
            //**********************************************************************
            DstPuntPtr->sizlBitmap  = pdsurfDst->pso->sizlBitmap;
            DstPuntPtr->cjBits      = pdsurfDst->pso->lDelta * pdsurfDst->pso->sizlBitmap.cy;
            DstPuntPtr->pvBits  = pdsurfDst->pso->pvBits;
            DstPuntPtr->pvScan0 = pdsurfDst->pso->pvScan0;
            DstPuntPtr->lDelta  = pdsurfDst->pso->lDelta;
            DstPuntPtr->iBitmapFormat = pdsurfDst->pso->iBitmapFormat;
            }

        //**********************************************************************
        // Use the 'wrapper' surface, instead of the original DFB surfobj for GDI
        //**********************************************************************

        TempDstSurfObjPtr       = DstPuntPtr;
        }

    ppdev->pfnWaitEngineBusy(ppdev);

    //**********************************************************************
    // Only supported on Win2k
    //**********************************************************************

#if _WIN32_WINNT >= 0x0500
    
    if (pBlendObj) {
        //**********************************************************************
        // This was a call from DrvAlphaBlend so call EngAlphaBlend
        //**********************************************************************
        bRet = ppdev->pfnEngAlphaBlend(TempDstSurfObjPtr, TempSrcSurfObjPtr, pco, pxlo, prclDst,
                                       prclSrc, pBlendObj);
    } else {
        //**********************************************************************
        // This was a call from DrvBitBlt so call EngBitBlt
        //**********************************************************************
        bRet = ppdev->pfnEngBitBlt(TempDstSurfObjPtr, TempSrcSurfObjPtr, psoMsk, pco, pxlo, prclDst,
                                   pptlSrc, pptlMsk, pbo, pptlBrush, rop4);
    }

#else // NT 4.0
    
    //**********************************************************************
    // This was a call from DrvBitBlt so call EngBitBlt
    //**********************************************************************
    bRet = ppdev->pfnEngBitBlt(TempDstSurfObjPtr, TempSrcSurfObjPtr, psoMsk, pco, pxlo, prclDst,
                               pptlSrc, pptlMsk, pbo, pptlBrush, rop4);

#endif //_WIN32_WINNT >= 0x0500



All_Done:

    if (alphaPreserve != NONE)
        {
        NV4DmaPushAlphaPreserve(ppdev, FALSE, alphaPreserve==IMAGEFROMCPU); // Start=FALSE; TRUE if FromCPU
        }

    return(bRet);

    }


#if _WIN32_WINNT >= 0x0500

//******************************************************************************
//
//  Function:   TransparentBitBlt
//
//  Routine Description:
//
//      Simpler version of GenericBitBltAlpha, used only by DrvTransparentBlt
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL TransparentBitBlt(
    SURFOBJ*    psoDst,
    SURFOBJ*    psoSrc,
    CLIPOBJ*    pco,
    XLATEOBJ*   pxlo,
    RECTL*      prclDst,
    RECTL*      prclSrc,
    POINTL*     pptlSrc,
    ULONG       iTransColor,
    ULONG       Reserved,
    PDEV*       ppdev
)

    {
    DSURF*          pdsurfDst;
    DSURF*          pdsurfSrc;
    POINTL          ptlSrc;
    BYTE            jClip;
    BOOL            bMore;
    CLIPENUM        ce;
    LONG            c;
    RECTL           rcl;
    FNXFER*         pfnXfer = ppdev->pfnXferNative;
    ULONG           iDir;
    BOOL            bRet;
    ULONG*          ScreenBitmap;
    ULONG*          DstBits;
    ULONG*          SrcBits;
    
    SURFOBJ*        TempDstSurfObjPtr;
    SURFOBJ*        TempSrcSurfObjPtr;

    ULONG           SrcOffset;
    ULONG           DstOffset;
    ULONG           SrcStride;
    ULONG           DstStride;

    // Assume success
    bRet = TRUE;

    // Trivially reject TransparentBlts we can't do
    if ((pxlo && pxlo->flXlate && !(pxlo->flXlate & XO_TRIVIAL) ) ||
        ((ppdev->iBitmapFormat != BMF_32BPP) && (ppdev->iBitmapFormat != BMF_16BPP)) ||
        (psoSrc == NULL) ||
        (!ppdev->bEnabled))
        {
        // Can't do translations
        // Can't hw accelerate anything except 16,32 bpp desktop
        // Must have a source bitmap
        // ppdev must be enabled (may be disable in Stress test)
        goto EngFallBack;
        }

    // Trivially reject blts to host memory bitmaps.
    if (!IS_DEV_SURF(psoDst))
        {
        goto EngFallBack;
        }
    

    //**************************************************************************
    // For NV, our primary screen surface is a GDI-Managed bitmap, instead of a
    // DEVICE MANAGED surface.  This allows us to punt any call back to GDI
    // if necessary.  Therefore, pdsurfDst will be NULL when the destination
    // is the SCREEN.  pdsurfDst will be Non-NULL when the destination is a DFB.
    // As a result, we determine if the SURFOBJ is the primary surface by taking
    // a look at the 'pvBits' value.  If pvBits == ppdev->pjScreen, then the
    // surfobj is the primary surface.
    //**************************************************************************

    pdsurfDst = (DSURF*) psoDst->dhsurf;    // May be NULL since we created the
                                            // primary surface as a GDI Managed bitmap

    //**************************************************************************
    // Check to see if the dest is a device bitmap which has been moved to main
    // memory
    //**************************************************************************
    if ((pdsurfDst != NULL) && (pdsurfDst->dt == DT_DIB))
        {
        psoDst = pdsurfDst->pso;
        pdsurfDst = (DSURF *) psoDst->dhsurf;
        }

    //**************************************************************************
    // Here we know psoDst should NOT be NULL! (already punted if psoSrc=NULL)
    //**************************************************************************

    ASSERTDD(((VOID *)psoDst != NULL), "Didn't expect a NULL destination");

    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    TRY_MOVE_SRC_TO_OFFSCREEN_MEM(psoSrc, pdsurfSrc, pxlo, ppdev);

    //**************************************************************************
    // Get pointers to the Destination and Source 'Bitmaps'
    // We'll use these to determine if the bitmap is ONSCREEN or not.
    //**************************************************************************

    DstBits = (ULONG *)(psoDst->pvBits);
    SrcBits = (ULONG *)(psoSrc->pvBits);
    ScreenBitmap = (ULONG *)(ppdev->pjScreen);

    //**************************************************************************
    // Determine the clipping type
    //**************************************************************************

    if (pco == NULL)
        jClip = DC_TRIVIAL;             // Don't have to worry about clipping
    else
        jClip = pco->iDComplexity;      // Use the CLIPOBJ-provided clipping

    //**************************************************************************
    // Check if DEST is to VRAM or SYSTEM MEMORY
    //**************************************************************************

    if ((DstBits == ScreenBitmap) ||
        ((pdsurfDst !=NULL) && (pdsurfDst->dt == DT_SCREEN)))
        {
        //**********************************************************************
        // DEST is VRAM
        //**********************************************************************

        // Set linear offset and stride for destination buffer
        if (pdsurfDst != 0)
            {
            DstOffset = (ULONG)((BYTE *)(pdsurfDst->LinearPtr) - ppdev->pjFrameBufbase);
            DstStride = pdsurfDst->LinearStride;
            }
        else
            {
            DstOffset = ppdev->ulPrimarySurfaceOffset;
            DstStride = ppdev->lDelta;
            }

        // Set pitch and stride of destination buffer
        ppdev->pfnSetDestBase(ppdev, DstOffset , DstStride);

        // Check if the source is from VRAM or SYSTEM MEMORY
        if ((SrcBits == ScreenBitmap)   ||
            ((pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_SCREEN)))
            {
            //**********************************************************
            // DEST is VRAM
            // SOURCE is VRAM  (on-screen or off-screen)
            //
            // SCREEN TO SCREEN blt with no color translate
            //**********************************************************

            //**********************************************************
            // Linear memory management
            // Set linear offset and stride for source buffer
            //**********************************************************
    
            if (pdsurfSrc != 0)
                {
                SrcOffset = (ULONG)((BYTE *)(pdsurfSrc->LinearPtr) - ppdev->pjFrameBufbase);
                SrcStride = pdsurfSrc->LinearStride;
                }
            else
                {
                SrcOffset = ppdev->ulPrimarySurfaceOffset;
                SrcStride = ppdev->lDelta;
                }
    
            ppdev->pfnSetSourceBase(ppdev,SrcOffset,SrcStride);
    
    
            NV4DmaPushSetColorKey(ppdev, ppdev->iBitmapFormat, iTransColor);

            if (jClip == DC_TRIVIAL)
                {
                //**************************************************
                // No clipping required
                //**************************************************
                ppdev->pfnCopyBlt(ppdev, 1, prclDst, 0xcccc, pptlSrc, prclDst, NULL);
                
                goto All_Done;
                }
            else if (jClip == DC_RECT)
                {
                //**************************************************
                // Clip to a single rectangle
                //**************************************************

                if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                    {

                    ppdev->pfnCopyBlt(ppdev, 1, &rcl, 0xcccc, pptlSrc, prclDst, NULL);
                    
                    }

                goto All_Done;
                }
            else
                {
                //**************************************************
                // Clip region must be enumerated
                //**************************************************

                if (pptlSrc->y >= (prclDst->top))
                    {
                    if (pptlSrc->x >= (prclDst->left))
                        iDir = CD_RIGHTDOWN;
                    else
                        iDir = CD_LEFTDOWN;
                    }
                else
                    {
                    if (pptlSrc->x >= (prclDst->left))
                        iDir = CD_RIGHTUP;
                    else
                        iDir = CD_LEFTUP;
                    }

                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                     iDir, 0);

                do  {
                    bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                            (ULONG*) &ce);

                    c = cIntersect(prclDst, ce.arcl, ce.c);

                    if (c != 0)
                        {
                        
                        ppdev->pfnCopyBlt(ppdev, c, ce.arcl, 0xcccc, pptlSrc, prclDst, NULL);

                        }

                    } while (bMore);
                 goto All_Done;
                 }
            }
        else
            {
            //**********************************************************
            // DEST is VRAM
            // SOURCE is SYSTEM MEMORY
            //**********************************************************

            // Transfer from bitmap with SAME pixel depth, or 32bpp source w/ 16bpp dest
            if ((psoSrc->iBitmapFormat == ppdev->iBitmapFormat) ||
                (psoSrc->iBitmapFormat == BMF_32BPP) && (ppdev->iBitmapFormat == BMF_16BPP))
                {
                
                pfnXfer = ppdev->pfnXferNative;
                goto Xfer_It;

                }
            } // DEST is VRAM, SRC is SYSTEM MEMORY
        } // ...if (DstBits == ScreenBitmap)

    //**************************************************************************
    // GDI handles all other blits
    //
    // Destination = System Memory
    //**************************************************************************
    goto EngFallBack;

    //**************************************************************************
    // Common bitmap transfer
    //**************************************************************************

Xfer_It:

    NV4DmaPushSetColorKey(ppdev, psoSrc->iBitmapFormat, iTransColor);

    if (jClip == DC_TRIVIAL)
        {
        //**********************************************************************
        // No clipping required
        //**********************************************************************

        pfnXfer(ppdev, 1, prclDst, 0xcccc, psoSrc, pptlSrc, prclDst, pxlo,0,NULL);

        }
    else if (jClip == DC_RECT)
        {
        //**********************************************************************
        // Clip to a single rectangle
        //**********************************************************************
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
            pfnXfer(ppdev, 1, &rcl, 0xcccc, psoSrc, pptlSrc, prclDst, pxlo,0,NULL);
        
        }
    else
        {

        //**********************************************************************
        // Clip region must be enumerated
        //**********************************************************************

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do  {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                    (ULONG*) &ce);

            c = cIntersect(prclDst, ce.arcl, ce.c);

            if (c != 0)
                {
                pfnXfer(ppdev, c, ce.arcl, 0xcccc, psoSrc, pptlSrc, prclDst, pxlo,0,NULL);
                }

            } while (bMore);
        }
    
    goto All_Done;

EngFallBack:

    PrepareSurfacesForPunt(psoSrc,psoDst,(SURFOBJ**)&TempSrcSurfObjPtr,(SURFOBJ**)&TempDstSurfObjPtr,ppdev);

    ppdev->pfnWaitEngineBusy(ppdev);
    bRet = ppdev->pfnEngTransparentBlt(TempDstSurfObjPtr,TempSrcSurfObjPtr,pco,pxlo,prclDst,prclSrc,iTransColor,Reserved); 

All_Done:

    NV4DmaPushSetColorKey(ppdev, 0, 0);
    
    return(bRet);

    }

#endif // _WIN32_WINNT >= 0x0500


//******************************************************************************
//
//  Function:   DrvBitBlt
//
//  Routine Description:
//
//      Implements Bit Block Transfers without alpha blend support -paul.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL DrvBitBlt(
    SURFOBJ*    psoDst,
    SURFOBJ*    psoSrc,
    SURFOBJ*    psoMsk,
    CLIPOBJ*    pco,
    XLATEOBJ*   pxlo,
    RECTL*      prclDst,
    POINTL*     pptlSrc,
    POINTL*     pptlMsk,
    BRUSHOBJ*   pbo,
    POINTL*     pptlBrush,
    ROP4        rop4)
{
    PDEV*           ppdev;
    
    ppdev = (PDEV*) psoDst->dhpdev;
    
    //**************************************************************************
    // ppdev may not be present in the Dst surface object
    // This can happen if the Dst surface object is a standard DIB
    //**************************************************************************

    if (ppdev == NULL || (ppdev->hdevEng != psoDst->hdev)) {

        if (psoSrc != NULL)
            ppdev = (PDEV *)psoSrc->dhpdev;
        if (ppdev == NULL || (ppdev->hdevEng != psoSrc->hdev))
            //******************************************************************
            // This blit call is either screwed up, or we got a
            // memory to memory blit (with no physical device associated).
            // Send the call back to GDI.
            //******************************************************************
                return(EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst,
                                pptlSrc, pptlMsk, pbo, pptlBrush, rop4));

    }

    //************************************************************************** 
    // Need to do smart sync between OpenGL and GDI depending on 
    // clip intersection.
    //**************************************************************************
    if (OglIsEnabled(ppdev)) // fast ogl check
    {
        bOglSyncIfGdiInOglWindowBlt(ppdev,psoDst,psoSrc,pco,prclDst,pptlSrc);        
    }


    return GenericBitBltAlpha(psoDst,
                              psoSrc,
                              psoMsk,
                              pco,
                              pxlo,
                              prclDst,
                              NULL,        // RECTL *prclSrc
                              pptlSrc,
                              pptlMsk,
                              pbo,
                              pptlBrush,
                              rop4,
                              NULL,         // BLENDOBJ *pBlendObj
                              ppdev
                              );

}

#if _WIN32_WINNT >= 0x0500

//******************************************************************************
//
//  Function:   DrvAlphaBlend
//
//  Routine Description:
//
//      Implements Bit Block Transfers with alpha blend support. -paul
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL DrvAlphaBlend(
    SURFOBJ  *psoDst,
    SURFOBJ  *psoSrc,
    CLIPOBJ  *pco,
    XLATEOBJ  *pxlo,
    RECTL  *prclDst,
    RECTL  *prclSrc,
    BLENDOBJ  *pBlendObj) 
{
    PDEV*           ppdev;
    POINTL          ptlSrc;
    LONG            SrcWidth;
    LONG            SrcHeight;


    //**************************************************************************
    // Either the source or the destination should have the physical device
    // associated with it. (We should never get a memory to memory blit)
    // Default to getting the PPDEV from the dst.  Otherwise, get it from source
    //**************************************************************************

    ppdev = (PDEV*) psoDst->dhpdev;
    //**************************************************************************
    // ppdev may not be present in the Dst surface object
    // This can happen if the Dst surface object is a standard DIB
    //**************************************************************************
    if (ppdev == NULL || (ppdev->hdevEng != psoDst->hdev) || (!ppdev->bEnabled)) 
        {

        if (psoSrc != NULL)
            ppdev = (PDEV *)psoSrc->dhpdev;
        if (ppdev == NULL || (ppdev->hdevEng != psoSrc->hdev) || (!ppdev->bEnabled))
            //******************************************************************
            // This blit call is either screwed up, or we got a
            // memory to memory blit (with no physical device associated).
            // Send the call back to GDI.
            //******************************************************************
            {
            return (EngAlphaBlend(psoDst,psoSrc,pco,pxlo,prclDst,prclSrc,pBlendObj)); 
            }
        }

    // NOTE: GDI does not pass the call if no per-pixel alpha and SourceConstantAlpha is 0xFF. 

    // We get called if SourceConstantAlpha == 0x00, but no visual change for this, so return ASAP
    if(!(pBlendObj->BlendFunction.SourceConstantAlpha))
        {
        return TRUE; // nothing to blend.
        }


    //************************************************************************** 
    // Need to do smart sync between OpenGL and GDI depending on 
    // clip intersection.
    //**************************************************************************
    if (OglIsEnabled(ppdev)) // fast ogl check
    {
        bOglSyncIfGdiInOglWindowStretch(ppdev,psoDst,psoSrc,pco,prclDst,prclSrc);        
    }


    //**********************************************************************
    // Source and Dest rects may be different size.
    // If they are a different size, we need to stretch/squash 'em. 
    // Currently we don't support StretchBlt, which would be the function we'd
    // feed into.
    //**********************************************************************
    SrcWidth  = prclSrc->right  - prclSrc->left;
    SrcHeight = prclSrc->bottom - prclSrc->top;

    if ((SrcWidth != prclDst->right - prclDst->left) ||
        (SrcHeight!= prclDst->bottom - prclDst->top))
        {
        // SCALED_IMAGE class will support this, when we switch to it eventually.
        ppdev->pfnWaitEngineBusy(ppdev);
        return (ppdev->pfnEngAlphaBlend(psoDst,psoSrc,pco,pxlo,prclDst,prclSrc,pBlendObj)); 
        }

    //**********************************************************************
    // Create the src point struct based on the source rect
    //**********************************************************************

    ptlSrc.x = prclSrc->left;
    ptlSrc.y = prclSrc->top;

    DISPDBG((4,"DrvAlphablend:x=%d,y=%d,w=%d,h=%d",ptlSrc.x, ptlSrc.y, SrcWidth, SrcHeight));
    return GenericBitBltAlpha(psoDst,
                              psoSrc,
                              NULL,        // SURFOBJ  *psoMsk
                              pco,
                              pxlo,
                              prclDst,
                              prclSrc,
                              &ptlSrc,
                              NULL,        // POINTL   *pptlMsk
                              NULL,        // BRUSHOBJ *pbo
                              NULL,        // POINTL   *pptlBrush
                              0,           // ROP4     rop4
                              pBlendObj,
                              ppdev
                              );

}


//******************************************************************************
//
//  Function:   DrvTransparentBlt
//
//  Routine Description:
//
//      Implements Bit Block Transfers with transparency (color key)
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOL DrvTransparentBlt(
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    CLIPOBJ     *pco,
    XLATEOBJ    *pxlo,
    RECTL       *prclDst,
    RECTL       *prclSrc,
    ULONG       iTransColor,
    ULONG       Reserved) 
{
    PDEV*           ppdev;
    POINTL          ptlSrc;
    LONG            SrcWidth;
    LONG            SrcHeight;

    ppdev = (PDEV*) psoDst->dhpdev;
    
    //**************************************************************************
    // ppdev may not be present in the Dst surface object
    // This can happen if the Dst surface object is a standard DIB
    //**************************************************************************

    if (ppdev == NULL || (ppdev->hdevEng != psoDst->hdev)) {

        if (psoSrc != NULL)
            ppdev = (PDEV *)psoSrc->dhpdev;
        if (ppdev == NULL || (ppdev->hdevEng != psoSrc->hdev))
            //******************************************************************
            // This blit call is either screwed up, or we got a
            // memory to memory blit (with no physical device associated).
            // Send the call back to GDI.
            //******************************************************************
                return(EngTransparentBlt(psoDst, psoSrc, pco, pxlo, prclDst, prclSrc, iTransColor, Reserved));

    }


    //************************************************************************** 
    // Need to do smart sync between OpenGL and GDI depending on 
    // clip intersection.
    //**************************************************************************
    if (OglIsEnabled(ppdev)) // fast ogl check
    {
        bOglSyncIfGdiInOglWindowStretch(ppdev,psoDst,psoSrc,pco,prclDst,prclSrc);        
    }


    //**********************************************************************
    // Source and Dest rects may be different size.
    // If they are a different size, we need to stretch/squash 'em. 
    // Currently we don't support StretchBlt, which would be the function we'd
    // feed into.
    //**********************************************************************
    SrcWidth  = prclSrc->right  - prclSrc->left;
    SrcHeight = prclSrc->bottom - prclSrc->top;

    if ((SrcWidth != prclDst->right - prclDst->left) ||
        (SrcHeight!= prclDst->bottom - prclDst->top))
        {
        // SCALED_IMAGE class will support this, when we switch to it eventually.
        ppdev->pfnWaitEngineBusy(ppdev);
        return (ppdev->pfnEngTransparentBlt(psoDst,psoSrc,pco,pxlo,prclDst,prclSrc,iTransColor,Reserved)); 
        }

    //**********************************************************************
    // Create the src point struct based on the source rect
    //**********************************************************************

    ptlSrc.x = prclSrc->left;
    ptlSrc.y = prclSrc->top;

    DISPDBG((4,"DrvTransparentBlt:x=%d,y=%d,w=%d,h=%d",ptlSrc.x, ptlSrc.y, SrcWidth, SrcHeight));
    
    return TransparentBitBlt(psoDst,
                              psoSrc,
                              pco,
                              pxlo,
                              prclDst,
                              prclSrc,
                              &ptlSrc,
                              iTransColor,
                              Reserved,
                              ppdev
                              );
}

#endif // _WIN32_WINNT >= 0x0500

//******************************************************************************
//
//  Function:   DrvCopyBits
//
//  Routine Description:
//
//      Do fast bitmap copies.
//
//      Note that GDI will (usually) automatically adjust the blt extents to
//      adjust for any rectangular clipping, so we'll rarely see DC_RECT
//      clipping in this routine (and as such, we don't bother special casing
//      it).
//
//      I'm not sure if the performance benefit from this routine is actually
//      worth the increase in code size, since SRCCOPY BitBlts are hardly the
//      most common drawing operation we'll get.  But what the heck.
//
//      On the S3 it's faster to do straight SRCCOPY bitblt's through the
//      memory aperture than to use the data transfer register; as such, this
//      routine is the logical place to put this special case.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//******************************************************************************


BOOL DrvCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)

    {
    BOOL        bMore;
    CLIPENUM    ce;
    LONG        c;
    PDEV*       ppdev;
    DSURF*      pdsurfSrc;
    DSURF*      pdsurfDst;
    RECTL       rcl;
    POINTL      ptlSrc;
    ULONG*      ScreenBitmap;
    ULONG*      DstBits;
    ULONG*      SrcBits;
    FNXFER*     pfnXfer;
    BYTE        jClip;
    ULONG       jXlo;

    ULONG       iDstBitmapFormat;
    ULONG       iSrcBitmapFormat;

    SURFOBJ*    SrcPuntPtr;
    SURFOBJ*    DstPuntPtr;
    SURFOBJ*    TempDstSurfObjPtr;
    SURFOBJ*    TempSrcSurfObjPtr;
    BOOL        bret                = FALSE;

    ULONG       bltHeight;
    ULONG       bltWidth;
    ULONG       bltDelta;
    ULONG       SrcOffset;
    ULONG       DstOffset;
    ULONG       SrcStride;
    ULONG       DstStride;

    BYTE*       SrcOffsetPtr;
    BYTE*       DstOffsetPtr;

    ALPHA_SAVE  alphaPreserve=NONE;

    //**************************************************************************
    //  Src and Dst surfaces better be valid.
    //**************************************************************************

    ASSERTDD(((VOID *)psoSrc != NULL), "Didn't expect a NULL source");
    ASSERTDD(((VOID *)psoDst != NULL), "Didn't expect a NULL destination");

    //**************************************************************************
    // Either the source or the destination should have the physical device
    // associated with it. Default to getting the PPDEV from the dst.
    // Otherwise, get it from source
    //**************************************************************************

    ppdev = (PDEV*) psoDst->dhpdev;

    //**************************************************************************
    // ppdev may not be present in the Dst surface object
    // This can happen if the Dst surface object is a standard DIB
    //**************************************************************************

    if (ppdev == NULL)
        {
        //******************************************************************
        // If the PDEV ptr is still NULL, then just kick it back to DIB engine
        //******************************************************************
        ppdev = (PDEV *)psoSrc->dhpdev;
        if (ppdev == NULL)
            //*******************************************
            // No device managed surfaces in the blit.
            //*******************************************

            return(EngCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc));
        }


    //************************************************************************** 
    // Need to do smart sync between OpenGL and GDI depending on 
    // clip intersection.
    //**************************************************************************
    if (OglIsEnabled(ppdev)) // fast ogl check
    {
        bOglSyncIfGdiInOglWindowBlt(ppdev,psoDst,psoSrc,pco,prclDst,pptlSrc);        
    }


    //**************************************************************************
    // Get ptrs to the drivers private device surface structs.
    //**************************************************************************

    pdsurfDst = (DSURF*) psoDst->dhsurf;
    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    //**************************************************************************
    // Try Signature of ppdev....Only accept PPDEV if it matches our signature
    // (NetMeeting seems to be passing in bogus ppdev values)
    //**************************************************************************

    if (ppdev->NVSignature != NV_SIGNATURE)

        {
        //**********************************************************************
        // The ppdev from the DST did not match...try the ppdev from psosrc
        //**********************************************************************

        ppdev = (PDEV*) psoSrc->dhpdev;

        if (ppdev->NVSignature != NV_SIGNATURE)

            {
            //*******************************************************************
            // We're not able to determine the correct ppdev....just punt
            //*******************************************************************

            goto EngCopyBits_It;
            }

        }

#if _WIN32_WINNT >= 0x0500
    
    //**************************************************************************
    //  Fixes case where driver is called in full screen DOS during STRESS tests.
    //  In this case, GDI is allowed to call us to update DFBs that are stored in
    //  system memory, or offscreen memory. We need to wrap the surface and call
    //  EngBitBlt.
    //**************************************************************************

    if(!ppdev->bEnabled)
        goto EngCopyBits_It;
#endif

    //**************************************************************************
    // Trivially reject calls we don't handle. We don't do color translation or
    // clipping here, nor do we blt between host memory bitmaps.
    //**************************************************************************

    if (pco == NULL)
        jClip = DC_TRIVIAL;
    else
        jClip = pco->iDComplexity;

    if (pxlo == NULL)
        jXlo = XO_TRIVIAL;
    else
        jXlo = pxlo->flXlate;

    //**************************************************************************
    // Check to see if the dest is a device bitmap which has been moved to main
    // memory
    //**************************************************************************

    if ((pdsurfDst != NULL) && (pdsurfDst->dt == DT_DIB))
        {
        psoDst = pdsurfDst->pso;
        if ((pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_DIB))
            {
            //*************************************************************
            // No Device surfaces involved in the blt - check if overlap to
            // avoid GDI bug.
            //*************************************************************
            psoSrc = pdsurfSrc->pso;
            if (pdsurfSrc == pdsurfDst)
                {
                goto CheckDibToDibOverlap;
                }
            }
        goto EngCopyBits_It;     // destination in DIB, no overlap so just punt to GDI
        }

    //**************************************************************************
    // Check and see if we can move system memory DFB's back into
    // offscreen VRAM for better performance. That is, at some point, we put a
    // DFB in system memory. Now we determine that if this DFB is getting
    // used a lot, put it back in offscreen VRAM so we can regain performance.
    //**************************************************************************

    if ( (pdsurfSrc != NULL) && (pdsurfSrc->dt == DT_DIB) )

        {
        //**********************************************************************
        // Here we consider putting a DIB DFB back into off-screen
        // memory. See 'DrvCopyBits' for some more comments on how this
        // moving-it-back-into-off-screen-memory thing works:
        //******************************************************************
        if (pdsurfSrc->iUniq == ppdev->iHeapUniq)

            {
            ASSERTDD(pdsurfSrc->pso->iBitmapFormat == ppdev->iBitmapFormat, "oops");
            //**************************************************************
            // Attempt to move DIB back to offscreen VRAM.
            // This won't necessarily succeed.
            //
            // NOTE: If space doesn't get freed up for a while (heapUniq
            //       remains the same), and this call fails, then cBlt will
            //       wrap around to 0xffffffff, meaning we won't consider
            //       putting this DFB DIB back into offscreen VRAM for a
            //       LONG time, until someone frees up some offscreen memory,
            //       and causes cBlt to be reset to HEAP_COUNT_DOWN.
            //**************************************************************

            if (--pdsurfSrc->cBlt == 0)
                if (bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfSrc))
                    goto DstDevBmp;

            }
        else
            {
            //**************************************************************
            // Some space was freed up in off-screen memory,
            // so reset the counter for this DFB:
            //**************************************************************
            ASSERTDD(pdsurfSrc->pso->iBitmapFormat == ppdev->iBitmapFormat, "oops");

            pdsurfSrc->iUniq = ppdev->iHeapUniq;
            pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
            }
        psoSrc = pdsurfSrc->pso;
        }

    //**************************************************************************
    // Get pointers to the Destination and Source 'Bitmaps'
    // We'll use these to determine if the bitmap is ONSCREEN or not.
    //**************************************************************************
DstDevBmp:
    DstBits = (ULONG *)(psoDst->pvBits);
    SrcBits = (ULONG *)(psoSrc->pvBits);
    ScreenBitmap = (ULONG *)(ppdev->pjScreen);

    //**************************************************************************
    // Bitmaps can be one of 4 types, resulting in 16 ways to do blits as follows
    //
    //
    // 1) DIB,  2) DFB (OFFSCREEN),  3) DFB (SYS MEMORY),   4) SCREEN
    //
    //
    //    DIB               to DIB                -> Will not handle - Punt to GDI
    //    DFB (OFFSCREEN)   to DIB                -> Will not handle - Punt to GDI
    //    DFB (SYS MEMORY)  to DIB                -> Will not handle - Punt to GDI
    // SCREEN               to DIB                -> Will not handle - Punt to GDI
    //
    //    DIB               to DFB (OFFSCREEN)    -> Handled
    //    DFB (OFFSCREEN)   to DFB (OFFSCREEN)    -> Handled (rare?)
    //    DFB (SYS MEMORY)  to DFB (OFFSCREEN)    -> Handled (rare?)
    // SCREEN               to DFB (OFFSCREEN)    -> Handled
    //
    //    DIB               to DFB (SYS MEMORY)   -> Will not handle - Punt to GDI
    //    DFB (OFFSCREEN)   to DFB (SYS MEMORY)   -> Will not handle - Punt to GDI ??
    //    DFB (SYS MEMORY)  to DFB (SYS MEMORY)   -> Will not handle - Punt to GDI ??
    // SCREEN               to DFB (SYS MEMORY)   -> Will not handle - Punt to GDI
    //
    //    DIB               to SCREEN             -> Handled
    //    DFB (OFFSCREEN)   to SCREEN             -> Handled
    //    DFB (SYS MEMORY)  to SCREEN             -> Handled
    // SCREEN               to SCREEN             -> Handled
    //
    //
    //      We'll only need to handle the following cases:  (Punt the rest to GDI)
    //      The reason we need to check against ScreenBitmap is that
    //      we've mapped the primary surface using EngCreateBitmap,
    //      so that we can let GDI draw directly to it.  Because of this,
    //      the primary surface is NOT a device managed surface, but rather
    //      a GDI-managed surface.  This means that pdsurf for the
    //      primary surface will be NULL.  So in order to determine
    //      if a surface corresponds to the primary screen surface,
    //      we simply check it's pointer against the ScreenBitmap pointer
    //
    //      Optional:  Since we started with a Dumb Frame Buffer driver using
    //                 EngCreateBitmap (primary surface is GDI-managed, not device
    //                 managed), we check if a standard DIB is the primary surface
    //                 by checking if pvBits == ScreenBitmap.  We can avoid
    //                 this by converting the primary surface to be device managed.
    //                 (EngCreateDeviceSurface). This would result in a more consistent
    //                 driver. (This is the original way it was done in the S3 driver).
    //                 However, we started with a Dumb Frame buffer driver, so
    //                 just leave it for now. It doesn't seem to make that much
    //                 of a difference except for a couple of extra 'if' statements.
    //
    //
    //      We only handle blits where the destination is VRAM, as follows:
    //
    //
    //  1) SCREEN to SCREEN             (CopyBlit)
    //
    //        pdsurfSrc == 0 && SrcBits == ScreenBitmap
    //        pdsurfDst == 0 && DstBits == ScreenBitmap
    //
    //  2) DFB (SYS MEMORY) to SCREEN   (Memory to Screen)
    //
    //        pdsurfSrc != 0 && pdsurfSrc->dt == DT_DIB     && SrcBits != ScreenBitmap;
    //        pdsurfDst == 0 && DstBits == ScreenBitmap
    //
    //  3) DFB (OFFSCREEN) to SCREEN    (CopyBlit)
    //
    //        pdsurfSrc != 0 && pdsurfSrc->dt == DT_SCREEN  &&  SrcBits != ScreenBitmap
    //        pdsurfDst == 0 && DstBits == ScreenBitmap
    //
    //  4) DIB to SCREEN                (Memory to Screen)
    //
    //        pdsurfSrc == 0 && SrcBits != ScreenBitmap;
    //        pdsurfDst == 0 && DstBits == ScreenBitmap
    //
    //  5) SCREEN to DFB (OFFSCREEN)    (CopyBlit)
    //
    //        pdsurfSrc == 0 && SrcBits == ScreenBitmap
    //        pdsurfDst != 0 && pdsurfDst->dt == DT_SCREEN  && DstBits != ScreenBitmap
    //
    //  6) DFB (SYS MEMORY) to DFB (OFFSCREEN)   (Memory to Screen)
    //
    //        pdsurfSrc != 0 && pdsurfSrc->dt == DT_DIB     && SrcBits != ScreenBitmap
    //        pdsurfDst != 0 && pdsurfDst->dt == DT_SCREEN  && DstBits != ScreenBitmap
    //
    //  7) DFB (OFFSCREEN) to DFB (OFFSCREEN)    (CopyBlit)
    //
    //        pdsurfSrc != 0 && pdsurfSrc->dt == DT_SCREEN  && SrcBits != ScreenBitmap
    //        pdsurfDst != 0 && pdsurfDst->dt == DT_SCREEN  && DstBits != ScreenBitmap
    //
    //  8) DIB to DFB (OFFSCREEN)       (Memory to Screen)
    //
    //        pdsurfSrc == 0 && SrcBits != ScreenBitmap
    //        pdsurfDst != 0 && pdsurfDst->dt == DT_SCREEN  DstBits != ScreenBitmap
    //
    //
    //      If the destination is system memory, then we send it back to GDI
    //
    //**************************************************************************

    //**********************************************************************
    // Check if DEST is the SCREEN or MEMORY
    //**********************************************************************
    if (IS_DEV_SURF(psoDst))

        {
        //******************************************************************
        // DEST is SCREEN
        //******************************************************************

        if (IS_DEV_SURF(psoSrc))
            {
            //**************************************************************
            // DEST is SCREEN
            // SOURCE is SCREEN
            // Handle simple SCREEN to SCREEN blit with ROP=SRCCOPY
            //**************************************************************

            if ((jClip != DC_TRIVIAL) || (jXlo != XO_TRIVIAL))
                goto DrvBlt_It;

            //**************************************************************
            // Linear memory management
            // Set linear offset and stride for source buffer
            //**************************************************************

            if (pdsurfSrc != 0)     // source is offscreen bitmap
                {
                SrcOffset = (ULONG)((BYTE *)(pdsurfSrc->LinearPtr) - ppdev->pjFrameBufbase);
                SrcStride = pdsurfSrc->LinearStride;
                }
            else
                {
                SrcOffset = ppdev->ulPrimarySurfaceOffset;
                SrcStride = ppdev->lDelta;
                }

            (ppdev->pfnSetSourceBase)(ppdev,SrcOffset,SrcStride);

            //**************************************************************
            // Set linear offset and stride for destination buffer
            //**************************************************************

            if (pdsurfDst != 0)     // dest is offscreen bitmap
                {
                DstOffset = (ULONG)((BYTE *)(pdsurfDst->LinearPtr) - ppdev->pjFrameBufbase);
                DstStride = pdsurfDst->LinearStride;
                }
            else
                {
                DstOffset = ppdev->ulPrimarySurfaceOffset;
                DstStride = ppdev->lDelta;
                }

            (ppdev->pfnSetDestBase)(ppdev, DstOffset , DstStride);

            //**************************************************************
            // Do the blit
            //**************************************************************
#if (_WIN32_WINNT >= 0x0500)
            if (ppdev->iBitmapFormat == BMF_32BPP)
                {
                // 32bpp src copy - upper 8 bits may be alpha
                // Preserve alpha since this bitmap may be the source on a future DrvAlphaBlend
                alphaPreserve = COPYBLIT;
                NV4DmaPushAlphaPreserve(ppdev, TRUE, FALSE); // Start=TRUE, FromCpu=TRUE
                }
#endif // NT5
            ppdev->pfnCopyBlt(ppdev, 1, prclDst, 0xcccc, pptlSrc, prclDst, NULL);

            bret = TRUE;
            goto Exit;
            }

        else

            {

            //**************************************************************
            // DEST is SCREEN
            // SOURCE is MEMORY
            // Handle simple MEMORY to SCREEN blit with ROP=SRCCOPY
            //**************************************************************

            //**************************************************************
            // Set linear offset and stride for destination buffers
            //**************************************************************

            if (pdsurfDst != 0)     // dest is offscreen bitmap
                {
                DstOffset = (ULONG)((BYTE *)(pdsurfDst->LinearPtr) - ppdev->pjFrameBufbase);
                DstStride = pdsurfDst->LinearStride;
                }
            else
                {
                DstOffset = ppdev->ulPrimarySurfaceOffset;
                DstStride = ppdev->lDelta;
                }

            (ppdev->pfnSetDestBase)(ppdev, DstOffset , DstStride);

            iSrcBitmapFormat = psoSrc->iBitmapFormat;
            iDstBitmapFormat = ppdev->iBitmapFormat;
            bltHeight = prclDst->bottom - prclDst->top;

            if ((jXlo & XO_TABLE)               &&
                (iSrcBitmapFormat == BMF_8BPP)  &&
                (jClip == DC_TRIVIAL)           &&
                (ppdev->DmaPushEnabled2D)       &&
                (bltHeight == 1))
                {

                if ((iDstBitmapFormat == BMF_32BPP))
                    {
                    ppdev->pfnFastXfer8to32(ppdev, prclDst, psoSrc, pptlSrc, pxlo);
                    bret = TRUE;
                    goto Exit;
                    }

                if ((iDstBitmapFormat == BMF_16BPP))
                    {
                    ppdev->pfnFastXfer8to16(ppdev, prclDst, psoSrc, pptlSrc, pxlo);
                    bret = TRUE;
                    goto Exit;
                    }

                goto DrvBlt_It;
                }

            if (((iSrcBitmapFormat == BMF_8BPP)  ||
                 (iSrcBitmapFormat == BMF_4BPP)) &&
                ((iDstBitmapFormat == BMF_32BPP) ||
                 (iDstBitmapFormat == BMF_16BPP)) &&
                 (jXlo & XO_TABLE))
                {
                //******************************************************
                // For small bitmaps, it is faster to do a manual indexed
                // image transfer.
                //******************************************************

                bltWidth = prclDst->right - prclDst->left;

                //
                // pfnIndexedImage will download 256 dwords palette and the image itself
                // 16x16 in 8bpp = 64 dwords
                // 16x16 in 4bpp = 32 dwords
                // pfnXferXtoYY will xlate in sw and put the xlated data to the pushbuffer
                // We need to count the palette overhead to make a decision
                // suggestion: if ((bltWidth * bltHeight) <= 320)
                if ((bltWidth <= 16) && (bltHeight <= 16))
                    {
                    if (iDstBitmapFormat == BMF_16BPP)
                        {
                        if (iSrcBitmapFormat == BMF_4BPP)
                            pfnXfer = ppdev->pfnXfer4to16bpp;
                        else
                            pfnXfer = ppdev->pfnXfer8to16bpp;
                        }
                    else
                        {
                        if (iSrcBitmapFormat == BMF_4BPP)
                            pfnXfer = ppdev->pfnXfer4to32bpp;
                        else
                            pfnXfer = ppdev->pfnXfer8to32bpp;
                        }
                    }
                else
                    {
                    //******************************************************
                    // Use hardware Indexed Image to transfer from 4bpp or 8bpp
                    // source bitmap to 16bpp or 32bpp destination bitmap
                    //******************************************************

                    pfnXfer = ppdev->pfnIndexedImage;
                    }

                if (pfnXfer == NULL)
                    goto DrvBlt_It;

                if (jClip == DC_TRIVIAL)
                    pfnXfer(ppdev, 1, prclDst, 0xcccc, psoSrc, pptlSrc, prclDst, pxlo, 0, NULL);
                else if (jClip == DC_RECT)
                    {
                    if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                        pfnXfer(ppdev, 1, &rcl, 0xcccc, psoSrc, pptlSrc, prclDst, pxlo, 0, NULL);
                    }
                else
                    {

            //************************************************************
            // Clip region must be enumerated
            //************************************************************

                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                    do  {
                        bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                           (ULONG*) &ce);

                        c = cIntersect(prclDst, ce.arcl, ce.c);

                        if (c != 0)
                            {
                            pfnXfer(ppdev, c, ce.arcl, 0xcccc, psoSrc,
                                    pptlSrc, prclDst, pxlo, 0, NULL);
                            }

                        } while (bMore);
                    }
                }
            //**************************************************************
            // If source format == dest format, do straight mem to screen BLT.
            //**************************************************************

            else
                {
                if ((jClip != DC_TRIVIAL) ||
                    (iSrcBitmapFormat != iDstBitmapFormat) ||
                    (jXlo != XO_TRIVIAL))

                    goto DrvBlt_It;

#if (_WIN32_WINNT >= 0x0500)
                if (iDstBitmapFormat == BMF_32BPP)
                    {
                    // Preserve alpha since this bitmap may be the source on a future DrvAlphaBlend
                    alphaPreserve = IMAGEFROMCPU;
                    NV4DmaPushAlphaPreserve(ppdev, TRUE, TRUE); // Start=TRUE, FromCpu=TRUE
                    }
#endif // NT5

                (ppdev->pfnMemToScreenBlt)(ppdev, psoSrc, pptlSrc, prclDst);
                }

            bret = TRUE;
            goto Exit;

            }

        }

    else

        {

        //******************************************************************
        // DEST is MEMORY
        //******************************************************************

        if (IS_DEV_SURF(psoSrc))
            {
            //**************************************************************
            // DEST is MEMORY
            // SOURCE is SCREEN
            // Handle simple SCREEN to MEMORY blit with ROP=SRCCOPY
            //**************************************************************
            goto DrvBlt_It;
            }

        else
            {
            //**************************************************************
            // DEST is MEMORY
            // SOURCE is MEMORY
            // Should never get here since we trivially rejected this case.
            // But if we do get here, punt.
            //**************************************************************
            goto EngCopyBits_It;
            }

        }

    //**************************************************************************
    // If DrvCopyBits couldn't handle it, just send it to DrvBitBlt.
    // A DrvCopyBits is after all just a simplified DrvBitBlt:
    //**************************************************************************

DrvBlt_It:
    bret = GenericBitBltAlpha(psoDst,
                              psoSrc,
                              NULL,
                              pco,
                              pxlo,
                              prclDst,
                              NULL,        // RECTL *prclSrc
                              pptlSrc,
                              NULL,
                              NULL,
                              NULL,
                              0x0000CCCC,
                              NULL,         // BLENDOBJ *pBlendObj
                              ppdev
                              );
    goto Exit;

EngCopyBits_It:

    //**************************************************************************
    // GDI only knows how to write to standard DIB surfaces.
    // That means, if the SOURCE or DEST is a DFB, we need to create a standard
    // DIB SurfObj in place of the device managed surface (DFB) object in order
    // to let GDI do the blit.
    //
    // Essentially, there are 4 types of SURFOBJS we'll encounter.
    //
    //      1) System Memory SurfObj (Standard DIB)
    //          We can pass this surfobj to GDI as is.
    //
    //      2) DFB - exists in offscreen VRAM memory
    //          Need to create a standard DIB SurfObj to let GDI draw to this surface
    //
    //      3) DFB - exists in system memory
    //          Need to create a standard DIB surfObj to let GDI draw to this surface
    //
    //      4) Primary Surface VRAM (Standard DIB format)
    //          We can pass this surfobj to GDI as is.
    //
    //          CONDITION                                           SURFOBJ TYPE
    //          ---------                                           ------------
    //
    // (pdsurf != NULL)  &&  (pdsurf->dt == DT_DIB)         --> This is a DFB in system memory
    // (pdsurf != NULL)  &&  (pdsurf->dt == DT_SCREEN)      --> This is a DFB in offscreen VRAM memory
    //
    // (pdsurf == NULL)  &&  (pvBits != ppdev->pjScreen)    --> Standard DIB
    // (pdsurf == NULL)  &&  (pvBits == ppdev->pjScreen)    --> Primary Screen Surface
    //**************************************************************************


    //**************************************************************************
    // Default to using the original, un-modified SURFOBJ's that were passed to us.
    //**************************************************************************

    TempSrcSurfObjPtr = psoSrc;
    TempDstSurfObjPtr = psoDst;

    //**************************************************************************
    // Get pointers to the 'wrapper' surfaces that we use to draw to the
    // screen surface if necessary.  These surfaces are locked.
    // (The surfaces that we pass to GDI MUST be locked).
    // See EnableOffscreenHeap for more information.
    //**************************************************************************

    SrcPuntPtr = ppdev->psoPunt;
    DstPuntPtr = ppdev->psoPunt2;

    //**************************************************************************
    // Check if source bitmap is a DFB.  If so, create a temporary surfobj
    // (mapped to the screen) that GDI can read from
    //**************************************************************************

    if (pdsurfSrc !=0 )
        {
        SrcPuntPtr->dhsurf      = 0;                    // Behave like a standard DIB
        if (pdsurfSrc->dt == DT_SCREEN)
            {
            SrcPuntPtr->sizlBitmap  = pdsurfSrc->sizl;
            SrcPuntPtr->cjBits  = pdsurfSrc->LinearStride * pdsurfSrc->sizl.cy;
            SrcPuntPtr->pvBits  = pdsurfSrc->LinearPtr;
            SrcPuntPtr->pvScan0 = pdsurfSrc->LinearPtr;
            SrcPuntPtr->lDelta  = pdsurfSrc->LinearStride;
            SrcPuntPtr->iBitmapFormat = ppdev->iBitmapFormat;
            }
        else
            {
            //**********************************************************************
            // This is a DFB which is stored in main memory as a DIB
            //**********************************************************************
            SrcPuntPtr->sizlBitmap  = pdsurfSrc->pso->sizlBitmap;
            SrcPuntPtr->cjBits      = pdsurfSrc->pso->lDelta * pdsurfSrc->pso->sizlBitmap.cy;
            SrcPuntPtr->pvBits  = pdsurfSrc->pso->pvBits;
            SrcPuntPtr->pvScan0 = pdsurfSrc->pso->pvScan0;
            SrcPuntPtr->lDelta  = pdsurfSrc->pso->lDelta;
            SrcPuntPtr->iBitmapFormat = pdsurfSrc->pso->iBitmapFormat;
            }

        //**********************************************************************
        // Use the 'wrapper' surface, instead of the original DFB surfobj for GDI
        //**********************************************************************

        TempSrcSurfObjPtr       = SrcPuntPtr;
        }


    //**************************************************************************
    // Check if destination bitmap is a DFB.  If so, create a temporary surfobj
    // (mapped to the screen) that GDI can write on
    //**************************************************************************

    if (pdsurfDst !=0 )
        {
        DstPuntPtr->dhsurf      = 0;                    // Behave like a standard DIB
        if (pdsurfDst->dt == DT_SCREEN)
            {
            DstPuntPtr->sizlBitmap  = pdsurfDst->sizl;
            DstPuntPtr->cjBits  = pdsurfDst->LinearStride * pdsurfDst->sizl.cy;
            DstPuntPtr->pvBits  = pdsurfDst->LinearPtr;
            DstPuntPtr->pvScan0 = pdsurfDst->LinearPtr;
            DstPuntPtr->lDelta  = pdsurfDst->LinearStride;
            DstPuntPtr->iBitmapFormat = ppdev->iBitmapFormat;
            }
        else
            {
            //**********************************************************************
            // This is a DFB which is stored in main memory as a DIB
            //**********************************************************************
            DstPuntPtr->sizlBitmap  = pdsurfDst->pso->sizlBitmap;
            DstPuntPtr->cjBits      = pdsurfDst->pso->lDelta * pdsurfDst->pso->sizlBitmap.cy;
            DstPuntPtr->pvBits  = pdsurfDst->pso->pvBits;
            DstPuntPtr->pvScan0 = pdsurfDst->pso->pvScan0;
            DstPuntPtr->lDelta  = pdsurfDst->pso->lDelta;
            DstPuntPtr->iBitmapFormat = pdsurfDst->pso->iBitmapFormat;
            }

        //**********************************************************************
        // Use the 'wrapper' surface, instead of the original DFB surfobj for GDI
        //**********************************************************************

        TempDstSurfObjPtr       = DstPuntPtr;
        }
    
    //**************************************************************************
    // Let GDI do the blit, even our DFB surfobjs!
    //**************************************************************************
    ppdev->pfnWaitEngineBusy(ppdev);
    bret = (ppdev->pfnEngCopyBits(TempDstSurfObjPtr, TempSrcSurfObjPtr, pco, pxlo, prclDst, pptlSrc));
    goto Exit;

    //**************************************************************************
    //
    // There is a bug in GDI that shows up with MapView (a Japanese app). The
    // problem ends up occuring where an offscreen bitmap is punted to system
    // memory. Then the app does a copy from one part of the bitmap to the other.
    // In some cases, there is overlap and the copy to the destination stomps on
    // the source. Working around that problem here.
    //
    // On entry, pdsurfDst = psoDst->dhsurf
    //           pdsurfSrc = psoSrc->dhsurf
    //
    //**************************************************************************

CheckDibToDibOverlap:

    bltDelta = pdsurfDst->pso->lDelta;

    DstOffsetPtr = SrcOffsetPtr = pdsurfSrc->pso->pvScan0;

    SrcOffsetPtr += (((pptlSrc->x) << (ppdev->cjPelSize/2)) + (pptlSrc->y * bltDelta)) ;
    DstOffsetPtr += (((prclDst->left) << (ppdev->cjPelSize/2)) + (prclDst->top * bltDelta)) ;

    //*****************************************************************
    // Check if Src DIB offsetis before Dest DIB. If so, then we might
    // need to copy this DIB from bottom to top to take care of the
    // overlapping case.
    //*****************************************************************

    if ((SrcOffsetPtr < DstOffsetPtr) &&
        (jClip == DC_TRIVIAL) && (jXlo == XO_TRIVIAL))
        {
        ULONG       bltHeight;
        ULONG       bltWidth;
        ULONG       bitmapEnd;

        bltHeight = prclDst->bottom - prclDst->top;
        bltWidth  = (prclDst->right  - prclDst->left) << (ppdev->cjPelSize/2);
        bitmapEnd = ((bltHeight-1)*bltDelta) + bltWidth;

        //*****************************************************************
        // Check if end of Src DIB overlaps start of Dest DIB. If so, then
        // we handle this case since there is a bug in GDI.
        //*****************************************************************

        if ((SrcOffsetPtr+bitmapEnd) > DstOffsetPtr)
            {
            //*****************************************************************
            // Copy from Src DIB to Dest DIB taking care of overlapping
            //*****************************************************************
            SrcOffsetPtr += bitmapEnd;                 // point to end of src bitmap
            DstOffsetPtr += bitmapEnd;                 // point to end of dest bitmap

            CopyDIBBitmaps (pdsurfDst,
                            DstOffsetPtr,
                            SrcOffsetPtr,
                            bltHeight,
                            bltWidth);

            bret = TRUE;
            goto Exit;
            }
        }
    goto EngCopyBits_It;


Exit:

#if (NVARCH >= 0x4)
    // MSchwarzer 10/04/2000 need this extrypoint for fixes in overlaymode
    if(   (bret)                                            // CopyBit was successful
#if _WIN32_WINNT >= 0x0500
        &&(ppdev->bEnabled)                                 // see above
#endif
        &&(ppdev->bOglOverlaySurfacesCreated)               // OverlayMode is enabled
        &&(XO_TRIVIAL == jXlo )                             // no color translation
        &&(psoDst->iBitmapFormat == ppdev->iBitmapFormat)   // Dst has same format than Primary
      )
    {
        // 1st check for primary to mem/offscreen blit
        if(   (STYPE_DEVICE == psoSrc->iType)
            &&(STYPE_DEVICE != psoDst->iType)
            &&(NULL         == pco  )          // no clipping => need to check this for W2K fading !!
           )
        {
            DISPDBG((20, "PM:psoSrc: 0x%x, psoDst: 0x%x, pco: 0x%x",psoSrc,psoDst,pco));                

            // Check for intersection between source and any overlaywindow and
            // copy mainplanefront of these areas into destination bitmap
            if( bCopyIntersectingMainPlaneFrontToPSO( ppdev, psoSrc, psoDst, prclDst, pptlSrc) )
            {
                // remember Destination Bitmap for restauration purposes
                if(!bAddPointerToList( &ppdev->plSavedPopupMenus, (PULONG)psoDst ))
                {
                    if( bRemoveFirstElementFromList( &ppdev->plSavedPopupMenus ) )
                    {
                        if(!bAddPointerToList( &ppdev->plSavedPopupMenus, (PULONG)psoDst ))
                            DISPDBG((0, "too many popup windows at one time to store !"));                
                    }
                }
            }

        }
        // 2nd check if it was a restauration blit ( mem/offsreen to primary )
        else if(   (STYPE_DEVICE == psoDst->iType)
                 &&(bIsPointerInList(&ppdev->plSavedPopupMenus,(PULONG)psoSrc))
               )
        {
            DISPDBG((20, "MP:psoSrc: 0x%x, psoDst: 0x%x, pco: 0x%x",psoSrc,psoDst,pco));                

            // Restore color format before entering the merge blit. The Colorkey blit 
            // needs the right color format set for the primary surface.
            if (alphaPreserve != NONE)
            {
                NV4DmaPushAlphaPreserve(ppdev, FALSE, alphaPreserve!=COPYBLIT); // Start=FALSE; TRUE if FromCPU else FALSE
                alphaPreserve = NONE;
            }

            // we need to to a mergeblit on any parts of OverlayWindows
            // affected by this blit
            if( !bDoMergeBlitOnIntersectingRectangle(ppdev, prclDst) )
                DISPDBG((0, "bDoMergeBlitOnIntersectingRectangle failed "));                
            if(!bRemovePointerFromList( &ppdev->plSavedPopupMenus, (PULONG)psoSrc ))
               DISPDBG((0, "Could not remove popupmenue from psolist! !"));                
        }
    }
#endif// #if (NVARCH >= 0x4)

    if (alphaPreserve != NONE)
        {
        NV4DmaPushAlphaPreserve(ppdev, FALSE, alphaPreserve!=COPYBLIT); // Start=FALSE; TRUE if FromCPU else FALSE
        }


    return bret;
    }


//*****************************************************************************
//
// There is a bug in GDI that shows up with MapView (a Japanese app). The
// problem ends up occuring where an offscreen bitmap is punted to system
// memory. Then the app does a copy from one part of the bitmap to the other.
// In some cases, there is overlap and the copy to the destination stomps on
// the source. The ntoskrnl!movemem routine checks for overlapping one scanline
// at a time, but the calling code does not take care of the bitmaps overlapping
// correctly. This routine copies the bitmap when a source offset is less than
// the destination offset and takes care of the overlapping.
//
// Note: Performance is not an issue with this bug - this code will almost never
//       execute. The only way I can reproduce this is with MapView on NV3 (with
//       4M or less offscreen memory) at 800x600x32 or 1024x768x32.
//*****************************************************************************

VOID CopyDIBBitmaps (
DSURF*      pdsurf,
BYTE*       DstOffset,      // points to end of DIB bitmap
BYTE*       SrcOffset,      // points to end of DIB bitmap
ULONG       bltHeight,
ULONG       bltWidth)

    {

    LONG    i;
    LONG    cjMiddle;
    LONG    culMiddle;
    LONG    cjStartPhase;
    LONG    cjEndPhase;
    LONG    lDelta;

    lDelta    = pdsurf->pso->lDelta;

    //******************************************************************
    // Align the copy according to the DEST.
    //
    // Careful:  Phase is 0 if on a byte 0 boundary.
    //           Phase is 3 if on a byte 1 boundary.
    //           Phase is 2 if on a byte 2 boundary.
    //           Phase is 1 if on a byte 3 boundary.
    //
    // cjStartPhase is the number of bytes we need to output first, before
    // we can start outputting the rest of the bytes.
    //******************************************************************

    // We ignore upper dword since we only care about bottom 2 bits
    cjStartPhase = (ULONG)((ULONG_PTR)DstOffset & 3);

    //******************************************************************
    // Calculate Number of bytes remaing after outputting the 'starting'
    // phase bytes. We'll later calculate the final culMiddle and cjEndPhase
    // from cjMiddle.
    //**************************************************************************

    cjMiddle = bltWidth - cjStartPhase;

    //**************************************************************************
    // The following condition always holds true:
    //
    //      cjStartPhase + (culMiddle * 4) +cjEndPhase  ==  cjScan
    //
    // EXCEPT for the cases where cjMiddle < 0.  So we must special case them.
    // Here, we'll just get rid of the starting phase.  The end result is that
    // for these case, bytes will only be output in the 'cjEndPhase'.
    //
    //**************************************************************************

    if (cjMiddle < 0)
        {
        cjStartPhase = 0;
        cjMiddle     = bltWidth;
        }

    //**************************************************************************
    // Update the number of bytes we need to add to get to the next scanline,
    // after copying 'cjScan' bytes.
    //**************************************************************************

    lDelta -= bltWidth;

    //**************************************************************************
    // EndPhase will be copied in bytes.
    // MiddlePhase will always be copied in DWORDS.
    // See description up above.
    //**************************************************************************

    cjEndPhase = cjMiddle & 3;
    culMiddle  = cjMiddle >> 2;

    //**********************************************************************
    // Align to the destination (implying that the source may be
    // unaligned).
    // Copy scanlines at a time.
    //**********************************************************************

    for (; bltHeight > 0; bltHeight--)

        {
        //******************************************************************
        // Copy Bytes at a time
        //******************************************************************

        for (i = cjStartPhase; i > 0; i--)
            {
            *(--DstOffset) = *(--SrcOffset);
            }

        //******************************************************************
        // Copy Dwords at a time
        //******************************************************************

        for (i = culMiddle; i > 0; i--)
            {
            *(--((ULONG*)DstOffset)) = *(--((ULONG UNALIGNED *)SrcOffset));
            }

        //******************************************************************
        // Copy Bytes at a time
        //******************************************************************

        for (i = cjEndPhase; i > 0; i--)
            {
            *(--DstOffset) = *(--SrcOffset);
            }

        SrcOffset -= lDelta;
        DstOffset -= lDelta;
        }

    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\display\winnt4\displays\nv_disp\debug.c ===
//*****************************Module*Header************************************
//
// Module Name: debug.c
//
// Debug helper routines.
//
// Copyright (c) 1992-1996 Microsoft Corporation
//
//******************************************************************************

/*******************************************************************************
 *                                                                             *
 *   Copyright (C) 1997 NVidia Corporation. All Rights Reserved.               *
 *                                                                             *
 ******************************************************************************/

#include "precomp.h"
#include "driver.h"

#if DBG
    #ifndef _DEBUG_H
    #error debug.c should see debug.h, please include!
    #endif

////////////////////////////////////////////////////////////////////////////
// DEBUGGING INITIALIZATION CODE
//
// When you're bringing up your display for the first time, you can
// recompile with 'DebugLevel' set to 100.  That will cause absolutely
// all DISPDBG messages to be displayed on the kernel debugger (this
// is known as the "PrintF Approach to Debugging" and is about the only
// viable method for debugging driver initialization code).

LONG DebugLevel = 0;            // Set to '100' to debug initialization code
                                //   (the default is '0')

BOOL    g_bNvbreak = FALSE;     // By default, we don't want to assert.

////////////////////////////////////////////////////////////////////////////

LONG gcFifo = 0;                // Number of currently free FIFO entries

BOOL gbCrtcCriticalSection = FALSE;
                                // Have we acquired the CRTC register
                                //   critical section?

#define LARGE_LOOP_COUNT  10000000

////////////////////////////////////////////////////////////////////////////
// Miscellaneous Driver Debug Routines
////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    LONG  DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )
{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
#ifdef _WIN32_WINNT         // NT 4.x
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
        EngDebugPrint("", "\n", ap);
#else
        char buffer[128];

        vsprintf(buffer, DebugMessage, ap);
        OutputDebugStringA(buffer);
        OutputDebugStringA("\n");
#endif                      // NT 4.x
    }

    va_end(ap);

} // DebugPrint()



/******************************Public*Routine******************************\
* VOID vAcquireCrtc()
* VOID vReleaseCrtc()
*
* Debug thunks for grabbing the CRTC register critical section.
*
\**************************************************************************/

VOID vAcquireCrtc(PDEV* ppdev)
{
    EngAcquireSemaphore(ppdev->csCrtc);

    if (gbCrtcCriticalSection)
        RIP("Had already acquired Critical Section");
    gbCrtcCriticalSection = TRUE;
}

VOID vReleaseCrtc(PDEV* ppdev)
{
    if (!gbCrtcCriticalSection)
        RIP("Hadn't yet acquired Critical Section");
    gbCrtcCriticalSection = FALSE;
    EngReleaseSemaphore(ppdev->csCrtc);
}


//*************************************************************************
// szDbg_GetDBG_NAMEINDEX
// 
// Helper function for DBG_NAMEINDEX to retrieve the string matching 
// ulIndex out of array pNameIndex. 
//
// NOTE: debug.h for more information
//*************************************************************************
char *szDbg_GetDBG_NAMEINDEX(
    IN const DBG_NAMEINDEX *pNameIndex, // pointer to array with lEntries members
    IN  